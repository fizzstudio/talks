var H$ = Object.defineProperty;
var G$ = (e, t, r) => t in e ? H$(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Ke = (e, t, r) => G$(e, typeof t != "symbol" ? t + "" : t, r);
window.process = {
  env: {
    NODE_ENV: "production"
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const w1 = globalThis, o6 = w1.ShadowRoot && (w1.ShadyCSS === void 0 || w1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, a6 = Symbol(), fS = /* @__PURE__ */ new WeakMap();
let _P = class {
  constructor(t, r, n) {
    if (this._$cssResult$ = !0, n !== a6) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = r;
  }
  get styleSheet() {
    let t = this.o;
    const r = this.t;
    if (o6 && t === void 0) {
      const n = r !== void 0 && r.length === 1;
      n && (t = fS.get(r)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), n && fS.set(r, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const du = (e) => new _P(typeof e == "string" ? e : e + "", void 0, a6), Te = (e, ...t) => {
  const r = e.length === 1 ? e[0] : t.reduce((n, i, s) => n + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + e[s + 1], e[0]);
  return new _P(r, e, a6);
}, Q$ = (e, t) => {
  if (o6) e.adoptedStyleSheets = t.map((r) => r instanceof CSSStyleSheet ? r : r.styleSheet);
  else for (const r of t) {
    const n = document.createElement("style"), i = w1.litNonce;
    i !== void 0 && n.setAttribute("nonce", i), n.textContent = r.cssText, e.appendChild(n);
  }
}, gS = o6 ? (e) => e : (e) => e instanceof CSSStyleSheet ? ((t) => {
  let r = "";
  for (const n of t.cssRules) r += n.cssText;
  return du(r);
})(e) : e;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: W$, defineProperty: q$, getOwnPropertyDescriptor: Y$, getOwnPropertyNames: K$, getOwnPropertySymbols: Z$, getPrototypeOf: J$ } = Object, yl = globalThis, mS = yl.trustedTypes, X$ = mS ? mS.emptyScript : "", ev = yl.reactiveElementPolyfillSupport, nf = (e, t) => e, sm = { toAttribute(e, t) {
  switch (t) {
    case Boolean:
      e = e ? X$ : null;
      break;
    case Object:
    case Array:
      e = e == null ? e : JSON.stringify(e);
  }
  return e;
}, fromAttribute(e, t) {
  let r = e;
  switch (t) {
    case Boolean:
      r = e !== null;
      break;
    case Number:
      r = e === null ? null : Number(e);
      break;
    case Object:
    case Array:
      try {
        r = JSON.parse(e);
      } catch {
        r = null;
      }
  }
  return r;
} }, l6 = (e, t) => !W$(e, t), yS = { attribute: !0, type: String, converter: sm, reflect: !1, useDefault: !1, hasChanged: l6 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), yl.litPropertyMetadata ?? (yl.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let Oh = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, r = yS) {
    if (r.state && (r.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(t) && ((r = Object.create(r)).wrapped = !0), this.elementProperties.set(t, r), !r.noAccessor) {
      const n = Symbol(), i = this.getPropertyDescriptor(t, n, r);
      i !== void 0 && q$(this.prototype, t, i);
    }
  }
  static getPropertyDescriptor(t, r, n) {
    const { get: i, set: s } = Y$(this.prototype, t) ?? { get() {
      return this[r];
    }, set(o) {
      this[r] = o;
    } };
    return { get: i, set(o) {
      const a = i == null ? void 0 : i.call(this);
      s == null || s.call(this, o), this.requestUpdate(t, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? yS;
  }
  static _$Ei() {
    if (this.hasOwnProperty(nf("elementProperties"))) return;
    const t = J$(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(nf("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(nf("properties"))) {
      const r = this.properties, n = [...K$(r), ...Z$(r)];
      for (const i of n) this.createProperty(i, r[i]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const r = litPropertyMetadata.get(t);
      if (r !== void 0) for (const [n, i] of r) this.elementProperties.set(n, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [r, n] of this.elementProperties) {
      const i = this._$Eu(r, n);
      i !== void 0 && this._$Eh.set(i, r);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const r = [];
    if (Array.isArray(t)) {
      const n = new Set(t.flat(1 / 0).reverse());
      for (const i of n) r.unshift(gS(i));
    } else t !== void 0 && r.push(gS(t));
    return r;
  }
  static _$Eu(t, r) {
    const n = r.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((r) => this.enableUpdating = r), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((r) => r(this));
  }
  addController(t) {
    var r;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((r = t.hostConnected) == null || r.call(t));
  }
  removeController(t) {
    var r;
    (r = this._$EO) == null || r.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), r = this.constructor.elementProperties;
    for (const n of r.keys()) this.hasOwnProperty(n) && (t.set(n, this[n]), delete this[n]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Q$(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((r) => {
      var n;
      return (n = r.hostConnected) == null ? void 0 : n.call(r);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((r) => {
      var n;
      return (n = r.hostDisconnected) == null ? void 0 : n.call(r);
    });
  }
  attributeChangedCallback(t, r, n) {
    this._$AK(t, n);
  }
  _$ET(t, r) {
    var s;
    const n = this.constructor.elementProperties.get(t), i = this.constructor._$Eu(t, n);
    if (i !== void 0 && n.reflect === !0) {
      const o = (((s = n.converter) == null ? void 0 : s.toAttribute) !== void 0 ? n.converter : sm).toAttribute(r, n.type);
      this._$Em = t, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null;
    }
  }
  _$AK(t, r) {
    var s, o;
    const n = this.constructor, i = n._$Eh.get(t);
    if (i !== void 0 && this._$Em !== i) {
      const a = n.getPropertyOptions(i), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((s = a.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? a.converter : sm;
      this._$Em = i, this[i] = l.fromAttribute(r, a.type) ?? ((o = this._$Ej) == null ? void 0 : o.get(i)) ?? null, this._$Em = null;
    }
  }
  requestUpdate(t, r, n) {
    var i;
    if (t !== void 0) {
      const s = this.constructor, o = this[t];
      if (n ?? (n = s.getPropertyOptions(t)), !((n.hasChanged ?? l6)(o, r) || n.useDefault && n.reflect && o === ((i = this._$Ej) == null ? void 0 : i.get(t)) && !this.hasAttribute(s._$Eu(t, n)))) return;
      this.C(t, r, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(t, r, { useDefault: n, reflect: i, wrapped: s }, o) {
    n && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t) && (this._$Ej.set(t, o ?? r ?? this[t]), s !== !0 || o !== void 0) || (this._$AL.has(t) || (this.hasUpdated || n || (r = void 0), this._$AL.set(t, r)), i === !0 && this._$Em !== t && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (r) {
      Promise.reject(r);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep) this[s] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [s, o] of i) {
        const { wrapped: a } = o, l = this[s];
        a !== !0 || this._$AL.has(s) || l === void 0 || this.C(s, void 0, o, l);
      }
    }
    let t = !1;
    const r = this._$AL;
    try {
      t = this.shouldUpdate(r), t ? (this.willUpdate(r), (n = this._$EO) == null || n.forEach((i) => {
        var s;
        return (s = i.hostUpdate) == null ? void 0 : s.call(i);
      }), this.update(r)) : this._$EM();
    } catch (i) {
      throw t = !1, this._$EM(), i;
    }
    t && this._$AE(r);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var r;
    (r = this._$EO) == null || r.forEach((n) => {
      var i;
      return (i = n.hostUpdated) == null ? void 0 : i.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((r) => this._$ET(r, this[r]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
Oh.elementStyles = [], Oh.shadowRootOptions = { mode: "open" }, Oh[nf("elementProperties")] = /* @__PURE__ */ new Map(), Oh[nf("finalized")] = /* @__PURE__ */ new Map(), ev == null || ev({ ReactiveElement: Oh }), (yl.reactiveElementVersions ?? (yl.reactiveElementVersions = [])).push("2.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const sf = globalThis, om = sf.trustedTypes, bS = om ? om.createPolicy("lit-html", { createHTML: (e) => e }) : void 0, kP = "$lit$", ol = `lit$${Math.random().toFixed(9).slice(2)}$`, CP = "?" + ol, tz = `<${CP}>`, fu = document, Af = () => fu.createComment(""), Sf = (e) => e === null || typeof e != "object" && typeof e != "function", c6 = Array.isArray, ez = (e) => c6(e) || typeof (e == null ? void 0 : e[Symbol.iterator]) == "function", rv = `[ 	
\f\r]`, Td = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, vS = /-->/g, wS = />/g, Dc = RegExp(`>|${rv}(?:([^\\s"'>=/]+)(${rv}*=${rv}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), xS = /'/g, ES = /"/g, IP = /^(?:script|style|textarea|title)$/i, PP = (e) => (t, ...r) => ({ _$litType$: e, strings: t, values: r }), Ht = PP(1), Ie = PP(2), la = Symbol.for("lit-noChange"), Lt = Symbol.for("lit-nothing"), AS = /* @__PURE__ */ new WeakMap(), Jc = fu.createTreeWalker(fu, 129);
function RP(e, t) {
  if (!c6(e) || !e.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return bS !== void 0 ? bS.createHTML(t) : t;
}
const rz = (e, t) => {
  const r = e.length - 1, n = [];
  let i, s = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", o = Td;
  for (let a = 0; a < r; a++) {
    const l = e[a];
    let c, h, u = -1, p = 0;
    for (; p < l.length && (o.lastIndex = p, h = o.exec(l), h !== null); ) p = o.lastIndex, o === Td ? h[1] === "!--" ? o = vS : h[1] !== void 0 ? o = wS : h[2] !== void 0 ? (IP.test(h[2]) && (i = RegExp("</" + h[2], "g")), o = Dc) : h[3] !== void 0 && (o = Dc) : o === Dc ? h[0] === ">" ? (o = i ?? Td, u = -1) : h[1] === void 0 ? u = -2 : (u = o.lastIndex - h[2].length, c = h[1], o = h[3] === void 0 ? Dc : h[3] === '"' ? ES : xS) : o === ES || o === xS ? o = Dc : o === vS || o === wS ? o = Td : (o = Dc, i = void 0);
    const y = o === Dc && e[a + 1].startsWith("/>") ? " " : "";
    s += o === Td ? l + tz : u >= 0 ? (n.push(c), l.slice(0, u) + kP + l.slice(u) + ol + y) : l + ol + (u === -2 ? a : y);
  }
  return [RP(e, s + (e[r] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
};
let a3 = class TP {
  constructor({ strings: t, _$litType$: r }, n) {
    let i;
    this.parts = [];
    let s = 0, o = 0;
    const a = t.length - 1, l = this.parts, [c, h] = rz(t, r);
    if (this.el = TP.createElement(c, n), Jc.currentNode = this.el.content, r === 2 || r === 3) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (i = Jc.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const u of i.getAttributeNames()) if (u.endsWith(kP)) {
          const p = h[o++], y = i.getAttribute(u).split(ol), g = /([.?@])?(.*)/.exec(p);
          l.push({ type: 1, index: s, name: g[2], strings: y, ctor: g[1] === "." ? iz : g[1] === "?" ? sz : g[1] === "@" ? oz : zy }), i.removeAttribute(u);
        } else u.startsWith(ol) && (l.push({ type: 6, index: s }), i.removeAttribute(u));
        if (IP.test(i.tagName)) {
          const u = i.textContent.split(ol), p = u.length - 1;
          if (p > 0) {
            i.textContent = om ? om.emptyScript : "";
            for (let y = 0; y < p; y++) i.append(u[y], Af()), Jc.nextNode(), l.push({ type: 2, index: ++s });
            i.append(u[p], Af());
          }
        }
      } else if (i.nodeType === 8) if (i.data === CP) l.push({ type: 2, index: s });
      else {
        let u = -1;
        for (; (u = i.data.indexOf(ol, u + 1)) !== -1; ) l.push({ type: 7, index: s }), u += ol.length - 1;
      }
      s++;
    }
  }
  static createElement(t, r) {
    const n = fu.createElement("template");
    return n.innerHTML = t, n;
  }
};
function Yh(e, t, r = e, n) {
  var o, a;
  if (t === la) return t;
  let i = n !== void 0 ? (o = r._$Co) == null ? void 0 : o[n] : r._$Cl;
  const s = Sf(t) ? void 0 : t._$litDirective$;
  return (i == null ? void 0 : i.constructor) !== s && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), s === void 0 ? i = void 0 : (i = new s(e), i._$AT(e, r, n)), n !== void 0 ? (r._$Co ?? (r._$Co = []))[n] = i : r._$Cl = i), i !== void 0 && (t = Yh(e, i._$AS(e, t.values), i, n)), t;
}
let nz = class {
  constructor(t, r) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = r;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: r }, parts: n } = this._$AD, i = ((t == null ? void 0 : t.creationScope) ?? fu).importNode(r, !0);
    Jc.currentNode = i;
    let s = Jc.nextNode(), o = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new u6(s, s.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, t) : l.type === 6 && (c = new az(s, this, t)), this._$AV.push(c), l = n[++a];
      }
      o !== (l == null ? void 0 : l.index) && (s = Jc.nextNode(), o++);
    }
    return Jc.currentNode = fu, i;
  }
  p(t) {
    let r = 0;
    for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, r), r += n.strings.length - 2) : n._$AI(t[r])), r++;
  }
}, u6 = class OP {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, r, n, i) {
    this.type = 2, this._$AH = Lt, this._$AN = void 0, this._$AA = t, this._$AB = r, this._$AM = n, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const r = this._$AM;
    return r !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = r.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, r = this) {
    t = Yh(this, t, r), Sf(t) ? t === Lt || t == null || t === "" ? (this._$AH !== Lt && this._$AR(), this._$AH = Lt) : t !== this._$AH && t !== la && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : ez(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== Lt && Sf(this._$AH) ? this._$AA.nextSibling.data = t : this.T(fu.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var s;
    const { values: r, _$litType$: n } = t, i = typeof n == "number" ? this._$AC(t) : (n.el === void 0 && (n.el = a3.createElement(RP(n.h, n.h[0]), this.options)), n);
    if (((s = this._$AH) == null ? void 0 : s._$AD) === i) this._$AH.p(r);
    else {
      const o = new nz(i, this), a = o.u(this.options);
      o.p(r), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let r = AS.get(t.strings);
    return r === void 0 && AS.set(t.strings, r = new a3(t)), r;
  }
  k(t) {
    c6(this._$AH) || (this._$AH = [], this._$AR());
    const r = this._$AH;
    let n, i = 0;
    for (const s of t) i === r.length ? r.push(n = new OP(this.O(Af()), this.O(Af()), this, this.options)) : n = r[i], n._$AI(s), i++;
    i < r.length && (this._$AR(n && n._$AB.nextSibling, i), r.length = i);
  }
  _$AR(t = this._$AA.nextSibling, r) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, r); t && t !== this._$AB; ) {
      const i = t.nextSibling;
      t.remove(), t = i;
    }
  }
  setConnected(t) {
    var r;
    this._$AM === void 0 && (this._$Cv = t, (r = this._$AP) == null || r.call(this, t));
  }
}, zy = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, r, n, i, s) {
    this.type = 1, this._$AH = Lt, this._$AN = void 0, this.element = t, this.name = r, this._$AM = i, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = Lt;
  }
  _$AI(t, r = this, n, i) {
    const s = this.strings;
    let o = !1;
    if (s === void 0) t = Yh(this, t, r, 0), o = !Sf(t) || t !== this._$AH && t !== la, o && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = s[0], l = 0; l < s.length - 1; l++) c = Yh(this, a[n + l], r, l), c === la && (c = this._$AH[l]), o || (o = !Sf(c) || c !== this._$AH[l]), c === Lt ? t = Lt : t !== Lt && (t += (c ?? "") + s[l + 1]), this._$AH[l] = c;
    }
    o && !i && this.j(t);
  }
  j(t) {
    t === Lt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}, iz = class extends zy {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === Lt ? void 0 : t;
  }
}, sz = class extends zy {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== Lt);
  }
}, oz = class extends zy {
  constructor(t, r, n, i, s) {
    super(t, r, n, i, s), this.type = 5;
  }
  _$AI(t, r = this) {
    if ((t = Yh(this, t, r, 0) ?? Lt) === la) return;
    const n = this._$AH, i = t === Lt && n !== Lt || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, s = t !== Lt && (n === Lt || i);
    i && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var r;
    typeof this._$AH == "function" ? this._$AH.call(((r = this.options) == null ? void 0 : r.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}, az = class {
  constructor(t, r, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = r, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Yh(this, t);
  }
};
const nv = sf.litHtmlPolyfillSupport;
nv == null || nv(a3, u6), (sf.litHtmlVersions ?? (sf.litHtmlVersions = [])).push("3.3.0");
const lz = (e, t, r) => {
  const n = (r == null ? void 0 : r.renderBefore) ?? t;
  let i = n._$litPart$;
  if (i === void 0) {
    const s = (r == null ? void 0 : r.renderBefore) ?? null;
    n._$litPart$ = i = new u6(t.insertBefore(Af(), s), s, void 0, r ?? {});
  }
  return i._$AI(e), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const su = globalThis;
let Ir = class extends Oh {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var r;
    const t = super.createRenderRoot();
    return (r = this.renderOptions).renderBefore ?? (r.renderBefore = t.firstChild), t;
  }
  update(t) {
    const r = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = lz(r, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
  }
  render() {
    return la;
  }
};
var SP;
Ir._$litElement$ = !0, Ir.finalized = !0, (SP = su.litElementHydrateSupport) == null || SP.call(su, { LitElement: Ir });
const iv = su.litElementPolyfillSupport;
iv == null || iv({ LitElement: Ir });
(su.litElementVersions ?? (su.litElementVersions = [])).push("4.2.0");
class SS {
  /**
   * Constructor
   * @param {*} options 
   * @constructor
   */
  constructor(t) {
    this._options = t;
  }
  /**
   * Initializes the module and calls the different methods in order.
   * @private
   * @memberOf module:@fizz/svmjs
   */
  async _init() {
  }
  // data is NxD array of floats. labels are 1 or -1.
  train(t, r, n) {
    this.data = t, this.labels = r, n = n || {};
    const i = n.C || 1, s = n.tol || 1e-4, o = n.alphatol || 1e-7, a = n.maxiter || 1e4, l = n.numpasses || 10;
    let c = sv;
    if (this.kernelType = "linear", "kernel" in n)
      if (typeof n.kernel == "string") {
        if (n.kernel === "linear" && (this.kernelType = "linear", c = sv), n.kernel === "rbf") {
          const g = n.rbfsigma || 0.5;
          this.rbfSigma = g, this.kernelType = "rbf", c = _S(g);
        }
      } else
        this.kernelType = "custom", c = n.kernel;
    this.kernel = c, this.N = t.length;
    const h = this.N;
    if (this.D = t[0].length, this.D, this.alpha = uz(h), this.b = 0, this.usew_ = !1, n.memoize) {
      this.kernelResults = new Array(h);
      for (let g = 0; g < h; g++) {
        this.kernelResults[g] = new Array(h);
        for (let b = 0; b < h; b++)
          this.kernelResults[g][b] = c(t[g], t[b]);
      }
    }
    let u = 0, p = 0;
    for (; p < l && u < a; ) {
      let g = 0;
      for (let b = 0; b < h; b++) {
        const f = this.marginOne(t[b]) - r[b];
        if (r[b] * f < -s && this.alpha[b] < i || r[b] * f > s && this.alpha[b] > 0) {
          let E = b;
          for (; E === b; ) E = cz(0, this.N);
          const A = this.marginOne(t[E]) - r[E];
          let x = this.alpha[b], m = this.alpha[E], w = 0, _ = i;
          if (r[b] === r[E] ? (w = Math.max(0, x + m - i), _ = Math.min(i, x + m)) : (w = Math.max(0, m - x), _ = Math.min(i, i + m - x)), Math.abs(w - _) < 1e-4) continue;
          const S = 2 * this.kernelResult(b, E) - this.kernelResult(b, b) - this.kernelResult(E, E);
          if (S >= 0) continue;
          let R = m - r[E] * (f - A) / S;
          if (R > _ && (R = _), R < w && (R = w), Math.abs(m - R) < 1e-4) continue;
          this.alpha[E] = R;
          const O = x + r[b] * r[E] * (m - R);
          this.alpha[b] = O;
          const $ = this.b - f - r[b] * (O - x) * this.kernelResult(b, b) - r[E] * (R - m) * this.kernelResult(b, E), z = this.b - A - r[b] * (O - x) * this.kernelResult(b, E) - r[E] * (R - m) * this.kernelResult(E, E);
          this.b = 0.5 * ($ + z), O > 0 && O < i && (this.b = $), R > 0 && R < i && (this.b = z), g++;
        }
      }
      u++, g == 0 ? p++ : p = 0;
    }
    if (this.kernelType === "linear") {
      this.w = new Array(this.D);
      for (let g = 0; g < this.D; g++) {
        let b = 0;
        for (let f = 0; f < this.N; f++)
          b += this.alpha[f] * r[f] * t[f][g];
        this.w[g] = b, this.usew_ = !0;
      }
    } else {
      const g = [], b = [], f = [];
      for (let E = 0; E < this.N; E++)
        this.alpha[E] > o && (g.push(this.data[E]), b.push(this.labels[E]), f.push(this.alpha[E]));
      this.data = g, this.labels = b, this.alpha = f, this.N = this.data.length;
    }
    const y = {};
    return y.iters = u, y;
  }
  // inst is an array of length D. Returns margin of given example
  // this is the core prediction function. All others are for convenience mostly
  // and end up calling this one somehow.
  marginOne(t) {
    let r = this.b;
    if (this.usew_)
      for (let n = 0; n < this.D; n++)
        r += t[n] * this.w[n];
    else
      for (let n = 0; n < this.N; n++)
        r += this.alpha[n] * this.labels[n] * this.kernel(t, this.data[n]);
    return r;
  }
  predictOne(t) {
    return this.marginOne(t) > 0 ? 1 : -1;
  }
  // data is an NxD array. Returns array of margins.
  margins(t) {
    const r = t.length, n = new Array(r);
    for (let i = 0; i < r; i++)
      n[i] = this.marginOne(t[i]);
    return n;
  }
  kernelResult(t, r) {
    return this.kernelResults ? this.kernelResults[t][r] : this.kernel(this.data[t], this.data[r]);
  }
  // data is NxD array. Returns array of 1 or -1, predictions
  predict(t) {
    const r = this.margins(t);
    for (let n = 0; n < r.length; n++)
      r[n] = r[n] > 0 ? 1 : -1;
    return r;
  }
  // THIS FUNCTION IS NOW DEPRECATED. WORKS FINE BUT NO NEED TO USE ANYMORE. 
  // LEAVING IT HERE JUST FOR BACKWARDS COMPATIBILITY FOR A WHILE.
  // if we trained a linear svm, it is possible to calculate just the weights and the offset
  // prediction is then yhat = sign(X * w + b)
  getWeights() {
    const t = new Array(this.D);
    for (let r = 0; r < this.D; r++) {
      let n = 0;
      for (let i = 0; i < this.N; i++)
        n += this.alpha[i] * this.labels[i] * this.data[i][r];
      t[r] = n;
    }
    return { w: t, b: this.b };
  }
  toJSON() {
    if (this.kernelType === "custom")
      return console.log("Can't save this SVM because it's using custom, unsupported kernel..."), {};
    const t = {};
    return t.N = this.N, t.D = this.D, t.b = this.b, t.kernelType = this.kernelType, this.kernelType === "linear" && (t.w = this.w), this.kernelType === "rbf" && (t.rbfSigma = this.rbfSigma, t.data = this.data, t.labels = this.labels, t.alpha = this.alpha), t;
  }
  fromJSON(t) {
    this.N = t.N, this.D = t.D, this.b = t.b, this.kernelType = t.kernelType, this.kernelType === "linear" ? (this.w = t.w, this.usew_ = !0, this.kernel = sv) : this.kernelType == "rbf" ? (this.rbfSigma = t.rbfSigma, this.kernel = _S(this.rbfSigma), this.data = t.data, this.labels = t.labels, this.alpha = t.alpha) : console.log("ERROR! unrecognized kernel type." + this.kernelType);
  }
}
function _S(e) {
  return function(t, r) {
    let n = 0;
    for (let i = 0; i < t.length; i++)
      n += (t[i] - r[i]) * (t[i] - r[i]);
    return Math.exp(-n / (2 * e * e));
  };
}
function sv(e, t) {
  let r = 0;
  for (let n = 0; n < e.length; n++)
    r += e[n] * t[n];
  return r;
}
function cz(e, t) {
  return Math.floor(Math.random() * (t - e) + e);
}
function uz(e) {
  const t = new Array(e);
  for (let r = 0; r < e; r++)
    t[r] = 0;
  return t;
}
function h6(e) {
  var t, r, n = e.length;
  if (n === 1)
    t = 0, r = e[0][1];
  else {
    for (var i = 0, s = 0, o = 0, a = 0, l, c, h, u = 0; u < n; u++)
      l = e[u], c = l[0], h = l[1], i += c, s += h, o += c * c, a += c * h;
    t = (n * a - i * s) / (n * o - i * i), r = s / n - t * i / n;
  }
  return {
    m: t,
    b: r
  };
}
function hz(e) {
  return function(t) {
    return e.b + e.m * t;
  };
}
function pz(e) {
  if (e.length === 0)
    return 0;
  var t = e[0], r = 0, n;
  if (typeof t != "number")
    return Number.NaN;
  for (var i = 1; i < e.length; i++) {
    if (typeof e[i] != "number")
      return Number.NaN;
    n = t + e[i], Math.abs(t) >= Math.abs(e[i]) ? r += t - n + e[i] : r += e[i] - n + t, t = n;
  }
  return t + r;
}
function Pl(e) {
  if (e.length === 0)
    throw new Error("mean requires at least one data point");
  return pz(e) / e.length;
}
function dz(e, t) {
  var r = Pl(e), n = 0, i, s;
  for (s = 0; s < e.length; s++)
    i = e[s] - r, n += i * i;
  return n;
}
function fz(e, t) {
  if (e.length < 2)
    return 1;
  for (var r = 0, n = 0; n < e.length; n++)
    r += e[n][1];
  for (var i = r / e.length, s = 0, o = 0; o < e.length; o++)
    s += Math.pow(i - e[o][1], 2);
  for (var a = 0, l = 0; l < e.length; l++)
    a += Math.pow(e[l][1] - t(e[l][0]), 2);
  return 1 - a / s;
}
function gz(e) {
  if (e.length === 0)
    throw new Error("mode requires at least one data point");
  if (e.length === 1)
    return e[0];
  for (var t = e[0], r = Number.NaN, n = 0, i = 1, s = 1; s < e.length + 1; s++)
    e[s] !== t ? (i > n && (n = i, r = t), i = 1, t = e[s]) : i++;
  return r;
}
function mz(e) {
  return e.slice().sort(function(t, r) {
    return t - r;
  });
}
function yz(e) {
  return gz(mz(e));
}
function p6(e) {
  if (e.length === 0)
    throw new Error("min requires at least one data point");
  for (var t = e[0], r = 1; r < e.length; r++)
    e[r] < t && (t = e[r]);
  return t;
}
function d6(e) {
  if (e.length === 0)
    throw new Error("max requires at least one data point");
  for (var t = e[0], r = 1; r < e.length; r++)
    e[r] > t && (t = e[r]);
  return t;
}
function kS(e, t) {
  var r = e.length * t;
  if (e.length === 0)
    throw new Error("quantile requires at least one data point.");
  if (t < 0 || t > 1)
    throw new Error("quantiles must be between 0 and 1");
  return t === 1 ? e[e.length - 1] : t === 0 ? e[0] : r % 1 !== 0 ? e[Math.ceil(r) - 1] : e.length % 2 === 0 ? (e[r - 1] + e[r]) / 2 : e[r];
}
function x1(e, t, r, n) {
  for (r = r || 0, n = n || e.length - 1; n > r; ) {
    if (n - r > 600) {
      var i = n - r + 1, s = t - r + 1, o = Math.log(i), a = 0.5 * Math.exp(2 * o / 3), l = 0.5 * Math.sqrt(o * a * (i - a) / i);
      s - i / 2 < 0 && (l *= -1);
      var c = Math.max(r, Math.floor(t - s * a / i + l)), h = Math.min(
        n,
        Math.floor(t + (i - s) * a / i + l)
      );
      x1(e, t, c, h);
    }
    var u = e[t], p = r, y = n;
    for (Od(e, r, t), e[n] > u && Od(e, r, n); p < y; ) {
      for (Od(e, p, y), p++, y--; e[p] < u; )
        p++;
      for (; e[y] > u; )
        y--;
    }
    e[r] === u ? Od(e, r, y) : (y++, Od(e, y, n)), y <= t && (r = y + 1), t <= y && (n = y - 1);
  }
}
function Od(e, t, r) {
  var n = e[t];
  e[t] = e[r], e[r] = n;
}
function bz(e, t) {
  var r = e.slice();
  if (Array.isArray(t)) {
    vz(r, t);
    for (var n = [], i = 0; i < t.length; i++)
      n[i] = kS(r, t[i]);
    return n;
  } else {
    var s = MP(r.length, t);
    return LP(r, s, 0, r.length - 1), kS(r, t);
  }
}
function LP(e, t, r, n) {
  t % 1 === 0 ? x1(e, t, r, n) : (t = Math.floor(t), x1(e, t, r, n), x1(e, t + 1, t + 1, n));
}
function vz(e, t) {
  for (var r = [0], n = 0; n < t.length; n++)
    r.push(MP(e.length, t[n]));
  r.push(e.length - 1), r.sort(wz);
  for (var i = [0, r.length - 1]; i.length; ) {
    var s = Math.ceil(i.pop()), o = Math.floor(i.pop());
    if (!(s - o <= 1)) {
      var a = Math.floor((o + s) / 2);
      LP(
        e,
        r[a],
        Math.floor(r[o]),
        Math.ceil(r[s])
      ), i.push(o, a, a, s);
    }
  }
}
function wz(e, t) {
  return e - t;
}
function MP(e, t) {
  var r = e * t;
  return t === 1 ? e - 1 : t === 0 ? 0 : r % 1 !== 0 ? Math.ceil(r) - 1 : e % 2 === 0 ? r - 0.5 : r;
}
function xz(e) {
  return +bz(e, 0.5);
}
function Ez(e, t) {
  if (e.length !== t.length)
    throw new Error("sampleCovariance requires samples with equal lengths");
  if (e.length < 2)
    throw new Error(
      "sampleCovariance requires at least two data points in each sample"
    );
  for (var r = Pl(e), n = Pl(t), i = 0, s = 0; s < e.length; s++)
    i += (e[s] - r) * (t[s] - n);
  var o = e.length - 1;
  return i / o;
}
function Az(e) {
  if (e.length < 2)
    throw new Error("sampleVariance requires at least two data points");
  var t = dz(e), r = e.length - 1;
  return t / r;
}
function CS(e) {
  var t = Az(e);
  return Math.sqrt(t);
}
function Sz(e, t) {
  var r = Ez(e, t), n = CS(e), i = CS(t);
  return r / n / i;
}
class _z {
  constructor(t) {
    t && (this.df = t);
  }
  LogGamma(t) {
    const r = 1 + 76.18009173 / t - 86.50532033 / (t + 1) + 24.01409822 / (t + 2) - 1.231739516 / (t + 3) + 0.00120858003 / (t + 4) - 536382e-11 / (t + 5);
    return (t - 0.5) * Math.log(t + 4.5) - (t + 4.5) + Math.log(r * 2.50662827465);
  }
  Betinc(t, r, n) {
    let i = 0, s = 1, o = 1, a = 1, l = 0, c = 0, h;
    for (; Math.abs((o - c) / o) > 1e-5; )
      c = o, h = -(r + l) * (r + n + l) * t / (r + 2 * l) / (r + 2 * l + 1), i = o + h * i, s = a + h * s, l = l + 1, h = l * (n - l) * t / (r + 2 * l - 1) / (r + 2 * l), o = i + h * o, a = s + h * a, i = i / a, s = s / a, o = o / a, a = 1;
    return o / r;
  }
  cumulativeProbability(t, r) {
    r || (r = this.df);
    let n;
    if (r <= 0)
      console.error("Degrees of freedom must be positive");
    else {
      const i = r / 2, s = i + 0.5, o = r / (r + t * t), a = Math.exp(this.LogGamma(s) - this.LogGamma(0.5) - this.LogGamma(i) + i * Math.log(o) + 0.5 * Math.log(1 - o));
      let l;
      o < (i + 1) / (s + 2) ? l = a * this.Betinc(o, i, 0.5) : l = 1 - a * this.Betinc(1 - o, 0.5, i), t < 0 ? n = l / 2 : n = 1 - l / 2;
    }
    return n = Math.round(n * 1e5) / 1e5, n;
  }
  invCumulativeProbability(t, r) {
    if (r || (r = this.df), t >= 0.5) {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(o, r) >= t); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(n + o / 100) >= t); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(i + o / 1e4) >= t); o += 1)
        s = i + o / 1e4;
      return s;
    } else {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-o, r) <= t); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-n - o / 100) <= t); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-i - o / 1e4) <= t); o += 1)
        s = i + o / 1e4;
      return -s;
    }
  }
}
class kz {
  constructor(t, r) {
    this.df1 = t, this.df2 = r, this.EPSILON = 1e-10;
  }
  L504(t, r, n, i) {
    const s = t * r / (t * r + n), o = Math.sqrt(s), a = Math.log(o), l = Math.sqrt(1 - s), c = Math.log(l);
    let u = 1 - 2 * Math.atan(o / Math.sqrt(-o * o + 1)) / Math.PI, p = 0;
    if (n != 1) {
      const y = Math.log(2 * o / Math.PI);
      if (u -= Math.exp(y + c), n != 3) {
        const g = Math.floor((n - 3) / 2);
        for (let b = 1; b <= g; b++) {
          const f = 2 * b + 1;
          p += Math.log((f - 1) / f);
          const E = p + c * f + y;
          E > -78.4 && (u -= Math.exp(E));
        }
      }
    }
    if (t != 1) {
      let y = p;
      if (n > 1 && (y += Math.log(n - 1)), y += Math.log(2 / Math.PI) + a + c * n, y > -78.4 && (u += Math.exp(y)), t != 3) {
        const g = Math.floor((t - 3) / 2);
        p = 0;
        for (let b = 1; b <= g; b++) {
          const f = b * 2 + 1;
          p += Math.log((n + f - 2) / f);
          const E = p + a * (f - 1) + y;
          E > -78.4 && (u += Math.exp(E));
        }
      }
    }
    return u;
  }
  L401(t, r, n, i) {
    const s = t * r / (t * r + n), o = Math.log(s);
    let a = 0;
    const l = Math.log(1 - s) * n / 2;
    if (l > -78.4 && (a = Math.exp(l)), t != 2) {
      const c = Math.floor(t / 2 - 1);
      let h = 0;
      for (let u = 1; u <= c; u++) {
        const p = 2 * u;
        h += Math.log(n + p - 2) - Math.log(p) + o, h + l > -78.4 && (a += Math.exp(h + l));
      }
    }
    return i == 1 && (a = 1 - a), a;
  }
  ProbF(t, r, n) {
    let i = n, s = t, o = r, a = 0;
    return Math.floor(s / 2) * 2 == s ? this.L401(s, i, o, a) : Math.floor(o / 2) * 2 != o ? this.L504(s, i, o, a) : (i = 1 / i, s = r, o = t, a = 1, this.L401(s, i, o, a));
  }
  cumulativeProbability(t) {
    if (this.df1 > 0.01 && this.df2 > 0.01 && t > this.EPSILON)
      return 1 - this.ProbF(this.df1, this.df2, t);
    console.error("df1, df2, and F must be numbers greater than 0.");
  }
}
function l3(e) {
  return Math.atan(e) * 180 / Math.PI;
}
function Vo(e, t) {
  const r = [];
  for (let n = 0; n < e; n++)
    r.push(t(n));
  return r;
}
const IS = [
  1.4142024783770517,
  1.7285350177358225,
  1.975558322080508,
  2.165309701618668,
  2.3223314597870495,
  2.43666896580902,
  2.539575597098922,
  2.629725259756139,
  2.6946351910160824,
  2.7571690989287108,
  2.82429436007275,
  2.86976990061697,
  2.911181488216127,
  2.9562785307147474,
  2.991043137459134,
  3.031892332910388,
  3.0390882779033968,
  3.084150339177206,
  3.1068126593538534,
  3.1377944664764175,
  3.1526730795266236,
  3.1856353298858746,
  3.1923941584623616,
  3.2232152987382205,
  3.2423279731889063,
  3.2672678614514434,
  3.28815589678312,
  3.306598538588182,
  3.3169876930034423,
  3.3426537588982366,
  3.338808432731316,
  3.3551800156910674,
  3.3677857453596176,
  3.3801704122612546,
  3.3894353098402292,
  3.4103476461664384,
  3.420758782190955,
  3.4234022273067235,
  3.4377591100482245,
  3.4495251663075597,
  3.45784133640642,
  3.4655169406594553,
  3.499664208072353,
  3.5075228374867624,
  3.4963470841468247,
  3.5194522982765517,
  3.50887461478777,
  3.517883433127914,
  3.527130862311399,
  3.5478465903324174,
  3.5524335509017972,
  3.5453727082671342,
  3.556173872494318,
  3.557087103502499,
  3.589369632641309,
  3.5859140345184524,
  3.572323092223869,
  3.6004177405174853,
  3.6100996977289306,
  3.601519301860006,
  3.606430559116003,
  3.623484959486857,
  3.6110156117453704,
  3.6398254610166214,
  3.6485762129590045,
  3.6369984456518214,
  3.6420217039991707,
  3.6515502039986543,
  3.6534596174533878,
  3.6659253039539754,
  3.678204062277477,
  3.673013776537585,
  3.6873396028854244,
  3.677549442478252,
  3.672393117945697,
  3.694338890356745,
  3.698559967922895,
  3.7088383298959364,
  3.6960214124422732,
  3.6962804693332054,
  3.7259363906151113,
  3.6945941836261005,
  3.7123614650012637,
  3.7266182166220743,
  3.726433940762783,
  3.7262288936328507,
  3.73068538678121,
  3.7464587039431216,
  3.734498500854471,
  3.7666496106093086,
  3.7577811376185797,
  3.755885408241557,
  3.7653220485067256,
  3.759612302718265,
  3.750000422234468,
  3.776893666562007,
  3.7656945047078376
], Cz = [
  [
    12.92876788710003,
    18.669362102797844,
    20.708185574014465
  ],
  [
    12.893379950402329,
    17.838738753100234,
    20.009145166260716
  ],
  [
    12.567620517329296,
    17.39284624657391,
    19.327403214291675
  ],
  [
    12.44012368783225,
    17.159725181804923,
    19.031999514734718
  ],
  [
    12.258810404004157,
    16.643626920880678,
    18.520644599539708
  ],
  [
    12.490936102639248,
    17.07031258707699,
    19.26763537042604
  ],
  [
    12.230582644506537,
    16.8611702133535,
    19.04138451550924
  ],
  [
    12.285890759032673,
    16.72028694459538,
    18.998686524252154
  ],
  [
    12.265830882960202,
    16.861313711298223,
    19.01741086021432
  ],
  [
    12.221592293386445,
    16.856569952690425,
    18.679522968116675
  ],
  [
    12.207863926087379,
    16.466760433982508,
    18.327798576854196
  ],
  [
    12.23047144884862,
    16.604698640112442,
    18.778749913667404
  ],
  [
    12.310880515319493,
    16.75477031068603,
    18.61887265606582
  ],
  [
    12.09088910593483,
    16.680683526842817,
    19.10909766756724
  ],
  [
    12.28969274656454,
    16.494346369998592,
    18.555323182091747
  ],
  [
    12.351479909044647,
    17.231085800266705,
    19.12315903511468
  ],
  [
    12.232654018508402,
    17.03319706813043,
    19.36238761950663
  ],
  [
    12.24175327982118,
    17.01249507542771,
    19.29261479388184
  ],
  [
    12.240819762926595,
    16.958668959199564,
    18.703343358289676
  ],
  [
    12.325576191647679,
    16.741637280941735,
    18.706270613293825
  ],
  [
    12.29079270883332,
    16.83580567418819,
    18.885633182327588
  ],
  [
    12.105579742321321,
    16.801481191805877,
    18.74917129995002
  ],
  [
    12.241506985184987,
    16.421107838741005,
    18.51907643327747
  ],
  [
    12.22772321442409,
    16.76637698315794,
    18.59944945667253
  ],
  [
    12.146827427372807,
    16.504491710455042,
    18.624893334253915
  ],
  [
    12.099825423105056,
    16.517727777727934,
    18.389759370770282
  ],
  [
    12.241793182544008,
    16.69983166753318,
    18.199273554649118
  ],
  [
    12.133827646762477,
    16.937161124066893,
    18.865979715097055
  ],
  [
    12.014897172400497,
    16.64164656731907,
    18.52796800753582
  ],
  [
    12.03194886183511,
    16.448427247716083,
    18.360165754021324
  ],
  [
    12.060576333659972,
    16.972556324548336,
    18.909884009510286
  ],
  [
    12.130919558394593,
    16.846538605893603,
    18.974105413083418
  ],
  [
    12.167013704292577,
    16.962535224497064,
    18.952800614645692
  ],
  [
    12.307745895005242,
    16.69776947316106,
    18.73020815902911
  ],
  [
    12.03703814065202,
    16.744259233990512,
    19.40987043616083
  ],
  [
    12.23158902787162,
    16.992381220472012,
    19.23258888861058
  ],
  [
    12.30313545083327,
    16.80175925410746,
    18.88639508508212
  ],
  [
    12.216506652052612,
    16.95978747527697,
    19.07369251354378
  ],
  [
    12.289633178985905,
    17.037358965358983,
    18.978000598844293
  ],
  [
    12.114391564747471,
    16.353909897952686,
    18.35011390560238
  ],
  [
    12.208213936084457,
    16.12841887472018,
    18.239736208276152
  ],
  [
    12.326886082604242,
    16.87043068171149,
    18.900551155302647
  ],
  [
    12.24602935198574,
    16.740078446411406,
    18.57610242578182
  ],
  [
    12.154508067768113,
    16.70375179351137,
    18.84458221820561
  ],
  [
    12.053162931004179,
    16.63616478058826,
    18.764716631834734
  ],
  [
    12.242031428895839,
    16.870439498648583,
    18.946299240629287
  ],
  [
    12.172676093456305,
    16.57616403586386,
    18.901254056077153
  ],
  [
    12.234873290793098,
    16.849691971911838,
    19.020953521536004
  ],
  [
    12.307356477970162,
    17.070904468883104,
    19.124634537613513
  ],
  [
    12.258316325281726,
    16.98236293001686,
    19.362641577913156
  ],
  [
    12.236258781616636,
    16.835948685325945,
    18.872615556171525
  ],
  [
    12.218214829379882,
    16.72052856570416,
    18.576319895769533
  ],
  [
    12.266452802779268,
    17.001974682521503,
    19.397512454689892
  ],
  [
    12.142229768023105,
    16.760040761542093,
    18.73221439686166
  ],
  [
    12.362128316602698,
    16.779263655428466,
    18.690631800055144
  ],
  [
    12.23248525532616,
    16.78957578482738,
    19.290187946573045
  ],
  [
    12.194978246692179,
    16.66872414977679,
    18.38065055971982
  ],
  [
    12.364346090585878,
    16.78308783969924,
    18.787944141467552
  ],
  [
    12.213523054233821,
    16.745070120633624,
    18.779462580096293
  ],
  [
    12.120562728816676,
    16.72947148909386,
    18.540581750860838
  ],
  [
    12.147441684285011,
    16.362711939455345,
    18.5928909502196
  ],
  [
    12.349013958141011,
    17.115157968739332,
    19.074081167238724
  ],
  [
    12.169896474381117,
    16.779107284309674,
    19.095614865501265
  ],
  [
    12.212332899050487,
    17.15220159015151,
    19.18433312800504
  ],
  [
    12.427266331944576,
    17.19802901185036,
    19.08282870552354
  ],
  [
    12.208415329256482,
    16.698611123996386,
    18.437039290733527
  ],
  [
    12.150857540075965,
    16.747967767000077,
    18.522105916017864
  ],
  [
    12.185133777587764,
    16.716543085287885,
    18.75368115517968
  ],
  [
    12.202518998568662,
    16.695350960024488,
    18.766605345681214
  ],
  [
    12.293516845096802,
    16.848652152520355,
    18.73818931670063
  ],
  [
    12.264328782539446,
    16.898700733974184,
    18.91736903501125
  ],
  [
    12.283442238272498,
    16.79113139749197,
    18.762641899116595
  ],
  [
    12.288571666812464,
    16.947956362708894,
    19.26608413111616
  ],
  [
    12.199938820517241,
    16.73882101164454,
    18.649824259785902
  ],
  [
    12.281399931209005,
    16.74455321404603,
    18.993644280454557
  ],
  [
    11.978508088635845,
    16.751385791647305,
    19.067980524092103
  ],
  [
    12.352190443412464,
    17.002035355108024,
    18.910150024775536
  ],
  [
    12.11299191492474,
    16.85211409238294,
    19.21553533835868
  ],
  [
    12.252946905996852,
    16.77267825853487,
    18.758060103809566
  ],
  [
    12.253428278525488,
    17.05117162481038,
    19.437396636388712
  ],
  [
    12.365555609949542,
    17.217797222036967,
    19.557725250431925
  ],
  [
    12.446856234792692,
    17.13219895129848,
    19.189823799758685
  ],
  [
    12.378913383861864,
    16.69420382596318,
    18.614200176451167
  ],
  [
    12.209646506057828,
    17.049298470931937,
    19.21471558598783
  ],
  [
    12.07451389049845,
    16.52146599860598,
    18.646538442813565
  ],
  [
    12.242992826481506,
    17.118044327693312,
    19.109033882498373
  ],
  [
    12.031588638774476,
    16.440292876584916,
    18.365137461548116
  ],
  [
    12.256327863966023,
    16.937124809805663,
    19.055448755862216
  ],
  [
    12.152502866561859,
    16.51661734703226,
    18.292867488178068
  ],
  [
    12.240166584135661,
    17.01144955716148,
    19.269980514360167
  ],
  [
    12.288087364649998,
    16.9124768573556,
    18.78496409520197
  ],
  [
    12.261031067472498,
    17.080660923120398,
    18.993376274931116
  ],
  [
    12.149516099981419,
    16.429960356660846,
    18.693814658804264
  ],
  [
    12.189972968413274,
    16.360091390089806,
    18.372140642711813
  ],
  [
    12.247713311640034,
    16.85901876289993,
    18.747152105084417
  ],
  [
    12.235996387439796,
    16.719425800548546,
    18.73463631602104
  ]
], ou = {
  minLen3: 0,
  minLen6: 1,
  tooManyPoints: 2
}, Iz = {
  [ou.minLen3]: "line must have at least 3 points",
  [ou.minLen6]: "line must have at least 6 points",
  [ou.tooManyPoints]: "line contains too many points"
};
let Vy = class extends Error {
  constructor(t) {
    super(Iz[t]), this.code = t;
  }
};
function Pz(e, t, r) {
  return e.map((n) => n - t).map((n) => n / r);
}
function ov(e) {
  const t = e.bestFit, r = t.rss();
  return {
    se: Math.sqrt(r / e.length),
    rss: r,
    resid: t.residuals,
    slope: t.slope,
    inter: t.intercept
  };
}
function Rz(e) {
  if (e.length < 3)
    throw new Vy(ou.minLen3);
  const t = Sz(e.points.map((r) => r.x), e.points.map((r) => r.y));
  return Number.isNaN(t) ? 1 : Math.abs(t);
}
function Tz(e) {
  const t = e.length;
  if (t < 6)
    throw new Vy(ou.minLen6);
  const { se: r } = ov(e);
  if (r === 0)
    return { feats: [0, 0, 0] };
  const n = Cz[t - 6], i = [];
  for (let a = 2; a < t - 3; a++) {
    const l = a + 1, { se: c } = ov(e.slice(0, l)), { se: h } = ov(e.slice(l));
    i.push(c ** l * h ** (t - l) / r ** t);
  }
  const s = Math.min(...i), o = -Math.log(s);
  return {
    feats: n.map((a) => o > a ? 1 : 0),
    logLambda: o,
    t: i.indexOf(s) + 2
  };
}
function NP(e) {
  const t = e.length;
  if (t < 6)
    throw new Vy(ou.minLen6);
  const r = e.bestFit.rss(), n = [0, 0];
  if (r === 0)
    return { feats: n };
  const i = [], s = e.points.map((f) => f.x), o = e.points.map((f) => f.y), a = (f) => f.reduce((E, A) => E + A), l = (f, E) => a(f.map((A, x) => A * E[x])), c = [], h = [];
  for (let f = 2; f < t - 3; f++) {
    const E = s.slice(0, f + 1), A = o.slice(0, f + 1), x = a(E), m = a(A), w = l(E, A), _ = a(E.map((st) => st ** 2)), S = w - x * m / (f + 1), R = _ - x ** 2 / (f + 1), O = S / R, $ = Pl(A) - O * Pl(E), z = s[f], F = $ + O * z, Y = s.slice(f + 1), rt = o.slice(f + 1), at = a(Y), pt = a(rt), vt = l(Y, rt), _t = a(Y.map((st) => st ** 2)), Ct = pt - (e.length - (f + 1)) * F, It = at - (e.length - (f + 1)) * z, jt = Ct / It, lt = vt / at - jt * _t / at, L = E.map((st) => $ + O * st), D = a(E.map((st, X) => (A[X] - L[X]) ** 2)), tt = Y.map((st) => lt + jt * st), et = a(Y.map((st, X) => (rt[X] - tt[X]) ** 2));
    i.push(D + et), c.push({ a1: $, b1: O, a2: lt, b2: jt }), h.push(L.concat(tt));
  }
  const u = Math.min(...i);
  let p, y = (r - u) / 2 / (u / (t - 4));
  y <= 0 && (y = 1e-3), y === 1 / 0 ? p = 0 : p = 1 - new kz(2, t - 4).cumulativeProbability(y);
  const g = i.indexOf(u) + 2, b = { rssMin: u, rssl: r, F: y, p, split: g, params: c[g - 2], yhats: h[g - 2] };
  return p < 0.1 && (n[0] = 1), p < 0.05 && (n[1] = 1), { feats: n, debug: b };
}
function Oz(e) {
  const t = e.bestFit.residuals.map(Math.sign), { r, nminus: n, nplus: i } = t.reduce(
    (a, l, c) => (c && l !== t[c - 1] && a.r++, l || (l = 1), a[l === 1 ? "nplus" : "nminus"]++, a),
    { r: 1, nminus: 0, nplus: 0 }
  ), s = 2 * i * n / (i + n) + 1, o = Math.abs(Math.sqrt(
    2 * i * n * (2 * i * n - i - n) / (Math.pow(i + n, 2) * (i + n - 1))
  ));
  return { feats: [r < s - o / 2 ? 1 : r > s + o / 2 ? -1 : 0, r, s, o, Math.abs(r - s) / s] };
}
function Lz(e) {
  const t = e.length;
  if (t > IS.length + 4)
    throw new Vy(ou.tooManyPoints);
  const r = e.bestFit.residuals, n = Math.sqrt(
    r.map((p) => p ** 2 / (t - 2)).reduce((p, y) => p + y)
  );
  if (n === 0)
    return [-1, 0];
  const i = e.points.map((p) => p.x), s = Pl(i), o = i.map((p) => (p - s) ** 2), a = o.reduce((p, y) => p + y), l = o.map((p) => n * Math.sqrt(1 - 1 / t - p / a)), c = r.map((p, y) => p / l[y]).map((p) => Math.abs(p)), h = Math.max(...c), u = IS[t - 4];
  return [h, c.filter((p) => p > u).length];
}
function Mz(e) {
  const t = e.bestFit.rss(), r = e.points.at(-1).x - e.points[0].x, n = Math.sqrt(t / e.length) / r, i = Math.atan(e.bestFit.slope);
  return [n, n * Math.cos(i) ** 2];
}
let Nz = class {
  /**
   * Compute non-standardized feature columns from examples.
   * @param examples - Training examples
   * @returns Feature columns
   */
  computeFeatures(t) {
    function r(i, s) {
      const o = i[0].length, a = {};
      for (let l = 0; l < o; l++)
        a[`${s}${l + 1}`] = [];
      for (const l of i)
        l.forEach((c, h) => a[`${s}${h + 1}`].push(c));
      return a;
    }
    const n = {
      absCorrCoeff: t.map((i) => Rz(i.data)),
      nPoints: t.map((i) => i.data.length),
      ...r(t.map((i) => Mz(i.data)), "scaledS"),
      nPointsChart: t.map((i) => i.chartLength),
      chartPct: t.map((i) => (i.data.length - 1) / (i.chartLength - 1))
    };
    return t[0].data.length >= 6 && Object.assign(
      n,
      r(t.map((i) => Tz(i.data).feats), "qTest"),
      r(t.map((i) => NP(i.data).feats), "fTest"),
      r(t.map((i) => Oz(i.data).feats), "runsTest"),
      r(t.map((i) => Lz(i.data)), "outlierTest")
    ), n;
  }
  /**
   * Standardize feature columns.
   * @param featCols - Non-standardized feature columns
   * @param featStats - Feature column statistics
   * @returns Standardized feature columns
   */
  standardizeFeatures(t, r) {
    const n = {};
    for (const [i, s] of Object.entries(t)) {
      const o = r[i];
      n[i] = o ? Pz(s, o.mean, o.stdDev) : s;
    }
    return n;
  }
  /**
   * Assemble feature matrix from standardized feature columns.
   * @param stdFeatCols - Standardized feature columns.
   * @returns Feature matrix (array of example rows)
   */
  assembleMatrix(t) {
    const r = Object.values(t)[0].length, n = Vo(r, (i) => []);
    for (const [i, s] of Object.entries(t))
      s.forEach((o, a) => n[a].push(o));
    return n;
  }
  /**
   * Compute feature matrix from examples.
   * @param examples - Training examples
   * @param featStats - Feature column statistics
   * @returns Feature matrix (array of example rows)
   */
  computeMatrix(t, r) {
    const n = this.computeFeatures(t), i = this.standardizeFeatures(n, r);
    return this.assembleMatrix(i);
  }
};
const DP = {
  "188b757048e": {
    breaks: "breaks_JF_CM3",
    small: {
      model: {
        N: 216,
        D: 6,
        b: 1.0301052191704447,
        kernelType: "linear",
        w: [
          -0.3670377924881308,
          0.24109852608042484,
          0.10770417080350453,
          3.7309289892912494,
          -0.24351287768173968,
          0.1773538767010703
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6613098596026764,
          stdDev: 0.32645241503938466
        },
        nPoints: {
          mean: 4.027777777777778,
          stdDev: 0.79484775003546
        },
        scaledS1: {
          mean: 0.2738191427566398,
          stdDev: 0.31274618795081666
        },
        scaledS2: {
          mean: 0.16552447256379144,
          stdDev: 0.22401114065292482
        },
        nPointsChart: {
          mean: 18.88425925925926,
          stdDev: 11.50047652834366
        },
        chartPct: {
          mean: 0.24575562721992683,
          stdDev: 0.17658868716036033
        }
      }
    },
    big: {
      model: {
        N: 818,
        D: 18,
        b: -0.5949603608497636,
        kernelType: "linear",
        w: [
          -0.4977108970919176,
          0.7541270816821308,
          0.9144109510673445,
          1.6047203771838476,
          -1.4368172642074537,
          -0.21592712823176308,
          0.07644318713996778,
          0.014636523739875784,
          0.1763324579259402,
          1.106707575171747,
          -0.47385129596321995,
          0.45987873914033983,
          0.35112878139332787,
          -0.6236067182671058,
          0.9485075089484734,
          0.19163220544936868,
          0.20546829454342905,
          -0.06915930322456987
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6452237813470705,
          stdDev: 0.3240018443609284
        },
        nPoints: {
          mean: 14.583129584352077,
          stdDev: 8.99604477133496
        },
        scaledS1: {
          mean: 0.10594325137217282,
          stdDev: 0.09177436527475356
        },
        scaledS2: {
          mean: 0.08668479622616888,
          stdDev: 0.07415105573907281
        },
        nPointsChart: {
          mean: 27.0880195599022,
          stdDev: 12.696709863610126
        },
        chartPct: {
          mean: 0.5831555684741223,
          stdDev: 0.28777669079271473
        },
        runsTest2: {
          mean: 5.10757946210269,
          stdDev: 2.511304431521282
        },
        runsTest3: {
          mean: 8.050945471288665,
          stdDev: 4.446028922152818
        },
        runsTest4: {
          mean: 1.6812783091074126,
          stdDev: 0.5646901163167827
        },
        runsTest5: {
          mean: 0.337916669549109,
          stdDev: 0.20151780352623566
        },
        outlierTest1: {
          mean: 2.100035193879811,
          stdDev: 0.5296286424653459
        },
        outlierTest2: {
          mean: 0.05867970660146699,
          stdDev: 0.2351680408679939
        }
      }
    }
  },
  "18afd2f54c7": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3380856560371651,
        kernelType: "linear",
        w: [
          -0.756517811722315,
          0.37069999610745497,
          0.21673055797213336,
          1.1244975473636247,
          0.035519868943893806,
          0.6975781903311828
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6866332461949628,
          stdDev: 0.3229548134968895
        },
        nPoints: {
          mean: 4.069767441860465,
          stdDev: 0.8050959803624481
        },
        scaledS1: {
          mean: 0.03965686197121996,
          stdDev: 0.0338017466328698
        },
        scaledS2: {
          mean: 0.038745499336644146,
          stdDev: 0.033324943757710994
        },
        nPointsChart: {
          mean: 15.078488372093023,
          stdDev: 8.898337515306299
        },
        chartPct: {
          mean: 0.2979532652417984,
          stdDev: 0.1884678355817908
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.22042056305341218,
        kernelType: "linear",
        w: [
          -0.3280468854878086,
          -0.11665058369931192,
          -0.0022542536097451466,
          2.219103384778342,
          0.0342024760983941,
          0.4293989826596215,
          0.2975608661999607,
          -0.6077251584818741,
          0.4000527465309003,
          0.4042384593088002,
          0.001186586425212074,
          0.5190085928118862,
          -0.23537053975123523,
          0.0715945226988598,
          0.033154145420287044,
          -0.06347880606856209,
          0.1850990704458409,
          -0.001228864486559927
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6223429821764429,
          stdDev: 0.3110591999188207
        },
        nPoints: {
          mean: 13.731607629427794,
          stdDev: 8.370686093707965
        },
        scaledS1: {
          mean: 0.03544093688268208,
          stdDev: 0.026611386439376005
        },
        scaledS2: {
          mean: 0.03455363316854854,
          stdDev: 0.026077505679786228
        },
        nPointsChart: {
          mean: 23.768392370572208,
          stdDev: 11.730176258926388
        },
        chartPct: {
          mean: 0.6094307363719895,
          stdDev: 0.26692294365220165
        },
        runsTest2: {
          mean: 5.151226158038147,
          stdDev: 2.6793673522936645
        },
        runsTest3: {
          mean: 7.583581141916727,
          stdDev: 4.081715945141601
        },
        runsTest4: {
          mean: 1.6148756585462214,
          stdDev: 0.5411094264297078
        },
        runsTest5: {
          mean: 0.3153327018423893,
          stdDev: 0.19626169453505887
        },
        outlierTest1: {
          mean: 2.118980108638941,
          stdDev: 0.6300714899329056
        },
        outlierTest2: {
          mean: 0.09128065395095368,
          stdDev: 0.2882041970351209
        }
      }
    }
  },
  "18b1686ceb4": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3309416402875685,
        kernelType: "linear",
        w: [
          -0.20000267112106263,
          0.42809635761540643,
          0.46656203058966117,
          1.841671684760453,
          -0.6434524674952959,
          0.49143545422517687
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6764124363859395,
          stdDev: 0.3236057116921364
        },
        nPoints: {
          mean: 4.116279069767442,
          stdDev: 0.8069465847859293
        },
        scaledS1: {
          mean: 0.1858035195675879,
          stdDev: 0.21428670248595916
        },
        scaledS2: {
          mean: 0.12950420831848175,
          stdDev: 0.15751874574784924
        },
        nPointsChart: {
          mean: 15.761627906976743,
          stdDev: 9.783137376835176
        },
        chartPct: {
          mean: 0.300526358561615,
          stdDev: 0.1927265795559554
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.33318046701370874,
        kernelType: "linear",
        w: [
          0.032315062605570585,
          0.48106580584263436,
          -1.1047252909009055,
          3.7368759283052406,
          -0.6183759573768267,
          0.6939892440180402,
          0.3861182101902436,
          -0.4528094207813589,
          0.19685209857044894,
          0.5317134144006395,
          -0.3268861531591498,
          0.5416909853776097,
          0.11204746654248579,
          -0.042886524593192116,
          0.04725504450122949,
          0.09451185559860642,
          -0.011544267888957445,
          0.17029310632188632
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6349627683741144,
          stdDev: 0.3047569778403939
        },
        nPoints: {
          mean: 13.728882833787466,
          stdDev: 8.419998905023999
        },
        scaledS1: {
          mean: 0.07039535118699393,
          stdDev: 0.06922873611482698
        },
        scaledS2: {
          mean: 0.06255041459772398,
          stdDev: 0.05952611432033109
        },
        nPointsChart: {
          mean: 23.705722070844686,
          stdDev: 11.739000887557054
        },
        chartPct: {
          mean: 0.6095266522529739,
          stdDev: 0.26470522117524425
        },
        runsTest2: {
          mean: 5.129427792915531,
          stdDev: 2.7706078547777717
        },
        runsTest3: {
          mean: 7.603857452118007,
          stdDev: 4.140301994340143
        },
        runsTest4: {
          mean: 1.6191709447588931,
          stdDev: 0.5436847808406448
        },
        runsTest5: {
          mean: 0.32151695128382807,
          stdDev: 0.19159541197646354
        },
        outlierTest1: {
          mean: 2.116230031599242,
          stdDev: 0.5977792703826863
        },
        outlierTest2: {
          mean: 0.09400544959128065,
          stdDev: 0.29203530028780983
        }
      }
    }
  }
};
function Dz() {
  return Object.keys(DP).sort();
}
function Bz(e) {
  return DP[e ?? Dz().at(-1)];
}
var jz = Object.defineProperty, Fz = (e, t, r) => t in e ? jz(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, $z = (e, t, r) => (Fz(e, t + "", r), r);
const zz = 0.2;
function Vz(e, t, r = zz) {
  if (e.length === 3)
    return 1;
  const n = e.points.at(-1).x - e.points[0].x, i = (e.points.at(-1).y - e.points[0].y) / n, s = Math.atan(i), o = Math.cos(s), a = e.points.map((f) => f.y), l = e.slice(1, e.length - 1);
  let c = a.indexOf(Math.min(...a)) - 1;
  (c < 0 || c === l.length) && (c = null);
  let h = a.indexOf(Math.max(...a)) - 1;
  (h < 0 || h === l.length) && (h = null);
  const u = [], p = l.points.map((f) => {
    const E = f.x - e.points[0].x, A = Math.abs(f.y - (i * E + e.points[0].y));
    return u.push(A), A * o;
  }), y = p.indexOf(Math.max(...p));
  let g = !1;
  c !== null && Math.abs(c - y) / (t - 1) <= r && (g = u[c] > p[y]);
  let b = !1;
  return h !== null && Math.abs(h - y) / (t - 1) <= r && (b = u[h] > p[y]), b ? h + 1 : g ? c + 1 : y + 1;
}
let Uz = class {
  /**
   * @param model - (Optional) ID of split model to use.
   */
  constructor(t = void 0) {
    $z(this, "models");
    const r = Bz(t);
    if (r)
      this.models = {
        small: {
          svm: new SS(),
          stats: r.small.stats
        },
        big: {
          svm: new SS(),
          stats: r.big.stats
        }
      };
    else
      throw new Error(`unknown model ID: '${t}'`);
    this.models.small.svm.fromJSON(r.small.model), this.models.big.svm.fromJSON(r.big.model);
  }
  /**
   * Predict whether a sequence should be split.
   * @param seq - Data points of sequence to evaluate. 
   * @param chartLength - Number of data points in the complete chart
   * of which 'seq' is a part.
   * @returns Whether the sequence should be split.
   */
  shouldSplit(t, r) {
    if (t.length < 3 || t.points.every((a) => a.y === t.points[0].y))
      return !1;
    const n = new Nz(), i = t.length < 6 ? "small" : "big", [s] = n.computeMatrix(
      [{ data: t, chartLength: r }],
      this.models[i].stats
    ), [o] = this.models[i].svm.predict([s]);
    return o === 1;
  }
  /**
   * Predict trend sequences a series should be split into.
   * @param series - Data points of series to split.
   * @param yAxis - Displayed chart y-axis bounds; defaults to extreme values of data
   * @param pipCloseness - Max distance (as % of chart length) a sequence-local 
   * min/max point can be from the PIP to be a possible split point.
   * @returns List of index pairs denoting the start and end of each sequence.
   * @remarks
   * As in slices, the end index in a pair is not included in the set of indices
   * included in a sequence.
   * NB: Adjacent sequences share the point where they were split.
   * E.g., a hypothetical set of sequences might look like:
   *   [\{start: 0, end: 5\}, \{start: 4, end: 7\}, \{start: 6, end: 10\}]
   * where the first two sequences share the point at index 4, and the last
   * two share the point at index 6.
   */
  getSequences(t, r, n) {
    const i = t.length;
    t = t.project(void 0, r);
    const s = [], o = (a, l) => {
      const c = t.slice(a, l);
      if (this.shouldSplit(c, t.length)) {
        const h = Vz(c, t.length, n) + a;
        o(a, h + 1), o(h, l);
      } else
        s.push({ start: a, end: l });
    };
    return o(0, i), s;
  }
};
var Hz = Object.defineProperty, Gz = (e, t, r) => t in e ? Hz(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, PS = (e, t, r) => (Gz(e, typeof t != "symbol" ? t + "" : t, r), r);
const Qz = [
  [
    -1,
    1,
    "ReversalToRise",
    "PossibleReversalToRise"
    /* PRR */
  ],
  [
    1,
    -1,
    "ReversalToFall",
    "PossibleReversalToFall"
    /* PRF */
  ],
  [
    0,
    1,
    "EmergingRise",
    "PossibleEmergingRise"
    /* PER */
  ],
  [
    0,
    -1,
    "EmergingFall",
    "PossibleEmergingFall"
    /* PEF */
  ],
  [
    1,
    0,
    "RiseToStable",
    "PossibleRiseToStable"
    /* PRS */
  ],
  [
    -1,
    0,
    "FallToStable",
    "PossibleFallToStable"
    /* PFS */
  ]
], Wz = [
  [
    1,
    -1,
    1,
    "Rebound",
    "PossibleRebound"
    /* PRB */
  ],
  [
    -1,
    1,
    -1,
    "TemporaryJump",
    "PossibleTemporaryJump"
    /* PTJ */
  ]
], qz = 6, f6 = 5, Yz = 0.15;
let Bc = class {
  constructor(t, r = t.yBounds(), n, ...i) {
    PS(this, "params"), PS(this, "magnitude"), this.category = n, this.params = i, this.magnitude = this.computeMagnitude(t, r);
  }
  computeMagnitude(t, r) {
    const n = t.points.map((i) => i.y).slice(this.params[0], this.params.at(-1));
    return (Math.max(...n) - Math.min(...n)) / (r.end - r.start);
  }
  toString() {
    return `${this.category}(${this.params[0]}-${this.params[this.params.length - 1]})`;
  }
};
function Kz(e) {
  const t = Pl(e), r = e.map((n) => n - t);
  return Math.sqrt(r.reduce((n, i) => n + i ** 2, 0));
}
function Fg(e) {
  return Math.sign(e);
}
function am(e, t = f6, r = t) {
  const n = e.length;
  if (n < 3) {
    let i = (e.points[1].y - e.points[0].y) / (e.points[1].x - e.points[0].x);
    const s = l3(i);
    return Math.abs(s) < r && (i = 0), { classes: [Fg(i)], slope: i, angle: s };
  } else {
    const i = e.bestFit.rss();
    if (n < qz) {
      let u = Fg(e.bestFit.slope);
      return Math.abs(e.bestFit.xAngle) < r && (u = 0), { classes: [u], slope: e.bestFit.slope, angle: e.bestFit.xAngle };
    }
    const s = e.points.map((u) => u.x), o = Math.sqrt(i / (n - 2)) / Kz(s), a = 1 - 0.05 / 2, l = new _z(n - 2).invCumulativeProbability(a) * o, c = [e.bestFit.slope - l, e.bestFit.slope + l], h = [];
    return Math.sign(c[0]) !== Math.sign(c[1]) ? (h.push(0), Math.abs(e.bestFit.xAngle) >= t && h.push(Fg(e.bestFit.slope))) : (h.push(Fg(e.bestFit.slope)), Math.abs(e.bestFit.xAngle) < t && e.bestFit.slope && h.push(0)), { classes: h, slope: e.bestFit.slope, angle: e.bestFit.xAngle, moe: l };
  }
}
function Zz(e, t, r = Yz, n = f6, i = n, s) {
  const o = e.project(void 0, s), a = t[t.length - 1], l = o.slice(a.start, a.end);
  if (l.length < 3)
    return null;
  const c = (g) => {
    const { classes: b } = am(l.slice(0, g + 1), n, i), { classes: f } = am(l.slice(g), n, i);
    if (b.length === 1 && f.length === 1 && b[0] !== f[0] || b.length === 1 && !f.includes(b[0]) || f.length === 1 && !b.includes(f[0])) {
      const E = a.start + g;
      return a.end = E + 1, t.push({ start: E, end: e.length }), !0;
    } else
      return !1;
  };
  let h = Math.round(r * e.length);
  if (h < 2)
    return null;
  if (h === 2 || l.length === 3)
    return c(l.length - 2);
  if (l.length < 6)
    return !!(c(2) || l.length === 5 && c(3));
  for (; l.length - h < l.length / 2; )
    h--;
  const u = l.slice(-(h + 3)), { feats: p, debug: y } = NP(u);
  if (p[0] && p[1]) {
    const g = a.end - (h + 3) + y.split;
    return a.end = g + 1, t.push({ start: g, end: e.length }), !0;
  }
  return !1;
}
function Jz(e, t, r, n) {
  const i = [];
  let s = -1;
  function o(a) {
    const l = t[s][1], c = t[a - 1][2];
    i.push([
      am(e.slice(l, c), r, n),
      l,
      c
    ]);
  }
  for (let a = 0; a < t.length; a++) {
    if (t[a][0].classes.length > 1) {
      s !== -1 && o(a), s = a, o(a + 1), s = -1;
      continue;
    }
    s === -1 ? s = a : t[a][0].classes[0] !== t[a - 1][0].classes[0] && (o(a), s = a);
  }
  return s !== -1 && o(t.length), i;
}
function Xz(e, t, r = f6, n = r, i, s = !1) {
  const o = e.project(void 0, i);
  let a = t.map(
    ({ start: c, end: h }) => [
      am(o.slice(c, h), r, n),
      c,
      h
    ]
  );
  s && a.length > 1 && (a = Jz(o, a, r, n));
  const l = [];
  for (let c = 0; c < a.length; c++) {
    const [h, u, p] = a[c];
    for (const y of h.classes)
      l.push(new Bc(
        e,
        i,
        [
          "Fall",
          "Stable",
          "Rise"
          /* RT */
        ][y + 1],
        u,
        p
      ));
    if (c < a.length - 1) {
      h.classes.includes(1) ? l.push(new Bc(e, i, "BigJump", u, p)) : h.classes.includes(-1) && l.push(new Bc(e, i, "BigFall", u, p));
      const [y, g, b] = a[c + 1], f = Qz.filter((E) => h.classes.includes(E[0]) && y.classes.includes(E[1]));
      for (const E of f)
        l.push(new Bc(e, i, E[2], u, g, b)), c + 1 === a.length - 1 && l.push(new Bc(e, i, E[3], u, g, b));
      if (c < a.length - 2) {
        const [E, A, x] = a[c + 2], m = Wz.filter(
          (w) => h.classes.includes(w[0]) && y.classes.includes(w[1]) && E.classes.includes(w[2])
        );
        for (const w of m)
          l.push(new Bc(e, i, w[3], u, g, A, x)), c + 2 === a.length - 1 && l.push(new Bc(e, i, w[4], u, g, A, x));
      }
    }
  }
  return { candidates: l, slopeInfo: a.map(([c, h, u]) => c) };
}
class tV extends Error {
}
function RS(e) {
  const t = [];
  let r = 0;
  for (let n = 0; n < e; n++)
    t[n] = Math.random(), r += t[n];
  for (let n = 0; n < e; n++)
    t[n] = t[n] / r;
  return t;
}
function g6(e, t, r) {
  if (t && t.length > 0) {
    const n = [];
    if (t.length === 1 || r === t.length - 1) {
      const i = t.length === 1 ? 0 : r, s = t[i].values.length;
      for (let o = 0; o < s; o++) {
        const a = RS(e.length);
        n.push(a);
      }
    } else {
      const i = t[r].values.length;
      for (let s = 0; s < i; s++) {
        const o = g6(e, t, r + 1);
        n.push(o);
      }
    }
    return n;
  } else
    return RS(e.length);
}
function eV(e, t, r) {
  const n = g6(e, t, 0);
  return BP(n, r, 0), n;
}
function TS(e) {
  return e.constructor === Array;
}
function rV(e) {
  return !!(TS(e) && e.length > 0 && TS(e[0]));
}
function BP(e, t, r) {
  if (rV(e)) {
    let n = r;
    for (let i = 0; i < e.length; i++)
      n = BP(e[i], t, n);
    return n;
  } else {
    for (let i = 0; i < e.length; i++)
      e[i] = t[r][i];
    return r + 1;
  }
}
function nV(e) {
  const t = [];
  for (let r = 0; r < e.length; r++)
    t.push(jP(e[r]));
  return t;
}
function jP(e) {
  const t = [];
  let r = 0;
  for (let n = 0; n < e.length; n++)
    t[n] = e[n] + 1e-3, r += t[n];
  for (let n = 0; n < e.length; n++)
    t[n] = t[n] / r;
  return t;
}
class iV {
  constructor(t, r) {
    Ke(this, "name");
    Ke(this, "values");
    Ke(this, "_sampledLw");
    Ke(this, "wasSampled", !1);
    // keeping parent names here rather than references works better
    // for using worker threads
    Ke(this, "parents", []);
    Ke(this, "cpt", []);
    Ke(this, "value", -1);
    Ke(this, "dirty", !1);
    Ke(this, "isObserved", !1);
    // XXX better to use Map
    Ke(this, "valueIndexMap");
    Ke(this, "g");
    this.name = t, this.values = r;
  }
  initSampleLw() {
    this._sampledLw = void 0;
  }
  sampleLw() {
    if (this.wasSampled)
      return 1;
    const t = this.parents.map((i) => this.g.nodeMap[i]);
    let r = 1;
    t.forEach((i) => {
      r *= i.sampleLw();
    }), this.wasSampled = !0;
    let n = this.cpt;
    if (t.forEach((i) => {
      n = n[i.value];
    }), this.value != -1)
      r *= n[this.value];
    else {
      let i = Math.random();
      for (let s = 0; s < n.length; s++)
        if (i -= n[s], i < 0) {
          this.value = s;
          break;
        }
    }
    return r;
  }
  saveSampleLw(t) {
    if (!this._sampledLw) {
      this._sampledLw = new Array(this.values.length);
      for (let r = this.values.length - 1; r >= 0; r--)
        this._sampledLw[r] = 0;
    }
    this._sampledLw[this.value] += t;
  }
  addParent(t) {
    return this.parents.push(t), this.dirty = !0, this;
  }
  valueIndex(t) {
    if (!this.valueIndexMap) {
      this.valueIndexMap = {};
      for (let r = 0; r < this.values.length; r++) {
        const n = this.values[r];
        this.valueIndexMap[n] = r;
      }
    }
    return this.valueIndexMap[t];
  }
  observe(t) {
    const r = this.valueIndex(t);
    r >= 0 ? (this.isObserved = !0, this.value = r) : console.error("could not find value " + t + " for node " + this.name);
  }
  unobserve() {
    this.isObserved = !1, this.value = -1;
  }
  setCpt(t) {
    if (this.parents.length === 0)
      this.cpt = jP(t);
    else {
      if (!this.g)
        throw new tV("must add node to graph before calling setCpt()");
      const r = this.parents.map((n) => this.g.nodeMap[n]);
      this.cpt = eV(this.values, r, nV(t));
    }
  }
  probs() {
    if (!this._sampledLw)
      return [];
    const t = this._sampledLw.reduce((r, n) => r + n, 0);
    return this._sampledLw.map((r) => r / t);
  }
}
function sV() {
  class e {
    constructor(s, o) {
      Ke(this, "name");
      Ke(this, "values");
      Ke(this, "_sampledLw");
      Ke(this, "wasSampled", !1);
      Ke(this, "parents", []);
      Ke(this, "cpt", []);
      Ke(this, "value", -1);
      Ke(this, "dirty", !1);
      Ke(this, "isObserved", !1);
      Ke(this, "g");
      this.name = s, this.values = o;
    }
    initSampleLw() {
      this._sampledLw = void 0;
    }
    sampleLw() {
      if (this.wasSampled)
        return 1;
      const s = this.parents.map((l) => this.g.nodeMap[l]);
      let o = 1;
      s.forEach((l) => {
        o *= l.sampleLw();
      }), this.wasSampled = !0;
      let a = this.cpt;
      if (s.forEach((l) => {
        a = a[l.value];
      }), this.value != -1)
        o *= a[this.value];
      else {
        let l = Math.random();
        for (let c = 0; c < a.length; c++)
          if (l -= a[c], l < 0) {
            this.value = c;
            break;
          }
      }
      return o;
    }
    saveSampleLw(s) {
      if (!this._sampledLw) {
        this._sampledLw = new Array(this.values.length);
        for (let o = this.values.length - 1; o >= 0; o--)
          this._sampledLw[o] = 0;
      }
      this._sampledLw[this.value] += s;
    }
  }
  class t {
    constructor() {
      Ke(this, "nodes", []);
      Ke(this, "nodeMap", {});
    }
    sample(s) {
      for (let a = this.nodes.length - 1; a >= 0; a--)
        this.nodes[a].initSampleLw();
      let o = 0;
      for (let a = 0; a < s; a++) {
        for (let c = this.nodes.length - 1; c >= 0; c--) {
          const h = this.nodes[c];
          h.isObserved || (h.value = -1), h.wasSampled = !1;
        }
        const l = this.nodes.reduceRight((c, h) => c * h.sampleLw(), 1);
        o += l;
        for (let c = this.nodes.length - 1; c >= 0; c--)
          this.nodes[c].saveSampleLw(l);
      }
      return o;
    }
  }
  function r(i) {
    const s = Object.create(t.prototype, Object.getOwnPropertyDescriptors(i.graph)), o = s.nodes.map((a) => {
      const l = Object.create(e.prototype, Object.getOwnPropertyDescriptors(a));
      return l.g = s, s.nodeMap[a.name] = l, l;
    });
    return s.nodes = o, s;
  }
  function n(i) {
    const s = r(i);
    s.sample(i.samples);
    const o = {};
    for (let a = 0; a < s.nodes.length; a++)
      o[s.nodes[a].name] = s.nodes[a];
    self.postMessage(o);
  }
  self.onmessage = function(i) {
    n(i.data);
  };
}
const oV = sV.toString().trim().split(`
`).slice(1, -1).join(`
`), aV = new Blob([oV], { type: "text/javascript" }), lV = URL.createObjectURL(aV);
class cV {
  constructor() {
    Ke(this, "nodes", []);
    Ke(this, "saveSamples", !1);
    Ke(this, "samples", []);
    Ke(this, "nodeMap", {});
  }
  reinit() {
    this.nodes.forEach((t) => {
      if (t.dirty === void 0 || t.dirty) {
        const r = t.parents.map((n) => this.nodeMap[n]);
        t.cpt = g6(t.values, r, 0), t.dirty = !1;
      }
    });
  }
  sample(t) {
    this.saveSamples && (this.samples = []);
    for (let n = this.nodes.length - 1; n >= 0; n--)
      this.nodes[n].initSampleLw();
    let r = 0;
    for (let n = 0; n < t; n++) {
      for (let s = this.nodes.length - 1; s >= 0; s--) {
        const o = this.nodes[s];
        o.isObserved || (o.value = -1), o.wasSampled = !1;
      }
      const i = this.nodes.reduceRight((s, o) => s * o.sampleLw(), 1);
      r += i;
      for (let s = this.nodes.length - 1; s >= 0; s--)
        this.nodes[s].saveSampleLw(i);
      if (this.saveSamples) {
        const s = {};
        for (let o = this.nodes.length - 1; o >= 0; o--) {
          const a = this.nodes[o];
          s[a.name] = a.values[a.value];
        }
        this.samples.push(s);
      }
    }
    return r;
  }
  /*private createNodeMap() {
    this.nodeMap = {};
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      this.nodeMap[node.name] = node;
    }
  }*/
  node(t) {
    return this.nodeMap[t];
  }
  observe(t, r) {
    const n = this.node(t);
    n ? n.observe(r) : console.error("could not find node with name " + t);
  }
  unobserve(t) {
    const r = this.node(t);
    r && r.unobserve();
  }
  newNode(t, r) {
    const n = new iV(t, r);
    return this.addNodes(n), n;
  }
  addNodes(...t) {
    t.forEach((r) => {
      r.g = this, this.nodeMap[r.name] = r;
    }), this.nodes.push(...t);
  }
  samplesAsCsv(t) {
    const r = t || {}, n = r.rowDelimiter || `
`, i = r.fieldDelimiter || ",";
    let s = "", o = "";
    for (let a = 0; a < this.nodes.length; a++)
      o += this.nodes[a].name, a < this.nodes.length - 1 && (o += i);
    s += o + n;
    for (let a = 0; a < this.samples.length; a++) {
      const l = this.samples[a];
      o = "";
      for (let c = 0; c < this.nodes.length; c++) {
        const h = this.nodes[c];
        o += l[h.name], c < this.nodes.length - 1 && (o += i);
      }
      s += o, a < this.samples.length - 1 && (s += n);
    }
    return s;
  }
  toWorkerMessage(t) {
    return {
      samples: t,
      graph: this
    };
  }
  async sampleWithWorker(t) {
    return new Promise((r) => {
      const n = new Worker(lV, { type: "module" });
      n.onerror = (i) => {
        console.error(i);
      }, n.onmessage = (i) => {
        const s = i.data;
        this.updateFromWorker(s), r();
      }, n.postMessage(this.toWorkerMessage(t));
    });
  }
  updateFromWorker(t) {
    for (let r = 0; r < this.nodes.length; r++) {
      const n = this.nodes[r], i = t[n.name];
      i && (n.value = i.value, n.wasSampled = i.wasSampled, n._sampledLw = i._sampledLw);
    }
  }
}
var uV = Object.defineProperty, hV = (e, t, r) => t in e ? uV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, mi = (e, t, r) => (hV(e, typeof t != "symbol" ? t + "" : t, r), r);
function pV(e, t) {
  const r = e.length, n = e.project(void 0, t);
  if (r < 3) {
    const i = (n.points[1].y - n.points[0].y) / (n.points[1].x - n.points[0].x);
    return l3(i);
  } else {
    const i = h6(e.points.map((s) => [s.x, s.y]));
    return l3(i.m);
  }
}
const FP = {
  /*density: {
    values: ['low', 'med', 'high'],
    fn(series: Point[]) {
      return series.length < 10 ? this.values[0] : series.length < 30 ? this.values[1] : this.values[2];
    }
  },*/
}, $P = {
  percentage: {
    values: ["<20", ">=20", ">=40", ">=60", ">=80", "100"],
    fn(e, t) {
      const r = (e.params[e.params.length - 1] - 1 - e.params[0]) / (t.length - 1);
      return this.values[Math.floor(r * 10 / 2)];
    }
  },
  /*percentage: {
    values: ['<80', '>=80', '100'],
    fn(cand: Candidate, series: Point[]) {
      // cand.params values (indices) are taken from sequence endpoints, which now look like
      // slices, so the final param value will always be 1 greater than the final
      // index of the final sequence.
      const pct = (cand.params[cand.params.length - 1]! - 1 - cand.params[0])/(series.length - 1);
      return pct === 1 ? this.values[2] : pct >= 0.8 ? this.values[1] : this.values[0];
    }
  },*/
  touchEnd: {
    values: ["yes", "no"],
    fn(e, t) {
      return e.params.at(-1) === t.length ? this.values[0] : this.values[1];
    }
  },
  lastLength: {
    values: ["<20", ">=20"],
    fn(e, t) {
      const r = e.params.length;
      return (e.params[r - 1] - 1 - e.params[r - 2]) / (t.length - 1) >= 0.2 ? this.values[1] : this.values[0];
    }
  },
  volatility: {
    values: ["low", "med", "high"],
    fn(e, t) {
      const r = t.points.map((o) => o.y), n = d6(r) - p6(r);
      if (n === 0)
        return this.values[0];
      let i = 0;
      for (let o = 0; o < e.params.length - 1; o++) {
        const a = o < e.params.length - 2 ? t.slice(e.params[o], e.params[o + 1] + 1) : t.slice(e.params[o], e.params[o + 1]);
        a.length > 2 && (i += 2 * Math.sqrt(a.bestFit.rss() / a.length) / n);
      }
      const s = i / (e.params.length - 1);
      return s < 0.1 ? this.values[0] : s < 0.3 ? this.values[1] : this.values[2];
    }
  },
  /*containsMinMax: {
    values: ['yes', 'no'],
    fn(cand: Candidate, series: Point[]) {
      const ys = series.map(p => p[1]);
      const min = Math.min(...ys);
      const max = Math.max(...ys);
      const candYs = ys.slice(cand.params[0], cand.params.at(-1)! + 1);
      return candYs.find(y => y === min || y === max) !== undefined ? this.values[0] : this.values[1];
    }
  },*/
  /*yScale: {
    values: ['<80', '>=80'],
    cats: ['BigJump', 'BigFall'],
    fn(cand: Candidate, series: Point[], chartRanges?: ChartRanges) {
      const ys = series.map(p => p[1]);
      const candYs = ys.slice(cand.params[0], cand.params.at(-1)!);
      const candYRange = Math.max(...candYs) - Math.min(...candYs);
      const chartYRange = chartRanges ? chartRanges.y : getChartRanges(series).y;
      const yScale = candYRange/(chartYRange[1] - chartYRange[0]);
      return yScale >= 0.8 ? this.values[1] : this.values[0];
    }     
  },*/
  yScale: {
    values: ["<20", ">=20", ">=40", ">=60", ">=80", "100"],
    fn(e, t, r = t.yBounds()) {
      const n = t.points.map((o) => o.y).slice(e.params[0], e.params.at(-1)), i = Math.max(...n) - Math.min(...n);
      if (i === 0)
        return this.values[0];
      const s = i / (r.end - r.start);
      return this.values[Math.floor(s * 10 / 2)];
    }
  },
  xDuration: {
    values: ["<25", ">=25"],
    cats: ["BigJump", "BigFall"],
    fn(e, t) {
      return (e.params.at(-1) - 1 - e.params[0]) / (t.length - 1) >= 0.25 ? this.values[1] : this.values[0];
    }
  },
  bigSlope: {
    values: ["<60", ">=60"],
    cats: ["BigJump", "BigFall"],
    fn(e, t, r) {
      const n = t.slice(e.params[0], e.params.at(-1));
      return Math.abs(pV(n, r)) >= 60 ? this.values[1] : this.values[0];
    }
  }
};
function dV(e, t) {
  const r = {};
  for (const [n, i] of Object.entries(FP))
    r[n] = i.fn(e, t);
  return r;
}
function fV(e, t, r) {
  const n = {};
  for (const [i, s] of Object.entries($P))
    (s.cats === void 0 || s.cats.includes(e.category)) && (n[i] = s.fn(e, t, r));
  return n;
}
function gV(e) {
  const t = {};
  for (const r of e) {
    const n = r.category;
    t[n] || (t[n] = []), t[n].push(r);
  }
  return t;
}
let mV = class {
  constructor(t, r, n, i) {
    mi(this, "cands"), mi(this, "net", new cV()), mi(this, "root"), mi(this, "catNodes", {}), mi(this, "hasSugNodes", {}), mi(this, "candNodes", {}), mi(this, "genEvidNodes", {}), mi(this, "candEvidNodes", {}), this.msgEx = t, this.line = r, this.yAxis = i, this.cands = gV(n), this.root = this.net.newNode("root", this.msgEx.cats), this.root.setCpt(this.msgEx.catPriors);
  }
  build() {
    this.createGeneralEvidenceNodes(), this.createCategoryNodes();
    for (const t of this.msgEx.cats) {
      const r = this.net.newNode(`${t}.hasSug`, ["true", "false"]);
      this.hasSugNodes[t] = r, r.addParent(t);
      const n = this.msgEx.catPHasSug[t];
      r.setCpt([
        [1, 0],
        // p(hasSug=T|cat=T), p(hasSug=F|cat=T)
        [n, 1 - n]
        // p(hasSug=T|cat=F), p(hasSug=F|cat=F) 
      ]);
    }
    for (const t of Object.keys(this.cands).sort()) {
      this.createCandidateNodes(t);
      const r = this.candNodes[t];
      this.candEvidNodes[t] = [];
      for (let n = 0; n < r.length; n++)
        this.createCandidateEvidenceNodes(t, n);
    }
  }
  createGeneralEvidenceNodes() {
    for (const [t, r] of Object.entries(FP))
      this.genEvidNodes[t] = this.net.newNode(t, r.values);
    for (const [t, r] of Object.entries(this.genEvidNodes))
      r.addParent(this.root.name), r.setCpt([
        ...this.root.values.map((n) => r.values.map((i) => this.msgEx.catProbs[n].general.density[i]))
        // p(density=val|root=cat)
      ]);
  }
  createCategoryNodes() {
    for (const t of this.msgEx.cats) {
      const r = this.net.newNode(t, ["true", "false"]);
      r.addParent(this.root.name), r.setCpt(this.msgEx.cats.map((n) => n === t ? [1, 0] : [0, 1])), this.catNodes[t] = r;
    }
  }
  createCandidateNodes(t) {
    const r = [];
    this.catNodes[t];
    const n = this.cands[t];
    for (let i = 0; i < n.length; i++) {
      n[i];
      const s = this.net.newNode(`${t}.cand${i}`, ["true", "false"]);
      r.push(s), s.addParent(t);
      for (let l = 0; l < i; l++)
        s.addParent(r[l].name);
      const o = [], a = 2 ** s.parents.length;
      for (let l = 0; l < a; l++)
        l === a / 2 - 1 ? o.push([
          // I'm making the assumption that, given no evidence,
          // all candidates for a particular message are equally likely
          // (given that message=T)
          1 / (n.length - i),
          (n.length - (i + 1)) / (n.length - i)
        ]) : o.push([0, 1]);
      s.setCpt(o);
    }
    this.candNodes[t] = r;
  }
  createCandidateEvidenceNodes(t, r) {
    const n = this.candNodes[t][r], i = {};
    for (const [s, o] of Object.entries($P))
      (o.cats === void 0 || o.cats.includes(t)) && (i[s] = this.net.newNode(`${t}.cand${r}.${s}`, o.values));
    for (const [s, o] of Object.entries(i)) {
      o.addParent(n.name);
      const a = this.msgEx.catProbs[t].cand[s];
      o.setCpt([
        o.values.map((l) => a[l][0]),
        // p(evid=val|inPlan)
        o.values.map((l) => a[l][1])
        // p(evid=val|notInPlan)
      ]);
    }
    this.candEvidNodes[t].push(i);
  }
  observeEvidence() {
    var t;
    for (const n of this.msgEx.cats)
      this.hasSugNodes[n].observe(this.cands[n] ? "true" : "false"), (t = this.candEvidNodes[n]) == null || t.forEach((i, s) => {
        const o = this.cands[n][s], a = fV(o, this.line, this.yAxis);
        for (const [l, c] of Object.entries(i))
          c.observe(a[l]);
      });
    const r = dV(this.line, this.yAxis);
    for (const [n, i] of Object.entries(this.genEvidNodes))
      i.observe(r[n]);
  }
  async updateProbs(t = !0) {
    t ? await this.net.sampleWithWorker(1e4) : this.net.sample(1e4);
  }
  getSelectedCat() {
    let t = 0, r = 0;
    const n = this.root.probs();
    for (let i = 0; i < this.root.values.length; i++)
      n[i] > t && (t = n[i], r = i);
    return this.root.values[r];
  }
  getSelectedCand(t) {
    const r = this.candNodes[t];
    if (r === void 0)
      return;
    let n = 0, i = 0;
    for (let s = 0; s < r.length; s++) {
      const o = r[s].probs();
      o[0] > n && (n = o[0], i = s);
    }
    return i;
  }
  getPrediction() {
    const t = this.getSelectedCat(), r = this.getSelectedCand(t);
    if (r !== void 0)
      return { cand: this.cands[t][r], idx: r };
  }
}, yV = class {
  /**
   * @param model - Optional statistical data used by the Bayesian network (or ID thereof)
   */
  constructor(t) {
    if (mi(this, "modelData"), mi(this, "cats"), mi(this, "catPriors"), mi(this, "catPHasSug"), mi(this, "catProbs"), typeof t == "string" || t === void 0) {
      const r = vV(t);
      if (!r)
        throw new Error(`unknown model ID '${t}'`);
      this.modelData = r;
    } else
      this.modelData = t;
    this.cats = Object.keys(this.modelData).sort(), this.catPriors = this.cats.map((r) => this.modelData[r].prior), this.catPHasSug = Object.fromEntries(this.cats.map((r) => [r, this.modelData[r].hasSug])), this.catProbs = Object.fromEntries(this.cats.map((r) => [r, this.modelData[r].probs]));
  }
  /**
   * Select the most likely (i.e., most important section) of a line.
   * @param line - Line to analyze (in its original coordinate system)
   * @param candidates - All candidate messages (as generated by 
   * chart-message-candidates#genCandidates())
   * @param yAxis - Optional displayed chart y-axis value range;
   * defaults to extreme values of data
   * @param useWorker - Do prediction in a Web Worker
   * @returns Selected candidate object and index of said candidate with
   * respect to all candidates of its type, or undefined if the model
   * failed to make a valid prediction.
   * @remarks
   * The machine learning analysis performed by this method is now
   * offloaded to a worker thread, so the result can be usefully obtained
   * asynchronously via a `.then()` callback on the returned promise.
   */
  async chooseMessage(t, r, n, i = !0) {
    if (r.length === 1)
      return { cand: r[0], idx: 0 };
    const s = new mV(this, t, r, n);
    return s.build(), s.observeEvidence(), await s.updateProbs(i), s.getPrediction();
  }
  /*buildNet(series: number[], candidates: Candidate[]) {
    const net = new BayesNet(this, series, candidates);
    net.build();
    return net;
  }*/
  /*netToTree(net: JGraph): TreeNode {
    const nodes: {[index: string]: TreeNode} = {};
    function newTreeNode(jnode: JNode) {
      const tn: TreeNode = {
        name: jnode.name,
        prob: 0
      };
      if (jnode.values[0] === 'true') {
        tn.values = jnode.values;
        tn.prob = jnode.probs();
      } else {
        tn.values = jnode.values;
        tn.prob = jnode.probs();
      }
      return tn;
    }
    for (const node of net.nodes) {
      if (node.name === 'TempJump') {
        console.log('TempJump', node, node.probs());
      }
      if (!nodes[node.name]) {
        nodes[node.name] = newTreeNode(node);
      }
      const treeNode = nodes[node.name];
      for (const p of node.parents) {
        if (!nodes[p.name]) {
          nodes[p.name] = newTreeNode(p);
        }
        if (!nodes[p.name].children) {
          nodes[p.name].children = [];
        }
        nodes[p.name].children!.push(treeNode);
      }
    }
    return nodes['root'];
  }*/
};
const zP = {
  "18b7ef6b98c": {
    trainDataName: "cm3_reconc_jf",
    model: {
      Rise: {
        prior: 0.05333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.8125,
                0
              ],
              "<20": [
                0,
                0.4180790960451977
              ],
              ">=20": [
                0.125,
                0.3220338983050847
              ],
              ">=40": [
                0,
                0.14689265536723164
              ],
              ">=60": [
                0.0625,
                0.0847457627118644
              ],
              ">=80": [
                0,
                0.02824858757062147
              ]
            },
            touchEnd: {
              yes: [
                0.9375,
                0.2514124293785311
              ],
              no: [
                0.0625,
                0.748587570621469
              ]
            },
            lastLength: {
              "<20": [
                0,
                0.4180790960451977
              ],
              ">=20": [
                1,
                0.5819209039548022
              ]
            },
            volatility: {
              low: [
                0.3125,
                0.5084745762711864
              ],
              med: [
                0.6875,
                0.423728813559322
              ],
              high: [
                0,
                0.06779661016949153
              ]
            },
            yScale: {
              100: [
                0.4375,
                0.0480225988700565
              ],
              "<20": [
                0,
                0.17231638418079095
              ],
              ">=20": [
                0.0625,
                0.2570621468926554
              ],
              ">=40": [
                0.3125,
                0.268361581920904
              ],
              ">=60": [
                0.125,
                0.12146892655367232
              ],
              ">=80": [
                0.0625,
                0.1327683615819209
              ]
            }
          }
        },
        hasSug: 0.7640845070422535
      },
      Fall: {
        prior: 0.07,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.7619047619047619,
                0.005633802816901409
              ],
              "<20": [
                0,
                0.4788732394366197
              ],
              ">=20": [
                0.09523809523809523,
                0.27323943661971833
              ],
              ">=40": [
                0.09523809523809523,
                0.14366197183098592
              ],
              ">=60": [
                0,
                0.05352112676056338
              ],
              ">=80": [
                0.047619047619047616,
                0.04507042253521127
              ]
            },
            touchEnd: {
              yes: [
                0.9523809523809523,
                0.2619718309859155
              ],
              no: [
                0.047619047619047616,
                0.7380281690140845
              ]
            },
            lastLength: {
              "<20": [
                0,
                0.4788732394366197
              ],
              ">=20": [
                1,
                0.5211267605633803
              ]
            },
            volatility: {
              low: [
                0.3333333333333333,
                0.5183098591549296
              ],
              med: [
                0.5714285714285714,
                0.38591549295774646
              ],
              high: [
                0.09523809523809523,
                0.09577464788732394
              ]
            },
            yScale: {
              100: [
                0.5714285714285714,
                0.07323943661971831
              ],
              "<20": [
                0,
                0.17746478873239438
              ],
              ">=20": [
                0.09523809523809523,
                0.29014084507042254
              ],
              ">=40": [
                0.23809523809523808,
                0.23380281690140844
              ],
              ">=60": [
                0.047619047619047616,
                0.11549295774647887
              ],
              ">=80": [
                0.047619047619047616,
                0.10985915492957747
              ]
            }
          }
        },
        hasSug: 0.8028673835125448
      },
      Stable: {
        prior: 0.03333333333333333,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.5,
                0
              ],
              "<20": [
                0,
                0.12962962962962962
              ],
              ">=20": [
                0.2,
                0.2962962962962963
              ],
              ">=40": [
                0,
                0.3194444444444444
              ],
              ">=60": [
                0.2,
                0.14351851851851852
              ],
              ">=80": [
                0.1,
                0.1111111111111111
              ]
            },
            touchEnd: {
              yes: [
                1,
                0.48148148148148145
              ],
              no: [
                0,
                0.5185185185185185
              ]
            },
            lastLength: {
              "<20": [
                0,
                0.12962962962962962
              ],
              ">=20": [
                1,
                0.8703703703703703
              ]
            },
            volatility: {
              low: [
                0.5,
                0.5972222222222222
              ],
              med: [
                0,
                0.37037037037037035
              ],
              high: [
                0.5,
                0.032407407407407406
              ]
            },
            yScale: {
              100: [
                0,
                0.004629629629629629
              ],
              "<20": [
                0.5,
                0.7870370370370371
              ],
              ">=20": [
                0.2,
                0.17592592592592593
              ],
              ">=40": [
                0.3,
                0.027777777777777776
              ],
              ">=60": [
                0,
                0.004629629629629629
              ],
              ">=80": [
                0,
                0
              ]
            }
          }
        },
        hasSug: 0.6206896551724138
      },
      BigJump: {
        prior: 0.006666666666666667,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0
              ],
              "<20": [
                1,
                0.4431818181818182
              ],
              ">=20": [
                0,
                0.32954545454545453
              ],
              ">=40": [
                0,
                0.12878787878787878
              ],
              ">=60": [
                0,
                0.06439393939393939
              ],
              ">=80": [
                0,
                0.03409090909090909
              ]
            },
            touchEnd: {
              yes: [
                0,
                0
              ],
              no: [
                1,
                1
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.4431818181818182
              ],
              ">=20": [
                0,
                0.5568181818181818
              ]
            },
            volatility: {
              low: [
                1,
                0.4659090909090909
              ],
              med: [
                0,
                0.45454545454545453
              ],
              high: [
                0,
                0.07954545454545454
              ]
            },
            yScale: {
              100: [
                0,
                0.06439393939393939
              ],
              "<20": [
                0,
                0.125
              ],
              ">=20": [
                0,
                0.26515151515151514
              ],
              ">=40": [
                0,
                0.2840909090909091
              ],
              ">=60": [
                0,
                0.14393939393939395
              ],
              ">=80": [
                1,
                0.11742424242424243
              ]
            },
            xDuration: {
              "<25": [
                1,
                0.5984848484848485
              ],
              ">=25": [
                0,
                0.4015151515151515
              ]
            },
            bigSlope: {
              "<60": [
                1,
                0.4734848484848485
              ],
              ">=60": [
                0,
                0.5265151515151515
              ]
            }
          }
        },
        hasSug: 0.6442953020134228
      },
      BigFall: {
        prior: 0.02666666666666667,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0
              ],
              "<20": [
                0.75,
                0.5568627450980392
              ],
              ">=20": [
                0.25,
                0.2549019607843137
              ],
              ">=40": [
                0,
                0.13725490196078433
              ],
              ">=60": [
                0,
                0.03529411764705882
              ],
              ">=80": [
                0,
                0.01568627450980392
              ]
            },
            touchEnd: {
              yes: [
                0,
                0
              ],
              no: [
                1,
                1
              ]
            },
            lastLength: {
              "<20": [
                0.75,
                0.5568627450980392
              ],
              ">=20": [
                0.25,
                0.44313725490196076
              ]
            },
            volatility: {
              low: [
                0.5,
                0.47058823529411764
              ],
              med: [
                0.25,
                0.41568627450980394
              ],
              high: [
                0.25,
                0.11372549019607843
              ]
            },
            yScale: {
              100: [
                0.375,
                0.0784313725490196
              ],
              "<20": [
                0,
                0.09019607843137255
              ],
              ">=20": [
                0,
                0.3137254901960784
              ],
              ">=40": [
                0,
                0.25098039215686274
              ],
              ">=60": [
                0,
                0.1411764705882353
              ],
              ">=80": [
                0.625,
                0.12549019607843137
              ]
            },
            xDuration: {
              "<25": [
                0.875,
                0.6627450980392157
              ],
              ">=25": [
                0.125,
                0.33725490196078434
              ]
            },
            bigSlope: {
              "<60": [
                0.5,
                0.5294117647058824
              ],
              ">=60": [
                0.5,
                0.47058823529411764
              ]
            }
          }
        },
        hasSug: 0.6506849315068494
      },
      ReversalToRise: {
        prior: 0.07,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.3333333333333333,
                0.03289473684210526
              ],
              "<20": [
                0.047619047619047616,
                0.125
              ],
              ">=20": [
                0.2857142857142857,
                0.375
              ],
              ">=40": [
                0.09523809523809523,
                0.2565789473684211
              ],
              ">=60": [
                0.047619047619047616,
                0.16447368421052633
              ],
              ">=80": [
                0.19047619047619047,
                0.046052631578947366
              ]
            },
            touchEnd: {
              yes: [
                0.5238095238095238,
                0.32894736842105265
              ],
              no: [
                0.47619047619047616,
                0.6710526315789473
              ]
            },
            lastLength: {
              "<20": [
                0.3333333333333333,
                0.5263157894736842
              ],
              ">=20": [
                0.6666666666666666,
                0.47368421052631576
              ]
            },
            volatility: {
              low: [
                0.3333333333333333,
                0.48026315789473684
              ],
              med: [
                0.5238095238095238,
                0.5131578947368421
              ],
              high: [
                0.14285714285714285,
                0.006578947368421052
              ]
            },
            yScale: {
              100: [
                0.2857142857142857,
                0.15789473684210525
              ],
              "<20": [
                0,
                0.006578947368421052
              ],
              ">=20": [
                0.09523809523809523,
                0.2236842105263158
              ],
              ">=40": [
                0.3333333333333333,
                0.26973684210526316
              ],
              ">=60": [
                0.09523809523809523,
                0.19736842105263158
              ],
              ">=80": [
                0.19047619047619047,
                0.14473684210526316
              ]
            }
          }
        },
        hasSug: 0.4014336917562724
      },
      ReversalToFall: {
        prior: 0.07,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.42857142857142855,
                0.047337278106508875
              ],
              "<20": [
                0.14285714285714285,
                0.11242603550295859
              ],
              ">=20": [
                0.09523809523809523,
                0.38461538461538464
              ],
              ">=40": [
                0.14285714285714285,
                0.27218934911242604
              ],
              ">=60": [
                0.09523809523809523,
                0.13609467455621302
              ],
              ">=80": [
                0.09523809523809523,
                0.047337278106508875
              ]
            },
            touchEnd: {
              yes: [
                0.6666666666666666,
                0.23076923076923078
              ],
              no: [
                0.3333333333333333,
                0.7692307692307693
              ]
            },
            lastLength: {
              "<20": [
                0.23809523809523808,
                0.6035502958579881
              ],
              ">=20": [
                0.7619047619047619,
                0.39644970414201186
              ]
            },
            volatility: {
              low: [
                0.2857142857142857,
                0.4378698224852071
              ],
              med: [
                0.6666666666666666,
                0.5325443786982249
              ],
              high: [
                0.047619047619047616,
                0.029585798816568046
              ]
            },
            yScale: {
              100: [
                0.23809523809523808,
                0.13609467455621302
              ],
              "<20": [
                0,
                0.01775147928994083
              ],
              ">=20": [
                0.14285714285714285,
                0.1952662721893491
              ],
              ">=40": [
                0.3333333333333333,
                0.3136094674556213
              ],
              ">=60": [
                0.09523809523809523,
                0.1952662721893491
              ],
              ">=80": [
                0.19047619047619047,
                0.14201183431952663
              ]
            }
          }
        },
        hasSug: 0.44802867383512546
      },
      EmergingRise: {
        prior: 0.09333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.75,
                0.027777777777777776
              ],
              "<20": [
                0,
                0.08333333333333333
              ],
              ">=20": [
                0,
                0.25
              ],
              ">=40": [
                0.10714285714285714,
                0.3611111111111111
              ],
              ">=60": [
                0.10714285714285714,
                0.25
              ],
              ">=80": [
                0.03571428571428571,
                0.027777777777777776
              ]
            },
            touchEnd: {
              yes: [
                0.9642857142857143,
                0.08333333333333333
              ],
              no: [
                0.03571428571428571,
                0.9166666666666666
              ]
            },
            lastLength: {
              "<20": [
                0.07142857142857142,
                0.5555555555555556
              ],
              ">=20": [
                0.9285714285714286,
                0.4444444444444444
              ]
            },
            volatility: {
              low: [
                0.7142857142857143,
                0.5
              ],
              med: [
                0.2857142857142857,
                0.4722222222222222
              ],
              high: [
                0,
                0.027777777777777776
              ]
            },
            yScale: {
              100: [
                0.35714285714285715,
                0.1111111111111111
              ],
              "<20": [
                0,
                0.05555555555555555
              ],
              ">=20": [
                0.10714285714285714,
                0.16666666666666666
              ],
              ">=40": [
                0.42857142857142855,
                0.25
              ],
              ">=60": [
                0.03571428571428571,
                0.19444444444444445
              ],
              ">=80": [
                0.07142857142857142,
                0.2222222222222222
              ]
            }
          }
        },
        hasSug: 0.11397058823529412
      },
      EmergingFall: {
        prior: 0.05333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.4375,
                0
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.0625,
                0.16129032258064516
              ],
              ">=40": [
                0.1875,
                0.41935483870967744
              ],
              ">=60": [
                0.0625,
                0.22580645161290322
              ],
              ">=80": [
                0.25,
                0.1935483870967742
              ]
            },
            touchEnd: {
              yes: [
                0.875,
                0.1935483870967742
              ],
              no: [
                0.125,
                0.8064516129032258
              ]
            },
            lastLength: {
              "<20": [
                0.1875,
                0.6451612903225806
              ],
              ">=20": [
                0.8125,
                0.3548387096774194
              ]
            },
            volatility: {
              low: [
                0.5,
                0.5483870967741935
              ],
              med: [
                0.5,
                0.45161290322580644
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.125,
                0.22580645161290322
              ],
              "<20": [
                0,
                0.0967741935483871
              ],
              ">=20": [
                0.3125,
                0.22580645161290322
              ],
              ">=40": [
                0.375,
                0.25806451612903225
              ],
              ">=60": [
                0.125,
                0.0967741935483871
              ],
              ">=80": [
                0.0625,
                0.0967741935483871
              ]
            }
          }
        },
        hasSug: 0.1056338028169014
      },
      RiseToStable: {
        prior: 0.07333333333333333,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.45454545454545453,
                0.05263157894736842
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.045454545454545456,
                0.3157894736842105
              ],
              ">=40": [
                0.09090909090909091,
                0.34210526315789475
              ],
              ">=60": [
                0.13636363636363635,
                0.15789473684210525
              ],
              ">=80": [
                0.2727272727272727,
                0.13157894736842105
              ]
            },
            touchEnd: {
              yes: [
                0.9090909090909091,
                0.4473684210526316
              ],
              no: [
                0.09090909090909091,
                0.5526315789473685
              ]
            },
            lastLength: {
              "<20": [
                0.045454545454545456,
                0.23684210526315788
              ],
              ">=20": [
                0.9545454545454546,
                0.7631578947368421
              ]
            },
            volatility: {
              low: [
                0.5,
                0.631578947368421
              ],
              med: [
                0.5,
                0.3684210526315789
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.22727272727272727,
                0.10526315789473684
              ],
              "<20": [
                0.045454545454545456,
                0.05263157894736842
              ],
              ">=20": [
                0.13636363636363635,
                0.34210526315789475
              ],
              ">=40": [
                0.36363636363636365,
                0.3157894736842105
              ],
              ">=60": [
                0.13636363636363635,
                0.10526315789473684
              ],
              ">=80": [
                0.09090909090909091,
                0.07894736842105263
              ]
            }
          }
        },
        hasSug: 0.12589928057553956
      },
      FallToStable: {
        prior: 0.17333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.4807692307692308,
                0.16666666666666666
              ],
              "<20": [
                0,
                0.027777777777777776
              ],
              ">=20": [
                0,
                0.19444444444444445
              ],
              ">=40": [
                0.057692307692307696,
                0.2777777777777778
              ],
              ">=60": [
                0.19230769230769232,
                0.19444444444444445
              ],
              ">=80": [
                0.2692307692307692,
                0.1388888888888889
              ]
            },
            touchEnd: {
              yes: [
                0.9807692307692307,
                0.5833333333333334
              ],
              no: [
                0.019230769230769232,
                0.4166666666666667
              ]
            },
            lastLength: {
              "<20": [
                0.019230769230769232,
                0.1111111111111111
              ],
              ">=20": [
                0.9807692307692307,
                0.8888888888888888
              ]
            },
            volatility: {
              low: [
                0.3269230769230769,
                0.6111111111111112
              ],
              med: [
                0.6730769230769231,
                0.3611111111111111
              ],
              high: [
                0,
                0.027777777777777776
              ]
            },
            yScale: {
              100: [
                0.25,
                0.19444444444444445
              ],
              "<20": [
                0,
                0.08333333333333333
              ],
              ">=20": [
                0.15384615384615385,
                0.3055555555555556
              ],
              ">=40": [
                0.4423076923076923,
                0.16666666666666666
              ],
              ">=60": [
                0.11538461538461539,
                0.1388888888888889
              ],
              ">=80": [
                0.038461538461538464,
                0.1111111111111111
              ]
            }
          }
        },
        hasSug: 0.14112903225806453
      },
      Rebound: {
        prior: 0.10333333333333333,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.22580645161290322,
                0.09090909090909091
              ],
              "<20": [
                0,
                0.015151515151515152
              ],
              ">=20": [
                0.06451612903225806,
                0.22727272727272727
              ],
              ">=40": [
                0.16129032258064516,
                0.3333333333333333
              ],
              ">=60": [
                0.3225806451612903,
                0.24242424242424243
              ],
              ">=80": [
                0.22580645161290322,
                0.09090909090909091
              ]
            },
            touchEnd: {
              yes: [
                0.6774193548387096,
                0.3333333333333333
              ],
              no: [
                0.3225806451612903,
                0.6666666666666666
              ]
            },
            lastLength: {
              "<20": [
                0.2903225806451613,
                0.6515151515151515
              ],
              ">=20": [
                0.7096774193548387,
                0.3484848484848485
              ]
            },
            volatility: {
              low: [
                0.5483870967741935,
                0.42424242424242425
              ],
              med: [
                0.45161290322580644,
                0.5606060606060606
              ],
              high: [
                0,
                0.015151515151515152
              ]
            },
            yScale: {
              100: [
                0.3548387096774194,
                0.2878787878787879
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.10606060606060606
              ],
              ">=40": [
                0.2903225806451613,
                0.25757575757575757
              ],
              ">=60": [
                0.16129032258064516,
                0.16666666666666666
              ],
              ">=80": [
                0.1935483870967742,
                0.18181818181818182
              ]
            }
          }
        },
        hasSug: 0.17472118959107807
      },
      TemporaryJump: {
        prior: 0.056666666666666664,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.35294117647058826,
                0.09230769230769231
              ],
              "<20": [
                0,
                0.046153846153846156
              ],
              ">=20": [
                0.11764705882352941,
                0.2153846153846154
              ],
              ">=40": [
                0.17647058823529413,
                0.3384615384615385
              ],
              ">=60": [
                0.058823529411764705,
                0.16923076923076924
              ],
              ">=80": [
                0.29411764705882354,
                0.13846153846153847
              ]
            },
            touchEnd: {
              yes: [
                0.8823529411764706,
                0.26153846153846155
              ],
              no: [
                0.11764705882352941,
                0.7384615384615385
              ]
            },
            lastLength: {
              "<20": [
                0.23529411764705882,
                0.6153846153846154
              ],
              ">=20": [
                0.7647058823529411,
                0.38461538461538464
              ]
            },
            volatility: {
              low: [
                0.4117647058823529,
                0.4153846153846154
              ],
              med: [
                0.5882352941176471,
                0.5538461538461539
              ],
              high: [
                0,
                0.03076923076923077
              ]
            },
            yScale: {
              100: [
                0.47058823529411764,
                0.3076923076923077
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.12307692307692308
              ],
              ">=40": [
                0.17647058823529413,
                0.2
              ],
              ">=60": [
                0.23529411764705882,
                0.12307692307692308
              ],
              ">=80": [
                0.11764705882352941,
                0.24615384615384617
              ]
            }
          }
        },
        hasSug: 0.16607773851590105
      },
      PossibleReversalToRise: {
        prior: 0.013333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.25,
                0.19298245614035087
              ],
              "<20": [
                0.25,
                0.05263157894736842
              ],
              ">=20": [
                0.25,
                0.2631578947368421
              ],
              ">=40": [
                0,
                0.2807017543859649
              ],
              ">=60": [
                0.25,
                0.10526315789473684
              ],
              ">=80": [
                0,
                0.10526315789473684
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                0.75,
                0.3684210526315789
              ],
              ">=20": [
                0.25,
                0.631578947368421
              ]
            },
            volatility: {
              low: [
                0.75,
                0.5087719298245614
              ],
              med: [
                0.25,
                0.45614035087719296
              ],
              high: [
                0,
                0.03508771929824561
              ]
            },
            yScale: {
              100: [
                0,
                0.10526315789473684
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.25,
                0.21052631578947367
              ],
              ">=40": [
                0.5,
                0.3684210526315789
              ],
              ">=60": [
                0.25,
                0.2631578947368421
              ],
              ">=80": [
                0,
                0.05263157894736842
              ]
            }
          }
        },
        hasSug: 0.19256756756756757
      },
      PossibleReversalToFall: {
        prior: 0.02,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                1,
                0.23404255319148937
              ],
              "<20": [
                0,
                0.02127659574468085
              ],
              ">=20": [
                0,
                0.2553191489361702
              ],
              ">=40": [
                0,
                0.2553191489361702
              ],
              ">=60": [
                0,
                0.1276595744680851
              ],
              ">=80": [
                0,
                0.10638297872340426
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                0.8333333333333334,
                0.23404255319148937
              ],
              ">=20": [
                0.16666666666666666,
                0.7659574468085106
              ]
            },
            volatility: {
              low: [
                0.6666666666666666,
                0.48936170212765956
              ],
              med: [
                0.3333333333333333,
                0.5106382978723404
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.16666666666666666,
                0.19148936170212766
              ],
              "<20": [
                0,
                0.02127659574468085
              ],
              ">=20": [
                0,
                0.1702127659574468
              ],
              ">=40": [
                0.6666666666666666,
                0.40425531914893614
              ],
              ">=60": [
                0.16666666666666666,
                0.14893617021276595
              ],
              ">=80": [
                0,
                0.06382978723404255
              ]
            }
          }
        },
        hasSug: 0.1598639455782313
      },
      PossibleEmergingRise: {
        prior: 0.0033333333333333335,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0.7586206896551724
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0
              ],
              ">=40": [
                0,
                0.13793103448275862
              ],
              ">=60": [
                1,
                0.06896551724137931
              ],
              ">=80": [
                0,
                0.034482758620689655
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.06896551724137931
              ],
              ">=20": [
                0,
                0.9310344827586207
              ]
            },
            volatility: {
              low: [
                1,
                0.7241379310344828
              ],
              med: [
                0,
                0.2413793103448276
              ],
              high: [
                0,
                0.034482758620689655
              ]
            },
            yScale: {
              100: [
                0,
                0.3793103448275862
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                1,
                0.10344827586206896
              ],
              ">=40": [
                0,
                0.4482758620689655
              ],
              ">=60": [
                0,
                0.034482758620689655
              ],
              ">=80": [
                0,
                0.034482758620689655
              ]
            }
          }
        },
        hasSug: 0.09698996655518395
      },
      PossibleEmergingFall: {
        prior: 0.006666666666666667,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0.3888888888888889
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.5,
                0.05555555555555555
              ],
              ">=40": [
                0,
                0.2777777777777778
              ],
              ">=60": [
                0,
                0.1111111111111111
              ],
              ">=80": [
                0.5,
                0.16666666666666666
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.2222222222222222
              ],
              ">=20": [
                0,
                0.7777777777777778
              ]
            },
            volatility: {
              low: [
                1,
                0.6666666666666666
              ],
              med: [
                0,
                0.3333333333333333
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0,
                0.1111111111111111
              ],
              "<20": [
                0.5,
                0.1111111111111111
              ],
              ">=20": [
                0.5,
                0.2777777777777778
              ],
              ">=40": [
                0,
                0.2777777777777778
              ],
              ">=60": [
                0,
                0.16666666666666666
              ],
              ">=80": [
                0,
                0.05555555555555555
              ]
            }
          }
        },
        hasSug: 0.06040268456375839
      },
      PossibleRiseToStable: {
        prior: 0.01,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.3333333333333333,
                0.3235294117647059
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.17647058823529413
              ],
              ">=40": [
                0.3333333333333333,
                0.17647058823529413
              ],
              ">=60": [
                0,
                0.20588235294117646
              ],
              ">=80": [
                0.3333333333333333,
                0.11764705882352941
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                0.3333333333333333,
                0.14705882352941177
              ],
              ">=20": [
                0.6666666666666666,
                0.8529411764705882
              ]
            },
            volatility: {
              low: [
                0.6666666666666666,
                0.5294117647058824
              ],
              med: [
                0.3333333333333333,
                0.47058823529411764
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.3333333333333333,
                0.17647058823529413
              ],
              "<20": [
                0,
                0.029411764705882353
              ],
              ">=20": [
                0.3333333333333333,
                0.20588235294117646
              ],
              ">=40": [
                0,
                0.38235294117647056
              ],
              ">=60": [
                0.3333333333333333,
                0.08823529411764706
              ],
              ">=80": [
                0,
                0.11764705882352941
              ]
            }
          }
        },
        hasSug: 0.11447811447811448
      },
      PossibleFallToStable: {
        prior: 0.0033333333333333335,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                1,
                0.4225352112676056
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.028169014084507043
              ],
              ">=40": [
                0,
                0.11267605633802817
              ],
              ">=60": [
                0,
                0.18309859154929578
              ],
              ">=80": [
                0,
                0.2535211267605634
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.04225352112676056
              ],
              ">=20": [
                0,
                0.9577464788732394
              ]
            },
            volatility: {
              low: [
                1,
                0.4084507042253521
              ],
              med: [
                0,
                0.5774647887323944
              ],
              high: [
                0,
                0.014084507042253521
              ]
            },
            yScale: {
              100: [
                1,
                0.2535211267605634
              ],
              "<20": [
                0,
                0.028169014084507043
              ],
              ">=20": [
                0,
                0.19718309859154928
              ],
              ">=40": [
                0,
                0.36619718309859156
              ],
              ">=60": [
                0,
                0.11267605633802817
              ],
              ">=80": [
                0,
                0.04225352112676056
              ]
            }
          }
        },
        hasSug: 0.23745819397993312
      },
      PossibleRebound: {
        prior: 0.043333333333333335,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.23076923076923078,
                0.3333333333333333
              ],
              "<20": [
                0.07692307692307693,
                0
              ],
              ">=20": [
                0.15384615384615385,
                0.06666666666666667
              ],
              ">=40": [
                0.38461538461538464,
                0.23333333333333334
              ],
              ">=60": [
                0.15384615384615385,
                0.16666666666666666
              ],
              ">=80": [
                0,
                0.2
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.23333333333333334
              ],
              ">=20": [
                0,
                0.7666666666666667
              ]
            },
            volatility: {
              low: [
                0.38461538461538464,
                0.5666666666666667
              ],
              med: [
                0.6153846153846154,
                0.43333333333333335
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.15384615384615385,
                0.3
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.07692307692307693,
                0.03333333333333333
              ],
              ">=40": [
                0.15384615384615385,
                0.3333333333333333
              ],
              ">=60": [
                0.46153846153846156,
                0.16666666666666666
              ],
              ">=80": [
                0.15384615384615385,
                0.16666666666666666
              ]
            }
          }
        },
        hasSug: 0.10452961672473868
      },
      PossibleTemporaryJump: {
        prior: 0.016666666666666666,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.2,
                0.4074074074074074
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.2,
                0.037037037037037035
              ],
              ">=40": [
                0,
                0.2222222222222222
              ],
              ">=60": [
                0.4,
                0.07407407407407407
              ],
              ">=80": [
                0.2,
                0.25925925925925924
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.2222222222222222
              ],
              ">=20": [
                0,
                0.7777777777777778
              ]
            },
            volatility: {
              low: [
                0.2,
                0.5185185185185185
              ],
              med: [
                0.8,
                0.48148148148148145
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.4,
                0.5185185185185185
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.037037037037037035
              ],
              ">=40": [
                0.6,
                0.14814814814814814
              ],
              ">=60": [
                0,
                0.14814814814814814
              ],
              ">=80": [
                0,
                0.14814814814814814
              ]
            }
          }
        },
        hasSug: 0.09152542372881356
      }
    }
  }
};
function bV() {
  return Object.keys(zP).sort();
}
function vV(e) {
  return zP[e ?? bV().at(-1)].model;
}
var wV = Object.defineProperty, xV = (e, t, r) => t in e ? wV(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, OS = (e, t, r) => (xV(e, typeof t != "symbol" ? t + "" : t, r), r);
function EV(e) {
  const t = e.points.map((i) => i.y), r = p6(t), n = d6(t);
  return {
    min: {
      value: r,
      labels: LS(e.points, r)
    },
    max: {
      value: n,
      labels: LS(e.points, n)
    },
    range: VP(e),
    mean: Pl(t),
    median: xz(t),
    mode: yz(t)
  };
}
function LS(e, t) {
  return e.filter((r) => r.y === t).map((r) => `${r.x}`);
}
function VP(e) {
  const t = e.points.map((r) => r.y);
  return d6(t) - p6(t);
}
function AV(e, t) {
  return (t.y - e.y) / (t.x - e.x);
}
function lm(e, t, r, n) {
  return n.range === 0 ? 1 : VP(e.slice(t, r)) / n.range;
}
function SV(e, t) {
  const r = Math.min(e.points[t].y, e.points[t + 1].y), n = e.points[t + 1].x - e.points[t].x, i = Math.max(e.points[t].y, e.points[t + 1].y) - r;
  return n * (r + 0.5 * i);
}
function cm(e, t, r, n) {
  if (t >= r)
    return 0;
  const i = e.slice(t, r), s = [];
  for (let A = 0; A < i.points.length; A++)
    s.push([i.points[A].x, i.points[A].y]);
  const o = 1 - fz(s, hz(h6(s))), a = [], l = [], c = i.yBounds().start, h = i.xBounds().start;
  for (let A = 0; A < i.points.length; A++)
    a.push((s[A][0] - h) * (i.points.length - 1) / i.xRange()), l.push((s[A][1] - c) / i.yRange());
  const u = [];
  for (let A = 1; A < s.length - 1; A++)
    u.push(((l[A + 1] - 2 * l[A] + l[A - 1]) / ((a[A] - a[A - 1]) * (a[A + 1] - a[A]))) ** 2);
  const p = u.reduce((A, x) => A + x, 0), y = i.length < 3 ? 0 : Math.atan(p / u.length) * 2 / Math.PI;
  let g = 0;
  for (let A = 0; A < s.length - 2; A++)
    (l[A + 2] - l[A + 1]) * (l[A + 1] - l[A]) < 0 && (g += 1);
  const b = g / (s.length - 2), f = Math.atan(i.length / 20) * 2 / Math.PI, E = [1 / 4, 1, 2, 3 / 4];
  return i.length < 3 ? 0 : (o * E[0] + y * E[1] + b * E[2] + f * E[3]) * i.yRange() / (4 * n.range);
}
function _V(e, t) {
  return e.slice(0, -1).points.map((r, n) => ({
    i: n,
    direction: Math.sign(AV(r, e.points[n + 1])) || 0,
    // convert any -0 to +0
    magnitude: lm(e, n, n + 2, t),
    area: SV(e, n)
  }));
}
function kV(e, t, r) {
  const n = [{ start: 0, direction: r[0].direction }];
  let i = n[0];
  for (let s = 1; s < r.length; s++) {
    const o = r[s].direction;
    o !== i.direction && (i.end = s + 1, i.magnitude = lm(e, i.start, i.end, t), i.volatility = cm(e, i.start, i.end, t), i.area = r.slice(i.start, i.end - 1).reduce((a, l) => a + l.area, 0), i = { start: s, direction: o }, n.push(i));
  }
  return i.end = r.length + 1, i.magnitude = lm(e, i.start, i.end, t), i.volatility = cm(e, i.start, i.end, t), i.area = r.slice(i.start, i.end - 1).reduce((s, o) => s + o.area, 0), n;
}
let CV = class {
  constructor() {
    OS(this, "bd"), OS(this, "mex"), this.bd = new Uz(), this.mex = new yV();
  }
  /**
   * Perform all analysis of a time series.
   * @param series - Time series
   * @param opts - Options (optional)
   * @returns Results of the series analysis
   * @remarks
   * The message determination machine learning analysis performed by this 
   * method is now offloaded to a worker thread, so the result can be usefully 
   * obtained asynchronously via a `.then()` callback on the returned promise.
   */
  async analyzeSeries(t, r) {
    const n = EV(t), i = _V(t, n), s = kV(t, n, i), o = async (y, g) => {
      const b = this.bd.getSequences(y, g);
      Zz(y, b);
      const { candidates: f, slopeInfo: E } = Xz(
        y,
        b,
        r == null ? void 0 : r.candStableAngleCutoff,
        r != null && r.cm2Compat ? 10 : void 0,
        g
      );
      return { msg: await this.mex.chooseMessage(y, f, g, r == null ? void 0 : r.useWorker), seqBounds: b, slopeInfo: E };
    }, { msg: a, seqBounds: l, slopeInfo: c } = await o(t, r == null ? void 0 : r.yAxis), h = a ? a.cand.category : null, u = l.map((y, g) => ({
      start: y.start,
      end: y.end,
      slopeInfo: c[g],
      magnitude: lm(t, y.start, y.end, n),
      volatility: cm(t, y.start, y.end, n),
      area: i.slice(y.start, y.end - 1).reduce((b, f) => b + f.area, 0)
    }));
    if (u.length === 1)
      u[0].message = h, u[0].messageStart = a ? 0 : null, u[0].messageEnd = a ? t.length : null;
    else
      for (const y of u) {
        const { msg: g } = await o(t.slice(y.start, y.end), r == null ? void 0 : r.yAxis);
        g ? (y.message = g.cand.category, y.messageStart = y.start + g.cand.params[0], y.messageEnd = y.start + g.cand.params.at(-1)) : (y.message = null, y.messageStart = null, y.messageEnd = null);
      }
    let p = [];
    if (a) {
      const y = a.cand.params.slice(0, -1);
      p = Array.from(u.keys()).filter(
        (g) => y.includes(u[g].start)
      );
    }
    return {
      stats: n,
      volatility: cm(t, 0, t.length, n),
      area: i.reduce((y, g) => y + g.area, 0),
      message: h,
      messageSeqs: p,
      // will be [] if message === null
      segments: i,
      runs: s,
      sequences: u
    };
  }
};
function hr(e) {
  let t, r, n;
  return t = e, (i, s, o) => {
    if (o.value != null)
      o.value = MS(o.value, t, r, n);
    else if (o.get != null)
      o.get = MS(o.get, t, r, n);
    else
      throw "Only put a Memoize() decorator on a method or get accessor.";
  };
}
const av = /* @__PURE__ */ new Map();
function MS(e, t, r = 0, n) {
  const i = Symbol("__memoized_map__");
  return function(...s) {
    let o;
    this.hasOwnProperty(i) || Object.defineProperty(this, i, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: /* @__PURE__ */ new Map()
    });
    let a = this[i];
    if (Array.isArray(n))
      for (const l of n)
        av.has(l) ? av.get(l).push(a) : av.set(l, [a]);
    if (t || s.length > 0 || r > 0) {
      let l;
      t === !0 ? l = s.map((u) => u.toString()).join("!") : t ? l = t.apply(this, s) : l = s[0];
      const c = `${l}__timestamp`;
      let h = !1;
      if (r > 0)
        if (!a.has(c))
          h = !0;
        else {
          let u = a.get(c);
          h = Date.now() - u > r;
        }
      a.has(l) && !h ? o = a.get(l) : (o = e.apply(this, s), a.set(l, o), r > 0 && a.set(c, Date.now()));
    } else {
      const l = this;
      a.has(l) ? o = a.get(l) : (o = e.apply(this, s), a.set(l, o));
    }
    return o;
  };
}
var UP = (e) => {
  throw TypeError(e);
}, HP = (e, t, r) => t.has(e) || UP("Cannot " + r), NS = (e, t, r) => (HP(e, t, "read from private field"), r ? r.call(e) : t.get(e)), DS = (e, t, r) => t.has(e) ? UP("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), BS = (e, t, r, n) => (HP(e, t, "write to private field"), t.set(e, r), r);
const um = "[a-fA-F0-9]", xp = "[a-zA-Z0-9-._~]", Os = "[!$&'()*+,;=]", zu = `%${um}${um}`, $g = "(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])", m6 = `${$g}\\.${$g}\\.${$g}\\.${$g}`, Sr = `${um}{1,4}`, jc = `(?:${Sr}:${Sr}|${m6})`, IV = `(?:(?:${Sr}:){6}${jc}|::(?:${Sr}:){5}${jc}|(?:${Sr})?::(?:${Sr}:){4}${jc}|(?:(?:${Sr}:){0,1}${Sr})?::(?:${Sr}:){3}${jc}|(?:(?:${Sr}:){0,2}${Sr})?::(?:${Sr}:){2}${jc}|(?:(?:${Sr}:){0,3}${Sr})?::(?:${Sr}:){1}${jc}|(?:(?:${Sr}:){0,4}${Sr})?::${jc}|(?:(?:${Sr}:){0,5}${Sr})?::${Sr}|(?:(?:${Sr}:){0,6}${Sr})?::)`, PV = `v${um}+\\.(?:${xp}|${Os}|:)+`, GP = `\\[(?:${IV}|${PV})\\]`, Ep = "(?<scheme>[a-zA-Z][a-zA-Z0-9-+.]*)", QP = ":(?<port>\\d*)", RV = `(?:${xp}|${zu}|${Os})*?`, TV = `(?<host>${GP}|${m6}|${RV})`, OV = `(?<userinfo>(?:${xp}|${zu}|${Os}|:)*)`, y6 = `(?:${xp}|${zu}|${Os}|:|@)`, WP = `${y6}*?`, qP = `(?:/${WP})*`, b6 = `(?<authority>(?:${OV}@)?${TV}(?:${QP})?)`, v6 = `(?<path>${qP})`, w6 = `(?<path2>${WP}${qP})`, x6 = `(?:\\?(?<query>(?:${y6}|/|\\?)*))?`, YP = `(?:#(?<fragment>(?:${y6}|/|\\?)*))?`, LV = `^${Ep}:(?://${b6}${v6}|${w6})${x6}${YP}$`, MV = `^(?:${Ep}:|)(?://${b6}${v6}|${w6})${x6}${YP}$`, NV = `^${Ep}:(?://${b6}${v6}|${w6})${x6}$`, x0 = "[a-zA-Z0-9-._~\\00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF\\u10000-\\u1FFFD\\u20000-\\u2FFFD\\u30000-\\u3FFFD\\u40000-\\u4FFFD\\u50000-\\u5FFFD\\u60000-\\u6FFFD\\u70000-\\u7FFFD\\u80000-\\u8FFFD\\u90000-\\u9FFFD\\uA0000-\\uAFFFD\\uB0000-\\uBFFFD\\uC0000-\\uCFFFD\\uD0000-\\uDFFFD\\uE1000-\\uEFFFD]", DV = "[\\uE000-\\uF8FF\\uF0000-\\uFFFFD\\u100000-\\u10FFFD]", BV = `(?:${x0}|${zu}|${Os})*?`, jV = `(?<host>${GP}|${m6}|${BV})`, FV = `(?<userinfo>(?:${x0}|${zu}|${Os}|:)*)`, E6 = `(?:${x0}|${zu}|${Os}|:|@)`, KP = `${E6}*?`, ZP = `(?:/${KP})*`, A6 = `(?<authority>(?:${FV}@)?${jV}(?:${QP})?)`, S6 = `(?<path>${ZP})`, _6 = `(?<path2>${KP}${ZP})`, k6 = `(?:\\?(?<query>(?:${E6}|${DV}|/|\\?)*))?`, JP = `(?:#(?<fragment>(?:${E6}|/|\\?)*))?`, XP = `^${Ep}:(?://${A6}${S6}|${_6})${k6}${JP}$`, tR = `^(?:${Ep}:|)(?://${A6}${S6}|${_6})${k6}${JP}$`, eR = `^${Ep}:(?://${A6}${S6}|${_6})${k6}$`, $V = (e) => (t, r) => {
  const n = (
    /** @type IdentifierComponents */
    e.parseReference(t)
  );
  if (n.scheme === void 0) {
    const i = e.parseAbsolute(r);
    n.scheme = i.scheme, n.authority === void 0 && (n.authority = i.authority, n.path === "" ? (n.path = i.path, n.query === void 0 && (n.query = i.query)) : n.path.startsWith("/") || (n.path = zV(n.path, i)));
  }
  return rR(e, n);
}, zV = (e, t) => {
  if (t.authority && t.path === "")
    return "/" + e;
  {
    const r = t.path.lastIndexOf("/");
    return r === -1 ? e : t.path.slice(0, r + 1) + e;
  }
}, VV = /^\.?\.\/|^\.\.?$/, UV = /^\/\.(?:\/|$)/, HV = /^\/\.\.(?:\/|$)/, GV = (e) => {
  let t = "";
  for (; e.length > 0; )
    if (VV.test(e))
      e = jS(e);
    else if (UV.test(e))
      e = FS(e);
    else if (HV.test(e))
      e = FS(e), t = QV(t);
    else {
      const r = WV(e);
      e = jS(e), t += r;
    }
  return t;
}, jS = (e) => {
  const t = e.indexOf("/", 1);
  return t === -1 ? "" : "/" + e.slice(t + 1);
}, FS = (e) => {
  const t = e.indexOf("/", 1);
  return t === -1 ? "/" : "/" + e.slice(t + 1);
}, QV = (e) => {
  const t = e.lastIndexOf("/");
  return t === -1 ? e : e.slice(0, t);
}, WV = (e) => {
  const t = e.indexOf("/", 1);
  return t === -1 ? e : e.slice(0, t);
}, rR = (e, t) => {
  let r = t.scheme.toLowerCase() + ":";
  return r += t.authority === void 0 ? "" : "//" + t.authority.toLowerCase(), r += e.normalizePath(t.path), r += t.query === void 0 ? "" : "?" + e.normalizeQuery(t.query), r += t.fragment === void 0 ? "" : "#" + e.normalizeFragment(t.fragment), r;
}, nR = new RegExp(zu, "g"), iR = (e) => (t) => {
  const r = parseInt(t.slice(1), 16), n = String.fromCharCode(r);
  return e(n) ? n : t.toUpperCase();
};
RegExp.prototype.test.bind(new RegExp(`${xp}|${Os}|[:@]`));
const qV = RegExp.prototype.test.bind(new RegExp(`${x0}|${Os}|[:@]`)), YV = (e) => (t) => GV(t).replaceAll(nR, iR(e));
RegExp.prototype.test.bind(new RegExp(`${xp}|${Os}|[:@/?]`));
const $S = RegExp.prototype.test.bind(new RegExp(`${x0}|${Os}|[:@/?]`)), zS = (e) => (t) => t.replaceAll(nR, iR(e));
RegExp.prototype.test.bind(new RegExp(LV));
RegExp.prototype.test.bind(new RegExp(MV));
RegExp.prototype.test.bind(new RegExp(NV));
RegExp.prototype.test.bind(new RegExp(XP));
RegExp.prototype.test.bind(new RegExp(tR));
RegExp.prototype.test.bind(new RegExp(eR));
const C6 = (e, t) => (r) => {
  const n = e.exec(r);
  if (n === null)
    throw Error(`Invalid ${t}: ${r}`);
  const i = (
    /** @type Record<string, string> */
    n.groups
  );
  return i.authority === void 0 && (i.path = i.path2), delete i.path2, /** @type A */
  i;
}, I6 = (
  /** @type Parser<IdentifierComponents> */
  C6(new RegExp(XP), "IRI")
), sR = (
  /** @type Parser<RelativeIdentifierComponents> */
  C6(new RegExp(tR), "IRI-reference")
), KV = (
  /** @type Parser<AbsoluteIdentifierComponents> */
  C6(new RegExp(eR), "absolute-IRI")
), oR = {
  iri: {
    parseAbsolute: KV,
    parseReference: sR,
    parse: I6,
    normalizePath: YV(qV),
    normalizeQuery: zS($S),
    normalizeFragment: zS($S)
  }
}, ZV = (e) => (t) => {
  const r = e.parse(t);
  return delete r.fragment, rR(e, r);
}, au = ZV(oR.iri), _f = $V(oR.iri), JV = "", c3 = function* (e) {
  if (e.length > 0 && e[0] !== "/")
    throw Error("Invalid JSON Pointer");
  let t = 1, r = 0;
  for (; r < e.length; ) {
    const n = e.indexOf("/", t);
    r = n === -1 ? e.length : n;
    const i = e.slice(t, r);
    t = r + 1, yield eU(i);
  }
}, XV = (e, t = void 0) => {
  if (t === void 0) {
    const r = [...c3(e)];
    return (n) => VS(r, n);
  } else
    return VS(c3(e), t);
}, VS = (e, t) => {
  let r = JV;
  for (const n of e)
    t = nU(t, n, r), r = gu(n, r);
  return t;
}, gu = (e, t) => t + "/" + tU(e), tU = (e) => e.toString().replace(/~/g, "~0").replace(/\//g, "~1"), eU = (e) => e.toString().replace(/~1/g, "/").replace(/~0/g, "~"), rU = (e, t) => Array.isArray(e) && t === "-" ? e.length : t, nU = (e, t, r = "") => {
  if (e === void 0)
    throw TypeError(`Value at '${r}' is undefined and does not have property '${t}'`);
  if (e === null)
    throw TypeError(`Value at '${r}' is null and does not have property '${t}'`);
  if (iU(e))
    throw TypeError(`Value at '${r}' is a ${typeof e} and does not have property '${t}'`);
  {
    const n = rU(e, t);
    return e[n];
  }
}, iU = (e) => e === null || typeof e != "object", aR = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return t;
    case "object":
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) === Object.prototype)
        return "object";
    default: {
      const r = t === "object" ? Object.getPrototypeOf(e).constructor.name || "anonymous" : t;
      throw Error(`Not a JSON compatible type: ${r}`);
    }
  }
}, lR = (e) => {
  const t = e.indexOf("#"), r = t === -1 ? e.length : t;
  return e.slice(0, r);
}, cR = (e) => decodeURIComponent(sR(e).fragment || ""), hm = {}, Uy = (e) => {
  if (e.indexOf("#") !== -1) {
    const t = lR(e);
    return { ...hm[t], id: e };
  }
  return hm[e];
}, sU = (e, t) => {
  const r = oU(e, t);
  if (!r)
    throw Error(`Encountered unknown keyword '${e}'`);
  const n = Uy(r);
  if (!n)
    throw Error(`Encountered unsupported keyword ${e}. You can provide an implementation for the '${r}' keyword using the 'addKeyword' function.`);
  return n;
}, re = (e) => {
  hm[e.id] = e;
}, u3 = {}, Yl = (e, t) => {
  u3[e] = t;
}, of = {}, h3 = {}, lv = {}, oU = (e, t) => {
  var r;
  return ((r = uR(t)) == null ? void 0 : r[e]) || (h3[t] || e.startsWith("x-")) && `https://json-schema.org/keyword/unknown#${e}`;
}, Vr = (e, t) => {
  const r = uR(e);
  for (const n in r)
    if (r[n] === t)
      return n;
}, uR = (e) => {
  if (!(e in of))
    throw Error(`Encountered unknown dialect '${e}'`);
  return of[e];
}, hR = (e, t, r = !1, n = !0) => {
  h3[e] = r, lv[e] = lv[e] || n, of[e] = {}, Object.entries(t).forEach(([i, s]) => {
    if (i in u3)
      Object.entries(u3[i]).forEach(([o, a]) => {
        !(a in hm) && !s && (a = `https://json-schema.org/keyword/unknown#${o}`), of[e][o] = a;
      });
    else if (!r || s)
      throw delete of[e], delete h3[e], delete lv[e], Error(`Unrecognized vocabulary: ${i}. You can define this vocabulary with the 'defineVocabulary' function.`);
  });
};
var US = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function pR(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var zg = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var HS;
function aU() {
  if (HS) return zg;
  HS = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, n = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  zg.format = o, zg.parse = a;
  function o(u) {
    if (!u || typeof u != "object")
      throw new TypeError("argument obj is required");
    var p = u.parameters, y = u.type;
    if (!y || !s.test(y))
      throw new TypeError("invalid type");
    var g = y;
    if (p && typeof p == "object")
      for (var b, f = Object.keys(p).sort(), E = 0; E < f.length; E++) {
        if (b = f[E], !r.test(b))
          throw new TypeError("invalid parameter name");
        g += "; " + b + "=" + c(p[b]);
      }
    return g;
  }
  function a(u) {
    if (!u)
      throw new TypeError("argument string is required");
    var p = typeof u == "object" ? l(u) : u;
    if (typeof p != "string")
      throw new TypeError("argument string is required to be a string");
    var y = p.indexOf(";"), g = y !== -1 ? p.slice(0, y).trim() : p.trim();
    if (!s.test(g))
      throw new TypeError("invalid media type");
    var b = new h(g.toLowerCase());
    if (y !== -1) {
      var f, E, A;
      for (e.lastIndex = y; E = e.exec(p); ) {
        if (E.index !== y)
          throw new TypeError("invalid parameter format");
        y += E[0].length, f = E[1].toLowerCase(), A = E[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(n, "$1"))), b.parameters[f] = A;
      }
      if (y !== p.length)
        throw new TypeError("invalid parameter format");
    }
    return b;
  }
  function l(u) {
    var p;
    if (typeof u.getHeader == "function" ? p = u.getHeader("content-type") : typeof u.headers == "object" && (p = u.headers && u.headers["content-type"]), typeof p != "string")
      throw new TypeError("content-type header is missing from object");
    return p;
  }
  function c(u) {
    var p = String(u);
    if (r.test(p))
      return p;
    if (p.length > 0 && !t.test(p))
      throw new TypeError("invalid parameter value");
    return '"' + p.replace(i, "\\$1") + '"';
  }
  function h(u) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = u;
  }
  return zg;
}
var dR = aU();
const lU = /* @__PURE__ */ pR(dR), kf = {}, fR = (e, t) => {
  kf[e] = t;
}, cU = (e) => {
  const t = e.headers.get("content-type");
  if (t === null)
    throw new gU("The media type of the response could not be determined. Make sure the response includes a 'Content-Type' header.", { cause: e });
  const r = dR.parse(t);
  for (const n in kf)
    if (pU(n, r.type))
      return kf[n].parse(e);
  throw new fU(r.type, `'${r.type}' is not supported. Use the 'addMediaTypePlugin' function to add support for this media type.`, {
    cause: e
  });
}, uU = "A-Za-z", cv = `[!#$%&'*\\-_.^\`|~\\d${uU}]+`, hU = `(?<type>${cv})/(?<subType>${cv}(?:\\+(?<suffix>${cv}))?)`, GS = new RegExp(hU), pU = (e, t) => {
  var r, n;
  if (e === t)
    return !0;
  const i = (r = GS.exec(e)) == null ? void 0 : r.groups;
  if (!i)
    throw Error(`Unable to parse media-range: ${e}`);
  const s = (n = GS.exec(t)) == null ? void 0 : n.groups;
  if (!s)
    throw Error(`Unable to parse media-type: ${t}`);
  return (i.type === s.type || i.type === "*") && (i.subType === s.subType || i.subType === "*" || i.subType === s.suffix);
}, dU = () => {
  let e = "";
  for (const t in kf)
    e = QS(e, t, kf[t].quality);
  return QS(e, "*/*", "0.001");
}, QS = (e, t, r) => (e.length > 0 && (e += ", "), e += t, r && (e += `; q=${r}`), e);
let fU = class extends Error {
  constructor(t, r = void 0) {
    super(r), this.name = this.constructor.name, this.mediaType = t;
  }
}, gU = class extends Error {
  constructor(t = void 0) {
    super(t), this.name = this.constructor.name;
  }
};
const mU = (e, t = void 0) => JSON.parse(e, (r, n) => {
  const i = n !== null && typeof n.$ref == "string" ? new Xc(n.$ref) : n;
  return t ? t(r, i) : i;
});
var E1, A1;
let Xc = class {
  constructor(t, r = void 0) {
    DS(this, E1), DS(this, A1), BS(this, E1, t), BS(this, A1, r ?? { $ref: t });
  }
  get href() {
    return NS(this, E1);
  }
  toJSON() {
    return NS(this, A1);
  }
};
E1 = /* @__PURE__ */ new WeakMap(), A1 = /* @__PURE__ */ new WeakMap();
const gR = (e) => {
  const t = typeof e;
  switch (t) {
    case "bigint":
      return "number";
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return t;
    case "object":
      if (e instanceof Xc)
        return "reference";
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) === Object.prototype || Object.getPrototypeOf(e) === null)
        return "object";
    default: {
      const r = t === "object" ? Object.getPrototypeOf(e).constructor.name || "anonymous" : t;
      throw Error(`Not a JRef compatible type: ${r}`);
    }
  }
}, yU = {
  parse: async (e) => ({
    baseUri: e.url,
    root: mU(await e.text()),
    anchorLocation: bU
  }),
  fileMatcher: (e) => /[^/]\.jref$/.test(e)
}, bU = (e) => decodeURI(e || ""), p3 = {}, mR = (e, t) => {
  p3[e] = t;
}, vU = (e, t) => {
  e = _f(e, t);
  const { scheme: r } = I6(e);
  if (!(r in p3))
    throw new wU(r, `The '${r}:' URI scheme is not supported. Use the 'addUriSchemePlugin' function to add support for '${r}:' URIs.`);
  return p3[r].retrieve(e, t);
};
let wU = class extends Error {
  constructor(t, r = void 0) {
    super(r), this.name = this.constructor.name, this.scheme = t;
  }
};
const xU = /* @__PURE__ */ new Set([200, 203]), EU = async (e) => {
  const t = await fetch(e, { headers: { Accept: dU() } });
  if (t.status >= 400)
    throw new WS(t, `Failed to retrieve '${e}'`);
  if (!xU.has(t.status))
    throw new WS(t, "Unsupported HTTP response status code");
  return t;
}, yR = { retrieve: EU };
let WS = class extends Error {
  constructor(t, r = void 0) {
    super(`${t.status} ${t.statusText}${r ? ` -- ${r}` : ""}`), this.name = this.constructor.name, this.response = t;
  }
};
var bR = AU;
function AU(e, t) {
  return function r() {
    t == null && (t = e.length);
    var n = [].slice.call(arguments);
    return n.length >= t ? e.apply(this, n) : function() {
      return r.apply(this, n.concat([].slice.call(arguments)));
    };
  };
}
const SU = () => {
  var e, t;
  return ((t = (e = globalThis.document) == null ? void 0 : e.location) == null ? void 0 : t.toString()) ?? "";
}, Hy = async (e, t = { _cache: {} }) => {
  var r, n, i;
  const s = ((r = t.document) == null ? void 0 : r.baseUri) ?? SU();
  e = _f(e, s);
  const o = au(e), { fragment: a } = I6(e), l = t._cache[o] ?? ((i = (n = t.document) == null ? void 0 : n.embedded) == null ? void 0 : i[o]);
  if (l)
    t.document = l, t.uri = e, t.cursor = t.document.anchorLocation(a);
  else {
    try {
      const c = await vU(e, s);
      t.document = await cU(c), t.uri = c.url + (a === void 0 ? "" : `#${a}`), t.cursor = t.document.anchorLocation(a);
    } catch (c) {
      const h = t.uri ? ` Referenced from '${t.uri}'.` : "";
      throw new kU(`Unable to load resource '${e}'.${h}`, c);
    }
    t._cache[o] = t.document;
  }
  return t._value = XV(t.cursor, t.document.root), vR(t);
}, vR = (e) => gR(Ee(e)) === "reference" ? Hy(Ee(e).href, e) : e, Ee = (e) => e._value, ca = (e) => gR(e._value), wR = (e, t) => e in t._value, xR = (e) => e._value.length, Ps = bR((e, t) => vR({
  ...t,
  cursor: gu(`${e}`, t.cursor),
  _value: t._value[e]
})), Kl = async function* (e) {
  for (let t = 0; t < Ee(e).length; t++)
    yield Ps(t, e);
}, d3 = function* (e) {
  for (const t in Ee(e))
    yield t;
}, _U = async function* (e) {
  for (const t in Ee(e))
    yield Ps(t, e);
}, mu = async function* (e) {
  for (const t in Ee(e))
    yield [t, await Ps(t, e)];
};
let kU = class extends Error {
  constructor(t, r) {
    super(t, { cause: r }), this.name = this.constructor.name;
  }
};
fR("application/reference+json", yU);
mR("http", yR);
mR("https", yR);
const CU = {
  parse: async (e) => {
    const t = lU.parse(e.headers.get("content-type") ?? ""), r = t.parameters.schema ?? t.parameters.profile;
    return dm(await e.json(), e.url, r);
  },
  fileMatcher: async (e) => /(\.|\/)schema\.json$/.test(e)
}, pm = {}, IU = async (e, t = void 0) => {
  t || (t = { _cache: {} });
  for (const n in pm)
    n in t._cache || (t._cache[n] = pm[n]);
  const r = await Hy(e, { ...t });
  if (typeof r.document.dialectId != "string")
    throw Error(`The document at ${r.document.baseUri} is not a schema.`);
  return r;
}, va = (e, t, r) => {
  e = structuredClone(e);
  const n = dm(e, t, r);
  if (n.baseUri in pm)
    throw Error(`A schema has already been registered for '${n.baseUri}. You can use 'unregisterSchema' to remove the old schema before registering the new one.`);
  if (n.baseUri.startsWith("file:"))
    throw Error(`Registering a schema with a 'file:' URI scheme is not allowed: ${n.baseUri}`);
  pm[n.baseUri] = n;
}, dm = (e, t, r, n = {}) => {
  if (typeof e.$schema == "string" && (r = e.$schema, delete e.$schema), !r)
    throw Error("Unable to determine a dialect for the schema. The dialect can be declared in a number of ways, but the recommended way is to use the '$schema' keyword in your schema.");
  r = au(r);
  const i = Vr(r, "https://json-schema.org/keyword/draft-04/id"), s = Vr(r, "https://json-schema.org/keyword/id") || i;
  if (!e[s] && !t)
    throw Error(`Unable to determine an identifier for the schema. Use the '${s}' keyword or pass a retrievalUri when loading the schema.`);
  const o = _f(e[s] ?? "", t ?? "");
  t = au(o), i && o.length > t.length ? e[s] = "#" + cR(o) : delete e[s];
  const a = Vr(r, "https://json-schema.org/keyword/vocabulary");
  if (aR(e[a]) === "object") {
    const u = e[a]["https://json-schema.org/draft/2019-09/vocab/core"] || e[a]["https://json-schema.org/draft/2020-12/vocab/core"];
    hR(t, e[a], u, !1), delete e[a];
  }
  const l = { "": "" }, c = {}, h = Vr(r, "https://json-schema.org/keyword/draft-2019-09/recursiveAnchor");
  return e[h] === !0 && (c[""] = `${t}#`), delete e[h], n[t] = {
    baseUri: t,
    dialectId: r,
    root: f3(e, t, r, "", n, l, c),
    anchorLocation: (u) => {
      if (u === void 0)
        return "";
      if (u = decodeURI(u), u[0] === "/")
        return u;
      if (u in l)
        return l[u];
      throw Error(`No such anchor '${t}#${encodeURI(u)}'`);
    },
    anchors: l,
    dynamicAnchors: c,
    embedded: n
  }, n[t];
}, f3 = (e, t, r, n, i, s, o) => {
  if (aR(e) === "object") {
    const a = typeof e.$schema == "string" ? au(e.$schema) : r, l = Vr(a, "https://json-schema.org/keyword/id");
    if (typeof e[l] == "string") {
      const g = au(_f(e[l], t));
      return e[l] = g, i[g] = dm(e, g, a, i), new Xc(g, {});
    }
    const c = Vr(a, "https://json-schema.org/keyword/draft-04/id");
    if (typeof e[c] == "string")
      if (e[c][0] === "#") {
        const g = decodeURIComponent(e[c].slice(1));
        s[g] = n, delete e[c];
      } else {
        const g = au(_f(e[c], t));
        return e[c] = g, i[g] = dm(e, g, a, i), new Xc(g, {});
      }
    const h = Vr(r, "https://json-schema.org/keyword/draft-04/ref");
    if (typeof e[h] == "string")
      return new Xc(e[h], e);
    const u = Vr(r, "https://json-schema.org/keyword/anchor");
    typeof e[u] == "string" && (s[e[u]] = n, delete e[u]);
    const p = Vr(r, "https://json-schema.org/keyword/dynamicAnchor");
    typeof e[p] == "string" && (o[e[p]] = `${t}#${encodeURI(n)}`, delete e[p]);
    const y = Vr(r, "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor");
    typeof e[y] == "string" && (o[e[y]] = `${t}#${encodeURI(n)}`, s[e[y]] = n, delete e[y]);
    for (const g in e) {
      const b = Vr(r, "https://json-schema.org/keyword/ref");
      g === b && typeof e[g] == "string" ? e[g] = new Xc(e[g], e[g]) : e[g] = f3(e[g], t, r, gu(g, n), i, s, o);
    }
  } else if (Array.isArray(e))
    for (let a = 0; a < e.length; a++)
      e[a] = f3(e[a], t, r, gu(a, n), i, s, o);
  return e;
}, Kh = (e) => `${e.document.baseUri}#${encodeURI(e.cursor)}`, Ap = (
  /** @type API.curry */
  (e) => (...t) => {
    const r = e.length === 1 ? (
      /** @type Extract<typeof fn, (a: any) => any> */
      e(t[0])
    ) : e(t[0], t[1]), n = (
      /** @type I */
      t[e.length]
    );
    return n === void 0 ? r : r(n);
  }
), ER = Ap((e) => function* (t) {
  for (const r of t)
    yield e(r);
}), Bn = Ap((e) => async function* (t) {
  for await (const r of t)
    yield e(r);
}), AR = Ap((e) => function* (t) {
  for (const r of t)
    e(r) && (yield r);
}), PU = Ap((e) => function* (t) {
  let r = 0;
  for (const n of t)
    r++ >= e && (yield n);
}), RU = (e) => {
  const t = kR(e).next();
  return t.done ? void 0 : t.value;
}, SR = function* (e, t) {
  for (let r = e; t === void 0; r++)
    yield r;
}, qS = function* () {
}, P6 = function* (e, t) {
  const r = kR(t);
  for (const n of e)
    yield [n, r.next().value];
}, TU = function* (...e) {
  for (const t of e)
    yield* t;
}, _R = (
  /** @type API.reduce */
  Ap(
    // eslint-disable-next-line @stylistic/no-extra-parens
    /** @type API.reduce */
    (e, t) => (r) => {
      for (const n of r)
        t = e(
          t,
          /** @type any */
          n
        );
      return t;
    }
  )
), Ls = async (e) => {
  const t = [];
  for await (const r of e)
    t.push(r);
  return t;
}, OU = (e) => {
  const t = /* @__PURE__ */ new Set();
  for (const r of e)
    t.add(r);
  return t;
}, g3 = async (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  for await (const [r, n] of e)
    t[r] = n;
  return t;
}, LU = Ap((e) => (t) => {
  let r = RU(t) ?? "";
  for (const n of t)
    r += e + n;
  return r;
}), kR = (e) => {
  if (typeof (e == null ? void 0 : e[Symbol.iterator]) == "function")
    return e[Symbol.iterator]();
  throw TypeError("`iter` is not iterable");
}, on = (
  /** @type (acc: any, ...fns: ((a: any) => any)[]) => any */
  (e, ...t) => _R((r, n) => n(r), e, t)
), S1 = (e, t = "", r = "", n = void 0) => {
  const i = typeof e;
  switch (i) {
    case "number":
    case "string":
    case "boolean":
      return Ld(t, r, e, i, [], n);
    case "object":
      if (e === null)
        return Ld(t, r, e, "null", [], n);
      if (Array.isArray(e)) {
        const s = Ld(t, r, e, "array", [], n);
        return s.children = e.map((o, a) => S1(o, t, gu(a, r), s)), s;
      } else if (Object.getPrototypeOf(e) === Object.prototype) {
        const s = Ld(t, r, e, "object", [], n);
        return s.children = Object.entries(e).map((o) => {
          const a = gu(o[0], r), l = Ld(t, a, void 0, "property", [], s);
          return l.children = o.map((c) => S1(c, t, a, l)), l;
        }), s;
      } else if (e instanceof Xc)
        return S1(e.toJSON(), t, r, n);
    default: {
      const s = i === "object" ? Object.getPrototypeOf(e).constructor.name || "anonymous" : i;
      throw Error(`Not a JSON compatible type: ${s}`);
    }
  }
}, Ld = (e, t, r, n, i, s) => {
  const o = {
    baseUri: e ? au(e) : "",
    pointer: t,
    value: r,
    type: n,
    children: i,
    parent: s,
    valid: !0,
    errors: {},
    annotations: {}
  };
  return o.root = (s == null ? void 0 : s.root) ?? o, o;
}, MU = (e) => `${e.baseUri}#${encodeURI(e.pointer)}`, br = (e) => e.value, Fe = (e) => e.type, Zh = (e, t) => e in t.value, Vu = function* (e) {
  e.type === "array" && (yield* e.children);
}, R6 = function* (e) {
  if (e.type === "object")
    for (const t of e.children)
      yield t.children[0];
}, NU = function* (e) {
  if (e.type === "object")
    for (const t of e.children)
      t.children[1] && (yield t.children[1]);
}, Zl = function* (e) {
  if (e.type === "object")
    for (const t of e.children)
      t.children.length === 2 && (yield t.children);
}, E0 = (e) => {
  if (e.type === "array")
    return e.children.length;
}, m3 = function* (e) {
  switch (yield e, Fe(e)) {
    case "object":
      for (const t of NU(e))
        yield* m3(t);
      break;
    case "array":
      for (const t of Vu(e))
        yield* m3(t);
      break;
  }
}, Vh = {};
let DU = 0;
const BU = (e, t) => {
  e in Vh || (Vh[e] = {});
  const r = `pubsub_subscription_${DU++}`;
  return Vh[e][r] = t, r;
}, jU = async (e, t) => {
  const r = [];
  for (const n in Vh)
    if (n === e || e.startsWith(`${n}.`))
      for (const i in Vh[n])
        r.push(Vh[e][i](e, t));
  await Promise.all(r);
};
let CR;
const FU = () => CR, $U = (e) => {
  CR = e;
};
let zU = class extends Error {
  constructor(t) {
    super("Invalid Schema"), this.name = this.constructor.name, this.output = t;
  }
};
const IR = "https://json-schema.org/evaluation/validate", VU = async (e, t) => {
  await jU("validate.metaValidate", e), e.document.baseUri in t.metaData || (t.metaData[e.document.baseUri] = {
    dynamicAnchors: e.document.dynamicAnchors
  });
  const r = Kh(e);
  if (!(r in t)) {
    t[r] = !1;
    const n = Ee(e);
    if (!["object", "boolean"].includes(typeof n))
      throw Error(`No schema found at '${r}'`);
    t[r] = typeof n == "boolean" ? n : await on(
      mu(e),
      Bn(async ([i, s]) => {
        const o = sU(i, e.document.dialectId), a = await o.compile(s, t, e);
        return [o.id, gu(i, Kh(e)), a];
      }),
      Ls
    );
  }
  return r;
}, UU = (e, t, r, n, i = !1) => {
  n = { ...r.metaData[lR(e)].dynamicAnchors, ...n };
  let s = !0;
  if (typeof r[e] == "boolean")
    s = r[e];
  else
    for (const [o, a, l] of r[e])
      t.valid = Uy(o).interpret(l, t, r, n, i, e), t.valid || (i || (t.errors[a] = o), s = !1);
  return s || (t.errors[e] = IR), t.valid = s, s;
}, HU = /* @__PURE__ */ new Set(), GU = (e, t, r, n, i = !1) => {
  if (typeof r[e] == "boolean")
    return r[e] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[e]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedProperties")
      continue;
    const l = Uy(o), c = "collectEvaluatedProperties" in l ? l.collectEvaluatedProperties(a, t, r, n, i) : l.interpret(a, t, r, n, !0) && HU;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, QU = /* @__PURE__ */ new Set(), WU = (e, t, r, n, i = !1) => {
  if (typeof r[e] == "boolean")
    return r[e] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[e]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedItems")
      continue;
    const l = Uy(o), c = "collectEvaluatedItems" in l ? l.collectEvaluatedItems(a, t, r, n, i) : l.interpret(a, t, r, n, !0) && QU;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, Vt = { id: IR, compile: VU, interpret: UU, collectEvaluatedProperties: GU, collectEvaluatedItems: WU }, fm = {}, qU = (e, t) => {
  if (t in fm)
    return fm[t](e);
  throw Error(`The '${t}' error format is not supported`);
};
fm.FLAG = (e) => ({ valid: e.valid });
fm.BASIC = (e) => {
  const t = {
    valid: e.valid
  };
  if (!e.valid) {
    t.errors = [];
    for (const r of m3(e))
      for (const [n, i] of Object.entries(r.errors).reverse())
        i !== "https://json-schema.org/evaluation/validate" && !r.valid && t.errors.unshift({
          keyword: i,
          absoluteKeywordLocation: n,
          instanceLocation: MU(r),
          valid: r.valid
        });
  }
  return t;
};
const PR = "FLAG";
$U(PR);
const YU = async (e) => {
  const t = { metaData: {} }, r = await Vt.compile(e, t);
  return { ast: t, schemaUri: r };
}, KU = bR(({ ast: e, schemaUri: t }, r, n = PR) => (Vt.interpret(t, r, e, {}), qU(r, n))), uv = {};
BU("validate.metaValidate", async (e, t) => {
  if (!t.document.validated) {
    if (t.document.validated = !0, !(t.document.dialectId in uv)) {
      const i = await IU(t.document.dialectId, t), s = await YU(i);
      uv[t.document.dialectId] = KU(s);
    }
    const r = S1(t.document.root, t.document.baseUri), n = uv[t.document.dialectId](r, FU());
    if (!n.valid)
      throw new zU(n);
  }
});
const ZU = "https://json-schema.org/keyword/additionalProperties", JU = async (e, t, r) => {
  const n = Vr(e.document.dialectId, "https://json-schema.org/keyword/properties"), i = await Ps(n, r), s = ca(i) === "object" ? ER((h) => "^" + XU(h) + "$", d3(i)) : qS(), o = Vr(e.document.dialectId, "https://json-schema.org/keyword/patternProperties"), a = await Ps(o, r), l = ca(a) === "object" ? d3(a) : qS(), c = on(
    TU(s, l),
    LU("|")
  ) || "(?!)";
  return [new RegExp(c, "u"), await Vt.compile(e, t)];
}, XU = (e) => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), tH = ([e, t], r, n, i, s) => {
  if (Fe(r) !== "object")
    return !0;
  let o = !0;
  for (const [a, l] of Zl(r)) {
    const c = br(a);
    !e.test(c) && !Vt.interpret(t, l, n, i, s) && (o = !1);
  }
  return o;
}, eH = ([e, t], r, n, i) => {
  if (Fe(r) !== "object")
    return !0;
  const s = /* @__PURE__ */ new Set();
  for (const [o, a] of Zl(r)) {
    const l = br(o);
    if (!e.test(l)) {
      if (!Vt.interpret(t, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, rH = { id: ZU, compile: JU, interpret: tH, collectEvaluatedProperties: eH }, nH = "https://json-schema.org/keyword/allOf", iH = (e, t) => on(
  Kl(e),
  Bn((r) => Vt.compile(r, t)),
  Ls
), sH = (e, t, r, n, i) => {
  let s = !0;
  for (const o of e)
    Vt.interpret(o, t, r, n, i) || (s = !1);
  return s;
}, oH = (e, t, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of e) {
    const o = Vt.collectEvaluatedProperties(s, t, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, aH = (e, t, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of e) {
    const o = Vt.collectEvaluatedItems(s, t, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, lH = { id: nH, compile: iH, interpret: sH, collectEvaluatedProperties: oH, collectEvaluatedItems: aH }, cH = { id: "https://json-schema.org/keyword/anchor" }, uH = "https://json-schema.org/keyword/anyOf", hH = (e, t) => on(
  Kl(e),
  Bn((r) => Vt.compile(r, t)),
  Ls
), pH = (e, t, r, n, i) => e.filter((s) => Vt.interpret(s, t, r, n, i)).length > 0, dH = (e, t, r, n) => {
  let i = !1;
  for (const s of e) {
    const o = Vt.collectEvaluatedProperties(s, t, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, fH = (e, t, r, n) => {
  let i = !1;
  for (const s of e) {
    const o = Vt.collectEvaluatedItems(s, t, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, gH = { id: uH, compile: hH, interpret: pH, collectEvaluatedProperties: dH, collectEvaluatedItems: fH }, mH = "https://json-schema.org/keyword/conditional", yH = (e, t) => on(
  Kl(e),
  RR,
  Bn((r) => Vt.compile(r, t)),
  Ls
), bH = (e, t, r, n, i) => {
  for (let s = 0; s < e.length; s += 2) {
    const o = Vt.interpret(e[s], t, r, n, i);
    if (s + 1 === e.length)
      return o;
    if (o)
      return Vt.interpret(e[s + 1], t, r, n, i);
  }
  return !0;
}, vH = (e, t, r, n) => {
  for (let i = 0; i < e.length; i += 2) {
    const s = Vt.collectEvaluatedProperties(e[i], t, r, n);
    if (i + 1 === e.length)
      return s;
    if (s !== !1)
      return Vt.collectEvaluatedProperties(e[i + 1], t, r, n);
  }
  return /* @__PURE__ */ new Set();
}, wH = (e, t, r, n) => {
  for (let i = 0; i < e.length; i += 2) {
    const s = Vt.collectEvaluatedItems(e[i], t, r, n);
    if (i + 1 === e.length)
      return s;
    if (s !== !1)
      return Vt.collectEvaluatedItems(e[i + 1], t, r, n);
  }
  return /* @__PURE__ */ new Set();
}, RR = async function* (e, t = 1) {
  for await (const r of e)
    t > 0 && ca(r) === "array" ? yield* RR(Kl(r), t - 1) : yield r;
}, xH = { id: mH, compile: yH, interpret: bH, collectEvaluatedProperties: vH, collectEvaluatedItems: wH };
var YS, KS;
function EH() {
  return KS || (KS = 1, YS = {
    space: "",
    cycles: !1,
    replacer: (e, t) => t,
    stringify: JSON.stringify
  }), YS;
}
var ZS, JS;
function Fc() {
  return JS || (JS = 1, ZS = {
    isArray: Array.isArray,
    assign: Object.assign,
    isObject: (e) => typeof e == "object",
    isFunction: (e) => typeof e == "function",
    isBoolean: (e) => typeof e == "boolean",
    isRegex: (e) => e instanceof RegExp,
    keys: Object.keys
  }), ZS;
}
var hv, XS;
function AH() {
  if (XS) return hv;
  XS = 1;
  const e = EH(), t = Fc().isFunction, r = Fc().isBoolean, n = Fc().isObject, i = Fc().isArray, s = Fc().isRegex, o = Fc().assign, a = Fc().keys;
  function l(h) {
    return h == null ? h : s(h) ? h.toString() : h.toJSON ? h.toJSON() : h;
  }
  function c(h, u) {
    u = u || o({}, e), t(u) && (u = { compare: u });
    const p = u.space || e.space, y = r(u.cycles) ? u.cycles : e.cycles, g = u.replacer || e.replacer, b = u.stringify || e.stringify, f = u.compare && /* @__PURE__ */ function(A) {
      return function(x) {
        return function(m, w) {
          const _ = { key: m, value: x[m] }, S = { key: w, value: x[w] };
          return A(_, S);
        };
      };
    }(u.compare);
    y || b(h);
    const E = [];
    return function A(x, m, w, _) {
      const S = p ? `
` + new Array(_ + 1).join(p) : "", R = p ? ": " : ":";
      if (w = l(w), w = g.call(x, m, w), w !== void 0) {
        if (!n(w) || w === null) return b(w);
        if (i(w)) {
          const O = [];
          for (let $ = 0; $ < w.length; $++) {
            const z = A(w, $, w[$], _ + 1) || b(null);
            O.push(S + p + z);
          }
          return "[" + O.join(",") + S + "]";
        } else {
          if (y) {
            if (E.indexOf(w) !== -1)
              return b("[Circular]");
            E.push(w);
          }
          const O = a(w).sort(f && f(w)), $ = [];
          for (let z = 0; z < O.length; z++) {
            const F = O[z], Y = A(w, F, w[F], _ + 1);
            if (!Y) continue;
            const rt = b(F) + R + Y;
            $.push(S + p + rt);
          }
          return E.splice(E.indexOf(w), 1), "{" + $.join(",") + S + "}";
        }
      }
    }({ "": h }, "", h, 0);
  }
  return hv = c, hv;
}
var SH = AH();
const A0 = /* @__PURE__ */ pR(SH), _H = "https://json-schema.org/keyword/const", kH = (e) => A0(Ee(e)), CH = (e, t) => A0(br(t)) === e, IH = { id: _H, compile: kH, interpret: CH }, PH = "https://json-schema.org/keyword/contains", RH = async (e, t, r) => {
  const n = await Vt.compile(e, t), i = Vr(e.document.dialectId, "https://json-schema.org/keyword/minContains"), s = await Ps(i, r), o = ca(s) === "number" ? Ee(s) : 1, a = Vr(e.document.dialectId, "https://json-schema.org/keyword/maxContains"), l = await Ps(a, r), c = ca(l) === "number" ? Ee(l) : Number.MAX_SAFE_INTEGER;
  return { contains: n, minContains: o, maxContains: c };
}, TR = ({ contains: e, minContains: t, maxContains: r }, n, i, s, o) => {
  const a = Fe(n) !== "array" || on(
    Vu(n),
    AR((l) => Vt.interpret(e, l, i, s, o)),
    _R((l) => l + 1, 0)
  );
  return a >= t && a <= r;
}, TH = (e, t, r, n) => TR(e, t, r, n, !0) && Fe(t) === "array" && on(
  P6(Vu(t), SR(0)),
  AR(([i]) => Vt.interpret(e.contains, i, r, n, !0)),
  ER(([, i]) => i),
  OU
), OH = { id: PH, compile: RH, interpret: TR, collectEvaluatedItems: TH }, LH = "https://json-schema.org/keyword/comment", MH = () => {
}, NH = () => !0, DH = { id: LH, compile: MH, interpret: NH }, cs = (e, t, r, n) => {
  t in e.annotations || (e.annotations[t] = {}), e.annotations[t][r] = n;
}, OR = "https://json-schema.org/keyword/contentEncoding", BH = (e) => Ee(e), jH = (e, t, r, n, i, s) => (cs(t, OR, s, e), !0), FH = { id: OR, compile: BH, interpret: jH }, LR = "https://json-schema.org/keyword/contentMediaType", $H = (e) => Ee(e), zH = (e, t, r, n, i, s) => (cs(t, LR, s, e), !0), VH = { id: LR, compile: $H, interpret: zH }, MR = "https://json-schema.org/keyword/contentSchema", UH = (e) => Kh(e), HH = (e, t, r, n, i, s) => (cs(t, MR, s, e), !0), GH = { id: MR, compile: UH, interpret: HH }, NR = "https://json-schema.org/keyword/default", QH = (e) => Ee(e), WH = (e, t, r, n, i, s) => (cs(t, NR, s, e), !0), qH = { id: NR, compile: QH, interpret: WH }, YH = "https://json-schema.org/keyword/definitions", KH = (e, t) => on(
  _U(e),
  Bn((r) => Vt.compile(r, t)),
  Ls
), ZH = () => !0, JH = { id: YH, compile: KH, interpret: ZH }, XH = "https://json-schema.org/keyword/dependentRequired", tG = (e) => on(
  mu(e),
  Bn(([t, r]) => [t, Ee(r)]),
  Ls
), eG = (e, t) => {
  if (Fe(t) !== "object")
    return !0;
  let r = !0;
  for (const [n, i] of e)
    Zh(n, t) && !i.every((s) => Zh(s, t)) && (r = !1);
  return r;
}, rG = { id: XH, compile: tG, interpret: eG }, nG = "https://json-schema.org/keyword/dependentSchemas", iG = (e, t) => on(
  mu(e),
  Bn(async ([r, n]) => [r, await Vt.compile(n, t)]),
  Ls
), sG = (e, t, r, n, i) => {
  if (Fe(t) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of e)
    Zh(o, t) && !Vt.interpret(a, t, r, n, i) && (s = !1);
  return s;
}, oG = (e, t, r, n) => {
  if (Fe(t) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of e)
    if (Zh(s, t)) {
      const a = Vt.collectEvaluatedProperties(o, t, r, n);
      if (a === !1)
        return !1;
      a.forEach(Set.prototype.add.bind(i));
    }
  return i;
}, aG = { id: nG, compile: iG, interpret: sG, collectEvaluatedProperties: oG }, DR = "https://json-schema.org/keyword/deprecated", lG = (e) => Ee(e), cG = (e, t, r, n, i, s) => (cs(t, DR, s, e), !0), uG = { id: DR, compile: lG, interpret: cG }, BR = "https://json-schema.org/keyword/description", hG = (e) => Ee(e), pG = (e, t, r, n, i, s) => (cs(t, BR, s, e), !0), dG = { id: BR, compile: hG, interpret: pG }, fG = { id: "https://json-schema.org/keyword/dynamicAnchor" }, gG = "https://json-schema.org/keyword/dynamicRef", mG = async (e, t) => {
  const r = Ee(e), n = await Hy(e.document.baseUri, e);
  return await Vt.compile(n, t), r;
}, T6 = (e, t, r, n, i, s) => {
  if (!(t in i))
    throw Error(`No dynamic anchor found for "${t}"`);
  return e(i[t], r, n, i, s);
}, yG = (...e) => T6(Vt.interpret, ...e), bG = (...e) => T6(Vt.collectEvaluatedProperties, ...e), vG = (...e) => T6(Vt.collectEvaluatedItems, ...e), wG = { id: gG, compile: mG, interpret: yG, collectEvaluatedProperties: bG, collectEvaluatedItems: vG }, xG = "https://json-schema.org/keyword/else", EG = async (e, t, r) => {
  const n = Vr(e.document.dialectId, "https://json-schema.org/keyword/if");
  if (wR(n, r)) {
    const i = await Ps(n, r);
    return [await Vt.compile(i, t), await Vt.compile(e, t)];
  } else
    return [];
}, AG = ([e, t], r, n, i, s) => e === void 0 || Vt.interpret(e, r, n, i, !0) || Vt.interpret(t, r, n, i, s), SG = ([e, t], r, n, i) => e === void 0 || Vt.interpret(e, r, n, i, !0) ? /* @__PURE__ */ new Set() : Vt.collectEvaluatedProperties(t, r, n, i), _G = ([e, t], r, n, i) => e === void 0 || Vt.interpret(e, r, n, i, !0) ? /* @__PURE__ */ new Set() : Vt.collectEvaluatedItems(t, r, n, i), kG = { id: xG, compile: EG, interpret: AG, collectEvaluatedProperties: SG, collectEvaluatedItems: _G }, CG = "https://json-schema.org/keyword/enum", IG = (e) => on(
  Kl(e),
  Bn(Ee),
  Bn(A0),
  Ls
), PG = (e, t) => {
  const r = A0(br(t));
  return e.some((n) => r === n);
}, RG = { id: CG, compile: IG, interpret: PG }, jR = "https://json-schema.org/keyword/examples", TG = (e) => Ee(e), OG = (e, t, r, n, i, s) => (cs(t, jR, s, e), !0), LG = { id: jR, compile: TG, interpret: OG }, MG = "https://json-schema.org/keyword/exclusiveMaximum", NG = (e) => Ee(e), DG = (e, t) => Fe(t) !== "number" || br(t) < e, BG = { id: MG, compile: NG, interpret: DG }, jG = "https://json-schema.org/keyword/exclusiveMinimum", FG = (e) => Ee(e), $G = (e, t) => Fe(t) !== "number" || br(t) > e, zG = { id: jG, compile: FG, interpret: $G }, FR = "https://json-schema.org/keyword/format", VG = (e) => Ee(e), UG = (e, t, r, n, i, s) => (cs(t, FR, s, e), !0), HG = { id: FR, compile: VG, interpret: UG }, GG = { id: "https://json-schema.org/keyword/id" }, QG = "https://json-schema.org/keyword/if", WG = (e, t) => Vt.compile(e, t), qG = (e, t, r, n) => (Vt.interpret(e, t, r, n, !0), !0), YG = (e, t, r, n) => Vt.collectEvaluatedProperties(e, t, r, n) || [], KG = (e, t, r, n) => Vt.collectEvaluatedItems(e, t, r, n) || /* @__PURE__ */ new Set(), ZG = { id: QG, compile: WG, interpret: qG, collectEvaluatedProperties: YG, collectEvaluatedItems: KG }, JG = () => {
  const e = Yi(!1), t = Yi(!0);
  return yn(e, t), { start: e, end: t };
}, XG = (e) => {
  const t = Yi(!1), r = Yi(!0);
  return sQ(t, r, e), { start: t, end: r };
}, tQ = (e, t) => e === void 0 ? t : (yn(e.end, t.start), e.end.isEnd = !1, { start: e.start, end: t.end }), eQ = (e, t) => {
  const r = Yi(!1);
  yn(r, e.start), yn(r, t.start);
  const n = Yi(!0);
  return yn(e.end, n), e.end.isEnd = !1, yn(t.end, n), t.end.isEnd = !1, { start: r, end: n };
}, rQ = (e) => {
  const t = Yi(!1), r = Yi(!0);
  return yn(t, r), yn(t, e.start), yn(e.end, r), yn(e.end, e.start), e.end.isEnd = !1, { start: t, end: r };
}, nQ = (e) => {
  const t = Yi(!1), r = Yi(!0);
  return yn(t, r), yn(t, e.start), yn(e.end, r), e.end.isEnd = !1, { start: t, end: r };
}, iQ = (e) => {
  const t = Yi(!1), r = Yi(!0);
  return yn(t, e.start), yn(e.end, r), yn(e.end, e.start), e.end.isEnd = !1, { start: t, end: r };
}, yn = (e, t) => {
  e.epsilonTransitions.push(t);
}, sQ = (e, t, r) => {
  e.transition[r] = t;
}, Yi = (e) => ({
  isEnd: e,
  transition: {},
  epsilonTransitions: []
}), oQ = "https://json-schema.org/keyword/itemPattern", $R = async (e, t) => {
  const r = [[]];
  let n = r[0];
  for await (const i of Kl(e))
    if (ca(i) === "string") {
      const s = Ee(i);
      if (s === "*")
        n.push(rQ(n.pop()));
      else if (s === "?")
        n.push(nQ(n.pop()));
      else if (s === "+")
        n.push(iQ(n.pop()));
      else if (s === "|")
        n = [], r.push(n);
      else
        throw Error(`Unsupported pattern syntax: ${s}`);
    } else {
      const s = ca(i) === "array" ? $R(i, t) : XG(await Vt.compile(i, t));
      n.push(await s);
    }
  return xR(e) === 0 ? JG() : r.map((i) => i.reduce(tQ)).reduce(eQ);
}, O6 = (e) => (t, r, n, i, s) => {
  if (Fe(r) !== "array")
    return !0;
  let o = [];
  y3(t.start, o, []);
  for (const a of Vu(r)) {
    const l = [];
    for (const c of o) {
      const h = aQ(e, c.transition, a, n, i, s);
      h && y3(h, l, []);
    }
    o = l;
  }
  return !!o.find((a) => a.isEnd);
}, y3 = (e, t, r) => {
  if (e.epsilonTransitions.length)
    for (const n of e.epsilonTransitions)
      r.find((i) => i === n) || (r.push(n), y3(n, t, r));
  else
    t.push(e);
}, aQ = (e, t, r, n, i, s) => {
  for (const o in t)
    if (e(o, r, n, i, s))
      return t[o];
}, lQ = O6(Vt.interpret), cQ = O6(Vt.collectEvaluatedProperties), uQ = O6(Vt.collectEvaluatedItems), hQ = { id: oQ, compile: $R, interpret: lQ, collectEvalatedProperties: cQ, collectEvalatedItems: uQ }, pQ = "https://json-schema.org/keyword/items", dQ = async (e, t, r) => {
  const n = Vr(e.document.dialectId, "https://json-schema.org/keyword/prefixItems"), i = await Ps(n, r);
  return [ca(i) === "array" ? xR(i) : 0, await Vt.compile(e, t)];
}, zR = ([e, t], r, n, i, s) => {
  if (Fe(r) !== "array")
    return !0;
  let o = !0;
  for (const a of PU(e, Vu(r)))
    Vt.interpret(t, a, n, i, s) || (o = !1);
  return o;
}, fQ = (e, t, r, n) => {
  if (!zR(e, t, r, n, !0))
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (let s = e[0]; s < E0(t); s++)
    i.add(s);
  return i;
}, gQ = { id: pQ, compile: dQ, interpret: zR, collectEvaluatedItems: fQ }, mQ = "https://json-schema.org/keyword/maxContains", yQ = (e) => Ee(e), bQ = () => !0, vQ = { id: mQ, compile: yQ, interpret: bQ }, wQ = "https://json-schema.org/keyword/maxItems", xQ = (e) => Ee(e), EQ = (e, t) => Fe(t) !== "array" || E0(t) <= e, AQ = { id: wQ, compile: xQ, interpret: EQ }, SQ = "https://json-schema.org/keyword/maxLength", _Q = (e) => Ee(e), kQ = (e, t) => Fe(t) !== "string" || [...br(t)].length <= e, CQ = { id: SQ, compile: _Q, interpret: kQ }, IQ = "https://json-schema.org/keyword/maxProperties", PQ = (e) => Ee(e), RQ = (e, t) => Fe(t) !== "object" || [...R6(t)].length <= e, TQ = { id: IQ, compile: PQ, interpret: RQ }, OQ = "https://json-schema.org/keyword/maximum", LQ = (e) => Ee(e), MQ = (e, t) => Fe(t) !== "number" || br(t) <= e, NQ = { id: OQ, compile: LQ, interpret: MQ }, DQ = "https://json-schema.org/keyword/minContains", BQ = (e) => Ee(e), jQ = () => !0, FQ = { id: DQ, compile: BQ, interpret: jQ }, $Q = "https://json-schema.org/keyword/minItems", zQ = (e) => Ee(e), VQ = (e, t) => Fe(t) !== "array" || E0(t) >= e, UQ = { id: $Q, compile: zQ, interpret: VQ }, HQ = "https://json-schema.org/keyword/minLength", GQ = (e) => Ee(e), QQ = (e, t) => Fe(t) !== "string" || [...br(t)].length >= e, WQ = { id: HQ, compile: GQ, interpret: QQ }, qQ = "https://json-schema.org/keyword/minProperties", YQ = (e) => Ee(e), KQ = (e, t) => Fe(t) !== "object" || [...R6(t)].length >= e, ZQ = { id: qQ, compile: YQ, interpret: KQ }, JQ = "https://json-schema.org/keyword/minimum", XQ = (e) => Ee(e), tW = (e, t) => Fe(t) !== "number" || br(t) >= e, eW = { id: JQ, compile: XQ, interpret: tW }, rW = "https://json-schema.org/keyword/multipleOf", nW = (e) => Ee(e), iW = (e, t) => {
  if (Fe(t) !== "number")
    return !0;
  const r = br(t) % e;
  return t9(0, r) || t9(e, r);
}, t9 = (e, t) => Math.abs(e - t) < 11920929e-14, sW = { id: rW, compile: nW, interpret: iW }, oW = "https://json-schema.org/keyword/not", aW = (...e) => Vt.compile(...e), lW = (...e) => !Vt.interpret(...e), cW = { id: oW, compile: aW, interpret: lW }, uW = "https://json-schema.org/keyword/oneOf", hW = (e, t) => on(
  Kl(e),
  Bn((r) => Vt.compile(r, t)),
  Ls
), pW = (e, t, r, n, i) => {
  let s = 0;
  for (const o of e)
    Vt.interpret(o, t, r, n, i) && s++;
  return s === 1;
}, dW = (e, t, r, n) => {
  let i = !1;
  for (const s of e) {
    const o = Vt.collectEvaluatedProperties(s, t, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, fW = (e, t, r, n) => {
  let i = !1;
  for (const s of e) {
    const o = Vt.collectEvaluatedItems(s, t, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, gW = { id: uW, compile: hW, interpret: pW, collectEvaluatedProperties: dW, collectEvaluatedItems: fW }, mW = "https://json-schema.org/keyword/pattern", yW = (e) => new RegExp(Ee(e), "u"), bW = (e, t) => Fe(t) !== "string" || e.test(br(t)), vW = { id: mW, compile: yW, interpret: bW }, wW = "https://json-schema.org/keyword/patternProperties", xW = (e, t) => on(
  mu(e),
  Bn(async ([r, n]) => [
    new RegExp(r, "u"),
    await Vt.compile(n, t)
  ]),
  Ls
), EW = (e, t, r, n, i) => {
  if (Fe(t) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of e)
    for (const [l, c] of Zl(t)) {
      const h = br(l);
      o.test(h) && !Vt.interpret(a, c, r, n, i) && (s = !1);
    }
  return s;
}, AW = (e, t, r, n) => {
  if (Fe(t) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of e)
    for (const [a, l] of Zl(t)) {
      const c = br(a);
      if (s.test(c)) {
        if (!Vt.interpret(o, l, r, n, !0))
          return !1;
        i.add(c);
      }
    }
  return i;
}, SW = { id: wW, compile: xW, interpret: EW, collectEvaluatedProperties: AW }, _W = "https://json-schema.org/keyword/prefixItems", kW = (e, t) => on(
  Kl(e),
  Bn((r) => Vt.compile(r, t)),
  Ls
), VR = (e, t, r, n, i) => {
  if (Fe(t) !== "array")
    return !0;
  let s = !0, o = 0;
  const a = E0(t);
  for (const [l, c] of P6(e, Vu(t))) {
    if (o >= a)
      break;
    Vt.interpret(l, c, r, n, i) || (s = !1), o++;
  }
  return s;
}, CW = (e, t, r, n) => VR(e, t, r, n, !0) && new Set(e.map((i, s) => s)), IW = { id: _W, compile: kW, interpret: VR, collectEvaluatedItems: CW }, PW = "https://json-schema.org/keyword/properties", RW = (e, t) => on(
  mu(e),
  Bn(async ([r, n]) => [r, await Vt.compile(n, t)]),
  g3
), TW = (e, t, r, n, i) => {
  if (Fe(t) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of Zl(t)) {
    const l = br(o);
    l in e && !Vt.interpret(e[l], a, r, n, i) && (s = !1);
  }
  return s;
}, OW = (e, t, r, n) => {
  if (Fe(t) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of Zl(t)) {
    const a = br(s);
    if (a in e) {
      if (!Vt.interpret(e[a], o, r, n, !0))
        return !1;
      i.add(a);
    }
  }
  return i;
}, LW = { id: PW, compile: RW, interpret: TW, collectEvaluatedProperties: OW }, MW = "https://json-schema.org/keyword/propertyDependencies", NW = (e, t) => on(
  mu(e),
  Bn(async ([r, n]) => [r, await on(
    mu(n),
    Bn(async ([i, s]) => [i, await Vt.compile(s, t)]),
    g3
  )]),
  g3
), DW = (e, t, r, n, i) => {
  if (Fe(t) !== "object")
    return !0;
  let s = !0;
  const o = br(t);
  for (const [a, l] of Object.entries(e)) {
    const c = o[a];
    Zh(a, t) && c in l && !Vt.interpret(l[c], t, r, n, i) && (s = !1);
  }
  return s;
}, BW = (e, t, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s in e) {
    const o = br(t)[s], a = e[s];
    if (Zh(s, t) && o in a) {
      const l = Vt.collectEvaluatedProperties(a[o], t, r, n);
      if (!l)
        return !1;
      l.forEach(i.add, i);
    }
  }
  return i;
}, jW = { id: MW, compile: NW, interpret: DW, collectEvaluatedProperties: BW }, FW = "https://json-schema.org/keyword/propertyNames", $W = (e, t) => Vt.compile(e, t), zW = (e, t, r, n) => {
  if (Fe(t) !== "object")
    return !0;
  let i = !0;
  for (const s of R6(t))
    Vt.interpret(e, s, r, n, !0) || (i = !1);
  return i;
}, VW = { id: FW, compile: $W, interpret: zW }, UR = "https://json-schema.org/keyword/readOnly", UW = (e) => Ee(e), HW = (e, t, r, n, i, s) => (cs(t, UR, s, e), !0), GW = { id: UR, compile: UW, interpret: HW }, QW = "https://json-schema.org/keyword/ref", WW = (...e) => Vt.compile(...e), qW = (...e) => Vt.interpret(...e), YW = (...e) => Vt.collectEvaluatedProperties(...e), KW = (...e) => Vt.collectEvaluatedItems(...e), ZW = { id: QW, compile: WW, interpret: qW, collectEvaluatedProperties: YW, collectEvaluatedItems: KW }, JW = "https://json-schema.org/keyword/requireAllExcept", XW = async (e, t, r) => {
  const n = await Ee(e), i = Vr(e.document.dialectId, "https://json-schema.org/keyword/properties"), s = await Ps(i, r), o = ca(s) === "object" ? d3(s) : [], a = new Set(o);
  return n.forEach((l) => o.remove(l)), [...a];
}, tq = (e, t) => Fe(t) !== "object" || e.every((r) => Object.hasOwn(br(t), r)), eq = { id: JW, compile: XW, interpret: tq }, rq = "https://json-schema.org/keyword/required", nq = (e) => Ee(e), iq = (e, t) => Fe(t) !== "object" || e.every((r) => Object.hasOwn(br(t), r)), sq = { id: rq, compile: nq, interpret: iq }, HR = "https://json-schema.org/keyword/title", oq = (e) => Ee(e), aq = (e, t, r, n, i, s) => (cs(t, HR, s, e), !0), lq = { id: HR, compile: oq, interpret: aq }, cq = "https://json-schema.org/keyword/then", uq = async (e, t, r) => {
  const n = Vr(e.document.dialectId, "https://json-schema.org/keyword/if");
  if (wR(n, r)) {
    const i = await Ps(n, r);
    return [await Vt.compile(i, t), await Vt.compile(e, t)];
  } else
    return [];
}, hq = ([e, t], r, n, i, s) => e === void 0 || !Vt.interpret(e, r, n, i, !0) || Vt.interpret(t, r, n, i, s), pq = ([e, t], r, n, i) => e === void 0 || !Vt.interpret(e, r, n, i, !0) ? /* @__PURE__ */ new Set() : Vt.collectEvaluatedProperties(t, r, n, i), dq = ([e, t], r, n, i) => e === void 0 || !Vt.interpret(e, r, n, i, !0) ? /* @__PURE__ */ new Set() : Vt.collectEvaluatedItems(t, r, n, i), fq = { id: cq, compile: uq, interpret: hq, collectEvaluatedProperties: pq, collectEvaluatedItems: dq }, gq = "https://json-schema.org/keyword/type", mq = (e) => Ee(e), yq = (e, t) => typeof e == "string" ? e9(t)(e) : e.some(e9(t)), e9 = (e) => (t) => t === "integer" ? Fe(e) === "number" && Number.isInteger(br(e)) : Fe(e) === t, bq = { id: gq, compile: mq, interpret: yq }, vq = "https://json-schema.org/keyword/unevaluatedItems", wq = async (e, t, r) => [Kh(r), await Vt.compile(e, t)], xq = ([e, t], r, n, i, s) => {
  if (Fe(r) !== "array")
    return !0;
  const o = Vt.collectEvaluatedItems(e, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of P6(Vu(r), SR(0)))
    !o.has(c) && !Vt.interpret(t, l, n, i, s) && (a = !1);
  return a;
}, Eq = (e, t, r, n) => {
  const i = Vt.collectEvaluatedItems(e[0], t, r, n, !0);
  if (!i)
    return !1;
  const s = /* @__PURE__ */ new Set();
  for (let o = 0; o < E0(t); o++)
    i.has(o) || s.add(o);
  return s;
}, Aq = { id: vq, compile: wq, interpret: xq, collectEvaluatedItems: Eq }, Sq = "https://json-schema.org/keyword/unevaluatedProperties", _q = async (e, t, r) => [Kh(r), await Vt.compile(e, t)], kq = ([e, t], r, n, i, s) => {
  if (Fe(r) !== "object")
    return !0;
  const o = Vt.collectEvaluatedProperties(e, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of Zl(r)) {
    const h = br(l);
    !o.has(h) && !Vt.interpret(t, c, n, i, s) && (a = !1);
  }
  return a;
}, Cq = ([e, t], r, n, i) => {
  if (Fe(r) !== "object")
    return !0;
  const s = Vt.collectEvaluatedProperties(e, r, n, i, !0);
  if (!s)
    return !1;
  for (const [o, a] of Zl(r)) {
    const l = br(o);
    if (!s.has(l)) {
      if (!Vt.interpret(t, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, Iq = { id: Sq, compile: _q, interpret: kq, collectEvaluatedProperties: Cq }, Pq = "https://json-schema.org/keyword/uniqueItems", Rq = (e) => Ee(e), Tq = (e, t) => {
  if (Fe(t) !== "array" || e === !1)
    return !0;
  const r = br(t).map(A0);
  return new Set(r).size === r.length;
}, Oq = { id: Pq, compile: Rq, interpret: Tq }, GR = "https://json-schema.org/keyword/unknown", Lq = (e) => [[...c3(e.cursor)].pop(), Ee(e)], Mq = ([e, t], r, n, i, s, o) => {
  const a = `${GR}#${e}`;
  return cs(r, a, o, t), !0;
}, Nq = { id: GR, compile: Lq, interpret: Mq }, Dq = { id: "https://json-schema.org/keyword/vocabulary" }, QR = "https://json-schema.org/keyword/writeOnly", Bq = (e) => Ee(e), jq = (e, t, r, n, i, s) => (cs(t, QR, s, e), !0), Fq = { id: QR, compile: Bq, interpret: jq };
fR("application/schema+json", CU);
re(rH);
re(lH);
re(cH);
re(gH);
re(xH);
re(IH);
re(OH);
re(DH);
re(FH);
re(VH);
re(GH);
re(qH);
re(JH);
re(rG);
re(aG);
re(uG);
re(dG);
re(fG);
re(wG);
re(kG);
re(RG);
re(LG);
re(BG);
re(zG);
re(HG);
re(GG);
re(ZG);
re(hQ);
re(gQ);
re(vQ);
re(AQ);
re(CQ);
re(TQ);
re(NQ);
re(FQ);
re(UQ);
re(WQ);
re(ZQ);
re(eW);
re(sW);
re(cW);
re(gW);
re(vW);
re(SW);
re(IW);
re(LW);
re(jW);
re(VW);
re(GW);
re(ZW);
re(eq);
re(sq);
re(lq);
re(fq);
re(bq);
re(Aq);
re(Iq);
re(Oq);
re(Nq);
re(Dq);
re(Fq);
const $q = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://json-schema.org/draft/2020-12/schema",
  $vocabulary: {
    "https://json-schema.org/draft/2020-12/vocab/core": !0,
    "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
    "https://json-schema.org/draft/2020-12/vocab/validation": !0,
    "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
    "https://json-schema.org/draft/2020-12/vocab/content": !0
  },
  $dynamicAnchor: "meta",
  title: "Core and Validation specifications meta-schema",
  allOf: [
    { $ref: "meta/core" },
    { $ref: "meta/applicator" },
    { $ref: "meta/unevaluated" },
    { $ref: "meta/validation" },
    { $ref: "meta/meta-data" },
    { $ref: "meta/format-annotation" },
    { $ref: "meta/content" }
  ],
  type: ["object", "boolean"],
  properties: {
    definitions: {
      $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    dependencies: {
      $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
      type: "object",
      additionalProperties: {
        anyOf: [
          { $dynamicRef: "#meta" },
          { $ref: "meta/validation#/$defs/stringArray" }
        ]
      }
    }
  }
}, zq = {
  $id: "https://json-schema.org/draft/2020-12/meta/core",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Core vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    $id: {
      type: "string",
      format: "uri-reference",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $anchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicRef: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicAnchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        type: "string",
        format: "uri"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    }
  }
}, Vq = {
  $id: "https://json-schema.org/draft/2020-12/meta/applicator",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    prefixItems: { $ref: "#/$defs/schemaArray" },
    items: { $dynamicRef: "#meta" },
    contains: { $dynamicRef: "#meta" },
    additionalProperties: { $dynamicRef: "#meta" },
    properties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      propertyNames: { format: "regex" },
      default: {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      }
    },
    propertyNames: { $dynamicRef: "#meta" },
    if: { $dynamicRef: "#meta" },
    then: { $dynamicRef: "#meta" },
    else: { $dynamicRef: "#meta" },
    allOf: { $ref: "#/$defs/schemaArray" },
    anyOf: { $ref: "#/$defs/schemaArray" },
    oneOf: { $ref: "#/$defs/schemaArray" },
    not: { $dynamicRef: "#meta" }
  },
  $defs: {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: { $dynamicRef: "#meta" }
    }
  }
}, Uq = {
  $id: "https://json-schema.org/draft/2020-12/meta/validation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Validation vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: { $ref: "#/$defs/nonNegativeInteger" },
    minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: { $ref: "#/$defs/nonNegativeInteger" },
    minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    uniqueItems: {
      type: "boolean",
      default: !1
    },
    maxContains: { $ref: "#/$defs/nonNegativeInteger" },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 1
    },
    maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
    minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    required: { $ref: "#/$defs/stringArray" },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    },
    const: !0,
    enum: {
      type: "array",
      items: !0
    },
    type: {
      anyOf: [
        { $ref: "#/$defs/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/$defs/simpleTypes" },
          minItems: 1,
          uniqueItems: !0
        }
      ]
    }
  },
  $defs: {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 0
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: []
    }
  }
}, Hq = {
  $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Meta-data vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    default: !0,
    deprecated: {
      type: "boolean",
      default: !1
    },
    readOnly: {
      type: "boolean",
      default: !1
    },
    writeOnly: {
      type: "boolean",
      default: !1
    },
    examples: {
      type: "array",
      items: !0
    }
  }
}, Gq = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for annotation results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, Qq = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-assertion",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for assertion results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, Wq = {
  $id: "https://json-schema.org/draft/2020-12/meta/content",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Content vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    contentSchema: { $dynamicRef: "#meta" }
  }
}, qq = {
  $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Unevaluated applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    unevaluatedItems: { $dynamicRef: "#meta" },
    unevaluatedProperties: { $dynamicRef: "#meta" }
  }
}, Yq = { id: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor" }, Kq = "https://json-schema.org/keyword/draft-2020-12/dynamicRef", Zq = async (e, t) => {
  const r = cR(Ee(e)), n = await Hy(Ee(e), e);
  return await Vt.compile(n, t), [n.document.baseUri, r, Kh(n)];
}, L6 = (e, [t, r, n], i, s, o, a) => r in s.metaData[t].dynamicAnchors ? (o = { ...s.metaData[t].dynamicAnchors, ...o }, e(o[r], i, s, o, a)) : e(n, i, s, o, a), Jq = (...e) => L6(Vt.interpret, ...e), Xq = (...e) => L6(Vt.collectEvaluatedProperties, ...e), tY = (...e) => L6(Vt.collectEvaluatedItems, ...e), eY = { id: Kq, compile: Zq, interpret: Jq, collectEvaluatedProperties: Xq, collectEvaluatedItems: tY };
re(eY);
re(Yq);
Yl("https://json-schema.org/draft/2020-12/vocab/core", {
  $anchor: "https://json-schema.org/keyword/anchor",
  $comment: "https://json-schema.org/keyword/comment",
  $defs: "https://json-schema.org/keyword/definitions",
  $dynamicAnchor: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor",
  $dynamicRef: "https://json-schema.org/keyword/draft-2020-12/dynamicRef",
  $id: "https://json-schema.org/keyword/id",
  $ref: "https://json-schema.org/keyword/ref",
  $vocabulary: "https://json-schema.org/keyword/vocabulary"
});
Yl("https://json-schema.org/draft/2020-12/vocab/applicator", {
  additionalProperties: "https://json-schema.org/keyword/additionalProperties",
  allOf: "https://json-schema.org/keyword/allOf",
  anyOf: "https://json-schema.org/keyword/anyOf",
  contains: "https://json-schema.org/keyword/contains",
  dependentSchemas: "https://json-schema.org/keyword/dependentSchemas",
  if: "https://json-schema.org/keyword/if",
  then: "https://json-schema.org/keyword/then",
  else: "https://json-schema.org/keyword/else",
  items: "https://json-schema.org/keyword/items",
  not: "https://json-schema.org/keyword/not",
  oneOf: "https://json-schema.org/keyword/oneOf",
  patternProperties: "https://json-schema.org/keyword/patternProperties",
  prefixItems: "https://json-schema.org/keyword/prefixItems",
  properties: "https://json-schema.org/keyword/properties",
  propertyNames: "https://json-schema.org/keyword/propertyNames"
});
Yl("https://json-schema.org/draft/2020-12/vocab/validation", {
  const: "https://json-schema.org/keyword/const",
  dependentRequired: "https://json-schema.org/keyword/dependentRequired",
  enum: "https://json-schema.org/keyword/enum",
  exclusiveMaximum: "https://json-schema.org/keyword/exclusiveMaximum",
  exclusiveMinimum: "https://json-schema.org/keyword/exclusiveMinimum",
  maxContains: "https://json-schema.org/keyword/maxContains",
  maxItems: "https://json-schema.org/keyword/maxItems",
  maxLength: "https://json-schema.org/keyword/maxLength",
  maxProperties: "https://json-schema.org/keyword/maxProperties",
  maximum: "https://json-schema.org/keyword/maximum",
  minContains: "https://json-schema.org/keyword/minContains",
  minItems: "https://json-schema.org/keyword/minItems",
  minLength: "https://json-schema.org/keyword/minLength",
  minProperties: "https://json-schema.org/keyword/minProperties",
  minimum: "https://json-schema.org/keyword/minimum",
  multipleOf: "https://json-schema.org/keyword/multipleOf",
  pattern: "https://json-schema.org/keyword/pattern",
  required: "https://json-schema.org/keyword/required",
  type: "https://json-schema.org/keyword/type",
  uniqueItems: "https://json-schema.org/keyword/uniqueItems"
});
Yl("https://json-schema.org/draft/2020-12/vocab/meta-data", {
  default: "https://json-schema.org/keyword/default",
  deprecated: "https://json-schema.org/keyword/deprecated",
  description: "https://json-schema.org/keyword/description",
  examples: "https://json-schema.org/keyword/examples",
  readOnly: "https://json-schema.org/keyword/readOnly",
  title: "https://json-schema.org/keyword/title",
  writeOnly: "https://json-schema.org/keyword/writeOnly"
});
Yl("https://json-schema.org/draft/2020-12/vocab/format-annotation", {
  format: "https://json-schema.org/keyword/format"
});
Yl("https://json-schema.org/draft/2020-12/vocab/format-assertion", {
  format: "https://json-schema.org/keyword/format-assertion"
});
Yl("https://json-schema.org/draft/2020-12/vocab/content", {
  contentEncoding: "https://json-schema.org/keyword/contentEncoding",
  contentMediaType: "https://json-schema.org/keyword/contentMediaType",
  contentSchema: "https://json-schema.org/keyword/contentSchema"
});
Yl("https://json-schema.org/draft/2020-12/vocab/unevaluated", {
  unevaluatedItems: "https://json-schema.org/keyword/unevaluatedItems",
  unevaluatedProperties: "https://json-schema.org/keyword/unevaluatedProperties"
});
hR("https://json-schema.org/draft/2020-12/schema", {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, !0);
va($q);
va(zq);
va(Vq);
va(Uq);
va(Hq);
va(Gq);
va(Qq);
va(Wq);
va(qq);
function Vg(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var r9 = { exports: {} };
/*! jsonpath 1.1.1 */
var n9;
function rY() {
  return n9 || (n9 = 1, function(e, t) {
    (function(r) {
      e.exports = r();
    })(function() {
      return function r(n, i, s) {
        function o(c, h) {
          if (!i[c]) {
            if (!n[c]) {
              var u = typeof Vg == "function" && Vg;
              if (!h && u) return u(c, !0);
              if (a) return a(c, !0);
              var p = new Error("Cannot find module '" + c + "'");
              throw p.code = "MODULE_NOT_FOUND", p;
            }
            var y = i[c] = { exports: {} };
            n[c][0].call(y.exports, function(g) {
              var b = n[c][1][g];
              return o(b || g);
            }, y, y.exports, r, n, i, s);
          }
          return i[c].exports;
        }
        for (var a = typeof Vg == "function" && Vg, l = 0; l < s.length; l++) o(s[l]);
        return o;
      }({ "./aesprim": [function(r, n, i) {
        (function(s, o) {
          o(typeof i < "u" ? i : s.esprima = {});
        })(this, function(s) {
          var o, a, l, c, h, u, p, y, g, b, f, E, A, x, m, w, _, S;
          o = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
          }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
            "(",
            "{",
            "[",
            "in",
            "typeof",
            "instanceof",
            "new",
            "return",
            "case",
            "delete",
            "throw",
            "void",
            // assignment operators
            "=",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "<<=",
            ">>=",
            ">>>=",
            "&=",
            "|=",
            "^=",
            ",",
            // binary/unary operators
            "+",
            "-",
            "*",
            "/",
            "%",
            "++",
            "--",
            "<<",
            ">>",
            ">>>",
            "&",
            "|",
            "^",
            "!",
            "~",
            "&&",
            "||",
            "?",
            ":",
            "===",
            "==",
            ">=",
            "<=",
            "<",
            ">",
            "!=",
            "!=="
          ], c = {
            AssignmentExpression: "AssignmentExpression",
            ArrayExpression: "ArrayExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            Program: "Program",
            Property: "Property",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SwitchStatement: "SwitchStatement",
            SwitchCase: "SwitchCase",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement"
          }, h = {
            Data: 1,
            Get: 2,
            Set: 4
          }, u = {
            UnexpectedToken: "Unexpected token %0",
            UnexpectedNumber: "Unexpected number",
            UnexpectedString: "Unexpected string",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedEOS: "Unexpected end of input",
            NewlineAfterThrow: "Illegal newline after throw",
            InvalidRegExp: "Invalid regular expression",
            UnterminatedRegExp: "Invalid regular expression: missing /",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NoCatchOrFinally: "Missing catch or finally after try",
            UnknownLabel: "Undefined label '%0'",
            Redeclaration: "%0 '%1' has already been declared",
            IllegalContinue: "Illegal continue statement",
            IllegalBreak: "Illegal break statement",
            IllegalReturn: "Illegal return statement",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
            AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
            AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode"
          }, p = {
            NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
            NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
          };
          function R(d, v) {
            if (!d)
              throw new Error("ASSERT: " + v);
          }
          function O(d) {
            return d >= 48 && d <= 57;
          }
          function $(d) {
            return "0123456789abcdefABCDEF".indexOf(d) >= 0;
          }
          function z(d) {
            return "01234567".indexOf(d) >= 0;
          }
          function F(d) {
            return d === 32 || d === 9 || d === 11 || d === 12 || d === 160 || d >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(d) >= 0;
          }
          function Y(d) {
            return d === 10 || d === 13 || d === 8232 || d === 8233;
          }
          function rt(d) {
            return d == 64 || d === 36 || d === 95 || // $ (dollar) and _ (underscore)
            d >= 65 && d <= 90 || // A..Z
            d >= 97 && d <= 122 || // a..z
            d === 92 || // \ (backslash)
            d >= 128 && p.NonAsciiIdentifierStart.test(String.fromCharCode(d));
          }
          function at(d) {
            return d === 36 || d === 95 || // $ (dollar) and _ (underscore)
            d >= 65 && d <= 90 || // A..Z
            d >= 97 && d <= 122 || // a..z
            d >= 48 && d <= 57 || // 0..9
            d === 92 || // \ (backslash)
            d >= 128 && p.NonAsciiIdentifierPart.test(String.fromCharCode(d));
          }
          function pt(d) {
            switch (d) {
              case "class":
              case "enum":
              case "export":
              case "extends":
              case "import":
              case "super":
                return !0;
              default:
                return !1;
            }
          }
          function vt(d) {
            switch (d) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return !0;
              default:
                return !1;
            }
          }
          function _t(d) {
            return d === "eval" || d === "arguments";
          }
          function Ct(d) {
            if (b && vt(d))
              return !0;
            switch (d.length) {
              case 2:
                return d === "if" || d === "in" || d === "do";
              case 3:
                return d === "var" || d === "for" || d === "new" || d === "try" || d === "let";
              case 4:
                return d === "this" || d === "else" || d === "case" || d === "void" || d === "with" || d === "enum";
              case 5:
                return d === "while" || d === "break" || d === "catch" || d === "throw" || d === "const" || d === "yield" || d === "class" || d === "super";
              case 6:
                return d === "return" || d === "typeof" || d === "delete" || d === "switch" || d === "export" || d === "import";
              case 7:
                return d === "default" || d === "finally" || d === "extends";
              case 8:
                return d === "function" || d === "continue" || d === "debugger";
              case 10:
                return d === "instanceof";
              default:
                return !1;
            }
          }
          function It(d, v, I, j, Z) {
            var ht;
            R(typeof I == "number", "Comment must have valid position"), !(_.lastCommentStart >= I) && (_.lastCommentStart = I, ht = {
              type: d,
              value: v
            }, S.range && (ht.range = [I, j]), S.loc && (ht.loc = Z), S.comments.push(ht), S.attachComment && (S.leadingComments.push(ht), S.trailingComments.push(ht)));
          }
          function jt(d) {
            var v, I, j, Z;
            for (v = f - d, I = {
              start: {
                line: E,
                column: f - A - d
              }
            }; f < x; )
              if (j = g.charCodeAt(f), ++f, Y(j)) {
                S.comments && (Z = g.slice(v + d, f - 1), I.end = {
                  line: E,
                  column: f - A - 1
                }, It("Line", Z, v, f - 1, I)), j === 13 && g.charCodeAt(f) === 10 && ++f, ++E, A = f;
                return;
              }
            S.comments && (Z = g.slice(v + d, f), I.end = {
              line: E,
              column: f - A
            }, It("Line", Z, v, f, I));
          }
          function lt() {
            var d, v, I, j;
            for (S.comments && (d = f - 2, v = {
              start: {
                line: E,
                column: f - A - 2
              }
            }); f < x; )
              if (I = g.charCodeAt(f), Y(I))
                I === 13 && g.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && bt({}, u.UnexpectedToken, "ILLEGAL");
              else if (I === 42) {
                if (g.charCodeAt(f + 1) === 47) {
                  ++f, ++f, S.comments && (j = g.slice(d + 2, f - 2), v.end = {
                    line: E,
                    column: f - A
                  }, It("Block", j, d, f, v));
                  return;
                }
                ++f;
              } else
                ++f;
            bt({}, u.UnexpectedToken, "ILLEGAL");
          }
          function L() {
            var d, v;
            for (v = f === 0; f < x; )
              if (d = g.charCodeAt(f), F(d))
                ++f;
              else if (Y(d))
                ++f, d === 13 && g.charCodeAt(f) === 10 && ++f, ++E, A = f, v = !0;
              else if (d === 47)
                if (d = g.charCodeAt(f + 1), d === 47)
                  ++f, ++f, jt(2), v = !0;
                else if (d === 42)
                  ++f, ++f, lt();
                else
                  break;
              else if (v && d === 45)
                if (g.charCodeAt(f + 1) === 45 && g.charCodeAt(f + 2) === 62)
                  f += 3, jt(3);
                else
                  break;
              else if (d === 60)
                if (g.slice(f + 1, f + 4) === "!--")
                  ++f, ++f, ++f, ++f, jt(4);
                else
                  break;
              else
                break;
          }
          function D(d) {
            var v, I, j, Z = 0;
            for (I = d === "u" ? 4 : 2, v = 0; v < I; ++v)
              if (f < x && $(g[f]))
                j = g[f++], Z = Z * 16 + "0123456789abcdef".indexOf(j.toLowerCase());
              else
                return "";
            return String.fromCharCode(Z);
          }
          function tt() {
            var d, v;
            for (d = g.charCodeAt(f++), v = String.fromCharCode(d), d === 92 && (g.charCodeAt(f) !== 117 && bt({}, u.UnexpectedToken, "ILLEGAL"), ++f, d = D("u"), (!d || d === "\\" || !rt(d.charCodeAt(0))) && bt({}, u.UnexpectedToken, "ILLEGAL"), v = d); f < x && (d = g.charCodeAt(f), !!at(d)); )
              ++f, v += String.fromCharCode(d), d === 92 && (v = v.substr(0, v.length - 1), g.charCodeAt(f) !== 117 && bt({}, u.UnexpectedToken, "ILLEGAL"), ++f, d = D("u"), (!d || d === "\\" || !at(d.charCodeAt(0))) && bt({}, u.UnexpectedToken, "ILLEGAL"), v += d);
            return v;
          }
          function et() {
            var d, v;
            for (d = f++; f < x; ) {
              if (v = g.charCodeAt(f), v === 92)
                return f = d, tt();
              if (at(v))
                ++f;
              else
                break;
            }
            return g.slice(d, f);
          }
          function st() {
            var d, v, I;
            return d = f, v = g.charCodeAt(f) === 92 ? tt() : et(), v.length === 1 ? I = o.Identifier : Ct(v) ? I = o.Keyword : v === "null" ? I = o.NullLiteral : v === "true" || v === "false" ? I = o.BooleanLiteral : I = o.Identifier, {
              type: I,
              value: v,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          }
          function X() {
            var d = f, v = g.charCodeAt(f), I, j = g[f], Z, ht, Ot;
            switch (v) {
              case 46:
              case 40:
              case 41:
              case 59:
              case 44:
              case 123:
              case 125:
              case 91:
              case 93:
              case 58:
              case 63:
              case 126:
                return ++f, S.tokenize && (v === 40 ? S.openParenToken = S.tokens.length : v === 123 && (S.openCurlyToken = S.tokens.length)), {
                  type: o.Punctuator,
                  value: String.fromCharCode(v),
                  lineNumber: E,
                  lineStart: A,
                  start: d,
                  end: f
                };
              default:
                if (I = g.charCodeAt(f + 1), I === 61)
                  switch (v) {
                    case 43:
                    case 45:
                    case 47:
                    case 60:
                    case 62:
                    case 94:
                    case 124:
                    case 37:
                    case 38:
                    case 42:
                      return f += 2, {
                        type: o.Punctuator,
                        value: String.fromCharCode(v) + String.fromCharCode(I),
                        lineNumber: E,
                        lineStart: A,
                        start: d,
                        end: f
                      };
                    case 33:
                    case 61:
                      return f += 2, g.charCodeAt(f) === 61 && ++f, {
                        type: o.Punctuator,
                        value: g.slice(d, f),
                        lineNumber: E,
                        lineStart: A,
                        start: d,
                        end: f
                      };
                  }
            }
            if (Ot = g.substr(f, 4), Ot === ">>>=")
              return f += 4, {
                type: o.Punctuator,
                value: Ot,
                lineNumber: E,
                lineStart: A,
                start: d,
                end: f
              };
            if (ht = Ot.substr(0, 3), ht === ">>>" || ht === "<<=" || ht === ">>=")
              return f += 3, {
                type: o.Punctuator,
                value: ht,
                lineNumber: E,
                lineStart: A,
                start: d,
                end: f
              };
            if (Z = ht.substr(0, 2), j === Z[1] && "+-<>&|".indexOf(j) >= 0 || Z === "=>")
              return f += 2, {
                type: o.Punctuator,
                value: Z,
                lineNumber: E,
                lineStart: A,
                start: d,
                end: f
              };
            if ("<>=!+-*%&|^/".indexOf(j) >= 0)
              return ++f, {
                type: o.Punctuator,
                value: j,
                lineNumber: E,
                lineStart: A,
                start: d,
                end: f
              };
            bt({}, u.UnexpectedToken, "ILLEGAL");
          }
          function ot(d) {
            for (var v = ""; f < x && $(g[f]); )
              v += g[f++];
            return v.length === 0 && bt({}, u.UnexpectedToken, "ILLEGAL"), rt(g.charCodeAt(f)) && bt({}, u.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt("0x" + v, 16),
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          }
          function mt(d) {
            for (var v = "0" + g[f++]; f < x && z(g[f]); )
              v += g[f++];
            return (rt(g.charCodeAt(f)) || O(g.charCodeAt(f))) && bt({}, u.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt(v, 8),
              octal: !0,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          }
          function U() {
            var d, v, I;
            if (I = g[f], R(
              O(I.charCodeAt(0)) || I === ".",
              "Numeric literal must start with a decimal digit or a decimal point"
            ), v = f, d = "", I !== ".") {
              if (d = g[f++], I = g[f], d === "0") {
                if (I === "x" || I === "X")
                  return ++f, ot(v);
                if (z(I))
                  return mt(v);
                I && O(I.charCodeAt(0)) && bt({}, u.UnexpectedToken, "ILLEGAL");
              }
              for (; O(g.charCodeAt(f)); )
                d += g[f++];
              I = g[f];
            }
            if (I === ".") {
              for (d += g[f++]; O(g.charCodeAt(f)); )
                d += g[f++];
              I = g[f];
            }
            if (I === "e" || I === "E")
              if (d += g[f++], I = g[f], (I === "+" || I === "-") && (d += g[f++]), O(g.charCodeAt(f)))
                for (; O(g.charCodeAt(f)); )
                  d += g[f++];
              else
                bt({}, u.UnexpectedToken, "ILLEGAL");
            return rt(g.charCodeAt(f)) && bt({}, u.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseFloat(d),
              lineNumber: E,
              lineStart: A,
              start: v,
              end: f
            };
          }
          function J() {
            var d = "", v, I, j, Z, ht, Ot, Gt = !1, fe, ce;
            for (fe = E, ce = A, v = g[f], R(
              v === "'" || v === '"',
              "String literal must starts with a quote"
            ), I = f, ++f; f < x; )
              if (j = g[f++], j === v) {
                v = "";
                break;
              } else if (j === "\\")
                if (j = g[f++], !j || !Y(j.charCodeAt(0)))
                  switch (j) {
                    case "u":
                    case "x":
                      Ot = f, ht = D(j), ht ? d += ht : (f = Ot, d += j);
                      break;
                    case "n":
                      d += `
`;
                      break;
                    case "r":
                      d += "\r";
                      break;
                    case "t":
                      d += "	";
                      break;
                    case "b":
                      d += "\b";
                      break;
                    case "f":
                      d += "\f";
                      break;
                    case "v":
                      d += "\v";
                      break;
                    default:
                      z(j) ? (Z = "01234567".indexOf(j), Z !== 0 && (Gt = !0), f < x && z(g[f]) && (Gt = !0, Z = Z * 8 + "01234567".indexOf(g[f++]), "0123".indexOf(j) >= 0 && f < x && z(g[f]) && (Z = Z * 8 + "01234567".indexOf(g[f++]))), d += String.fromCharCode(Z)) : d += j;
                      break;
                  }
                else
                  ++E, j === "\r" && g[f] === `
` && ++f, A = f;
              else {
                if (Y(j.charCodeAt(0)))
                  break;
                d += j;
              }
            return v !== "" && bt({}, u.UnexpectedToken, "ILLEGAL"), {
              type: o.StringLiteral,
              value: d,
              octal: Gt,
              startLineNumber: fe,
              startLineStart: ce,
              lineNumber: E,
              lineStart: A,
              start: I,
              end: f
            };
          }
          function St(d, v) {
            var I;
            try {
              I = new RegExp(d, v);
            } catch {
              bt({}, u.InvalidRegExp);
            }
            return I;
          }
          function Rt() {
            var d, v, I, j, Z;
            for (d = g[f], R(d === "/", "Regular expression literal must start with a slash"), v = g[f++], I = !1, j = !1; f < x; )
              if (d = g[f++], v += d, d === "\\")
                d = g[f++], Y(d.charCodeAt(0)) && bt({}, u.UnterminatedRegExp), v += d;
              else if (Y(d.charCodeAt(0)))
                bt({}, u.UnterminatedRegExp);
              else if (I)
                d === "]" && (I = !1);
              else if (d === "/") {
                j = !0;
                break;
              } else d === "[" && (I = !0);
            return j || bt({}, u.UnterminatedRegExp), Z = v.substr(1, v.length - 2), {
              value: Z,
              literal: v
            };
          }
          function zt() {
            var d, v, I, j;
            for (v = "", I = ""; f < x && (d = g[f], !!at(d.charCodeAt(0))); )
              if (++f, d === "\\" && f < x)
                if (d = g[f], d === "u") {
                  if (++f, j = f, d = D("u"), d)
                    for (I += d, v += "\\u"; j < f; ++j)
                      v += g[j];
                  else
                    f = j, I += "u", v += "\\u";
                  xt({}, u.UnexpectedToken, "ILLEGAL");
                } else
                  v += "\\", xt({}, u.UnexpectedToken, "ILLEGAL");
              else
                I += d, v += d;
            return {
              value: I,
              literal: v
            };
          }
          function Tt() {
            var d, v, I, j;
            return w = null, L(), d = f, v = Rt(), I = zt(), j = St(v.value, I.value), S.tokenize ? {
              type: o.RegularExpression,
              value: j,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            } : {
              literal: v.literal + I.literal,
              value: j,
              start: d,
              end: f
            };
          }
          function Yt() {
            var d, v, I, j;
            return L(), d = f, v = {
              start: {
                line: E,
                column: f - A
              }
            }, I = Tt(), v.end = {
              line: E,
              column: f - A
            }, S.tokenize || (S.tokens.length > 0 && (j = S.tokens[S.tokens.length - 1], j.range[0] === d && j.type === "Punctuator" && (j.value === "/" || j.value === "/=") && S.tokens.pop()), S.tokens.push({
              type: "RegularExpression",
              value: I.literal,
              range: [d, f],
              loc: v
            })), I;
          }
          function Zt(d) {
            return d.type === o.Identifier || d.type === o.Keyword || d.type === o.BooleanLiteral || d.type === o.NullLiteral;
          }
          function kt() {
            var d, v;
            if (d = S.tokens[S.tokens.length - 1], !d)
              return Yt();
            if (d.type === "Punctuator") {
              if (d.value === "]")
                return X();
              if (d.value === ")")
                return v = S.tokens[S.openParenToken - 1], v && v.type === "Keyword" && (v.value === "if" || v.value === "while" || v.value === "for" || v.value === "with") ? Yt() : X();
              if (d.value === "}") {
                if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                  if (v = S.tokens[S.openCurlyToken - 4], !v)
                    return X();
                } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                  if (v = S.tokens[S.openCurlyToken - 5], !v)
                    return Yt();
                } else
                  return X();
                return l.indexOf(v.value) >= 0 ? X() : Yt();
              }
              return Yt();
            }
            return d.type === "Keyword" ? Yt() : X();
          }
          function _e() {
            var d;
            return L(), f >= x ? {
              type: o.EOF,
              lineNumber: E,
              lineStart: A,
              start: f,
              end: f
            } : (d = g.charCodeAt(f), rt(d) ? st() : d === 40 || d === 41 || d === 59 ? X() : d === 39 || d === 34 ? J() : d === 46 ? O(g.charCodeAt(f + 1)) ? U() : X() : O(d) ? U() : S.tokenize && d === 47 ? kt() : X());
          }
          function Ye() {
            var d, v, I;
            return L(), d = {
              start: {
                line: E,
                column: f - A
              }
            }, v = _e(), d.end = {
              line: E,
              column: f - A
            }, v.type !== o.EOF && (I = g.slice(v.start, v.end), S.tokens.push({
              type: a[v.type],
              value: I,
              range: [v.start, v.end],
              loc: d
            })), v;
          }
          function wt() {
            var d;
            return d = w, f = d.end, E = d.lineNumber, A = d.lineStart, w = typeof S.tokens < "u" ? Ye() : _e(), f = d.end, E = d.lineNumber, A = d.lineStart, d;
          }
          function le() {
            var d, v, I;
            d = f, v = E, I = A, w = typeof S.tokens < "u" ? Ye() : _e(), f = d, E = v, A = I;
          }
          function te(d, v) {
            this.line = d, this.column = v;
          }
          function Se(d, v, I, j) {
            this.start = new te(d, v), this.end = new te(I, j);
          }
          y = {
            name: "SyntaxTree",
            processComment: function(d) {
              var v, I;
              if (!(d.type === c.Program && d.body.length > 0)) {
                for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= d.range[1] ? (I = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= d.range[1] && (I = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= d.range[0]; )
                  v = S.bottomRightStack.pop();
                v ? v.leadingComments && v.leadingComments[v.leadingComments.length - 1].range[1] <= d.range[0] && (d.leadingComments = v.leadingComments, delete v.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= d.range[0] && (d.leadingComments = S.leadingComments, S.leadingComments = []), I && (d.trailingComments = I), S.bottomRightStack.push(d);
              }
            },
            markEnd: function(d, v) {
              return S.range && (d.range = [v.start, f]), S.loc && (d.loc = new Se(
                v.startLineNumber === void 0 ? v.lineNumber : v.startLineNumber,
                v.start - (v.startLineStart === void 0 ? v.lineStart : v.startLineStart),
                E,
                f - A
              ), this.postProcess(d)), S.attachComment && this.processComment(d), d;
            },
            postProcess: function(d) {
              return S.source && (d.loc.source = S.source), d;
            },
            createArrayExpression: function(d) {
              return {
                type: c.ArrayExpression,
                elements: d
              };
            },
            createAssignmentExpression: function(d, v, I) {
              return {
                type: c.AssignmentExpression,
                operator: d,
                left: v,
                right: I
              };
            },
            createBinaryExpression: function(d, v, I) {
              var j = d === "||" || d === "&&" ? c.LogicalExpression : c.BinaryExpression;
              return {
                type: j,
                operator: d,
                left: v,
                right: I
              };
            },
            createBlockStatement: function(d) {
              return {
                type: c.BlockStatement,
                body: d
              };
            },
            createBreakStatement: function(d) {
              return {
                type: c.BreakStatement,
                label: d
              };
            },
            createCallExpression: function(d, v) {
              return {
                type: c.CallExpression,
                callee: d,
                arguments: v
              };
            },
            createCatchClause: function(d, v) {
              return {
                type: c.CatchClause,
                param: d,
                body: v
              };
            },
            createConditionalExpression: function(d, v, I) {
              return {
                type: c.ConditionalExpression,
                test: d,
                consequent: v,
                alternate: I
              };
            },
            createContinueStatement: function(d) {
              return {
                type: c.ContinueStatement,
                label: d
              };
            },
            createDebuggerStatement: function() {
              return {
                type: c.DebuggerStatement
              };
            },
            createDoWhileStatement: function(d, v) {
              return {
                type: c.DoWhileStatement,
                body: d,
                test: v
              };
            },
            createEmptyStatement: function() {
              return {
                type: c.EmptyStatement
              };
            },
            createExpressionStatement: function(d) {
              return {
                type: c.ExpressionStatement,
                expression: d
              };
            },
            createForStatement: function(d, v, I, j) {
              return {
                type: c.ForStatement,
                init: d,
                test: v,
                update: I,
                body: j
              };
            },
            createForInStatement: function(d, v, I) {
              return {
                type: c.ForInStatement,
                left: d,
                right: v,
                body: I,
                each: !1
              };
            },
            createFunctionDeclaration: function(d, v, I, j) {
              return {
                type: c.FunctionDeclaration,
                id: d,
                params: v,
                defaults: I,
                body: j,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createFunctionExpression: function(d, v, I, j) {
              return {
                type: c.FunctionExpression,
                id: d,
                params: v,
                defaults: I,
                body: j,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createIdentifier: function(d) {
              return {
                type: c.Identifier,
                name: d
              };
            },
            createIfStatement: function(d, v, I) {
              return {
                type: c.IfStatement,
                test: d,
                consequent: v,
                alternate: I
              };
            },
            createLabeledStatement: function(d, v) {
              return {
                type: c.LabeledStatement,
                label: d,
                body: v
              };
            },
            createLiteral: function(d) {
              return {
                type: c.Literal,
                value: d.value,
                raw: g.slice(d.start, d.end)
              };
            },
            createMemberExpression: function(d, v, I) {
              return {
                type: c.MemberExpression,
                computed: d === "[",
                object: v,
                property: I
              };
            },
            createNewExpression: function(d, v) {
              return {
                type: c.NewExpression,
                callee: d,
                arguments: v
              };
            },
            createObjectExpression: function(d) {
              return {
                type: c.ObjectExpression,
                properties: d
              };
            },
            createPostfixExpression: function(d, v) {
              return {
                type: c.UpdateExpression,
                operator: d,
                argument: v,
                prefix: !1
              };
            },
            createProgram: function(d) {
              return {
                type: c.Program,
                body: d
              };
            },
            createProperty: function(d, v, I) {
              return {
                type: c.Property,
                key: v,
                value: I,
                kind: d
              };
            },
            createReturnStatement: function(d) {
              return {
                type: c.ReturnStatement,
                argument: d
              };
            },
            createSequenceExpression: function(d) {
              return {
                type: c.SequenceExpression,
                expressions: d
              };
            },
            createSwitchCase: function(d, v) {
              return {
                type: c.SwitchCase,
                test: d,
                consequent: v
              };
            },
            createSwitchStatement: function(d, v) {
              return {
                type: c.SwitchStatement,
                discriminant: d,
                cases: v
              };
            },
            createThisExpression: function() {
              return {
                type: c.ThisExpression
              };
            },
            createThrowStatement: function(d) {
              return {
                type: c.ThrowStatement,
                argument: d
              };
            },
            createTryStatement: function(d, v, I, j) {
              return {
                type: c.TryStatement,
                block: d,
                guardedHandlers: v,
                handlers: I,
                finalizer: j
              };
            },
            createUnaryExpression: function(d, v) {
              return d === "++" || d === "--" ? {
                type: c.UpdateExpression,
                operator: d,
                argument: v,
                prefix: !0
              } : {
                type: c.UnaryExpression,
                operator: d,
                argument: v,
                prefix: !0
              };
            },
            createVariableDeclaration: function(d, v) {
              return {
                type: c.VariableDeclaration,
                declarations: d,
                kind: v
              };
            },
            createVariableDeclarator: function(d, v) {
              return {
                type: c.VariableDeclarator,
                id: d,
                init: v
              };
            },
            createWhileStatement: function(d, v) {
              return {
                type: c.WhileStatement,
                test: d,
                body: v
              };
            },
            createWithStatement: function(d, v) {
              return {
                type: c.WithStatement,
                object: d,
                body: v
              };
            }
          };
          function Kt() {
            var d, v, I, j;
            return d = f, v = E, I = A, L(), j = E !== v, f = d, E = v, A = I, j;
          }
          function bt(d, v) {
            var I, j = Array.prototype.slice.call(arguments, 2), Z = v.replace(
              /%(\d)/g,
              function(ht, Ot) {
                return R(Ot < j.length, "Message reference must be in range"), j[Ot];
              }
            );
            throw typeof d.lineNumber == "number" ? (I = new Error("Line " + d.lineNumber + ": " + Z), I.index = d.start, I.lineNumber = d.lineNumber, I.column = d.start - A + 1) : (I = new Error("Line " + E + ": " + Z), I.index = f, I.lineNumber = E, I.column = f - A + 1), I.description = Z, I;
          }
          function xt() {
            try {
              bt.apply(null, arguments);
            } catch (d) {
              if (S.errors)
                S.errors.push(d);
              else
                throw d;
            }
          }
          function Jt(d) {
            if (d.type === o.EOF && bt(d, u.UnexpectedEOS), d.type === o.NumericLiteral && bt(d, u.UnexpectedNumber), d.type === o.StringLiteral && bt(d, u.UnexpectedString), d.type === o.Identifier && bt(d, u.UnexpectedIdentifier), d.type === o.Keyword) {
              if (pt(d.value))
                bt(d, u.UnexpectedReserved);
              else if (b && vt(d.value)) {
                xt(d, u.StrictReservedWord);
                return;
              }
              bt(d, u.UnexpectedToken, d.value);
            }
            bt(d, u.UnexpectedToken, d.value);
          }
          function k(d) {
            var v = wt();
            (v.type !== o.Punctuator || v.value !== d) && Jt(v);
          }
          function M(d) {
            var v = wt();
            (v.type !== o.Keyword || v.value !== d) && Jt(v);
          }
          function B(d) {
            return w.type === o.Punctuator && w.value === d;
          }
          function it(d) {
            return w.type === o.Keyword && w.value === d;
          }
          function ct() {
            var d;
            return w.type !== o.Punctuator ? !1 : (d = w.value, d === "=" || d === "*=" || d === "/=" || d === "%=" || d === "+=" || d === "-=" || d === "<<=" || d === ">>=" || d === ">>>=" || d === "&=" || d === "^=" || d === "|=");
          }
          function Et() {
            var d;
            if (g.charCodeAt(f) === 59 || B(";")) {
              wt();
              return;
            }
            d = E, L(), E === d && w.type !== o.EOF && !B("}") && Jt(w);
          }
          function Mt(d) {
            return d.type === c.Identifier || d.type === c.MemberExpression;
          }
          function se() {
            var d = [], v;
            for (v = w, k("["); !B("]"); )
              B(",") ? (wt(), d.push(null)) : (d.push(q()), B("]") || k(","));
            return wt(), m.markEnd(m.createArrayExpression(d), v);
          }
          function de(d, v) {
            var I, j, Z;
            return I = b, Z = w, j = ds(), v && b && _t(d[0].name) && xt(v, u.StrictParamName), b = I, m.markEnd(m.createFunctionExpression(null, d, [], j), Z);
          }
          function ke() {
            var d, v;
            return v = w, d = wt(), d.type === o.StringLiteral || d.type === o.NumericLiteral ? (b && d.octal && xt(d, u.StrictOctalLiteral), m.markEnd(m.createLiteral(d), v)) : m.markEnd(m.createIdentifier(d.value), v);
          }
          function Xt() {
            var d, v, I, j, Z, ht;
            if (d = w, ht = w, d.type === o.Identifier)
              return I = ke(), d.value === "get" && !B(":") ? (v = ke(), k("("), k(")"), j = de([]), m.markEnd(m.createProperty("get", v, j), ht)) : d.value === "set" && !B(":") ? (v = ke(), k("("), d = w, d.type !== o.Identifier ? (k(")"), xt(d, u.UnexpectedToken, d.value), j = de([])) : (Z = [ut()], k(")"), j = de(Z, d)), m.markEnd(m.createProperty("set", v, j), ht)) : (k(":"), j = q(), m.markEnd(m.createProperty("init", I, j), ht));
            if (d.type === o.EOF || d.type === o.Punctuator)
              Jt(d);
            else
              return v = ke(), k(":"), j = q(), m.markEnd(m.createProperty("init", v, j), ht);
          }
          function ze() {
            var d = [], v, I, j, Z, ht = {}, Ot = String, Gt;
            for (Gt = w, k("{"); !B("}"); )
              v = Xt(), v.key.type === c.Identifier ? I = v.key.name : I = Ot(v.key.value), Z = v.kind === "init" ? h.Data : v.kind === "get" ? h.Get : h.Set, j = "$" + I, Object.prototype.hasOwnProperty.call(ht, j) ? (ht[j] === h.Data ? b && Z === h.Data ? xt({}, u.StrictDuplicateProperty) : Z !== h.Data && xt({}, u.AccessorDataProperty) : Z === h.Data ? xt({}, u.AccessorDataProperty) : ht[j] & Z && xt({}, u.AccessorGetSet), ht[j] |= Z) : ht[j] = Z, d.push(v), B("}") || k(",");
            return k("}"), m.markEnd(m.createObjectExpression(d), Gt);
          }
          function We() {
            var d;
            return k("("), d = W(), k(")"), d;
          }
          function pr() {
            var d, v, I, j;
            if (B("("))
              return We();
            if (B("["))
              return se();
            if (B("{"))
              return ze();
            if (d = w.type, j = w, d === o.Identifier)
              I = m.createIdentifier(wt().value);
            else if (d === o.StringLiteral || d === o.NumericLiteral)
              b && w.octal && xt(w, u.StrictOctalLiteral), I = m.createLiteral(wt());
            else if (d === o.Keyword) {
              if (it("function"))
                return kd();
              it("this") ? (wt(), I = m.createThisExpression()) : Jt(wt());
            } else d === o.BooleanLiteral ? (v = wt(), v.value = v.value === "true", I = m.createLiteral(v)) : d === o.NullLiteral ? (v = wt(), v.value = null, I = m.createLiteral(v)) : B("/") || B("/=") ? (typeof S.tokens < "u" ? I = m.createLiteral(Yt()) : I = m.createLiteral(Tt()), le()) : Jt(wt());
            return m.markEnd(I, j);
          }
          function Yr() {
            var d = [];
            if (k("("), !B(")"))
              for (; f < x && (d.push(q()), !B(")")); )
                k(",");
            return k(")"), d;
          }
          function ps() {
            var d, v;
            return v = w, d = wt(), Zt(d) || Jt(d), m.markEnd(m.createIdentifier(d.value), v);
          }
          function qe() {
            return k("."), ps();
          }
          function Vi() {
            var d;
            return k("["), d = W(), k("]"), d;
          }
          function T() {
            var d, v, I;
            return I = w, M("new"), d = H(), v = B("(") ? Yr() : [], m.markEnd(m.createNewExpression(d, v), I);
          }
          function V() {
            var d, v, I, j, Z;
            for (Z = w, d = _.allowIn, _.allowIn = !0, v = it("new") ? T() : pr(), _.allowIn = d; ; ) {
              if (B("."))
                j = qe(), v = m.createMemberExpression(".", v, j);
              else if (B("("))
                I = Yr(), v = m.createCallExpression(v, I);
              else if (B("["))
                j = Vi(), v = m.createMemberExpression("[", v, j);
              else
                break;
              m.markEnd(v, Z);
            }
            return v;
          }
          function H() {
            var d, v, I, j;
            for (j = w, d = _.allowIn, v = it("new") ? T() : pr(), _.allowIn = d; B(".") || B("["); )
              B("[") ? (I = Vi(), v = m.createMemberExpression("[", v, I)) : (I = qe(), v = m.createMemberExpression(".", v, I)), m.markEnd(v, j);
            return v;
          }
          function dt() {
            var d, v, I = w;
            return d = V(), w.type === o.Punctuator && (B("++") || B("--")) && !Kt() && (b && d.type === c.Identifier && _t(d.name) && xt({}, u.StrictLHSPostfix), Mt(d) || xt({}, u.InvalidLHSInAssignment), v = wt(), d = m.markEnd(m.createPostfixExpression(v.value, d), I)), d;
          }
          function ft() {
            var d, v, I;
            return w.type !== o.Punctuator && w.type !== o.Keyword ? v = dt() : B("++") || B("--") ? (I = w, d = wt(), v = ft(), b && v.type === c.Identifier && _t(v.name) && xt({}, u.StrictLHSPrefix), Mt(v) || xt({}, u.InvalidLHSInAssignment), v = m.createUnaryExpression(d.value, v), v = m.markEnd(v, I)) : B("+") || B("-") || B("~") || B("!") ? (I = w, d = wt(), v = ft(), v = m.createUnaryExpression(d.value, v), v = m.markEnd(v, I)) : it("delete") || it("void") || it("typeof") ? (I = w, d = wt(), v = ft(), v = m.createUnaryExpression(d.value, v), v = m.markEnd(v, I), b && v.operator === "delete" && v.argument.type === c.Identifier && xt({}, u.StrictDelete)) : v = dt(), v;
          }
          function K(d, v) {
            var I = 0;
            if (d.type !== o.Punctuator && d.type !== o.Keyword)
              return 0;
            switch (d.value) {
              case "||":
                I = 1;
                break;
              case "&&":
                I = 2;
                break;
              case "|":
                I = 3;
                break;
              case "^":
                I = 4;
                break;
              case "&":
                I = 5;
                break;
              case "==":
              case "!=":
              case "===":
              case "!==":
                I = 6;
                break;
              case "<":
              case ">":
              case "<=":
              case ">=":
              case "instanceof":
                I = 7;
                break;
              case "in":
                I = v ? 7 : 0;
                break;
              case "<<":
              case ">>":
              case ">>>":
                I = 8;
                break;
              case "+":
              case "-":
                I = 9;
                break;
              case "*":
              case "/":
              case "%":
                I = 11;
                break;
            }
            return I;
          }
          function C() {
            var d, v, I, j, Z, ht, Ot, Gt, fe, ce;
            if (d = w, fe = ft(), j = w, Z = K(j, _.allowIn), Z === 0)
              return fe;
            for (j.prec = Z, wt(), v = [d, w], Ot = ft(), ht = [fe, j, Ot]; (Z = K(w, _.allowIn)) > 0; ) {
              for (; ht.length > 2 && Z <= ht[ht.length - 2].prec; )
                Ot = ht.pop(), Gt = ht.pop().value, fe = ht.pop(), I = m.createBinaryExpression(Gt, fe, Ot), v.pop(), d = v[v.length - 1], m.markEnd(I, d), ht.push(I);
              j = wt(), j.prec = Z, ht.push(j), v.push(w), I = ft(), ht.push(I);
            }
            for (ce = ht.length - 1, I = ht[ce], v.pop(); ce > 1; )
              I = m.createBinaryExpression(ht[ce - 1].value, ht[ce - 2], I), ce -= 2, d = v.pop(), m.markEnd(I, d);
            return I;
          }
          function N() {
            var d, v, I, j, Z;
            return Z = w, d = C(), B("?") && (wt(), v = _.allowIn, _.allowIn = !0, I = q(), _.allowIn = v, k(":"), j = q(), d = m.createConditionalExpression(d, I, j), m.markEnd(d, Z)), d;
          }
          function q() {
            var d, v, I, j, Z;
            return d = w, Z = w, j = v = N(), ct() && (Mt(v) || xt({}, u.InvalidLHSInAssignment), b && v.type === c.Identifier && _t(v.name) && xt(d, u.StrictLHSAssignment), d = wt(), I = q(), j = m.markEnd(m.createAssignmentExpression(d.value, v, I), Z)), j;
          }
          function W() {
            var d, v = w;
            if (d = q(), B(",")) {
              for (d = m.createSequenceExpression([d]); f < x && B(","); )
                wt(), d.expressions.push(q());
              m.markEnd(d, v);
            }
            return d;
          }
          function G() {
            for (var d = [], v; f < x && !(B("}") || (v = Jr(), typeof v > "u")); )
              d.push(v);
            return d;
          }
          function nt() {
            var d, v;
            return v = w, k("{"), d = G(), k("}"), m.markEnd(m.createBlockStatement(d), v);
          }
          function ut() {
            var d, v;
            return v = w, d = wt(), d.type !== o.Identifier && Jt(d), m.markEnd(m.createIdentifier(d.value), v);
          }
          function gt(d) {
            var v = null, I, j;
            return j = w, I = ut(), b && _t(I.name) && xt({}, u.StrictVarName), d === "const" ? (k("="), v = q()) : B("=") && (wt(), v = q()), m.markEnd(m.createVariableDeclarator(I, v), j);
          }
          function At(d) {
            var v = [];
            do {
              if (v.push(gt(d)), !B(","))
                break;
              wt();
            } while (f < x);
            return v;
          }
          function Nt() {
            var d;
            return M("var"), d = At(), Et(), m.createVariableDeclaration(d, "var");
          }
          function Bt(d) {
            var v, I;
            return I = w, M(d), v = At(d), Et(), m.markEnd(m.createVariableDeclaration(v, d), I);
          }
          function Wt() {
            return k(";"), m.createEmptyStatement();
          }
          function oe() {
            var d = W();
            return Et(), m.createExpressionStatement(d);
          }
          function ie() {
            var d, v, I;
            return M("if"), k("("), d = W(), k(")"), v = Qe(), it("else") ? (wt(), I = Qe()) : I = null, m.createIfStatement(d, v, I);
          }
          function Ce() {
            var d, v, I;
            return M("do"), I = _.inIteration, _.inIteration = !0, d = Qe(), _.inIteration = I, M("while"), k("("), v = W(), k(")"), B(";") && wt(), m.createDoWhileStatement(d, v);
          }
          function De() {
            var d, v, I;
            return M("while"), k("("), d = W(), k(")"), I = _.inIteration, _.inIteration = !0, v = Qe(), _.inIteration = I, m.createWhileStatement(d, v);
          }
          function Dr() {
            var d, v, I;
            return I = w, d = wt(), v = At(), m.markEnd(m.createVariableDeclaration(v, d.value), I);
          }
          function On() {
            var d, v, I, j, Z, ht, Ot;
            return d = v = I = null, M("for"), k("("), B(";") ? wt() : (it("var") || it("let") ? (_.allowIn = !1, d = Dr(), _.allowIn = !0, d.declarations.length === 1 && it("in") && (wt(), j = d, Z = W(), d = null)) : (_.allowIn = !1, d = W(), _.allowIn = !0, it("in") && (Mt(d) || xt({}, u.InvalidLHSInForIn), wt(), j = d, Z = W(), d = null)), typeof j > "u" && k(";")), typeof j > "u" && (B(";") || (v = W()), k(";"), B(")") || (I = W())), k(")"), Ot = _.inIteration, _.inIteration = !0, ht = Qe(), _.inIteration = Ot, typeof j > "u" ? m.createForStatement(d, v, I, ht) : m.createForInStatement(j, Z, ht);
          }
          function Fa() {
            var d = null, v;
            return M("continue"), g.charCodeAt(f) === 59 ? (wt(), _.inIteration || bt({}, u.IllegalContinue), m.createContinueStatement(null)) : Kt() ? (_.inIteration || bt({}, u.IllegalContinue), m.createContinueStatement(null)) : (w.type === o.Identifier && (d = ut(), v = "$" + d.name, Object.prototype.hasOwnProperty.call(_.labelSet, v) || bt({}, u.UnknownLabel, d.name)), Et(), d === null && !_.inIteration && bt({}, u.IllegalContinue), m.createContinueStatement(d));
          }
          function $a() {
            var d = null, v;
            return M("break"), g.charCodeAt(f) === 59 ? (wt(), _.inIteration || _.inSwitch || bt({}, u.IllegalBreak), m.createBreakStatement(null)) : Kt() ? (_.inIteration || _.inSwitch || bt({}, u.IllegalBreak), m.createBreakStatement(null)) : (w.type === o.Identifier && (d = ut(), v = "$" + d.name, Object.prototype.hasOwnProperty.call(_.labelSet, v) || bt({}, u.UnknownLabel, d.name)), Et(), d === null && !(_.inIteration || _.inSwitch) && bt({}, u.IllegalBreak), m.createBreakStatement(d));
          }
          function bd() {
            var d = null;
            return M("return"), _.inFunctionBody || xt({}, u.IllegalReturn), g.charCodeAt(f) === 32 && rt(g.charCodeAt(f + 1)) ? (d = W(), Et(), m.createReturnStatement(d)) : Kt() ? m.createReturnStatement(null) : (B(";") || !B("}") && w.type !== o.EOF && (d = W()), Et(), m.createReturnStatement(d));
          }
          function vd() {
            var d, v;
            return b && (L(), xt({}, u.StrictModeWith)), M("with"), k("("), d = W(), k(")"), v = Qe(), m.createWithStatement(d, v);
          }
          function wd() {
            var d, v = [], I, j;
            for (j = w, it("default") ? (wt(), d = null) : (M("case"), d = W()), k(":"); f < x && !(B("}") || it("default") || it("case")); )
              I = Qe(), v.push(I);
            return m.markEnd(m.createSwitchCase(d, v), j);
          }
          function xd() {
            var d, v, I, j, Z;
            if (M("switch"), k("("), d = W(), k(")"), k("{"), v = [], B("}"))
              return wt(), m.createSwitchStatement(d, v);
            for (j = _.inSwitch, _.inSwitch = !0, Z = !1; f < x && !B("}"); )
              I = wd(), I.test === null && (Z && bt({}, u.MultipleDefaultsInSwitch), Z = !0), v.push(I);
            return _.inSwitch = j, k("}"), m.createSwitchStatement(d, v);
          }
          function Ed() {
            var d;
            return M("throw"), Kt() && bt({}, u.NewlineAfterThrow), d = W(), Et(), m.createThrowStatement(d);
          }
          function Ad() {
            var d, v, I;
            return I = w, M("catch"), k("("), B(")") && Jt(w), d = ut(), b && _t(d.name) && xt({}, u.StrictCatchVariable), k(")"), v = nt(), m.markEnd(m.createCatchClause(d, v), I);
          }
          function Sd() {
            var d, v = [], I = null;
            return M("try"), d = nt(), it("catch") && v.push(Ad()), it("finally") && (wt(), I = nt()), v.length === 0 && !I && bt({}, u.NoCatchOrFinally), m.createTryStatement(d, [], v, I);
          }
          function _d() {
            return M("debugger"), Et(), m.createDebuggerStatement();
          }
          function Qe() {
            var d = w.type, v, I, j, Z;
            if (d === o.EOF && Jt(w), d === o.Punctuator && w.value === "{")
              return nt();
            if (Z = w, d === o.Punctuator)
              switch (w.value) {
                case ";":
                  return m.markEnd(Wt(), Z);
                case "(":
                  return m.markEnd(oe(), Z);
              }
            if (d === o.Keyword)
              switch (w.value) {
                case "break":
                  return m.markEnd($a(), Z);
                case "continue":
                  return m.markEnd(Fa(), Z);
                case "debugger":
                  return m.markEnd(_d(), Z);
                case "do":
                  return m.markEnd(Ce(), Z);
                case "for":
                  return m.markEnd(On(), Z);
                case "function":
                  return m.markEnd(Va(), Z);
                case "if":
                  return m.markEnd(ie(), Z);
                case "return":
                  return m.markEnd(bd(), Z);
                case "switch":
                  return m.markEnd(xd(), Z);
                case "throw":
                  return m.markEnd(Ed(), Z);
                case "try":
                  return m.markEnd(Sd(), Z);
                case "var":
                  return m.markEnd(Nt(), Z);
                case "while":
                  return m.markEnd(De(), Z);
                case "with":
                  return m.markEnd(vd(), Z);
              }
            return v = W(), v.type === c.Identifier && B(":") ? (wt(), j = "$" + v.name, Object.prototype.hasOwnProperty.call(_.labelSet, j) && bt({}, u.Redeclaration, "Label", v.name), _.labelSet[j] = !0, I = Qe(), delete _.labelSet[j], m.markEnd(m.createLabeledStatement(v, I), Z)) : (Et(), m.markEnd(m.createExpressionStatement(v), Z));
          }
          function ds() {
            var d, v = [], I, j, Z, ht, Ot, Gt, fe, ce;
            for (ce = w, k("{"); f < x && !(w.type !== o.StringLiteral || (I = w, d = Jr(), v.push(d), d.expression.type !== c.Literal)); )
              j = g.slice(I.start + 1, I.end - 1), j === "use strict" ? (b = !0, Z && xt(Z, u.StrictOctalLiteral)) : !Z && I.octal && (Z = I);
            for (ht = _.labelSet, Ot = _.inIteration, Gt = _.inSwitch, fe = _.inFunctionBody, _.labelSet = {}, _.inIteration = !1, _.inSwitch = !1, _.inFunctionBody = !0; f < x && !(B("}") || (d = Jr(), typeof d > "u")); )
              v.push(d);
            return k("}"), _.labelSet = ht, _.inIteration = Ot, _.inSwitch = Gt, _.inFunctionBody = fe, m.markEnd(m.createBlockStatement(v), ce);
          }
          function za(d) {
            var v, I = [], j, Z, ht, Ot, Gt;
            if (k("("), !B(")"))
              for (ht = {}; f < x && (j = w, v = ut(), Ot = "$" + j.value, b ? (_t(j.value) && (Z = j, Gt = u.StrictParamName), Object.prototype.hasOwnProperty.call(ht, Ot) && (Z = j, Gt = u.StrictParamDupe)) : d || (_t(j.value) ? (d = j, Gt = u.StrictParamName) : vt(j.value) ? (d = j, Gt = u.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ht, Ot) && (d = j, Gt = u.StrictParamDupe)), I.push(v), ht[Ot] = !0, !B(")")); )
                k(",");
            return k(")"), {
              params: I,
              stricted: Z,
              firstRestricted: d,
              message: Gt
            };
          }
          function Va() {
            var d, v = [], I, j, Z, ht, Ot, Gt, fe, ce;
            return ce = w, M("function"), j = w, d = ut(), b ? _t(j.value) && xt(j, u.StrictFunctionName) : _t(j.value) ? (Ot = j, Gt = u.StrictFunctionName) : vt(j.value) && (Ot = j, Gt = u.StrictReservedWord), ht = za(Ot), v = ht.params, Z = ht.stricted, Ot = ht.firstRestricted, ht.message && (Gt = ht.message), fe = b, I = ds(), b && Ot && bt(Ot, Gt), b && Z && xt(Z, Gt), b = fe, m.markEnd(m.createFunctionDeclaration(d, v, [], I), ce);
          }
          function kd() {
            var d, v = null, I, j, Z, ht, Ot = [], Gt, fe, ce;
            return ce = w, M("function"), B("(") || (d = w, v = ut(), b ? _t(d.value) && xt(d, u.StrictFunctionName) : _t(d.value) ? (j = d, Z = u.StrictFunctionName) : vt(d.value) && (j = d, Z = u.StrictReservedWord)), ht = za(j), Ot = ht.params, I = ht.stricted, j = ht.firstRestricted, ht.message && (Z = ht.message), fe = b, Gt = ds(), b && j && bt(j, Z), b && I && xt(I, Z), b = fe, m.markEnd(m.createFunctionExpression(v, Ot, [], Gt), ce);
          }
          function Jr() {
            if (w.type === o.Keyword)
              switch (w.value) {
                case "const":
                case "let":
                  return Bt(w.value);
                case "function":
                  return Va();
                default:
                  return Qe();
              }
            if (w.type !== o.EOF)
              return Qe();
          }
          function Cd() {
            for (var d, v = [], I, j, Z; f < x && (I = w, !(I.type !== o.StringLiteral || (d = Jr(), v.push(d), d.expression.type !== c.Literal))); )
              j = g.slice(I.start + 1, I.end - 1), j === "use strict" ? (b = !0, Z && xt(Z, u.StrictOctalLiteral)) : !Z && I.octal && (Z = I);
            for (; f < x && (d = Jr(), !(typeof d > "u")); )
              v.push(d);
            return v;
          }
          function Id() {
            var d, v;
            return L(), le(), v = w, b = !1, d = Cd(), m.markEnd(m.createProgram(d), v);
          }
          function Ua() {
            var d, v, I, j = [];
            for (d = 0; d < S.tokens.length; ++d)
              v = S.tokens[d], I = {
                type: v.type,
                value: v.value
              }, S.range && (I.range = v.range), S.loc && (I.loc = v.loc), j.push(I);
            S.tokens = j;
          }
          function Pd(d, v) {
            var I, j, Z;
            I = String, typeof d != "string" && !(d instanceof String) && (d = I(d)), m = y, g = d, f = 0, E = g.length > 0 ? 1 : 0, A = 0, x = g.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, v = v || {}, v.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof v.range == "boolean" && v.range, S.loc = typeof v.loc == "boolean" && v.loc, typeof v.comment == "boolean" && v.comment && (S.comments = []), typeof v.tolerant == "boolean" && v.tolerant && (S.errors = []);
            try {
              if (le(), w.type === o.EOF)
                return S.tokens;
              for (j = wt(); w.type !== o.EOF; )
                try {
                  j = wt();
                } catch (ht) {
                  if (j = w, S.errors) {
                    S.errors.push(ht);
                    break;
                  } else
                    throw ht;
                }
              Ua(), Z = S.tokens, typeof S.comments < "u" && (Z.comments = S.comments), typeof S.errors < "u" && (Z.errors = S.errors);
            } catch (ht) {
              throw ht;
            } finally {
              S = {};
            }
            return Z;
          }
          function Rd(d, v) {
            var I, j;
            j = String, typeof d != "string" && !(d instanceof String) && (d = j(d)), m = y, g = d, f = 0, E = g.length > 0 ? 1 : 0, A = 0, x = g.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, typeof v < "u" && (S.range = typeof v.range == "boolean" && v.range, S.loc = typeof v.loc == "boolean" && v.loc, S.attachComment = typeof v.attachComment == "boolean" && v.attachComment, S.loc && v.source !== null && v.source !== void 0 && (S.source = j(v.source)), typeof v.tokens == "boolean" && v.tokens && (S.tokens = []), typeof v.comment == "boolean" && v.comment && (S.comments = []), typeof v.tolerant == "boolean" && v.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
            try {
              I = Id(), typeof S.comments < "u" && (I.comments = S.comments), typeof S.tokens < "u" && (Ua(), I.tokens = S.tokens), typeof S.errors < "u" && (I.errors = S.errors);
            } catch (Z) {
              throw Z;
            } finally {
              S = {};
            }
            return I;
          }
          s.version = "1.2.2", s.tokenize = Pd, s.parse = Rd, s.Syntax = function() {
            var d, v = {};
            typeof Object.create == "function" && (v = /* @__PURE__ */ Object.create(null));
            for (d in c)
              c.hasOwnProperty(d) && (v[d] = c[d]);
            return typeof Object.freeze == "function" && Object.freeze(v), v;
          }();
        });
      }, {}], 1: [function(r, n, i) {
        (function(s) {
          var o = function() {
            var a = {
              trace: function() {
              },
              yy: {},
              symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
              terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
              productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
              performAction: function(u, p, y, g, b, f, E) {
                g.ast || (g.ast = l, l.initialize());
                var A = f.length - 1;
                switch (b) {
                  case 1:
                    return g.ast.set({ expression: { type: "root", value: f[A] } }), g.ast.unshift(), g.ast.yield();
                  case 2:
                    return g.ast.set({ expression: { type: "root", value: f[A - 1] } }), g.ast.unshift(), g.ast.yield();
                  case 3:
                    return g.ast.unshift(), g.ast.yield();
                  case 4:
                    return g.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), g.ast.unshift(), g.ast.yield();
                  case 5:
                    break;
                  case 6:
                    break;
                  case 7:
                    g.ast.set({ operation: "member" }), g.ast.push();
                    break;
                  case 8:
                    g.ast.set({ operation: "subscript" }), g.ast.push();
                    break;
                  case 9:
                    g.ast.set({ scope: "child" });
                    break;
                  case 10:
                    g.ast.set({ scope: "descendant" });
                    break;
                  case 11:
                    break;
                  case 12:
                    g.ast.set({ scope: "child", operation: "member" });
                    break;
                  case 13:
                    break;
                  case 14:
                    g.ast.set({ expression: { type: "wildcard", value: f[A] } });
                    break;
                  case 15:
                    g.ast.set({ expression: { type: "identifier", value: f[A] } });
                    break;
                  case 16:
                    g.ast.set({ expression: { type: "script_expression", value: f[A] } });
                    break;
                  case 17:
                    g.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                    break;
                  case 18:
                    break;
                  case 19:
                    g.ast.set({ scope: "child" });
                    break;
                  case 20:
                    g.ast.set({ scope: "descendant" });
                    break;
                  case 21:
                    break;
                  case 22:
                    break;
                  case 23:
                    break;
                  case 24:
                    f[A].length > 1 ? g.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                    break;
                  case 25:
                    this.$ = [f[A]];
                    break;
                  case 26:
                    this.$ = f[A - 2].concat(f[A]);
                    break;
                  case 27:
                    this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, g.ast.set(this.$);
                    break;
                  case 28:
                    this.$ = { expression: { type: "string_literal", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 29:
                    this.$ = { expression: { type: "slice", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 30:
                    this.$ = { expression: { type: "wildcard", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 31:
                    this.$ = { expression: { type: "script_expression", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 32:
                    this.$ = { expression: { type: "filter_expression", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 33:
                    this.$ = f[A];
                    break;
                  case 34:
                    this.$ = f[A];
                    break;
                }
              },
              table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
              defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
              parseError: function(u, p) {
                if (p.recoverable)
                  this.trace(u);
                else
                  throw new Error(u);
              },
              parse: function(u) {
                var p = this, y = [0], g = [null], b = [], f = this.table, E = "", A = 0, x = 0, m = 2, w = 1, _ = b.slice.call(arguments, 1);
                this.lexer.setInput(u), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
                var S = this.lexer.yylloc;
                b.push(S);
                var R = this.lexer.options && this.lexer.options.ranges;
                typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
                function O() {
                  var It;
                  return It = p.lexer.lex() || w, typeof It != "number" && (It = p.symbols_[It] || It), It;
                }
                for (var $, z, F, Y, rt = {}, at, pt, vt, _t; ; ) {
                  if (z = y[y.length - 1], this.defaultActions[z] ? F = this.defaultActions[z] : (($ === null || typeof $ > "u") && ($ = O()), F = f[z] && f[z][$]), typeof F > "u" || !F.length || !F[0]) {
                    var Ct = "";
                    _t = [];
                    for (at in f[z])
                      this.terminals_[at] && at > m && _t.push("'" + this.terminals_[at] + "'");
                    this.lexer.showPosition ? Ct = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + _t.join(", ") + ", got '" + (this.terminals_[$] || $) + "'" : Ct = "Parse error on line " + (A + 1) + ": Unexpected " + ($ == w ? "end of input" : "'" + (this.terminals_[$] || $) + "'"), this.parseError(Ct, {
                      text: this.lexer.match,
                      token: this.terminals_[$] || $,
                      line: this.lexer.yylineno,
                      loc: S,
                      expected: _t
                    });
                  }
                  if (F[0] instanceof Array && F.length > 1)
                    throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + $);
                  switch (F[0]) {
                    case 1:
                      y.push($), g.push(this.lexer.yytext), b.push(this.lexer.yylloc), y.push(F[1]), $ = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                      break;
                    case 2:
                      if (pt = this.productions_[F[1]][1], rt.$ = g[g.length - pt], rt._$ = {
                        first_line: b[b.length - (pt || 1)].first_line,
                        last_line: b[b.length - 1].last_line,
                        first_column: b[b.length - (pt || 1)].first_column,
                        last_column: b[b.length - 1].last_column
                      }, R && (rt._$.range = [
                        b[b.length - (pt || 1)].range[0],
                        b[b.length - 1].range[1]
                      ]), Y = this.performAction.apply(rt, [
                        E,
                        x,
                        A,
                        this.yy,
                        F[1],
                        g,
                        b
                      ].concat(_)), typeof Y < "u")
                        return Y;
                      pt && (y = y.slice(0, -1 * pt * 2), g = g.slice(0, -1 * pt), b = b.slice(0, -1 * pt)), y.push(this.productions_[F[1]][0]), g.push(rt.$), b.push(rt._$), vt = f[y[y.length - 2]][y[y.length - 1]], y.push(vt);
                      break;
                    case 3:
                      return !0;
                  }
                }
                return !0;
              }
            }, l = {
              initialize: function() {
                this._nodes = [], this._node = {}, this._stash = [];
              },
              set: function(u) {
                for (var p in u) this._node[p] = u[p];
                return this._node;
              },
              node: function(u) {
                return arguments.length && (this._node = u), this._node;
              },
              push: function() {
                this._nodes.push(this._node), this._node = {};
              },
              unshift: function() {
                this._nodes.unshift(this._node), this._node = {};
              },
              yield: function() {
                var u = this._nodes;
                return this.initialize(), u;
              }
            }, c = /* @__PURE__ */ function() {
              var u = {
                EOF: 1,
                parseError: function(p, y) {
                  if (this.yy.parser)
                    this.yy.parser.parseError(p, y);
                  else
                    throw new Error(p);
                },
                // resets the lexer, sets new input
                setInput: function(p) {
                  return this._input = p, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                  }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
                },
                // consumes and returns one char from the input
                input: function() {
                  var p = this._input[0];
                  this.yytext += p, this.yyleng++, this.offset++, this.match += p, this.matched += p;
                  var y = p.match(/(?:\r\n?|\n).*/g);
                  return y ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), p;
                },
                // unshifts one char (or a string) into the input
                unput: function(p) {
                  var y = p.length, g = p.split(/(?:\r\n?|\n)/g);
                  this._input = p + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - y - 1), this.offset -= y;
                  var b = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), g.length - 1 && (this.yylineno -= g.length - 1);
                  var f = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: g ? (g.length === b.length ? this.yylloc.first_column : 0) + b[b.length - g.length].length - g[0].length : this.yylloc.first_column - y
                  }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - y]), this.yyleng = this.yytext.length, this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function() {
                  return this._more = !0, this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function() {
                  if (this.options.backtrack_lexer)
                    this._backtrack = !0;
                  else
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                      text: "",
                      token: null,
                      line: this.yylineno
                    });
                  return this;
                },
                // retain first n characters of the match
                less: function(p) {
                  this.unput(this.match.slice(p));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function() {
                  var p = this.matched.substr(0, this.matched.length - this.match.length);
                  return (p.length > 20 ? "..." : "") + p.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function() {
                  var p = this.match;
                  return p.length < 20 && (p += this._input.substr(0, 20 - p.length)), (p.substr(0, 20) + (p.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function() {
                  var p = this.pastInput(), y = new Array(p.length + 1).join("-");
                  return p + this.upcomingInput() + `
` + y + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function(p, y) {
                  var g, b, f;
                  if (this.options.backtrack_lexer && (f = {
                    yylineno: this.yylineno,
                    yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                  }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), b = p[0].match(/(?:\r\n?|\n).*/g), b && (this.yylineno += b.length), this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: b ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + p[0].length
                  }, this.yytext += p[0], this.match += p[0], this.matches = p, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(p[0].length), this.matched += p[0], g = this.performAction.call(this, this.yy, this, y, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), g)
                    return g;
                  if (this._backtrack) {
                    for (var E in f)
                      this[E] = f[E];
                    return !1;
                  }
                  return !1;
                },
                // return next match in input
                next: function() {
                  if (this.done)
                    return this.EOF;
                  this._input || (this.done = !0);
                  var p, y, g, b;
                  this._more || (this.yytext = "", this.match = "");
                  for (var f = this._currentRules(), E = 0; E < f.length; E++)
                    if (g = this._input.match(this.rules[f[E]]), g && (!y || g[0].length > y[0].length)) {
                      if (y = g, b = E, this.options.backtrack_lexer) {
                        if (p = this.test_match(g, f[E]), p !== !1)
                          return p;
                        if (this._backtrack) {
                          y = !1;
                          continue;
                        } else
                          return !1;
                      } else if (!this.options.flex)
                        break;
                    }
                  return y ? (p = this.test_match(y, f[b]), p !== !1 ? p : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                },
                // return next match that has a token
                lex: function() {
                  var p = this.next();
                  return p || this.lex();
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function(p) {
                  this.conditionStack.push(p);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function() {
                  var p = this.conditionStack.length - 1;
                  return p > 0 ? this.conditionStack.pop() : this.conditionStack[0];
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function() {
                  return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function(p) {
                  return p = this.conditionStack.length - 1 - Math.abs(p || 0), p >= 0 ? this.conditionStack[p] : "INITIAL";
                },
                // alias for begin(condition)
                pushState: function(p) {
                  this.begin(p);
                },
                // return the number of states currently on the stack
                stateStackSize: function() {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function(p, y, g, b) {
                  switch (g) {
                    case 0:
                      return 4;
                    case 1:
                      return 14;
                    case 2:
                      return 12;
                    case 3:
                      return 15;
                    case 4:
                      return 16;
                    case 5:
                      return 22;
                    case 6:
                      return 24;
                    case 7:
                      return 28;
                    case 8:
                      return 30;
                    case 9:
                      return 18;
                    case 10:
                      return y.yytext = y.yytext.substr(1, y.yyleng - 2), 32;
                    case 11:
                      return y.yytext = y.yytext.substr(1, y.yyleng - 2), 33;
                    case 12:
                      return 17;
                    case 13:
                      return 31;
                  }
                },
                rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
                conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
              };
              return u;
            }();
            a.lexer = c;
            function h() {
              this.yy = {};
            }
            return h.prototype = a, a.Parser = h, new h();
          }();
          typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
            return o.parse.apply(o, arguments);
          }, i.main = function(a) {
            a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
            var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
            return i.parser.parse(l);
          }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
        }).call(this, r("_process"));
      }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
        n.exports = {
          identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
          integer: "-?(?:0|[1-9][0-9]*)",
          qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
          q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
        };
      }, {}], 3: [function(r, n, i) {
        var s = r("./dict"), o = r("fs"), a = {
          lex: {
            macros: {
              esc: "\\\\",
              int: s.integer
            },
            rules: [
              ["\\$", "return 'DOLLAR'"],
              ["\\.\\.", "return 'DOT_DOT'"],
              ["\\.", "return 'DOT'"],
              ["\\*", "return 'STAR'"],
              [s.identifier, "return 'IDENTIFIER'"],
              ["\\[", "return '['"],
              ["\\]", "return ']'"],
              [",", "return ','"],
              ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
              ["{int}", "return 'INTEGER'"],
              [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
              [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
              ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
              ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
            ]
          },
          start: "JSON_PATH",
          bnf: {
            JSON_PATH: [
              ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
              ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
            ],
            PATH_COMPONENTS: [
              ["PATH_COMPONENT", ""],
              ["PATH_COMPONENTS PATH_COMPONENT", ""]
            ],
            PATH_COMPONENT: [
              ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
              ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
            ],
            MEMBER_COMPONENT: [
              ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_MEMBER_COMPONENT: [
              ["DOT MEMBER_EXPRESSION", ""]
            ],
            LEADING_CHILD_MEMBER_EXPRESSION: [
              ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
            ],
            DESCENDANT_MEMBER_COMPONENT: [
              ["DOT_DOT MEMBER_EXPRESSION", ""]
            ],
            MEMBER_EXPRESSION: [
              ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
              ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
              ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
              ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
              ["END", ""]
            ],
            SUBSCRIPT_COMPONENT: [
              ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_SUBSCRIPT_COMPONENT: [
              ["[ SUBSCRIPT ]", ""]
            ],
            DESCENDANT_SUBSCRIPT_COMPONENT: [
              ["DOT_DOT [ SUBSCRIPT ]", ""]
            ],
            SUBSCRIPT: [
              ["SUBSCRIPT_EXPRESSION", ""],
              ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
            ],
            SUBSCRIPT_EXPRESSION_LIST: [
              ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
              ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
            ],
            SUBSCRIPT_EXPRESSION_LISTABLE: [
              ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
              ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
              ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
            ],
            SUBSCRIPT_EXPRESSION: [
              ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
              ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
              ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
            ],
            STRING_LITERAL: [
              ["QQ_STRING", "$$ = $1"],
              ["Q_STRING", "$$ = $1"]
            ]
          }
        };
        o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
      }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
        var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
          return this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.traverse = y(!0), this.descend = y();
        }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
          var m = [x.operation, x.scope, x.expression.type].join("-"), w = this._fns[m];
          if (!w) throw new Error("couldn't resolve key: " + m);
          return w.bind(this);
        }, c.prototype.register = function(x, m) {
          if (!m instanceof Function)
            throw new Error("handler must be a function");
          this._fns[x] = m;
        }, c.prototype._fns = {
          "member-child-identifier": function(x, m) {
            var w = x.expression.value, _ = m.value;
            if (_ instanceof Object && w in _)
              return [{ value: _[w], path: m.path.concat(w) }];
          },
          "member-descendant-identifier": b(function(x, m, w) {
            return x == w;
          }),
          "subscript-child-numeric_literal": g(function(x, m, w) {
            return x === w;
          }),
          "member-child-numeric_literal": g(function(x, m, w) {
            return String(x) === String(w);
          }),
          "subscript-descendant-numeric_literal": b(function(x, m, w) {
            return x === w;
          }),
          "member-child-wildcard": g(function() {
            return !0;
          }),
          "member-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-child-wildcard": g(function() {
            return !0;
          }),
          "subscript-child-slice": function(x, m) {
            if (u(m.value)) {
              var w = x.expression.value.split(":").map(A), _ = m.value.map(function(S, R) {
                return { value: S, path: m.path.concat(R) };
              });
              return o.apply(null, [_].concat(w));
            }
          },
          "subscript-child-union": function(x, m) {
            var w = [];
            return x.expression.value.forEach(function(_) {
              var S = { operation: "subscript", scope: "child", expression: _.expression }, R = this.resolve(S), O = R(S, m);
              O && (w = w.concat(O));
            }, this), E(w);
          },
          "subscript-descendant-union": function(x, m, w) {
            var _ = r(".."), S = this, R = [], O = _.nodes(m, "$..*").slice(1);
            return O.forEach(function($) {
              R.length >= w || x.expression.value.forEach(function(z) {
                var F = { operation: "subscript", scope: "child", expression: z.expression }, Y = S.resolve(F), rt = Y(F, $);
                R = R.concat(rt);
              });
            }), E(R);
          },
          "subscript-child-filter_expression": function(x, m, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(O, $) {
              return f(S, { "@": $ });
            };
            return this.descend(m, null, R, w);
          },
          "subscript-descendant-filter_expression": function(x, m, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(O, $) {
              return f(S, { "@": $ });
            };
            return this.traverse(m, null, R, w);
          },
          "subscript-child-script_expression": function(x, m) {
            var w = x.expression.value.slice(1, -1);
            return h(m, w, "$[{{value}}]");
          },
          "member-child-script_expression": function(x, m) {
            var w = x.expression.value.slice(1, -1);
            return h(m, w, "$.{{value}}");
          },
          "member-descendant-script_expression": function(x, m) {
            var w = x.expression.value.slice(1, -1);
            return h(m, w, "$..value");
          }
        }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
        function h(x, m, w) {
          var _ = r("./index"), S = s.parse(m).body[0].expression, R = f(S, { "@": x.value }), O = w.replace(/\{\{\s*value\s*\}\}/g, R), $ = _.nodes(x.value, O);
          return $.forEach(function(z) {
            z.path = x.path.concat(z.path.slice(1));
          }), $;
        }
        function u(x) {
          return Array.isArray(x);
        }
        function p(x) {
          return x && !(x instanceof Array) && x instanceof Object;
        }
        function y(x) {
          return function(m, w, _, S) {
            var R = m.value, O = m.path, $ = [], z = (function(F, Y) {
              u(F) ? (F.forEach(function(rt, at) {
                $.length >= S || _(at, rt, w) && $.push({ path: Y.concat(at), value: rt });
              }), F.forEach(function(rt, at) {
                $.length >= S || x && z(rt, Y.concat(at));
              })) : p(F) && (this.keys(F).forEach(function(rt) {
                $.length >= S || _(rt, F[rt], w) && $.push({ path: Y.concat(rt), value: F[rt] });
              }), this.keys(F).forEach(function(rt) {
                $.length >= S || x && z(F[rt], Y.concat(rt));
              }));
            }).bind(this);
            return z(R, O), $;
          };
        }
        function g(x) {
          return function(m, w, _) {
            return this.descend(w, m.expression.value, x, _);
          };
        }
        function b(x) {
          return function(m, w, _) {
            return this.traverse(w, m.expression.value, x, _);
          };
        }
        function f() {
          try {
            return a.apply(this, arguments);
          } catch {
          }
        }
        function E(x) {
          return x = x.filter(function(m) {
            return m;
          }), l(
            x,
            function(m) {
              return m.path.map(function(w) {
                return String(w).replace("-", "--");
              }).join("-");
            }
          );
        }
        function A(x) {
          var m = String(x);
          return m.match(/^-?[0-9]+$/) ? parseInt(m) : null;
        }
        n.exports = c;
      }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
        var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
          this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.parser = new a(), this.handlers = new l();
        }, c.prototype.parse = function(p) {
          return s.ok(h(p), "we need a path"), this.parser.parse(p);
        }, c.prototype.parent = function(p, y) {
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path");
          var g = this.nodes(p, y)[0];
          return g.path.pop(), this.value(p, g.path);
        }, c.prototype.apply = function(p, y, g) {
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path"), s.equal(typeof g, "function", "fn needs to be function");
          var b = this.nodes(p, y).sort(function(f, E) {
            return E.path.length - f.path.length;
          });
          return b.forEach(function(f) {
            var E = f.path.pop(), A = this.value(p, this.stringify(f.path)), x = f.value = g.call(p, A[E]);
            A[E] = x;
          }, this), b;
        }, c.prototype.value = function(p, y, g) {
          if (s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path"), arguments.length >= 3) {
            var b = this.nodes(p, y).shift();
            if (!b) return this._vivify(p, y, g);
            var f = b.path.slice(-1).shift(), E = this.parent(p, this.stringify(b.path));
            E[f] = g;
          }
          return this.query(p, this.stringify(y), 1).shift();
        }, c.prototype._vivify = function(p, y, g) {
          var b = this;
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path");
          var f = this.parser.parse(y).map(function(A) {
            return A.expression.value;
          }), E = function(A, x) {
            var m = A.pop(), w = b.value(p, A);
            w || (E(A.concat(), typeof m == "string" ? {} : []), w = b.value(p, A)), w[m] = x;
          };
          return E(f, g), this.query(p, y)[0];
        }, c.prototype.query = function(p, y, g) {
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(h(y), "we need a path");
          var b = this.nodes(p, y, g).map(function(f) {
            return f.value;
          });
          return b;
        }, c.prototype.paths = function(p, y, g) {
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path");
          var b = this.nodes(p, y, g).map(function(f) {
            return f.path;
          });
          return b;
        }, c.prototype.nodes = function(p, y, g) {
          if (s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path"), g === 0) return [];
          var b = this.parser.parse(y), f = this.handlers, E = [{ path: ["$"], value: p }], A = [];
          return b.length && b[0].expression.type == "root" && b.shift(), b.length ? (b.forEach(function(x, m) {
            if (!(A.length >= g)) {
              var w = f.resolve(x), _ = [];
              E.forEach(function(S) {
                if (!(A.length >= g)) {
                  var R = w(x, S, g);
                  m == b.length - 1 ? A = A.concat(R || []) : _ = _.concat(R || []);
                }
              }), E = _;
            }
          }), g ? A.slice(0, g) : A) : E;
        }, c.prototype.stringify = function(p) {
          s.ok(p, "we need a path");
          var y = "$", g = {
            "descendant-member": "..{{value}}",
            "child-member": ".{{value}}",
            "descendant-subscript": "..[{{value}}]",
            "child-subscript": "[{{value}}]"
          };
          return p = this._normalize(p), p.forEach(function(b) {
            if (b.expression.type != "root") {
              var f = [b.scope, b.operation].join("-"), E = g[f], A;
              if (b.expression.type == "string_literal" ? A = JSON.stringify(b.expression.value) : A = b.expression.value, !E) throw new Error("couldn't find template " + f);
              y += E.replace(/{{value}}/, A);
            }
          }), y;
        }, c.prototype._normalize = function(p) {
          if (s.ok(p, "we need a path"), typeof p == "string")
            return this.parser.parse(p);
          if (Array.isArray(p) && typeof p[0] == "string") {
            var y = [{ expression: { type: "root", value: "$" } }];
            return p.forEach(function(g, b) {
              if (!(g == "$" && b === 0))
                if (typeof g == "string" && g.match("^" + o.identifier + "$"))
                  y.push({
                    operation: "member",
                    scope: "child",
                    expression: { value: g, type: "identifier" }
                  });
                else {
                  var f = typeof g == "number" ? "numeric_literal" : "string_literal";
                  y.push({
                    operation: "subscript",
                    scope: "child",
                    expression: { value: g, type: f }
                  });
                }
            }), y;
          } else if (Array.isArray(p) && typeof p[0] == "object")
            return p;
          throw new Error("couldn't understand path " + p);
        };
        function h(p) {
          return Object.prototype.toString.call(p) == "[object String]";
        }
        c.Handlers = l, c.Parser = a;
        var u = new c();
        u.JSONPath = c, n.exports = u;
      }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
        var s = r("./grammar"), o = r("../generated/parser"), a = function() {
          var l = new o.Parser(), c = l.parseError;
          return l.yy.parseError = function() {
            l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
          }, l;
        };
        a.grammar = s, n.exports = a;
      }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
        n.exports = function(o, a, l, c) {
          if (typeof a == "string") throw new Error("start cannot be a string");
          if (typeof l == "string") throw new Error("end cannot be a string");
          if (typeof c == "string") throw new Error("step cannot be a string");
          var h = o.length;
          if (c === 0) throw new Error("step cannot be zero");
          if (c = c ? s(c) : 1, a = a < 0 ? h + a : a, l = l < 0 ? h + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : h - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? h : -1)), a = c > 0 ? Math.max(0, a) : Math.min(h, a), l = c > 0 ? Math.min(l, h) : Math.max(-1, l), c > 0 && l <= a) return [];
          if (c < 0 && a <= l) return [];
          for (var u = [], p = a; p != l && !(c < 0 && p <= l || c > 0 && p >= l); p += c)
            u.push(o[p]);
          return u;
        };
        function s(o) {
          return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
        }
      }, {}], 8: [function(r, n, i) {
        var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = y;
        l.AssertionError = function(m) {
          this.name = "AssertionError", this.actual = m.actual, this.expected = m.expected, this.operator = m.operator, m.message ? (this.message = m.message, this.generatedMessage = !1) : (this.message = u(this), this.generatedMessage = !0);
          var w = m.stackStartFunction || p;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, w);
          else {
            var _ = new Error();
            if (_.stack) {
              var S = _.stack, R = w.name, O = S.indexOf(`
` + R);
              if (O >= 0) {
                var $ = S.indexOf(`
`, O + 1);
                S = S.substring($ + 1);
              }
              this.stack = S;
            }
          }
        }, s.inherits(l.AssertionError, Error);
        function c(m, w) {
          return s.isUndefined(w) ? "" + w : s.isNumber(w) && !isFinite(w) || s.isFunction(w) || s.isRegExp(w) ? w.toString() : w;
        }
        function h(m, w) {
          return s.isString(m) ? m.length < w ? m : m.slice(0, w) : m;
        }
        function u(m) {
          return h(JSON.stringify(m.actual, c), 128) + " " + m.operator + " " + h(JSON.stringify(m.expected, c), 128);
        }
        function p(m, w, _, S, R) {
          throw new l.AssertionError({
            message: _,
            actual: m,
            expected: w,
            operator: S,
            stackStartFunction: R
          });
        }
        l.fail = p;
        function y(m, w) {
          m || p(m, !0, w, "==", l.ok);
        }
        l.ok = y, l.equal = function(m, w, _) {
          m != w && p(m, w, _, "==", l.equal);
        }, l.notEqual = function(m, w, _) {
          m == w && p(m, w, _, "!=", l.notEqual);
        }, l.deepEqual = function(m, w, _) {
          g(m, w) || p(m, w, _, "deepEqual", l.deepEqual);
        };
        function g(m, w) {
          if (m === w)
            return !0;
          if (s.isBuffer(m) && s.isBuffer(w)) {
            if (m.length != w.length) return !1;
            for (var _ = 0; _ < m.length; _++)
              if (m[_] !== w[_]) return !1;
            return !0;
          } else return s.isDate(m) && s.isDate(w) ? m.getTime() === w.getTime() : s.isRegExp(m) && s.isRegExp(w) ? m.source === w.source && m.global === w.global && m.multiline === w.multiline && m.lastIndex === w.lastIndex && m.ignoreCase === w.ignoreCase : !s.isObject(m) && !s.isObject(w) ? m == w : f(m, w);
        }
        function b(m) {
          return Object.prototype.toString.call(m) == "[object Arguments]";
        }
        function f(m, w) {
          if (s.isNullOrUndefined(m) || s.isNullOrUndefined(w) || m.prototype !== w.prototype) return !1;
          if (s.isPrimitive(m) || s.isPrimitive(w))
            return m === w;
          var _ = b(m), S = b(w);
          if (_ && !S || !_ && S)
            return !1;
          if (_)
            return m = o.call(m), w = o.call(w), g(m, w);
          var R = x(m), O = x(w), $, z;
          if (R.length != O.length)
            return !1;
          for (R.sort(), O.sort(), z = R.length - 1; z >= 0; z--)
            if (R[z] != O[z])
              return !1;
          for (z = R.length - 1; z >= 0; z--)
            if ($ = R[z], !g(m[$], w[$])) return !1;
          return !0;
        }
        l.notDeepEqual = function(m, w, _) {
          g(m, w) && p(m, w, _, "notDeepEqual", l.notDeepEqual);
        }, l.strictEqual = function(m, w, _) {
          m !== w && p(m, w, _, "===", l.strictEqual);
        }, l.notStrictEqual = function(m, w, _) {
          m === w && p(m, w, _, "!==", l.notStrictEqual);
        };
        function E(m, w) {
          return !m || !w ? !1 : Object.prototype.toString.call(w) == "[object RegExp]" ? w.test(m) : m instanceof w ? !0 : w.call({}, m) === !0;
        }
        function A(m, w, _, S) {
          var R;
          s.isString(_) && (S = _, _ = null);
          try {
            w();
          } catch (O) {
            R = O;
          }
          if (S = (_ && _.name ? " (" + _.name + ")." : ".") + (S ? " " + S : "."), m && !R && p(R, _, "Missing expected exception" + S), !m && E(R, _) && p(R, _, "Got unwanted exception" + S), m && R && _ && !E(R, _) || !m && R)
            throw R;
        }
        l.throws = function(m, w, _) {
          A.apply(this, [!0].concat(o.call(arguments)));
        }, l.doesNotThrow = function(m, w) {
          A.apply(this, [!1].concat(o.call(arguments)));
        }, l.ifError = function(m) {
          if (m)
            throw m;
        };
        var x = Object.keys || function(m) {
          var w = [];
          for (var _ in m)
            a.call(m, _) && w.push(_);
          return w;
        };
      }, { "util/": 11 }], 9: [function(r, n, i) {
        typeof Object.create == "function" ? n.exports = function(s, o) {
          s.super_ = o, s.prototype = Object.create(o.prototype, {
            constructor: {
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : n.exports = function(s, o) {
          s.super_ = o;
          var a = function() {
          };
          a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
        };
      }, {}], 10: [function(r, n, i) {
        n.exports = function(s) {
          return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
        };
      }, {}], 11: [function(r, n, i) {
        (function(s, o) {
          var a = /%[sdj%]/g;
          i.format = function(L) {
            if (!O(L)) {
              for (var D = [], tt = 0; tt < arguments.length; tt++)
                D.push(h(arguments[tt]));
              return D.join(" ");
            }
            for (var tt = 1, et = arguments, st = et.length, X = String(L).replace(a, function(U) {
              if (U === "%%") return "%";
              if (tt >= st) return U;
              switch (U) {
                case "%s":
                  return String(et[tt++]);
                case "%d":
                  return Number(et[tt++]);
                case "%j":
                  try {
                    return JSON.stringify(et[tt++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return U;
              }
            }), ot = et[tt]; tt < st; ot = et[++tt])
              _(ot) || !Y(ot) ? X += " " + ot : X += " " + h(ot);
            return X;
          }, i.deprecate = function(L, D) {
            if (z(o.process))
              return function() {
                return i.deprecate(L, D).apply(this, arguments);
              };
            if (s.noDeprecation === !0)
              return L;
            var tt = !1;
            function et() {
              if (!tt) {
                if (s.throwDeprecation)
                  throw new Error(D);
                s.traceDeprecation ? console.trace(D) : console.error(D), tt = !0;
              }
              return L.apply(this, arguments);
            }
            return et;
          };
          var l = {}, c;
          i.debuglog = function(L) {
            if (z(c) && (c = s.env.NODE_DEBUG || ""), L = L.toUpperCase(), !l[L])
              if (new RegExp("\\b" + L + "\\b", "i").test(c)) {
                var D = s.pid;
                l[L] = function() {
                  var tt = i.format.apply(i, arguments);
                  console.error("%s %d: %s", L, D, tt);
                };
              } else
                l[L] = function() {
                };
            return l[L];
          };
          function h(L, D) {
            var tt = {
              seen: [],
              stylize: p
            };
            return arguments.length >= 3 && (tt.depth = arguments[2]), arguments.length >= 4 && (tt.colors = arguments[3]), w(D) ? tt.showHidden = D : D && i._extend(tt, D), z(tt.showHidden) && (tt.showHidden = !1), z(tt.depth) && (tt.depth = 2), z(tt.colors) && (tt.colors = !1), z(tt.customInspect) && (tt.customInspect = !0), tt.colors && (tt.stylize = u), g(tt, L, tt.depth);
          }
          i.inspect = h, h.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, h.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function u(L, D) {
            var tt = h.styles[D];
            return tt ? "\x1B[" + h.colors[tt][0] + "m" + L + "\x1B[" + h.colors[tt][1] + "m" : L;
          }
          function p(L, D) {
            return L;
          }
          function y(L) {
            var D = {};
            return L.forEach(function(tt, et) {
              D[tt] = !0;
            }), D;
          }
          function g(L, D, tt) {
            if (L.customInspect && D && pt(D.inspect) && // Filter out the util module, it's inspect function is special
            D.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
            !(D.constructor && D.constructor.prototype === D)) {
              var et = D.inspect(tt, L);
              return O(et) || (et = g(L, et, tt)), et;
            }
            var st = b(L, D);
            if (st)
              return st;
            var X = Object.keys(D), ot = y(X);
            if (L.showHidden && (X = Object.getOwnPropertyNames(D)), at(D) && (X.indexOf("message") >= 0 || X.indexOf("description") >= 0))
              return f(D);
            if (X.length === 0) {
              if (pt(D)) {
                var mt = D.name ? ": " + D.name : "";
                return L.stylize("[Function" + mt + "]", "special");
              }
              if (F(D))
                return L.stylize(RegExp.prototype.toString.call(D), "regexp");
              if (rt(D))
                return L.stylize(Date.prototype.toString.call(D), "date");
              if (at(D))
                return f(D);
            }
            var U = "", J = !1, St = ["{", "}"];
            if (m(D) && (J = !0, St = ["[", "]"]), pt(D)) {
              var Rt = D.name ? ": " + D.name : "";
              U = " [Function" + Rt + "]";
            }
            if (F(D) && (U = " " + RegExp.prototype.toString.call(D)), rt(D) && (U = " " + Date.prototype.toUTCString.call(D)), at(D) && (U = " " + f(D)), X.length === 0 && (!J || D.length == 0))
              return St[0] + U + St[1];
            if (tt < 0)
              return F(D) ? L.stylize(RegExp.prototype.toString.call(D), "regexp") : L.stylize("[Object]", "special");
            L.seen.push(D);
            var zt;
            return J ? zt = E(L, D, tt, ot, X) : zt = X.map(function(Tt) {
              return A(L, D, tt, ot, Tt, J);
            }), L.seen.pop(), x(zt, U, St);
          }
          function b(L, D) {
            if (z(D))
              return L.stylize("undefined", "undefined");
            if (O(D)) {
              var tt = "'" + JSON.stringify(D).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return L.stylize(tt, "string");
            }
            if (R(D))
              return L.stylize("" + D, "number");
            if (w(D))
              return L.stylize("" + D, "boolean");
            if (_(D))
              return L.stylize("null", "null");
          }
          function f(L) {
            return "[" + Error.prototype.toString.call(L) + "]";
          }
          function E(L, D, tt, et, st) {
            for (var X = [], ot = 0, mt = D.length; ot < mt; ++ot)
              lt(D, String(ot)) ? X.push(A(
                L,
                D,
                tt,
                et,
                String(ot),
                !0
              )) : X.push("");
            return st.forEach(function(U) {
              U.match(/^\d+$/) || X.push(A(
                L,
                D,
                tt,
                et,
                U,
                !0
              ));
            }), X;
          }
          function A(L, D, tt, et, st, X) {
            var ot, mt, U;
            if (U = Object.getOwnPropertyDescriptor(D, st) || { value: D[st] }, U.get ? U.set ? mt = L.stylize("[Getter/Setter]", "special") : mt = L.stylize("[Getter]", "special") : U.set && (mt = L.stylize("[Setter]", "special")), lt(et, st) || (ot = "[" + st + "]"), mt || (L.seen.indexOf(U.value) < 0 ? (_(tt) ? mt = g(L, U.value, null) : mt = g(L, U.value, tt - 1), mt.indexOf(`
`) > -1 && (X ? mt = mt.split(`
`).map(function(J) {
              return "  " + J;
            }).join(`
`).substr(2) : mt = `
` + mt.split(`
`).map(function(J) {
              return "   " + J;
            }).join(`
`))) : mt = L.stylize("[Circular]", "special")), z(ot)) {
              if (X && st.match(/^\d+$/))
                return mt;
              ot = JSON.stringify("" + st), ot.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ot = ot.substr(1, ot.length - 2), ot = L.stylize(ot, "name")) : (ot = ot.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ot = L.stylize(ot, "string"));
            }
            return ot + ": " + mt;
          }
          function x(L, D, tt) {
            var et = L.reduce(function(st, X) {
              return X.indexOf(`
`) >= 0, st + X.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return et > 60 ? tt[0] + (D === "" ? "" : D + `
 `) + " " + L.join(`,
  `) + " " + tt[1] : tt[0] + D + " " + L.join(", ") + " " + tt[1];
          }
          function m(L) {
            return Array.isArray(L);
          }
          i.isArray = m;
          function w(L) {
            return typeof L == "boolean";
          }
          i.isBoolean = w;
          function _(L) {
            return L === null;
          }
          i.isNull = _;
          function S(L) {
            return L == null;
          }
          i.isNullOrUndefined = S;
          function R(L) {
            return typeof L == "number";
          }
          i.isNumber = R;
          function O(L) {
            return typeof L == "string";
          }
          i.isString = O;
          function $(L) {
            return typeof L == "symbol";
          }
          i.isSymbol = $;
          function z(L) {
            return L === void 0;
          }
          i.isUndefined = z;
          function F(L) {
            return Y(L) && _t(L) === "[object RegExp]";
          }
          i.isRegExp = F;
          function Y(L) {
            return typeof L == "object" && L !== null;
          }
          i.isObject = Y;
          function rt(L) {
            return Y(L) && _t(L) === "[object Date]";
          }
          i.isDate = rt;
          function at(L) {
            return Y(L) && (_t(L) === "[object Error]" || L instanceof Error);
          }
          i.isError = at;
          function pt(L) {
            return typeof L == "function";
          }
          i.isFunction = pt;
          function vt(L) {
            return L === null || typeof L == "boolean" || typeof L == "number" || typeof L == "string" || typeof L == "symbol" || // ES6 symbol
            typeof L > "u";
          }
          i.isPrimitive = vt, i.isBuffer = r("./support/isBuffer");
          function _t(L) {
            return Object.prototype.toString.call(L);
          }
          function Ct(L) {
            return L < 10 ? "0" + L.toString(10) : L.toString(10);
          }
          var It = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function jt() {
            var L = /* @__PURE__ */ new Date(), D = [
              Ct(L.getHours()),
              Ct(L.getMinutes()),
              Ct(L.getSeconds())
            ].join(":");
            return [L.getDate(), It[L.getMonth()], D].join(" ");
          }
          i.log = function() {
            console.log("%s - %s", jt(), i.format.apply(i, arguments));
          }, i.inherits = r("inherits"), i._extend = function(L, D) {
            if (!D || !Y(D)) return L;
            for (var tt = Object.keys(D), et = tt.length; et--; )
              L[tt[et]] = D[tt[et]];
            return L;
          };
          function lt(L, D) {
            return Object.prototype.hasOwnProperty.call(L, D);
          }
        }).call(this, r("_process"), typeof US < "u" ? US : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
      }, {}], 13: [function(r, n, i) {
        (function(s) {
          function o(h, u) {
            for (var p = 0, y = h.length - 1; y >= 0; y--) {
              var g = h[y];
              g === "." ? h.splice(y, 1) : g === ".." ? (h.splice(y, 1), p++) : p && (h.splice(y, 1), p--);
            }
            if (u)
              for (; p--; p)
                h.unshift("..");
            return h;
          }
          i.resolve = function() {
            for (var h = "", u = !1, p = arguments.length - 1; p >= -1 && !u; p--) {
              var y = p >= 0 ? arguments[p] : s.cwd();
              if (typeof y != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              y && (h = y + "/" + h, u = y.charAt(0) === "/");
            }
            return h = o(l(h.split("/"), function(g) {
              return !!g;
            }), !u).join("/"), (u ? "/" : "") + h || ".";
          }, i.normalize = function(h) {
            var u = i.isAbsolute(h), p = c(h, -1) === "/";
            return h = o(l(h.split("/"), function(y) {
              return !!y;
            }), !u).join("/"), !h && !u && (h = "."), h && p && (h += "/"), (u ? "/" : "") + h;
          }, i.isAbsolute = function(h) {
            return h.charAt(0) === "/";
          }, i.join = function() {
            var h = Array.prototype.slice.call(arguments, 0);
            return i.normalize(l(h, function(u, p) {
              if (typeof u != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return u;
            }).join("/"));
          }, i.relative = function(h, u) {
            h = i.resolve(h).substr(1), u = i.resolve(u).substr(1);
            function p(x) {
              for (var m = 0; m < x.length && x[m] === ""; m++)
                ;
              for (var w = x.length - 1; w >= 0 && x[w] === ""; w--)
                ;
              return m > w ? [] : x.slice(m, w - m + 1);
            }
            for (var y = p(h.split("/")), g = p(u.split("/")), b = Math.min(y.length, g.length), f = b, E = 0; E < b; E++)
              if (y[E] !== g[E]) {
                f = E;
                break;
              }
            for (var A = [], E = f; E < y.length; E++)
              A.push("..");
            return A = A.concat(g.slice(f)), A.join("/");
          }, i.sep = "/", i.delimiter = ":", i.dirname = function(h) {
            if (typeof h != "string" && (h = h + ""), h.length === 0) return ".";
            for (var u = h.charCodeAt(0), p = u === 47, y = -1, g = !0, b = h.length - 1; b >= 1; --b)
              if (u = h.charCodeAt(b), u === 47) {
                if (!g) {
                  y = b;
                  break;
                }
              } else
                g = !1;
            return y === -1 ? p ? "/" : "." : p && y === 1 ? "/" : h.slice(0, y);
          };
          function a(h) {
            typeof h != "string" && (h = h + "");
            var u = 0, p = -1, y = !0, g;
            for (g = h.length - 1; g >= 0; --g)
              if (h.charCodeAt(g) === 47) {
                if (!y) {
                  u = g + 1;
                  break;
                }
              } else p === -1 && (y = !1, p = g + 1);
            return p === -1 ? "" : h.slice(u, p);
          }
          i.basename = function(h, u) {
            var p = a(h);
            return u && p.substr(-1 * u.length) === u && (p = p.substr(0, p.length - u.length)), p;
          }, i.extname = function(h) {
            typeof h != "string" && (h = h + "");
            for (var u = -1, p = 0, y = -1, g = !0, b = 0, f = h.length - 1; f >= 0; --f) {
              var E = h.charCodeAt(f);
              if (E === 47) {
                if (!g) {
                  p = f + 1;
                  break;
                }
                continue;
              }
              y === -1 && (g = !1, y = f + 1), E === 46 ? u === -1 ? u = f : b !== 1 && (b = 1) : u !== -1 && (b = -1);
            }
            return u === -1 || y === -1 || // We saw a non-dot character immediately before the dot
            b === 0 || // The (right-most) trimmed path component is exactly '..'
            b === 1 && u === y - 1 && u === p + 1 ? "" : h.slice(u, y);
          };
          function l(h, u) {
            if (h.filter) return h.filter(u);
            for (var p = [], y = 0; y < h.length; y++)
              u(h[y], y, h) && p.push(h[y]);
            return p;
          }
          var c = "ab".substr(-1) === "b" ? function(h, u, p) {
            return h.substr(u, p);
          } : function(h, u, p) {
            return u < 0 && (u = h.length + u), h.substr(u, p);
          };
        }).call(this, r("_process"));
      }, { _process: 14 }], 14: [function(r, n, i) {
        var s = n.exports = {}, o, a;
        function l() {
          throw new Error("setTimeout has not been defined");
        }
        function c() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? o = setTimeout : o = l;
          } catch {
            o = l;
          }
          try {
            typeof clearTimeout == "function" ? a = clearTimeout : a = c;
          } catch {
            a = c;
          }
        })();
        function h(m) {
          if (o === setTimeout)
            return setTimeout(m, 0);
          if ((o === l || !o) && setTimeout)
            return o = setTimeout, setTimeout(m, 0);
          try {
            return o(m, 0);
          } catch {
            try {
              return o.call(null, m, 0);
            } catch {
              return o.call(this, m, 0);
            }
          }
        }
        function u(m) {
          if (a === clearTimeout)
            return clearTimeout(m);
          if ((a === c || !a) && clearTimeout)
            return a = clearTimeout, clearTimeout(m);
          try {
            return a(m);
          } catch {
            try {
              return a.call(null, m);
            } catch {
              return a.call(this, m);
            }
          }
        }
        var p = [], y = !1, g, b = -1;
        function f() {
          !y || !g || (y = !1, g.length ? p = g.concat(p) : b = -1, p.length && E());
        }
        function E() {
          if (!y) {
            var m = h(f);
            y = !0;
            for (var w = p.length; w; ) {
              for (g = p, p = []; ++b < w; )
                g && g[b].run();
              b = -1, w = p.length;
            }
            g = null, y = !1, u(m);
          }
        }
        s.nextTick = function(m) {
          var w = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var _ = 1; _ < arguments.length; _++)
              w[_ - 1] = arguments[_];
          p.push(new A(m, w)), p.length === 1 && !y && h(E);
        };
        function A(m, w) {
          this.fun = m, this.array = w;
        }
        A.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
        function x() {
        }
        s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(m) {
          return [];
        }, s.binding = function(m) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(m) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 15: [function(r, n, i) {
        var s = r("escodegen").generate;
        n.exports = function(o, a) {
          a || (a = {});
          var l = {}, c = function h(u, p) {
            if (u.type === "Literal")
              return u.value;
            if (u.type === "UnaryExpression") {
              var y = h(u.argument);
              return u.operator === "+" ? +y : u.operator === "-" ? -y : u.operator === "~" ? ~y : u.operator === "!" ? !y : l;
            } else if (u.type === "ArrayExpression") {
              for (var g = [], b = 0, f = u.elements.length; b < f; b++) {
                var E = h(u.elements[b]);
                if (E === l) return l;
                g.push(E);
              }
              return g;
            } else if (u.type === "ObjectExpression") {
              for (var A = {}, b = 0; b < u.properties.length; b++) {
                var x = u.properties[b], m = x.value === null ? x.value : h(x.value);
                if (m === l) return l;
                A[x.key.value || x.key.name] = m;
              }
              return A;
            } else if (u.type === "BinaryExpression" || u.type === "LogicalExpression") {
              var f = h(u.left);
              if (f === l) return l;
              var w = h(u.right);
              if (w === l) return l;
              var _ = u.operator;
              return _ === "==" ? f == w : _ === "===" ? f === w : _ === "!=" ? f != w : _ === "!==" ? f !== w : _ === "+" ? f + w : _ === "-" ? f - w : _ === "*" ? f * w : _ === "/" ? f / w : _ === "%" ? f % w : _ === "<" ? f < w : _ === "<=" ? f <= w : _ === ">" ? f > w : _ === ">=" ? f >= w : _ === "|" ? f | w : _ === "&" ? f & w : _ === "^" ? f ^ w : _ === "&&" ? f && w : _ === "||" ? f || w : l;
            } else {
              if (u.type === "Identifier")
                return {}.hasOwnProperty.call(a, u.name) ? a[u.name] : l;
              if (u.type === "ThisExpression")
                return {}.hasOwnProperty.call(a, "this") ? a.this : l;
              if (u.type === "CallExpression") {
                var S = h(u.callee);
                if (S === l || typeof S != "function") return l;
                var R = u.callee.object ? h(u.callee.object) : l;
                R === l && (R = null);
                for (var O = [], b = 0, f = u.arguments.length; b < f; b++) {
                  var E = h(u.arguments[b]);
                  if (E === l) return l;
                  O.push(E);
                }
                return S.apply(R, O);
              } else if (u.type === "MemberExpression") {
                var A = h(u.object);
                if (A === l || typeof A == "function")
                  return l;
                if (u.property.type === "Identifier")
                  return A[u.property.name];
                var x = h(u.property);
                return x === l ? l : A[x];
              } else if (u.type === "ConditionalExpression") {
                var y = h(u.test);
                return y === l ? l : h(y ? u.consequent : u.alternate);
              } else if (u.type === "ExpressionStatement") {
                var y = h(u.expression);
                return y === l ? l : y;
              } else {
                if (u.type === "ReturnStatement")
                  return h(u.argument);
                if (u.type === "FunctionExpression") {
                  var $ = u.body.body, z = {};
                  Object.keys(a).forEach(function(It) {
                    z[It] = a[It];
                  });
                  for (var b = 0; b < u.params.length; b++) {
                    var F = u.params[b];
                    if (F.type == "Identifier")
                      a[F.name] = null;
                    else return l;
                  }
                  for (var b in $)
                    if (h($[b]) === l)
                      return l;
                  a = z;
                  var Y = Object.keys(a), rt = Y.map(function(It) {
                    return a[It];
                  });
                  return Function(Y.join(", "), "return " + s(u)).apply(null, rt);
                } else if (u.type === "TemplateLiteral") {
                  for (var at = "", b = 0; b < u.expressions.length; b++)
                    at += h(u.quasis[b]), at += h(u.expressions[b]);
                  return at += h(u.quasis[b]), at;
                } else if (u.type === "TaggedTemplateExpression") {
                  var pt = h(u.tag), vt = u.quasi, _t = vt.quasis.map(h), Ct = vt.expressions.map(h);
                  return pt.apply(null, [_t].concat(Ct));
                } else return u.type === "TemplateElement" ? u.value.cooked : l;
              }
            }
          }(o);
          return c === l ? void 0 : c;
        };
      }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
        n.exports = r("./lib/index");
      }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
    });
  }(r9)), r9.exports;
}
rY();
function nY(e) {
  return e.toLowerCase().replace(/\s+/g, "_").replace(/[^\w-]+/g, "_");
}
const b3 = {
  line: "line",
  stepline: "line",
  bar: "bar",
  column: "bar",
  lollipop: "bar",
  histogram: "histogram",
  scatter: "scatter",
  heatmap: "scatter",
  pie: "pastry",
  donut: "pastry",
  graph: "graph"
};
(() => {
  const e = {
    line: [],
    bar: [],
    pastry: [],
    scatter: [],
    histogram: [],
    graph: []
  };
  for (let t of Object.keys(b3))
    e[b3[t]].push(t);
  return e;
})();
function iY(e) {
  var t, r, n = e.length;
  if (n === 1)
    t = 0, r = e[0][1];
  else {
    for (var i = 0, s = 0, o = 0, a = 0, l, c, h, u = 0; u < n; u++)
      l = e[u], c = l[0], h = l[1], i += c, s += h, o += c * c, a += c * h;
    t = (n * a - i * s) / (n * o - i * i), r = s / n - t * i / n;
  }
  return {
    m: t,
    b: r
  };
}
function sY(e) {
  if (e.length === 0)
    throw new Error("min requires at least one data point");
  for (var t = e[0], r = 1; r < e.length; r++)
    e[r] < t && (t = e[r]);
  return t;
}
function oY(e) {
  if (e.length === 0)
    throw new Error("max requires at least one data point");
  for (var t = e[0], r = 1; r < e.length; r++)
    e[r] > t && (t = e[r]);
  return t;
}
var aY = Object.defineProperty, lY = (e, t, r) => t in e ? aY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Uh = (e, t, r) => (lY(e, typeof t != "symbol" ? t + "" : t, r), r);
let cY = class extends Error {
  constructor(t) {
    super(`line must have at least ${t} points`);
  }
}, uY = class extends Error {
  constructor() {
    super("The first array in a zipped array must not be longer than the second.");
  }
};
const hY = { width: 3, height: 1 };
function pY(e, t, r, n) {
  let { start: i, end: s } = r;
  return i === s && (i -= 1, s += 1), {
    x: (e.x - t.start) * n.width / (t.end - t.start),
    y: (e.y - i) * n.height / (s - i)
  };
}
function af(e) {
  return Math.atan(e) * 180 / Math.PI;
}
function lu(e, t) {
  const r = [];
  for (let n = 0; n < e; n++)
    r.push(t(n));
  return r;
}
function dY(e, t) {
  if (e.length > t.length)
    throw new uY();
  return e.map(function(r, n) {
    return [r, t[n]];
  });
}
let Cf = class Lh {
  /**
   * @param points - The line's points.
   * @param key - Optional string key for identifying the line.
   */
  constructor(t, r) {
    Uh(this, "computedBestFit"), this.points = t, this.key = r;
  }
  /**
   * Create a new Line from an array of y-values.
   * @param values - Y-values.
   * @param key - Optional string key for identifying the line.
   * @returns New Line.
   */
  static fromValues(t, r) {
    return new Lh(t.map((n, i) => ({ x: i, y: n })), r);
  }
  /**
   * Generate a straight line given starting and ending y-values.
   * @param y1 - Starting y-value.
   * @param y2 - Ending y-value.
   * @param n - Number of points.
   * @param startX - Optional starting x-value.
   * @param xStep - Optional x step value.
   * @param key - Optional string key for identifying the line.
   * @returns New Line.
   */
  static generate(t, r, n, i = 0, s = 1, o) {
    const a = (r - t) / (n - 1), l = [{ x: i, y: t }];
    for (let c = 1; c < n - 1; c++)
      l.push({ x: i + c * s, y: t + c * a });
    return l.push({ x: i + l.length * s, y: r }), new Lh(l, o);
  }
  /**
   * Number of points in the line.
   */
  get length() {
    return this.points.length;
  }
  /**
   * Get a sub-sequence of the line.
   * @param start - As in Array.prototype.slice().
   * @param end - As in Array.prototype.slice().
   * @returns The slice.
   */
  slice(t, r) {
    return new Lh(this.points.slice(t, r));
  }
  /**
   * Create a new line by concatenating the line with another line.
   * @param line - The other line.
   * @returns The new line.
   */
  concat(t) {
    return new Lh(this.points.concat(t.points));
  }
  /**
   * Inserts new points at the start of the line.
   * @param points - New points.
   * @returns New number of points in the line.
   */
  unshift(...t) {
    return t.length ? (this.computedBestFit = void 0, this.points.unshift(...t)) : this.points.length;
  }
  /**
   * Removes the first point of the line.
   * @returns The removed point.
   */
  shift() {
    return this.computedBestFit = void 0, this.points.shift();
  }
  /**
   * Inserts new points at the end of the line.
   * @param points - New points.
   * @returns New number of points in the line.
   */
  push(...t) {
    return t.length ? (this.computedBestFit = void 0, this.points.push(...t)) : this.points.length;
  }
  /**
   * Removes the last point of the line.
   * @returns The removed point.
   */
  pop() {
    return this.computedBestFit = void 0, this.points.pop();
  }
  /**
   * Extract a section of the line within an x-value interval.
   * If one or both interval bounds fall between existing points,
   * (a) new endpoint(s) will be produced via interpolation. 
   * @param interval - The x-value interval of the line section to extract.
   * @returns The extracted line section.
   */
  extractSection(t) {
    if (t.end < t.start || t.start > this.points.at(-1).x || t.start < this.points[0].x || t.end < this.points[0].x || t.end > this.points.at(-1).x)
      return;
    const r = this.points.findIndex((l) => l.x >= t.start);
    let n = this.points.findIndex((l) => l.x > t.end) - 1;
    n === -2 && (n = this.points.length - 1);
    const i = this.slice(r, n + 1), s = this.points[r].x > t.start, o = this.points[n].x < t.end;
    if (!s && !o)
      return i;
    const a = this.points[1].x - this.points[0].x;
    if (s) {
      const l = (t.start - this.points[r - 1].x) / a;
      i.unshift({
        x: t.start,
        y: this.points[r - 1].y + (this.points[r].y - this.points[r - 1].y) * l
      });
    }
    if (o && t.start !== t.end) {
      const l = (t.end - this.points[n].x) / a;
      i.push({
        x: t.end,
        y: this.points[n].y + (this.points[n + 1].y - this.points[n].y) * l
      });
    }
    return i;
  }
  /**
   * Project line into another coordinate system.
   * @param xAxis - Source chart display x-axis bounds.
   * @param yAxis - Source chart display y-axis bounds.
   * @param destSize - Destination coordinate system size (default: the shared training coord sys).
   * @returns Projected line.
   */
  project(t, r, n = hY) {
    return new Lh(this.points.map((i) => pY(i, t ?? this.xBounds(), r ?? this.yBounds(), n)));
  }
  /**
   * Compute line's min and max x-values.
   * @returns X bounds.
   */
  xBounds() {
    return { start: this.points[0].x, end: this.points.at(-1).x };
  }
  /**
   * Compute line's min and max y-values.
   * @returns Y bounds.
   */
  yBounds() {
    const t = this.points.map((r) => r.y);
    return { start: sY(t), end: oY(t) };
  }
  /**
   * Compute the magnitude of the x-value range covered by the line.
   * @returns X-value range.
   */
  xRange() {
    const t = this.xBounds();
    return t.end - t.start;
  }
  /**
   * Compute the magnitude of the y-value range covered by the line.
   * @returns Y-value range.
   */
  yRange() {
    const t = this.yBounds();
    return t.end - t.start;
  }
  /**
   * Extract the line segments comprising the line.
   * @returns The line segments.
   */
  getSegments() {
    return this.points.slice(0, -1).map((t, r) => new WR({ start: t, end: this.points[r + 1] }));
  }
  /**
   * Get the best-fit straight line approximating this line. 
   * @returns Best-fit line.
   */
  get bestFit() {
    return this.computedBestFit || (this.computedBestFit = new fY(this)), this.computedBestFit;
  }
}, WR = class {
  /**
   * @param endpoints - Endpoints of the segment.
   */
  constructor(t) {
    Uh(this, "computedSlope"), Uh(this, "computedAngle"), this.endpoints = t;
  }
  /**
   * Slope of the segment.
   */
  get slope() {
    return this.computedSlope === void 0 && (this.computedSlope = (this.endpoints.end.y - this.endpoints.start.y) / (this.endpoints.end.x - this.endpoints.start.x)), this.computedSlope;
  }
  /** Angle of the segment with the x-axis. */
  get xAngle() {
    return this.computedAngle === void 0 && (this.computedAngle = af(this.slope)), this.computedAngle;
  }
}, fY = class extends WR {
  /**
   * @param line - Line to approximate.
   */
  constructor(t) {
    if (t.length < 3)
      throw new cY(3);
    const r = iY(t.points.map((i) => [i.x, i.y])), n = t.points.map((i) => ({ x: i.x, y: r.m * i.x + r.b }));
    super({ start: n[0], end: n.at(-1) }), Uh(this, "intercept"), Uh(this, "points"), Uh(this, "residuals"), this.line = t, this.computedSlope = r.m, this.intercept = r.b, this.points = n, this.residuals = t.points.map((i, s) => i.y - n[s].y);
  }
  /**
   * Compute the residual sum of squares.
   * @returns Residual sum of squares.
   */
  rss() {
    return this.residuals.map((t) => t ** 2).reduce((t, r) => t + r);
  }
};
function yi(e, t, r, n, i) {
  return ua(t, ((s, o) => {
    const a = s[o];
    if (a === void 0)
      throw new TypeError(Cx(o));
    return a;
  })(e, t), r, n, i);
}
function ua(e, t, r, n, i, s) {
  const o = Pf(t, r, n);
  if (i && t !== o)
    throw new RangeError(aO(e, t, r, n, s));
  return o;
}
function ri(e) {
  return e !== null && /object|function/.test(typeof e);
}
function Ki(e, t = Map) {
  const r = new t();
  return (n, ...i) => {
    if (r.has(n))
      return r.get(n);
    const s = e(n, ...i);
    return r.set(n, s), s;
  };
}
function If(e) {
  return Jh({
    name: e
  }, 1);
}
function Jh(e, t) {
  return ha((r) => ({
    value: r,
    configurable: 1,
    writable: !t
  }), e);
}
function gY(e) {
  return ha((t) => ({
    get: t,
    configurable: 1
  }), e);
}
function M6(e) {
  return {
    [Symbol.toStringTag]: {
      value: e,
      configurable: 1
    }
  };
}
function Sp(e, t) {
  const r = {};
  let n = e.length;
  for (const i of t)
    r[e[--n]] = i;
  return r;
}
function ha(e, t, r) {
  const n = {};
  for (const i in t)
    n[i] = e(t[i], i, r);
  return n;
}
function Gy(e, t, r) {
  const n = {};
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    n[s] = e(s, i, r);
  }
  return n;
}
function qR(e, t, r) {
  const n = {};
  for (let i = 0; i < e.length; i++)
    n[t[i]] = r[e[i]];
  return n;
}
function Ms(e, t) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const n of e)
    r[n] = t[n];
  return r;
}
function i9(e, t) {
  for (const r of t)
    if (r in e)
      return 1;
  return 0;
}
function YR(e, t, r) {
  for (const n of e)
    if (t[n] !== r[n])
      return 0;
  return 1;
}
function KR(e, t, r) {
  const n = {
    ...r
  };
  for (let i = 0; i < t; i++)
    n[e[i]] = 0;
  return n;
}
function Ze(e, ...t) {
  return (...r) => e(...t, ...r);
}
function s9(e) {
  return e[0].toUpperCase() + e.substring(1);
}
function S0(e) {
  return e.slice().sort();
}
function gm(e, t) {
  return String(t).padStart(e, "0");
}
function bl(e, t) {
  return Math.sign(e - t);
}
function Pf(e, t, r) {
  return Math.min(Math.max(e, t), r);
}
function Zo(e, t) {
  return [Math.floor(e / t), lf(e, t)];
}
function lf(e, t) {
  return (e % t + t) % t;
}
function Rl(e, t) {
  return [Qy(e, t), N6(e, t)];
}
function Qy(e, t) {
  return Math.trunc(e / t) || 0;
}
function N6(e, t) {
  return e % t || 0;
}
function Ug(e) {
  return Math.abs(e % 1) === 0.5;
}
function ZR(e, t, r) {
  let n = 0, i = 0;
  for (let a = 0; a <= t; a++) {
    const l = e[r[a]], c = vo[a], h = Pr / c, [u, p] = Rl(l, h);
    n += p * c, i += u;
  }
  const [s, o] = Rl(n, Pr);
  return [i + s, o];
}
function Wy(e, t, r) {
  const n = {};
  for (let i = t; i >= 0; i--) {
    const s = vo[i];
    n[r[i]] = Qy(e, s), e = N6(e, s);
  }
  return n;
}
function mY(e) {
  if (e !== void 0)
    return Fn(e);
}
function yY(e) {
  if (e !== void 0)
    return Uo(e);
}
function JR(e) {
  if (e !== void 0)
    return D6(e);
}
function Uo(e) {
  return eT(D6(e));
}
function D6(e) {
  return tT(CZ(e));
}
function XR(e, t) {
  if (t == null)
    throw new RangeError(Cx(e));
  return t;
}
function _0(e) {
  if (!ri(e))
    throw new TypeError(JK);
  return e;
}
function B6(e, t, r = e) {
  if (typeof t !== e)
    throw new TypeError(nc(r, t));
  return t;
}
function tT(e, t = "number") {
  if (!Number.isInteger(e))
    throw new RangeError(QK(t, e));
  return e || 0;
}
function eT(e, t = "number") {
  if (e <= 0)
    throw new RangeError(WK(t, e));
  return e;
}
function j6(e) {
  if (typeof e == "symbol")
    throw new TypeError(ZK);
  return String(e);
}
function _1(e, t) {
  return ri(e) ? String(e) : Fn(e, t);
}
function F6(e) {
  if (typeof e == "string")
    return BigInt(e);
  if (typeof e != "bigint")
    throw new TypeError(KK(e));
  return e;
}
function rT(e, t = "number") {
  if (typeof e == "bigint")
    throw new TypeError(YK(t));
  if (e = Number(e), !Number.isFinite(e))
    throw new RangeError(qK(t, e));
  return e;
}
function Gn(e, t) {
  return Math.trunc(rT(e, t)) || 0;
}
function $6(e, t) {
  return tT(rT(e, t), t);
}
function o9(e, t) {
  return eT(Gn(e, t), t);
}
function z6(e, t) {
  let [r, n] = Rl(t, Pr), i = e + r;
  const s = Math.sign(i);
  return s && s === -Math.sign(n) && (i -= s, n += s * Pr), [i, n];
}
function Xh(e, t, r = 1) {
  return z6(e[0] + t[0] * r, e[1] + t[1] * r);
}
function yu(e, t) {
  return z6(e[0], e[1] + t);
}
function yo(e, t) {
  return Xh(t, e, -1);
}
function Zi(e, t) {
  return bl(e[0], t[0]) || bl(e[1], t[1]);
}
function nT(e, t, r) {
  return Zi(e, t) === -1 || Zi(e, r) === 1;
}
function V6(e, t = 1) {
  const r = BigInt(Pr / t);
  return [Number(e / r), Number(e % r) * t];
}
function mm(e, t = 1) {
  const r = Pr / t, [n, i] = Rl(e, r);
  return [n, i * t];
}
function bo(e, t = 1, r) {
  const [n, i] = e, [s, o] = Rl(i, t);
  return n * (Pr / t) + (s + (r ? o / t : 0));
}
function U6(e, t, r = Zo) {
  const [n, i] = e, [s, o] = r(i, t);
  return [n * (Pr / t) + s, o];
}
function H6(e) {
  return yi(e, "isoYear", Nf, Mf, 1), e.isoYear === Nf ? yi(e, "isoMonth", 4, 12, 1) : e.isoYear === Mf && yi(e, "isoMonth", 1, 9, 1), e;
}
function ws(e) {
  return Ci({
    ...e,
    ...Ii,
    isoHour: 12
  }), e;
}
function Ci(e) {
  const t = yi(e, "isoYear", Nf, Mf, 1), r = t === Nf ? 1 : t === Mf ? -1 : 0;
  return r && Ro(vn({
    ...e,
    isoDay: e.isoDay + r,
    isoNanosecond: e.isoNanosecond - r
  })), e;
}
function Ro(e) {
  if (!e || nT(e, NZ, MZ))
    throw new RangeError(ic);
  return e;
}
function Tl(e) {
  return ZR(e, 5, Bs)[1];
}
function qy(e) {
  const [t, r] = Zo(e, Pr);
  return [Wy(r, 5, Bs), t];
}
function a9(e) {
  return U6(e, po);
}
function qn(e) {
  return _p(e.isoYear, e.isoMonth, e.isoDay, e.isoHour, e.isoMinute, e.isoSecond, e.isoMillisecond);
}
function vn(e) {
  const t = qn(e);
  if (t !== void 0) {
    const [r, n] = Rl(t, Si);
    return [r, n * Ea + (e.isoMicrosecond || 0) * O0 + (e.isoNanosecond || 0)];
  }
}
function G6(e, t) {
  const [r, n] = qy(Tl(e) - t);
  return Ro(vn({
    ...e,
    isoDay: e.isoDay + n,
    ...r
  }));
}
function ym(...e) {
  return _p(...e) / mO;
}
function _p(...e) {
  const [t, r] = iT(...e), n = t.valueOf();
  if (!isNaN(n))
    return n - r * Si;
}
function iT(e, t = 1, r = 1, n = 0, i = 0, s = 0, o = 0) {
  const a = e === Nf ? 1 : e === Mf ? -1 : 0, l = /* @__PURE__ */ new Date();
  return l.setUTCHours(n, i, s, o), l.setUTCFullYear(e, t - 1, r + a), [l, a];
}
function kp(e, t) {
  let [r, n] = yu(e, t);
  n < 0 && (n += Pr, r -= 1);
  const [i, s] = Zo(n, Ea), [o, a] = Zo(s, O0);
  return Yy(r * Si + i, o, a);
}
function Yy(e, t = 0, r = 0) {
  const n = Math.ceil(Math.max(0, Math.abs(e) - LZ) / Si) * Math.sign(e), i = new Date(e - n * Si);
  return Sp(m2, [i.getUTCFullYear(), i.getUTCMonth() + 1, i.getUTCDate() + n, i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds(), t, r]);
}
function Q6(e, t) {
  if (t < -864e13)
    throw new RangeError(ic);
  const r = e.formatToParts(t), n = {};
  for (const i of r)
    n[i.type] = i.value;
  return n;
}
function W6(e) {
  return [e.isoYear, e.isoMonth, e.isoDay];
}
function sT(e, t) {
  return [t, 0];
}
function oT() {
  return Wa;
}
function aT(e, t) {
  switch (t) {
    case 2:
      return q6(e) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function lT(e) {
  return q6(e) ? 366 : 365;
}
function q6(e) {
  return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);
}
function cT(e) {
  const [t, r] = iT(e.isoYear, e.isoMonth, e.isoDay);
  return lf(t.getUTCDay() - r, 7) || 7;
}
function uT(e) {
  return this.id === Mp ? (({ isoYear: t }) => t < 1 ? ["gregory-inverse", 1 - t] : ["gregory", t])(e) : this.id === Ml ? jZ(e) : [];
}
function bY(e) {
  const t = qn(e);
  if (t < BZ) {
    const { isoYear: s } = e;
    return s < 1 ? ["japanese-inverse", 1 - s] : ["japanese", s];
  }
  const r = Q6(Wx(Ml), t), { era: n, eraYear: i } = KT(r, Ml);
  return [n, i];
}
function Ky(e) {
  return Uu(e), Cp(e, 1), e;
}
function Uu(e) {
  return hT(e, 1), e;
}
function l9(e) {
  return YR(Dx, e, hT(e));
}
function hT(e, t) {
  const { isoYear: r } = e, n = yi(e, "isoMonth", 1, oT(), t);
  return {
    isoYear: r,
    isoMonth: n,
    isoDay: yi(e, "isoDay", 1, aT(r, n), t)
  };
}
function Cp(e, t) {
  return Sp(Bs, [yi(e, "isoHour", 0, 23, t), yi(e, "isoMinute", 0, 59, t), yi(e, "isoSecond", 0, 59, t), yi(e, "isoMillisecond", 0, 999, t), yi(e, "isoMicrosecond", 0, 999, t), yi(e, "isoNanosecond", 0, 999, t)]);
}
function lr(e) {
  return e === void 0 ? 0 : OO(_0(e));
}
function Zy(e, t = 0) {
  e = To(e);
  const r = LO(e), n = qZ(e, t);
  return [OO(e), n, r];
}
function Ip(e, t, r, n = 9, i = 0, s = 4) {
  t = To(t);
  let o = TO(t, n, i), a = Z6(t), l = N0(t, s);
  const c = M0(t, n, i, 1);
  return o == null ? o = Math.max(r, c) : gT(o, c), a = J6(a, c, 1), e && (l = ((h) => h < 4 ? (h + 2) % 4 : h)(l)), [o, c, a, l];
}
function Jy(e, t = 6, r) {
  let n = Z6(e = Xy(e, Am));
  const i = N0(e, 7);
  let s = M0(e, t);
  return s = XR(Am, s), n = J6(n, s, void 0, r), [s, n, i];
}
function Y6(e) {
  return jx(To(e));
}
function pT(e, t) {
  return K6(To(e), t);
}
function vY(e) {
  const t = Xy(e, vv), r = Jl(vv, QZ, t, 0);
  if (!r)
    throw new RangeError(nc(vv, r));
  return r;
}
function K6(e, t = 4) {
  const r = fT(e);
  return [N0(e, 4), ...dT(M0(e, t), r)];
}
function dT(e, t) {
  return e != null ? [vo[e], e < 4 ? 9 - 3 * e : -1] : [t === void 0 ? 1 : 10 ** (9 - t), t];
}
function Z6(e) {
  const t = e[cf];
  return t === void 0 ? 1 : Gn(t, cf);
}
function J6(e, t, r, n) {
  const i = n ? Pr : vo[t + 1];
  if (i) {
    const s = vo[t];
    if (i % ((e = ua(cf, e, 1, i / s - (n ? 0 : 1), 1)) * s))
      throw new RangeError(nc(cf, e));
  } else
    e = ua(cf, e, 1, r ? 10 ** 9 : 1, 1);
  return e;
}
function fT(e) {
  let t = e[bv];
  if (t !== void 0) {
    if (typeof t != "number") {
      if (j6(t) === "auto")
        return;
      throw new RangeError(nc(bv, t));
    }
    t = ua(bv, Math.floor(t), 0, 9, 1);
  }
  return t;
}
function To(e) {
  return e === void 0 ? {} : _0(e);
}
function Xy(e, t) {
  return typeof e == "string" ? {
    [t]: e
  } : _0(e);
}
function t2(e) {
  return {
    overflow: FZ[e]
  };
}
function X6(e, t, r = 9, n = 0, i) {
  let s = t[e];
  if (s === void 0)
    return i ? n : void 0;
  if (s = j6(s), s === "auto")
    return i ? n : null;
  let o = E3[s];
  if (o === void 0 && (o = RZ[s]), o === void 0)
    throw new RangeError(cO(e, s, E3));
  return ua(e, o, n, r, 1, Ix), o;
}
function Jl(e, t, r, n = 0) {
  const i = r[e];
  if (i === void 0)
    return n;
  const s = j6(i), o = t[s];
  if (o === void 0)
    throw new RangeError(cO(e, s, t));
  return o;
}
function gT(e, t) {
  if (t > e)
    throw new RangeError(vZ);
}
function wa(e) {
  return {
    branding: Vx,
    epochNanoseconds: e
  };
}
function Ns(e, t, r) {
  return {
    branding: sc,
    calendar: r,
    timeZone: t,
    epochNanoseconds: e
  };
}
function Ds(e, t = e.calendar) {
  return {
    branding: Np,
    calendar: t,
    ...Ms(TZ, e)
  };
}
function xa(e, t = e.calendar) {
  return {
    branding: D0,
    calendar: t,
    ...Ms(Bx, e)
  };
}
function Rf(e, t = e.calendar) {
  return {
    branding: Fx,
    calendar: t,
    ...Ms(Bx, e)
  };
}
function bm(e, t = e.calendar) {
  return {
    branding: $x,
    calendar: t,
    ...Ms(Bx, e)
  };
}
function Oo(e) {
  return {
    branding: zx,
    ...Ms(kO, e)
  };
}
function an(e) {
  return {
    branding: Ux,
    sign: Xl(e),
    ...Ms(Lx, e)
  };
}
function tx(e) {
  return U6(e.epochNanoseconds, Ea)[0];
}
function wY(e) {
  return ((t, r = 1) => {
    const [n, i] = t, s = Math.floor(i / r), o = Pr / r;
    return BigInt(n) * BigInt(o) + BigInt(s);
  })(e.epochNanoseconds);
}
function mT(e) {
  return e.epochNanoseconds;
}
function xY(e, t, r, n, i) {
  const s = bu(n), [o, a] = ((E, A) => {
    const x = A((E = Xy(E, _3))[PO]);
    let m = WZ(E);
    return m = XR(_3, m), [m, x];
  })(i, e), l = Math.max(o, s);
  if (!a && Of(l, a))
    return c9(n, o);
  if (!a)
    throw new RangeError(d2);
  if (!n.sign)
    return 0;
  const [c, h, u] = s2(t, r, a), p = cx(u), y = o2(u), g = ux(u), b = y(h, c, n);
  tp(a) || (Ci(c), Ci(b));
  const f = g(h, c, b, o);
  return Of(o, a) ? c9(f, o) : ((E, A, x, m, w, _, S) => {
    const R = Xl(E), [O, $] = ex(m, Nx(x, E), x, R, w, _, S), z = rx(A, O, $);
    return E[fr[x]] + z * R;
  })(f, p(b), o, h, c, p, y);
}
function c9(e, t) {
  return bo(En(e), vo[t], 1);
}
function ex(e, t, r, n, i, s, o) {
  const a = fr[r], l = {
    ...t,
    [a]: t[a] + n
  }, c = o(e, i, t), h = o(e, i, l);
  return [s(c), s(h)];
}
function rx(e, t, r) {
  const n = bo(yo(t, r));
  if (!n)
    throw new RangeError(Lp);
  return bo(yo(t, e)) / n;
}
function EY(e, t) {
  const [r, n, i] = Jy(t, 5, 1);
  return wa(r2(e.epochNanoseconds, r, n, i, 1));
}
function AY(e, t, r) {
  let { epochNanoseconds: n, timeZone: i, calendar: s } = t;
  const [o, a, l] = Jy(r);
  if (o === 0 && a === 1)
    return t;
  const c = e(i);
  if (o === 6)
    n = ((h, u, p, y) => {
      const g = Xi(p, u), [b, f] = h(g), E = p.epochNanoseconds, A = Ll(u, b), x = Ll(u, f);
      if (nT(E, A, x))
        throw new RangeError(Lp);
      return xT(rx(E, A, x), y) ? x : A;
    })(vT, c, t, l);
  else {
    const h = c.R(n);
    n = Pp(c, yT(kp(n, h), o, a, l), h, 2, 0, 1);
  }
  return Ns(n, i, s);
}
function SY(e, t) {
  return Ds(yT(e, ...Jy(t)), e.calendar);
}
function _Y(e, t) {
  const [r, n, i] = Jy(t, 5);
  var s;
  return Oo((s = i, nx(e, k0(r, n), s)[0]));
}
function kY(e, t) {
  const r = e(t.timeZone), n = Xi(t, r), [i, s] = vT(n), o = bo(yo(Ll(r, i), Ll(r, s)), g2, 1);
  if (o <= 0)
    throw new RangeError(Lp);
  return o;
}
function CY(e, t) {
  const { timeZone: r, calendar: n } = t, i = ((s, o, a) => Ll(o, s(Xi(a, o))))(wT, e(r), t);
  return Ns(i, r, n);
}
function yT(e, t, r, n) {
  return bT(e, k0(t, r), n);
}
function bT(e, t, r) {
  const [n, i] = nx(e, t, r);
  return Ci({
    ...Hu(e, i),
    ...n
  });
}
function nx(e, t, r) {
  return qy(Ol(Tl(e), t, r));
}
function vm(e) {
  return Ol(e, f2, 7);
}
function k0(e, t) {
  return vo[e] * t;
}
function vT(e) {
  const t = wT(e);
  return [t, Hu(t, 1)];
}
function wT(e) {
  return OZ(6, e);
}
function IY(e, t, r) {
  const n = Math.min(bu(e), 6);
  return Rp(n2(En(e, n), t, r), n);
}
function e2(e, t, r, n, i, s, o, a, l, c) {
  if (n === 0 && i === 1)
    return e;
  const h = Of(n, a) ? tp(a) && n < 6 && r >= 6 ? RY : PY : TY;
  let [u, p, y] = h(e, t, r, n, i, s, o, a, l, c);
  return y && n !== 7 && (u = ((g, b, f, E, A, x, m, w) => {
    const _ = Xl(g);
    for (let S = E + 1; S <= f; S++) {
      if (S === 7 && f !== 7)
        continue;
      const R = Nx(S, g);
      R[fr[S]] += _;
      const O = bo(yo(m(w(A, x, R)), b));
      if (O && Math.sign(O) !== _)
        break;
      g = R;
    }
    return g;
  })(u, p, r, Math.max(6, n), o, a, l, c)), u;
}
function r2(e, t, r, n, i) {
  if (t === 6) {
    const s = ((o) => o[0] + o[1] / Pr)(e);
    return [Ol(s, r, n), 0];
  }
  return n2(e, k0(t, r), n, i);
}
function n2(e, t, r, n) {
  let [i, s] = e;
  n && s < 0 && (s += Pr, i -= 1);
  const [o, a] = Zo(Ol(s, t, r), Pr);
  return z6(i + o, a);
}
function Ol(e, t, r) {
  return xT(e / t, r) * t;
}
function xT(e, t) {
  return ZZ[t](e);
}
function PY(e, t, r, n, i, s) {
  const o = Xl(e), a = En(e), l = r2(a, n, i, s), c = yo(a, l), h = Math.sign(l[0] - a[0]) === o, u = Rp(l, Math.min(r, 6));
  return [{
    ...e,
    ...u
  }, Xh(t, c), h];
}
function RY(e, t, r, n, i, s, o, a, l, c) {
  const h = Xl(e) || 1, u = bo(En(e, 5)), p = k0(n, i);
  let y = Ol(u, p, s);
  const [g, b] = ex(o, {
    ...e,
    ...Mx
  }, 6, h, a, l, c), f = y - bo(yo(g, b));
  let E = 0;
  f && Math.sign(f) !== h ? t = yu(g, y) : (E += h, y = Ol(f, p, s), t = yu(b, y));
  const A = a2(y);
  return [{
    ...e,
    ...A,
    days: e.days + E
  }, t, !!E];
}
function TY(e, t, r, n, i, s, o, a, l, c) {
  const h = Xl(e), u = fr[n], p = Nx(n, e);
  n === 7 && (e = {
    ...e,
    weeks: e.weeks + Math.trunc(e.days / 7)
  });
  const y = Qy(e[u], i) * i;
  p[u] = y;
  const [g, b] = ex(o, p, n, i * h, a, l, c), f = y + rx(t, g, b) * h * i, E = Ol(f, i, s), A = Math.sign(E - f) === h;
  return p[u] = E, [p, A ? b : g, A];
}
function u9(e, t, r, n) {
  const [i, s, o, a] = ((c) => {
    const h = K6(c = To(c));
    return [c.timeZone, ...h];
  })(n), l = i !== void 0;
  return ((c, h, u, p, y, g) => {
    u = n2(u, y, p, 1);
    const b = h.R(u);
    return ix(kp(u, b), g) + (c ? C0(vm(b)) : "Z");
  })(l, t(l ? e(i) : qu), r.epochNanoseconds, s, o, a);
}
function h9(e, t, r) {
  const [n, i, s, o, a, l] = ((c) => {
    c = To(c);
    const h = jx(c), u = fT(c), p = KZ(c), y = N0(c, 4), g = M0(c, 4);
    return [h, YZ(c), p, y, ...dT(g, u)];
  })(r);
  return ((c, h, u, p, y, g, b, f, E, A) => {
    p = n2(p, E, f, 1);
    const x = c(u).R(p);
    return ix(kp(p, x), A) + C0(vm(x), b) + ((m, w) => w !== 1 ? "[" + (w === 2 ? "!" : "") + m + "]" : "")(u, g) + sx(h, y);
  })(e, t.calendar, t.timeZone, t.epochNanoseconds, n, i, s, o, a, l);
}
function p9(e, t) {
  const [r, n, i, s] = ((c) => (c = To(c), [jx(c), ...K6(c)]))(t);
  return o = e.calendar, a = r, l = s, ix(bT(e, i, n), l) + sx(o, a);
  var o, a, l;
}
function d9(e, t) {
  return r = e.calendar, n = e, i = Y6(t), wm(n) + sx(r, i);
  var r, n, i;
}
function f9(e, t) {
  return ET(e.calendar, AT, e, Y6(t));
}
function g9(e, t) {
  return ET(e.calendar, OY, e, Y6(t));
}
function m9(e, t) {
  const [r, n, i] = pT(t);
  return s = i, ST(nx(e, n, r)[0], s);
  var s;
}
function pv(e, t) {
  const [r, n, i] = pT(t, 3);
  return n > 1 && Gu(e = {
    ...e,
    ...IY(e, n, r)
  }), ((s, o) => {
    const { sign: a } = s, l = a === -1 ? ni(s) : s, { hours: c, minutes: h } = l, [u, p] = U6(En(l, 3), po, Rl);
    IT(u);
    const y = ox(p, o), g = o >= 0 || !a || y;
    return (a < 0 ? "-" : "") + "P" + y9({
      Y: $c(l.years),
      M: $c(l.months),
      W: $c(l.weeks),
      D: $c(l.days)
    }) + (c || h || u || g ? "T" + y9({
      H: $c(c),
      M: $c(h),
      S: $c(u, g) + y
    }) : "");
  })(e, i);
}
function ET(e, t, r, n) {
  const i = n > 1 || n === 0 && e !== nr;
  return n === 1 ? e === nr ? t(r) : wm(r) : i ? wm(r) + _T(e, n === 2) : t(r);
}
function y9(e) {
  const t = [];
  for (const r in e) {
    const n = e[r];
    n && t.push(n, r);
  }
  return t.join("");
}
function ix(e, t) {
  return wm(e) + "T" + ST(e, t);
}
function wm(e) {
  return AT(e) + "-" + xs(e.isoDay);
}
function AT(e) {
  const { isoYear: t } = e;
  return (t < 0 || t > 9999 ? kT(t) + gm(6, Math.abs(t)) : gm(4, t)) + "-" + xs(e.isoMonth);
}
function OY(e) {
  return xs(e.isoMonth) + "-" + xs(e.isoDay);
}
function ST(e, t) {
  const r = [xs(e.isoHour), xs(e.isoMinute)];
  return t !== -1 && r.push(xs(e.isoSecond) + ((n, i, s, o) => ox(n * Ea + i * O0 + s, o))(e.isoMillisecond, e.isoMicrosecond, e.isoNanosecond, t)), r.join(":");
}
function C0(e, t = 0) {
  if (t === 1)
    return "";
  const [r, n] = Zo(Math.abs(e), g2), [i, s] = Zo(n, f2), [o, a] = Zo(s, po);
  return kT(e) + xs(r) + ":" + xs(i) + (o || a ? ":" + xs(o) + ox(a) : "");
}
function sx(e, t) {
  return t !== 1 && (t > 1 || t === 0 && e !== nr) ? _T(e, t === 2) : "";
}
function _T(e, t) {
  return "[" + (t ? "!" : "") + "u-ca=" + e + "]";
}
function ox(e, t) {
  let r = gm(9, e);
  return r = t === void 0 ? r.replace(tJ, "") : r.slice(0, t), r ? "." + r : "";
}
function kT(e) {
  return e < 0 ? "-" : "+";
}
function $c(e, t) {
  return e || t ? e.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function LY(e, t) {
  const { epochNanoseconds: r } = e, n = (t.R ? t : t(e.timeZone)).R(r), i = kp(r, n);
  return {
    calendar: e.calendar,
    ...i,
    offsetNanoseconds: n
  };
}
function Pp(e, t, r, n = 0, i = 0, s, o) {
  if (r !== void 0 && n === 1 && (n === 1 || o))
    return G6(t, r);
  const a = e.I(t);
  if (r !== void 0 && n !== 3) {
    const l = ((c, h, u, p) => {
      const y = vn(h);
      p && (u = vm(u));
      for (const g of c) {
        let b = bo(yo(g, y));
        if (p && (b = vm(b)), b === u)
          return g;
      }
    })(a, t, r, s);
    if (l !== void 0)
      return l;
    if (n === 0)
      throw new RangeError(dZ);
  }
  return o ? vn(t) : I0(e, t, i, a);
}
function I0(e, t, r = 0, n = e.I(t)) {
  if (n.length === 1)
    return n[0];
  if (r === 1)
    throw new RangeError(fZ);
  if (n.length)
    return n[r === 3 ? 1 : 0];
  const i = vn(t), s = ((a, l) => {
    const c = a.R(yu(l, -864e11));
    return ((h) => {
      if (h > Pr)
        throw new RangeError(pZ);
      return h;
    })(a.R(yu(l, Pr)) - c);
  })(e, i), o = s * (r === 2 ? -1 : 1);
  return (n = e.I(kp(i, o)))[r === 2 ? 0 : n.length - 1];
}
function Ll(e, t) {
  const r = e.I(t);
  if (r.length)
    return r[0];
  const n = yu(vn(t), -864e11);
  return e.O(n, 1);
}
function b9(e, t, r) {
  return wa(Ro(Xh(t.epochNanoseconds, ((n) => {
    if (PT(n))
      throw new RangeError(yZ);
    return En(n, 5);
  })(e ? ni(r) : r))));
}
function v9(e, t, r, n, i, s = /* @__PURE__ */ Object.create(null)) {
  const o = t(n.timeZone), a = e(n.calendar);
  return {
    ...n,
    ...ax(o, a, n, r ? ni(i) : i, s)
  };
}
function w9(e, t, r, n, i = /* @__PURE__ */ Object.create(null)) {
  const { calendar: s } = r;
  return Ds(lx(e(s), r, t ? ni(n) : n, i), s);
}
function x9(e, t, r, n, i) {
  const { calendar: s } = r;
  return xa(i2(e(s), r, t ? ni(n) : n, i), s);
}
function E9(e, t, r, n, i) {
  const s = r.calendar, o = e(s);
  let a = ws(Tf(o, r));
  t && (n = hx(n)), n.sign < 0 && (a = o.P(a, {
    ...An,
    months: 1
  }), a = Hu(a, -1));
  const l = o.P(a, n, i);
  return Rf(Tf(o, l), s);
}
function A9(e, t, r) {
  return Oo(CT(t, e ? ni(r) : r)[0]);
}
function ax(e, t, r, n, i) {
  const s = En(n, 5);
  let o = r.epochNanoseconds;
  if (PT(n)) {
    const a = Xi(r, e);
    o = Xh(I0(e, {
      ...i2(t, a, {
        ...n,
        ...Mx
      }, i),
      ...Ms(Bs, a)
    }), s);
  } else
    o = Xh(o, s), lr(i);
  return {
    epochNanoseconds: Ro(o)
  };
}
function lx(e, t, r, n) {
  const [i, s] = CT(t, r);
  return Ci({
    ...i2(e, t, {
      ...r,
      ...Mx,
      days: r.days + s
    }, n),
    ...i
  });
}
function i2(e, t, r, n) {
  if (r.years || r.months || r.weeks)
    return e.P(t, r, n);
  lr(n);
  const i = r.days + En(r, 5)[0];
  return i ? ws(Hu(t, i)) : t;
}
function Tf(e, t, r = 1) {
  return Hu(t, r - e.day(t));
}
function CT(e, t) {
  const [r, n] = En(t, 5), [i, s] = qy(Tl(e) + n);
  return [i, r + s];
}
function Hu(e, t) {
  return t ? {
    ...e,
    ...Yy(qn(e) + t * Si)
  } : e;
}
function s2(e, t, r) {
  const n = e(r.calendar);
  return tp(r) ? [r, n, t(r.timeZone)] : [{
    ...r,
    ...Ii
  }, n];
}
function cx(e) {
  return e ? mT : vn;
}
function o2(e) {
  return e ? Ze(ax, e) : lx;
}
function ux(e) {
  return e ? Ze(nK, e) : iK;
}
function tp(e) {
  return e && e.epochNanoseconds;
}
function Of(e, t) {
  return e <= 6 - (tp(t) ? 1 : 0);
}
function S9(e, t, r, n, i, s, o) {
  const a = e(To(o).relativeTo), l = Math.max(bu(i), bu(s));
  if (Of(l, a))
    return an(Gu(((b, f, E, A) => {
      const x = Xh(En(b), En(f), A ? -1 : 1);
      if (!Number.isFinite(x[0]))
        throw new RangeError(ic);
      return {
        ...An,
        ...Rp(x, E)
      };
    })(i, s, l, n)));
  if (!a)
    throw new RangeError(d2);
  n && (s = ni(s));
  const [c, h, u] = s2(t, r, a), p = o2(u), y = ux(u), g = p(h, c, i);
  return an(y(h, c, p(h, g, s), l));
}
function MY(e, t, r, n, i) {
  const s = bu(n), [o, a, l, c, h] = ((_, S, R) => {
    _ = Xy(_, Am);
    let O = TO(_);
    const $ = R(_[PO]);
    let z = Z6(_);
    const F = N0(_, 7);
    let Y = M0(_);
    if (O === void 0 && Y === void 0)
      throw new RangeError(bZ);
    if (Y == null && (Y = 0), O == null && (O = Math.max(Y, S)), gT(O, Y), z = J6(z, Y, 1), z > 1 && Y > 5 && O !== Y)
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    return [O, Y, z, F, $];
  })(i, s, e), u = Math.max(s, o);
  if (!h && u <= 6)
    return an(Gu(((_, S, R, O, $) => {
      const z = r2(En(_), R, O, $);
      return {
        ...An,
        ...Rp(z, S)
      };
    })(n, o, a, l, c)));
  if (!tp(h) && !n.sign)
    return n;
  if (!h)
    throw new RangeError(d2);
  const [p, y, g] = s2(t, r, h), b = cx(g), f = o2(g), E = ux(g), A = f(y, p, n);
  tp(h) || (Ci(p), Ci(A));
  let x = E(y, p, A, o);
  const m = n.sign, w = Xl(x);
  if (m && w && m !== w)
    throw new RangeError(Lp);
  return x = e2(x, b(A), o, a, l, c, y, p, b, f), an(x);
}
function NY(e) {
  return e.sign === -1 ? hx(e) : e;
}
function hx(e) {
  return an(ni(e));
}
function ni(e) {
  const t = {};
  for (const r of fr)
    t[r] = -1 * e[r] || 0;
  return t;
}
function DY(e) {
  return !e.sign;
}
function Xl(e, t = fr) {
  let r = 0;
  for (const n of t) {
    const i = Math.sign(e[n]);
    if (i) {
      if (r && r !== i)
        throw new RangeError(mZ);
      r = i;
    }
  }
  return r;
}
function Gu(e) {
  for (const t of PZ)
    ua(t, e[t], -4294967295, eJ, 1);
  return IT(bo(En(e), po)), e;
}
function IT(e) {
  if (!Number.isSafeInteger(e))
    throw new RangeError(gZ);
}
function En(e, t = 6) {
  return ZR(e, t, fr);
}
function Rp(e, t = 6) {
  const [r, n] = e, i = Wy(n, t, fr);
  if (i[fr[t]] += r * (Pr / vo[t]), !Number.isFinite(i[fr[t]]))
    throw new RangeError(ic);
  return i;
}
function a2(e, t = 5) {
  return Wy(e, t, fr);
}
function PT(e) {
  return !!Xl(e, _O);
}
function bu(e) {
  let t = 9;
  for (; t > 0 && !e[fr[t]]; t--)
    ;
  return t;
}
function BY(e, t) {
  return [e, t];
}
function _9(e) {
  const t = Math.floor(e / C1) * C1;
  return [t, t + C1];
}
function jY(e) {
  const t = tc(e = _1(e));
  if (!t)
    throw new RangeError(wi(e));
  let r;
  if (t.j)
    r = 0;
  else {
    if (!t.offset)
      throw new RangeError(wi(e));
    r = Qu(t.offset);
  }
  return t.timeZone && mx(t.timeZone, 1), wa(G6(Ky(t), r));
}
function FY(e) {
  const t = tc(Fn(e));
  if (!t)
    throw new RangeError(wi(e));
  if (t.timeZone)
    return RT(t, t.offset ? Qu(t.offset) : void 0);
  if (t.j)
    throw new RangeError(wi(e));
  return OT(t);
}
function $Y(e, t) {
  const r = tc(Fn(e));
  if (!r || !r.timeZone)
    throw new RangeError(wi(e));
  const { offset: n } = r, i = n ? Qu(n) : void 0, [, s, o] = Zy(t);
  return RT(r, i, s, o);
}
function Qu(e) {
  const t = mx(e);
  if (t === void 0)
    throw new RangeError(wi(e));
  return t;
}
function zY(e) {
  const t = tc(Fn(e));
  if (!t || t.j)
    throw new RangeError(wi(e));
  return Ds(TT(t));
}
function px(e, t, r) {
  let n = tc(Fn(e));
  if (!n || n.j)
    throw new RangeError(wi(e));
  return t ? n.calendar === nr && (n = n.isoYear === -271821 && n.isoMonth === 4 ? {
    ...n,
    isoDay: 20,
    ...Ii
  } : {
    ...n,
    isoDay: 1,
    ...Ii
  }) : r && n.calendar === nr && (n = {
    ...n,
    isoYear: Xo
  }), xa(n.C ? TT(n) : OT(n));
}
function VY(e, t) {
  const r = fx(Fn(t));
  if (r)
    return dx(r), Rf(H6(Uu(r)));
  const n = px(t, 1);
  return Rf(Tf(e(n.calendar), n));
}
function dx(e) {
  if (e.calendar !== nr)
    throw new RangeError(Jo(e.calendar));
}
function UY(e, t) {
  const r = gx(Fn(t));
  if (r)
    return dx(r), bm(Uu(r));
  const n = px(t, 0, 1), { calendar: i } = n, s = e(i), [o, a, l] = s.v(n), [c, h] = s.q(o, a), [u, p] = s.G(c, h, l);
  return bm(ws(s.V(u, p, l)), i);
}
function HY(e) {
  let t, r = ((n) => {
    const i = lJ.exec(n);
    return i ? (l2(i[10]), NT(i)) : void 0;
  })(Fn(e));
  if (!r) {
    if (r = tc(e), !r)
      throw new RangeError(wi(e));
    if (!r.C)
      throw new RangeError(wi(e));
    if (r.j)
      throw new RangeError(Jo("Z"));
    dx(r);
  }
  if ((t = fx(e)) && l9(t))
    throw new RangeError(wi(e));
  if ((t = gx(e)) && l9(t))
    throw new RangeError(wi(e));
  return Oo(Cp(r, 1));
}
function GY(e) {
  const t = ((r) => {
    const n = hJ.exec(r);
    return n ? ((i) => {
      function s(h, u, p) {
        let y = 0, g = 0;
        if (p && ([y, l] = Zo(l, vo[p])), h !== void 0) {
          if (a)
            throw new RangeError(Jo(h));
          g = ((b) => {
            const f = parseInt(b);
            if (!Number.isFinite(f))
              throw new RangeError(Jo(b));
            return f;
          })(h), o = 1, u && (l = yx(u) * (vo[p] / po), a = 1);
        }
        return y + g;
      }
      let o = 0, a = 0, l = 0, c = {
        ...Sp(fr, [s(i[2]), s(i[3]), s(i[4]), s(i[5]), s(i[6], i[7], 5), s(i[8], i[9], 4), s(i[10], i[11], 3)]),
        ...Wy(l, 2, fr)
      };
      if (!o)
        throw new RangeError(lO(fr));
      return bx(i[1]) < 0 && (c = ni(c)), c;
    })(n) : void 0;
  })(Fn(e));
  if (!t)
    throw new RangeError(wi(e));
  return an(Gu(t));
}
function QY(e) {
  const t = tc(e) || fx(e) || gx(e);
  return t ? t.calendar : e;
}
function WY(e) {
  const t = tc(e);
  return t && (t.timeZone || t.j && qu || t.offset) || e;
}
function RT(e, t, r = 0, n = 0) {
  const i = vx(e.timeZone), s = Ve(i);
  let o;
  return Ky(e), o = e.C ? Pp(s, e, t, r, n, !s.$, e.j) : Ll(s, e), Ns(o, i, p2(e.calendar));
}
function TT(e) {
  return LT(Ci(Ky(e)));
}
function OT(e) {
  return LT(ws(Uu(e)));
}
function LT(e) {
  return {
    ...e,
    calendar: p2(e.calendar)
  };
}
function tc(e) {
  const t = aJ.exec(e);
  return t ? ((r) => {
    const n = r[10], i = (n || "").toUpperCase() === "Z";
    return {
      isoYear: MT(r),
      isoMonth: parseInt(r[4]),
      isoDay: parseInt(r[5]),
      ...NT(r.slice(5)),
      ...l2(r[16]),
      C: !!r[6],
      j: i,
      offset: i ? void 0 : n
    };
  })(t) : void 0;
}
function fx(e) {
  const t = sJ.exec(e);
  return t ? ((r) => ({
    isoYear: MT(r),
    isoMonth: parseInt(r[4]),
    isoDay: 1,
    ...l2(r[5])
  }))(t) : void 0;
}
function gx(e) {
  const t = oJ.exec(e);
  return t ? ((r) => ({
    isoYear: Xo,
    isoMonth: parseInt(r[1]),
    isoDay: parseInt(r[2]),
    ...l2(r[3])
  }))(t) : void 0;
}
function mx(e, t) {
  const r = cJ.exec(e);
  return r ? ((n, i) => {
    const s = n[4] || n[5];
    if (i && s)
      throw new RangeError(Jo(s));
    return ((o) => {
      if (Math.abs(o) >= Pr)
        throw new RangeError(hZ);
      return o;
    })((Hh(n[2]) * g2 + Hh(n[3]) * f2 + Hh(n[4]) * po + yx(n[5] || "")) * bx(n[1]));
  })(r, t) : void 0;
}
function MT(e) {
  const t = bx(e[1]), r = parseInt(e[2] || e[3]);
  if (t < 0 && !r)
    throw new RangeError(Jo(-0));
  return t * r;
}
function NT(e) {
  const t = Hh(e[3]);
  return {
    ...qy(yx(e[4] || ""))[0],
    isoHour: Hh(e[1]),
    isoMinute: Hh(e[2]),
    isoSecond: t === 60 ? 59 : t
  };
}
function l2(e) {
  let t, r;
  const n = [];
  if (e.replace(uJ, (i, s, o) => {
    const a = !!s, [l, c] = o.split("=").reverse();
    if (c) {
      if (c === "u-ca")
        n.push(l), t || (t = a);
      else if (a || /[A-Z]/.test(c))
        throw new RangeError(Jo(i));
    } else {
      if (r)
        throw new RangeError(Jo(i));
      r = l;
    }
    return "";
  }), n.length > 1 && t)
    throw new RangeError(Jo(e));
  return {
    timeZone: r,
    calendar: n[0] || nr
  };
}
function yx(e) {
  return parseInt(e.padEnd(9, "0"));
}
function Tp(e) {
  return new RegExp(`^${e}$`, "i");
}
function bx(e) {
  return e && e !== "+" ? -1 : 1;
}
function Hh(e) {
  return e === void 0 ? 0 : parseInt(e);
}
function qY(e) {
  return vx(Fn(e));
}
function vx(e) {
  const t = wx(e);
  return typeof t == "number" ? C0(t) : t ? ((r) => {
    if (fJ.test(r))
      throw new RangeError(dO(r));
    if (dJ.test(r))
      throw new RangeError(uZ);
    return r.toLowerCase().split("/").map((n, i) => (n.length <= 3 || /\d/.test(n)) && !/etc|yap/.test(n) ? n.toUpperCase() : n.replace(/baja|dumont|[a-z]+/g, (s, o) => s.length <= 2 && !i || s === "in" || s === "chat" ? s.toUpperCase() : s.length > 2 || !o ? s9(s).replace(/island|noronha|murdo|rivadavia|urville/, s9) : s)).join("/");
  })(e) : qu;
}
function k9(e) {
  const t = wx(e);
  return typeof t == "number" ? t : t ? t.resolvedOptions().timeZone : qu;
}
function wx(e) {
  const t = mx(e = e.toUpperCase(), 1);
  return t !== void 0 ? t : e !== qu ? pJ(e) : void 0;
}
function DT(e, t) {
  return Zi(e.epochNanoseconds, t.epochNanoseconds);
}
function BT(e, t) {
  return Zi(e.epochNanoseconds, t.epochNanoseconds);
}
function YY(e, t, r, n, i, s) {
  const o = e(To(s).relativeTo), a = Math.max(bu(n), bu(i));
  if (YR(fr, n, i))
    return 0;
  if (Of(a, o))
    return Zi(En(n), En(i));
  if (!o)
    throw new RangeError(d2);
  const [l, c, h] = s2(t, r, o), u = cx(h), p = o2(h);
  return Zi(u(p(c, l, n)), u(p(c, l, i)));
}
function jT(e, t) {
  return Op(e, t) || xx(e, t);
}
function Op(e, t) {
  return bl(qn(e), qn(t));
}
function xx(e, t) {
  return bl(Tl(e), Tl(t));
}
function KY(e, t) {
  return !DT(e, t);
}
function ZY(e, t) {
  return !BT(e, t) && !!FT(e.timeZone, t.timeZone) && e.calendar === t.calendar;
}
function JY(e, t) {
  return !jT(e, t) && e.calendar === t.calendar;
}
function XY(e, t) {
  return !Op(e, t) && e.calendar === t.calendar;
}
function tK(e, t) {
  return !Op(e, t) && e.calendar === t.calendar;
}
function eK(e, t) {
  return !Op(e, t) && e.calendar === t.calendar;
}
function rK(e, t) {
  return !xx(e, t);
}
function FT(e, t) {
  if (e === t)
    return 1;
  try {
    return k9(e) === k9(t);
  } catch {
  }
}
function C9(e, t, r, n) {
  const i = Ip(e, n, 3, 5), s = c2(t.epochNanoseconds, r.epochNanoseconds, ...i);
  return an(e ? ni(s) : s);
}
function I9(e, t, r, n, i, s) {
  const o = h2(n.calendar, i.calendar), [a, l, c, h] = Ip(r, s, 5), u = n.epochNanoseconds, p = i.epochNanoseconds, y = Zi(p, u);
  let g;
  if (y)
    if (a < 6)
      g = c2(u, p, a, l, c, h);
    else {
      const b = t(((E, A) => {
        if (!FT(E, A))
          throw new RangeError(fO);
        return E;
      })(n.timeZone, i.timeZone)), f = e(o);
      g = zT(f, b, n, i, y, a, s), g = e2(g, p, a, l, c, h, f, n, mT, Ze(ax, b));
    }
  else
    g = An;
  return an(r ? ni(g) : g);
}
function P9(e, t, r, n, i) {
  const s = h2(r.calendar, n.calendar), [o, a, l, c] = Ip(t, i, 6), h = vn(r), u = vn(n), p = Zi(u, h);
  let y;
  if (p)
    if (o <= 6)
      y = c2(h, u, o, a, l, c);
    else {
      const g = e(s);
      y = VT(g, r, n, p, o, i), y = e2(y, u, o, a, l, c, g, r, vn, lx);
    }
  else
    y = An;
  return an(t ? ni(y) : y);
}
function R9(e, t, r, n, i) {
  const s = h2(r.calendar, n.calendar);
  return $T(t, () => e(s), r, n, ...Ip(t, i, 6, 9, 6));
}
function T9(e, t, r, n, i) {
  const s = h2(r.calendar, n.calendar), o = Ip(t, i, 9, 9, 8), a = e(s), l = Tf(a, r), c = Tf(a, n);
  return l.isoYear === c.isoYear && l.isoMonth === c.isoMonth && l.isoDay === c.isoDay ? an(An) : $T(t, () => a, ws(l), ws(c), ...o, 8);
}
function $T(e, t, r, n, i, s, o, a, l = 6) {
  const c = vn(r), h = vn(n);
  if (c === void 0 || h === void 0)
    throw new RangeError(ic);
  let u;
  if (Zi(h, c))
    if (i === 6)
      u = c2(c, h, i, s, o, a);
    else {
      const p = t();
      u = p.N(r, n, i), s === l && o === 1 || (u = e2(u, h, i, s, o, a, p, r, vn, i2));
    }
  else
    u = An;
  return an(e ? ni(u) : u);
}
function O9(e, t, r, n) {
  const [i, s, o, a] = Ip(e, n, 5, 5), l = Ol(Ex(t, r), k0(s, o), a), c = {
    ...An,
    ...a2(l, i)
  };
  return an(e ? ni(c) : c);
}
function nK(e, t, r, n, i, s) {
  const o = Zi(n.epochNanoseconds, r.epochNanoseconds);
  return o ? i < 6 ? UT(r.epochNanoseconds, n.epochNanoseconds, i) : zT(t, e, r, n, o, i, s) : An;
}
function iK(e, t, r, n, i) {
  const s = vn(t), o = vn(r), a = Zi(o, s);
  return a ? n <= 6 ? UT(s, o, n) : VT(e, t, r, a, n, i) : An;
}
function zT(e, t, r, n, i, s, o) {
  const [a, l, c] = ((p, y, g, b) => {
    function f() {
      return S = {
        ...Hu(x, w++ * -b),
        ...A
      }, R = I0(p, S), Zi(m, R) === -b;
    }
    const E = Xi(y, p), A = Ms(Bs, E), x = Xi(g, p), m = g.epochNanoseconds;
    let w = 0;
    const _ = Ex(E, x);
    let S, R;
    if (Math.sign(_) === -b && w++, f() && (b === -1 || f()))
      throw new RangeError(Lp);
    const O = bo(yo(R, m));
    return [E, S, O];
  })(t, r, n, i);
  var h, u;
  return {
    ...s === 6 ? (h = a, u = l, {
      ...An,
      days: HT(h, u)
    }) : e.N(a, l, s, o),
    ...a2(c)
  };
}
function VT(e, t, r, n, i, s) {
  const [o, a, l] = ((c, h, u) => {
    let p = h, y = Ex(c, h);
    return Math.sign(y) === -u && (p = Hu(h, -u), y += Pr * u), [c, p, y];
  })(t, r, n);
  return {
    ...e.N(o, a, i, s),
    ...a2(l)
  };
}
function c2(e, t, r, n, i, s) {
  return {
    ...An,
    ...Rp(r2(yo(e, t), n, i, s), r)
  };
}
function UT(e, t, r) {
  return {
    ...An,
    ...Rp(yo(e, t), r)
  };
}
function HT(e, t) {
  return u2(qn(e), qn(t));
}
function u2(e, t) {
  return Math.trunc((t - e) / Si);
}
function Ex(e, t) {
  return Tl(t) - Tl(e);
}
function h2(e, t) {
  if (e !== t)
    throw new RangeError(pO);
  return e;
}
function GT(e) {
  return this.m(e)[0];
}
function QT(e) {
  return this.m(e)[1];
}
function Ax(e) {
  const [t] = this.v(e);
  return u2(this.p(t), qn(e)) + 1;
}
function Sx(e) {
  const t = gJ.exec(e);
  if (!t)
    throw new RangeError(lZ(e));
  return [parseInt(t[1]), !!t[2]];
}
function P0(e, t) {
  return "M" + xs(e) + (t ? "L" : "");
}
function xm(e, t, r) {
  return e + (t || r && e >= r ? 1 : 0);
}
function _x(e, t) {
  return e - (t && e >= t ? 1 : 0);
}
function WT(e, t) {
  return (t + e) * (Math.sign(t) || 1) || 0;
}
function v3(e) {
  return AO[YT(e)];
}
function qT(e) {
  return _Z[YT(e)];
}
function YT(e) {
  return vu(e.id || nr);
}
function sK(e) {
  function t(i) {
    return ((s, o) => ({
      ...KT(s, o),
      o: s.month,
      day: parseInt(s.day)
    }))(Q6(r, i), n);
  }
  const r = Wx(e), n = vu(e);
  return {
    id: e,
    h: oK(t),
    l: aK(t)
  };
}
function oK(e) {
  return Ki((t) => {
    const r = qn(t);
    return e(r);
  }, WeakMap);
}
function aK(e) {
  const t = e(0).year - DZ;
  return Ki((r) => {
    let n, i = _p(r - t), s = 0;
    const o = [], a = [];
    do
      i += 400 * Si;
    while ((n = e(i)).year <= r);
    do
      if (i += (1 - n.day) * Si, n.year === r && (o.push(i), a.push(n.o)), i -= Si, ++s > 100 || i < -864e13)
        throw new RangeError(Lp);
    while ((n = e(i)).year >= r);
    return {
      i: o.reverse(),
      u: gO(a.reverse())
    };
  });
}
function KT(e, t) {
  let r, n, i = ZT(e);
  if (e.era) {
    const s = AO[t], o = SO[t] || {};
    s !== void 0 && (r = t === "islamic" ? "ah" : e.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), r === "bc" || r === "b" ? r = "bce" : r === "ad" || r === "a" ? r = "ce" : r === "beforeroc" && (r = "broc"), r = o[r] || r, n = i, i = WT(n, s[r] || 0));
  }
  return {
    era: r,
    eraYear: n,
    year: i
  };
}
function ZT(e) {
  return parseInt(e.relatedYear || e.year);
}
function Em(e) {
  const { year: t, o: r, day: n } = this.h(e), { u: i } = this.l(t);
  return [t, i[r] + 1, n];
}
function Lf(e, t = 1, r = 1) {
  return this.l(e).i[t - 1] + (r - 1) * Si;
}
function JT(e, t) {
  const r = k1.call(this, e);
  return [_x(t, r), r === t];
}
function k1(e) {
  const t = M9(this, e), r = M9(this, e - 1), n = t.length;
  if (n > r.length) {
    const i = qT(this);
    if (i < 0)
      return -i;
    for (let s = 0; s < n; s++)
      if (t[s] !== r[s])
        return s + 1;
  }
}
function Hg(e) {
  return u2(Lf.call(this, e), Lf.call(this, e + 1));
}
function L9(e, t) {
  const { i: r } = this.l(e);
  let n = t + 1, i = r;
  return n > r.length && (n = 1, i = this.l(e + 1).i), u2(r[t - 1], i[n - 1]);
}
function Gg(e) {
  return this.l(e).i.length;
}
function XT(e) {
  const t = this.h(e);
  return [t.era, t.eraYear];
}
function M9(e, t) {
  return Object.keys(e.l(t).u);
}
function R0(e) {
  return p2(Fn(e));
}
function p2(e) {
  if ((e = e.toLowerCase()) !== nr && e !== Mp) {
    const t = Wx(e).resolvedOptions().calendar;
    if (vu(e) !== vu(t))
      throw new RangeError(hO(e));
    return t;
  }
  return e;
}
function vu(e) {
  return e === "islamicc" && (e = "islamic"), e.split("-")[0];
}
function tO(e, t) {
  return (r) => r === nr ? e : r === Mp || r === Ml ? Object.assign(Object.create(e), {
    id: r
  }) : Object.assign(Object.create(t), mJ(r));
}
function lK(e, t, r, n) {
  const i = ec(r, n, Sa, [], vO);
  if (i.timeZone !== void 0) {
    const s = r.F(i), o = T0(i), a = e(i.timeZone);
    return {
      epochNanoseconds: Pp(t(a), {
        ...s,
        ...o
      }, i.offset !== void 0 ? Qu(i.offset) : void 0),
      timeZone: a
    };
  }
  return {
    ...r.F(i),
    ...Ii
  };
}
function cK(e, t, r, n, i, s) {
  const o = ec(r, i, Sa, yO, vO), a = e(o.timeZone), [l, c, h] = Zy(s), u = r.F(o, t2(l)), p = T0(o, l);
  return Ns(Pp(t(a), {
    ...u,
    ...p
  }, o.offset !== void 0 ? Qu(o.offset) : void 0, c, h), a, n);
}
function uK(e, t, r) {
  const n = ec(e, t, Sa, [], Aa), i = lr(r);
  return Ds(Ci({
    ...e.F(n, t2(i)),
    ...T0(n, i)
  }));
}
function hK(e, t, r, n = []) {
  const i = ec(e, t, Sa, n);
  return e.F(i, r);
}
function pK(e, t, r, n) {
  const i = ec(e, t, Ox, n);
  return e.K(i, r);
}
function dK(e, t, r, n) {
  const i = ec(e, r, Sa, L0);
  return t && i.month !== void 0 && i.monthCode === void 0 && i.year === void 0 && (i.year = Xo), e._(i, n);
}
function fK(e, t) {
  return Oo(T0(Ji(e, A3, [], 1), lr(t)));
}
function gK(e) {
  const t = Ji(e, Lx);
  return an(Gu({
    ...An,
    ...t
  }));
}
function ec(e, t, r, n = [], i = []) {
  return Ji(t, [...e.fields(r), ...i].sort(), n);
}
function Ji(e, t, r, n = !r) {
  const i = {};
  let s, o = 0;
  for (const a of t) {
    if (a === s)
      throw new RangeError(tZ(a));
    if (a === "constructor" || a === "__proto__")
      throw new RangeError(XK(a));
    let l = e[a];
    if (l !== void 0)
      o = 1, N9[a] && (l = N9[a](l, a)), i[a] = l;
    else if (r) {
      if (r.includes(a))
        throw new TypeError(Cx(a));
      i[a] = EO[a];
    }
    s = a;
  }
  if (n && !o)
    throw new TypeError(lO(t));
  return i;
}
function T0(e, t) {
  return Cp(qx({
    ...EO,
    ...e
  }), t);
}
function mK(e, t, r, n, i) {
  const { calendar: s, timeZone: o } = r, a = e(s), l = t(o), c = [...a.fields(Sa), ...bO].sort(), h = ((E) => {
    const A = Xi(E, Ve), x = C0(A.offsetNanoseconds), m = b2(E.calendar), [w, _, S] = m.v(A), [R, O] = m.q(w, _), $ = P0(R, O);
    return {
      ...SJ(A),
      year: w,
      monthCode: $,
      day: S,
      offset: x
    };
  })(r), u = Ji(n, c), p = a.k(h, u), y = {
    ...h,
    ...u
  }, [g, b, f] = Zy(i, 2);
  return Ns(Pp(l, {
    ...a.F(p, t2(g)),
    ...Cp(qx(y), g)
  }, Qu(y.offset), b, f), o, s);
}
function yK(e, t, r, n) {
  const i = e(t.calendar), s = [...i.fields(Sa), ...Aa].sort(), o = {
    ...rO(a = t),
    hour: a.isoHour,
    minute: a.isoMinute,
    second: a.isoSecond,
    millisecond: a.isoMillisecond,
    microsecond: a.isoMicrosecond,
    nanosecond: a.isoNanosecond
  };
  var a;
  const l = Ji(r, s), c = lr(n), h = i.k(o, l), u = {
    ...o,
    ...l
  };
  return Ds(Ci({
    ...i.F(h, t2(c)),
    ...Cp(qx(u), c)
  }));
}
function bK(e, t, r, n) {
  const i = e(t.calendar), s = i.fields(Sa).sort(), o = rO(t), a = Ji(r, s), l = i.k(o, a);
  return i.F(l, n);
}
function vK(e, t, r, n) {
  const i = e(t.calendar), s = i.fields(Ox).sort(), o = ((c) => {
    const h = b2(c.calendar), [u, p] = h.v(c), [y, g] = h.q(u, p);
    return {
      year: u,
      monthCode: P0(y, g)
    };
  })(t), a = Ji(r, s), l = i.k(o, a);
  return i.K(l, n);
}
function wK(e, t, r, n) {
  const i = e(t.calendar), s = i.fields(Sa).sort(), o = ((c) => {
    const h = b2(c.calendar), [u, p, y] = h.v(c), [g, b] = h.q(u, p);
    return {
      monthCode: P0(g, b),
      day: y
    };
  })(t), a = Ji(r, s), l = i.k(o, a);
  return i._(l, n);
}
function xK(e, t, r) {
  return Oo(((n, i, s) => T0({
    ...Ms(A3, n),
    ...Ji(i, A3)
  }, lr(s)))(e, t, r));
}
function EK(e, t) {
  return an((r = e, n = t, Gu({
    ...r,
    ...Ji(n, Lx)
  })));
  var r, n;
}
function eO(e, t, r, n, i) {
  t = Ms(r = e.fields(r), t), n = Ji(n, i = e.fields(i), []);
  let s = e.k(t, n);
  return s = Ji(s, [...r, ...i].sort(), []), e.F(s);
}
function dv(e, t) {
  const r = v3(e), n = SO[e.id || ""] || {};
  let { era: i, eraYear: s, year: o } = t;
  if (i !== void 0 || s !== void 0) {
    if (i === void 0 || s === void 0)
      throw new TypeError(iZ);
    if (!r)
      throw new RangeError(nZ);
    const a = r[n[i] || i];
    if (a === void 0)
      throw new RangeError(oZ(i));
    const l = WT(s, a);
    if (o !== void 0 && o !== l)
      throw new RangeError(sZ);
    o = l;
  } else if (o === void 0)
    throw new TypeError(aZ(r));
  return o;
}
function Qg(e, t, r, n) {
  let { month: i, monthCode: s } = t;
  if (s !== void 0) {
    const o = ((a, l, c, h) => {
      const u = a.L(c), [p, y] = Sx(l);
      let g = xm(p, y, u);
      if (y) {
        const b = qT(a);
        if (b === void 0)
          throw new RangeError(Nd);
        if (b > 0) {
          if (g > b)
            throw new RangeError(Nd);
          if (u === void 0) {
            if (h === 1)
              throw new RangeError(Nd);
            g--;
          }
        } else {
          if (g !== -b)
            throw new RangeError(Nd);
          if (u === void 0 && h === 1)
            throw new RangeError(Nd);
        }
      }
      return g;
    })(e, s, r, n);
    if (i !== void 0 && i !== o)
      throw new RangeError(cZ);
    i = o, n = 1;
  } else if (i === void 0)
    throw new TypeError(uO);
  return ua("month", i, 1, e.B(r), n);
}
function fv(e, t, r, n, i) {
  return yi(t, "day", 1, e.U(n, r), i);
}
function gv(e, t, r, n) {
  let i = 0;
  const s = [];
  for (const o of r)
    t[o] !== void 0 ? i = 1 : s.push(o);
  if (Object.assign(e, t), i)
    for (const o of n || s)
      delete e[o];
}
function rO(e) {
  const t = b2(e.calendar), [r, n, i] = t.v(e), [s, o] = t.q(r, n);
  return {
    year: r,
    monthCode: P0(s, o),
    day: i
  };
}
function AK(e) {
  return wa(Ro(V6(F6(e))));
}
function SK(e, t, r, n, i = nr) {
  return Ns(Ro(V6(F6(r))), t(n), e(i));
}
function _K(e, t, r, n, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, h = nr) {
  return Ds(Ci(Ky(ha(Gn, Sp(m2, [t, r, n, i, s, o, a, l, c])))), e(h));
}
function kK(e, t, r, n, i = nr) {
  return xa(ws(Uu(ha(Gn, {
    isoYear: t,
    isoMonth: r,
    isoDay: n
  }))), e(i));
}
function CK(e, t, r, n = nr, i = 1) {
  const s = Gn(t), o = Gn(r), a = e(n);
  return Rf(H6(Uu({
    isoYear: s,
    isoMonth: o,
    isoDay: Gn(i)
  })), a);
}
function IK(e, t, r, n = nr, i = Xo) {
  const s = Gn(t), o = Gn(r), a = e(n);
  return bm(ws(Uu({
    isoYear: Gn(i),
    isoMonth: s,
    isoDay: o
  })), a);
}
function PK(e = 0, t = 0, r = 0, n = 0, i = 0, s = 0) {
  return Oo(Cp(ha(Gn, Sp(Bs, [e, t, r, n, i, s])), 1));
}
function RK(e = 0, t = 0, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0) {
  return an(Gu(ha($6, Sp(fr, [e, t, r, n, i, s, o, a, l, c]))));
}
function TK(e, t, r = nr) {
  return Ns(e.epochNanoseconds, t, r);
}
function OK(e) {
  return wa(e.epochNanoseconds);
}
function nO(e, t) {
  return Ds(Xi(t, e));
}
function iO(e, t) {
  return xa(Xi(t, e));
}
function sO(e, t) {
  return Oo(Xi(t, e));
}
function LK(e, t, r, n) {
  const i = ((s, o, a, l) => {
    const c = ((h) => LO(To(h)))(l);
    return I0(s(o), a, c);
  })(e, r, t, n);
  return Ns(Ro(i), r, t.calendar);
}
function MK(e, t, r, n, i) {
  const s = e(i.timeZone), o = i.plainTime, a = o !== void 0 ? t(o) : void 0, l = r(s);
  let c;
  return c = a ? I0(l, {
    ...n,
    ...a
  }) : Ll(l, {
    ...n,
    ...Ii
  }), Ns(c, s, n.calendar);
}
function NK(e, t = Ii) {
  return Ds(Ci({
    ...e,
    ...t
  }));
}
function DK(e, t, r) {
  return ((n, i) => {
    const s = ec(n, i, wO);
    return n.K(s, void 0);
  })(e(t.calendar), r);
}
function BK(e, t, r) {
  return ((n, i) => {
    const s = ec(n, i, xO);
    return n._(s);
  })(e(t.calendar), r);
}
function jK(e, t, r, n) {
  return ((i, s, o) => eO(i, s, wO, _0(o), L0))(e(t.calendar), r, n);
}
function FK(e, t, r, n) {
  return ((i, s, o) => eO(i, s, xO, _0(o), Px))(e(t.calendar), r, n);
}
function $K(e) {
  return wa(Ro(mm($6(e), Ea)));
}
function zK(e) {
  return wa(Ro(V6(F6(e))));
}
function Wu(e, t, r) {
  const n = new Set(r);
  return (i, s) => {
    const o = r && i9(i, r);
    if (!i9(i = ((a, l) => {
      const c = {};
      for (const h in l)
        a.has(h) || (c[h] = l[h]);
      return c;
    })(n, i), e)) {
      if (s && o)
        throw new TypeError("Invalid formatting options");
      i = {
        ...t,
        ...i
      };
    }
    return r && (i.timeZone = qu, ["full", "long"].includes(i.J) && (i.J = "medium")), i;
  };
}
function rc(e, t = oO, r = 0) {
  const [n, , , i] = e;
  return (s, o = UJ, ...a) => {
    const l = t(i && i(...a), s, o, n, r), c = l.resolvedOptions();
    return [l, ...VK(e, c, a)];
  };
}
function oO(e, t, r, n, i) {
  if (r = n(r, i), e) {
    if (r.timeZone !== void 0)
      throw new TypeError(xZ);
    r.timeZone = e;
  }
  return new vl(t, r);
}
function VK(e, t, r) {
  const [, n, i] = e;
  return r.map((s) => (s.calendar && ((o, a, l) => {
    if ((l || o !== nr) && o !== a)
      throw new RangeError(pO);
  })(s.calendar, t.calendar, i), n(s, t)));
}
function UK(e, t, r) {
  const n = t.timeZone, i = e(n), s = {
    ...Xi(t, i),
    ...r || Ii
  };
  let o;
  return o = r ? Pp(i, s, s.offsetNanoseconds, 2) : Ll(i, s), Ns(o, n, t.calendar);
}
function HK(e, t = Ii) {
  return Ds(Ci({
    ...e,
    ...t
  }));
}
function kx(e, t) {
  return {
    ...e,
    calendar: t
  };
}
function GK(e, t) {
  return {
    ...e,
    timeZone: t
  };
}
function mv(e) {
  const t = w3();
  return kp(t, e.R(t));
}
function w3() {
  return mm(Date.now(), Ea);
}
function Md() {
  return D9 || (D9 = new vl().resolvedOptions().timeZone);
}
const QK = (e, t) => `Non-integer ${e}: ${t}`, WK = (e, t) => `Non-positive ${e}: ${t}`, qK = (e, t) => `Non-finite ${e}: ${t}`, YK = (e) => `Cannot convert bigint to ${e}`, KK = (e) => `Invalid bigint: ${e}`, ZK = "Cannot convert Symbol to string", JK = "Invalid object", aO = (e, t, r, n, i) => i ? aO(e, i[t], i[r], i[n]) : nc(e, t) + `; must be between ${r}-${n}`, nc = (e, t) => `Invalid ${e}: ${t}`, Cx = (e) => `Missing ${e}`, XK = (e) => `Invalid field ${e}`, tZ = (e) => `Duplicate field ${e}`, lO = (e) => "No valid fields: " + e.join(), eZ = "Invalid bag", cO = (e, t, r) => nc(e, t) + "; must be " + Object.keys(r).join(), rZ = "Cannot use valueOf", x3 = "Invalid calling context", nZ = "Forbidden era/eraYear", iZ = "Mismatching era/eraYear", sZ = "Mismatching year/eraYear", oZ = (e) => `Invalid era: ${e}`, aZ = (e) => "Missing year" + (e ? "/era/eraYear" : ""), lZ = (e) => `Invalid monthCode: ${e}`, cZ = "Mismatching month/monthCode", uO = "Missing month/monthCode", Nd = "Invalid leap month", Lp = "Invalid protocol results", hO = (e) => nc("Calendar", e), pO = "Mismatching Calendars", dO = (e) => nc("TimeZone", e), fO = "Mismatching TimeZones", uZ = "Forbidden ICU TimeZone", hZ = "Out-of-bounds offset", pZ = "Out-of-bounds TimeZone gap", dZ = "Invalid TimeZone offset", fZ = "Ambiguous offset", ic = "Out-of-bounds date", gZ = "Out-of-bounds duration", mZ = "Cannot mix duration signs", d2 = "Missing relativeTo", yZ = "Cannot use large units", bZ = "Required smallestUnit or largestUnit", vZ = "smallestUnit > largestUnit", wi = (e) => `Cannot parse: ${e}`, Jo = (e) => `Invalid substring: ${e}`, wZ = (e) => `Cannot format ${e}`, yv = "Mismatching types for formatting", xZ = "Cannot specify TimeZone", gO = /* @__PURE__ */ Ze(Gy, (e, t) => t), ep = /* @__PURE__ */ Ze(Gy, (e, t, r) => r), xs = /* @__PURE__ */ Ze(gm, 2), E3 = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, Ix = /* @__PURE__ */ Object.keys(E3), Si = 864e5, mO = 1e3, O0 = 1e3, Ea = 1e6, po = 1e9, f2 = 6e10, g2 = 36e11, Pr = 864e11, vo = [1, O0, Ea, po, f2, g2, Pr], Aa = /* @__PURE__ */ Ix.slice(0, 6), A3 = /* @__PURE__ */ S0(Aa), EZ = ["offset"], yO = ["timeZone"], bO = /* @__PURE__ */ Aa.concat(EZ), vO = /* @__PURE__ */ bO.concat(yO), S3 = ["era", "eraYear"], AZ = /* @__PURE__ */ S3.concat(["year"]), Px = ["year"], Rx = ["monthCode"], Tx = /* @__PURE__ */ ["month"].concat(Rx), L0 = ["day"], Ox = /* @__PURE__ */ Tx.concat(Px), wO = /* @__PURE__ */ Rx.concat(Px), Sa = /* @__PURE__ */ L0.concat(Ox), SZ = /* @__PURE__ */ L0.concat(Tx), xO = /* @__PURE__ */ L0.concat(Rx), EO = /* @__PURE__ */ ep(Aa, 0), nr = "iso8601", Mp = "gregory", Ml = "japanese", AO = {
  [Mp]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [Ml]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, SO = {
  [Mp]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [Ml]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
}, _Z = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, Fn = /* @__PURE__ */ Ze(B6, "string"), kZ = /* @__PURE__ */ Ze(B6, "boolean"), CZ = /* @__PURE__ */ Ze(B6, "number"), fr = /* @__PURE__ */ Ix.map((e) => e + "s"), Lx = /* @__PURE__ */ S0(fr), IZ = /* @__PURE__ */ fr.slice(0, 6), _O = /* @__PURE__ */ fr.slice(6), PZ = /* @__PURE__ */ _O.slice(1), RZ = /* @__PURE__ */ gO(fr), An = /* @__PURE__ */ ep(fr, 0), Mx = /* @__PURE__ */ ep(IZ, 0), Nx = /* @__PURE__ */ Ze(KR, fr), Bs = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"], Dx = ["isoDay", "isoMonth", "isoYear"], m2 = /* @__PURE__ */ Bs.concat(Dx), Bx = /* @__PURE__ */ S0(Dx), kO = /* @__PURE__ */ S0(Bs), TZ = /* @__PURE__ */ S0(m2), Ii = /* @__PURE__ */ ep(kO, 0), OZ = /* @__PURE__ */ Ze(KR, m2), CO = 1e8, LZ = CO * Si, MZ = [CO, 0], NZ = [-1e8, 0], Mf = 275760, Nf = -271821, vl = Intl.DateTimeFormat, IO = "en-GB", DZ = 1970, Xo = 1972, Wa = 12, BZ = /* @__PURE__ */ _p(1868, 9, 8), jZ = /* @__PURE__ */ Ki(bY, WeakMap), Am = "smallestUnit", _3 = "unit", cf = "roundingIncrement", bv = "fractionalSecondDigits", PO = "relativeTo", vv = "direction", RO = {
  constrain: 0,
  reject: 1
}, FZ = /* @__PURE__ */ Object.keys(RO), $Z = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}, zZ = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}, VZ = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}, UZ = {
  auto: 0,
  never: 1,
  critical: 2
}, HZ = {
  auto: 0,
  never: 1
}, GZ = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}, QZ = {
  previous: -1,
  next: 1
}, M0 = /* @__PURE__ */ Ze(X6, Am), TO = /* @__PURE__ */ Ze(X6, "largestUnit"), WZ = /* @__PURE__ */ Ze(X6, _3), OO = /* @__PURE__ */ Ze(Jl, "overflow", RO), LO = /* @__PURE__ */ Ze(Jl, "disambiguation", $Z), qZ = /* @__PURE__ */ Ze(Jl, "offset", zZ), jx = /* @__PURE__ */ Ze(Jl, "calendarName", VZ), YZ = /* @__PURE__ */ Ze(Jl, "timeZoneName", UZ), KZ = /* @__PURE__ */ Ze(Jl, "offset", HZ), N0 = /* @__PURE__ */ Ze(Jl, "roundingMode", GZ), Fx = "PlainYearMonth", $x = "PlainMonthDay", D0 = "PlainDate", Np = "PlainDateTime", zx = "PlainTime", sc = "ZonedDateTime", Vx = "Instant", Ux = "Duration", ZZ = [Math.floor, (e) => Ug(e) ? Math.floor(e) : Math.round(e), Math.ceil, (e) => Ug(e) ? Math.ceil(e) : Math.round(e), Math.trunc, (e) => Ug(e) ? Math.trunc(e) || 0 : Math.round(e), (e) => e < 0 ? Math.floor(e) : Math.ceil(e), (e) => Math.sign(e) * Math.round(Math.abs(e)) || 0, (e) => Ug(e) ? (e = Math.trunc(e) || 0) + e % 2 : Math.round(e)], qu = "UTC", C1 = 5184e3, JZ = /* @__PURE__ */ ym(1847), XZ = /* @__PURE__ */ ym(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10), tJ = /0+$/, Xi = /* @__PURE__ */ Ki(LY, WeakMap), eJ = 2 ** 32 - 1, Ve = /* @__PURE__ */ Ki((e) => {
  const t = wx(e);
  return typeof t == "object" ? new nJ(t) : new rJ(t || 0);
});
class rJ {
  constructor(t) {
    this.$ = t;
  }
  R() {
    return this.$;
  }
  I(t) {
    return ((r) => {
      const n = vn({
        ...r,
        ...Ii
      });
      if (!n || Math.abs(n[0]) > 1e8)
        throw new RangeError(ic);
    })(t), [G6(t, this.$)];
  }
  O() {
  }
}
class nJ {
  constructor(t) {
    this.nn = ((r) => {
      function n(c) {
        const h = Pf(c, a, l), [u, p] = _9(h), y = s(u), g = s(p);
        return y === g ? y : i(o(u, p), y, g, c);
      }
      function i(c, h, u, p) {
        let y, g;
        for (; (p === void 0 || (y = p < c[0] ? h : p >= c[1] ? u : void 0) === void 0) && (g = c[1] - c[0]); ) {
          const b = c[0] + Math.floor(g / 2);
          r(b) === u ? c[1] = b : c[0] = b + 1;
        }
        return y;
      }
      const s = Ki(r), o = Ki(BY);
      let a = JZ, l = XZ;
      return {
        tn(c) {
          const h = n(c - 86400), u = n(c + 86400), p = c - h, y = c - u;
          if (h === u)
            return [p];
          const g = n(p);
          return g === n(y) ? [c - g] : h > u ? [p, y] : [];
        },
        rn: n,
        O(c, h) {
          const u = Pf(c, a, l);
          let [p, y] = _9(u);
          const g = C1 * h, b = h < 0 ? () => y > a || (a = u, 0) : () => p < l || (l = u, 0);
          for (; b(); ) {
            const f = s(p), E = s(y);
            if (f !== E) {
              const A = o(p, y);
              i(A, f, E);
              const x = A[0];
              if ((bl(x, c) || 1) === h)
                return x;
            }
            p += g, y += g;
          }
        }
      };
    })(/* @__PURE__ */ ((r) => (n) => {
      const i = Q6(r, n * mO);
      return ym(ZT(i), parseInt(i.month), parseInt(i.day), parseInt(i.hour), parseInt(i.minute), parseInt(i.second)) - n;
    })(t));
  }
  R(t) {
    return this.nn.rn(((r) => a9(r)[0])(t)) * po;
  }
  I(t) {
    const [r, n] = [ym((i = t).isoYear, i.isoMonth, i.isoDay, i.isoHour, i.isoMinute, i.isoSecond), i.isoMillisecond * Ea + i.isoMicrosecond * O0 + i.isoNanosecond];
    var i;
    return this.nn.tn(r).map((s) => Ro(yu(mm(s, po), n)));
  }
  O(t, r) {
    const [n, i] = a9(t), s = this.nn.O(n + (r > 0 || i ? 1 : 0), r);
    if (s !== void 0)
      return mm(s, po);
  }
}
const Hx = "([+-])", I1 = "(?:[.,](\\d{1,9}))?", MO = `(?:(?:${Hx}(\\d{6}))|(\\d{4}))-?(\\d{2})`, Gx = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + I1 + ")?)?", Qx = Hx + Gx, iJ = MO + "-?(\\d{2})(?:[T ]" + Gx + "(Z|" + Qx + ")?)?", NO = "\\[(!?)([^\\]]*)\\]", y2 = `((?:${NO}){0,9})`, sJ = /* @__PURE__ */ Tp(MO + y2), oJ = /* @__PURE__ */ Tp("(?:--)?(\\d{2})-?(\\d{2})" + y2), aJ = /* @__PURE__ */ Tp(iJ + y2), lJ = /* @__PURE__ */ Tp("T?" + Gx + "(?:" + Qx + ")?" + y2), cJ = /* @__PURE__ */ Tp(Qx), uJ = /* @__PURE__ */ new RegExp(NO, "g"), hJ = /* @__PURE__ */ Tp(`${Hx}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${I1}H)?(?:(\\d+)${I1}M)?(?:(\\d+)${I1}S)?)?`), pJ = /* @__PURE__ */ Ki((e) => new vl(IO, {
  timeZone: e,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
})), dJ = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, fJ = /[^\w\/:+-]+/, gJ = /^M(\d{2})(L?)$/, mJ = /* @__PURE__ */ Ki(sK), Wx = /* @__PURE__ */ Ki((e) => new vl(IO, {
  calendar: e,
  timeZone: qu,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
})), DO = {
  P(e, t, r) {
    const n = lr(r);
    let i, { years: s, months: o, weeks: a, days: l } = t;
    if (l += En(t, 5)[0], s || o)
      i = ((c, h, u, p, y) => {
        let [g, b, f] = c.v(h);
        if (u) {
          const [E, A] = c.q(g, b);
          g += u, b = xm(E, A, c.L(g)), b = ua("month", b, 1, c.B(g), y);
        }
        return p && ([g, b] = c.un(g, b, p)), f = ua("day", f, 1, c.U(g, b), y), c.p(g, b, f);
      })(this, e, s, o, n);
    else {
      if (!a && !l)
        return e;
      i = qn(e);
    }
    if (i === void 0)
      throw new RangeError(ic);
    return i += (7 * a + l) * Si, ws(Yy(i));
  },
  N(e, t, r) {
    if (r <= 7) {
      let l = 0, c = HT({
        ...e,
        ...Ii
      }, {
        ...t,
        ...Ii
      });
      return r === 7 && ([l, c] = Rl(c, 7)), {
        ...An,
        weeks: l,
        days: c
      };
    }
    const n = this.v(e), i = this.v(t);
    let [s, o, a] = ((l, c, h, u, p, y, g) => {
      let b = p - c, f = y - h, E = g - u;
      if (b || f) {
        const A = Math.sign(b || f);
        let x = l.U(p, y), m = 0;
        if (Math.sign(E) === -A) {
          const w = x;
          [p, y] = l.un(p, y, -A), b = p - c, f = y - h, x = l.U(p, y), m = A < 0 ? -w : x;
        }
        if (E = g - Math.min(u, x) + m, b) {
          const [w, _] = l.q(c, h), [S, R] = l.q(p, y);
          if (f = S - w || Number(R) - Number(_), Math.sign(f) === -A) {
            const O = A < 0 && -l.B(p);
            b = (p -= A) - c, f = y - xm(w, _, l.L(p)) + (O || l.B(p));
          }
        }
      }
      return [b, f, E];
    })(this, ...n, ...i);
    return r === 8 && (o += this.cn(s, n[0]), s = 0), {
      ...An,
      years: s,
      months: o,
      days: a
    };
  },
  F(e, t) {
    const r = lr(t), n = dv(this, e), i = Qg(this, e, n, r), s = fv(this, e, i, n, r);
    return xa(ws(this.V(n, i, s)), this.id || nr);
  },
  K(e, t) {
    const r = lr(t), n = dv(this, e), i = Qg(this, e, n, r);
    return Rf(H6(this.V(n, i, 1)), this.id || nr);
  },
  _(e, t) {
    const r = lr(t);
    let n, i, s, o = e.eraYear !== void 0 || e.year !== void 0 ? dv(this, e) : void 0;
    const a = !this.id;
    if (o === void 0 && a && (o = Xo), o !== void 0) {
      const u = Qg(this, e, o, r);
      n = fv(this, e, u, o, r);
      const p = this.L(o);
      i = _x(u, p), s = u === p;
    } else {
      if (e.monthCode === void 0)
        throw new TypeError(uO);
      if ([i, s] = Sx(e.monthCode), this.id && this.id !== Mp && this.id !== Ml)
        if (this.id && vu(this.id) === "coptic" && r === 0) {
          const u = s || i !== 13 ? 30 : 6;
          n = e.day, n = Pf(n, 1, u);
        } else if (this.id && vu(this.id) === "chinese" && r === 0) {
          const u = !s || i !== 1 && i !== 9 && i !== 10 && i !== 11 && i !== 12 ? 30 : 29;
          n = e.day, n = Pf(n, 1, u);
        } else
          n = e.day;
      else
        n = fv(this, e, Qg(this, e, Xo, r), Xo, r);
    }
    const l = this.G(i, s, n);
    if (!l)
      throw new RangeError("Cannot guess year");
    const [c, h] = l;
    return bm(ws(this.V(c, h, n)), this.id || nr);
  },
  fields(e) {
    return v3(this) && e.includes("year") ? [...e, ...S3] : e;
  },
  k(e, t) {
    const r = Object.assign(/* @__PURE__ */ Object.create(null), e);
    return gv(r, t, Tx), v3(this) && (gv(r, t, AZ), this.id === Ml && gv(r, t, SZ, S3)), r;
  },
  inLeapYear(e) {
    const [t] = this.v(e);
    return this.sn(t);
  },
  monthsInYear(e) {
    const [t] = this.v(e);
    return this.B(t);
  },
  daysInMonth(e) {
    const [t, r] = this.v(e);
    return this.U(t, r);
  },
  daysInYear(e) {
    const [t] = this.v(e);
    return this.fn(t);
  },
  dayOfYear: Ax,
  era(e) {
    return this.hn(e)[0];
  },
  eraYear(e) {
    return this.hn(e)[1];
  },
  monthCode(e) {
    const [t, r] = this.v(e), [n, i] = this.q(t, r);
    return P0(n, i);
  },
  dayOfWeek: cT,
  daysInWeek() {
    return 7;
  }
}, yJ = {
  v: W6,
  hn: uT,
  q: sT
}, bJ = {
  dayOfYear: Ax,
  v: W6,
  p: _p
}, vJ = /* @__PURE__ */ Object.assign({}, bJ, {
  weekOfYear: GT,
  yearOfWeek: QT,
  m(e) {
    function t(y) {
      return (7 - y < n ? 7 : 0) - y;
    }
    function r(y) {
      const g = lT(p + y), b = y || 1, f = t(lf(l + g * b, 7));
      return h = (g + (f - c) * b) / 7;
    }
    const n = this.id ? 1 : 4, i = cT(e), s = this.dayOfYear(e), o = lf(i - 1, 7), a = s - 1, l = lf(o - a, 7), c = t(l);
    let h, u = Math.floor((a - c) / 7) + 1, p = e.isoYear;
    return u ? u > r(0) && (u = 1, p++) : (u = r(-1), p--), [u, p, h];
  }
}), wJ = /* @__PURE__ */ Object.assign({}, DO, vJ, {
  v: W6,
  hn: uT,
  q: sT,
  G(e, t) {
    if (!t)
      return [Xo, e];
  },
  sn: q6,
  L() {
  },
  B: oT,
  cn: (e) => e * Wa,
  U: aT,
  fn: lT,
  V: (e, t, r) => ({
    isoYear: e,
    isoMonth: t,
    isoDay: r
  }),
  p: _p,
  un: (e, t, r) => (e += Qy(r, Wa), (t += N6(r, Wa)) < 1 ? (e--, t += Wa) : t > Wa && (e++, t -= Wa), [e, t]),
  year(e) {
    return e.isoYear;
  },
  month(e) {
    return e.isoMonth;
  },
  day: (e) => e.isoDay
}), xJ = {
  v: Em,
  hn: XT,
  q: JT
}, EJ = {
  dayOfYear: Ax,
  v: Em,
  p: Lf,
  weekOfYear: GT,
  yearOfWeek: QT,
  m() {
    return [];
  }
}, AJ = /* @__PURE__ */ Object.assign({}, DO, EJ, {
  v: Em,
  hn: XT,
  q: JT,
  G(e, t, r) {
    const n = this.id && vu(this.id) === "chinese" ? ((c, h, u) => {
      if (h)
        switch (c) {
          case 1:
            return 1651;
          case 2:
            return u < 30 ? 1947 : 1765;
          case 3:
            return u < 30 ? 1966 : 1955;
          case 4:
            return u < 30 ? 1963 : 1944;
          case 5:
            return u < 30 ? 1971 : 1952;
          case 6:
            return u < 30 ? 1960 : 1941;
          case 7:
            return u < 30 ? 1968 : 1938;
          case 8:
            return u < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      return 1972;
    })(e, t, r) : Xo;
    let [i, s, o] = Em.call(this, {
      isoYear: n,
      isoMonth: Wa,
      isoDay: 31
    });
    const a = k1.call(this, i), l = s === a;
    (bl(e, _x(s, a)) || bl(Number(t), Number(l)) || bl(r, o)) === 1 && i--;
    for (let c = 0; c < 100; c++) {
      const h = i - c, u = k1.call(this, h), p = xm(e, t, u);
      if (t === (p === u) && r <= L9.call(this, h, p))
        return [h, p];
    }
  },
  sn(e) {
    const t = Hg.call(this, e);
    return t > Hg.call(this, e - 1) && t > Hg.call(this, e + 1);
  },
  L: k1,
  B: Gg,
  cn(e, t) {
    const r = t + e, n = Math.sign(e), i = n < 0 ? -1 : 0;
    let s = 0;
    for (let o = t; o !== r; o += n)
      s += Gg.call(this, o + i);
    return s;
  },
  U: L9,
  fn: Hg,
  V(e, t, r) {
    return Yy(Lf.call(this, e, t, r));
  },
  p: Lf,
  un(e, t, r) {
    if (r) {
      if (t += r, !Number.isSafeInteger(t))
        throw new RangeError(ic);
      if (r < 0)
        for (; t < 1; )
          t += Gg.call(this, --e);
      else {
        let n;
        for (; t > (n = Gg.call(this, e)); )
          t -= n, e++;
      }
    }
    return [e, t];
  },
  year(e) {
    return this.h(e).year;
  },
  month(e) {
    const { year: t, o: r } = this.h(e), { u: n } = this.l(t);
    return n[r] + 1;
  },
  day(e) {
    return this.h(e).day;
  }
}), b2 = /* @__PURE__ */ tO(yJ, xJ), Le = /* @__PURE__ */ tO(wJ, AJ), N9 = {
  era: _1,
  eraYear: Gn,
  year: Gn,
  month: o9,
  monthCode(e) {
    const t = _1(e);
    return Sx(t), t;
  },
  day: o9,
  .../* @__PURE__ */ ep(Aa, Gn),
  .../* @__PURE__ */ ep(fr, $6),
  offset(e) {
    const t = _1(e);
    return Qu(t), t;
  }
}, qx = /* @__PURE__ */ Ze(qR, Aa, Bs), SJ = /* @__PURE__ */ Ze(qR, Bs, Aa), wl = "numeric", B0 = ["timeZoneName"], BO = {
  month: wl,
  day: wl
}, Yx = {
  year: wl,
  month: wl
}, Kx = /* @__PURE__ */ Object.assign({}, Yx, {
  day: wl
}), Zx = {
  hour: wl,
  minute: wl,
  second: wl
}, Jx = /* @__PURE__ */ Object.assign({}, Kx, Zx), _J = /* @__PURE__ */ Object.assign({}, Jx, {
  timeZoneName: "short"
}), kJ = /* @__PURE__ */ Object.keys(Yx), CJ = /* @__PURE__ */ Object.keys(BO), IJ = /* @__PURE__ */ Object.keys(Kx), PJ = /* @__PURE__ */ Object.keys(Zx), Xx = ["dateStyle"], RJ = /* @__PURE__ */ kJ.concat(Xx), TJ = /* @__PURE__ */ CJ.concat(Xx), t5 = /* @__PURE__ */ IJ.concat(Xx, ["weekday"]), j0 = /* @__PURE__ */ PJ.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]), e5 = /* @__PURE__ */ t5.concat(j0), OJ = /* @__PURE__ */ B0.concat(j0), LJ = /* @__PURE__ */ B0.concat(t5), MJ = /* @__PURE__ */ B0.concat(["day", "weekday"], j0), NJ = /* @__PURE__ */ B0.concat(["year", "weekday"], j0), DJ = /* @__PURE__ */ Wu(e5, Jx), BJ = /* @__PURE__ */ Wu(e5, _J), jJ = /* @__PURE__ */ Wu(e5, Jx, B0), FJ = /* @__PURE__ */ Wu(t5, Kx, OJ), $J = /* @__PURE__ */ Wu(j0, Zx, LJ), zJ = /* @__PURE__ */ Wu(RJ, Yx, MJ), VJ = /* @__PURE__ */ Wu(TJ, BO, NJ), UJ = {}, jO = new vl(void 0, {
  calendar: nr
}).resolvedOptions().calendar === nr, FO = [DJ, tx], HJ = [BJ, tx, 0, (e, t) => {
  const r = e.timeZone;
  if (t && t.timeZone !== r)
    throw new RangeError(fO);
  return r;
}], $O = [jJ, qn], zO = [FJ, qn], VO = [$J, (e) => Tl(e) / Ea], UO = [zJ, qn, jO], HO = [VJ, qn, jO];
let D9;
function oc(e, t, r, n, i) {
  function s(...l) {
    if (!(this instanceof s))
      throw new TypeError(x3);
    F9(this, t(...l));
  }
  function o(l, c) {
    return Object.defineProperties(function(...h) {
      return l.call(this, a(this), ...h);
    }, If(c));
  }
  function a(l) {
    const c = ii(l);
    if (!c || c.branding !== e)
      throw new TypeError(x3);
    return c;
  }
  return Object.defineProperties(s.prototype, {
    ...gY(ha(o, r)),
    ...Jh(ha(o, n)),
    ...M6("Temporal." + e)
  }), Object.defineProperties(s, {
    ...Jh(i),
    ...If(e)
  }), [s, (l) => {
    const c = Object.create(s.prototype);
    return F9(c, l), c;
  }, a];
}
function Dp(e) {
  if (ii(e) || e.calendar !== void 0 || e.timeZone !== void 0)
    throw new TypeError(eZ);
  return e;
}
function F0(e) {
  return GO(e) || nr;
}
function GO(e) {
  const { calendar: t } = e;
  if (t !== void 0)
    return v2(t);
}
function v2(e) {
  if (ri(e)) {
    const { calendar: t } = ii(e) || {};
    if (!t)
      throw new TypeError(hO(e));
    return t;
  }
  return ((t) => p2(QY(Fn(t))))(e);
}
function r5(e) {
  const t = {};
  for (const r in e)
    t[r] = (n) => {
      const { calendar: i } = n;
      return Le(i)[r](n);
    };
  return t;
}
function ac() {
  throw new TypeError(rZ);
}
function Qi(e) {
  if (ri(e)) {
    const { timeZone: t } = ii(e) || {};
    if (!t)
      throw new TypeError(dO(e));
    return t;
  }
  return ((t) => vx(WY(Fn(t))))(e);
}
function Xr(e) {
  if (ri(e)) {
    const t = ii(e);
    return t && t.branding === Ux ? t : gK(e);
  }
  return GY(e);
}
function Dd(e) {
  if (e !== void 0) {
    if (ri(e)) {
      const t = ii(e) || {};
      switch (t.branding) {
        case sc:
        case D0:
          return t;
        case Np:
          return xa(t);
      }
      const r = F0(e);
      return {
        ...lK(Qi, Ve, Le(r), e),
        calendar: r
      };
    }
    return FY(e);
  }
}
function qa(e, t) {
  if (ri(e)) {
    const n = ii(e) || {};
    switch (n.branding) {
      case zx:
        return lr(t), n;
      case Np:
        return lr(t), Oo(n);
      case sc:
        return lr(t), sO(Ve, n);
    }
    return fK(e, t);
  }
  const r = HY(e);
  return lr(t), r;
}
function n5(e) {
  return e === void 0 ? void 0 : qa(e);
}
function hh(e, t) {
  if (ri(e)) {
    const n = ii(e) || {};
    switch (n.branding) {
      case Np:
        return lr(t), n;
      case D0:
        return lr(t), Ds({
          ...n,
          ...Ii
        });
      case sc:
        return lr(t), nO(Ve, n);
    }
    return uK(Le(F0(e)), e, t);
  }
  const r = zY(e);
  return lr(t), r;
}
function B9(e, t) {
  if (ri(e)) {
    const n = ii(e);
    if (n && n.branding === $x)
      return lr(t), n;
    const i = GO(e);
    return dK(Le(i || nr), !i, e, t);
  }
  const r = UY(Le, e);
  return lr(t), r;
}
function ph(e, t) {
  if (ri(e)) {
    const n = ii(e);
    return n && n.branding === Fx ? (lr(t), n) : pK(Le(F0(e)), e, t);
  }
  const r = VY(Le, e);
  return lr(t), r;
}
function dh(e, t) {
  if (ri(e)) {
    const n = ii(e) || {};
    switch (n.branding) {
      case D0:
        return lr(t), n;
      case Np:
        return lr(t), xa(n);
      case sc:
        return lr(t), iO(Ve, n);
    }
    return hK(Le(F0(e)), e, t);
  }
  const r = px(e);
  return lr(t), r;
}
function fh(e, t) {
  if (ri(e)) {
    const r = ii(e);
    if (r && r.branding === sc)
      return Zy(t), r;
    const n = F0(e);
    return cK(Qi, Ve, Le(n), n, e, t);
  }
  return $Y(e, t);
}
function j9(e) {
  return ha((t) => (r) => t(k3(r)), e);
}
function k3(e) {
  return Xi(e, Ve);
}
function gh(e) {
  if (ri(e)) {
    const t = ii(e);
    if (t)
      switch (t.branding) {
        case Vx:
          return t;
        case sc:
          return wa(t.epochNanoseconds);
      }
  }
  return jY(e);
}
function GJ() {
  function e(s, o) {
    return new t(s, o);
  }
  function t(s, o = /* @__PURE__ */ Object.create(null)) {
    _m.set(this, ((a, l) => {
      const c = new vl(a, l), h = c.resolvedOptions(), u = h.locale, p = Ms(Object.keys(l), h), y = Ki(qJ), g = (b, ...f) => {
        if (b) {
          if (f.length !== 2)
            throw new TypeError(yv);
          for (const m of f)
            if (m === void 0)
              throw new TypeError(yv);
        }
        b || f[0] !== void 0 || (f = []);
        const E = f.map((m) => ii(m) || Number(m));
        let A, x = 0;
        for (const m of E) {
          const w = typeof m == "object" ? m.branding : void 0;
          if (x++ && w !== A)
            throw new TypeError(yv);
          A = w;
        }
        return A ? y(A)(u, p, ...E) : [c, ...E];
      };
      return g.X = c, g;
    })(s, o));
  }
  const r = vl.prototype, n = Object.getOwnPropertyDescriptors(r), i = Object.getOwnPropertyDescriptors(vl);
  for (const s in n) {
    const o = n[s], a = s.startsWith("format") && QJ(s);
    typeof o.value == "function" ? o.value = s === "constructor" ? e : a || WJ(s) : a && (o.get = function() {
      if (!_m.has(this))
        throw new TypeError(x3);
      return (...l) => a.apply(this, l);
    }, Object.defineProperties(o.get, If(`get ${s}`)));
  }
  return i.prototype.value = t.prototype = Object.create({}, n), Object.defineProperties(e, i), e;
}
function QJ(e) {
  return Object.defineProperties(function(...t) {
    const r = _m.get(this), [n, ...i] = r(e.includes("Range"), ...t);
    return n[e](...i);
  }, If(e));
}
function WJ(e) {
  return Object.defineProperties(function(...t) {
    return _m.get(this).X[e](...t);
  }, If(e));
}
function qJ(e) {
  const t = tX[e];
  if (!t)
    throw new TypeError(wZ(e));
  return rc(t, Ki(oO), 1);
}
const Sm = /* @__PURE__ */ new WeakMap(), ii = /* @__PURE__ */ Sm.get.bind(Sm), F9 = /* @__PURE__ */ Sm.set.bind(Sm), QO = {
  era: mY,
  eraYear: JR,
  year: D6,
  month: Uo,
  daysInMonth: Uo,
  daysInYear: Uo,
  inLeapYear: kZ,
  monthsInYear: Uo
}, i5 = {
  monthCode: Fn
}, WO = {
  day: Uo
}, YJ = {
  dayOfWeek: Uo,
  dayOfYear: Uo,
  weekOfYear: yY,
  yearOfWeek: JR,
  daysInWeek: Uo
}, s5 = /* @__PURE__ */ r5(/* @__PURE__ */ Object.assign({}, QO, i5, WO, YJ)), KJ = /* @__PURE__ */ r5({
  ...QO,
  ...i5
}), ZJ = /* @__PURE__ */ r5({
  ...i5,
  ...WO
}), $0 = {
  calendarId: (e) => e.calendar
}, JJ = /* @__PURE__ */ Gy((e) => (t) => t[e], fr.concat("sign")), o5 = /* @__PURE__ */ Gy((e, t) => (r) => r[Bs[t]], Aa), qO = {
  epochMilliseconds: tx,
  epochNanoseconds: wY
}, [XJ, Ur, Yxt] = oc(Ux, RK, {
  ...JJ,
  blank: DY
}, {
  with: (e, t) => Ur(EK(e, t)),
  negated: (e) => Ur(hx(e)),
  abs: (e) => Ur(NY(e)),
  add: (e, t, r) => Ur(S9(Dd, Le, Ve, 0, e, Xr(t), r)),
  subtract: (e, t, r) => Ur(S9(Dd, Le, Ve, 1, e, Xr(t), r)),
  round: (e, t) => Ur(MY(Dd, Le, Ve, e, t)),
  total: (e, t) => xY(Dd, Le, Ve, e, t),
  toLocaleString(e, t, r) {
    return Intl.DurationFormat ? new Intl.DurationFormat(t, r).format(this) : pv(e);
  },
  toString: pv,
  toJSON: (e) => pv(e),
  valueOf: ac
}, {
  from: (e) => Ur(Xr(e)),
  compare: (e, t, r) => YY(Dd, Le, Ve, Xr(e), Xr(t), r)
}), tX = {
  Instant: FO,
  PlainDateTime: $O,
  PlainDate: zO,
  PlainTime: VO,
  PlainYearMonth: UO,
  PlainMonthDay: HO
}, eX = /* @__PURE__ */ rc(FO), rX = /* @__PURE__ */ rc(HJ), nX = /* @__PURE__ */ rc($O), iX = /* @__PURE__ */ rc(zO), sX = /* @__PURE__ */ rc(VO), oX = /* @__PURE__ */ rc(UO), aX = /* @__PURE__ */ rc(HO), [lX, al] = oc(zx, PK, o5, {
  with(e, t, r) {
    return al(xK(this, Dp(t), r));
  },
  add: (e, t) => al(A9(0, e, Xr(t))),
  subtract: (e, t) => al(A9(1, e, Xr(t))),
  until: (e, t, r) => Ur(O9(0, e, qa(t), r)),
  since: (e, t, r) => Ur(O9(1, e, qa(t), r)),
  round: (e, t) => al(_Y(e, t)),
  equals: (e, t) => rK(e, qa(t)),
  toLocaleString(e, t, r) {
    const [n, i] = sX(t, r, e);
    return n.format(i);
  },
  toString: m9,
  toJSON: (e) => m9(e),
  valueOf: ac
}, {
  from: (e, t) => al(qa(e, t)),
  compare: (e, t) => xx(qa(e), qa(t))
}), [cX, Xs] = oc(Np, Ze(_K, R0), {
  ...$0,
  ...s5,
  ...o5
}, {
  with: (e, t, r) => Xs(yK(Le, e, Dp(t), r)),
  withCalendar: (e, t) => Xs(kx(e, v2(t))),
  withPlainTime: (e, t) => Xs(HK(e, n5(t))),
  add: (e, t, r) => Xs(w9(Le, 0, e, Xr(t), r)),
  subtract: (e, t, r) => Xs(w9(Le, 1, e, Xr(t), r)),
  until: (e, t, r) => Ur(P9(Le, 0, e, hh(t), r)),
  since: (e, t, r) => Ur(P9(Le, 1, e, hh(t), r)),
  round: (e, t) => Xs(SY(e, t)),
  equals: (e, t) => JY(e, hh(t)),
  toZonedDateTime: (e, t, r) => Vn(LK(Ve, e, Qi(t), r)),
  toPlainDate: (e) => so(xa(e)),
  toPlainTime: (e) => al(Oo(e)),
  toLocaleString(e, t, r) {
    const [n, i] = nX(t, r, e);
    return n.format(i);
  },
  toString: p9,
  toJSON: (e) => p9(e),
  valueOf: ac
}, {
  from: (e, t) => Xs(hh(e, t)),
  compare: (e, t) => jT(hh(e), hh(t))
}), [uX, C3, Kxt] = oc($x, Ze(IK, R0), {
  ...$0,
  ...ZJ
}, {
  with: (e, t, r) => C3(wK(Le, e, Dp(t), r)),
  equals: (e, t) => eK(e, B9(t)),
  toPlainDate(e, t) {
    return so(FK(Le, e, this, t));
  },
  toLocaleString(e, t, r) {
    const [n, i] = aX(t, r, e);
    return n.format(i);
  },
  toString: g9,
  toJSON: (e) => g9(e),
  valueOf: ac
}, {
  from: (e, t) => C3(B9(e, t))
}), [hX, qd, Zxt] = oc(Fx, Ze(CK, R0), {
  ...$0,
  ...KJ
}, {
  with: (e, t, r) => qd(vK(Le, e, Dp(t), r)),
  add: (e, t, r) => qd(E9(Le, 0, e, Xr(t), r)),
  subtract: (e, t, r) => qd(E9(Le, 1, e, Xr(t), r)),
  until: (e, t, r) => Ur(T9(Le, 0, e, ph(t), r)),
  since: (e, t, r) => Ur(T9(Le, 1, e, ph(t), r)),
  equals: (e, t) => tK(e, ph(t)),
  toPlainDate(e, t) {
    return so(jK(Le, e, this, t));
  },
  toLocaleString(e, t, r) {
    const [n, i] = oX(t, r, e);
    return n.format(i);
  },
  toString: f9,
  toJSON: (e) => f9(e),
  valueOf: ac
}, {
  from: (e, t) => qd(ph(e, t)),
  compare: (e, t) => Op(ph(e), ph(t))
}), [pX, so, Jxt] = oc(D0, Ze(kK, R0), {
  ...$0,
  ...s5
}, {
  with: (e, t, r) => so(bK(Le, e, Dp(t), r)),
  withCalendar: (e, t) => so(kx(e, v2(t))),
  add: (e, t, r) => so(x9(Le, 0, e, Xr(t), r)),
  subtract: (e, t, r) => so(x9(Le, 1, e, Xr(t), r)),
  until: (e, t, r) => Ur(R9(Le, 0, e, dh(t), r)),
  since: (e, t, r) => Ur(R9(Le, 1, e, dh(t), r)),
  equals: (e, t) => XY(e, dh(t)),
  toZonedDateTime(e, t) {
    const r = ri(t) ? t : {
      timeZone: t
    };
    return Vn(MK(Qi, qa, Ve, e, r));
  },
  toPlainDateTime: (e, t) => Xs(NK(e, n5(t))),
  toPlainYearMonth(e) {
    return qd(DK(Le, e, this));
  },
  toPlainMonthDay(e) {
    return C3(BK(Le, e, this));
  },
  toLocaleString(e, t, r) {
    const [n, i] = iX(t, r, e);
    return n.format(i);
  },
  toString: d9,
  toJSON: (e) => d9(e),
  valueOf: ac
}, {
  from: (e, t) => so(dh(e, t)),
  compare: (e, t) => Op(dh(e), dh(t))
}), [dX, Vn] = oc(sc, Ze(SK, R0, qY), {
  ...qO,
  ...$0,
  ...j9(s5),
  ...j9(o5),
  offset: (e) => C0(k3(e).offsetNanoseconds),
  offsetNanoseconds: (e) => k3(e).offsetNanoseconds,
  timeZoneId: (e) => e.timeZone,
  hoursInDay: (e) => kY(Ve, e)
}, {
  with: (e, t, r) => Vn(mK(Le, Ve, e, Dp(t), r)),
  withCalendar: (e, t) => Vn(kx(e, v2(t))),
  withTimeZone: (e, t) => Vn(GK(e, Qi(t))),
  withPlainTime: (e, t) => Vn(UK(Ve, e, n5(t))),
  add: (e, t, r) => Vn(v9(Le, Ve, 0, e, Xr(t), r)),
  subtract: (e, t, r) => Vn(v9(Le, Ve, 1, e, Xr(t), r)),
  until: (e, t, r) => Ur(an(I9(Le, Ve, 0, e, fh(t), r))),
  since: (e, t, r) => Ur(an(I9(Le, Ve, 1, e, fh(t), r))),
  round: (e, t) => Vn(AY(Ve, e, t)),
  startOfDay: (e) => Vn(CY(Ve, e)),
  equals: (e, t) => ZY(e, fh(t)),
  toInstant: (e) => Ya(OK(e)),
  toPlainDateTime: (e) => Xs(nO(Ve, e)),
  toPlainDate: (e) => so(iO(Ve, e)),
  toPlainTime: (e) => al(sO(Ve, e)),
  toLocaleString(e, t, r = {}) {
    const [n, i] = rX(t, r, e);
    return n.format(i);
  },
  toString: (e, t) => h9(Ve, e, t),
  toJSON: (e) => h9(Ve, e),
  valueOf: ac,
  getTimeZoneTransition(e, t) {
    const { timeZone: r, epochNanoseconds: n } = e, i = vY(t), s = Ve(r).O(n, i);
    return s ? Vn({
      ...e,
      epochNanoseconds: s
    }) : null;
  }
}, {
  from: (e, t) => Vn(fh(e, t)),
  compare: (e, t) => BT(fh(e), fh(t))
}), [fX, Ya, Xxt] = oc(Vx, AK, qO, {
  add: (e, t) => Ya(b9(0, e, Xr(t))),
  subtract: (e, t) => Ya(b9(1, e, Xr(t))),
  until: (e, t, r) => Ur(C9(0, e, gh(t), r)),
  since: (e, t, r) => Ur(C9(1, e, gh(t), r)),
  round: (e, t) => Ya(EY(e, t)),
  equals: (e, t) => KY(e, gh(t)),
  toZonedDateTimeISO: (e, t) => Vn(TK(e, Qi(t))),
  toLocaleString(e, t, r) {
    const [n, i] = eX(t, r, e);
    return n.format(i);
  },
  toString: (e, t) => u9(Qi, Ve, e, t),
  toJSON: (e) => u9(Qi, Ve, e),
  valueOf: ac
}, {
  from: (e) => Ya(gh(e)),
  fromEpochMilliseconds: (e) => Ya($K(e)),
  fromEpochNanoseconds: (e) => Ya(zK(e)),
  compare: (e, t) => DT(gh(e), gh(t))
}), gX = /* @__PURE__ */ Object.defineProperties({}, {
  ...M6("Temporal.Now"),
  ...Jh({
    timeZoneId: () => Md(),
    instant: () => Ya(wa(w3())),
    zonedDateTimeISO: (e = Md()) => Vn(Ns(w3(), Qi(e), nr)),
    plainDateTimeISO: (e = Md()) => Xs(Ds(mv(Ve(Qi(e))), nr)),
    plainDateISO: (e = Md()) => so(xa(mv(Ve(Qi(e))), nr)),
    plainTimeISO: (e = Md()) => al(Oo(mv(Ve(Qi(e)))))
  })
}), I3 = /* @__PURE__ */ Object.defineProperties({}, {
  ...M6("Temporal"),
  ...Jh({
    PlainYearMonth: hX,
    PlainMonthDay: uX,
    PlainDate: pX,
    PlainTime: lX,
    PlainDateTime: cX,
    ZonedDateTime: dX,
    Instant: fX,
    Duration: XJ,
    Now: gX
  })
}), mX = /* @__PURE__ */ GJ(), _m = /* @__PURE__ */ new WeakMap();
Jh({
  DateTimeFormat: mX
});
let $9 = class extends Error {
  constructor(t) {
    super(`[ParaModel]: ${t}`);
  }
};
function Nn(e) {
  const t = [];
  let r = 0;
  for (const n of e)
    t.push([n, r]), r++;
  return t;
}
function YO(e, t, r) {
  if (t.length !== r.length)
    return !1;
  for (const [n, i] of dY(t, r))
    if (!e(n, i))
      return !1;
  return !0;
}
function uf(e) {
  return I3.Instant.fromEpochMilliseconds(e).toZonedDateTimeISO("UTC").toPlainDateTime();
}
let P3 = class {
  constructor(t) {
    this.points = [t];
  }
  add(t) {
    this.points.push(t);
  }
};
function yX(e, t) {
  if (e.length <= 1)
    return e;
  const r = [];
  t(e[0], e[1]) ? r.push(new P3(e[0])) : r.push(e[0]);
  for (let n = 1; n < e.length - 1; n++)
    t(e[n - 1], e[n]) ? r.at(-1).add(e[n]) : t(e[n], e[n + 1]) ? r.push(new P3(e[n])) : r.push(e[n]);
  return t(e.at(-2), e.at(-1)) ? r.at(-1).add(e.at(-1)) : r.push(e.at(-1)), r;
}
function R3(e) {
  return e === "number" || e === "date";
}
let a5 = class {
  constructor(t) {
    this.raw = t, this.value = this.convertRaw(t);
  }
};
class bX extends a5 {
  convertRaw(t) {
    const r = parseFloat(t);
    if (isNaN(r))
      throw new Error("x values in Numeric Datapoints must be numbers");
    return r;
  }
  isNumber() {
    return !0;
  }
  isString() {
    return !1;
  }
  isDate() {
    return !1;
  }
  isEqual(t) {
    return this.value === t.value;
  }
  isNumberLike() {
    return !0;
  }
  asNumber() {
    return this.value;
  }
  datatype() {
    return "number";
  }
}
class vX extends a5 {
  convertRaw(t) {
    return t;
  }
  isNumber() {
    return !1;
  }
  isString() {
    return !0;
  }
  isDate() {
    return !1;
  }
  isEqual(t) {
    return this.value === t.value;
  }
  isNumberLike() {
    return !1;
  }
  asNumber() {
    return null;
  }
  datatype() {
    return "string";
  }
}
const wX = ["01", "04", "07", "10"];
function xX(e) {
  let t = parseFloat(e), r = 0;
  return e[0] === "Q" && (r = parseInt(e[1]) - 1, e[3] === "'" ? t = parseInt(e.substring(4)) + 2e3 : t = parseInt(e.substring(3))), Number.isNaN(t) || Number.isNaN(r) ? null : `${t}${wX[r]}01`;
}
class EX extends a5 {
  convertRaw(t) {
    const r = xX(t);
    if (r === null)
      throw new $9(`Raw date string "${t}" could not be parsed.`);
    try {
      return I3.PlainDateTime.from(r);
    } catch (n) {
      throw new $9(`RFC9557 date string "${r}" could not be parsed. Parsing error: ${n}`);
    }
  }
  isNumber() {
    return !1;
  }
  isString() {
    return !1;
  }
  isDate() {
    return !0;
  }
  isEqual(t) {
    return I3.PlainDateTime.compare(this.value, t.value) === 0;
  }
  isNumberLike() {
    return !0;
  }
  // Temporal requires PlaneDateTimes be converted to ZonedDateTimes to get their milliseconds since
  //   the epoch (1/1/1970). We convert PlaneDateTimes to an arbitrary time zone here (UTC, i.e. 
  //   Greenwich mean time) as we are only concerned with the relative differences between PlaneDateTimes
  asNumber() {
    return this.value.toZonedDateTime("UTC").epochMilliseconds;
  }
  datatype() {
    return "date";
  }
}
const AX = {
  string: vX,
  number: bX,
  date: EX
};
let KO = class {
  constructor() {
    this.boxes = [];
  }
  get values() {
    return this.boxes;
  }
  has(t) {
    return this.boxes.some((r) => t.isEqual(r));
  }
  add(t) {
    this.has(t) || this.boxes.push(t);
  }
  merge(t) {
    t.forEach((r) => this.add(r));
  }
};
function SX(e) {
  if (e.length === 0)
    return 0;
  var t = e[0], r = 0, n;
  if (typeof t != "number")
    return Number.NaN;
  for (var i = 1; i < e.length; i++) {
    if (typeof e[i] != "number")
      return Number.NaN;
    n = t + e[i], Math.abs(t) >= Math.abs(e[i]) ? r += t - n + e[i] : r += e[i] - n + t, t = n;
  }
  return t + r;
}
function wo(e) {
  if (e.length === 0)
    throw new Error("mean requires at least one data point");
  return SX(e) / e.length;
}
function _X(e, t) {
  var r = wo(e), n = 0, i, s;
  for (s = 0; s < e.length; s++)
    i = e[s] - r, n += i * i;
  return n;
}
function kX(e) {
  if (e.length === 0)
    throw new Error("mode requires at least one data point");
  if (e.length === 1)
    return e[0];
  for (var t = e[0], r = Number.NaN, n = 0, i = 1, s = 1; s < e.length + 1; s++)
    e[s] !== t ? (i > n && (n = i, r = t), i = 1, t = e[s]) : i++;
  return r;
}
function CX(e) {
  return e.slice().sort(function(t, r) {
    return t - r;
  });
}
function IX(e) {
  return kX(CX(e));
}
function z9(e, t) {
  var r = e.length * t;
  if (e.length === 0)
    throw new Error("quantile requires at least one data point.");
  if (t < 0 || t > 1)
    throw new Error("quantiles must be between 0 and 1");
  return t === 1 ? e[e.length - 1] : t === 0 ? e[0] : r % 1 !== 0 ? e[Math.ceil(r) - 1] : e.length % 2 === 0 ? (e[r - 1] + e[r]) / 2 : e[r];
}
function P1(e, t, r, n) {
  for (r = r || 0, n = n || e.length - 1; n > r; ) {
    if (n - r > 600) {
      var i = n - r + 1, s = t - r + 1, o = Math.log(i), a = 0.5 * Math.exp(2 * o / 3), l = 0.5 * Math.sqrt(o * a * (i - a) / i);
      s - i / 2 < 0 && (l *= -1);
      var c = Math.max(r, Math.floor(t - s * a / i + l)), h = Math.min(
        n,
        Math.floor(t + (i - s) * a / i + l)
      );
      P1(e, t, c, h);
    }
    var u = e[t], p = r, y = n;
    for (Bd(e, r, t), e[n] > u && Bd(e, r, n); p < y; ) {
      for (Bd(e, p, y), p++, y--; e[p] < u; )
        p++;
      for (; e[y] > u; )
        y--;
    }
    e[r] === u ? Bd(e, r, y) : (y++, Bd(e, y, n)), y <= t && (r = y + 1), t <= y && (n = y - 1);
  }
}
function Bd(e, t, r) {
  var n = e[t];
  e[t] = e[r], e[r] = n;
}
function PX(e, t) {
  var r = e.slice();
  if (Array.isArray(t)) {
    RX(r, t);
    for (var n = [], i = 0; i < t.length; i++)
      n[i] = z9(r, t[i]);
    return n;
  } else {
    var s = JO(r.length, t);
    return ZO(r, s, 0, r.length - 1), z9(r, t);
  }
}
function ZO(e, t, r, n) {
  t % 1 === 0 ? P1(e, t, r, n) : (t = Math.floor(t), P1(e, t, r, n), P1(e, t + 1, t + 1, n));
}
function RX(e, t) {
  for (var r = [0], n = 0; n < t.length; n++)
    r.push(JO(e.length, t[n]));
  r.push(e.length - 1), r.sort(TX);
  for (var i = [0, r.length - 1]; i.length; ) {
    var s = Math.ceil(i.pop()), o = Math.floor(i.pop());
    if (!(s - o <= 1)) {
      var a = Math.floor((o + s) / 2);
      ZO(
        e,
        r[a],
        Math.floor(r[o]),
        Math.ceil(r[s])
      ), i.push(o, a, a, s);
    }
  }
}
function TX(e, t) {
  return e - t;
}
function JO(e, t) {
  var r = e * t;
  return t === 1 ? e - 1 : t === 0 ? 0 : r % 1 !== 0 ? Math.ceil(r) - 1 : e % 2 === 0 ? r - 0.5 : r;
}
function OX(e) {
  return +PX(e, 0.5);
}
function LX(e, t) {
  if (e.length !== t.length)
    throw new Error("sampleCovariance requires samples with equal lengths");
  if (e.length < 2)
    throw new Error(
      "sampleCovariance requires at least two data points in each sample"
    );
  for (var r = wo(e), n = wo(t), i = 0, s = 0; s < e.length; s++)
    i += (e[s] - r) * (t[s] - n);
  var o = e.length - 1;
  return i / o;
}
function MX(e) {
  if (e.length < 2)
    throw new Error("sampleVariance requires at least two data points");
  var t = _X(e), r = e.length - 1;
  return t / r;
}
function T3(e) {
  var t = MX(e);
  return Math.sqrt(t);
}
function NX(e, t) {
  var r = LX(e, t), n = T3(e), i = T3(t);
  return r / n / i;
}
var O3 = 9e15, lc = 1e9, L3 = "0123456789abcdef", km = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", Cm = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", M3 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -9e15,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: O3,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, XO, Ho, Pe = !0, w2 = "[DecimalError] ", wu = w2 + "Invalid argument: ", tL = w2 + "Precision limit exceeded", eL = w2 + "crypto unavailable", Sn = Math.floor, fn = Math.pow, DX = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, BX = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, jX = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, FX = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Es = 1e7, ye = 7, $X = 9007199254740991, zX = km.length - 1, N3 = Cm.length - 1, Ft = { name: "[object Decimal]" };
Ft.absoluteValue = Ft.abs = function() {
  var e = new this.constructor(this);
  return e.s < 0 && (e.s = 1), he(e);
};
Ft.ceil = function() {
  return he(new this.constructor(this), this.e + 1, 2);
};
Ft.comparedTo = Ft.cmp = function(e) {
  var t, r, n, i, s = this, o = s.d, a = (e = new s.constructor(e)).d, l = s.s, c = e.s;
  if (!o || !a)
    return !l || !c ? NaN : l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? l : a[0] ? -c : 0;
  if (l !== c) return l;
  if (s.e !== e.e) return s.e > e.e ^ l < 0 ? 1 : -1;
  for (n = o.length, i = a.length, t = 0, r = n < i ? n : i; t < r; ++t)
    if (o[t] !== a[t]) return o[t] > a[t] ^ l < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
};
Ft.cosine = Ft.cos = function() {
  var e, t, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + ye, n.rounding = 1, r = VX(n, oL(n, r)), n.precision = e, n.rounding = t, he(Ho == 2 || Ho == 3 ? r.neg() : r, e, t, !0)) : new n(1) : new n(NaN);
};
Ft.cubeRoot = Ft.cbrt = function() {
  var e, t, r, n, i, s, o, a, l, c, h = this, u = h.constructor;
  if (!h.isFinite() || h.isZero()) return new u(h);
  for (Pe = !1, s = h.s * Math.pow(h.s * h, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = rn(h.d), e = h.e, (s = (e - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Math.pow(r, 1 / 3), e = Sn((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + e : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new u(r), n.s = h.s) : n = new u(s.toString()), o = (e = u.precision) + 3; ; )
    if (a = n, l = a.times(a).times(a), c = l.plus(h), n = tr(c.plus(h).times(a), c.plus(l), o + 2, 1), rn(a.d).slice(0, o) === (r = rn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (he(a, e + 1, 0), a.times(a).times(a).eq(h))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (he(n, e + 1, 1), t = !n.times(n).times(n).eq(h));
        break;
      }
  return Pe = !0, he(n, e, u.rounding, t);
};
Ft.decimalPlaces = Ft.dp = function() {
  var e, t = this.d, r = NaN;
  if (t) {
    if (e = t.length - 1, r = (e - Sn(this.e / ye)) * ye, e = t[e], e) for (; e % 10 == 0; e /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
Ft.dividedBy = Ft.div = function(e) {
  return tr(this, new this.constructor(e));
};
Ft.dividedToIntegerBy = Ft.divToInt = function(e) {
  var t = this, r = t.constructor;
  return he(tr(t, new r(e), 0, 1, 1), r.precision, r.rounding);
};
Ft.equals = Ft.eq = function(e) {
  return this.cmp(e) === 0;
};
Ft.floor = function() {
  return he(new this.constructor(this), this.e + 1, 3);
};
Ft.greaterThan = Ft.gt = function(e) {
  return this.cmp(e) > 0;
};
Ft.greaterThanOrEqualTo = Ft.gte = function(e) {
  var t = this.cmp(e);
  return t == 1 || t === 0;
};
Ft.hyperbolicCosine = Ft.cosh = function() {
  var e, t, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (e = Math.ceil(i / 3), t = Math.pow(4, -e).toString()) : (e = 16, t = "2.3283064365386962890625e-10"), s = rp(o, 1, s.times(t), new o(1), !0);
  for (var l, c = e, h = new o(8); c--; )
    l = s.times(s), s = a.minus(l.times(h.minus(l.times(h))));
  return he(s, o.precision = r, o.rounding = n, !0);
};
Ft.hyperbolicSine = Ft.sinh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero()) return new s(i);
  if (t = s.precision, r = s.rounding, s.precision = t + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = rp(s, 2, i, i, !0);
  else {
    e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(Math.pow(5, -e)), i = rp(s, 2, i, i, !0);
    for (var o, a = new s(5), l = new s(16), c = new s(20); e--; )
      o = i.times(i), i = i.times(a.plus(o.times(l.times(o).plus(c))));
  }
  return s.precision = t, s.rounding = r, he(i, t, r, !0);
};
Ft.hyperbolicTangent = Ft.tanh = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, tr(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s);
};
Ft.inverseCosine = Ft.acos = function() {
  var e, t = this, r = t.constructor, n = t.abs().cmp(1), i = r.precision, s = r.rounding;
  return n !== -1 ? n === 0 ? t.isNeg() ? ms(r, i, s) : new r(0) : new r(NaN) : t.isZero() ? ms(r, i + 4, s).times(0.5) : (r.precision = i + 6, r.rounding = 1, t = t.asin(), e = ms(r, i + 4, s).times(0.5), r.precision = i, r.rounding = s, e.minus(t));
};
Ft.inverseHyperbolicCosine = Ft.acosh = function() {
  var e, t, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, Pe = !1, r = r.times(r).minus(1).sqrt().plus(r), Pe = !0, n.precision = e, n.rounding = t, r.ln()) : new n(r);
};
Ft.inverseHyperbolicSine = Ft.asinh = function() {
  var e, t, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, Pe = !1, r = r.times(r).plus(1).sqrt().plus(r), Pe = !0, n.precision = e, n.rounding = t, r.ln());
};
Ft.inverseHyperbolicTangent = Ft.atanh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = s.precision, t = s.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? he(new s(i), e, t, !0) : (s.precision = r = n - i.e, i = tr(i.plus(1), new s(1).minus(i), r + e, 1), s.precision = e + 4, s.rounding = 1, i = i.ln(), s.precision = e, s.rounding = t, i.times(0.5))) : new s(NaN);
};
Ft.inverseSine = Ft.asin = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (t = i.abs().cmp(1), r = s.precision, n = s.rounding, t !== -1 ? t === 0 ? (e = ms(s, r + 4, n).times(0.5), e.s = i.s, e) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
Ft.inverseTangent = Ft.atan = function() {
  var e, t, r, n, i, s, o, a, l, c = this, h = c.constructor, u = h.precision, p = h.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new h(c);
    if (c.abs().eq(1) && u + 4 <= N3)
      return o = ms(h, u + 4, p).times(0.25), o.s = c.s, o;
  } else {
    if (!c.s) return new h(NaN);
    if (u + 4 <= N3)
      return o = ms(h, u + 4, p).times(0.5), o.s = c.s, o;
  }
  for (h.precision = a = u + 10, h.rounding = 1, r = Math.min(28, a / ye + 2 | 0), e = r; e; --e) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (Pe = !1, t = Math.ceil(a / ye), n = 1, l = c.times(c), o = new h(c), i = c; e !== -1; )
    if (i = i.times(l), s = o.minus(i.div(n += 2)), i = i.times(l), o = s.plus(i.div(n += 2)), o.d[t] !== void 0) for (e = t; o.d[e] === s.d[e] && e--; ) ;
  return r && (o = o.times(2 << r - 1)), Pe = !0, he(o, h.precision = u, h.rounding = p, !0);
};
Ft.isFinite = function() {
  return !!this.d;
};
Ft.isInteger = Ft.isInt = function() {
  return !!this.d && Sn(this.e / ye) > this.d.length - 2;
};
Ft.isNaN = function() {
  return !this.s;
};
Ft.isNegative = Ft.isNeg = function() {
  return this.s < 0;
};
Ft.isPositive = Ft.isPos = function() {
  return this.s > 0;
};
Ft.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
Ft.lessThan = Ft.lt = function(e) {
  return this.cmp(e) < 0;
};
Ft.lessThanOrEqualTo = Ft.lte = function(e) {
  return this.cmp(e) < 1;
};
Ft.logarithm = Ft.log = function(e) {
  var t, r, n, i, s, o, a, l, c = this, h = c.constructor, u = h.precision, p = h.rounding, y = 5;
  if (e == null)
    e = new h(10), t = !0;
  else {
    if (e = new h(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1)) return new h(NaN);
    t = e.eq(10);
  }
  if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1))
    return new h(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (t)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      s = i !== 1;
    }
  if (Pe = !1, a = u + y, o = pl(c, a), n = t ? Im(h, a + 10) : pl(e, a), l = tr(o, n, a, 1), Df(l.d, i = u, p))
    do
      if (a += 10, o = pl(c, a), n = t ? Im(h, a + 10) : pl(e, a), l = tr(o, n, a, 1), !s) {
        +rn(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = he(l, u + 1, 0));
        break;
      }
    while (Df(l.d, i += 10, p));
  return Pe = !0, he(l, u, p);
};
Ft.minus = Ft.sub = function(e) {
  var t, r, n, i, s, o, a, l, c, h, u, p, y = this, g = y.constructor;
  if (e = new g(e), !y.d || !e.d)
    return !y.s || !e.s ? e = new g(NaN) : y.d ? e.s = -e.s : e = new g(e.d || y.s !== e.s ? y : NaN), e;
  if (y.s != e.s)
    return e.s = -e.s, y.plus(e);
  if (c = y.d, p = e.d, a = g.precision, l = g.rounding, !c[0] || !p[0]) {
    if (p[0]) e.s = -e.s;
    else if (c[0]) e = new g(y);
    else return new g(l === 3 ? -0 : 0);
    return Pe ? he(e, a, l) : e;
  }
  if (r = Sn(e.e / ye), h = Sn(y.e / ye), c = c.slice(), s = h - r, s) {
    for (u = s < 0, u ? (t = c, s = -s, o = p.length) : (t = p, r = h, o = c.length), n = Math.max(Math.ceil(a / ye), o) + 2, s > n && (s = n, t.length = 1), t.reverse(), n = s; n--; ) t.push(0);
    t.reverse();
  } else {
    for (n = c.length, o = p.length, u = n < o, u && (o = n), n = 0; n < o; n++)
      if (c[n] != p[n]) {
        u = c[n] < p[n];
        break;
      }
    s = 0;
  }
  for (u && (t = c, c = p, p = t, e.s = -e.s), o = c.length, n = p.length - o; n > 0; --n) c[o++] = 0;
  for (n = p.length; n > s; ) {
    if (c[--n] < p[n]) {
      for (i = n; i && c[--i] === 0; ) c[i] = Es - 1;
      --c[i], c[n] += Es;
    }
    c[n] -= p[n];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --r;
  return c[0] ? (e.d = c, e.e = x2(c, r), Pe ? he(e, a, l) : e) : new g(l === 3 ? -0 : 0);
};
Ft.modulo = Ft.mod = function(e) {
  var t, r = this, n = r.constructor;
  return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? he(new n(r), n.precision, n.rounding) : (Pe = !1, n.modulo == 9 ? (t = tr(r, e.abs(), 0, 3, 1), t.s *= e.s) : t = tr(r, e, 0, n.modulo, 1), t = t.times(e), Pe = !0, r.minus(t));
};
Ft.naturalExponential = Ft.exp = function() {
  return D3(this);
};
Ft.naturalLogarithm = Ft.ln = function() {
  return pl(this);
};
Ft.negated = Ft.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s, he(e);
};
Ft.plus = Ft.add = function(e) {
  var t, r, n, i, s, o, a, l, c, h, u = this, p = u.constructor;
  if (e = new p(e), !u.d || !e.d)
    return !u.s || !e.s ? e = new p(NaN) : u.d || (e = new p(e.d || u.s === e.s ? u : NaN)), e;
  if (u.s != e.s)
    return e.s = -e.s, u.minus(e);
  if (c = u.d, h = e.d, a = p.precision, l = p.rounding, !c[0] || !h[0])
    return h[0] || (e = new p(u)), Pe ? he(e, a, l) : e;
  if (s = Sn(u.e / ye), n = Sn(e.e / ye), c = c.slice(), i = s - n, i) {
    for (i < 0 ? (r = c, i = -i, o = h.length) : (r = h, n = s, o = c.length), s = Math.ceil(a / ye), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = c.length, i = h.length, o - i < 0 && (i = o, r = h, h = c, c = r), t = 0; i; )
    t = (c[--i] = c[i] + h[i] + t) / Es | 0, c[i] %= Es;
  for (t && (c.unshift(t), ++n), o = c.length; c[--o] == 0; ) c.pop();
  return e.d = c, e.e = x2(c, n), Pe ? he(e, a, l) : e;
};
Ft.precision = Ft.sd = function(e) {
  var t, r = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(wu + e);
  return r.d ? (t = rL(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
};
Ft.round = function() {
  var e = this, t = e.constructor;
  return he(new t(e), e.e + 1, t.rounding);
};
Ft.sine = Ft.sin = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + ye, n.rounding = 1, r = HX(n, oL(n, r)), n.precision = e, n.rounding = t, he(Ho > 2 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
Ft.squareRoot = Ft.sqrt = function() {
  var e, t, r, n, i, s, o = this, a = o.d, l = o.e, c = o.s, h = o.constructor;
  if (c !== 1 || !a || !a[0])
    return new h(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (Pe = !1, c = Math.sqrt(+o), c == 0 || c == 1 / 0 ? (t = rn(a), (t.length + l) % 2 == 0 && (t += "0"), c = Math.sqrt(t), l = Sn((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? t = "1e" + l : (t = c.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + l), n = new h(t)) : n = new h(c.toString()), r = (l = h.precision) + 3; ; )
    if (s = n, n = s.plus(tr(o, s, r + 2, 1)).times(0.5), rn(s.d).slice(0, r) === (t = rn(n.d)).slice(0, r))
      if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
        if (!i && (he(s, l + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+t || !+t.slice(1) && t.charAt(0) == "5") && (he(n, l + 1, 1), e = !n.times(n).eq(o));
        break;
      }
  return Pe = !0, he(n, l, h.rounding, e);
};
Ft.tangent = Ft.tan = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = tr(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, he(Ho == 2 || Ho == 4 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
Ft.times = Ft.mul = function(e) {
  var t, r, n, i, s, o, a, l, c, h = this, u = h.constructor, p = h.d, y = (e = new u(e)).d;
  if (e.s *= h.s, !p || !p[0] || !y || !y[0])
    return new u(!e.s || p && !p[0] && !y || y && !y[0] && !p ? NaN : !p || !y ? e.s / 0 : e.s * 0);
  for (r = Sn(h.e / ye) + Sn(e.e / ye), l = p.length, c = y.length, l < c && (s = p, p = y, y = s, o = l, l = c, c = o), s = [], o = l + c, n = o; n--; ) s.push(0);
  for (n = c; --n >= 0; ) {
    for (t = 0, i = l + n; i > n; )
      a = s[i] + y[n] * p[i - n - 1] + t, s[i--] = a % Es | 0, t = a / Es | 0;
    s[i] = (s[i] + t) % Es | 0;
  }
  for (; !s[--o]; ) s.pop();
  return t ? ++r : s.shift(), e.d = s, e.e = x2(s, r), Pe ? he(e, u.precision, u.rounding) : e;
};
Ft.toBinary = function(e, t) {
  return l5(this, 2, e, t);
};
Ft.toDecimalPlaces = Ft.toDP = function(e, t) {
  var r = this, n = r.constructor;
  return r = new n(r), e === void 0 ? r : (Yn(e, 0, lc), t === void 0 ? t = n.rounding : Yn(t, 0, 8), he(r, e + r.e + 1, t));
};
Ft.toExponential = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = xo(n, !0) : (Yn(e, 0, lc), t === void 0 ? t = i.rounding : Yn(t, 0, 8), n = he(new i(n), e + 1, t), r = xo(n, !0, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ft.toFixed = function(e, t) {
  var r, n, i = this, s = i.constructor;
  return e === void 0 ? r = xo(i) : (Yn(e, 0, lc), t === void 0 ? t = s.rounding : Yn(t, 0, 8), n = he(new s(i), e + i.e + 1, t), r = xo(n, !1, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
Ft.toFraction = function(e) {
  var t, r, n, i, s, o, a, l, c, h, u, p, y = this, g = y.d, b = y.constructor;
  if (!g) return new b(y);
  if (c = r = new b(1), n = l = new b(0), t = new b(n), s = t.e = rL(g) - y.e - 1, o = s % ye, t.d[0] = fn(10, o < 0 ? ye + o : o), e == null)
    e = s > 0 ? t : c;
  else {
    if (a = new b(e), !a.isInt() || a.lt(c)) throw Error(wu + a);
    e = a.gt(t) ? s > 0 ? t : c : a;
  }
  for (Pe = !1, a = new b(rn(g)), h = b.precision, b.precision = s = g.length * ye * 2; u = tr(a, t, 0, 1, 1), i = r.plus(u.times(n)), i.cmp(e) != 1; )
    r = n, n = i, i = c, c = l.plus(u.times(i)), l = i, i = t, t = a.minus(u.times(i)), a = i;
  return i = tr(e.minus(r), n, 0, 1, 1), l = l.plus(i.times(c)), r = r.plus(i.times(n)), l.s = c.s = y.s, p = tr(c, n, s, 1).minus(y).abs().cmp(tr(l, r, s, 1).minus(y).abs()) < 1 ? [c, n] : [l, r], b.precision = h, Pe = !0, p;
};
Ft.toHexadecimal = Ft.toHex = function(e, t) {
  return l5(this, 16, e, t);
};
Ft.toNearest = function(e, t) {
  var r = this, n = r.constructor;
  if (r = new n(r), e == null) {
    if (!r.d) return r;
    e = new n(1), t = n.rounding;
  } else {
    if (e = new n(e), t === void 0 ? t = n.rounding : Yn(t, 0, 8), !r.d) return e.s ? r : e;
    if (!e.d)
      return e.s && (e.s = r.s), e;
  }
  return e.d[0] ? (Pe = !1, r = tr(r, e, 0, t, 1).times(e), Pe = !0, he(r)) : (e.s = r.s, r = e), r;
};
Ft.toNumber = function() {
  return +this;
};
Ft.toOctal = function(e, t) {
  return l5(this, 8, e, t);
};
Ft.toPower = Ft.pow = function(e) {
  var t, r, n, i, s, o, a = this, l = a.constructor, c = +(e = new l(e));
  if (!a.d || !e.d || !a.d[0] || !e.d[0]) return new l(fn(+a, c));
  if (a = new l(a), a.eq(1)) return a;
  if (n = l.precision, s = l.rounding, e.eq(1)) return he(a, n, s);
  if (t = Sn(e.e / ye), t >= e.d.length - 1 && (r = c < 0 ? -c : c) <= $X)
    return i = nL(l, a, r, n), e.s < 0 ? new l(1).div(i) : he(i, n, s);
  if (o = a.s, o < 0) {
    if (t < e.d.length - 1) return new l(NaN);
    if (!(e.d[t] & 1) && (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = fn(+a, c), t = r == 0 || !isFinite(r) ? Sn(c * (Math.log("0." + rn(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, t > l.maxE + 1 || t < l.minE - 1 ? new l(t > 0 ? o / 0 : 0) : (Pe = !1, l.rounding = a.s = 1, r = Math.min(12, (t + "").length), i = D3(e.times(pl(a, n + r)), n), i.d && (i = he(i, n + 5, 1), Df(i.d, n, s) && (t = n + 10, i = he(D3(e.times(pl(a, t + r)), t), t + 5, 1), +rn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = he(i, n + 1, 0)))), i.s = o, Pe = !0, l.rounding = s, he(i, n, s));
};
Ft.toPrecision = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = xo(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (Yn(e, 1, lc), t === void 0 ? t = i.rounding : Yn(t, 0, 8), n = he(new i(n), e, t), r = xo(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ft.toSignificantDigits = Ft.toSD = function(e, t) {
  var r = this, n = r.constructor;
  return e === void 0 ? (e = n.precision, t = n.rounding) : (Yn(e, 1, lc), t === void 0 ? t = n.rounding : Yn(t, 0, 8)), he(new n(r), e, t);
};
Ft.toString = function() {
  var e = this, t = e.constructor, r = xo(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() && !e.isZero() ? "-" + r : r;
};
Ft.truncated = Ft.trunc = function() {
  return he(new this.constructor(this), this.e + 1, 1);
};
Ft.valueOf = Ft.toJSON = function() {
  var e = this, t = e.constructor, r = xo(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() ? "-" + r : r;
};
function rn(e) {
  var t, r, n, i = e.length - 1, s = "", o = e[0];
  if (i > 0) {
    for (s += o, t = 1; t < i; t++)
      n = e[t] + "", r = ye - n.length, r && (s += Ka(r)), s += n;
    o = e[t], n = o + "", r = ye - n.length, r && (s += Ka(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function Yn(e, t, r) {
  if (e !== ~~e || e < t || e > r)
    throw Error(wu + e);
}
function Df(e, t, r, n) {
  var i, s, o, a;
  for (s = e[0]; s >= 10; s /= 10) --t;
  return --t < 0 ? (t += ye, i = 0) : (i = Math.ceil((t + 1) / ye), t %= ye), s = fn(10, ye - t), a = e[i] % s | 0, n == null ? t < 3 ? (t == 0 ? a = a / 100 | 0 : t == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 100 | 0) == fn(10, t - 2) - 1 || (a == s / 2 || a == 0) && (e[i + 1] / s / 100 | 0) == 0 : t < 4 ? (t == 0 ? a = a / 1e3 | 0 : t == 1 ? a = a / 100 | 0 : t == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 1e3 | 0) == fn(10, t - 3) - 1, o;
}
function R1(e, t, r) {
  for (var n, i = [0], s, o = 0, a = e.length; o < a; ) {
    for (s = i.length; s--; ) i[s] *= t;
    for (i[0] += L3.indexOf(e.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function VX(e, t) {
  var r, n, i = t.d.length;
  i < 32 ? (r = Math.ceil(i / 3), n = Math.pow(4, -r).toString()) : (r = 16, n = "2.3283064365386962890625e-10"), e.precision += r, t = rp(e, 1, t.times(n), new e(1));
  for (var s = r; s--; ) {
    var o = t.times(t);
    t = o.times(o).minus(o).times(8).plus(1);
  }
  return e.precision -= r, t;
}
var tr = /* @__PURE__ */ function() {
  function e(n, i, s) {
    var o, a = 0, l = n.length;
    for (n = n.slice(); l--; )
      o = n[l] * i + a, n[l] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function t(n, i, s, o) {
    var a, l;
    if (s != o)
      l = s > o ? 1 : -1;
    else
      for (a = l = 0; a < s; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, o, a, l) {
    var c, h, u, p, y, g, b, f, E, A, x, m, w, _, S, R, O, $, z, F, Y = n.constructor, rt = n.s == i.s ? 1 : -1, at = n.d, pt = i.d;
    if (!at || !at[0] || !pt || !pt[0])
      return new Y(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (at ? pt && at[0] == pt[0] : !pt) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          at && at[0] == 0 || !pt ? rt * 0 : rt / 0
        )
      );
    for (l ? (y = 1, h = n.e - i.e) : (l = Es, y = ye, h = Sn(n.e / y) - Sn(i.e / y)), z = pt.length, O = at.length, E = new Y(rt), A = E.d = [], u = 0; pt[u] == (at[u] || 0); u++) ;
    if (pt[u] > (at[u] || 0) && h--, s == null ? (_ = s = Y.precision, o = Y.rounding) : a ? _ = s + (n.e - i.e) + 1 : _ = s, _ < 0)
      A.push(1), g = !0;
    else {
      if (_ = _ / y + 2 | 0, u = 0, z == 1) {
        for (p = 0, pt = pt[0], _++; (u < O || p) && _--; u++)
          S = p * l + (at[u] || 0), A[u] = S / pt | 0, p = S % pt | 0;
        g = p || u < O;
      } else {
        for (p = l / (pt[0] + 1) | 0, p > 1 && (pt = e(pt, p, l), at = e(at, p, l), z = pt.length, O = at.length), R = z, x = at.slice(0, z), m = x.length; m < z; ) x[m++] = 0;
        F = pt.slice(), F.unshift(0), $ = pt[0], pt[1] >= l / 2 && ++$;
        do
          p = 0, c = t(pt, x, z, m), c < 0 ? (w = x[0], z != m && (w = w * l + (x[1] || 0)), p = w / $ | 0, p > 1 ? (p >= l && (p = l - 1), b = e(pt, p, l), f = b.length, m = x.length, c = t(b, x, f, m), c == 1 && (p--, r(b, z < f ? F : pt, f, l))) : (p == 0 && (c = p = 1), b = pt.slice()), f = b.length, f < m && b.unshift(0), r(x, b, m, l), c == -1 && (m = x.length, c = t(pt, x, z, m), c < 1 && (p++, r(x, z < m ? F : pt, m, l))), m = x.length) : c === 0 && (p++, x = [0]), A[u++] = p, c && x[0] ? x[m++] = at[R] || 0 : (x = [at[R]], m = 1);
        while ((R++ < O || x[0] !== void 0) && _--);
        g = x[0] !== void 0;
      }
      A[0] || A.shift();
    }
    if (y == 1)
      E.e = h, XO = g;
    else {
      for (u = 1, p = A[0]; p >= 10; p /= 10) u++;
      E.e = u + h * y - 1, he(E, a ? s + E.e + 1 : s, o, g);
    }
    return E;
  };
}();
function he(e, t, r, n) {
  var i, s, o, a, l, c, h, u, p, y = e.constructor;
  t: if (t != null) {
    if (u = e.d, !u) return e;
    for (i = 1, a = u[0]; a >= 10; a /= 10) i++;
    if (s = t - i, s < 0)
      s += ye, o = t, h = u[p = 0], l = h / fn(10, i - o - 1) % 10 | 0;
    else if (p = Math.ceil((s + 1) / ye), a = u.length, p >= a)
      if (n) {
        for (; a++ <= p; ) u.push(0);
        h = l = 0, i = 1, s %= ye, o = s - ye + 1;
      } else
        break t;
    else {
      for (h = a = u[p], i = 1; a >= 10; a /= 10) i++;
      s %= ye, o = s - ye + i, l = o < 0 ? 0 : h / fn(10, i - o - 1) % 10 | 0;
    }
    if (n = n || t < 0 || u[p + 1] !== void 0 || (o < 0 ? h : h % fn(10, i - o - 1)), c = r < 4 ? (l || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? h / fn(10, i - o) : 0 : u[p - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !u[0])
      return u.length = 0, c ? (t -= e.e + 1, u[0] = fn(10, (ye - t % ye) % ye), e.e = -t || 0) : u[0] = e.e = 0, e;
    if (s == 0 ? (u.length = p, a = 1, p--) : (u.length = p + 1, a = fn(10, ye - s), u[p] = o > 0 ? (h / fn(10, i - o) % fn(10, o) | 0) * a : 0), c)
      for (; ; )
        if (p == 0) {
          for (s = 1, o = u[0]; o >= 10; o /= 10) s++;
          for (o = u[0] += a, a = 1; o >= 10; o /= 10) a++;
          s != a && (e.e++, u[0] == Es && (u[0] = 1));
          break;
        } else {
          if (u[p] += a, u[p] != Es) break;
          u[p--] = 0, a = 1;
        }
    for (s = u.length; u[--s] === 0; ) u.pop();
  }
  return Pe && (e.e > y.maxE ? (e.d = null, e.e = NaN) : e.e < y.minE && (e.e = 0, e.d = [0])), e;
}
function xo(e, t, r) {
  if (!e.isFinite()) return sL(e);
  var n, i = e.e, s = rn(e.d), o = s.length;
  return t ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + Ka(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (s = "0." + Ka(-i - 1) + s, r && (n = r - o) > 0 && (s += Ka(n))) : i >= o ? (s += Ka(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + Ka(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += Ka(n))), s;
}
function x2(e, t) {
  var r = e[0];
  for (t *= ye; r >= 10; r /= 10) t++;
  return t;
}
function Im(e, t, r) {
  if (t > zX)
    throw Pe = !0, r && (e.precision = r), Error(tL);
  return he(new e(km), t, 1, !0);
}
function ms(e, t, r) {
  if (t > N3) throw Error(tL);
  return he(new e(Cm), t, r, !0);
}
function rL(e) {
  var t = e.length - 1, r = t * ye + 1;
  if (t = e[t], t) {
    for (; t % 10 == 0; t /= 10) r--;
    for (t = e[0]; t >= 10; t /= 10) r++;
  }
  return r;
}
function Ka(e) {
  for (var t = ""; e--; ) t += "0";
  return t;
}
function nL(e, t, r, n) {
  var i, s = new e(1), o = Math.ceil(n / ye + 4);
  for (Pe = !1; ; ) {
    if (r % 2 && (s = s.times(t), H9(s.d, o) && (i = !0)), r = Sn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    t = t.times(t), H9(t.d, o);
  }
  return Pe = !0, s;
}
function V9(e) {
  return e.d[e.d.length - 1] & 1;
}
function iL(e, t, r) {
  for (var n, i = new e(t[0]), s = 0; ++s < t.length; )
    if (n = new e(t[s]), n.s)
      i[r](n) && (i = n);
    else {
      i = n;
      break;
    }
  return i;
}
function D3(e, t) {
  var r, n, i, s, o, a, l, c = 0, h = 0, u = 0, p = e.constructor, y = p.rounding, g = p.precision;
  if (!e.d || !e.d[0] || e.e > 17)
    return new p(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
  for (t == null ? (Pe = !1, l = g) : l = t, a = new p(0.03125); e.e > -2; )
    e = e.times(a), u += 5;
  for (n = Math.log(fn(2, u)) / Math.LN10 * 2 + 5 | 0, l += n, r = s = o = new p(1), p.precision = l; ; ) {
    if (s = he(s.times(e), l, 1), r = r.times(++h), a = o.plus(tr(s, r, l, 1)), rn(a.d).slice(0, l) === rn(o.d).slice(0, l)) {
      for (i = u; i--; ) o = he(o.times(o), l, 1);
      if (t == null)
        if (c < 3 && Df(o.d, l - n, y, c))
          p.precision = l += 10, r = s = a = new p(1), h = 0, c++;
        else
          return he(o, p.precision = g, y, Pe = !0);
      else
        return p.precision = g, o;
    }
    o = a;
  }
}
function pl(e, t) {
  var r, n, i, s, o, a, l, c, h, u, p, y = 1, g = 10, b = e, f = b.d, E = b.constructor, A = E.rounding, x = E.precision;
  if (b.s < 0 || !f || !f[0] || !b.e && f[0] == 1 && f.length == 1)
    return new E(f && !f[0] ? -1 / 0 : b.s != 1 ? NaN : f ? 0 : b);
  if (t == null ? (Pe = !1, h = x) : h = t, E.precision = h += g, r = rn(f), n = r.charAt(0), Math.abs(s = b.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      b = b.times(e), r = rn(b.d), n = r.charAt(0), y++;
    s = b.e, n > 1 ? (b = new E("0." + r), s++) : b = new E(n + "." + r.slice(1));
  } else
    return c = Im(E, h + 2, x).times(s + ""), b = pl(new E(n + "." + r.slice(1)), h - g).plus(c), E.precision = x, t == null ? he(b, x, A, Pe = !0) : b;
  for (u = b, l = o = b = tr(b.minus(1), b.plus(1), h, 1), p = he(b.times(b), h, 1), i = 3; ; ) {
    if (o = he(o.times(p), h, 1), c = l.plus(tr(o, new E(i), h, 1)), rn(c.d).slice(0, h) === rn(l.d).slice(0, h))
      if (l = l.times(2), s !== 0 && (l = l.plus(Im(E, h + 2, x).times(s + ""))), l = tr(l, new E(y), h, 1), t == null)
        if (Df(l.d, h - g, A, a))
          E.precision = h += g, c = o = b = tr(u.minus(1), u.plus(1), h, 1), p = he(b.times(b), h, 1), i = a = 1;
        else
          return he(l, E.precision = x, A, Pe = !0);
      else
        return E.precision = x, l;
    l = c, i += 2;
  }
}
function sL(e) {
  return String(e.s * e.s / 0);
}
function U9(e, t) {
  var r, n, i;
  for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0; t.charCodeAt(n) === 48; n++) ;
  for (i = t.length; t.charCodeAt(i - 1) === 48; --i) ;
  if (t = t.slice(n, i), t) {
    if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % ye, r < 0 && (n += ye), n < i) {
      for (n && e.d.push(+t.slice(0, n)), i -= ye; n < i; ) e.d.push(+t.slice(n, n += ye));
      t = t.slice(n), n = ye - t.length;
    } else
      n -= i;
    for (; n--; ) t += "0";
    e.d.push(+t), Pe && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
  } else
    e.e = 0, e.d = [0];
  return e;
}
function UX(e, t) {
  var r, n, i, s, o, a, l, c, h;
  if (t === "Infinity" || t === "NaN")
    return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
  if (BX.test(t))
    r = 16, t = t.toLowerCase();
  else if (DX.test(t))
    r = 2;
  else if (jX.test(t))
    r = 8;
  else
    throw Error(wu + t);
  for (s = t.search(/p/i), s > 0 ? (l = +t.slice(s + 1), t = t.substring(2, s)) : t = t.slice(2), s = t.indexOf("."), o = s >= 0, n = e.constructor, o && (t = t.replace(".", ""), a = t.length, s = a - s, i = nL(n, new n(r), s, s * 2)), c = R1(t, r, Es), h = c.length - 1, s = h; c[s] === 0; --s) c.pop();
  return s < 0 ? new n(e.s * 0) : (e.e = x2(c, h), e.d = c, Pe = !1, o && (e = tr(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? Math.pow(2, l) : z0.pow(2, l))), Pe = !0, e);
}
function HX(e, t) {
  var r, n = t.d.length;
  if (n < 3) return rp(e, 2, t, t);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(Math.pow(5, -r)), t = rp(e, 2, t, t);
  for (var i, s = new e(5), o = new e(16), a = new e(20); r--; )
    i = t.times(t), t = t.times(s.plus(i.times(o.times(i).minus(a))));
  return t;
}
function rp(e, t, r, n, i) {
  var s, o, a, l, c = e.precision, h = Math.ceil(c / ye);
  for (Pe = !1, l = r.times(r), a = new e(n); ; ) {
    if (o = tr(a.times(l), new e(t++ * t++), c, 1), a = i ? n.plus(o) : n.minus(o), n = tr(o.times(l), new e(t++ * t++), c, 1), o = a.plus(n), o.d[h] !== void 0) {
      for (s = h; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = n, n = o, o = s;
  }
  return Pe = !0, o.d.length = h + 1, o;
}
function oL(e, t) {
  var r, n = t.s < 0, i = ms(e, e.precision, 1), s = i.times(0.5);
  if (t = t.abs(), t.lte(s))
    return Ho = n ? 4 : 1, t;
  if (r = t.divToInt(i), r.isZero())
    Ho = n ? 3 : 2;
  else {
    if (t = t.minus(r.times(i)), t.lte(s))
      return Ho = V9(r) ? n ? 2 : 3 : n ? 4 : 1, t;
    Ho = V9(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return t.minus(i).abs();
}
function l5(e, t, r, n) {
  var i, s, o, a, l, c, h, u, p, y = e.constructor, g = r !== void 0;
  if (g ? (Yn(r, 1, lc), n === void 0 ? n = y.rounding : Yn(n, 0, 8)) : (r = y.precision, n = y.rounding), !e.isFinite())
    h = sL(e);
  else {
    for (h = xo(e), o = h.indexOf("."), g ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, o >= 0 && (h = h.replace(".", ""), p = new y(1), p.e = h.length - o, p.d = R1(xo(p), 10, i), p.e = p.d.length), u = R1(h, 10, i), s = l = u.length; u[--l] == 0; ) u.pop();
    if (!u[0])
      h = g ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (e = new y(e), e.d = u, e.e = s, e = tr(e, p, r, n, 0, i), u = e.d, s = e.e, c = XO), o = u[r], a = i / 2, c = c || u[r + 1] !== void 0, c = n < 4 ? (o !== void 0 || c) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || c || n === 6 && u[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), u.length = r, c)
        for (; ++u[--r] > i - 1; )
          u[r] = 0, r || (++s, u.unshift(1));
      for (l = u.length; !u[l - 1]; --l) ;
      for (o = 0, h = ""; o < l; o++) h += L3.charAt(u[o]);
      if (g) {
        if (l > 1)
          if (t == 16 || t == 8) {
            for (o = t == 16 ? 4 : 3, --l; l % o; l++) h += "0";
            for (u = R1(h, i, t), l = u.length; !u[l - 1]; --l) ;
            for (o = 1, h = "1."; o < l; o++) h += L3.charAt(u[o]);
          } else
            h = h.charAt(0) + "." + h.slice(1);
        h = h + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) h = "0" + h;
        h = "0." + h;
      } else if (++s > l) for (s -= l; s--; ) h += "0";
      else s < l && (h = h.slice(0, s) + "." + h.slice(s));
    }
    h = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + h;
  }
  return e.s < 0 ? "-" + h : h;
}
function H9(e, t) {
  if (e.length > t)
    return e.length = t, !0;
}
function GX(e) {
  return new this(e).abs();
}
function QX(e) {
  return new this(e).acos();
}
function WX(e) {
  return new this(e).acosh();
}
function qX(e, t) {
  return new this(e).plus(t);
}
function YX(e) {
  return new this(e).asin();
}
function KX(e) {
  return new this(e).asinh();
}
function ZX(e) {
  return new this(e).atan();
}
function JX(e) {
  return new this(e).atanh();
}
function XX(e, t) {
  e = new this(e), t = new this(t);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !e.s || !t.s ? r = new this(NaN) : !e.d && !t.d ? (r = ms(this, s, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t.d || e.isZero() ? (r = t.s < 0 ? ms(this, n, i) : new this(0), r.s = e.s) : !e.d || t.isZero() ? (r = ms(this, s, 1).times(0.5), r.s = e.s) : t.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(tr(e, t, s, 1)), t = ms(this, s, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(tr(e, t, s, 1)), r;
}
function ttt(e) {
  return new this(e).cbrt();
}
function ett(e) {
  return he(e = new this(e), e.e + 1, 2);
}
function rtt(e) {
  if (!e || typeof e != "object") throw Error(w2 + "Object expected");
  var t, r, n, i = e.defaults === !0, s = [
    "precision",
    1,
    lc,
    "rounding",
    0,
    8,
    "toExpNeg",
    -9e15,
    0,
    "toExpPos",
    0,
    O3,
    "maxE",
    0,
    O3,
    "minE",
    -9e15,
    0,
    "modulo",
    0,
    9
  ];
  for (t = 0; t < s.length; t += 3)
    if (r = s[t], i && (this[r] = M3[r]), (n = e[r]) !== void 0)
      if (Sn(n) === n && n >= s[t + 1] && n <= s[t + 2]) this[r] = n;
      else throw Error(wu + r + ": " + n);
  if (r = "crypto", i && (this[r] = M3[r]), (n = e[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(eL);
      else
        this[r] = !1;
    else
      throw Error(wu + r + ": " + n);
  return this;
}
function ntt(e) {
  return new this(e).cos();
}
function itt(e) {
  return new this(e).cosh();
}
function aL(e) {
  var t, r, n;
  function i(s) {
    var o, a, l, c = this;
    if (!(c instanceof i)) return new i(s);
    if (c.constructor = i, s instanceof i) {
      c.s = s.s, c.e = s.e, c.d = (s = s.d) ? s.slice() : s;
      return;
    }
    if (l = typeof s, l === "number") {
      if (s === 0) {
        c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        c.e = o, c.d = [s];
        return;
      } else if (s * 0 !== 0) {
        s || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return U9(c, s.toString());
    } else if (l !== "string")
      throw Error(wu + s);
    return s.charCodeAt(0) === 45 ? (s = s.slice(1), c.s = -1) : c.s = 1, FX.test(s) ? U9(c, s) : UX(c, s);
  }
  if (i.prototype = Ft, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = rtt, i.clone = aL, i.isDecimal = ctt, i.abs = GX, i.acos = QX, i.acosh = WX, i.add = qX, i.asin = YX, i.asinh = KX, i.atan = ZX, i.atanh = JX, i.atan2 = XX, i.cbrt = ttt, i.ceil = ett, i.cos = ntt, i.cosh = itt, i.div = stt, i.exp = ott, i.floor = att, i.hypot = ltt, i.ln = utt, i.log = htt, i.log10 = dtt, i.log2 = ptt, i.max = ftt, i.min = gtt, i.mod = mtt, i.mul = ytt, i.pow = btt, i.random = vtt, i.round = wtt, i.sign = xtt, i.sin = Ett, i.sinh = Att, i.sqrt = Stt, i.sub = _tt, i.tan = ktt, i.tanh = Ctt, i.trunc = Itt, e === void 0 && (e = {}), e && e.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0; t < n.length; ) e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
  return i.config(e), i;
}
function stt(e, t) {
  return new this(e).div(t);
}
function ott(e) {
  return new this(e).exp();
}
function att(e) {
  return he(e = new this(e), e.e + 1, 3);
}
function ltt() {
  var e, t, r = new this(0);
  for (Pe = !1, e = 0; e < arguments.length; )
    if (t = new this(arguments[e++]), t.d)
      r.d && (r = r.plus(t.times(t)));
    else {
      if (t.s)
        return Pe = !0, new this(1 / 0);
      r = t;
    }
  return Pe = !0, r.sqrt();
}
function ctt(e) {
  return e instanceof z0 || e && e.name === "[object Decimal]" || !1;
}
function utt(e) {
  return new this(e).ln();
}
function htt(e, t) {
  return new this(e).log(t);
}
function ptt(e) {
  return new this(e).log(2);
}
function dtt(e) {
  return new this(e).log(10);
}
function ftt() {
  return iL(this, arguments, "lt");
}
function gtt() {
  return iL(this, arguments, "gt");
}
function mtt(e, t) {
  return new this(e).mod(t);
}
function ytt(e, t) {
  return new this(e).mul(t);
}
function btt(e, t) {
  return new this(e).pow(t);
}
function vtt(e) {
  var t, r, n, i, s = 0, o = new this(1), a = [];
  if (e === void 0 ? e = this.precision : Yn(e, 1, lc), n = Math.ceil(e / ye), this.crypto)
    if (crypto.getRandomValues)
      for (t = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = t[s], i >= 429e7 ? t[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (t = crypto.randomBytes(n *= 4); s < n; )
        i = t[s] + (t[s + 1] << 8) + (t[s + 2] << 16) + ((t[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(t, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(eL);
  else for (; s < n; ) a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], e %= ye, n && e && (i = fn(10, ye - e), a[s] = (n / i | 0) * i); a[s] === 0; s--) a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= ye) a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
    n < ye && (r -= ye - n);
  }
  return o.e = r, o.d = a, o;
}
function wtt(e) {
  return he(e = new this(e), e.e + 1, this.rounding);
}
function xtt(e) {
  return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
}
function Ett(e) {
  return new this(e).sin();
}
function Att(e) {
  return new this(e).sinh();
}
function Stt(e) {
  return new this(e).sqrt();
}
function _tt(e, t) {
  return new this(e).sub(t);
}
function ktt(e) {
  return new this(e).tan();
}
function Ctt(e) {
  return new this(e).tanh();
}
function Itt(e) {
  return he(e = new this(e), e.e + 1, 1);
}
var z0 = aL(M3);
km = new z0(km);
Cm = new z0(Cm);
function Ptt(e) {
  let t = 0.01;
  switch (!0) {
    case e.gte(1e12):
      t = 1e12;
      break;
    case e.gte(1e9):
      t = 1e9;
      break;
    case e.gte(1e6):
      t = 1e6;
      break;
    case e.gte(1e3):
      t = 1e3;
      break;
    case e.gte(1):
      t = 1;
      break;
  }
  return { number: e.div(t).toNumber(), scale: t };
}
function Rtt(e) {
  if (e.length < 2)
    return e.length;
  const t = [];
  t: for (const r of e) {
    for (const n of t)
      if (r.equals(n))
        continue t;
    t.push(r);
  }
  return t.length;
}
function Ttt(e, t) {
  return e.cmp(t);
}
function Ott(e) {
  const t = e.map((a) => a.number * a.scale), r = new Set(t).size, n = t.map((a) => new z0(a));
  let i = !0, s = 3, o = [];
  for (; i; ) {
    o = n.map((l) => l.toSD(s));
    const a = Rtt(o);
    r === a ? i = !1 : s++, s === 10 && (i = !1);
  }
  return o.map((a, l) => ({ ...Ptt(a), roundingDirection: Ttt(a, n[l]) }));
}
function lL(e, t) {
  const r = t.map((a) => a.facetValueAsNumber(e)), n = Math.min(...r), i = Math.max(...r), s = t.filter((a) => a.facetValueAsNumber(e) === n), o = t.filter((a) => a.facetValueAsNumber(e) === i);
  return {
    min: { value: n, datapoints: s },
    max: { value: i, datapoints: o },
    range: i - n,
    mean: wo(r),
    median: OX(r),
    mode: IX(r)
  };
}
function Ltt(e, t) {
  const r = t.map((n) => ({ number: n, scale: e }));
  return Ott(r);
}
function Mtt(e, t, r) {
  const n = [], i = [];
  for (const p of e) {
    n.push(...p.datapoints.map((g) => g.facetValue("y")));
    const y = p.getFacetStats("y");
    i.push(
      p.datapoints[0].facetValue("y"),
      p.datapoints.at(-1).facetValue("y"),
      y.max.value,
      y.min.value
    );
  }
  const s = n.concat(i);
  s.push(...t.map((p) => p.value));
  const o = Ltt(r ?? 1, s);
  let a = e[0].length;
  const l = {};
  for (let p = 0; p < e.length; p++) {
    const y = e[p];
    l[y.key] = o.slice(p * a, p + 1 * a);
  }
  let c = e.length * a;
  a = 4;
  const h = {};
  for (let p = 0; p < e.length; p++) {
    const y = e[p];
    h[y.key] = {
      start: o[p * a + c],
      end: o[p * a + c + 1],
      max: o[p * a + c + 2],
      min: o[p * a + c + 3]
    };
  }
  c += e.length * 4;
  const u = o.slice(c);
  return [l, h, u];
}
function Ntt(e, t) {
  if (!YO((r, n) => r === n, Object.keys(e), Object.keys(t)))
    return !1;
  for (const r in e)
    if (!e[r].isEqual(t[r]))
      return !1;
  return !0;
}
class Dtt {
  constructor(t) {
    if (this.facets = t, this.facetKeyIndexMap = {}, this.facets.length === 0)
      throw new Error("dataframes must have at least 1 column");
    this.columns = lu(this.facets.length, (r) => []), this.facets.forEach((r, n) => {
      this.facetKeyIndexMap[r.key] = n;
    });
  }
  addDatapoint(t) {
    const r = Object.keys(t).length;
    if (r !== this.nColumns)
      throw new Error(`datapoint ${t} cannot be added to dataframe. This dataframe has ${this.nColumns} columns, but this datapoint as ${r} facets`);
    lu(this.nColumns, (n) => {
      const i = this.facets[n], s = t[i.key];
      if (s === void 0)
        throw new Error(`datapoint ${t} is missing the facet ${i.key}`);
      this.columns[n].push(new AX[i.datatype](s));
    });
  }
  get nRows() {
    return this.columns[0].length;
  }
  get nColumns() {
    return this.columns.length;
  }
  get rows() {
    return lu(this.nRows, (t) => {
      const r = {};
      return this.columns.forEach((n, i) => {
        r[this.facets[i].key] = n[t];
      }), r;
    });
  }
  facet(t) {
    return this.columns[this.facetKeyIndexMap[t]] ?? null;
  }
  /** Iterate over the rows, producing DataFrames of one row. */
  /* *[Symbol.iterator]() {
    for (let i = 0; i < this.nRows; i++) {
      yield [i, this.slice(i, i + 1)] as [number, DataFrame];
    }
  }*/
  /** Iterate over the columns, producing Series. */
  /*get iterCols() {
      return new ColumnIterable(this.data);
    }
  
    private checkRowBounds(row: number) {
      if (row < 0) {
        if (row < -this.nRows) {
          throw new Error(`row index '${row}' out of bounds`);
        }
        row = this.data[0].length + row;
      } else if (row >= this.nRows) {
        throw new Error(`row index '${row}' out of bounds`);
      }
    }*/
  /**
   * Retrieve the row at the given index as a series.
   * @param row - The row.
   * @remarks
   * Will fail if all columns are not of the same type.
   */
  /*row(row: number) {
      this.checkRowBounds(row);
      if (this.data.length === 0) {
        throw new Error('data frame has no columns');
      }
      const type = this.data[0].dtype;
      this.data.slice(1).forEach(series => {
        if (series.dtype !== type) {
          throw new Error(`all columns must have type '${type}'`);
        }
      }); 
      return new seriesTypes[type](this.data.map(series => series.at(row)) as ScalarArray);
    }
  
    col(name: string) {
      const series = this.data.find(series => series.name === name);
      if (!series) {  
        throw new Error(`no column with name '${name}'`);
      }
      return series;
    }
  
    slice(start?: number, end?: number) {
      return new DataFrame(
        this.data.map(series => series.slice(start, end)));
    }
  
    at(row: number, col: string) {
      this.checkRowBounds(row);
      const series = this.data.find(series => series.name === col);
      if (!series) {
        throw new Error(`no column with name '${col}'`);
      }
      return series.atBoxed(row);
    }
  
    private assertColsExist(colNames: string[]) {
      const existingColNames = this.data.map(series => series.name!);
      colNames.forEach(name => {
        if (!existingColNames.includes(name)) {
          throw new Error(`no such column '${name}'`);
        }
      });
    }
  
    takeCols(colNames: string[]) {
      this.assertColsExist(colNames);
      return new DataFrame(colNames.map(name => this.col(name)!));
    }
  
    dropCols(colNames: string[]) {
      this.assertColsExist(colNames);
      const existingColNames = this.data.map(series => series.name!);
      return new DataFrame(
        existingColNames
          .filter(name => !colNames.includes(name))
          .map(name => this.col(name)!));
    }
  
    map<T>(fn: (el: DataFrame, index: number) => T): T[] {
      const out: T[] = [];
      for (const [i, row] of this) {
        out.push(fn(row, i));
      }
      return out;
    }
  
    mapCols<T>(fn: (el: Series<Scalar>, index: number) => T): T[] {
      const out: T[] = [];
      for (const [i, col] of this.iterCols) {
        out.push(fn(col, i));
      }
      return out;
    }*/
}
var Btt = Object.defineProperty, jtt = Object.getOwnPropertyDescriptor, E2 = (e, t, r, n) => {
  for (var i = jtt(t, r), s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(t, r, i) || i);
  return i && Btt(t, r, i), i;
};
let Bp = class {
  constructor(t, r, n) {
    this.data = t, this.seriesKey = r, this.datapointIndex = n;
  }
  entries() {
    return Object.entries(this.data)[Symbol.iterator]();
  }
  facetBox(t) {
    return this.data[t] ?? null;
  }
  facetValue(t) {
    return this.data[t].value ?? null;
  }
  facetValueAsNumber(t) {
    const r = this.data[t];
    return r === void 0 || !r.isNumberLike() ? null : r.asNumber();
  }
  facetValueNumericized(t) {
    const r = this.data[t];
    return r === void 0 ? null : r.isNumber() ? r.value : r.isDate() ? r.asNumber() : this.datapointIndex;
  }
  convertFacetValuesToXYForLine(t, r) {
    const n = this.facetValueNumericized(t), i = this.facetValueNumericized(r);
    return n === null || i === null ? null : { x: n, y: i };
  }
  equals(t) {
    return Ntt(this.data, t.data) && this.seriesKey === t.seriesKey && this.datapointIndex === t.datapointIndex;
  }
  getNavcode() {
    return `datapoint-${this.seriesKey}-${this.datapointIndex}`;
  }
};
E2([
  hr()
], Bp.prototype, "facetValueAsNumber");
E2([
  hr()
], Bp.prototype, "facetValueNumericized");
E2([
  hr()
], Bp.prototype, "convertFacetValuesToXYForLine");
E2([
  hr()
], Bp.prototype, "getNavcode");
class Ftt extends Bp {
  constructor(t, r, n, i, s) {
    if (super(t, r, n), this.indepKey = i, this.depKey = s, !(i in t))
      throw new Error(`'PlaneDatapoint' is missing the '${i}' independent axis facet value`);
    if (!(s in t))
      throw new Error(`'PlaneDatapoint' is missing the '${s}' dependent axis facet value`);
  }
  get indepBox() {
    return this.data[this.indepKey];
  }
  get depBox() {
    return this.data[this.depKey];
  }
  // TODO: Is this needed any more with PlaneSeries?
  convertToActualXYForLine() {
    return this.convertFacetValuesToXYForLine(this.indepKey, this.depKey);
  }
}
var $tt = Object.defineProperty, ztt = Object.getOwnPropertyDescriptor, _a = (e, t, r, n) => {
  for (var i = ztt(t, r), s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(t, r, i) || i);
  return i && $tt(t, r, i), i;
};
let Lo = class {
  constructor(t, r, n, i, s) {
    this.manifest = t, this.rawData = r, this.facetSignatures = n, this.indepKey = i, this.depKey = s, this.datapoints = [], this.facetKeys = [], this._uniqueValuesForFacetMappedByKey = {}, this._facetDatatypeMappedByKey = {}, this.key = this.manifest.key, this.id = nY(this.key), this.label = this.manifest.label ?? this.key, this.facetSignatures.forEach((o) => {
      this.facetKeys.push(o.key), this._uniqueValuesForFacetMappedByKey[o.key] = new KO(), this._facetDatatypeMappedByKey[o.key] = o.datatype;
    }), this._dataframe = new Dtt(n), this.length = this.rawData.length, this.rawData.forEach((o) => this._dataframe.addDatapoint(o)), this._dataframe.rows.forEach((o, a) => {
      const l = this.constructDatapoint(o, this.key, a);
      this[a] = l, this.datapoints.push(l), Object.keys(o).forEach(
        (c) => this._uniqueValuesForFacetMappedByKey[c].add(o[c])
      );
    });
  }
  constructDatapoint(t, r, n) {
    return new Bp(t, r, n);
  }
  facetBoxes(t) {
    return this._dataframe.facet(t);
  }
  allFacetValues(t) {
    var r;
    return ((r = this._uniqueValuesForFacetMappedByKey[t]) == null ? void 0 : r.values) ?? null;
  }
  getFacetDatatype(t) {
    return this._facetDatatypeMappedByKey[t] ?? null;
  }
  createLineFromFacets(t, r) {
    if (!this.facetKeys.includes(t) || !this.facetKeys.includes(r))
      return null;
    const n = this.datapoints.map((i) => i.convertFacetValuesToXYForLine(t, r));
    return new Cf(n, this.key);
  }
  facetAverage(t) {
    const r = this._facetDatatypeMappedByKey[t];
    return R3(r) ? wo(this.datapoints.map((n) => n.facetValueAsNumber(t))) : null;
  }
  getFacetStats(t) {
    const r = this._facetDatatypeMappedByKey[t];
    return R3(r) ? lL(t, this.datapoints) : null;
  }
  [Symbol.iterator]() {
    return this.datapoints[Symbol.iterator]();
  }
  // Assumes at most one datapoint at that value at that facet
  datapointAt(t, r) {
    const n = this._facetDatatypeMappedByKey[t];
    if (n === void 0 || r.datatype() !== n)
      return null;
    for (const i of this.datapoints)
      if (i.facetBox(t).isEqual(r))
        return i;
    return null;
  }
  getLabel() {
    return this.label ? this.label : this.key;
  }
};
_a([
  hr()
], Lo.prototype, "facetBoxes");
_a([
  hr()
], Lo.prototype, "allFacetValues");
_a([
  hr()
], Lo.prototype, "getFacetDatatype");
_a([
  hr()
], Lo.prototype, "createLineFromFacets");
_a([
  hr()
], Lo.prototype, "facetAverage");
_a([
  hr()
], Lo.prototype, "getFacetStats");
_a([
  hr()
], Lo.prototype, "getLabel");
let A2 = class extends Lo {
  /*protected xMap: Map<ScalarMap[X], number[]>;
  private yMap: Map<number, ScalarMap[X][]>;*/
  constructor(t, r, n, i, s) {
    super(t, r, n, i, s), console.assert(this.facetKeys.includes(i), `[ParaModel/Internal]: PlaneSeries constructed with unknown indepKey ${i}`), console.assert(this.facetKeys.includes(s), `[ParaModel/Internal]: PlaneSeries constructed with unknown depKey ${s}`), console.assert(R3(this.getFacetDatatype(s)), `[ParaModel/Internal]: PlaneSeries depKey ${s} has non-number-like ${this.getFacetDatatype(s)} datatype`);
  }
  constructDatapoint(t, r, n) {
    return new Ftt(t, r, n, this.indepKey, this.depKey);
  }
  getActualLine() {
    return this.createLineFromFacets(this.indepKey, this.depKey);
  }
  getIndepAverage() {
    return this.facetAverage(this.indepKey);
  }
  // TODO: Add This
  /*@Memoize()
  public getAnalyzer(): SingleSeriesMetadataAnalyzer {
    return new BasicSingleSeriesAnalyzer(this.createActualLine());
  }*/
  /*atX(x: ScalarMap[X]): number[] | null {
      return this.xMap.get(x) ?? null;
    }
  
    atY(y: number): ScalarMap[X][] | null {
      return this.yMap.get(y) ?? null;
    }*/
};
_a([
  hr()
], A2.prototype, "getActualLine");
_a([
  hr()
], A2.prototype, "getIndepAverage");
function Vtt(e, t) {
  if (!e.records)
    throw new Error("only series manifests with inline data can use this method.");
  return new Lo(e, e.records, t);
}
function Utt(e, t, r, n) {
  if (!e.records)
    throw new Error("only series manifests with inline data can use this method.");
  return new A2(
    e,
    e.records,
    t,
    r,
    n
  );
}
const cu = {
  numPointsNotEqual: 0,
  segStartNotBeforeEnd: 1,
  seriesWithoutKey: 2
}, Htt = {
  [cu.numPointsNotEqual]: "number of points in each time series must be equal",
  [cu.segStartNotBeforeEnd]: "The start x value of a segment must be less than the end x value of the segment.",
  [cu.seriesWithoutKey]: "Every series must have a key"
};
let Pm = class extends Error {
  /**
   * Constructs the Err class
   * @param code - The code of the error
   */
  constructor(t) {
    super(Htt[t]), this.code = t;
  }
};
function G9(e, t) {
  return { start: e.points[t], end: e.points[t + 1] };
}
let cL = class {
  constructor(t, r, n) {
    if (this.series1 = t, this.series2 = r, t.length !== r.length)
      throw new Pm(cu.numPointsNotEqual);
    this.allSegPairProps = lu(
      t.length - 1,
      (o) => this.checkIntersection(G9(t, o), G9(r, o), n, o)
    ), this.intersectingSegPairs = this.getIntersections(), this.parallelSegPairs = this.getParallelSegPairs();
    const { dominant: i, timeOnTop: s } = this.findDominant();
    this.dominant = i, this.timeOnTop = s, this.averageGap = t.points.map((o, a) => Math.abs(o.y - r.points[a].y)).reduce((o, a) => o + a, 0) / t.length;
  }
  // This is public only for testing
  getIntersections() {
    return this.allSegPairProps.filter((t) => t.intersection !== "None");
  }
  getParallelSegPairs() {
    return this.allSegPairProps.filter(
      (t) => t.relationship === 3 || t.relationship === 4
      /* FunctionallyParallel */
    );
  }
  findDominant() {
    const t = this.series1.points[1].x - this.series1.points[0].x;
    let r = 0;
    this.allSegPairProps.forEach((i, s) => {
      const o = i.segs;
      if (i.relationship === 0) {
        const a = i.intersection;
        a.crosspoint.x === o[0].start.x ? o[0].end.y > o[1].end.y && (r += t) : a.crosspoint.x === o[0].end.x ? o[0].start.y > o[1].start.y && (r += t) : o[0].start.y > o[1].start.y ? r += a.crosspoint.x - o[0].start.x : r += o[0].end.x - a.crosspoint.x;
      } else i.relationship !== 2 && o[0].start.y > o[1].start.y && (r += t);
    }), r /= this.series1.points.at(-1).x - this.series1.points[0].x;
    const n = r > 0.5 ? 1 : r < 0.5 ? 2 : -1;
    return { dominant: n, timeOnTop: n === 1 ? r : 1 - r };
  }
  /**
   * Check for the relationship between two lines. 
   * Uses a vector cross-product approach described on StackOverflow:
   * http://stackoverflow.com/a/565282/786339
   */
  // This is only public for testing
  checkIntersection(t, r, n, i) {
    const s = this.findSlope(t, n), o = this.findSlope(r, n);
    let a = {
      i,
      segs: [t, r],
      relationship: 1,
      slopes: {
        a: s,
        b: o
      },
      category: "",
      //TODO: add categories?
      intersection: "None"
    };
    return Math.max(t.start.y, t.end.y) < Math.min(r.start.y, r.end.y) || Math.min(t.start.y, t.end.y) > Math.max(r.start.y, r.end.y) ? a.relationship = this.getParallelApproximation(a.slopes.a, a.slopes.b) : t.start.y === r.start.y || t.end.y === r.end.y ? t.end.y !== r.end.y || t.start.y !== r.start.y ? (a.relationship = 0, a.intersection = {
      crosspoint: t.end.y !== r.end.y ? t.start : t.end,
      angle: this.findAngle(s, o),
      atRecord: !0
    }) : (a.relationship = 2, a.intersection = "Overlap") : this.calculateLineIntersectionPoints(t, r, a), a;
  }
  /**
   * Check for the relationship between two lines. 
   * Uses a vector cross-product approach described on StackOverflow:
   * http://stackoverflow.com/a/565282/786339
   *  
   * The formula expressed in this module takes advantage of vector representations for number lines. 
   * A typical numberline is expressed in start and end points on an x, y plane or axis.Example line:
   * 
   * p (1,2) as the startpoint
   * p2 (3,6) as the endpoint 
   * 
   * Points on a number line can also be expressed as a 2 x 1 vector
   *  p = |1|
   *      |2|
   * 
   * And therefore line segments are expressed by vector addition: 
   * p + r where 
   * p = original point on the number line.
   * r = the transformation. This can de thought of as the difference, or change between point p and point p2.
   * 
   * this means r = p2 - p.    
   * 
   * so in the above points r = (2, 3) of r = |2|
   *                                          |3|
   *   
   * p in this case is the same as the above. It is the startpoint of the number line.
   * 
   * The rest of this function references the above formula fairly closely. 
   */
  calculateLineIntersectionPoints(t, r, n) {
    const i = this.subtractPoints(t.end, t.start), s = this.subtractPoints(r.end, r.start), o = this.crossProduct(this.subtractPoints(r.start, t.start), i), a = this.crossProduct(i, s);
    if (a === 0 && o !== 0)
      n.relationship = 3;
    else {
      const l = o / a, c = this.crossProduct(this.subtractPoints(r.start, t.start), i) / a;
      if (c >= 0 && c <= 1 && l >= 0 && l <= 1) {
        let h = { x: i.x * c, y: i.y * c };
        const u = this.addPoints(h, t.start);
        n.relationship = 0, n.intersection = {
          crosspoint: u,
          //NOTE: the left and right angles here will be the same
          angle: this.findAngle(n.slopes.a, n.slopes.b),
          atRecord: !1
        };
      } else
        this.getParallelApproximation(n.slopes.a, n.slopes.b);
    }
  }
  /**
   */
  getParallelApproximation(t, r) {
    const n = af(t), i = af(r), s = 5, o = Math.abs(n - i);
    return n === i ? 3 : o < s ? 4 : 1;
  }
  /**
   * Find the apparent slope/gradient of a segment, scaled to the x and y ranges that the graph displays.
   *   NOTE:  run can always be considered 1, as the two points of a segment are adjacent.
   *   NOTE: Horizontal lines are 0. Verticle lines are impossible, as x1 must be strictly greater than x2.
   * @returns the slope as a float.
   */
  findSlope(t, r) {
    if (t.end.x <= t.start.x)
      throw new Pm(cu.segStartNotBeforeEnd);
    const n = (t.end.y - t.start.y) * r;
    return n === 0 ? 0 : n / 1;
  }
  /**
   * Calculate the cross product of two points.
   * @param point1 - point object with x and y coordinates
   * @param point2 - point object with x and y coordinates
   * @returns The cross product result as a float
   */
  crossProduct(t, r) {
    return t.x * r.y - t.y * r.x;
  }
  /**
   * Subtracts the second point from the first.
   * @param point1 - point object with x and y coordinates
   * @param point2 - point object with x and y coordinates
   * @returns The subtraction result as a point object
   */
  subtractPoints(t, r) {
    return { x: t.x - r.x, y: t.y - r.y };
  }
  /**
   * Add two points.
   * @param point1 - point object with x and y coordinates
   * @param point2 - point object with x and y coordinates
   * @returns The addition result as a point object
   */
  addPoints(t, r) {
    return {
      x: Number((t.x + r.x).toFixed(3)),
      y: Number((t.y + r.y).toFixed(3))
    };
  }
  getSlopeClass(t) {
    return t > 0 ? "positive" : t < 0 ? "negative" : "zero";
  }
  oppositeSlopes(t, r) {
    return t === "positive" && r === "negative" || r === "positive" && t === "negative";
  }
  // NOTE: if lineAt45DegreesY == startTopY then acuteAngle == obtuseAngle == 90
  findAngle(t, r) {
    const n = this.findLineIntersectionAngle(t, r), i = this.getSlopeClass(t), s = this.getSlopeClass(r);
    if (this.oppositeSlopes(i, s)) {
      const [o, a] = i === "positive" ? [t, r] : [r, t], l = -1 / a;
      if (o > l)
        return 180 - n;
    }
    return n;
  }
  /**
   * Finds the acute angle of intersection between two line segments, using their slopes. 
   *   Note that parallel and colinear lines will return an angle of 0.
   * @param m1 - the numeric value of the first slope.
   * @param m2 - the numeric value of the second slope.
   * @returns the acute angle of intersection in degrees.
   */
  findLineIntersectionAngle(t, r) {
    const n = Math.abs((r - t) / (1 + t * r));
    return af(n);
  }
}, uL = class {
  //screenCoordSysSize: [xScreenSize, yScreenSize], only ratio matters
  constructor(t, r, n, i) {
    const s = r[0] / r[1], o = t[0].length - 1;
    n = n ?? 0, i = i ?? Math.max(...t.map((c) => c.yBounds().end));
    const a = o / (i - n);
    this.yScale = a * s, this.intersections = [], this.overlaps = [], this.parallels = [], this.pairs = [], this.trackingGroups = [], this.trackingZones = [], this.clusters = [], this.clusterOutliers = [];
    const l = t.length;
    if (l !== 1)
      for (let c = 0; c < l - 1; c++) {
        const h = t[c];
        if (h.key === void 0)
          throw new Pm(cu.seriesWithoutKey);
        for (let u = c + 1; u < l; u++) {
          const p = t[u];
          if (p.key === void 0)
            throw new Pm(cu.seriesWithoutKey);
          const y = [h.key, p.key], g = new cL(h, p, this.yScale), b = g.intersectingSegPairs;
          for (let _ = 0; _ < b.length; _++) {
            const S = b[_];
            if (S.relationship === 2)
              continue;
            const R = S.intersection;
            let O;
            const $ = this.generateAngleDetails(S, y, "start");
            let z, F, Y;
            if (R.atRecord) {
              if (_ < b.length - 1 && b[_ + 1].relationship === 2 || _ > 0 && b[_ - 1].relationship === 2)
                continue;
              if (O = {
                // the exact record the intersection took place at
                labelValue: R.crosspoint.x,
                beforeValue: null,
                afterValue: null
              }, R.crosspoint.x === h.points[0].x)
                z = null, F = $, Y = this.getTransversal(S.segs, y, "start");
              else if (R.crosspoint.x === h.points.at(-1).x)
                z = $, F = null, Y = this.getTransversal(S.segs, y, "end");
              else {
                _++;
                const rt = b[_];
                z = $, F = {
                  top: this.getTop(rt.segs, y, "end"),
                  angle: rt.intersection.angle,
                  //TODO: explain cast
                  slope: {
                    [h.key]: rt.slopes.a,
                    [p.key]: rt.slopes.b
                  }
                }, Y = this.getTransversalOnRecord(S.segs, rt.segs, y);
              }
            } else
              O = {
                labelValue: null,
                // the intersection occurred between two record indexes, therefore the prior and post record labels are populated
                beforeValue: S.segs[0].start.x,
                afterValue: S.segs[0].end.x
              }, z = $, F = $, F.top = this.getTop(S.segs, y, "end"), Y = this.getTransversal(S.segs, y, "middle");
            this.intersections.push({
              // the record labels for the intersection
              record: O,
              // the value of the intersection point, in y-axis units
              value: S.intersection.crosspoint.y,
              // TODO: explain cast
              // the list of series labels for all the series that participated in the intersection
              series: y,
              incomingAngle: this.generateAngleMetadata(z, y),
              outgoingAngle: this.generateAngleMetadata(F, y),
              transversality: Y
            });
          }
          let f = this.blankOverlap(y), E = !1;
          for (let _ = 0; _ < b.length; _++) {
            const S = b[_];
            if (S.relationship === 2) {
              const R = S.segs[0].start, O = S.segs[0].end;
              E ? f.datapoints.push([O.x.toString(), O.y]) : (f.incomingAngle = _ === 0 ? null : this.generateAngleMetadata(this.generateAngleDetails(
                b[_ - 1],
                y,
                "start"
              ), y), f.datapoints.push([R.x.toString(), R.y]), f.datapoints.push([O.x.toString(), O.y]), E = !0);
            } else
              E && (f.outgoingAngle = this.generateAngleMetadata(
                this.generateAngleDetails(b[_], y, "end"),
                y
              ), this.overlaps.push(structuredClone(f)), f = this.blankOverlap(y), E = !1);
          }
          E && this.overlaps.push(f);
          const A = g.allSegPairProps;
          let x = this.blankParallel(y), m = !1, w = 0;
          for (let _ = 0; _ < A.length; _++) {
            const S = A[_];
            if (S.relationship === 3 || S.relationship === 4) {
              const R = S.segs[0].start, O = S.segs[0].end;
              w++, S.relationship === 4 && (x.kind = "functional"), m ? x.records.push({ label: O.x.toString() }) : (x.incomingDirection = _ === 0 ? null : this.determineDirection(A[_ - 1], "start"), x.records.push({ label: R.x.toString() }), x.records.push({ label: O.x.toString() }), m = !0);
            } else
              m && (x.outgoingDirection = _ === A.length - 1 ? null : this.determineDirection(A[_ + 1], "end"), this.parallels.push(structuredClone(x)), x = this.blankParallel(y), m = !1);
          }
          m && this.parallels.push(x), this.pairs.push({
            series: y,
            dominant: g.dominant === -1 ? null : y[g.dominant - 1],
            dominantPercent: g.timeOnTop,
            parallelPercent: w / A.length * 100
          });
        }
      }
  }
  getIntersections() {
    return this.intersections;
  }
  getOverlaps() {
    return this.overlaps;
  }
  getParallels() {
    return this.parallels;
  }
  getPairs() {
    return this.pairs;
  }
  getTrackingGroups() {
    return this.trackingGroups;
  }
  getTrackingZones() {
    return this.trackingZones;
  }
  getClusters() {
    return this.clusters;
  }
  getClusterOutliers() {
    return this.clusterOutliers;
  }
  generateAngleDetails(t, r, n) {
    return {
      top: this.getTop(t.segs, r, n),
      angle: t.intersection.angle,
      //TODO: explain cast
      slope: {
        [r[0]]: t.slopes.a,
        [r[1]]: t.slopes.b
      }
    };
  }
  generateAngleMetadata(t, r) {
    return t === null ? null : {
      [r[0]]: {
        [r[1]]: t
      },
      [r[1]]: {
        [r[0]]: t
      }
    };
  }
  blankOverlap(t) {
    return {
      datapoints: [],
      series: t,
      incomingAngle: null,
      outgoingAngle: null
    };
  }
  blankParallel(t) {
    return {
      records: [],
      series: t,
      incomingDirection: null,
      outgoingDirection: null,
      kind: "perfect"
    };
  }
  getTop(t, r, n) {
    const i = this.getTopIndex(t, n);
    return i === null ? null : r[i];
  }
  getTopIndex(t, r) {
    const n = t[0][r].y, i = t[1][r].y;
    return n > i ? 0 : n < i ? 1 : null;
  }
  determineDirection(t, r) {
    const n = Math.abs(t.segs[0].start.y - t.segs[1].start.y), i = Math.abs(t.segs[0].end.y - t.segs[1].end.y);
    return (r === "start" ? i : n) < (r === "start" ? n : i) ? "converge" : "diverge";
  }
  getTransversal(t, r, n) {
    let i, s;
    if (n !== "middle") {
      i = "edge";
      const a = n === "start" ? "end" : "start";
      s = this.getTopIndex(t, a);
    } else {
      s = this.getTopIndex(t, "start");
      const a = this.getTopIndex(t, "end");
      s === a ? i = "touch" : i = "cross";
    }
    const o = +(s === 0);
    return i === "cross" ? {
      kind: i,
      topToBottom: r[s],
      bottomToTop: r[o]
    } : {
      kind: i,
      top: r[s],
      bottom: r[o]
    };
  }
  getTransversalOnRecord(t, r, n) {
    const i = this.getTopIndex(t, "start"), s = this.getTopIndex(r, "end");
    if (i === s) {
      const o = +(i === 0);
      return {
        kind: "touch",
        top: n[i],
        bottom: n[o]
      };
    } else
      return {
        kind: "cross",
        topToBottom: n[i],
        bottomToTop: n[s]
      };
  }
};
function Gtt(e) {
  return e === "" ? "" : e[0].toLowerCase() + e.slice(1);
}
function hL(e, t) {
  let r = Gtt(e);
  return t === "proportion" && r.startsWith("proportion of ") && (r = r.slice(14)), { baseQuantity: r, baseKind: t };
}
function Qtt(e) {
  if (!e.multi)
    return e.getSeriesTheme(e.seriesKeys[0]);
  const t = e.family === "pastry" ? "proportion" : "number";
  return hL(e.title ?? "value", t);
}
function Wtt(e, t) {
  if (!t.multi && t.hasExplictChartTheme())
    return t.getChartTheme();
  const r = t.family === "pastry" ? "proportion" : "number";
  return hL(t.atKey(e).label, r);
}
var qtt = Object.defineProperty, Ytt = Object.getOwnPropertyDescriptor, $i = (e, t, r, n) => {
  for (var i = Ytt(t, r), s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(t, r, i) || i);
  return i && qtt(t, r, i), i;
};
let js = class {
  constructor(t, r) {
    if (this.series = t, this.facetKeys = [], this.dependentFacetKeys = [], this.independentFacetKeys = [], this.seriesKeys = [], this.allPoints = [], this._facetMap = {}, this._facetDatatypeMap = {}, this._facetDisplayTypeMap = {}, this._uniqueValuesForFacet = {}, this._axisFacetKeys = [], this._seriesMap = {}, this._seriesThemeMap = {}, this.series.length === 0)
      throw new Error("models must have at least one series");
    this.multi = this.series.length > 1, this._dataset = r.datasets[0], this.title = this._dataset.title, this.description = this._dataset.description, this.type = this._dataset.type, this.family = b3[this.type], this._theme = this._dataset.chartTheme, this.facetSignatures = this.series[0].facetSignatures, this.facetSignatures.forEach((n) => {
      this.facetKeys.push(n.key), this._uniqueValuesForFacet[n.key] = new KO(), this._facetDatatypeMap[n.key] = n.datatype;
    }), this.facetKeys.forEach((n) => {
      const i = this._dataset.facets[n];
      this._facetDisplayTypeMap[n] = i.displayType, this._facetMap[n] = i, i.variableType === "dependent" && this.dependentFacetKeys.push(n), i.variableType === "independent" && this.independentFacetKeys.push(n);
    }), this.numSeries = this.series.length;
    for (const [n, i] of Nn(this.series)) {
      if (this.seriesKeys.includes(n.key))
        throw new Error("every series in a model must have a unique key");
      if (!YO(
        (s, o) => s.key === o.key && s.datatype === o.datatype,
        n.facetSignatures,
        this.facetSignatures
      ))
        throw new Error("every series in a model must have the same facets");
      this.seriesKeys.push(n.key), this[i] = n, this._seriesMap[n.key] = n, this.allPoints.push(...n), Object.keys(this._uniqueValuesForFacet).forEach((s) => {
        this._uniqueValuesForFacet[s].merge(n.allFacetValues(s));
      }), this._seriesThemeMap[n.key] = n.manifest.theme;
    }
  }
  atKey(t) {
    return this._seriesMap[t] ?? null;
  }
  atKeyAndIndex(t, r) {
    var n;
    return ((n = this.atKey(t)) == null ? void 0 : n[r]) ?? null;
  }
  allFacetValues(t) {
    var r;
    return ((r = this._uniqueValuesForFacet[t]) == null ? void 0 : r.values) ?? null;
  }
  getFacetStats(t) {
    return this._facetDatatypeMap[t] !== "number" ? null : lL(t, this.allPoints);
  }
  getFacetInterval(t) {
    const r = this.getFacetStats(t);
    return r ? { start: r.min.value, end: r.max.value } : null;
  }
  getFacet(t) {
    return this._facetMap[t] ?? null;
  }
  hasExplictChartTheme() {
    return this._theme !== void 0;
  }
  getChartTheme() {
    return this._theme ?? Qtt(this);
  }
  getSeriesTheme(t) {
    return this.atKey(t) === null ? null : this._seriesThemeMap[t] ?? Wtt(t, this);
  }
  isPlaneModel() {
    return !1;
  }
  prevDatapoint(t) {
    const r = this.atKey(t.seriesKey);
    return r === null ? null : r.datapoints.at(t.datapointIndex - 1) ?? null;
  }
  nextDatapoint(t) {
    const r = this.atKey(t.seriesKey);
    return r === null ? null : r.datapoints.at(t.datapointIndex + 1) ?? null;
  }
};
$i([
  hr()
], js.prototype, "atKey");
$i([
  hr()
], js.prototype, "allFacetValues");
$i([
  hr()
], js.prototype, "getFacetStats");
$i([
  hr()
], js.prototype, "getFacetInterval");
$i([
  hr()
], js.prototype, "getFacet");
$i([
  hr()
], js.prototype, "hasExplictChartTheme");
$i([
  hr()
], js.prototype, "getChartTheme");
$i([
  hr()
], js.prototype, "getSeriesTheme");
let cc = class extends js {
  /*public readonly xs: ScalarMap[X][];
  public readonly ys: number[];*/
  constructor(t, r, n, i = uL, s = !0) {
    var o;
    if (super(t, r), this.seriesAnalyzerConstructor = n, this.pairAnalyzerConstructor = i, this._useWorker = s, this.intersections = [], this.clusters = [], this.clusterOutliers = [], this.trackingGroups = [], this.trackingZones = [], this._seriesPairAnalyzer = null, this._seriesLineMap = {}, this._seriesAnalysisDone = !1, this.grouped = this._dataset.seriesRelations === "grouped", this.facetKeys.forEach((a) => {
      const l = this._dataset.facets[a];
      l.displayType.type === "axis" && (l.displayType.orientation === "horizontal" ? this.horizontalAxisKey = a : l.displayType.orientation === "vertical" && (this.verticalAxisKey = a));
    }), this.dependentAxisKey = this.dependentFacetKeys[0], this.independentAxisKey = this.independentFacetKeys[0], (this.horizontalAxisKey === void 0 || this.verticalAxisKey === void 0) && (this.horizontalAxisKey = this.independentAxisKey, this.verticalAxisKey = this.dependentAxisKey), this.family === "line" || this.family === "bar" || this.family === "histogram") {
      for (const a of this.series)
        this._seriesLineMap[a.key] = a.getActualLine();
      if (this.multi) {
        const a = this.getAxisInterval(this.getAxisOrientation("dependent"));
        this._seriesPairAnalyzer = new this.pairAnalyzerConstructor(
          Object.values(this._seriesLineMap),
          [1, 1],
          //FIXME: get actual screen size
          a.start,
          a.end
        ), this.intersections = this._seriesPairAnalyzer.getIntersections(), this.clusters = this._seriesPairAnalyzer.getClusters(), this.clusterOutliers = this._seriesPairAnalyzer.getClusterOutliers(), this.trackingGroups = this._seriesPairAnalyzer.getTrackingGroups(), this.trackingZones = this._seriesPairAnalyzer.getTrackingZones();
      }
      [this.seriesScaledValues, this.seriesStatsScaledValues, this.intersectionScaledValues] = Mtt(this.series, this.intersections, (o = this.getAxisFacet("vert")) == null ? void 0 : o.multiplier);
    }
  }
  async generateSeriesAnalyses() {
    if (this._seriesAnalysisDone)
      return;
    const t = new this.seriesAnalyzerConstructor();
    this._seriesAnalysisMap = {};
    for (const r in this._seriesLineMap)
      this._seriesAnalysisMap[r] = await t.analyzeSeries(
        this._seriesLineMap[r],
        {
          useWorker: this._useWorker,
          yAxis: this.getAxisInterval(this.getAxisOrientation("dependent"))
        }
      );
    this._seriesAnalysisDone = !0;
  }
  atKey(t) {
    return super.atKey(t);
  }
  getAxisFacet(t) {
    return t === "horiz" ? this.horizontalAxisKey ? this._facetMap[this.horizontalAxisKey] : null : this.verticalAxisKey ? this._facetMap[this.verticalAxisKey] : null;
  }
  getAxisOrientation(t) {
    return (t === "dependent" ? this.dependentAxisKey : this.independentAxisKey) === this.verticalAxisKey ? "vert" : "horiz";
  }
  getAxisInterval(t) {
    var r, n, i, s, o, a;
    const l = t === "horiz" ? this.horizontalAxisKey : this.verticalAxisKey, c = this.getFacetInterval(l);
    if (!c)
      return null;
    let { start: h, end: u } = c;
    const p = ((i = (n = (r = this._dataset.settings) == null ? void 0 : r.axis) == null ? void 0 : n[l]) == null ? void 0 : i.minValue) ?? "unset", y = ((a = (o = (s = this._dataset.settings) == null ? void 0 : s.axis) == null ? void 0 : o[l]) == null ? void 0 : a.maxValue) ?? "unset";
    return p !== "unset" && (h = p), y !== "unset" && (u = y), { start: h, end: u };
  }
  async getSeriesAnalysis(t) {
    return this.type === "scatter" || !this.seriesAnalyzerConstructor || !this.seriesKeys.includes(t) ? null : (await this.generateSeriesAnalyses(), this._seriesAnalysisMap[t]);
  }
  isPlaneModel() {
    return !0;
  }
  getChordAt(t, r) {
    const n = this._facetDatatypeMap[t];
    return n === void 0 || r.datatype() !== n ? null : this.series.map((i) => i.datapointAt(t, r)).filter((i) => i !== null);
  }
};
$i([
  hr()
], cc.prototype, "atKey");
$i([
  hr()
], cc.prototype, "getAxisFacet");
$i([
  hr()
], cc.prototype, "getAxisOrientation");
$i([
  hr()
], cc.prototype, "getAxisInterval");
$i([
  hr()
], cc.prototype, "getSeriesAnalysis");
function V0(e) {
  return Object.keys(e.facets).map((t) => ({ key: t, datatype: e.facets[t].datatype }));
}
function pL(e) {
  const t = Object.entries(e.facets).filter(([n, i]) => i.displayType.type === "axis").filter(([n, i]) => i.variableType === "independent").map(([n, i]) => n).at(0), r = Object.entries(e.facets).filter(([n, i]) => i.displayType.type === "axis").filter(([n, i]) => i.variableType === "dependent").map(([n, i]) => n).at(0);
  return { independentAxisKey: t, dependentAxisKey: r };
}
function Ktt(e) {
  const t = e.datasets[0];
  if (t.data.source !== "inline")
    throw new Error("only manifests with inline data can use this method.");
  const r = V0(t), n = t.series.map(
    (i) => Vtt(i, r)
  );
  return new js(n, e);
}
function Ztt(e, t) {
  const r = V0(t.datasets[0]), n = Object.keys(e).map((i) => {
    const s = t.datasets[0].series.filter((o) => o.key === i)[0];
    return new Lo(s, e[i], r);
  });
  return new js(n, t);
}
function Jtt(e, t, r, n) {
  const i = e.datasets[0];
  if (i.data.source !== "inline")
    throw new Error("only manifests with inline data can use this function.");
  const { independentAxisKey: s, dependentAxisKey: o } = pL(i);
  if (!s || !o)
    throw new Error("only manifests with 2D axes can use this function.");
  const a = V0(i), l = i.series.map(
    (c) => Utt(c, a, s, o)
  );
  return new cc(l, e, t, r, n);
}
function Xtt(e, t, r, n, i) {
  const s = t.datasets[0], { independentAxisKey: o, dependentAxisKey: a } = pL(s);
  if (!o || !a)
    throw new Error("only manifests with 2D axes can use this function.");
  const l = V0(s), c = Object.keys(e).map((h) => {
    const u = s.series.filter((p) => p.key === h)[0];
    return new A2(u, e[h], l, o, a);
  });
  return new cc(c, t, r, n, i);
}
let Q9 = class {
  /**
   * Constructor
   * @param {*} options 
   * @constructor
   */
  constructor(t) {
    this._options = t;
  }
  /**
   * Initializes the module and calls the different methods in order.
   * @private
   * @memberOf module:@fizz/svmjs
   */
  async _init() {
  }
  // data is NxD array of floats. labels are 1 or -1.
  train(t, r, n) {
    this.data = t, this.labels = r, n = n || {};
    const i = n.C || 1, s = n.tol || 1e-4, o = n.alphatol || 1e-7, a = n.maxiter || 1e4, l = n.numpasses || 10;
    let c = wv;
    if (this.kernelType = "linear", "kernel" in n)
      if (typeof n.kernel == "string") {
        if (n.kernel === "linear" && (this.kernelType = "linear", c = wv), n.kernel === "rbf") {
          const g = n.rbfsigma || 0.5;
          this.rbfSigma = g, this.kernelType = "rbf", c = W9(g);
        }
      } else
        this.kernelType = "custom", c = n.kernel;
    this.kernel = c, this.N = t.length;
    const h = this.N;
    if (this.D = t[0].length, this.D, this.alpha = eet(h), this.b = 0, this.usew_ = !1, n.memoize) {
      this.kernelResults = new Array(h);
      for (let g = 0; g < h; g++) {
        this.kernelResults[g] = new Array(h);
        for (let b = 0; b < h; b++)
          this.kernelResults[g][b] = c(t[g], t[b]);
      }
    }
    let u = 0, p = 0;
    for (; p < l && u < a; ) {
      let g = 0;
      for (let b = 0; b < h; b++) {
        const f = this.marginOne(t[b]) - r[b];
        if (r[b] * f < -s && this.alpha[b] < i || r[b] * f > s && this.alpha[b] > 0) {
          let E = b;
          for (; E === b; ) E = tet(0, this.N);
          const A = this.marginOne(t[E]) - r[E];
          let x = this.alpha[b], m = this.alpha[E], w = 0, _ = i;
          if (r[b] === r[E] ? (w = Math.max(0, x + m - i), _ = Math.min(i, x + m)) : (w = Math.max(0, m - x), _ = Math.min(i, i + m - x)), Math.abs(w - _) < 1e-4) continue;
          const S = 2 * this.kernelResult(b, E) - this.kernelResult(b, b) - this.kernelResult(E, E);
          if (S >= 0) continue;
          let R = m - r[E] * (f - A) / S;
          if (R > _ && (R = _), R < w && (R = w), Math.abs(m - R) < 1e-4) continue;
          this.alpha[E] = R;
          const O = x + r[b] * r[E] * (m - R);
          this.alpha[b] = O;
          const $ = this.b - f - r[b] * (O - x) * this.kernelResult(b, b) - r[E] * (R - m) * this.kernelResult(b, E), z = this.b - A - r[b] * (O - x) * this.kernelResult(b, E) - r[E] * (R - m) * this.kernelResult(E, E);
          this.b = 0.5 * ($ + z), O > 0 && O < i && (this.b = $), R > 0 && R < i && (this.b = z), g++;
        }
      }
      u++, g == 0 ? p++ : p = 0;
    }
    if (this.kernelType === "linear") {
      this.w = new Array(this.D);
      for (let g = 0; g < this.D; g++) {
        let b = 0;
        for (let f = 0; f < this.N; f++)
          b += this.alpha[f] * r[f] * t[f][g];
        this.w[g] = b, this.usew_ = !0;
      }
    } else {
      const g = [], b = [], f = [];
      for (let E = 0; E < this.N; E++)
        this.alpha[E] > o && (g.push(this.data[E]), b.push(this.labels[E]), f.push(this.alpha[E]));
      this.data = g, this.labels = b, this.alpha = f, this.N = this.data.length;
    }
    const y = {};
    return y.iters = u, y;
  }
  // inst is an array of length D. Returns margin of given example
  // this is the core prediction function. All others are for convenience mostly
  // and end up calling this one somehow.
  marginOne(t) {
    let r = this.b;
    if (this.usew_)
      for (let n = 0; n < this.D; n++)
        r += t[n] * this.w[n];
    else
      for (let n = 0; n < this.N; n++)
        r += this.alpha[n] * this.labels[n] * this.kernel(t, this.data[n]);
    return r;
  }
  predictOne(t) {
    return this.marginOne(t) > 0 ? 1 : -1;
  }
  // data is an NxD array. Returns array of margins.
  margins(t) {
    const r = t.length, n = new Array(r);
    for (let i = 0; i < r; i++)
      n[i] = this.marginOne(t[i]);
    return n;
  }
  kernelResult(t, r) {
    return this.kernelResults ? this.kernelResults[t][r] : this.kernel(this.data[t], this.data[r]);
  }
  // data is NxD array. Returns array of 1 or -1, predictions
  predict(t) {
    const r = this.margins(t);
    for (let n = 0; n < r.length; n++)
      r[n] = r[n] > 0 ? 1 : -1;
    return r;
  }
  // THIS FUNCTION IS NOW DEPRECATED. WORKS FINE BUT NO NEED TO USE ANYMORE. 
  // LEAVING IT HERE JUST FOR BACKWARDS COMPATIBILITY FOR A WHILE.
  // if we trained a linear svm, it is possible to calculate just the weights and the offset
  // prediction is then yhat = sign(X * w + b)
  getWeights() {
    const t = new Array(this.D);
    for (let r = 0; r < this.D; r++) {
      let n = 0;
      for (let i = 0; i < this.N; i++)
        n += this.alpha[i] * this.labels[i] * this.data[i][r];
      t[r] = n;
    }
    return { w: t, b: this.b };
  }
  toJSON() {
    if (this.kernelType === "custom")
      return console.log("Can't save this SVM because it's using custom, unsupported kernel..."), {};
    const t = {};
    return t.N = this.N, t.D = this.D, t.b = this.b, t.kernelType = this.kernelType, this.kernelType === "linear" && (t.w = this.w), this.kernelType === "rbf" && (t.rbfSigma = this.rbfSigma, t.data = this.data, t.labels = this.labels, t.alpha = this.alpha), t;
  }
  fromJSON(t) {
    this.N = t.N, this.D = t.D, this.b = t.b, this.kernelType = t.kernelType, this.kernelType === "linear" ? (this.w = t.w, this.usew_ = !0, this.kernel = wv) : this.kernelType == "rbf" ? (this.rbfSigma = t.rbfSigma, this.kernel = W9(this.rbfSigma), this.data = t.data, this.labels = t.labels, this.alpha = t.alpha) : console.log("ERROR! unrecognized kernel type." + this.kernelType);
  }
};
function W9(e) {
  return function(t, r) {
    let n = 0;
    for (let i = 0; i < t.length; i++)
      n += (t[i] - r[i]) * (t[i] - r[i]);
    return Math.exp(-n / (2 * e * e));
  };
}
function wv(e, t) {
  let r = 0;
  for (let n = 0; n < e.length; n++)
    r += e[n] * t[n];
  return r;
}
function tet(e, t) {
  return Math.floor(Math.random() * (t - e) + e);
}
function eet(e) {
  const t = new Array(e);
  for (let r = 0; r < e; r++)
    t[r] = 0;
  return t;
}
class ret {
  constructor(t) {
    t && (this.df = t);
  }
  LogGamma(t) {
    const r = 1 + 76.18009173 / t - 86.50532033 / (t + 1) + 24.01409822 / (t + 2) - 1.231739516 / (t + 3) + 0.00120858003 / (t + 4) - 536382e-11 / (t + 5);
    return (t - 0.5) * Math.log(t + 4.5) - (t + 4.5) + Math.log(r * 2.50662827465);
  }
  Betinc(t, r, n) {
    let i = 0, s = 1, o = 1, a = 1, l = 0, c = 0, h;
    for (; Math.abs((o - c) / o) > 1e-5; )
      c = o, h = -(r + l) * (r + n + l) * t / (r + 2 * l) / (r + 2 * l + 1), i = o + h * i, s = a + h * s, l = l + 1, h = l * (n - l) * t / (r + 2 * l - 1) / (r + 2 * l), o = i + h * o, a = s + h * a, i = i / a, s = s / a, o = o / a, a = 1;
    return o / r;
  }
  cumulativeProbability(t, r) {
    r || (r = this.df);
    let n;
    if (r <= 0)
      console.error("Degrees of freedom must be positive");
    else {
      const i = r / 2, s = i + 0.5, o = r / (r + t * t), a = Math.exp(this.LogGamma(s) - this.LogGamma(0.5) - this.LogGamma(i) + i * Math.log(o) + 0.5 * Math.log(1 - o));
      let l;
      o < (i + 1) / (s + 2) ? l = a * this.Betinc(o, i, 0.5) : l = 1 - a * this.Betinc(1 - o, 0.5, i), t < 0 ? n = l / 2 : n = 1 - l / 2;
    }
    return n = Math.round(n * 1e5) / 1e5, n;
  }
  invCumulativeProbability(t, r) {
    if (r || (r = this.df), t >= 0.5) {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(o, r) >= t); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(n + o / 100) >= t); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(i + o / 1e4) >= t); o += 1)
        s = i + o / 1e4;
      return s;
    } else {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-o, r) <= t); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-n - o / 100) <= t); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-i - o / 1e4) <= t); o += 1)
        s = i + o / 1e4;
      return -s;
    }
  }
}
class net {
  constructor(t, r) {
    this.df1 = t, this.df2 = r, this.EPSILON = 1e-10;
  }
  L504(t, r, n, i) {
    const s = t * r / (t * r + n), o = Math.sqrt(s), a = Math.log(o), l = Math.sqrt(1 - s), c = Math.log(l);
    let h = 1 - 2 * Math.atan(o / Math.sqrt(-o * o + 1)) / Math.PI, u = 0;
    if (n != 1) {
      const p = Math.log(2 * o / Math.PI);
      if (h -= Math.exp(p + c), n != 3) {
        const y = Math.floor((n - 3) / 2);
        for (let g = 1; g <= y; g++) {
          const b = 2 * g + 1;
          u += Math.log((b - 1) / b);
          const f = u + c * b + p;
          f > -78.4 && (h -= Math.exp(f));
        }
      }
    }
    if (t != 1) {
      let p = u;
      if (n > 1 && (p += Math.log(n - 1)), p += Math.log(2 / Math.PI) + a + c * n, p > -78.4 && (h += Math.exp(p)), t != 3) {
        const y = Math.floor((t - 3) / 2);
        u = 0;
        for (let g = 1; g <= y; g++) {
          const b = g * 2 + 1;
          u += Math.log((n + b - 2) / b);
          const f = u + a * (b - 1) + p;
          f > -78.4 && (h += Math.exp(f));
        }
      }
    }
    return h;
  }
  L401(t, r, n, i) {
    const s = t * r / (t * r + n), o = Math.log(s);
    let a = 0;
    const l = Math.log(1 - s) * n / 2;
    if (l > -78.4 && (a = Math.exp(l)), t != 2) {
      const c = Math.floor(t / 2 - 1);
      let h = 0;
      for (let u = 1; u <= c; u++) {
        const p = 2 * u;
        h += Math.log(n + p - 2) - Math.log(p) + o, h + l > -78.4 && (a += Math.exp(h + l));
      }
    }
    return i == 1 && (a = 1 - a), a;
  }
  ProbF(t, r, n) {
    let i = n, s = t, o = r, a = 0;
    return Math.floor(s / 2) * 2 == s ? this.L401(s, i, o, a) : Math.floor(o / 2) * 2 != o ? this.L504(s, i, o, a) : (i = 1 / i, s = r, o = t, a = 1, this.L401(s, i, o, a));
  }
  cumulativeProbability(t) {
    if (this.df1 > 0.01 && this.df2 > 0.01 && t > this.EPSILON)
      return 1 - this.ProbF(this.df1, this.df2, t);
    console.error("df1, df2, and F must be numbers greater than 0.");
  }
}
const q9 = [
  1.4142024783770517,
  1.7285350177358225,
  1.975558322080508,
  2.165309701618668,
  2.3223314597870495,
  2.43666896580902,
  2.539575597098922,
  2.629725259756139,
  2.6946351910160824,
  2.7571690989287108,
  2.82429436007275,
  2.86976990061697,
  2.911181488216127,
  2.9562785307147474,
  2.991043137459134,
  3.031892332910388,
  3.0390882779033968,
  3.084150339177206,
  3.1068126593538534,
  3.1377944664764175,
  3.1526730795266236,
  3.1856353298858746,
  3.1923941584623616,
  3.2232152987382205,
  3.2423279731889063,
  3.2672678614514434,
  3.28815589678312,
  3.306598538588182,
  3.3169876930034423,
  3.3426537588982366,
  3.338808432731316,
  3.3551800156910674,
  3.3677857453596176,
  3.3801704122612546,
  3.3894353098402292,
  3.4103476461664384,
  3.420758782190955,
  3.4234022273067235,
  3.4377591100482245,
  3.4495251663075597,
  3.45784133640642,
  3.4655169406594553,
  3.499664208072353,
  3.5075228374867624,
  3.4963470841468247,
  3.5194522982765517,
  3.50887461478777,
  3.517883433127914,
  3.527130862311399,
  3.5478465903324174,
  3.5524335509017972,
  3.5453727082671342,
  3.556173872494318,
  3.557087103502499,
  3.589369632641309,
  3.5859140345184524,
  3.572323092223869,
  3.6004177405174853,
  3.6100996977289306,
  3.601519301860006,
  3.606430559116003,
  3.623484959486857,
  3.6110156117453704,
  3.6398254610166214,
  3.6485762129590045,
  3.6369984456518214,
  3.6420217039991707,
  3.6515502039986543,
  3.6534596174533878,
  3.6659253039539754,
  3.678204062277477,
  3.673013776537585,
  3.6873396028854244,
  3.677549442478252,
  3.672393117945697,
  3.694338890356745,
  3.698559967922895,
  3.7088383298959364,
  3.6960214124422732,
  3.6962804693332054,
  3.7259363906151113,
  3.6945941836261005,
  3.7123614650012637,
  3.7266182166220743,
  3.726433940762783,
  3.7262288936328507,
  3.73068538678121,
  3.7464587039431216,
  3.734498500854471,
  3.7666496106093086,
  3.7577811376185797,
  3.755885408241557,
  3.7653220485067256,
  3.759612302718265,
  3.750000422234468,
  3.776893666562007,
  3.7656945047078376
], iet = [
  [
    12.92876788710003,
    18.669362102797844,
    20.708185574014465
  ],
  [
    12.893379950402329,
    17.838738753100234,
    20.009145166260716
  ],
  [
    12.567620517329296,
    17.39284624657391,
    19.327403214291675
  ],
  [
    12.44012368783225,
    17.159725181804923,
    19.031999514734718
  ],
  [
    12.258810404004157,
    16.643626920880678,
    18.520644599539708
  ],
  [
    12.490936102639248,
    17.07031258707699,
    19.26763537042604
  ],
  [
    12.230582644506537,
    16.8611702133535,
    19.04138451550924
  ],
  [
    12.285890759032673,
    16.72028694459538,
    18.998686524252154
  ],
  [
    12.265830882960202,
    16.861313711298223,
    19.01741086021432
  ],
  [
    12.221592293386445,
    16.856569952690425,
    18.679522968116675
  ],
  [
    12.207863926087379,
    16.466760433982508,
    18.327798576854196
  ],
  [
    12.23047144884862,
    16.604698640112442,
    18.778749913667404
  ],
  [
    12.310880515319493,
    16.75477031068603,
    18.61887265606582
  ],
  [
    12.09088910593483,
    16.680683526842817,
    19.10909766756724
  ],
  [
    12.28969274656454,
    16.494346369998592,
    18.555323182091747
  ],
  [
    12.351479909044647,
    17.231085800266705,
    19.12315903511468
  ],
  [
    12.232654018508402,
    17.03319706813043,
    19.36238761950663
  ],
  [
    12.24175327982118,
    17.01249507542771,
    19.29261479388184
  ],
  [
    12.240819762926595,
    16.958668959199564,
    18.703343358289676
  ],
  [
    12.325576191647679,
    16.741637280941735,
    18.706270613293825
  ],
  [
    12.29079270883332,
    16.83580567418819,
    18.885633182327588
  ],
  [
    12.105579742321321,
    16.801481191805877,
    18.74917129995002
  ],
  [
    12.241506985184987,
    16.421107838741005,
    18.51907643327747
  ],
  [
    12.22772321442409,
    16.76637698315794,
    18.59944945667253
  ],
  [
    12.146827427372807,
    16.504491710455042,
    18.624893334253915
  ],
  [
    12.099825423105056,
    16.517727777727934,
    18.389759370770282
  ],
  [
    12.241793182544008,
    16.69983166753318,
    18.199273554649118
  ],
  [
    12.133827646762477,
    16.937161124066893,
    18.865979715097055
  ],
  [
    12.014897172400497,
    16.64164656731907,
    18.52796800753582
  ],
  [
    12.03194886183511,
    16.448427247716083,
    18.360165754021324
  ],
  [
    12.060576333659972,
    16.972556324548336,
    18.909884009510286
  ],
  [
    12.130919558394593,
    16.846538605893603,
    18.974105413083418
  ],
  [
    12.167013704292577,
    16.962535224497064,
    18.952800614645692
  ],
  [
    12.307745895005242,
    16.69776947316106,
    18.73020815902911
  ],
  [
    12.03703814065202,
    16.744259233990512,
    19.40987043616083
  ],
  [
    12.23158902787162,
    16.992381220472012,
    19.23258888861058
  ],
  [
    12.30313545083327,
    16.80175925410746,
    18.88639508508212
  ],
  [
    12.216506652052612,
    16.95978747527697,
    19.07369251354378
  ],
  [
    12.289633178985905,
    17.037358965358983,
    18.978000598844293
  ],
  [
    12.114391564747471,
    16.353909897952686,
    18.35011390560238
  ],
  [
    12.208213936084457,
    16.12841887472018,
    18.239736208276152
  ],
  [
    12.326886082604242,
    16.87043068171149,
    18.900551155302647
  ],
  [
    12.24602935198574,
    16.740078446411406,
    18.57610242578182
  ],
  [
    12.154508067768113,
    16.70375179351137,
    18.84458221820561
  ],
  [
    12.053162931004179,
    16.63616478058826,
    18.764716631834734
  ],
  [
    12.242031428895839,
    16.870439498648583,
    18.946299240629287
  ],
  [
    12.172676093456305,
    16.57616403586386,
    18.901254056077153
  ],
  [
    12.234873290793098,
    16.849691971911838,
    19.020953521536004
  ],
  [
    12.307356477970162,
    17.070904468883104,
    19.124634537613513
  ],
  [
    12.258316325281726,
    16.98236293001686,
    19.362641577913156
  ],
  [
    12.236258781616636,
    16.835948685325945,
    18.872615556171525
  ],
  [
    12.218214829379882,
    16.72052856570416,
    18.576319895769533
  ],
  [
    12.266452802779268,
    17.001974682521503,
    19.397512454689892
  ],
  [
    12.142229768023105,
    16.760040761542093,
    18.73221439686166
  ],
  [
    12.362128316602698,
    16.779263655428466,
    18.690631800055144
  ],
  [
    12.23248525532616,
    16.78957578482738,
    19.290187946573045
  ],
  [
    12.194978246692179,
    16.66872414977679,
    18.38065055971982
  ],
  [
    12.364346090585878,
    16.78308783969924,
    18.787944141467552
  ],
  [
    12.213523054233821,
    16.745070120633624,
    18.779462580096293
  ],
  [
    12.120562728816676,
    16.72947148909386,
    18.540581750860838
  ],
  [
    12.147441684285011,
    16.362711939455345,
    18.5928909502196
  ],
  [
    12.349013958141011,
    17.115157968739332,
    19.074081167238724
  ],
  [
    12.169896474381117,
    16.779107284309674,
    19.095614865501265
  ],
  [
    12.212332899050487,
    17.15220159015151,
    19.18433312800504
  ],
  [
    12.427266331944576,
    17.19802901185036,
    19.08282870552354
  ],
  [
    12.208415329256482,
    16.698611123996386,
    18.437039290733527
  ],
  [
    12.150857540075965,
    16.747967767000077,
    18.522105916017864
  ],
  [
    12.185133777587764,
    16.716543085287885,
    18.75368115517968
  ],
  [
    12.202518998568662,
    16.695350960024488,
    18.766605345681214
  ],
  [
    12.293516845096802,
    16.848652152520355,
    18.73818931670063
  ],
  [
    12.264328782539446,
    16.898700733974184,
    18.91736903501125
  ],
  [
    12.283442238272498,
    16.79113139749197,
    18.762641899116595
  ],
  [
    12.288571666812464,
    16.947956362708894,
    19.26608413111616
  ],
  [
    12.199938820517241,
    16.73882101164454,
    18.649824259785902
  ],
  [
    12.281399931209005,
    16.74455321404603,
    18.993644280454557
  ],
  [
    11.978508088635845,
    16.751385791647305,
    19.067980524092103
  ],
  [
    12.352190443412464,
    17.002035355108024,
    18.910150024775536
  ],
  [
    12.11299191492474,
    16.85211409238294,
    19.21553533835868
  ],
  [
    12.252946905996852,
    16.77267825853487,
    18.758060103809566
  ],
  [
    12.253428278525488,
    17.05117162481038,
    19.437396636388712
  ],
  [
    12.365555609949542,
    17.217797222036967,
    19.557725250431925
  ],
  [
    12.446856234792692,
    17.13219895129848,
    19.189823799758685
  ],
  [
    12.378913383861864,
    16.69420382596318,
    18.614200176451167
  ],
  [
    12.209646506057828,
    17.049298470931937,
    19.21471558598783
  ],
  [
    12.07451389049845,
    16.52146599860598,
    18.646538442813565
  ],
  [
    12.242992826481506,
    17.118044327693312,
    19.109033882498373
  ],
  [
    12.031588638774476,
    16.440292876584916,
    18.365137461548116
  ],
  [
    12.256327863966023,
    16.937124809805663,
    19.055448755862216
  ],
  [
    12.152502866561859,
    16.51661734703226,
    18.292867488178068
  ],
  [
    12.240166584135661,
    17.01144955716148,
    19.269980514360167
  ],
  [
    12.288087364649998,
    16.9124768573556,
    18.78496409520197
  ],
  [
    12.261031067472498,
    17.080660923120398,
    18.993376274931116
  ],
  [
    12.149516099981419,
    16.429960356660846,
    18.693814658804264
  ],
  [
    12.189972968413274,
    16.360091390089806,
    18.372140642711813
  ],
  [
    12.247713311640034,
    16.85901876289993,
    18.747152105084417
  ],
  [
    12.235996387439796,
    16.719425800548546,
    18.73463631602104
  ]
], uu = {
  minLen3: 0,
  minLen6: 1,
  tooManyPoints: 2
}, set = {
  [uu.minLen3]: "line must have at least 3 points",
  [uu.minLen6]: "line must have at least 6 points",
  [uu.tooManyPoints]: "line contains too many points"
};
let S2 = class extends Error {
  constructor(t) {
    super(set[t]), this.code = t;
  }
};
function oet(e, t, r) {
  return e.map((n) => n - t).map((n) => n / r);
}
function xv(e) {
  const t = e.bestFit, r = t.rss();
  return {
    se: Math.sqrt(r / e.length),
    rss: r,
    resid: t.residuals,
    slope: t.slope,
    inter: t.intercept
  };
}
function aet(e) {
  if (e.length < 3)
    throw new S2(uu.minLen3);
  const t = NX(e.points.map((r) => r.x), e.points.map((r) => r.y));
  return Number.isNaN(t) ? 1 : Math.abs(t);
}
function cet(e) {
  const t = e.length;
  if (t < 6)
    throw new S2(uu.minLen6);
  const { se: r } = xv(e);
  if (r === 0)
    return { feats: [0, 0, 0] };
  const n = iet[t - 6], i = [];
  for (let a = 2; a < t - 3; a++) {
    const l = a + 1, { se: c } = xv(e.slice(0, l)), { se: h } = xv(e.slice(l));
    i.push(c ** l * h ** (t - l) / r ** t);
  }
  const s = Math.min(...i), o = -Math.log(s);
  return {
    feats: n.map((a) => o > a ? 1 : 0),
    logLambda: o,
    t: i.indexOf(s) + 2
  };
}
function uet(e) {
  const t = e.length;
  if (t < 6)
    throw new S2(uu.minLen6);
  const r = e.bestFit.rss(), n = [0, 0];
  if (r === 0)
    return { feats: n };
  const i = [], s = e.points.map((f) => f.x), o = e.points.map((f) => f.y), a = (f) => f.reduce((E, A) => E + A), l = (f, E) => a(f.map((A, x) => A * E[x])), c = [], h = [];
  for (let f = 2; f < t - 3; f++) {
    const E = s.slice(0, f + 1), A = o.slice(0, f + 1), x = a(E), m = a(A), w = l(E, A), _ = a(E.map((st) => st ** 2)), S = w - x * m / (f + 1), R = _ - x ** 2 / (f + 1), O = S / R, $ = wo(A) - O * wo(E), z = s[f], F = $ + O * z, Y = s.slice(f + 1), rt = o.slice(f + 1), at = a(Y), pt = a(rt), vt = l(Y, rt), _t = a(Y.map((st) => st ** 2)), Ct = pt - (e.length - (f + 1)) * F, It = at - (e.length - (f + 1)) * z, jt = Ct / It, lt = vt / at - jt * _t / at, L = E.map((st) => $ + O * st), D = a(E.map((st, X) => (A[X] - L[X]) ** 2)), tt = Y.map((st) => lt + jt * st), et = a(Y.map((st, X) => (rt[X] - tt[X]) ** 2));
    i.push(D + et), c.push({ a1: $, b1: O, a2: lt, b2: jt }), h.push(L.concat(tt));
  }
  const u = Math.min(...i);
  let p, y = (r - u) / 2 / (u / (t - 4));
  y <= 0 && (y = 1e-3), y === 1 / 0 ? p = 0 : p = 1 - new net(2, t - 4).cumulativeProbability(y);
  const g = i.indexOf(u) + 2, b = { rssMin: u, rssl: r, F: y, p, split: g, params: c[g - 2], yhats: h[g - 2] };
  return p < 0.1 && (n[0] = 1), p < 0.05 && (n[1] = 1), { feats: n, debug: b };
}
function het(e) {
  const t = e.bestFit.residuals.map(Math.sign), { r, nminus: n, nplus: i } = t.reduce(
    (a, l, c) => (c && l !== t[c - 1] && a.r++, l || (l = 1), a[l === 1 ? "nplus" : "nminus"]++, a),
    { r: 1, nminus: 0, nplus: 0 }
  ), s = 2 * i * n / (i + n) + 1, o = Math.abs(Math.sqrt(
    2 * i * n * (2 * i * n - i - n) / (Math.pow(i + n, 2) * (i + n - 1))
  ));
  return { feats: [r < s - o / 2 ? 1 : r > s + o / 2 ? -1 : 0, r, s, o, Math.abs(r - s) / s] };
}
function pet(e) {
  const t = e.length;
  if (t > q9.length + 4)
    throw new S2(uu.tooManyPoints);
  const r = e.bestFit.residuals, n = Math.sqrt(
    r.map((p) => p ** 2 / (t - 2)).reduce((p, y) => p + y)
  );
  if (n === 0)
    return [-1, 0];
  const i = e.points.map((p) => p.x), s = wo(i), o = i.map((p) => (p - s) ** 2), a = o.reduce((p, y) => p + y), l = o.map((p) => n * Math.sqrt(1 - 1 / t - p / a)), c = r.map((p, y) => p / l[y]).map((p) => Math.abs(p)), h = Math.max(...c), u = q9[t - 4];
  return [h, c.filter((p) => p > u).length];
}
function det(e) {
  const t = e.bestFit.rss(), r = e.points.at(-1).x - e.points[0].x, n = Math.sqrt(t / e.length) / r, i = Math.atan(e.bestFit.slope);
  return [n, n * Math.cos(i) ** 2];
}
class fet {
  /**
   * Compute non-standardized feature columns from examples.
   * @param examples - Training examples
   * @returns Feature columns
   */
  computeFeatures(t) {
    function r(i, s) {
      const o = i[0].length, a = {};
      for (let l = 0; l < o; l++)
        a[`${s}${l + 1}`] = [];
      for (const l of i)
        l.forEach((c, h) => a[`${s}${h + 1}`].push(c));
      return a;
    }
    const n = {
      absCorrCoeff: t.map((i) => aet(i.data)),
      nPoints: t.map((i) => i.data.length),
      ...r(t.map((i) => det(i.data)), "scaledS"),
      nPointsChart: t.map((i) => i.chartLength),
      chartPct: t.map((i) => (i.data.length - 1) / (i.chartLength - 1))
    };
    return t[0].data.length >= 6 && Object.assign(
      n,
      r(t.map((i) => cet(i.data).feats), "qTest"),
      r(t.map((i) => uet(i.data).feats), "fTest"),
      r(t.map((i) => het(i.data).feats), "runsTest"),
      r(t.map((i) => pet(i.data)), "outlierTest")
    ), n;
  }
  /**
   * Standardize feature columns.
   * @param featCols - Non-standardized feature columns
   * @param featStats - Feature column statistics
   * @returns Standardized feature columns
   */
  standardizeFeatures(t, r) {
    const n = {};
    for (const [i, s] of Object.entries(t)) {
      const o = r[i];
      n[i] = o ? oet(s, o.mean, o.stdDev) : s;
    }
    return n;
  }
  /**
   * Assemble feature matrix from standardized feature columns.
   * @param stdFeatCols - Standardized feature columns.
   * @returns Feature matrix (array of example rows)
   */
  assembleMatrix(t) {
    const r = Object.values(t)[0].length, n = lu(r, (i) => []);
    for (const [i, s] of Object.entries(t))
      s.forEach((o, a) => n[a].push(o));
    return n;
  }
  /**
   * Compute feature matrix from examples.
   * @param examples - Training examples
   * @param featStats - Feature column statistics
   * @returns Feature matrix (array of example rows)
   */
  computeMatrix(t, r) {
    const n = this.computeFeatures(t), i = this.standardizeFeatures(n, r);
    return this.assembleMatrix(i);
  }
}
const dL = {
  "188b757048e": {
    breaks: "breaks_JF_CM3",
    small: {
      model: {
        N: 216,
        D: 6,
        b: 1.0301052191704447,
        kernelType: "linear",
        w: [
          -0.3670377924881308,
          0.24109852608042484,
          0.10770417080350453,
          3.7309289892912494,
          -0.24351287768173968,
          0.1773538767010703
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6613098596026764,
          stdDev: 0.32645241503938466
        },
        nPoints: {
          mean: 4.027777777777778,
          stdDev: 0.79484775003546
        },
        scaledS1: {
          mean: 0.2738191427566398,
          stdDev: 0.31274618795081666
        },
        scaledS2: {
          mean: 0.16552447256379144,
          stdDev: 0.22401114065292482
        },
        nPointsChart: {
          mean: 18.88425925925926,
          stdDev: 11.50047652834366
        },
        chartPct: {
          mean: 0.24575562721992683,
          stdDev: 0.17658868716036033
        }
      }
    },
    big: {
      model: {
        N: 818,
        D: 18,
        b: -0.5949603608497636,
        kernelType: "linear",
        w: [
          -0.4977108970919176,
          0.7541270816821308,
          0.9144109510673445,
          1.6047203771838476,
          -1.4368172642074537,
          -0.21592712823176308,
          0.07644318713996778,
          0.014636523739875784,
          0.1763324579259402,
          1.106707575171747,
          -0.47385129596321995,
          0.45987873914033983,
          0.35112878139332787,
          -0.6236067182671058,
          0.9485075089484734,
          0.19163220544936868,
          0.20546829454342905,
          -0.06915930322456987
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6452237813470705,
          stdDev: 0.3240018443609284
        },
        nPoints: {
          mean: 14.583129584352077,
          stdDev: 8.99604477133496
        },
        scaledS1: {
          mean: 0.10594325137217282,
          stdDev: 0.09177436527475356
        },
        scaledS2: {
          mean: 0.08668479622616888,
          stdDev: 0.07415105573907281
        },
        nPointsChart: {
          mean: 27.0880195599022,
          stdDev: 12.696709863610126
        },
        chartPct: {
          mean: 0.5831555684741223,
          stdDev: 0.28777669079271473
        },
        runsTest2: {
          mean: 5.10757946210269,
          stdDev: 2.511304431521282
        },
        runsTest3: {
          mean: 8.050945471288665,
          stdDev: 4.446028922152818
        },
        runsTest4: {
          mean: 1.6812783091074126,
          stdDev: 0.5646901163167827
        },
        runsTest5: {
          mean: 0.337916669549109,
          stdDev: 0.20151780352623566
        },
        outlierTest1: {
          mean: 2.100035193879811,
          stdDev: 0.5296286424653459
        },
        outlierTest2: {
          mean: 0.05867970660146699,
          stdDev: 0.2351680408679939
        }
      }
    }
  },
  "18afd2f54c7": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3380856560371651,
        kernelType: "linear",
        w: [
          -0.756517811722315,
          0.37069999610745497,
          0.21673055797213336,
          1.1244975473636247,
          0.035519868943893806,
          0.6975781903311828
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6866332461949628,
          stdDev: 0.3229548134968895
        },
        nPoints: {
          mean: 4.069767441860465,
          stdDev: 0.8050959803624481
        },
        scaledS1: {
          mean: 0.03965686197121996,
          stdDev: 0.0338017466328698
        },
        scaledS2: {
          mean: 0.038745499336644146,
          stdDev: 0.033324943757710994
        },
        nPointsChart: {
          mean: 15.078488372093023,
          stdDev: 8.898337515306299
        },
        chartPct: {
          mean: 0.2979532652417984,
          stdDev: 0.1884678355817908
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.22042056305341218,
        kernelType: "linear",
        w: [
          -0.3280468854878086,
          -0.11665058369931192,
          -0.0022542536097451466,
          2.219103384778342,
          0.0342024760983941,
          0.4293989826596215,
          0.2975608661999607,
          -0.6077251584818741,
          0.4000527465309003,
          0.4042384593088002,
          0.001186586425212074,
          0.5190085928118862,
          -0.23537053975123523,
          0.0715945226988598,
          0.033154145420287044,
          -0.06347880606856209,
          0.1850990704458409,
          -0.001228864486559927
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6223429821764429,
          stdDev: 0.3110591999188207
        },
        nPoints: {
          mean: 13.731607629427794,
          stdDev: 8.370686093707965
        },
        scaledS1: {
          mean: 0.03544093688268208,
          stdDev: 0.026611386439376005
        },
        scaledS2: {
          mean: 0.03455363316854854,
          stdDev: 0.026077505679786228
        },
        nPointsChart: {
          mean: 23.768392370572208,
          stdDev: 11.730176258926388
        },
        chartPct: {
          mean: 0.6094307363719895,
          stdDev: 0.26692294365220165
        },
        runsTest2: {
          mean: 5.151226158038147,
          stdDev: 2.6793673522936645
        },
        runsTest3: {
          mean: 7.583581141916727,
          stdDev: 4.081715945141601
        },
        runsTest4: {
          mean: 1.6148756585462214,
          stdDev: 0.5411094264297078
        },
        runsTest5: {
          mean: 0.3153327018423893,
          stdDev: 0.19626169453505887
        },
        outlierTest1: {
          mean: 2.118980108638941,
          stdDev: 0.6300714899329056
        },
        outlierTest2: {
          mean: 0.09128065395095368,
          stdDev: 0.2882041970351209
        }
      }
    }
  },
  "18b1686ceb4": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3309416402875685,
        kernelType: "linear",
        w: [
          -0.20000267112106263,
          0.42809635761540643,
          0.46656203058966117,
          1.841671684760453,
          -0.6434524674952959,
          0.49143545422517687
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6764124363859395,
          stdDev: 0.3236057116921364
        },
        nPoints: {
          mean: 4.116279069767442,
          stdDev: 0.8069465847859293
        },
        scaledS1: {
          mean: 0.1858035195675879,
          stdDev: 0.21428670248595916
        },
        scaledS2: {
          mean: 0.12950420831848175,
          stdDev: 0.15751874574784924
        },
        nPointsChart: {
          mean: 15.761627906976743,
          stdDev: 9.783137376835176
        },
        chartPct: {
          mean: 0.300526358561615,
          stdDev: 0.1927265795559554
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.33318046701370874,
        kernelType: "linear",
        w: [
          0.032315062605570585,
          0.48106580584263436,
          -1.1047252909009055,
          3.7368759283052406,
          -0.6183759573768267,
          0.6939892440180402,
          0.3861182101902436,
          -0.4528094207813589,
          0.19685209857044894,
          0.5317134144006395,
          -0.3268861531591498,
          0.5416909853776097,
          0.11204746654248579,
          -0.042886524593192116,
          0.04725504450122949,
          0.09451185559860642,
          -0.011544267888957445,
          0.17029310632188632
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6349627683741144,
          stdDev: 0.3047569778403939
        },
        nPoints: {
          mean: 13.728882833787466,
          stdDev: 8.419998905023999
        },
        scaledS1: {
          mean: 0.07039535118699393,
          stdDev: 0.06922873611482698
        },
        scaledS2: {
          mean: 0.06255041459772398,
          stdDev: 0.05952611432033109
        },
        nPointsChart: {
          mean: 23.705722070844686,
          stdDev: 11.739000887557054
        },
        chartPct: {
          mean: 0.6095266522529739,
          stdDev: 0.26470522117524425
        },
        runsTest2: {
          mean: 5.129427792915531,
          stdDev: 2.7706078547777717
        },
        runsTest3: {
          mean: 7.603857452118007,
          stdDev: 4.140301994340143
        },
        runsTest4: {
          mean: 1.6191709447588931,
          stdDev: 0.5436847808406448
        },
        runsTest5: {
          mean: 0.32151695128382807,
          stdDev: 0.19159541197646354
        },
        outlierTest1: {
          mean: 2.116230031599242,
          stdDev: 0.5977792703826863
        },
        outlierTest2: {
          mean: 0.09400544959128065,
          stdDev: 0.29203530028780983
        }
      }
    }
  }
};
function get() {
  return Object.keys(dL).sort();
}
function met(e) {
  return dL[e ?? get().at(-1)];
}
var yet = Object.defineProperty, bet = (e, t, r) => t in e ? yet(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, vet = (e, t, r) => (bet(e, t + "", r), r);
const wet = 0.2;
function fL(e, t, r = wet) {
  if (e.length === 3)
    return 1;
  const n = e.points.at(-1).x - e.points[0].x, i = (e.points.at(-1).y - e.points[0].y) / n, s = Math.atan(i), o = Math.cos(s), a = e.points.map((f) => f.y), l = e.slice(1, e.length - 1);
  let c = a.indexOf(Math.min(...a)) - 1;
  (c < 0 || c === l.length) && (c = null);
  let h = a.indexOf(Math.max(...a)) - 1;
  (h < 0 || h === l.length) && (h = null);
  const u = [], p = l.points.map((f) => {
    const E = f.x - e.points[0].x, A = Math.abs(f.y - (i * E + e.points[0].y));
    return u.push(A), A * o;
  }), y = p.indexOf(Math.max(...p));
  let g = !1;
  c !== null && Math.abs(c - y) / (t - 1) <= r && (g = u[c] > p[y]);
  let b = !1;
  return h !== null && Math.abs(h - y) / (t - 1) <= r && (b = u[h] > p[y]), b ? h + 1 : g ? c + 1 : y + 1;
}
class xet {
  /**
   * @param model - (Optional) ID of split model to use.
   */
  constructor(t = void 0) {
    vet(this, "models");
    const r = met(t);
    if (r)
      this.models = {
        small: {
          svm: new Q9(),
          stats: r.small.stats
        },
        big: {
          svm: new Q9(),
          stats: r.big.stats
        }
      };
    else
      throw new Error(`unknown model ID: '${t}'`);
    this.models.small.svm.fromJSON(r.small.model), this.models.big.svm.fromJSON(r.big.model);
  }
  /**
   * Predict whether a sequence should be split.
   * @param seq - Data points of sequence to evaluate. 
   * @param chartLength - Number of data points in the complete chart
   * of which 'seq' is a part.
   * @returns Whether the sequence should be split.
   */
  shouldSplit(t, r) {
    if (t.length < 3 || t.points.every((a) => a.y === t.points[0].y))
      return !1;
    const n = new fet(), i = t.length < 6 ? "small" : "big", [s] = n.computeMatrix(
      [{ data: t, chartLength: r }],
      this.models[i].stats
    ), [o] = this.models[i].svm.predict([s]);
    return o === 1;
  }
  /**
   * Predict trend sequences a series should be split into.
   * @param series - Data points of series to split.
   * @param yAxis - Displayed chart y-axis bounds; defaults to extreme values of data
   * @param pipCloseness - Max distance (as % of chart length) a sequence-local 
   * min/max point can be from the PIP to be a possible split point.
   * @returns List of index pairs denoting the start and end of each sequence.
   * @remarks
   * As in slices, the end index in a pair is not included in the set of indices
   * included in a sequence.
   * NB: Adjacent sequences share the point where they were split.
   * E.g., a hypothetical set of sequences might look like:
   *   [\{start: 0, end: 5\}, \{start: 4, end: 7\}, \{start: 6, end: 10\}]
   * where the first two sequences share the point at index 4, and the last
   * two share the point at index 6.
   */
  getSequences(t, r, n) {
    const i = t.length;
    t = t.project(void 0, r);
    const s = [], o = (a, l) => {
      const c = t.slice(a, l);
      if (this.shouldSplit(c, t.length)) {
        const h = fL(c, t.length, n) + a;
        o(a, h + 1), o(h, l);
      } else
        s.push({ start: a, end: l });
    };
    return o(0, i), s;
  }
}
const Eet = 6, Aet = 5;
function _et(e) {
  const t = wo(e), r = e.map((n) => n - t);
  return Math.sqrt(r.reduce((n, i) => n + i ** 2, 0));
}
function Wg(e) {
  return Math.sign(e);
}
function ket(e, t = Aet, r = t) {
  const n = e.length;
  if (n < 3) {
    let i = (e.points[1].y - e.points[0].y) / (e.points[1].x - e.points[0].x);
    const s = af(i);
    return Math.abs(s) < r && (i = 0), { classes: [Wg(i)], slope: i, angle: s };
  } else {
    const i = e.bestFit.rss();
    if (n < Eet) {
      let u = Wg(e.bestFit.slope);
      return Math.abs(e.bestFit.xAngle) < r && (u = 0), { classes: [u], slope: e.bestFit.slope, angle: e.bestFit.xAngle };
    }
    const s = e.points.map((u) => u.x), o = Math.sqrt(i / (n - 2)) / _et(s), a = 1 - 0.05 / 2, l = new ret(n - 2).invCumulativeProbability(a) * o, c = [e.bestFit.slope - l, e.bestFit.slope + l], h = [];
    return Math.sign(c[0]) !== Math.sign(c[1]) ? (h.push(0), Math.abs(e.bestFit.xAngle) >= t && h.push(Wg(e.bestFit.slope))) : (h.push(Wg(e.bestFit.slope)), Math.abs(e.bestFit.xAngle) < t && e.bestFit.slope && h.push(0)), { classes: h, slope: e.bestFit.slope, angle: e.bestFit.xAngle, moe: l };
  }
}
function Cet(e, t) {
  return e.size !== t.size ? !1 : Array.from(e).every((r) => t.has(r));
}
function Iet(e) {
  const t = [];
  for (let r = 0; r < e.length; r++)
    for (let n = r + 1; n < e.length; n++)
      t.push([e[r], e[n]]);
  return t;
}
function Pet(e, t) {
  return {
    start: Math.min(e.start, t.start),
    end: Math.max(e.end, t.end)
  };
}
function Ret(e, t) {
  return e.start === t.start && e.end === t.end;
}
function Tet(e, t) {
  return e.start >= t.start && e.start <= t.end || t.start >= e.start && t.start <= t.end;
}
function Oet(e, t) {
  const r = [e.points[0].x, ...t, e.points.at(-1).x], n = [];
  for (let i = 1; i < r.length; i++)
    n.push({ start: r[i - 1], end: r[i] });
  return n;
}
let B3 = class Qa {
  /**
   * Do not use; call TrackingGroup.getGroups() to create tracking groups.
   * @internal
   */
  constructor(t, r, n) {
    this.keys = t, this.interval = r, this.seriesByKey = n;
  }
  /**
   * Compute tracking groups for the set of series of a chart.
   * @param allSeries - All series of a chart.
   * @param minSize - Value between 0 and 1 determining the minimum size of a 
   * tracking group (as a percentage of chart width).
   * @param closeness - Value between 0 and 1 determining the degree of tracking
   * closeness required for lines to pair/group.
   * @returns The tracking groups.
   */
  static getGroups(t, r = 0.25, n = 0.9) {
    const i = /* @__PURE__ */ new Map();
    t.forEach((h) => i.set(h.key, h));
    const s = Iet(t).map(([h, u]) => [h.key, u.key]);
    let o = [];
    const a = Math.min(...t.map((h) => h.yBounds().start)), l = {
      start: 0,
      end: Math.max(...t.map((h) => h.yBounds().end)) - a
    };
    for (const h of s) {
      const u = new jet(
        i.get(h[0]),
        i.get(h[1]),
        0.5
      ).getRelativeTrajectories(l).filter((p) => p.type === "tracking" && p.interval.end - p.interval.start >= t[0].xRange() * r && p.degree >= n).map((p) => ({ keyPair: h, interval: p.interval }));
      o = o.concat(u);
    }
    let c = Qa.createGroupsFromPairs(o, i);
    return c = Qa.normalizeGroups(c), c.reverse(), c;
  }
  static createGroupsFromPairs(t, r) {
    const n = [];
    function i(l) {
      return n.findIndex((c) => c.start === l.start && c.end === l.end);
    }
    for (const l of t)
      i(l.interval) === -1 && n.push(l.interval);
    const s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    for (const { keyPair: l, interval: c } of t) {
      const h = i(c);
      let u = s.get(h);
      u || (u = [], s.set(h, u)), u.push(l);
      let p = o.get(h);
      p || (p = [], o.set(h, p));
      for (const y of l)
        p.includes(y) || p.push(y);
    }
    const a = [];
    for (const [l, c] of o) {
      const h = s.get(l);
      let u = [];
      for (const p of h) {
        const y = u.find((b) => b.has(p[0])), g = u.find((b) => b.has(p[1]));
        !y && !g ? u.push(new Set(p)) : y && g && y !== g ? (g.forEach((b) => y.add(b)), u = u.filter((b) => b !== g)) : y ? y.add(p[1]) : g.add(p[0]);
      }
      for (const p of u)
        a.push(new Qa(p, n[l], r));
    }
    return a;
  }
  /**
   * Supplement smaller tracking groups contained entirely within larger ones.
   * Line groups are updated in-place.
   * @internal
   */
  static suppleteGroups(t) {
    let r = !1;
    t.sort((n, i) => {
      const s = n.interval.end - n.interval.start, o = i.interval.end - i.interval.start;
      return Math.sign(o - s);
    });
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      for (let s = n + 1; s < t.length; s++) {
        const o = t[s];
        if (!(i.interval.start > o.interval.start || i.interval.end < o.interval.end))
          if (i.interval.end - i.interval.start === o.interval.end - o.interval.start) {
            const a = i.supplete(o), l = o.supplete(i);
            r || (r = a || l);
          } else {
            const a = i.supplete(o);
            r || (r = a);
          }
      }
    }
    return r;
  }
  /**
   * Supplete group 'other' in-place.
   */
  supplete(t) {
    let r = !1;
    if (Array.from(this.keys).some((n) => t.keys.has(n)))
      for (const n of this.keys)
        t.keys.has(n) || (t.keys.add(n), r = !0);
    return r;
  }
  /**
   * Create a new array of tracking groups by merging any groups
   * that overlap (or abut) and consist of the same set of lines.
   * @param groups - Original array of tracking groups
   * @returns New array of tracking groups
   * @internal
   */
  static mergeGroups(t) {
    if (t.length) {
      let r;
      do {
        r = [];
        const n = [];
        t:
          for (let i = 0; i < t.length; i++) {
            const s = t[i];
            for (let o = i + 1; o < t.length; o++) {
              const a = t[o];
              if (Tet(s.interval, a.interval) && Cet(s.keys, a.keys)) {
                r.push(new Qa(
                  s.keys,
                  Pet(s.interval, a.interval),
                  s.seriesByKey
                )), n.push(s, a);
                break t;
              }
            }
          }
        t = t.filter((i) => !n.includes(i)).concat(r);
      } while (r.length);
    }
    return t;
  }
  /**
   * Iteratively supplete and merge a set of tracking groups until
   * we can't supplete any group further.
   * @internal
   */
  static normalizeGroups(t) {
    let r = Qa.suppleteGroups(t);
    do
      t = Qa.mergeGroups(t), r = Qa.suppleteGroups(t);
    while (r);
    return t;
  }
  /**
   * Get series not included in the tracking group.
   * @returns The outlier line keys relative to the group.
   */
  outliers() {
    return Array.from(this.seriesByKey.keys()).filter((t) => !this.keys.has(t)).sort();
  }
  /**
   * Compute the line of averaged values from the lines in the tracking group.
   * @returns The average line.
   */
  averageLine() {
    const t = Array.from(this.keys).map((n) => this.seriesByKey.get(n).extractSection(this.interval)), r = t.length;
    return new Cf(lu(t[0].length, (n) => ({
      x: t[0].points[n].x,
      y: lu(r, (i) => t[i].points[n].y).reduce((i, s) => i + s) / r
    })));
  }
}, Let = class gL {
  /**
   * Do not use; call TrackingZone.getZones() to create tracking zones.
   */
  constructor(t, r) {
    this.trackingGroups = t, this.interval = r;
  }
  /**
   * Compute tracking zones from a set of tracking groups.
   * @param trackingGroups - Tracking groups of the chart.
   * @returns The list of tracking zones.
   * @public
   */
  static getZones(t) {
    const r = /* @__PURE__ */ new Set();
    t.forEach((o) => {
      r.add(o.interval.start), r.add(o.interval.end);
    });
    const n = Array.from(r).sort().slice(1, -1), i = Oet(
      t[0].seriesByKey.values().next().value,
      n
    ), s = [];
    for (const o of i) {
      let a = !1;
      for (const l of t)
        if (l.interval.start <= o.start && l.interval.end >= o.end) {
          const c = s.find((u) => Ret(o, u.interval)), h = new B3(new Set(l.keys), o, l.seriesByKey);
          c ? c.trackingGroups.push(h) : (s.push(new gL([h], o)), a = !0);
        }
      if (a) {
        const l = s.at(-1);
        l.trackingGroups = B3.normalizeGroups(l.trackingGroups);
      }
    }
    return s;
  }
};
const Met = 2, j3 = -1;
function Net(e, t, r) {
  const n = r.map((i) => Math.abs(t - i));
  return n.sort((i, s) => Math.sign(i - s)), n[e];
}
function Det(e, t, r, n) {
  let i = -1;
  const s = /* @__PURE__ */ new Map();
  for (const o of e) {
    if (s.get(o) !== void 0)
      continue;
    const a = Y9(e, t, o, r);
    if (a.length < n) {
      s.set(o, j3);
      continue;
    }
    i++, s.set(o, i);
    const l = new Set(Array.from(a).filter((c) => c !== o));
    for (const c of l) {
      if (s.get(c) === j3 && s.set(c, i), s.get(c) !== void 0)
        continue;
      s.set(c, i);
      const h = Y9(e, t, c, r);
      if (h.length >= n)
        for (const u of h)
          l.add(u);
    }
  }
  return s;
}
function Y9(e, t, r, n) {
  return e.filter((i) => t(r, i) <= n);
}
class Bet {
  /**
   * @param allSeries - All series of a chart.
   * @param minPts - Optional min neighbors (including itself) a point must have
   * to be considered a core point.
   */
  constructor(t, r = Met) {
    this.clusters = [], this.noise = [];
    const n = t.map((u) => wo(u.points.map((p) => p.y))), i = n.map((u) => Net(1, u, n)).toSorted((u, p) => -Math.sign(u - p)), s = Cf.fromValues(i), o = fL(s, s.length), a = Math.min(...t.map((u) => u.yBounds().start)), l = (Math.max(...t.map((u) => u.yBounds().end)) - a) / 10, c = Math.max(i[o], l), h = Det(n, (u, p) => Math.abs(u - p), c, r);
    for (let u = 0; u < n.length; u++) {
      const p = h.get(n[u]);
      if (p === j3)
        this.noise.push(t[u]);
      else {
        let y = this.clusters[p];
        y || (this.clusters[p] = y = []), y.push(t[u]);
      }
    }
  }
}
class jet extends cL {
  constructor(t, r, n) {
    super(t, r, n), this.differentialLine = this.computeDifferentialLine();
  }
  computeDifferentialLine() {
    let t = new Cf(this.series1.points.map(
      (n, i) => ({ x: n.x, y: Math.abs(n.y - this.series2.points[i].y) })
    ));
    const r = this.intersectingSegPairs.filter((n) => n.intersection !== "Overlap").filter((n) => !n.intersection.atRecord).map((n) => n.intersection.crosspoint);
    for (const n of r) {
      const i = t.points.findLastIndex((o) => n.x > o.x), s = Array.from(t.points);
      s.splice(i + 1, 0, { x: n.x, y: 0 }), t = new Cf(s);
    }
    return t;
  }
  /**
   * 
   * @param yAxis - Interval from 0 to the y-range of the chart, representing
   * the minimum and maximum possible y-value differences between records of two series.
   * @returns 
   */
  getRelativeTrajectories(t) {
    const r = [], n = new xet().getSequences(this.differentialLine, t), i = this.differentialLine.project(void 0, t), s = n.map(
      ({ start: a, end: l }) => ket(i.slice(a, l))
    );
    for (let a = 0; a < n.length; a++) {
      const l = s[a];
      if (l.classes.length === 2 && Math.abs(l.moe) < Math.abs(l.slope)) {
        const h = l.classes.indexOf(0);
        Math.abs(l.angle) < 5 ? l.classes.splice(1 - h, 1) : l.classes.splice(h, 1);
      }
      const c = {
        start: this.differentialLine.points[n[a].start].x,
        end: this.differentialLine.points[n[a].end - 1].x
      };
      l.classes[0] === 0 ? r.push({
        interval: c,
        type: "tracking",
        degree: 1 - T3(
          this.differentialLine.slice(n[a].start, n[a].end).points.map((h) => h.y)
        ) / t.end
      }) : r.push({
        interval: c,
        type: l.classes[0] === 1 ? "diverging" : "converging",
        degree: Math.abs(l.angle / 90)
      });
    }
    const o = [];
    if (r.length) {
      o.push(r[0]);
      for (let a = 1; a < r.length; a++)
        r[a].type === r[a - 1].type ? o.at(-1).interval.end = r[a].interval.end : o.push(r[a]);
    }
    return o;
  }
}
let Fet = class extends uL {
  constructor(t, r, n, i) {
    super(t, r, n, i);
    const s = B3.getGroups(t, void 0, 0.9);
    this.trackingGroups = s.map((a) => this.generateTrackingGroupMetadata(a)), s.length && (this.trackingZones = Let.getZones(s).map((a) => this.generateTrackingZoneMetadata(a)));
    const o = new Bet(t);
    this.clusters = o.clusters.map((a) => a.map((l) => l.key)), this.clusterOutliers = o.noise.map((a) => a.key);
  }
  generateTrackingGroupMetadata(t) {
    return {
      keys: Array.from(t.keys),
      outliers: t.outliers(),
      valueInterval: [t.interval.start, t.interval.end],
      averageLine: t.averageLine().points.map((r) => [r.x, r.y])
    };
  }
  generateTrackingZoneMetadata(t) {
    return {
      groups: t.trackingGroups.map((r) => this.generateTrackingGroupMetadata(r)),
      valueInterval: [t.interval.start, t.interval.end]
    };
  }
};
function ka(e) {
  return class extends e {
    log(...r) {
      console.log(`[${this.logName()}]`, ...r);
    }
  };
}
const mL = ka(class {
  logName() {
    return "LOGNAME";
  }
});
function $et(e) {
  return typeof e == "function" ? e() : e;
}
const jy = class jy extends Event {
  /**
   * @param  {string} key of the state that has changed
   * @param  {unknown} value for the changed key
   */
  constructor(t, r, n) {
    super(jy.eventName, {
      cancelable: !1
    }), this.key = t, this.value = r, this.state = n;
  }
};
jy.eventName = "lit-state-changed";
let hu = jy;
const zet = (e, t) => t !== e && (t === t || e === e), cS = class cS extends EventTarget {
  static initPropertyMap() {
    this.propertyMap || (this.propertyMap = /* @__PURE__ */ new Map());
  }
  get propertyMap() {
    return this.constructor.propertyMap;
  }
  get stateValue() {
    return Object.fromEntries([...this.propertyMap].map(([t]) => [t, this[t]]));
  }
  constructor() {
    super(), this.hookMap = /* @__PURE__ */ new Map(), this.constructor.finalize(), this.propertyMap && [...this.propertyMap].forEach(([t, r]) => {
      if (r.initialValue !== void 0) {
        const n = $et(r.initialValue);
        this[t] = n, r.value = n;
      }
    });
  }
  static finalize() {
    if (this.finalized)
      return !1;
    this.finalized = !0;
    const t = Object.keys(this.properties || {});
    for (const r of t)
      this.createProperty(r, this.properties[r]);
    return !0;
  }
  static createProperty(t, r) {
    this.finalize();
    const n = typeof t == "symbol" ? Symbol() : `__${t}`, i = this.getPropertyDescriptor(String(t), n, r);
    Object.defineProperty(this.prototype, t, i);
  }
  static getPropertyDescriptor(t, r, n) {
    const i = (n == null ? void 0 : n.hasChanged) || zet;
    return {
      get() {
        return this[r];
      },
      set(s) {
        const o = this[t];
        this[r] = s, i(s, o) === !0 && this.dispatchStateEvent(t, s, this);
      },
      configurable: !0,
      enumerable: !0
    };
  }
  /**
   * Reset the state to its original values, skipping
   * properties marked as skipReset
   */
  reset() {
    this.hookMap.forEach((t) => t.reset()), [...this.propertyMap].filter(([t, r]) => !(r.skipReset === !0 || r.resetValue === void 0)).forEach(([t, r]) => {
      this[t] = r.resetValue;
    });
  }
  /**
   * subscribe to state change event. The callback will be called anytime
   * a state property change if `nameOrNames` is undefined, or only for matching
   * property values specified by `nameOrNames`
   * @param callback the callback function to call
   * @param nameOrNames
   * @returns a unsubscribe function.
   */
  subscribe(t, r, n) {
    r && !Array.isArray(r) && (r = [r]);
    const i = (s) => {
      (!r || r.includes(s.key)) && t(s.key, s.value, this);
    };
    return this.addEventListener(hu.eventName, i, n), () => this.removeEventListener(hu.eventName, i);
  }
  dispatchStateEvent(t, r, n) {
    this.dispatchEvent(new hu(t, r, n));
  }
};
cS.finalized = !1;
let Rm = cS;
class c5 {
  constructor(t, r, n) {
    this.host = t, this.state = r, this.callback = n || (() => this.host.requestUpdate()), this.host.addController(this);
  }
  dispose() {
    this.state.removeEventListener(hu.eventName, this.callback);
  }
  hostConnected() {
    this.state.addEventListener(hu.eventName, this.callback), this.callback();
  }
  hostDisconnected() {
    this.dispose();
  }
}
function vr(e) {
  return (t, r) => {
    if (Object.getOwnPropertyDescriptor(t, r))
      throw new Error("@property must be called before all state decorators");
    const n = t.constructor;
    n.initPropertyMap();
    const i = t.hasOwnProperty(r);
    return n.propertyMap.set(r, {
      ...e,
      initialValue: e == null ? void 0 : e.value,
      resetValue: e == null ? void 0 : e.value
    }), n.createProperty(r, e), i ? Object.getOwnPropertyDescriptor(t, r) : void 0;
  };
}
new URL(location.href);
class zi extends Ir {
  get store() {
    return this._store;
  }
  set store(t) {
    this._store = t, this._storeState = new c5(this, t);
  }
  logName() {
    return this.nodeName;
  }
  extractStyles(t) {
    const r = this.shadowRoot.adoptedStyleSheets, n = [];
    for (const i of r) {
      const s = i.cssRules;
      for (let o = 0; o < s.length; o++) {
        const a = s.item(o);
        n.push(a.cssText.replace(/^:host/, `#${t}`));
      }
    }
    return n.join(`
`);
  }
}
class Vet {
  constructor(t) {
    this._store = t, this._voice = null, this._lang = "en-US", this._rate = 1, this._volume = 1, this._pitch = 1, this._utterance = null, this._highlightIndex = null, this._speakingCount = 0, this._voice = window.speechSynthesis, this._voice || console.warn("Speech Synthesis unsupported");
  }
  get highlightIndex() {
    return this._highlightIndex;
  }
  get isSpeaking() {
    return this._speakingCount > 0;
  }
  speak(t, r, n = 0) {
    if (this._voice) {
      this.shutUp(), this._utterance = this.speakText(t), this._speakingCount++;
      const i = (s) => r.findIndex((o) => s >= o.start && s < o.end);
      this._utterance.onboundary = (s) => {
        const o = i(s.charIndex);
        if (o === -1) {
          this._highlightIndex = null;
          return;
        }
        this._highlightIndex = o;
        const a = r[this._highlightIndex];
        this._store.paraChart.postNotice("utteranceBoundary", a);
      }, this._utterance.onend = (s) => {
        this._store.paraChart.postNotice("utteranceEnd", null), this._speakingCount--;
      };
    }
  }
  speakText(t) {
    return this._utterance = new SpeechSynthesisUtterance(t), this._utterance.rate = this._rate, this._utterance.lang = this._lang, this._utterance.pitch = this._pitch, this._utterance.volume = this._volume, this._voice.speak(this._utterance), this._utterance;
  }
  pause() {
    var t;
    (t = this._voice) == null || t.pause();
  }
  resume() {
    var t;
    (t = this._voice) == null || t.resume();
  }
  togglePaused() {
    this.isPaused ? this.resume() : this.pause();
  }
  get isPaused() {
    var t;
    return (t = this._voice) == null ? void 0 : t.paused;
  }
  shutUp() {
    this._voice && this._voice.speaking && (this._voice.cancel(), this._highlightIndex = null);
  }
  get lang() {
    return this._lang;
  }
  set lang(t) {
    this._lang = t;
  }
  get rate() {
    return this._rate;
  }
  set rate(t) {
    this._rate = t;
  }
  get volume() {
    return this._volume;
  }
  set volume(t) {
    this._volume = t;
  }
  get pitch() {
    return this._pitch;
  }
  set pitch(t) {
    this._pitch = t;
  }
}
const u5 = Te`
  :host,
  :root {
    --axis-line-color: hsl(0, 0%, 0%);
    --label-color: hsl(0, 0%, 0%);
    --tick-grid-color: hsl(270, 50%, 50%);
    --background-color: white;
    --theme-color: var(--fizz-theme-color, purple);
    --theme-color-light: var(--fizz-theme-color-light, hsl(275.4, 100%, 88%));
    --theme-contrast-color: white;
    --fizz-theme-color: var(--paracharts-theme-color, navy);
    --fizz-theme-color-light: var(--paracharts-theme-color-light, hsl(210.5, 100%, 88%));
    /*--visited-color: red;*/
    --selected-color: var(--label-color);
    --datapoint-centroid: 50% 50%;
    --focus-animation: all 0.5s ease-in-out;
    --chart-cursor: pointer;
    --data-cursor: cell;

    /* default color palette */
    --color-palette-series-0: hsl(225, 30%, 52%);
    --color-palette-series-1: hsl(12, 69%, 35%);
    --color-palette-series-2: hsl(75, 43%, 45%);
    --color-palette-series-3: hsl(40, 100%, 49%);
    --color-palette-series-4: hsl(215, 37%, 66%);
    --color-palette-series-5: hsl(63, 100%, 23%);
    --color-palette-series-6: hsl(34, 57%, 46%);
    --color-palette-series-7: hsl(51, 56%, 64%);
    --color-palette-series-8: hsl(253, 26%, 43%);
    --color-palette-series-9: hsl(85, 65%, 36%);

    --focus-shadow-color: gray;
    --focus-shadow: drop-shadow(0px 0px 4px var(--focus-shadow-color));
  }

  .hidden { display: none !important; }

  /* https://kittygiraudel.com/snippets/sr-only-class/ */
  .sr-only {
    border: 0 !important;
    clip: rect(1px, 1px, 1px, 1px) !important;
    -webkit-clip-path: inset(50%) !important;
    clip-path: inset(50%) !important;
    height: 1px !important;
    overflow: hidden !important;
    margin: -1px !important;
    padding: 0 !important;
    position: absolute !important;
    width: 1px !important;
    white-space: nowrap !important;
  }

  * {
    font-family: "Trebuchet MS", Helvetica, sans-serif;
  }
  #y-axis-line {
    fill: none;
    stroke: var(--axis-line-color);
    stroke-width: 2px;
    stroke-linecap: round;
  }
  #x-axis-line {
    fill: none;
    stroke: var(--axis-line-color);
    opacity: 1;
    stroke-width: 2px;
    stroke-linecap: round;
  }
  .chart-title {
    font-size: 1.25rem;
  }
  /*.chart-title .middle {
    text-anchor: middle;
  }
  .chart-title .end {
    text-anchor: end;
  }*/
  .label {
    display: block;
    fill: var(--label-color);
  }
  .axis-title {
    text-anchor: middle;
  }
  .tick-label {
    fill: var(--label-color);
  }
  /*.tick-label.horiz {
    text-anchor: middle;
  }
  .tick-label.horiz.rotated {
    text-anchor: end;
  }
  .tick-label.horiz.rotated.north {
    text-anchor: start;
  }
  .tick-label.vert {
    text-anchor: end;
  }
  .tick-label.vert.east {
    text-anchor: start;
  }*/
  .tickmark-y {
    opacity: 0.2;
  }
  .tickmark-y-0 {
    fill: var(--tick-grid-color);
    stroke: var(--tick-grid-color);
    opacity: 1;
    stroke-width: 2px;
    stroke-linecap: round;
  }
  .tick-group-y:hover, .tick-group-y:hover .tickmark-y {
    font-weight: bold;
    opacity: 1;
  }
  .tickmark-x {
    opacity: 0.2;
  }
  .tickmark-x-0 {
    fill: var(--tick-grid-color);
    stroke: var(--tick-grid-color);
    opacity: 1;
    stroke-width: 2px;
    stroke-linecap: round;
  }
  .tick-group-x:hover, .tick-group-x:hover .tickmark_x {
    font-weight: bold;
    opacity: 1;
  }
  rect#data-backdrop {
    stroke: none;
    fill: none;
    pointer-events: all;
  }
  .stack {
    stroke-width: 0;
  }
  .bar:hover, .bar:focus {
    fill: hsl(270, 50%, 65%);
    outline: 2px auto -webkit-focus-ring-color;
  }
  .datapoint_background {
    fill: none;
    stroke: none;
    pointer-events: all;
    outline: none;
  }
  .datapoint_background:hover,
  .datapoint_background:focus {
    outline: 2px auto -webkit-focus-ring-color;
    box-shadow: none;
  }
  .data-line {
    fill: none;
    /*stroke-width: 3px;*/
    stroke-linecap: round;
  }
  .data_area {
    stroke: hsl(270, 50%, 50%);
    stroke-width: 3px;
    stroke-linecap: round;
    fill: none;
  }
  .data_area_background {
    stroke: none;
    fill: hsl(270, 50%, 50%);
    fill-opacity: 0.8;
  }
  .trendline {
    stroke: red;
    stroke-width: 3px;
    fill: none;
  }
  .center_label > tspan.subtext {
    font-size: 2rem;
    text-anchor: middle;
  }
  /*g.datapoint {
    transform-origin: var(--datapoint-centroid);
  }*/
  g.datapoint g.datapoint_popup rect {
    fill: hsl(0, 0%, 25%);
  }
  g.datapoint g.datapoint_popup text {
    fill: white;
    font-size: 1rem;
    text-anchor: middle;
  }
  g.datapoint g.datapoint_popup {
    stroke: none;
    opacity: 0.0;
    transition: opacity 0.3s ease-in-out;
  }
  g.datapoint:focus g.datapoint_popup, g.datapoint:hover g.datapoint_popup {
    opacity: 1.0;
    transition: opacity 0.3s ease-in-out;
  }
  g.datapoint g.datapoint_popup .desc {
    opacity: 0.0;
  }
  g.datapoint:focus g.datapoint_popup .desc, g.datapoint:hover g.datapoint_popup .desc {
    opacity: 1.0;
    transition: opacity 0.3s ease-in-out 2s;
  }
  g.datapoint.visited {
    fill: var(--visited-color, red);
    stroke: var(--visited-color, red);
    transform-box: fill-box;
/*    transition: var(--focus-animation); */
  }
  g.datapoint.visited:focus {
    /*outline: none;
    box-shadow: none;*/
    transition: var(--focus-animation);
    filter: var(--focus-shadow);
    /*animation: pulse-animation 2s infinite;*/
  }

  [data-charttype="stepline"] g.datapoint.visited {
    fill: var(--visited-color, red);
    stroke: var(--visited-color, red);
    transform: none;
/*    transition: var(--focus-animation); */
  }

  /* use#visited-mark {
    fill: inherit;
    stroke: inherit;
    transition: inherit;
  } */
  use.visited-mark {
    pointer-events: none;
  }
  @keyframes pulse-animation {
    0% {
      filter: drop-shadow(0px 0px 0px gray);
    }
    100% {
      filter: drop-shadow(0px 0px 12px gray);
    }
  }
  /*[data-charttype="line"] g.datapoint.visited {
    transform: scale(1.5);
  }
  [data-charttype="bar"] g.datapoint.visited {
    transform: scaleX(1.15);
  }*/
  .selected-datapoint-marker {
    fill: transparent;
    stroke: var(--selected-color);
    stroke-width: 3px;
    /*opacity: 0.5;*/
    pointer-events: none;
    stroke-linejoin: round;
  }
  .symbol {
    /*stroke-width: 2;*/
    stroke-linejoin: round;
  }
  .symbol.outline {
    fill: white;
  }
  .slice path {
    stroke: none;
    /*opacity: 0.5;*/
  }
  .slice text {
    fill: black;
    stroke: black;
    text-anchor: middle;
  }

  :fullscreen,
  ::backdrop {
    background-color: var(--background-color);
  }

  /* COLOR PALETTES */

  .theme-diva {
    --color-palette-series-0: hsl(225, 30%, 52%);
    --color-palette-series-1: hsl(12, 69%, 35%);
    --color-palette-series-2: hsl(75, 43%, 45%);
    --color-palette-series-3: hsl(40, 100%, 49%);
    --color-palette-series-4: hsl(215, 37%, 66%);
    --color-palette-series-5: hsl(63, 100%, 23%);
    --color-palette-series-6: hsl(34, 57%, 46%);
    --color-palette-series-7: hsl(51, 56%, 64%);
    --color-palette-series-8: hsl(253, 26%, 43%);
    --color-palette-series-9: hsl(85, 65%, 36%);
  }

  /* NOTE: not real deutan color palette! Replace after research */
  .theme-deutan {
    --color-palette-series-0: #800080;
    --color-palette-series-1: #ff00ff;
    --color-palette-series-2: #ca0088;
    --color-palette-series-3: #fa0080;
    --color-palette-series-4: #b400b4;
    --color-palette-series-5: #4477AA;
    --color-palette-series-6: #EE6677;
    --color-palette-series-7: #228833;
    --color-palette-series-8: #CCBB44;
    --color-palette-series-9: #66CCEE;
    --color-palette-series-10: #AA3377;
  }

  /* NOTE: not real protan color palette! Replace after research */
  .theme-protan {
    --color-palette-series-0: hsl(39, 70%, 54%);
    --color-palette-series-1: hsl(206, 68%, 66%);
    --color-palette-series-2: hsl(154, 39%, 44%);
    --color-palette-series-3: hsl(56, 81%, 66%);
    --color-palette-series-4: hsl(209, 57%, 43%);
    --color-palette-series-5: hsl(24, 68%, 46%);
    --color-palette-series-6: hsl(324, 35%, 62%);
  }

  /* NOTE: not real tritan color palette! Replace after research */
  .theme-tritan {
    --color-palette-series-0: #77AADD;
    --color-palette-series-1: #99DDFF;
    --color-palette-series-2: #44BB99;
    --color-palette-series-3: #BBCC33;
    --color-palette-series-4: #AAAAOO;
    --color-palette-series-5: #EEDD88;
    --color-palette-series-6: #FFAABB;
  }

  /* NOTE: not real grayscale color palette! Replace after research */
  .theme-grayscale {
    --color-palette-series-0: #262626;
    --color-palette-series-1: #595959;
    --color-palette-series-2: #7f7f7f;
    --color-palette-series-3: #a1a1a1;
    --color-palette-series-4: #bababa;
    --color-palette-series-5: #d4d4d4;
    --color-palette-series-6: #ededed;
  }

  .series-0 {
    fill: var(--color-palette-series-0);
    stroke: var(--color-palette-series-0);
  }
  .series-1 {
    fill: var(--color-palette-series-1);
    stroke: var(--color-palette-series-1);
  }
  .series-2 {
    fill: var(--color-palette-series-2);
    stroke: var(--color-palette-series-2);
  }
  .series-3 {
    fill: var(--color-palette-series-3);
    stroke: var(--color-palette-series-3);
  }
  .series-4 {
    fill: var(--color-palette-series-4);
    stroke: var(--color-palette-series-4);
  }
  .series-5 {
    fill: var(--color-palette-series-5);
    stroke: var(--color-palette-series-5);
  }
  .series-6 {
    fill: var(--color-palette-series-6);
    stroke: var(--color-palette-series-6);
  }
  .series-7 {
    fill: var(--color-palette-series-7);
    stroke: var(--color-palette-series-7);
  }
  .series-8 {
    fill: var(--color-palette-series-8);
    stroke: var(--color-palette-series-8);
  }
  .series-9 {
    fill: var(--color-palette-series-9);
    stroke: var(--color-palette-series-9);
  }

  .range-highlights {
    fill: pink;
    stroke: pink;
    fill-opacity: 0.25;
    stroke-width: 4px;
    stroke-opacity: 0.5;
  }
  .range-highlights rect[data-id="0"] {
    fill: orange;
    stroke: orange;
  }
  .range-highlights rect[data-id="1"] {
    fill: cyan;
    stroke: cyan;
  }
  .linebreaker[data-state=active] .linebreaker-marker {
    stroke: dodgerblue;
    stroke-width: 3px;
  }
  .best_fit_line[data-state=active] {
    display: inline;
    fill: none;
    stroke: hsl(315, 89%, 46%);
    stroke-width: 8px;
    stroke-linecap: butt;
    stroke-dasharray: 12 12;
    stroke-opacity: 0.5;
  }
  .best_fit_line[data-state=inactive] {
    display: none;
  }

  .setting-views {
    display: flex;
    gap: 1rem;
  }

  .setting-views+.setting-views {
    margin-top: 0.5rem;
  }

  figure {
    display: inline-block;
  }

  svg {
    display: block;
  }


  /* details box styles*/

  .tab-content {
    display: flex;
    flex-direction: row;
    gap: 1rem;
    align-items: center;
    justify-content: space-between;
    padding: 0.2rem;
  }

  .tab-content.stacked {
    flex-direction: column;
    gap: 0.1rem;
    align-items: flex-start;
    justify-content: space-between;
    padding: 0.5rem 0.2rem;
  }

  #chart-colors-presets {
    border: none;
    padding: 0;
    margin: 0;
  }

  #chart-colors-presets label {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
  }

  #chart-colors-presets label span {
    text-align: center;
    word-spacing: 20em;
  }

  /* dialog styles */

  #output_dialog {
    margin: 0 auto;
  }

  #output-dialog::backdrop {
    background: repeating-linear-gradient(
      45deg,
      rgba(128,0,128, 0.2),
      rgba(128,0,128, 0.2) 1px,
      rgba(128,0,128, 0.3) 1px,
      rgba(128,0,128, 0.3) 20px
    );
  }

  #output-dialog button {
    color: white;
    background-color: var(--theme-color);
    border: 1px solid var(--theme-color);
  }

  #output-dialog h1 {
    color: black;
    font-size: 1.3rem;
    font-weight: normal;
  }

  /* Tab Page styles */

  button {
    margin: 0.2rem;
    background-color: var(--theme-color);
    color: var(--theme-contrast-color);
    border: thin solid var(--theme-color);
    border-radius: 0.2em;
    padding: 0.2em;
  }

  #status_split {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }

  [role="graphics-document"] {
    cursor: var(--chart-cursor);
  }

  #chart-layers {
    cursor: var(--data-cursor);
  }
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Uet = (e) => e.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const _2 = { ATTRIBUTE: 1, CHILD: 2 }, k2 = (e) => (...t) => ({ _$litDirective$: e, values: t });
let C2 = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, r, n) {
    this._$Ct = t, this._$AM = r, this._$Ci = n;
  }
  _$AS(t, r) {
    return this.update(t, r);
  }
  update(t, r) {
    return this.render(...r);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const hf = (e, t) => {
  var n;
  const r = e._$AN;
  if (r === void 0) return !1;
  for (const i of r) (n = i._$AO) == null || n.call(i, t, !1), hf(i, t);
  return !0;
}, Tm = (e) => {
  let t, r;
  do {
    if ((t = e._$AM) === void 0) break;
    r = t._$AN, r.delete(e), e = t;
  } while ((r == null ? void 0 : r.size) === 0);
}, yL = (e) => {
  for (let t; t = e._$AM; e = t) {
    let r = t._$AN;
    if (r === void 0) t._$AN = r = /* @__PURE__ */ new Set();
    else if (r.has(e)) break;
    r.add(e), Qet(t);
  }
};
function Het(e) {
  this._$AN !== void 0 ? (Tm(this), this._$AM = e, yL(this)) : this._$AM = e;
}
function Get(e, t = !1, r = 0) {
  const n = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0) if (t) if (Array.isArray(n)) for (let s = r; s < n.length; s++) hf(n[s], !1), Tm(n[s]);
  else n != null && (hf(n, !1), Tm(n));
  else hf(this, e);
}
const Qet = (e) => {
  e.type == _2.CHILD && (e._$AP ?? (e._$AP = Get), e._$AQ ?? (e._$AQ = Het));
};
class Wet extends C2 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, r, n) {
    super._$AT(t, r, n), yL(this), this.isConnected = t._$AU;
  }
  _$AO(t, r = !0) {
    var n, i;
    t !== this.isConnected && (this.isConnected = t, t ? (n = this.reconnected) == null || n.call(this) : (i = this.disconnected) == null || i.call(this)), r && (hf(this, t), Tm(this));
  }
  setValue(t) {
    if (Uet(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const r = [...this._$Ct._$AH];
      r[this._$Ci] = t, this._$Ct._$AI(r, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const we = () => new qet();
class qet {
}
const Ev = /* @__PURE__ */ new WeakMap(), ge = k2(class extends Wet {
  render(e) {
    return Lt;
  }
  update(e, [t]) {
    var n;
    const r = t !== this.G;
    return r && this.G !== void 0 && this.rt(void 0), (r || this.lt !== this.ct) && (this.G = t, this.ht = (n = e.options) == null ? void 0 : n.host, this.rt(this.ct = e.element)), Lt;
  }
  rt(e) {
    if (this.isConnected || (e = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let r = Ev.get(t);
      r === void 0 && (r = /* @__PURE__ */ new WeakMap(), Ev.set(t, r)), r.get(this.G) !== void 0 && this.G.call(this.ht, void 0), r.set(this.G, e), e !== void 0 && this.G.call(this.ht, e);
    } else this.G.value = e;
  }
  get lt() {
    var e, t;
    return typeof this.G == "function" ? (e = Ev.get(this.ht ?? globalThis)) == null ? void 0 : e.get(this.G) : (t = this.G) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Oe = (e) => (t, r) => {
  r !== void 0 ? r.addInitializer(() => {
    customElements.define(e, t);
  }) : customElements.define(e, t);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Yet = { attribute: !0, type: String, converter: sm, reflect: !1, hasChanged: l6 }, Ket = (e = Yet, t, r) => {
  const { kind: n, metadata: i } = r;
  let s = globalThis.litPropertyMetadata.get(i);
  if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = /* @__PURE__ */ new Map()), n === "setter" && ((e = Object.create(e)).wrapped = !0), s.set(r.name, e), n === "accessor") {
    const { name: o } = r;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, l, e);
    }, init(a) {
      return a !== void 0 && this.C(o, void 0, e, a), a;
    } };
  }
  if (n === "setter") {
    const { name: o } = r;
    return function(a) {
      const l = this[o];
      t.call(this, a), this.requestUpdate(o, l, e);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function Qt(e) {
  return (t, r) => typeof r == "object" ? Ket(e, t, r) : ((n, i, s) => {
    const o = i.hasOwnProperty(s);
    return i.constructor.createProperty(s, n), o ? Object.getOwnPropertyDescriptor(i, s) : void 0;
  })(e, t, r);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Lr(e) {
  return Qt({ ...e, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const bL = (e, t, r) => (r.configurable = !0, r.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(e, t, r), r);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function U0(e) {
  return (t, r) => {
    const { slot: n, selector: i } = e ?? {}, s = "slot" + (n ? `[name=${n}]` : ":not([name])");
    return bL(t, r, { get() {
      var l;
      const o = (l = this.renderRoot) == null ? void 0 : l.querySelector(s), a = (o == null ? void 0 : o.assignedElements(e)) ?? [];
      return i === void 0 ? a : a.filter((c) => c.matches(i));
    } });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Zet(e) {
  return (t, r) => {
    const { slot: n } = {}, i = "slot" + (n ? `[name=${n}]` : ":not([name])");
    return bL(t, r, { get() {
      var o;
      const s = (o = this.renderRoot) == null ? void 0 : o.querySelector(i);
      return (s == null ? void 0 : s.assignedNodes(e)) ?? [];
    } });
  };
}
const sl = class sl {
  /**
   * Create a ScreenReaderBridge instance.
   * @param captionElement - the "caption" element, typically a span or div element
   */
  constructor(t) {
    this._maxNumPaddingCharacters = 3, this._numPaddingCharacters = 0, this._element = t, this._lastCreatedElement = null;
  }
  /**
   * Add the required aria attributes to an element for screen readers to properly work.
   * In order for the greatest number of screen reader and browser combinations to work, the following attributes must
   * be set on the element:
   * aria-live: assertive
   * roll: status
   * aria-atomic: true
   * aria-relevant: additions text
   * For the aria-live attribute, "polite" may also work, but that will create a queue of messages for the screen
   * reader to read out one after another which is probably not what you want.
   * @param element - the "caption" element which will host the messages for the screen reader to speak
   * @param [ariaLive] - the politeness of the aria-live attribute, one of "off", "assertive", or "polite"
   * @static
   */
  static addAriaAttributes(t, r = "assertive") {
    t.setAttribute("aria-live", r), t.setAttribute("role", "status"), t.setAttribute("aria-relevant", "additions text");
  }
  /**
   * The last created child element of the "caption" element.
   */
  get lastCreatedElement() {
    return this._lastCreatedElement;
  }
  /**
   * Clear the contents of the live region
   */
  clear() {
    this._element.innerHTML = "";
  }
  /**
   * Insert the provided text into the aria-live region.
   * @param text - the text to inserts
   */
  render(t) {
    const r = this._createPaddedText(t), n = document.createElement("div");
    n.textContent = r, n.setAttribute(
      sl.ORIGINAL_TEXT_ATTRIBUTE,
      t
    ), n.setAttribute("data-created", Date.now().toString()), this.lastCreatedElement && (this._removeOldElements(), this.lastCreatedElement.style.display = "none"), this._element.appendChild(n), this._lastCreatedElement = n;
  }
  /**
   * Pad the provided text with the padding character.
   * Padding the text tricks screen readers into speaking it, even if they think it should be suppressed.
   * @param text - the text to pad
   * @private
   */
  _createPaddedText(t) {
    let r = "";
    for (let n = 0; n < this._numPaddingCharacters; n++)
      r += sl.PADDING_CHARACTER;
    return this._numPaddingCharacters = (this._numPaddingCharacters + 1) % this._maxNumPaddingCharacters, t + r;
  }
  /**
   * Remove any hidden elements that were hidden longer than the set milliseconds.
   * We wait to remove those elements even though they are hidden because some screen readers don't like the DOM
   * changing that much.
   * @private
   */
  _removeOldElements() {
    const t = Date.now();
    Array.from(this._element.children).forEach((r) => {
      const n = Number(r.getAttribute("data-time"));
      t - n > sl.REMOVAL_DELAY && this._element.removeChild(r);
    });
  }
};
sl.PADDING_CHARACTER = "", sl.REMOVAL_DELAY = 25, sl.ORIGINAL_TEXT_ATTRIBUTE = "data-original-text";
let Bf = sl;
const Fy = class Fy extends Bf {
  /**
   * Insert the provided text & highlights into the aria-live region.
   * @param text - the text to insert
   * @param highlights - the highlights to insert
   */
  renderHighlights(t, r) {
    super.render(t), this._lastCreatedElement.setAttribute(
      Fy.ORIGINAL_HIGHLIGHT_ATTRIBUTE,
      JSON.stringify(r)
    );
  }
};
Fy.ORIGINAL_HIGHLIGHT_ATTRIBUTE = "data-original-highlight";
let Om = Fy;
var Jet = Object.defineProperty, Xet = Object.getOwnPropertyDescriptor, vL = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Xet(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && Jet(t, r, i), i;
};
let Lm = class extends zi {
  constructor() {
    super(...arguments), this.announcement = { text: "", html: "", highlights: [], startFrom: 0 }, this._ariaLiveRef = we(), this._history = [], this._historyDialogRef = we();
  }
  get voicing() {
    return this._voicing;
  }
  // @simonvarey: I added this so that `Voicing` could receive `store` and `shadowRoot` for highlighting.
  //   In theory, it should have been possible to add this to `_initAriaLiveRegion`, but that
  //   caused errors when I tried.
  connectedCallback() {
    super.connectedCallback(), this._voicing = new Vet(this.store);
  }
  _setHistory(e) {
    this._history = e, this._historyDialogRef.value.history = e;
  }
  willUpdate(e) {
    e.has("announcement") && this.announcement.text && (this.announcement.clear && this._srb.clear(), this._srb.renderHighlights(this.announcement.text, this.announcement.highlights));
  }
  firstUpdated(e) {
    var t;
    this._initAriaLiveRegion((t = this.shadowRoot) == null ? void 0 : t.querySelector("div"));
  }
  _initAriaLiveRegion(e) {
    Bf.addAriaAttributes(e), e.setAttribute("lang", "en"), this._srb = new Om(e), new MutationObserver((r) => {
      r.forEach((n) => {
        if (n.addedNodes.length === 0)
          return;
        const i = n.addedNodes[0], s = i.getAttribute(Bf.ORIGINAL_TEXT_ATTRIBUTE), o = i.getAttribute(Om.ORIGINAL_HIGHLIGHT_ATTRIBUTE);
        this._setHistory([...this._history, s ?? ""]), s && this._store.settings.ui.isVoicingEnabled && this._store.settings.ui.isAnnouncementEnabled && this._voicing.speak(s, JSON.parse(o), this.announcement.startFrom);
      });
    }).observe(e, {
      childList: !0
    });
  }
  showHistoryDialog() {
    this._historyDialogRef.value.show();
  }
  clear() {
    this._srb.clear();
  }
  get lastAnnouncement() {
    var e;
    return (e = this._srb.lastCreatedElement) == null ? void 0 : e.textContent;
  }
  replay() {
    const e = this.lastAnnouncement;
    e && this._store.announce(e);
  }
  render() {
    return this._voicing.rate = this._store.settings.ui.speechRate, Ht`
      <div
        ${ge(this._ariaLiveRef)}
        class="sr-only"
        data-testid="sr-status"
      ></div>
      <para-aria-live-history-dialog
        ${ge(this._historyDialogRef)}
      ></para-aria-live-history-dialog>
    `;
  }
};
Lm.styles = [
  u5,
  Te`
      div {
        white-space: pre-line;
      }
    `
];
vL([
  Qt({ type: Object })
], Lm.prototype, "announcement", 2);
Lm = vL([
  Oe("para-aria-live-region")
], Lm);
var trt = Object.defineProperty, ert = Object.getOwnPropertyDescriptor, h5 = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? ert(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && trt(t, r, i), i;
};
let jf = class extends zi {
  constructor() {
    super(...arguments), this._dialogRef = we(), this.btnText = "Okay", this.history = [];
  }
  render() {
    const e = [{ tag: "cancel", text: this.btnText }];
    return Ht`
      <fizz-dialog
        ${ge(this._dialogRef)} 
        title="History" 
        .buttons=${e}
      >
        <ul class="history"
        >
          ${this.history.map((t) => Ht`
              <li>${t}</li>
            `)}
        </ul>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
jf.styles = Te`
    .history {
      align-self: stretch;
    }
  `;
h5([
  Qt()
], jf.prototype, "btnText", 2);
h5([
  Qt({ type: Array })
], jf.prototype, "history", 2);
jf = h5([
  Oe("para-aria-live-history-dialog")
], jf);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const wL = "important", rrt = " !" + wL, ln = k2(class extends C2 {
  constructor(e) {
    var t;
    if (super(e), e.type !== _2.ATTRIBUTE || e.name !== "style" || ((t = e.strings) == null ? void 0 : t.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(e) {
    return Object.keys(e).reduce((t, r) => {
      const n = e[r];
      return n == null ? t : t + `${r = r.includes("-") ? r : r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${n};`;
    }, "");
  }
  update(e, [t]) {
    const { style: r } = e.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const n of this.ft) t[n] == null && (this.ft.delete(n), n.includes("-") ? r.removeProperty(n) : r[n] = null);
    for (const n in t) {
      const i = t[n];
      if (i != null) {
        this.ft.add(n);
        const s = typeof i == "string" && i.endsWith(rrt);
        n.includes("-") || s ? r.setProperty(n, s ? i.slice(0, -11) : i, s ? wL : "") : r[n] = i;
      }
    }
    return la;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Rr = k2(class extends C2 {
  constructor(e) {
    var t;
    if (super(e), e.type !== _2.ATTRIBUTE || e.name !== "class" || ((t = e.strings) == null ? void 0 : t.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(e) {
    return " " + Object.keys(e).filter((t) => e[t]).join(" ") + " ";
  }
  update(e, [t]) {
    var n, i;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), e.strings !== void 0 && (this.nt = new Set(e.strings.join(" ").split(/\s/).filter((s) => s !== "")));
      for (const s in t) t[s] && !((n = this.nt) != null && n.has(s)) && this.st.add(s);
      return this.render(t);
    }
    const r = e.element.classList;
    for (const s of this.st) s in t || (r.remove(s), this.st.delete(s));
    for (const s in t) {
      const o = !!t[s];
      o === this.st.has(s) || (i = this.nt) != null && i.has(s) || (o ? (r.add(s), this.st.add(s)) : (r.remove(s), this.st.delete(s)));
    }
    return la;
  }
}), Mo = Te`
  :host {
    --theme-color: var(--fizz-theme-color, purple);
    --theme-contrast-color: var(--fizz-theme-contrast-color, ghostwhite);
    --theme-extra-color: var(--fizz-theme-extra-color, ghostwhite);
    --theme-color-light: var(--fizz-theme-color-light, hsl(275.4, 100%, 88%));
    --theme-text-color: var(--fizz-theme-text-color, var(--theme-color, black));
    --theme-unselected-text-color: var(--fizz-theme-unselected-text-color, var(--theme-contrast-color, black));
    --theme-selected-text-decoration: var(--fizz-theme-selected-text-decoration, none);
    --control-panel-icon-color: var(--theme-unselected-text-color, ghostwhite);
    --contents-overflow: hidden;
  }

  /* * {
    background: var(--background, var(--theme-contrast-color));
  }*/
  .hidden {
    display: none !important;
  }

  .sr-only {
    width:1px;
    height:1px;
    overflow:hidden;
  }

`;
var nrt = Object.defineProperty, irt = Object.getOwnPropertyDescriptor, Tn = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? irt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && nrt(t, r, i), i;
};
let xu = class extends Ir {
  constructor() {
    super(...arguments), this.inline = !1, this.mode = "labels", this.tabs = [], this.icons = [], this.tabListRef = we(), this.tabRefs = [];
  }
  set panelGroup(t) {
    if (this._panelGroup)
      throw new Error("panel group element is already set");
    this._panelGroup = t;
  }
  set currentPanel(t) {
    this.tabRefs.forEach((r, n) => {
      r.value.selected = n === t;
    }), this._panelGroup.currentPanel = t;
  }
  connectedCallback() {
    super.connectedCallback(), this.inline && (this.style.display = "inline-block");
  }
  updated(t) {
    t.get("tabs") && (this.currentPanel = 0);
  }
  keyListener(t) {
    console.log("keyListener", t.detail.key), console.log("target", t.target), console.log("currentTarget", t.currentTarget);
  }
  // @keydown=${this.keyListener}
  render() {
    const t = {
      background: "none",
      padding: "0",
      "flex-grow": 1
    };
    return Ht`
      <ul
        ${ge(this.tabListRef)}
        role="tablist"
        class="tablist"
        style=${this.inline ? ln(t) : Lt}
        @tabclick=${(r) => {
      this.currentPanel = r.detail;
    }}
        @keynav=${(r) => {
      this.keyListener(r);
    }}
      >
        ${this.tabs.map((r, n) => {
      var i;
      return (i = this.tabRefs)[n] ?? (i[n] = we()), Ht`
              <fizz-tab
                ${ge(this.tabRefs[n])}
                .mode=${this.mode}
                .icon=${this.icons[n]}
                index=${n}
              >
                <span>${r}</span>
              </fizz-tab>
            `;
    })}
      </ul>
    `;
  }
};
xu.styles = [
  Mo,
  Te`
      :host {
        display: block;
      }
      .tablist {
        display: flex;
        background: var(--background, var(--theme-color));
        padding: var(--padding, 0.25rem 0.25rem 0 0.25rem);
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
        gap: var(--tab-gap, 0);
        font-size: var(--tab-font-size, unset);
        font-weight: var(--tab-font-weight, unset);
        margin: 0;
      }
    `
];
Tn([
  Qt({ type: Boolean })
], xu.prototype, "inline", 2);
Tn([
  Qt()
], xu.prototype, "mode", 2);
Tn([
  Lr()
], xu.prototype, "tabs", 2);
Tn([
  Lr()
], xu.prototype, "icons", 2);
xu = Tn([
  Oe("fizz-tab-list")
], xu);
let Mm = class extends Ir {
  constructor() {
    super(...arguments), this._currentPanel = 0;
  }
  get numPanels() {
    return this.panelEls.length;
  }
  get currentPanel() {
    return this._currentPanel;
  }
  set currentPanel(t) {
    this._currentPanel = t, this.panelEls.forEach(
      (r, n) => r.setSelected(n === this._currentPanel)
    );
  }
  connectedCallback() {
    super.connectedCallback(), this.tabListEl = this.findTabList(), this.tabListEl.panelGroup = this;
  }
  findTabList() {
    let t = this.parentElement;
    for (; t; ) {
      const r = t.querySelector("fizz-tab-list");
      if (r)
        return r;
      t = t.parentElement;
    }
    throw new Error("unable to locate tab list");
  }
  render() {
    return Ht`
      <div class="panels">
        <slot @slotchange=${(t) => {
      var r;
      this.tabListEl.tabs = this.panelEls.map((n) => n.tabLabel), (r = this.panelEls[0]) != null && r.icon && (this.tabListEl.icons = this.panelEls.map((n) => {
        if (n.icon)
          return n.icon;
        throw new Error(`panel '${n.tabLabel}' icon missing`);
      }));
    }}></slot>
      </div>
    `;
  }
};
Mm.styles = [
  Mo,
  Te`
      :host {
        display: block;
      }
      .panels {
        border-radius: var(--border-radius, 0 0 0.15rem 0.15rem);
      }
    `
];
Tn([
  U0()
], Mm.prototype, "panelEls", 2);
Mm = Tn([
  Oe("fizz-tab-panel-group")
], Mm);
let Eu = class extends Ir {
  constructor() {
    super(...arguments), this.tabLabel = "TAB", this.visible = !1, this.panelRef = we();
  }
  // get slottedNodes() {
  //   return this.slotRef.value!.assignedNodes();
  // }
  firstUpdated(t) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  render() {
    return Ht`
      <div
        ${ge(this.panelRef)}
        role="tabpanel"
        tabindex="0"
        class="panel"
        ?hidden=${!this.visible}
      >
        <slot></slot>
      </div>
    `;
  }
  setSelected(t) {
    this.visible = t;
  }
};
Eu.styles = [
  Mo,
  Te`
      :host {
        display: block;
      }
      .panel {
        border-radius: var(--border-radius, 0 0 0.15rem 0.15rem);
      }
    `
];
Tn([
  Qt()
], Eu.prototype, "tabLabel", 2);
Tn([
  Qt()
], Eu.prototype, "icon", 2);
Tn([
  Zet()
], Eu.prototype, "contentNodes", 2);
Tn([
  Lr()
], Eu.prototype, "visible", 2);
Eu = Tn([
  Oe("fizz-tab-panel")
], Eu);
let np = class extends Ir {
  constructor() {
    super(...arguments), this.selected = !1, this.ref = we();
  }
  activate(t) {
    t.preventDefault(), t.stopPropagation(), this.dispatchEvent(
      new CustomEvent(
        "tabclick",
        {
          bubbles: !0,
          composed: !0,
          detail: this.index
        }
      )
    );
  }
  keyListener(t) {
    t.preventDefault(), t.stopPropagation(), this.dispatchEvent(
      new CustomEvent(
        "keynav",
        {
          bubbles: !0,
          composed: !0,
          detail: t
        }
      )
    );
  }
  render() {
    const t = {
      hidden: this.mode === "icons" || this.mode === "icons-current-label" && !this.selected
    }, r = {
      icon: this.mode !== "labels"
    }, n = {
      mask: this.icon ? `url("${this.icon}") no-repeat 50% 50%` : void 0,
      "mask-size": "cover"
    };
    return Ht`
      <li
        role="presentation"
      >
        <button
          ${ge(this.ref)}
          role="tab"
          id="tab${this.index}"
          tabindex=${this.selected ? Lt : "-1"}
          aria-selected=${this.selected ? "true" : "false"}
          class="tab"
          @keydown=${(i) => {
      this.keyListener(i);
    }}
          @click=${(i) => this.activate(i)}
        >
          ${this.icon ? Ht`
            <span
              class=${Rr(r)}
              style=${ln(n)}
            >
            </span>
          ` : ""}
          <slot class=${Rr(t)}>
            TAB LABEL
          </slot>
        </button>
      </li>
    `;
  }
};
np.styles = [
  Mo,
  Te`
      :host {
        background: none !important;
      }
      li {
        list-style-type: none;
      }
      .tab {
        padding: var(--padding, 0.25rem 0.4rem);
        cursor: pointer;
        border: none;
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
      }
      [role='tab'] {
        color: var(--background-selected, var(--theme-unselected-text-color, var(--theme-extra-color)));
        background: none;
      }
      [role='tab'][aria-selected='true'] {
        background: var(--background-selected, var(--theme-extra-color));
        color: var(--theme-text-color, var(--color-selected, var(--theme-color)));
        text-decoration: var(--theme-selected-text-decoration) var(--theme-text-color);
        text-underline-offset: 0.25rem;
      }
      .icon {
        height: 1.2rem;
        width: 1.2rem;
        vertical-align: middle;
        background-color: currentColor;
        display: inline-block;
        margin-top: -0.5rem;
      }
      [role='tab-delete'] {
        background: var(--color, var(--theme-color));
      }
    `
];
Tn([
  Qt({ type: Number })
], np.prototype, "index", 2);
Tn([
  Lr()
], np.prototype, "selected", 2);
Tn([
  Lr()
], np.prototype, "mode", 2);
np = Tn([
  Oe("fizz-tab")
], np);
const srt = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2016.9%2016.9'%3e%3cg%20id='layer1'%3e%3ccircle%20style='fill:%23ffffff;%20stroke-width:0.3;'%20id='path1'%20cx='8.5'%20cy='8.5'%20r='8.5'%20/%3e%3cpath%20id='path2'%20style='fill:%23040404;%20stroke-width:0.3'%20d='M%204.2,5.3%205.3,4.2%208.5,7.4%2011.6,4.2%2012.7,5.3%209.5,8.5%2012.7,11.6%2011.6,12.7%208.5,9.5%205.3,12.7%204.2,11.6%207.4,8.5%20Z'%20/%3e%3c/g%3e%3c/svg%3e";
var ort = Object.defineProperty, art = Object.getOwnPropertyDescriptor, Mr = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? art(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && ort(t, r, i), i;
};
let Pi = class extends Ir {
  constructor() {
    super(), this.dialogRef = we(), this.xButtonRef = we(), this.cancel = { key: !0, button: !0, click: !0 }, this.modal = !1, this.x = "0", this.y = "0", this.tx = 0, this.ty = 0, this.open = !1, this.title = "", this.onDocumentClick = (t) => {
      this.isWithinRect(t.clientX, t.clientY, this.dialogRef.value.getBoundingClientRect()) || this.didCancel(t);
    };
  }
  isWithinRect(t, r, n) {
    return !(t < n.left || t > n.right || r < n.top || r > n.bottom);
  }
  render() {
    const t = this.modal ? { translate: `${this.tx}px ${this.ty}px;` } : {
      left: this.x,
      top: this.y,
      margin: 0
    };
    return this.width && (t.width = this.width), this.height && (t.height = this.height), Ht`
      <dialog
        ${ge(this.dialogRef)}
        @cancel=${this.didCancel}
        style=${ln(t)}
		aria-label = ${this.title}
      >
        <div class="content">
          ${this.cancel.button ? Ht`
              <button type="button" class="close-x" @click=${this.didCancel}>
                <img src=${srt} alt="Dialog close button">
                <span>Close</span>
              </button>
              ` : ""}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  firstUpdated(t) {
    this.open && this.show(), this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  async didCancel(t) {
    if (t.preventDefault(), !(t.type === "cancel" && !this.cancel.key || t.type === "click" && t.target === this.xButtonRef.value && !this.cancel.button))
      if (this.onCancel) {
        const r = await this.onCancel();
        r.close && this.close(r.value);
      } else
        this.close();
  }
  /**
   * Show the overlay.
   * @param afterShow - A function that will be called immediately after showing the overlay.
   * Can be useful if awaiting this method.
   * @returns Promise of string return value (typically the tag of the button
   * that caused the closure).
   * @remarks
   * This method can be awaited until the overlay is closed.
   */
  show(t) {
    return this.dialogRef.value.open ? this.promise : (this.modal ? this.dialogRef.value.showModal() : this.dialogRef.value.show(), this.cancel.click && setTimeout(() => document.addEventListener("click", this.onDocumentClick)), this.promise = new Promise((r) => {
      this.resolve = r, this.xButtonRef.value.focus(), t == null || t();
    }), this.promise);
  }
  /**
   * Close the overlay.
   * @param value - Value to resolve the promise with.
   */
  close(t = "ui_default_close") {
    this.dialogRef.value.close(), this.cancel.click && document.removeEventListener("click", this.onDocumentClick), this.resolve(t);
  }
};
Pi.styles = Te`
    dialog {
      padding: 0;
      border: none;
      box-shadow: 0 0 40px rgb(127, 127, 127);
      border-radius: var(--border-radius, 0.15rem);
      border: none;
    }
    dialog .content {
      position: relative;
      background: var(--theme-color-constrast, ghostwhite);
      border: solid var(--theme-color) 1px;
      border-radius: var(--border-radius, 0.15rem);
      min-width: 15rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
    }
    button.close-x {
      position: absolute;
      right: 0.25rem;
      top: 0.25rem;
      /*height: calc(100% - 0.5rem); // titlebar height minus padding */
      padding: 0;
      background: transparent;
      border: 0;
    }
    button.close-x img {
      height: 1.3em;
    }
    button.close-x span {
      display: none;
    }
  `;
Mr([
  Qt({ type: Object })
], Pi.prototype, "cancel", 2);
Mr([
  Qt({ type: Boolean })
], Pi.prototype, "modal", 2);
Mr([
  Qt()
], Pi.prototype, "x", 2);
Mr([
  Qt()
], Pi.prototype, "y", 2);
Mr([
  Qt()
], Pi.prototype, "width", 2);
Mr([
  Qt()
], Pi.prototype, "height", 2);
Mr([
  Qt({ type: Number })
], Pi.prototype, "tx", 2);
Mr([
  Qt({ type: Number })
], Pi.prototype, "ty", 2);
Mr([
  Qt({ type: Boolean })
], Pi.prototype, "open", 2);
Mr([
  Qt()
], Pi.prototype, "title", 2);
Pi = Mr([
  Oe("fizz-overlay")
], Pi);
let Ff = class extends Ir {
  constructor() {
    super(), this.prevX = 0, this.prevY = 0, this.tx = 0, this.ty = 0, this.title = "TITLE", this.buttons = [
      { tag: "cancel", text: "Cancel" },
      { tag: "okay", text: "Okay" }
    ], this.moveListener = this.move.bind(this);
  }
  render() {
    const t = JSON.stringify({ key: !0, button: !0, click: !1 });
    return Ht`
      <fizz-overlay modal cancel=${t} title = ${this.title}>
        <div
          class="title"
          @pointerdown=${this.titlebarPointerDown}
          @pointerup=${this.titlebarPointerUp}
        >
          ${this.title}
        </div>
        <slot></slot>
        <div class="buttons">
          ${this.buttons.map((r) => Ht`
            <button id=${r.tag} ?disabled=${r.disabled} @click=${this.btnClicked}>
              ${r.text}
            </button>
            `)}
        </div>
      </fizz-overlay>
    `;
  }
  firstUpdated(t) {
    this.titlebar = this.renderRoot.querySelector(".title"), this.btnsWrapper = this.renderRoot.querySelector(".buttons"), this.overlay = this.renderRoot.querySelector("fizz-overlay"), this.overlay.onCancel = async () => await this.didCancel();
  }
  titlebarPointerDown(t) {
    this.prevX = t.clientX, this.prevY = t.clientY, this.titlebar.addEventListener("pointermove", this.moveListener), this.titlebar.setPointerCapture(t.pointerId);
  }
  titlebarPointerUp(t) {
    this.titlebar.removeEventListener("pointermove", this.moveListener), this.titlebar.releasePointerCapture(t.pointerId);
  }
  move(t) {
    this.tx += t.clientX - this.prevX, this.prevX = t.clientX, this.ty += t.clientY - this.prevY, this.prevY = t.clientY, this.overlay.tx = this.tx, this.overlay.ty = this.ty;
  }
  async didCancel() {
    const t = this.buttonInfo("cancel");
    if (t) {
      const r = t.closeHook;
      return { close: r ? await r("cancel") : !0, value: "cancel" };
    } else
      return { close: !0 };
  }
  /**
   * Get the disabled state of all buttons.
   * @returns Mapping of button tags to disabled states.
   */
  getButtonsDisabled() {
    const t = {};
    for (const { tag: r } of this.buttons)
      t[r] = this.renderRoot.querySelector(`#${r}`).disabled;
    return t;
  }
  /**
   * Set the disabled state of specific buttons.
   * @param state - Mapping of button tags to desired disabled values.
   * All buttons will be disabled if this is omitted.
   * @returns Previous button disabled states if called with no argument.
   */
  setButtonsDisabled(t) {
    if (t)
      for (const [r, n] of Object.entries(t))
        this.renderRoot.querySelector(`#${r}`).disabled = n;
    else {
      const r = this.getButtonsDisabled();
      return this.renderRoot.querySelectorAll("button").forEach((n) => {
        n.disabled = !0;
      }), r;
    }
  }
  buttonInfo(t) {
    return this.buttons.find((r) => r.tag === t);
  }
  /**
   * Get the button corresponding to a specific tag..
   * @param tag - Button tag.
   * @returns Button element (or null).
   */
  button(t) {
    return this.renderRoot.querySelector(`#${t}`);
  }
  async btnClicked(t) {
    const r = this.setButtonsDisabled(), n = this.buttonInfo(t.target.id);
    (!n.closeHook || await n.closeHook(n.tag)) && this.overlay.close(n.tag), this.setButtonsDisabled(r);
  }
  /**
   * Show the dialog.
   * @param afterShow - A function that will be called immediately after showing the dialog.
   * Can be useful if awaiting this method.
   * @returns Promise of string return value (typically the tag of the button
   * that caused the closure).
   * @remarks
   * This method can be awaited until the dialog is closed.
   */
  show(t) {
    for (const { tag: r, disabled: n } of this.buttons)
      this.renderRoot.querySelector(`#${r}`).disabled = !!n;
    return this.overlay.tx = 0, this.overlay.ty = 0, this.tx = 0, this.ty = 0, this.prevX = 0, this.prevY = 0, this.overlay.show(t);
  }
};
Ff.styles = Te`
    .title {
      /*background: darkblue;
      color: white;*/
      font-weight: bold;
      align-self: stretch;
      text-align: center;
      padding: 0.25rem;
      margin-bottom: 0.5rem;
      border-radius: var(--border-radius, 0.15rem);
      /* If I leave this out, the title content area ends up every so slightly
         taller than the button image.*/
      height: 1rlh;
    }
    .buttons {
      padding: 0.5rem;
      display: flex;
      gap: 0.5rem;
    }


    .buttons button {
      --theme-color: purple;
      --theme-contrast-color: ghostwhite;

      margin: 0.2rem;
      background-color: var(--theme-color);
      color: var(--theme-contrast-color);
      border: thin solid var(--theme-color);
      border-radius: 0.2em;
      padding: 0.2em 0.4em;
    }
  `;
Mr([
  Qt()
], Ff.prototype, "title", 2);
Mr([
  Qt({ type: Array })
], Ff.prototype, "buttons", 2);
Ff = Mr([
  Oe("fizz-dialog")
], Ff);
let Nm = class extends Ir {
  constructor() {
    super(...arguments), this.btnText = "Okay", this.text = "Your message here";
  }
  render() {
    const t = JSON.stringify([{ tag: "cancel", text: this.btnText }]);
    return Ht`
      <fizz-dialog title="Message" buttons=${t}>
        <div class="text">${this.text}</div>
      </fizz-dialog>
    `;
  }
  firstUpdated(t) {
    this.dialog = this.renderRoot.querySelector("fizz-dialog");
  }
  /**
   * Show the dialog
   * @param text - Optional message text.
   */
  async show(t) {
    t && (this.text = t), await this.dialog.show(() => this.dialog.button("cancel").focus());
  }
};
Mr([
  Qt()
], Nm.prototype, "btnText", 2);
Mr([
  Qt()
], Nm.prototype, "text", 2);
Nm = Mr([
  Oe("fizz-msg-dialog")
], Nm);
let $f = class extends Ir {
  constructor() {
    super(...arguments), this.cancelText = "Cancel", this.okayText = "Okay", this.text = "Text";
  }
  render() {
    const t = JSON.stringify([
      { tag: "cancel", text: this.cancelText },
      { tag: "okay", text: this.okayText }
    ]);
    return Ht`
      <fizz-dialog title="Confirm" buttons=${t}>
        <div class="text">${this.text}</div>
      </fizz-dialog>
    `;
  }
  firstUpdated(t) {
    this.dialog = this.renderRoot.querySelector("fizz-dialog");
  }
  /**
   * Show the dialog.
   * @param text - Message text.
   * @param cancelText - Cancel button text.
   * @param okayText - Confirm (okay) button text.
   * @returns Promise of boolean indicating whether the user confirmed or cancelled.
   */
  async show(t, r, n) {
    return t && (this.text = t), r && (this.cancelText = r), n && (this.okayText = n), await this.dialog.show(() => this.dialog.button("okay").focus()) === "okay";
  }
};
Mr([
  Qt()
], $f.prototype, "cancelText", 2);
Mr([
  Qt()
], $f.prototype, "okayText", 2);
Mr([
  Qt()
], $f.prototype, "text", 2);
$f = Mr([
  Oe("fizz-conf-dialog")
], $f);
var lrt = Object.defineProperty, crt = Object.getOwnPropertyDescriptor, xL = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? crt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && lrt(t, r, i), i;
};
let Dm = class extends Ir {
  constructor() {
    super(...arguments), this.inputDescriptors = {};
  }
  /*private ref(key: string) {
    console.log(`this.ref("${key}")`);
    if (this.refs.has(key)) {
      console.log('found ref');
      return this.refs.get(key);
    } else {
      const r = createRef<HTMLInputElement>();
      console.log('new ref:', r);
      this.refs.set(key, r);
      return r;
    }
  }*/
  firstUpdated(t) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  render() {
    return Ht`
      <fieldset>
        <legend>
          <slot name="legend"></slot>
        </legend>
        <slot name="before"></slot>
        ${Object.entries(this.inputDescriptors).map(([t, r]) => Ht`
            <label for=${t.toLowerCase()}>
              ${r.label}
              <input
                id=${t.toLowerCase()}
                type=${r.type ?? "text"}
                value=${r.value ?? Lt}
                placeholder=${r.placeholder ?? Lt}
                size=${r.size ?? Lt}
                min=${r.min ?? Lt}
                max=${r.max ?? Lt}
                @input=${(n) => this.dispatchEvent(
      new CustomEvent("edit", { bubbles: !0, composed: !0 })
    )}
                @change=${(n) => this.dispatchEvent(
      new CustomEvent("commit", { bubbles: !0, composed: !0 })
    )}
              />
            </label>
          `)}
        <slot name="after"></slot>
      </fieldset>
    `;
  }
  getInputs() {
    const t = {};
    for (const r of Object.keys(this.inputDescriptors))
      t[r] = this.renderRoot.querySelector(`#${r.toLowerCase()}`);
    return t;
  }
  /**
   * Determine whether all text fields are set to a value or not.
   * @returns Whether all fields have non-empty values.
   */
  isAllFieldsSet() {
    return Object.values(this.getInputs()).every((t) => t.value);
  }
  /**
   * Retrieve the current values of all text fields.
   * @returns Mapping of field keys to string values.
   */
  fieldValues() {
    const t = {};
    for (const [r, n] of Object.entries(this.getInputs()))
      t[r] = n.value;
    return t;
  }
  /**
   * Set the values of all text fields.
   * @param values - Mapping of field keys to new values.
   */
  setFieldValues(t) {
    const r = this.getInputs();
    for (const [n, i] of Object.entries(t))
      r[n].value = i;
  }
};
Dm.styles = [
  Mo,
  Te`
      :host {
        display: block;
      }
      fieldset {
        display: flex;
        flex-direction: column;
        border-radius: var(--border-radius, 0.15rem);
        border-style: solid;
        border-width: 1px;
        border-color: var(--fieldset-border-color, var(--theme-color));
        color: var(--color, black);
        padding: 1rem;
        align-items: stretch;
      }
      legend {
        border-radius: var(--legend-border-radius, 0.15rem);
        padding: 0.25rem 0.5rem;
        background: var(--legend-background, var(--theme-color));
        color: var(--legend-color, var(--theme-extra-color));
      }
      label {
        display: flex;
        flex-direction: column;
        font-size: 0.75rem;
      }
      input {
        margin-left: 0;
        background: var(--input-background, white);
      }
    `
];
xL([
  Qt({ type: Object })
], Dm.prototype, "inputDescriptors", 2);
Dm = xL([
  Oe("fizz-textfieldset")
], Dm);
const urt = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2016.93%2016.93'%3e%3cdefs%20id='defs1'%20/%3e%3cg%20id='layer1'%3e%3ccircle%20style='fill:%23000000;stroke-width:0.36;fill-opacity:1'%20id='circle'%20cx='8.5'%20cy='8.5'%20r='8.5'%20/%3e%3cpath%20style='fill:%23ffffff;stroke-width:0.26;'%20d='m%207.4,9.4%20q%200,-0.6%200.25,-0.9%20Q%207.9,8.1%208.5,7.6%208.97,7.3%209.2,7%20q%200.25,-0.3%200.25,-0.6%200,-0.4%20-0.3,-0.54%20Q%208.88,5.66%208.41,5.66%207.93,5.66%207.47,5.80%207.01,5.95%206.52,6.20%20L%205.92,4.99%20Q%206.47,4.69%207.12,4.49%207.76,4.30%208.53,4.30%20q%201.17,0%201.81,0.6%200.65,0.6%200.65,1.43%200,0.46%20-0.14,0.80%20-0.14,0.33%20-0.44,0.63%20Q%2010.12,8.02%209.68,8.34%209.35,8.58%209.17,8.75%208.99,8.92%208.92,9.08%208.87,9.23%208.87,9.47%20V%209.80%20H%207.4%20Z%20m%20-0.18,2.29%20q%200,-0.51%200.28,-0.72%200.28,-0.21%200.68,-0.21%200.39,0%200.67,0.21%200.28,0.20%200.28,0.72%200,0.49%20-0.28,0.72%20-0.28,0.21%20-0.67,0.21%20-0.40,0%20-0.68,-0.21%20-0.28,-0.25%20-0.28,-0.72%20z'%20id='questionmark'%20aria-label='?'%20/%3e%3c/g%3e%3c/svg%3e";
var hrt = (e, t, r, n) => {
  for (var i = t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let F3 = class extends Ir {
  render() {
    return Ht`
      <button type="button" class="icon" @click=${this.onIconClick}>
        <img src=${urt} alt="Info pop-up icon">
        <span>Get info about this item</span>
      </button>
      <fizz-overlay>
        <slot></slot>
      </fizz-overlay>
    `;
  }
  firstUpdated(t) {
    this.overlay = this.renderRoot.querySelector("fizz-overlay"), this.icon = this.renderRoot.querySelector(".icon"), this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  onIconClick(t) {
    const r = this.icon.getBoundingClientRect();
    this.overlay.x = `calc(${r.x}px + 0.5rem)`, this.overlay.y = `calc(${r.y}px + 0.5rem)`, this.overlay.show();
  }
};
F3.styles = Te`
    button.icon {
      padding: 0;
      background: none;
      color: white;
      padding: 0;
      border: 0;
    }
    button.icon img {
      height: 1rem;
      vertical-align: bottom;
    }
    button.icon:hover {
    }
    button.icon span {
        display: none;
    }
  `;
F3 = hrt([
  Oe("fizz-infopopup")
], F3);
const p5 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMS4yNXJlbSIgaGVpZ2h0PSIxLjI1cmVtIiB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGNpcmNsZSBzdHlsZT0ic3Ryb2tlOmdob3N0d2hpdGU7IHN0cm9rZS13aWR0aDoxLjhweDsgZmlsbDpub25lOyIgY3g9IjEwIiBjeT0iMTAiIHI9IjkiLz48dGV4dCB4PSIxMCIgeT0iMTYiIHN0eWxlPSJmaWxsOmdob3N0d2hpdGU7IGZvbnQ6Ym9sZCAxOHB4ICdUaW1lcyBOZXcgUm9tYW4nLFRpbWVzLHNlcmlmOyB0ZXh0LWFuY2hvcjptaWRkbGU7Ij5pPC90ZXh0Pgo8L3N2Zz4K";
var prt = Object.defineProperty, drt = Object.getOwnPropertyDescriptor, d5 = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? drt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && prt(t, r, i), i;
};
let zf = class extends Ir {
  constructor() {
    super(...arguments), this.open = !1;
  }
  render() {
    return Ht`
      <details ?open=${this.open} @toggle=${() => this.dispatchEvent(new CustomEvent(
      this.details.open ? "open" : "close",
      { bubbles: !0, composed: !0 }
    ))}>
        <summary>
          <slot name="summary">Label</slot>
        </summary>
        <div class="content">
          <slot name="content">Contents</slot>
        </div>
      </details>
    `;
  }
  firstUpdated(t) {
    this.details = this.renderRoot.querySelector("details"), this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  /**
   * Replace the contents with the given elements.
   * @param newElements - Elements.
   */
  setContents(...t) {
    this.contents.forEach((r) => r.remove()), t.forEach((r) => {
      r.slot = "contents", this.append(r);
    });
  }
};
zf.styles = [
  Mo,
  Te`
      :host {
        display: block;
      }
      details {
        /* Only shows up at the corners of the content area */
        background: var(--background, var(--theme-color));
        border-radius: var(--border-radius, 0.15rem);
        border: 1px solid var(--background, var(--border, var(--theme-color)));
      }
      summary {
        background: var(--background, var(--theme-color));
        color: var(--color, var(--theme-contrast-color));
        padding: 0;
        padding-top: 2px;
        padding-left: 2px;
        list-style-type: none;
      }
      summary::before {
        display: inline-block;
        width: var(--summary-marker-size, 1.1rem);
        height: var(--summary-marker-size, 1.1rem);
        margin-left: 2px;
        margin-top: 1px;
        margin-right: 2px;
        content: '';
        background-color: var(--summary-marker-color, var(--theme-contrast-color));
        mask-image: var(--summary-marker, url(${du(p5)}));
        mask-size: cover;
        cursor: pointer;
      }
      .content {
        background: var(--content-background, var(--theme-contrast-color));
        color: var(--content-color, black);
        padding: var(--content-padding, 0 0.25rem);
        border-radius: var(--border-radius, 0.15rem);
        overflow: var(--content-overflow, hidden);
      }
    `
];
d5([
  Qt({ type: Boolean })
], zf.prototype, "open", 2);
d5([
  U0({ slot: "contents" })
], zf.prototype, "contents", 2);
zf = d5([
  Oe("fizz-details")
], zf);
var frt = Object.defineProperty, grt = Object.getOwnPropertyDescriptor, H0 = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? grt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && frt(t, r, i), i;
};
let Au = class extends Ir {
  constructor() {
    super(...arguments), this.label = "LABEL", this.options = [], this.selectRef = we();
  }
  connectedCallback() {
    super.connectedCallback(), this.selected === void 0 && (this.selected = this.placeholder !== void 0 ? -1 : 0);
  }
  /*protected firstUpdated(_changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>) {
    this.dispatchEvent(new CustomEvent('dropdownfirstupdate', {bubbles: true, composed: true}));
  }*/
  optionSelected(t) {
    this.dispatchEvent(
      new CustomEvent("select", {
        detail: t,
        bubbles: !0,
        composed: !0
      })
    );
  }
  render() {
    return Ht`
      <label>
        ${this.label}
        <select 
          ${ge(this.selectRef)}
          autocomplete="off"
          @change=${(t) => {
      const r = t.target.value;
      this.optionSelected(r === "" ? -1 : +r.slice(3));
    }}>
          ${this.placeholder ? Ht`
              <option value="">${this.placeholder}</option>
            ` : ""}
          ${this.options.map((t, r) => Ht`
              <option 
                value="opt${r}" 
                .selected=${r === this.selected}
              >
                ${t}
              </option>
            `)}
        </select>
      </label>
    `;
  }
  get selectedIndex() {
    return this.placeholder !== void 0 ? this.selectRef.value.selectedIndex - 1 : this.selectRef.value.selectedIndex;
  }
  /**
   * Select a specific option by index.
   * @param index - Index of option to select.
   * @remarks
   * If a placeholder is set, passing -1 as the index will select it.
   */
  select(t) {
    const r = this.placeholder ? -1 : 0;
    if (t < r || t >= this.options.length)
      throw new Error(`invalid selection index '${t}'`);
    this.selectRef.value.selectedIndex = this.placeholder !== void 0 ? t + 1 : t, this.optionSelected(t);
  }
};
Au.styles = Te`
  `;
H0([
  Qt()
], Au.prototype, "label", 2);
H0([
  Qt()
], Au.prototype, "placeholder", 2);
H0([
  Qt({ type: Array })
], Au.prototype, "options", 2);
H0([
  Qt({ type: Number })
], Au.prototype, "selected", 2);
Au = H0([
  Oe("fizz-dropdown")
], Au);
var mrt = Object.defineProperty, yrt = Object.getOwnPropertyDescriptor, us = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? yrt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && mrt(t, r, i), i;
};
let Kn = class extends Ir {
  constructor() {
    super(...arguments), this.label = "LABEL", this.key = "slider", this.showValue = !1, this.compact = !1, this.min = 0, this.max = 100, this.step = 1, this.percent = !1, this.inputRef = we(), this._value = 50;
  }
  set value(t) {
    this._value = t;
  }
  get value() {
    return this._value;
  }
  connectedCallback() {
    super.connectedCallback(), this.lowBound ?? (this.lowBound = this.min), this.highBound ?? (this.highBound = this.max);
  }
  formatLabel() {
    const t = this.value;
    return this.percent ? `${Math.round(t * 100)}%` : `${t}`;
  }
  // protected firstUpdated(_changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>): void {
  //   this.dispatchEvent(
  //     new CustomEvent('sliderfirstupdate', {
  //       bubbles: true,
  //       composed: true
  //     }));
  // }
  /*protected updated(changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>) {
    if (changedProperties.has('value')) {
      this.inputRef.value!.value = this.value.toString();
    }
  }*/
  render() {
    return Ht`
      <div
        class=${this.compact ? "compact" : Lt}
      >
        <span>
          <label for=${this.key}>${this.label}:</label>
          ${this.showValue && this.compact ? Ht`
            <output for=${this.key}>
              ${this.formatLabel()}
            </output>
          ` : ""}
        </span>
        <input
          ${ge(this.inputRef)}
          id=${this.key}
          type="range"
          min=${this.min} max=${this.max} step=${this.step}
          .value=${this.value}
          @input=${() => {
      const t = +this.inputRef.value.value;
      t < this.lowBound || t > this.highBound ? this.inputRef.value.value = this._value.toString() : (this._value = +this.inputRef.value.value, this.dispatchEvent(new CustomEvent(
        "update",
        { bubbles: !0, composed: !0, detail: this._value }
      )), this.requestUpdate());
    }}
        >
        ${this.showValue && !this.compact ? Ht`
            <output for=${this.key}>
              ${this.formatLabel()}
            </output>
          ` : ""}
      </div>
    `;
  }
};
Kn.styles = [
  Mo,
  Te`
      div {
        display: flex;
        flex-direction: row;
        gap: 0.5rem;
        align-items: flex-start;
      }
      div.compact {
        flex-direction: column;
        gap: 0;
      }
      input {
        width: var(--width, unset);
      }
    `
];
us([
  Qt()
], Kn.prototype, "label", 2);
us([
  Qt({ type: String })
], Kn.prototype, "key", 2);
us([
  Qt({ type: Number })
], Kn.prototype, "value", 1);
us([
  Qt({ type: Boolean })
], Kn.prototype, "showValue", 2);
us([
  Qt({ type: Boolean })
], Kn.prototype, "compact", 2);
us([
  Qt({ type: Number })
], Kn.prototype, "min", 2);
us([
  Qt({ type: Number })
], Kn.prototype, "max", 2);
us([
  Qt({ type: Number })
], Kn.prototype, "lowBound", 2);
us([
  Qt({ type: Number })
], Kn.prototype, "highBound", 2);
us([
  Qt({ type: Number })
], Kn.prototype, "step", 2);
us([
  Qt({ type: Boolean })
], Kn.prototype, "percent", 2);
Kn = us([
  Oe("fizz-slider")
], Kn);
var brt = Object.defineProperty, vrt = Object.getOwnPropertyDescriptor, G0 = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? vrt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && brt(t, r, i), i;
};
let EL = class {
  constructor(t, r, n, i, s) {
    this.key = t, this.descriptor = r, this.checked = n, this.type = i, this.group = s, this._inputRef = we();
  }
  get input() {
    return this._inputRef.value;
  }
  classMap() {
    return { [this.type]: !0 };
  }
  render() {
    return Ht`
      <label class=${Rr(this.classMap())} title=${this.descriptor.title ?? Lt} for=${this.key}>
        <input
          ${ge(this._inputRef)}
          id=${this.key}
          type="radio"
          name="radio"
          .checked=${this.checked}
          @change=${(t) => this.group.dispatchEvent(
      new CustomEvent("select", { bubbles: !0, composed: !0, detail: this.key })
    )}
        />
        ${this.content()}
      </label>
    `;
  }
};
const AL = class extends EL {
  constructor(t, r, n, i) {
    super(t, r, n, "plain", i);
  }
  classMap() {
    const t = super.classMap();
    return t[`layout-${this.group.layout}`] = !0, t;
  }
  content() {
    return Ht`
      <span class="main">
        ${this.descriptor.label}
      </span>
      ${this.descriptor.subLabel ? Ht`
        <span class="sub">${this.descriptor.subLabel}</span>
      ` : ""}
    `;
  }
};
AL.styles = Te`
    label.plain {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
    }
    label.plain.layout-compress {
      flex-direction: column;
      gap: 0;
    }
    label.plain span {
      text-align: center;
    }
  `;
let SL = AL;
const _L = class extends EL {
  constructor(t, r, n, i) {
    super(t, r, n, "icon", i);
  }
  content() {
    return Ht`
      <div class="tile">
        ${this.descriptor.icon ? Ht`
          <img src=${this.descriptor.icon} alt="">
        ` : ""}
        <span>
          ${this.descriptor.label}
          ${this.descriptor.subLabel ? Ht`<br>${this.descriptor.subLabel}` : ""}
        </span>
      </div>
    `;
  }
};
_L.styles = Te`
    label.icon {
      position: relative;
      height: 4rem;
      width: 4rem;
    }
    img {
      width: 3.2rem;
      background: inherit;
    }
    label.icon input {
      opacity: 0;
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
      margin: 0;
      cursor: pointer;
    }
    .tile {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
      width: 100%;
      height: 100%;
      border: 2px solid var(--theme-color-light, unset);
      border-radius: 5px;
      padding: 0.5rem;
      transition: transform 300ms ease;
    }
    label.icon span {
      text-align: center;
      font-size: 0.7rem;
      font-weight: 550;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--theme-text-color, unset);
    }
    label.icon input:checked + .tile {
      background-color: var(--theme-color-light, unset);
      border: 2px solid var(--theme-color-light, unset);
      color: var(--theme-text-color, unset);
      font-weight: 700;
      transform: scale(1.1, 1.1);
    }
    label.icon input:checked + .tile span {
      color: var(--theme-text-color, unset);
      background-color: var(--theme-color-light, unset);
    }
  `;
let kL = _L, Su = class extends Ir {
  constructor() {
    super(...arguments), this.buttons = {}, this.layout = "horiz", this.wrap = !1, this.radios = {};
  }
  /*protected firstUpdated(_changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>): void {
    this.dispatchEvent(
      new CustomEvent('radiofirstupdate', {
        bubbles: true,
        composed: true
      }));
  }*/
  connectedCallback() {
    super.connectedCallback(), this.selected ?? (this.selected = Object.keys(this.buttons)[0]);
  }
  updated(t) {
    if (t.has("selected"))
      for (const [r, n] of Object.entries(this.radios))
        n.input.checked = r === this.selected;
  }
  render() {
    const t = this.buttons[Object.keys(this.buttons)[0]].icon ? kL : SL;
    this.radios = {};
    for (const [n, i] of Object.entries(this.buttons))
      this.radios[n] = new t(n, i, n === this.selected, this);
    const r = {
      wrapper: !0,
      [this.layout]: !0,
      wrap: this.wrap
    };
    return Ht`
      <fieldset>
        <legend>
          <slot name="legend"></slot>
        </legend>
        <div class=${Rr(r)}>
          ${Object.entries(this.radios).map(([n, i]) => i.render())}
        </div>
      </fieldset>
    `;
  }
};
Su.styles = [
  Mo,
  Te`
      :host * {
        box-sizing: border-box;
      }
      .wrapper {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
      }
      .wrapper.vert {
        flex-direction: column;
        align-items: flex-start;
        width: min-content;
        margin-left: auto;
        margin-right: auto;
      }
      .wrapper.wrap {
        flex-wrap: wrap;
      }
      fieldset {
        border: var(--border, none);
        padding: 0;
        margin: 0;
      }
      legend {
        border-radius: var(--legend-border-radius, 0.15rem);
        padding: 0.25rem 0.5rem;
        margin-left: auto;
        margin-right: auto;
        background: var(--legend-background, unset);
        color: var(--legend-color, unset);
      }
    `,
  SL.styles,
  kL.styles
];
G0([
  Qt({ type: Object })
], Su.prototype, "buttons", 2);
G0([
  Qt()
], Su.prototype, "selected", 2);
G0([
  Qt()
], Su.prototype, "layout", 2);
G0([
  Qt({ type: Boolean })
], Su.prototype, "wrap", 2);
Su = G0([
  Oe("fizz-radiogroup")
], Su);
var wrt = Object.defineProperty, xrt = Object.getOwnPropertyDescriptor, Fs = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? xrt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && wrt(t, r, i), i;
};
let Ri = class extends Ir {
  constructor() {
    super(...arguments), this.open = !1, this.default = 0, this.tabLabelMode = "labels", this.openButtonAriaLabel = "Open or close tabbed interface", this.tabListAriaLabel = "Tabs", this.tabLabels = [], this._tabIcons = [], this._hiddenTabs = [], this._detailsRef = we(), this._tabRefs = [], this._panelsWrapperRef = we(), this._allPanelContents = [], this._ready = !1;
  }
  set selectedTab(t) {
    this._selectedTab = t, this._tabRefs[t].value.focus();
  }
  get selectedTab() {
    return this._selectedTab;
  }
  connectedCallback() {
    super.connectedCallback(), this._selectedTab = this.default;
  }
  firstUpdated(t) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  updated(t) {
    var r;
    t.get("tabLabels") && this.tabLabels.length, this._tabRefs.length && ((r = this._tabRefs[this.selectedTab].value) == null || r.scrollIntoView({ behavior: "smooth", block: "nearest" })), this._allPanelContents.length && !this._ready && (this._ready = !0, this.dispatchEvent(new CustomEvent("ready", { bubbles: !0, composed: !0 })));
  }
  hide(t) {
    if (this.tabLabels.indexOf(t) === -1)
      throw new Error(`no tab with label '${t}'`);
    this._hiddenTabs.includes(t) || (this._hiddenTabs = [...this._hiddenTabs, t]);
  }
  show(t) {
    if (!this.tabLabels.includes(t))
      throw new Error(`no tab with label '${t}'`);
    const r = this._hiddenTabs.indexOf(t);
    r !== -1 && (this._hiddenTabs = this._hiddenTabs.toSpliced(r, 1));
  }
  _activateTab(t, r) {
    t.preventDefault(), t.stopPropagation(), this.selectedTab = r;
  }
  _renderTab(t, r) {
    var n;
    if ((n = this._tabRefs)[r] ?? (n[r] = we()), this._hiddenTabs.includes(t))
      return Ht``;
    const i = this.selectedTab === r, s = {
      hidden: this.tabLabelMode === "icons" || this.tabLabelMode === "icons-current-label" && !i
    }, o = {
      icon: this.tabLabelMode !== "labels"
    }, a = {
      mask: this._tabIcons[r] ? `url("${this._tabIcons[r]}") no-repeat 50% 50%` : void 0,
      "mask-size": "cover"
    };
    return Ht`
      <li
        role="presentation"
      >
        <button
          ${ge(this._tabRefs[r])}
          role="tab"
          id="tab${r}"
          tabindex=${i ? Lt : -1}
          aria-selected=${i ? "true" : "false"}
          aria-controls="panel${r}"
          class="tab"
          @keydown=${(l) => {
      l.key === "ArrowLeft" || l.key === "ArrowUp" ? this._activateTab(l, r === 0 ? this.tabLabels.length - 1 : r - 1) : (l.key === "ArrowRight" || l.key === "ArrowDown") && this._activateTab(l, (r + 1) % this.tabLabels.length);
    }}
          @click=${(l) => this._activateTab(l, r)}
        >
          ${this._tabIcons[r] ? Ht`
            <span
              class=${Rr(o)}
              style=${ln(a)}
            >
            </span>
          ` : ""}
          <span class=${Rr(s)}>
            ${t}
          </span>
        </button>
      </li>
    `;
  }
  _absorbPanels() {
    this._allPanelContents = this._panelEls.map((t) => t.contentNodes), this._panelEls.forEach((t) => t.remove()), this.requestUpdate();
  }
  render() {
    return Ht`
      <details
        ${ge(this._detailsRef)}
        ?open=${this.open}
        @toggle=${() => {
      this.dispatchEvent(new CustomEvent(
        this.open ? "open" : "close",
        { bubbles: !0, composed: !0 }
      ));
    }}>
        <summary
          tabindex="0"
          aria-label=${this.openButtonAriaLabel}
          @click=${(t) => {
      t.preventDefault(), this.open = !this._detailsRef.value.open;
    }}
        >
          <menu
            role="tablist"
            class="tablist ${this.open ? "" : "hidden"}"
            aria-label=${this.tabListAriaLabel}
          >
            ${this.tabLabels.map((t, r) => this._renderTab(t, r))}
          </menu>
        </summary>
        <div class="panels"
          ${ge(this._panelsWrapperRef)}
        >
          ${this._allPanelContents.map((t, r) => Ht`
              <section
                id="panel${r}"
                ?hidden=${this._hiddenTabs.includes(this.tabLabels[r])}
                tabindex="0"
                role="tabpanel"
                aria-labelledby="tab${r}"
                class="panel ${this.selectedTab === r ? "" : "hidden"}"
              >
                ${t}
              </section>
            `)}
          <slot @slotchange=${(t) => {
      var r;
      if (!this.tabLabels.length)
        if (this.tabLabels = this._panelEls.map((n) => n.tabLabel), (r = this._panelEls[0]) != null && r.icon && (this._tabIcons = this._panelEls.map((n, i) => {
          if (n.id = `panel${i}`, n.icon)
            return n.icon;
          throw new Error(`panel '${n.tabLabel}' icon missing`);
        })), this._panelEls.forEach((n) => {
          n.hidden && this.hide(n.tabLabel);
        }), this._panelEls.map((n) => n.hasUpdated).every((n) => n))
          this._absorbPanels();
        else {
          const n = this._panelEls.filter((i) => !i.hasUpdated);
          n.forEach((i) => i.addEventListener("firstupdate", (s) => {
            s.stopPropagation(), n.map((o) => o.hasUpdated).every((o) => o) && this._absorbPanels();
          }, { once: !0 }));
        }
    }}></slot>
        </div>
      </details>
    `;
  }
};
Ri.styles = [
  Mo,
  Te`
      :host {
        display: block;
      }
      details {
        background: var(--background, var(--theme-contrast-color));
        color: var(--color, black);
        border-radius: var(--border-radius, 0.15rem);
      }

      summary {
        background: var(--summary-background, var(--theme-color));
        border-radius: var(--summary-border-radius, 0);
        padding: 0;
        padding-top: 2px;
        padding-left: 2px;
        list-style-type: none;
      }
      summary::before {
        display: inline-block;
        width: var(--summary-marker-size, 1.1rem);
        height: var(--summary-marker-size, 1.1rem);
        margin-left: 2px;
        margin-top: 2px;
        margin-right: 2px;
        padding: 1px;
        content: '';
        background-color: var(--summary-marker-color, ghostwhite);
        mask-image: var(--summary-marker-icon, url(${du(p5)}));
        mask-size: cover;
        cursor: pointer;
        z-index: 1;
      }

      details {
        border: var(--border, 1px solid var(--theme-color));
      }
      details[open] summary {
        border-radius: var(--summary-border-radius-open, 0);
      }
      details:not([open]) {
        /*
          marker width + marker margins + marker padding + summary left padding
          + summary left padding added on the right
        */
        width: calc(1.1rem + 4px + 2px + 2px + 2px);
        background: none;
        /*
          Keep the icon from moving by making the border transparent
          rather than removing it
        */
        border: 1px solid transparent;
      }
      details:not([open]) summary::before {
        background-color: var(--theme-color, ghostwhite);
      }
      details:not([open]) summary {
        background: none;
      }
      .panels {
        background: var(--contents-background, var(--theme-contrast-color));
        padding: var(--contents-padding, 0 0.25rem);
        margin: var(--contents-margin, 0);
        overflow: var(--contents-overflow, hidden);
        border-radius: var(--border-radius, 0 0 0.15rem 0.15rem);
        z-index: 3;
      }
      .tablist {
        display: inline-flex;
        padding: 0;
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
        gap: var(--tab-gap, 0);
        font-size: var(--tab-font-size, unset);
        font-weight: var(--tab-font-weight, unset);
        margin: 0;
        background: none;
        flex-grow: 1;
        width: calc(100% - 2rem);
      }
      li {
        list-style-type: none;
      }
      .tab {
        padding: var(--padding, 0.25rem 0.4rem);
        cursor: pointer;
        border: none;
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
      }
      [role='tab'] {
        color: var(--background-selected, var(--theme-unselected-text-color, var(--theme-extra-color)));
        background: none;
      }
      [role='tab'][aria-selected='true'] {
        background: var(--background-selected, var(--theme-extra-color));
        color: var(--theme-text-color, var(--color-selected, var(--theme-color)));
        text-decoration: var(--theme-selected-text-decoration) var(--theme-text-color);
        text-underline-offset: 0.25rem;
      }
      .icon {
        height: 1rem;
        width: 1rem;
        vertical-align: middle;
        background-color: currentColor;
        display: inline-block;
      }
      @media screen and (max-width: 600px) {
        .tablist {
          flex-direction: column;
          overflow-y: scroll;
          height: 3.5rem;
          /*gap: 0.1rem;*/
        }
        .tab {
          width: 100%;
        }
      }
    `
];
Fs([
  Qt({ type: Boolean })
], Ri.prototype, "open", 2);
Fs([
  Qt({ type: Number })
], Ri.prototype, "default", 2);
Fs([
  Qt()
], Ri.prototype, "tabLabelMode", 2);
Fs([
  Qt()
], Ri.prototype, "openButtonAriaLabel", 2);
Fs([
  Qt()
], Ri.prototype, "tabListAriaLabel", 2);
Fs([
  Lr()
], Ri.prototype, "tabLabels", 2);
Fs([
  Lr()
], Ri.prototype, "_tabIcons", 2);
Fs([
  Lr()
], Ri.prototype, "_hiddenTabs", 2);
Fs([
  Lr()
], Ri.prototype, "selectedTab", 1);
Fs([
  U0()
], Ri.prototype, "_panelEls", 2);
Ri = Fs([
  Oe("fizz-tab-details")
], Ri);
var Ert = Object.defineProperty, Art = Object.getOwnPropertyDescriptor, $s = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Art(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && Ert(t, r, i), i;
};
let Ti = class extends Ir {
  constructor() {
    super(...arguments), this.open = !1, this.default = 0, this.tabLabelMode = "labels", this.tabListAriaLabel = "Tabs", this.openButtonAriaLabel = "Toggle tab panel", this._tabLabels = [], this._tabIcons = [], this._hiddenTabs = [], this._tabRefs = [], this._panelsWrapperRef = we(), this._allPanelContents = [], this._ready = !1;
  }
  set selectedTab(t) {
    this._selectedTab = t, this._tabRefs[t].value.focus();
  }
  get selectedTab() {
    return this._selectedTab;
  }
  connectedCallback() {
    super.connectedCallback(), this._selectedTab = this.default;
  }
  firstUpdated(t) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  updated(t) {
    var r;
    this._tabRefs.length && ((r = this._tabRefs[this.selectedTab].value) == null || r.scrollIntoView({ behavior: "smooth", block: "nearest" })), this._allPanelContents.length && !this._ready && (this._ready = !0, this.dispatchEvent(new CustomEvent("ready", { bubbles: !0, composed: !0 })));
  }
  hide(t) {
    if (this._tabLabels.indexOf(t) === -1)
      throw new Error(`no tab with label '${t}'`);
    this._hiddenTabs.includes(t) || (this._hiddenTabs = [...this._hiddenTabs, t]);
  }
  show(t) {
    if (!this._tabLabels.includes(t))
      throw new Error(`no tab with label '${t}'`);
    const r = this._hiddenTabs.indexOf(t);
    r !== -1 && (this._hiddenTabs = this._hiddenTabs.toSpliced(r, 1));
  }
  _activateTab(t, r) {
    t.preventDefault(), t.stopPropagation(), this.selectedTab = r;
  }
  _renderTab(t, r) {
    var n;
    if ((n = this._tabRefs)[r] ?? (n[r] = we()), this._hiddenTabs.includes(t))
      return Ht``;
    const i = this.selectedTab === r, s = {
      mask: this._tabIcons[r] ? `url("${this._tabIcons[r]}") no-repeat 50% 50%` : void 0,
      "mask-size": "cover"
    }, o = this.tabLabelMode === "icons" || this.tabLabelMode === "icons-labels" || this.tabLabelMode === "icons-current-label" && i, a = this.tabLabelMode === "labels" || this.tabLabelMode === "icons-labels" || this.tabLabelMode === "icons-current-label" && i;
    return Ht`
      <li role="presentation">
        <button
          ${ge(this._tabRefs[r])}
          role="tab"
          id="tab${r}"
          tabindex=${i ? Lt : -1}
          aria-selected=${i ? "true" : "false"}
          aria-controls="panel${r}"
          class="tab"
          @keydown=${(l) => {
      l.key === "ArrowLeft" || l.key === "ArrowUp" ? this._activateTab(l, r === 0 ? this._tabLabels.length - 1 : r - 1) : (l.key === "ArrowRight" || l.key === "ArrowDown") && this._activateTab(l, (r + 1) % this._tabLabels.length);
    }}
          @click=${(l) => this._activateTab(l, r)}
        >
          ${o && this._tabIcons[r] ? Ht`<span class="icon" style=${ln(s)}></span>` : Lt}
          ${a ? Ht`<span>${t}</span>` : Lt}
        </button>
      </li>
    `;
  }
  _absorbPanels() {
    this._allPanelContents = this._panelEls.map((t) => t.contentNodes), this._panelEls.forEach((t) => t.remove()), this.requestUpdate();
  }
  render() {
    const t = Ht`
      <button
        class="toggle"
        @click=${() => {
      this.open = !this.open, this.dispatchEvent(new CustomEvent(
        this.open ? "open" : "close",
        { bubbles: !0, composed: !0 }
      ));
    }}
		aria-label=${this.openButtonAriaLabel}
		aria-expanded=${this.open}
        aria-controls="tabs-container"
      ></button>
    `;
    return Ht`
      <div id="tabs-container" class=${this.open ? "open" : ""}>
        ${this.open ? Ht`
          <div class="tablist-wrapper">
            ${t}
            <ul
              role="tablist"
              class="tablist"
              aria-label=${this.tabListAriaLabel}
            >
              ${this._tabLabels.map((r, n) => this._renderTab(r, n))}
            </ul>
          </div>

          <div class="panels" ${ge(this._panelsWrapperRef)}>
            ${this._allPanelContents.map((r, n) => Ht`
              <section
                id="panel${n}"
                ?hidden=${this._hiddenTabs.includes(this._tabLabels[n])}
                tabindex="0"
                role="tabpanel"
                aria-labelledby="tab${n}"
                class="panel ${this.selectedTab === n ? "" : "hidden"}"
              >
                ${r}
              </section>
            `)}
            <slot @slotchange=${(r) => {
      var n;
      if (!this._tabLabels.length)
        if (this._tabLabels = this._panelEls.map((i) => i.tabLabel), (n = this._panelEls[0]) != null && n.icon && (this._tabIcons = this._panelEls.map((i, s) => {
          if (i.id = `panel${s}`, i.icon) return i.icon;
          throw new Error(`panel '${i.tabLabel}' icon missing`);
        })), this._panelEls.forEach((i) => {
          i.hidden && this.hide(i.tabLabel);
        }), this._panelEls.map((i) => i.hasUpdated).every((i) => i))
          this._absorbPanels();
        else {
          const i = this._panelEls.filter((s) => !s.hasUpdated);
          i.forEach(
            (s) => s.addEventListener("firstupdate", (o) => {
              o.stopPropagation(), i.map((a) => a.hasUpdated).every((a) => a) && this._absorbPanels();
            }, { once: !0 })
          );
        }
    }}></slot>
          </div>` : Ht`
          ${t}
        `}
      </div>
    `;
  }
};
Ti.styles = [
  Mo,
  Te`
      :host {
        display: block;
      }

      #tabs-container {
        display: grid;
        border-radius: var(--border-radius, 0.15rem);
      }
      #tabs-container.open {
        border: 1px solid var(--theme-color);
      }

      button.toggle {
        width: var(--toggle-button-size, 1.1rem);
        height: var(--toggle-button-size, 1.1rem);
        background-color: var(--toggle-button-color, ghostwhite);
        mask-image: var(--toggle-button-icon, url(${du(p5)}));
        mask-size: cover;
        border: none;
        cursor: pointer;
        vertical-align: text-top;
        padding: 0 0.25rem;
      }
      #tabs-container.open button.toggle {
        justify-self: center;
        align-self: center;
      }
      #tabs-container:not(.open) button.toggle {
        background-color: var(--theme-color, ghostwhite);
      }

      .tablist-wrapper {
        display: grid;
        grid-template-columns: 1.5rem 1fr;
        background: var(--tablist-background, var(--theme-color));
        margin: 0;
      }

      .tablist {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 0;
        margin: 0;
        padding: 0;
      }

      li {
        display: contents;
        list-style-type: none;
        margin: 0;
      }

      .tab {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: var(--tab-padding, 0.25rem 0.4rem);
        border: none;
        border-radius: var(--border-radius, 0.1rem) var(--border-radius, 0.1rem) 0 0;
        cursor: pointer;
        background: none;
        font-size: var(--tab-font-size);
        font-weight: var(--tab-font-weight);
        margin: 0;
      }

      [role='tab'] {
        color: var(--theme-unselected-text-color);
      }

      [role='tab'][aria-selected='true'] {
        background: var(--theme-extra-color);
        color: var(--theme-text-color);
        text-decoration: var(--theme-selected-text-decoration);
        text-underline-offset: 0.25rem;
      }

      .icon {
        height: 1rem;
        width: 1rem;
        vertical-align: middle;
        background-color: currentColor;
        display: inline-block;
      }

      .panels {
        background: var(--theme-contrast-color);
        padding: var(--contents-padding);
        margin: 0;
        border-radius: 0 0 var(--border-radius, 0.1rem) var(--border-radius, 0.1rem);
      }

      @media screen and (max-width: 600px) {
        .tablist {
          flex-direction: column;
          overflow-y: auto;
          height: 3.5rem;
        }

        .tab {
          width: 100%;
        }
      }
    `
];
$s([
  Qt({ type: Boolean, reflect: !0, useDefault: !0 })
], Ti.prototype, "open", 2);
$s([
  Qt({ type: Number })
], Ti.prototype, "default", 2);
$s([
  Qt()
], Ti.prototype, "tabLabelMode", 2);
$s([
  Qt()
], Ti.prototype, "tabListAriaLabel", 2);
$s([
  Qt({ type: String, attribute: "openbuttonarialabel" })
], Ti.prototype, "openButtonAriaLabel", 2);
$s([
  Lr()
], Ti.prototype, "_tabLabels", 2);
$s([
  Lr()
], Ti.prototype, "_tabIcons", 2);
$s([
  Lr()
], Ti.prototype, "_hiddenTabs", 2);
$s([
  Lr()
], Ti.prototype, "selectedTab", 1);
$s([
  U0()
], Ti.prototype, "_panelEls", 2);
Ti = $s([
  Oe("fizz-tabs")
], Ti);
var Srt = Object.defineProperty, _rt = Object.getOwnPropertyDescriptor, Q0 = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? _rt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && Srt(t, r, i), i;
};
let _u = class extends zi {
  constructor() {
    super(...arguments), this.title = "", this.btnText = "Close", this.contentArray = [], this._dialogRef = we();
  }
  render() {
    const e = [{ tag: "cancel", text: this.btnText }];
    return Ht`
      <fizz-dialog
        ${ge(this._dialogRef)}
        title="${this.title}"
        .buttons=${e}
      >
        ${this._content}
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   * @param contentArray - status bar display contentArray.
   */
  // async show(title: string, contentArray: string[]) {
  async show(e, t = Ht``) {
    this.title = e, this._content = t, await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
_u.styles = Te`
    .contentArray {
      align-self: stretch;
    }

    button {
      margin: 0.2rem;
      background-color: var(--theme-color);
      color: var(--theme-contrast-color);
      border: thin solid var(--theme-color);
      border-radius: 0.2em;
      padding: 0.2em;
    }


    pre {
      height: 60vh;
      width: 80vw;
      padding: 1rem;
      overflow-y:
      scroll; background-color:
      black; color: white;
    }

    table {
      border-collapse: collapse;
      margin: 0 2rem;
    }

    th, td {
      border-bottom: 1px solid hsl(0, 0%, 75%);
      padding: 0.35em 2.5em;
      text-align: left;
    }

    tbody th {
      font-weight: normal;
      padding-left: 0;
    }

    td:last-of-type {
      padding-right: 0;
    }
  `;
Q0([
  Qt()
], _u.prototype, "title", 2);
Q0([
  Qt()
], _u.prototype, "btnText", 2);
Q0([
  Qt({ type: Array })
], _u.prototype, "contentArray", 2);
Q0([
  Lr()
], _u.prototype, "_content", 2);
_u = Q0([
  Oe("para-dialog")
], _u);
var krt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Crt(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var CL = { exports: {} };
/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/
(function(e, t) {
  ((r, n) => {
    e.exports = n();
  })(krt, function r() {
    var n = typeof self < "u" ? self : typeof window < "u" ? window : n !== void 0 ? n : {}, i, s = !n.document && !!n.postMessage, o = n.IS_PAPA_WORKER || !1, a = {}, l = 0, c = {};
    function h(R) {
      this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = { data: [], errors: [], meta: {} }, (function(O) {
        var $ = w(O);
        $.chunkSize = parseInt($.chunkSize), O.step || O.chunk || ($.chunkSize = null), this._handle = new b($), (this._handle.streamer = this)._config = $;
      }).call(this, R), this.parseChunk = function(O, $) {
        var z = parseInt(this._config.skipFirstNLines) || 0;
        if (this.isFirstChunk && 0 < z) {
          let Y = this._config.newline;
          Y || (F = this._config.quoteChar || '"', Y = this._handle.guessLineEndings(O, F)), O = [...O.split(Y).slice(z)].join(Y);
        }
        this.isFirstChunk && S(this._config.beforeFirstChunk) && (F = this._config.beforeFirstChunk(O)) !== void 0 && (O = F), this.isFirstChunk = !1, this._halted = !1;
        var z = this._partialLine + O, F = (this._partialLine = "", this._handle.parse(z, this._baseIndex, !this._finished));
        if (!this._handle.paused() && !this._handle.aborted()) {
          if (O = F.meta.cursor, z = (this._finished || (this._partialLine = z.substring(O - this._baseIndex), this._baseIndex = O), F && F.data && (this._rowCount += F.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview), o) n.postMessage({ results: F, workerId: c.WORKER_ID, finished: z });
          else if (S(this._config.chunk) && !$) {
            if (this._config.chunk(F, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
            this._completeResults = F = void 0;
          }
          return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(F.data), this._completeResults.errors = this._completeResults.errors.concat(F.errors), this._completeResults.meta = F.meta), this._completed || !z || !S(this._config.complete) || F && F.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), z || F && F.meta.paused || this._nextChunk(), F;
        }
        this._halted = !0;
      }, this._sendError = function(O) {
        S(this._config.error) ? this._config.error(O) : o && this._config.error && n.postMessage({ workerId: c.WORKER_ID, error: O, finished: !1 });
      };
    }
    function u(R) {
      var O;
      (R = R || {}).chunkSize || (R.chunkSize = c.RemoteChunkSize), h.call(this, R), this._nextChunk = s ? function() {
        this._readChunk(), this._chunkLoaded();
      } : function() {
        this._readChunk();
      }, this.stream = function($) {
        this._input = $, this._nextChunk();
      }, this._readChunk = function() {
        if (this._finished) this._chunkLoaded();
        else {
          if (O = new XMLHttpRequest(), this._config.withCredentials && (O.withCredentials = this._config.withCredentials), s || (O.onload = _(this._chunkLoaded, this), O.onerror = _(this._chunkError, this)), O.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !s), this._config.downloadRequestHeaders) {
            var $, z = this._config.downloadRequestHeaders;
            for ($ in z) O.setRequestHeader($, z[$]);
          }
          var F;
          this._config.chunkSize && (F = this._start + this._config.chunkSize - 1, O.setRequestHeader("Range", "bytes=" + this._start + "-" + F));
          try {
            O.send(this._config.downloadRequestBody);
          } catch (Y) {
            this._chunkError(Y.message);
          }
          s && O.status === 0 && this._chunkError();
        }
      }, this._chunkLoaded = function() {
        O.readyState === 4 && (O.status < 200 || 400 <= O.status ? this._chunkError() : (this._start += this._config.chunkSize || O.responseText.length, this._finished = !this._config.chunkSize || this._start >= (($) => ($ = $.getResponseHeader("Content-Range")) !== null ? parseInt($.substring($.lastIndexOf("/") + 1)) : -1)(O), this.parseChunk(O.responseText)));
      }, this._chunkError = function($) {
        $ = O.statusText || $, this._sendError(new Error($));
      };
    }
    function p(R) {
      (R = R || {}).chunkSize || (R.chunkSize = c.LocalChunkSize), h.call(this, R);
      var O, $, z = typeof FileReader < "u";
      this.stream = function(F) {
        this._input = F, $ = F.slice || F.webkitSlice || F.mozSlice, z ? ((O = new FileReader()).onload = _(this._chunkLoaded, this), O.onerror = _(this._chunkError, this)) : O = new FileReaderSync(), this._nextChunk();
      }, this._nextChunk = function() {
        this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
      }, this._readChunk = function() {
        var F = this._input, Y = (this._config.chunkSize && (Y = Math.min(this._start + this._config.chunkSize, this._input.size), F = $.call(F, this._start, Y)), O.readAsText(F, this._config.encoding));
        z || this._chunkLoaded({ target: { result: Y } });
      }, this._chunkLoaded = function(F) {
        this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(F.target.result);
      }, this._chunkError = function() {
        this._sendError(O.error);
      };
    }
    function y(R) {
      var O;
      h.call(this, R = R || {}), this.stream = function($) {
        return O = $, this._nextChunk();
      }, this._nextChunk = function() {
        var $, z;
        if (!this._finished) return $ = this._config.chunkSize, O = $ ? (z = O.substring(0, $), O.substring($)) : (z = O, ""), this._finished = !O, this.parseChunk(z);
      };
    }
    function g(R) {
      h.call(this, R = R || {});
      var O = [], $ = !0, z = !1;
      this.pause = function() {
        h.prototype.pause.apply(this, arguments), this._input.pause();
      }, this.resume = function() {
        h.prototype.resume.apply(this, arguments), this._input.resume();
      }, this.stream = function(F) {
        this._input = F, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
      }, this._checkIsFinished = function() {
        z && O.length === 1 && (this._finished = !0);
      }, this._nextChunk = function() {
        this._checkIsFinished(), O.length ? this.parseChunk(O.shift()) : $ = !0;
      }, this._streamData = _(function(F) {
        try {
          O.push(typeof F == "string" ? F : F.toString(this._config.encoding)), $ && ($ = !1, this._checkIsFinished(), this.parseChunk(O.shift()));
        } catch (Y) {
          this._streamError(Y);
        }
      }, this), this._streamError = _(function(F) {
        this._streamCleanUp(), this._sendError(F);
      }, this), this._streamEnd = _(function() {
        this._streamCleanUp(), z = !0, this._streamData("");
      }, this), this._streamCleanUp = _(function() {
        this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
      }, this);
    }
    function b(R) {
      var O, $, z, F, Y = Math.pow(2, 53), rt = -Y, at = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, pt = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, vt = this, _t = 0, Ct = 0, It = !1, jt = !1, lt = [], L = { data: [], errors: [], meta: {} };
      function D(X) {
        return R.skipEmptyLines === "greedy" ? X.join("").trim() === "" : X.length === 1 && X[0].length === 0;
      }
      function tt() {
        if (L && z && (st("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + c.DefaultDelimiter + "'"), z = !1), R.skipEmptyLines && (L.data = L.data.filter(function(U) {
          return !D(U);
        })), et()) {
          let U = function(J, St) {
            S(R.transformHeader) && (J = R.transformHeader(J, St)), lt.push(J);
          };
          if (L) if (Array.isArray(L.data[0])) {
            for (var X = 0; et() && X < L.data.length; X++) L.data[X].forEach(U);
            L.data.splice(0, 1);
          } else L.data.forEach(U);
        }
        function ot(U, J) {
          for (var St = R.header ? {} : [], Rt = 0; Rt < U.length; Rt++) {
            var zt = Rt, Tt = U[Rt], Tt = ((Yt, Zt) => ((kt) => (R.dynamicTypingFunction && R.dynamicTyping[kt] === void 0 && (R.dynamicTyping[kt] = R.dynamicTypingFunction(kt)), (R.dynamicTyping[kt] || R.dynamicTyping) === !0))(Yt) ? Zt === "true" || Zt === "TRUE" || Zt !== "false" && Zt !== "FALSE" && (((kt) => {
              if (at.test(kt) && (kt = parseFloat(kt), rt < kt && kt < Y))
                return 1;
            })(Zt) ? parseFloat(Zt) : pt.test(Zt) ? new Date(Zt) : Zt === "" ? null : Zt) : Zt)(zt = R.header ? Rt >= lt.length ? "__parsed_extra" : lt[Rt] : zt, Tt = R.transform ? R.transform(Tt, zt) : Tt);
            zt === "__parsed_extra" ? (St[zt] = St[zt] || [], St[zt].push(Tt)) : St[zt] = Tt;
          }
          return R.header && (Rt > lt.length ? st("FieldMismatch", "TooManyFields", "Too many fields: expected " + lt.length + " fields but parsed " + Rt, Ct + J) : Rt < lt.length && st("FieldMismatch", "TooFewFields", "Too few fields: expected " + lt.length + " fields but parsed " + Rt, Ct + J)), St;
        }
        var mt;
        L && (R.header || R.dynamicTyping || R.transform) && (mt = 1, !L.data.length || Array.isArray(L.data[0]) ? (L.data = L.data.map(ot), mt = L.data.length) : L.data = ot(L.data, 0), R.header && L.meta && (L.meta.fields = lt), Ct += mt);
      }
      function et() {
        return R.header && lt.length === 0;
      }
      function st(X, ot, mt, U) {
        X = { type: X, code: ot, message: mt }, U !== void 0 && (X.row = U), L.errors.push(X);
      }
      S(R.step) && (F = R.step, R.step = function(X) {
        L = X, et() ? tt() : (tt(), L.data.length !== 0 && (_t += X.data.length, R.preview && _t > R.preview ? $.abort() : (L.data = L.data[0], F(L, vt))));
      }), this.parse = function(X, ot, mt) {
        var U = R.quoteChar || '"', U = (R.newline || (R.newline = this.guessLineEndings(X, U)), z = !1, R.delimiter ? S(R.delimiter) && (R.delimiter = R.delimiter(X), L.meta.delimiter = R.delimiter) : ((U = ((J, St, Rt, zt, Tt) => {
          var Yt, Zt, kt, _e;
          Tt = Tt || [",", "	", "|", ";", c.RECORD_SEP, c.UNIT_SEP];
          for (var Ye = 0; Ye < Tt.length; Ye++) {
            for (var wt, le = Tt[Ye], te = 0, Se = 0, Kt = 0, bt = (kt = void 0, new E({ comments: zt, delimiter: le, newline: St, preview: 10 }).parse(J)), xt = 0; xt < bt.data.length; xt++) Rt && D(bt.data[xt]) ? Kt++ : (wt = bt.data[xt].length, Se += wt, kt === void 0 ? kt = wt : 0 < wt && (te += Math.abs(wt - kt), kt = wt));
            0 < bt.data.length && (Se /= bt.data.length - Kt), (Zt === void 0 || te <= Zt) && (_e === void 0 || _e < Se) && 1.99 < Se && (Zt = te, Yt = le, _e = Se);
          }
          return { successful: !!(R.delimiter = Yt), bestDelimiter: Yt };
        })(X, R.newline, R.skipEmptyLines, R.comments, R.delimitersToGuess)).successful ? R.delimiter = U.bestDelimiter : (z = !0, R.delimiter = c.DefaultDelimiter), L.meta.delimiter = R.delimiter), w(R));
        return R.preview && R.header && U.preview++, O = X, $ = new E(U), L = $.parse(O, ot, mt), tt(), It ? { meta: { paused: !0 } } : L || { meta: { paused: !1 } };
      }, this.paused = function() {
        return It;
      }, this.pause = function() {
        It = !0, $.abort(), O = S(R.chunk) ? "" : O.substring($.getCharIndex());
      }, this.resume = function() {
        vt.streamer._halted ? (It = !1, vt.streamer.parseChunk(O, !0)) : setTimeout(vt.resume, 3);
      }, this.aborted = function() {
        return jt;
      }, this.abort = function() {
        jt = !0, $.abort(), L.meta.aborted = !0, S(R.complete) && R.complete(L), O = "";
      }, this.guessLineEndings = function(J, U) {
        J = J.substring(0, 1048576);
        var U = new RegExp(f(U) + "([^]*?)" + f(U), "gm"), mt = (J = J.replace(U, "")).split("\r"), U = J.split(`
`), J = 1 < U.length && U[0].length < mt[0].length;
        if (mt.length === 1 || J) return `
`;
        for (var St = 0, Rt = 0; Rt < mt.length; Rt++) mt[Rt][0] === `
` && St++;
        return St >= mt.length / 2 ? `\r
` : "\r";
      };
    }
    function f(R) {
      return R.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function E(R) {
      var O = (R = R || {}).delimiter, $ = R.newline, z = R.comments, F = R.step, Y = R.preview, rt = R.fastMode, at = null, pt = !1, vt = R.quoteChar == null ? '"' : R.quoteChar, _t = vt;
      if (R.escapeChar !== void 0 && (_t = R.escapeChar), (typeof O != "string" || -1 < c.BAD_DELIMITERS.indexOf(O)) && (O = ","), z === O) throw new Error("Comment character same as delimiter");
      z === !0 ? z = "#" : (typeof z != "string" || -1 < c.BAD_DELIMITERS.indexOf(z)) && (z = !1), $ !== `
` && $ !== "\r" && $ !== `\r
` && ($ = `
`);
      var Ct = 0, It = !1;
      this.parse = function(jt, lt, L) {
        if (typeof jt != "string") throw new Error("Input must be a string");
        var D = jt.length, tt = O.length, et = $.length, st = z.length, X = S(F), ot = [], mt = [], U = [], J = Ct = 0;
        if (!jt) return te();
        if (rt || rt !== !1 && jt.indexOf(vt) === -1) {
          for (var St = jt.split($), Rt = 0; Rt < St.length; Rt++) {
            if (U = St[Rt], Ct += U.length, Rt !== St.length - 1) Ct += $.length;
            else if (L) return te();
            if (!z || U.substring(0, st) !== z) {
              if (X) {
                if (ot = [], _e(U.split(O)), Se(), It) return te();
              } else _e(U.split(O));
              if (Y && Y <= Rt) return ot = ot.slice(0, Y), te(!0);
            }
          }
          return te();
        }
        for (var zt = jt.indexOf(O, Ct), Tt = jt.indexOf($, Ct), Yt = new RegExp(f(_t) + f(vt), "g"), Zt = jt.indexOf(vt, Ct); ; ) if (jt[Ct] === vt) for (Zt = Ct, Ct++; ; ) {
          if ((Zt = jt.indexOf(vt, Zt + 1)) === -1) return L || mt.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: ot.length, index: Ct }), wt();
          if (Zt === D - 1) return wt(jt.substring(Ct, Zt).replace(Yt, vt));
          if (vt === _t && jt[Zt + 1] === _t) Zt++;
          else if (vt === _t || Zt === 0 || jt[Zt - 1] !== _t) {
            zt !== -1 && zt < Zt + 1 && (zt = jt.indexOf(O, Zt + 1));
            var kt = Ye((Tt = Tt !== -1 && Tt < Zt + 1 ? jt.indexOf($, Zt + 1) : Tt) === -1 ? zt : Math.min(zt, Tt));
            if (jt.substr(Zt + 1 + kt, tt) === O) {
              U.push(jt.substring(Ct, Zt).replace(Yt, vt)), jt[Ct = Zt + 1 + kt + tt] !== vt && (Zt = jt.indexOf(vt, Ct)), zt = jt.indexOf(O, Ct), Tt = jt.indexOf($, Ct);
              break;
            }
            if (kt = Ye(Tt), jt.substring(Zt + 1 + kt, Zt + 1 + kt + et) === $) {
              if (U.push(jt.substring(Ct, Zt).replace(Yt, vt)), le(Zt + 1 + kt + et), zt = jt.indexOf(O, Ct), Zt = jt.indexOf(vt, Ct), X && (Se(), It)) return te();
              if (Y && ot.length >= Y) return te(!0);
              break;
            }
            mt.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: ot.length, index: Ct }), Zt++;
          }
        }
        else if (z && U.length === 0 && jt.substring(Ct, Ct + st) === z) {
          if (Tt === -1) return te();
          Ct = Tt + et, Tt = jt.indexOf($, Ct), zt = jt.indexOf(O, Ct);
        } else if (zt !== -1 && (zt < Tt || Tt === -1)) U.push(jt.substring(Ct, zt)), Ct = zt + tt, zt = jt.indexOf(O, Ct);
        else {
          if (Tt === -1) break;
          if (U.push(jt.substring(Ct, Tt)), le(Tt + et), X && (Se(), It)) return te();
          if (Y && ot.length >= Y) return te(!0);
        }
        return wt();
        function _e(Kt) {
          ot.push(Kt), J = Ct;
        }
        function Ye(Kt) {
          var bt = 0;
          return bt = Kt !== -1 && (Kt = jt.substring(Zt + 1, Kt)) && Kt.trim() === "" ? Kt.length : bt;
        }
        function wt(Kt) {
          return L || (Kt === void 0 && (Kt = jt.substring(Ct)), U.push(Kt), Ct = D, _e(U), X && Se()), te();
        }
        function le(Kt) {
          Ct = Kt, _e(U), U = [], Tt = jt.indexOf($, Ct);
        }
        function te(Kt) {
          if (R.header && !lt && ot.length && !pt) {
            var bt = ot[0], xt = /* @__PURE__ */ Object.create(null), Jt = new Set(bt);
            let k = !1;
            for (let M = 0; M < bt.length; M++) {
              let B = bt[M];
              if (xt[B = S(R.transformHeader) ? R.transformHeader(B, M) : B]) {
                let it, ct = xt[B];
                for (; it = B + "_" + ct, ct++, Jt.has(it); ) ;
                Jt.add(it), bt[M] = it, xt[B]++, k = !0, (at = at === null ? {} : at)[it] = B;
              } else xt[B] = 1, bt[M] = B;
              Jt.add(B);
            }
            k && console.warn("Duplicate headers found and renamed."), pt = !0;
          }
          return { data: ot, errors: mt, meta: { delimiter: O, linebreak: $, aborted: It, truncated: !!Kt, cursor: J + (lt || 0), renamedHeaders: at } };
        }
        function Se() {
          F(te()), ot = [], mt = [];
        }
      }, this.abort = function() {
        It = !0;
      }, this.getCharIndex = function() {
        return Ct;
      };
    }
    function A(R) {
      var O = R.data, $ = a[O.workerId], z = !1;
      if (O.error) $.userError(O.error, O.file);
      else if (O.results && O.results.data) {
        var F = { abort: function() {
          z = !0, x(O.workerId, { data: [], errors: [], meta: { aborted: !0 } });
        }, pause: m, resume: m };
        if (S($.userStep)) {
          for (var Y = 0; Y < O.results.data.length && ($.userStep({ data: O.results.data[Y], errors: O.results.errors, meta: O.results.meta }, F), !z); Y++) ;
          delete O.results;
        } else S($.userChunk) && ($.userChunk(O.results, F, O.file), delete O.results);
      }
      O.finished && !z && x(O.workerId, O.results);
    }
    function x(R, O) {
      var $ = a[R];
      S($.userComplete) && $.userComplete(O), $.terminate(), delete a[R];
    }
    function m() {
      throw new Error("Not implemented.");
    }
    function w(R) {
      if (typeof R != "object" || R === null) return R;
      var O, $ = Array.isArray(R) ? [] : {};
      for (O in R) $[O] = w(R[O]);
      return $;
    }
    function _(R, O) {
      return function() {
        R.apply(O, arguments);
      };
    }
    function S(R) {
      return typeof R == "function";
    }
    return c.parse = function(R, O) {
      var $ = (O = O || {}).dynamicTyping || !1;
      if (S($) && (O.dynamicTypingFunction = $, $ = {}), O.dynamicTyping = $, O.transform = !!S(O.transform) && O.transform, !O.worker || !c.WORKERS_SUPPORTED) return $ = null, c.NODE_STREAM_INPUT, typeof R == "string" ? (R = ((z) => z.charCodeAt(0) !== 65279 ? z : z.slice(1))(R), $ = new (O.download ? u : y)(O)) : R.readable === !0 && S(R.read) && S(R.on) ? $ = new g(O) : (n.File && R instanceof File || R instanceof Object) && ($ = new p(O)), $.stream(R);
      ($ = (() => {
        var z;
        return !!c.WORKERS_SUPPORTED && (z = (() => {
          var F = n.URL || n.webkitURL || null, Y = r.toString();
          return c.BLOB_URL || (c.BLOB_URL = F.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", Y, ")();"], { type: "text/javascript" })));
        })(), (z = new n.Worker(z)).onmessage = A, z.id = l++, a[z.id] = z);
      })()).userStep = O.step, $.userChunk = O.chunk, $.userComplete = O.complete, $.userError = O.error, O.step = S(O.step), O.chunk = S(O.chunk), O.complete = S(O.complete), O.error = S(O.error), delete O.worker, $.postMessage({ input: R, config: O, workerId: $.id });
    }, c.unparse = function(R, O) {
      var $ = !1, z = !0, F = ",", Y = `\r
`, rt = '"', at = rt + rt, pt = !1, vt = null, _t = !1, Ct = ((() => {
        if (typeof O == "object") {
          if (typeof O.delimiter != "string" || c.BAD_DELIMITERS.filter(function(lt) {
            return O.delimiter.indexOf(lt) !== -1;
          }).length || (F = O.delimiter), typeof O.quotes != "boolean" && typeof O.quotes != "function" && !Array.isArray(O.quotes) || ($ = O.quotes), typeof O.skipEmptyLines != "boolean" && typeof O.skipEmptyLines != "string" || (pt = O.skipEmptyLines), typeof O.newline == "string" && (Y = O.newline), typeof O.quoteChar == "string" && (rt = O.quoteChar), typeof O.header == "boolean" && (z = O.header), Array.isArray(O.columns)) {
            if (O.columns.length === 0) throw new Error("Option columns is empty");
            vt = O.columns;
          }
          O.escapeChar !== void 0 && (at = O.escapeChar + rt), O.escapeFormulae instanceof RegExp ? _t = O.escapeFormulae : typeof O.escapeFormulae == "boolean" && O.escapeFormulae && (_t = /^[=+\-@\t\r].*$/);
        }
      })(), new RegExp(f(rt), "g"));
      if (typeof R == "string" && (R = JSON.parse(R)), Array.isArray(R)) {
        if (!R.length || Array.isArray(R[0])) return It(null, R, pt);
        if (typeof R[0] == "object") return It(vt || Object.keys(R[0]), R, pt);
      } else if (typeof R == "object") return typeof R.data == "string" && (R.data = JSON.parse(R.data)), Array.isArray(R.data) && (R.fields || (R.fields = R.meta && R.meta.fields || vt), R.fields || (R.fields = Array.isArray(R.data[0]) ? R.fields : typeof R.data[0] == "object" ? Object.keys(R.data[0]) : []), Array.isArray(R.data[0]) || typeof R.data[0] == "object" || (R.data = [R.data])), It(R.fields || [], R.data || [], pt);
      throw new Error("Unable to serialize unrecognized input");
      function It(lt, L, D) {
        var tt = "", et = (typeof lt == "string" && (lt = JSON.parse(lt)), typeof L == "string" && (L = JSON.parse(L)), Array.isArray(lt) && 0 < lt.length), st = !Array.isArray(L[0]);
        if (et && z) {
          for (var X = 0; X < lt.length; X++) 0 < X && (tt += F), tt += jt(lt[X], X);
          0 < L.length && (tt += Y);
        }
        for (var ot = 0; ot < L.length; ot++) {
          var mt = (et ? lt : L[ot]).length, U = !1, J = et ? Object.keys(L[ot]).length === 0 : L[ot].length === 0;
          if (D && !et && (U = D === "greedy" ? L[ot].join("").trim() === "" : L[ot].length === 1 && L[ot][0].length === 0), D === "greedy" && et) {
            for (var St = [], Rt = 0; Rt < mt; Rt++) {
              var zt = st ? lt[Rt] : Rt;
              St.push(L[ot][zt]);
            }
            U = St.join("").trim() === "";
          }
          if (!U) {
            for (var Tt = 0; Tt < mt; Tt++) {
              0 < Tt && !J && (tt += F);
              var Yt = et && st ? lt[Tt] : Tt;
              tt += jt(L[ot][Yt], Tt);
            }
            ot < L.length - 1 && (!D || 0 < mt && !J) && (tt += Y);
          }
        }
        return tt;
      }
      function jt(lt, L) {
        var D, tt;
        return lt == null ? "" : lt.constructor === Date ? JSON.stringify(lt).slice(1, 25) : (tt = !1, _t && typeof lt == "string" && _t.test(lt) && (lt = "'" + lt, tt = !0), D = lt.toString().replace(Ct, at), (tt = tt || $ === !0 || typeof $ == "function" && $(lt, L) || Array.isArray($) && $[L] || ((et, st) => {
          for (var X = 0; X < st.length; X++) if (-1 < et.indexOf(st[X])) return !0;
          return !1;
        })(D, c.BAD_DELIMITERS) || -1 < D.indexOf(F) || D.charAt(0) === " " || D.charAt(D.length - 1) === " ") ? rt + D + rt : D);
      }
    }, c.RECORD_SEP = "", c.UNIT_SEP = "", c.BYTE_ORDER_MARK = "\uFEFF", c.BAD_DELIMITERS = ["\r", `
`, '"', c.BYTE_ORDER_MARK], c.WORKERS_SUPPORTED = !s && !!n.Worker, c.NODE_STREAM_INPUT = 1, c.LocalChunkSize = 10485760, c.RemoteChunkSize = 5242880, c.DefaultDelimiter = ",", c.Parser = E, c.ParserHandle = b, c.NetworkStreamer = u, c.FileStreamer = p, c.StringStreamer = y, c.ReadableStreamStreamer = g, n.jQuery && ((i = n.jQuery).fn.parse = function(R) {
      var O = R.config || {}, $ = [];
      return this.each(function(Y) {
        if (!(i(this).prop("tagName").toUpperCase() === "INPUT" && i(this).attr("type").toLowerCase() === "file" && n.FileReader) || !this.files || this.files.length === 0) return !0;
        for (var rt = 0; rt < this.files.length; rt++) $.push({ file: this.files[rt], inputElem: this, instanceConfig: i.extend({}, O) });
      }), z(), this;
      function z() {
        if ($.length === 0) S(R.complete) && R.complete();
        else {
          var Y, rt, at, pt, vt = $[0];
          if (S(R.before)) {
            var _t = R.before(vt.file, vt.inputElem);
            if (typeof _t == "object") {
              if (_t.action === "abort") return Y = "AbortError", rt = vt.file, at = vt.inputElem, pt = _t.reason, void (S(R.error) && R.error({ name: Y }, rt, at, pt));
              if (_t.action === "skip") return void F();
              typeof _t.config == "object" && (vt.instanceConfig = i.extend(vt.instanceConfig, _t.config));
            } else if (_t === "skip") return void F();
          }
          var Ct = vt.instanceConfig.complete;
          vt.instanceConfig.complete = function(It) {
            S(Ct) && Ct(It, vt.file, vt.inputElem), F();
          }, c.parse(vt.file, vt.instanceConfig);
        }
      }
      function F() {
        $.splice(0, 1), z();
      }
    }), o && (n.onmessage = function(R) {
      R = R.data, c.WORKER_ID === void 0 && R && (c.WORKER_ID = R.workerId), typeof R.input == "string" ? n.postMessage({ workerId: c.WORKER_ID, results: c.parse(R.input, R.config), finished: !0 }) : (n.File && R.input instanceof File || R.input instanceof Object) && (R = c.parse(R.input, R.config)) && n.postMessage({ workerId: c.WORKER_ID, results: R, finished: !0 });
    }), (u.prototype = Object.create(h.prototype)).constructor = u, (p.prototype = Object.create(h.prototype)).constructor = p, (y.prototype = Object.create(y.prototype)).constructor = y, (g.prototype = Object.create(h.prototype)).constructor = g, c;
  });
})(CL);
var Irt = CL.exports;
const IL = /* @__PURE__ */ Crt(Irt);
var f5 = Symbol.for("immer-nothing"), pf = Symbol.for("immer-draftable"), Oi = Symbol.for("immer-state"), PL = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Wr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const r = PL[e], n = typeof r == "function" ? r.apply(null, t) : r;
    throw new Error(`[Immer] ${n}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var ku = Object.getPrototypeOf;
function Cu(e) {
  return !!e && !!e[Oi];
}
function Nl(e) {
  var t;
  return e ? RL(e) || Array.isArray(e) || !!e[pf] || !!((t = e.constructor) != null && t[pf]) || W0(e) || q0(e) : !1;
}
var Prt = Object.prototype.constructor.toString();
function RL(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = ku(e);
  if (t === null)
    return !0;
  const r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return r === Object ? !0 : typeof r == "function" && Function.toString.call(r) === Prt;
}
function Vf(e, t) {
  Iu(e) === 0 ? Reflect.ownKeys(e).forEach((r) => {
    t(r, e[r], e);
  }) : e.forEach((r, n) => t(n, r, e));
}
function Iu(e) {
  const t = e[Oi];
  return t ? t.type_ : Array.isArray(e) ? 1 : W0(e) ? 2 : q0(e) ? 3 : 0;
}
function Uf(e, t) {
  return Iu(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Av(e, t) {
  return Iu(e) === 2 ? e.get(t) : e[t];
}
function TL(e, t, r) {
  const n = Iu(e);
  n === 2 ? e.set(t, r) : n === 3 ? e.add(r) : e[t] = r;
}
function Rrt(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function W0(e) {
  return e instanceof Map;
}
function q0(e) {
  return e instanceof Set;
}
function qc(e) {
  return e.copy_ || e.base_;
}
function $3(e, t) {
  if (W0(e))
    return new Map(e);
  if (q0(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const r = RL(e);
  if (t === !0 || t === "class_only" && !r) {
    const n = Object.getOwnPropertyDescriptors(e);
    delete n[Oi];
    let i = Reflect.ownKeys(n);
    for (let s = 0; s < i.length; s++) {
      const o = i[s], a = n[o];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (n[o] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[o]
      });
    }
    return Object.create(ku(e), n);
  } else {
    const n = ku(e);
    if (n !== null && r)
      return { ...e };
    const i = Object.create(n);
    return Object.assign(i, e);
  }
}
function g5(e, t = !1) {
  return I2(e) || Cu(e) || !Nl(e) || (Iu(e) > 1 && (e.set = e.add = e.clear = e.delete = Trt), Object.freeze(e), t && Object.entries(e).forEach(([r, n]) => g5(n, !0))), e;
}
function Trt() {
  Wr(2);
}
function I2(e) {
  return Object.isFrozen(e);
}
var z3 = {};
function Pu(e) {
  const t = z3[e];
  return t || Wr(0, e), t;
}
function Ort(e, t) {
  z3[e] || (z3[e] = t);
}
var Hf;
function OL() {
  return Hf;
}
function Lrt(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function K9(e, t) {
  t && (Pu("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function V3(e) {
  U3(e), e.drafts_.forEach(Mrt), e.drafts_ = null;
}
function U3(e) {
  e === Hf && (Hf = e.parent_);
}
function Z9(e) {
  return Hf = Lrt(Hf, e);
}
function Mrt(e) {
  const t = e[Oi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function J9(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const r = t.drafts_[0];
  return e !== void 0 && e !== r ? (r[Oi].modified_ && (V3(t), Wr(4)), Nl(e) && (e = Bm(t, e), t.parent_ || jm(t, e)), t.patches_ && Pu("Patches").generateReplacementPatches_(
    r[Oi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Bm(t, r, []), V3(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== f5 ? e : void 0;
}
function Bm(e, t, r) {
  if (I2(t))
    return t;
  const n = t[Oi];
  if (!n)
    return Vf(
      t,
      (i, s) => X9(e, n, t, i, s, r)
    ), t;
  if (n.scope_ !== e)
    return t;
  if (!n.modified_)
    return jm(e, n.base_, !0), n.base_;
  if (!n.finalized_) {
    n.finalized_ = !0, n.scope_.unfinalizedDrafts_--;
    const i = n.copy_;
    let s = i, o = !1;
    n.type_ === 3 && (s = new Set(i), i.clear(), o = !0), Vf(
      s,
      (a, l) => X9(e, n, i, a, l, r, o)
    ), jm(e, i, !1), r && e.patches_ && Pu("Patches").generatePatches_(
      n,
      r,
      e.patches_,
      e.inversePatches_
    );
  }
  return n.copy_;
}
function X9(e, t, r, n, i, s, o) {
  if (process.env.NODE_ENV !== "production" && i === r && Wr(5), Cu(i)) {
    const a = s && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Uf(t.assigned_, n) ? s.concat(n) : void 0, l = Bm(e, i, a);
    if (TL(r, n, l), Cu(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else o && r.add(i);
  if (Nl(i) && !I2(i)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Bm(e, i), (!t || !t.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(r, n) && jm(e, i);
  }
}
function jm(e, t, r = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && g5(t, r);
}
function Nrt(e, t) {
  const r = Array.isArray(e), n = {
    type_: r ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : OL(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = n, s = m5;
  r && (i = [n], s = Gf);
  const { revoke: o, proxy: a } = Proxy.revocable(i, s);
  return n.draft_ = a, n.revoke_ = o, a;
}
var m5 = {
  get(e, t) {
    if (t === Oi)
      return e;
    const r = qc(e);
    if (!Uf(r, t))
      return Drt(e, r, t);
    const n = r[t];
    return e.finalized_ || !Nl(n) ? n : n === Sv(e.base_, t) ? (_v(e), e.copy_[t] = G3(n, e)) : n;
  },
  has(e, t) {
    return t in qc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(qc(e));
  },
  set(e, t, r) {
    const n = LL(qc(e), t);
    if (n != null && n.set)
      return n.set.call(e.draft_, r), !0;
    if (!e.modified_) {
      const i = Sv(qc(e), t), s = i == null ? void 0 : i[Oi];
      if (s && s.base_ === r)
        return e.copy_[t] = r, e.assigned_[t] = !1, !0;
      if (Rrt(r, i) && (r !== void 0 || Uf(e.base_, t)))
        return !0;
      _v(e), H3(e);
    }
    return e.copy_[t] === r && // special case: handle new props with value 'undefined'
    (r !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(r) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = r, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Sv(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, _v(e), H3(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const r = qc(e), n = Reflect.getOwnPropertyDescriptor(r, t);
    return n && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: n.enumerable,
      value: r[t]
    };
  },
  defineProperty() {
    Wr(11);
  },
  getPrototypeOf(e) {
    return ku(e.base_);
  },
  setPrototypeOf() {
    Wr(12);
  }
}, Gf = {};
Vf(m5, (e, t) => {
  Gf[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Gf.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Wr(13), Gf.set.call(this, e, t, void 0);
};
Gf.set = function(e, t, r) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Wr(14), m5.set.call(this, e[0], t, r, e[0]);
};
function Sv(e, t) {
  const r = e[Oi];
  return (r ? qc(r) : e)[t];
}
function Drt(e, t, r) {
  var i;
  const n = LL(t, r);
  return n ? "value" in n ? n.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = n.get) == null ? void 0 : i.call(e.draft_)
  ) : void 0;
}
function LL(e, t) {
  if (!(t in e))
    return;
  let r = ku(e);
  for (; r; ) {
    const n = Object.getOwnPropertyDescriptor(r, t);
    if (n)
      return n;
    r = ku(r);
  }
}
function H3(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && H3(e.parent_));
}
function _v(e) {
  e.copy_ || (e.copy_ = $3(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Brt = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, r, n) => {
      if (typeof t == "function" && typeof r != "function") {
        const s = r;
        r = t;
        const o = this;
        return function(l = s, ...c) {
          return o.produce(l, (h) => r.call(this, h, ...c));
        };
      }
      typeof r != "function" && Wr(6), n !== void 0 && typeof n != "function" && Wr(7);
      let i;
      if (Nl(t)) {
        const s = Z9(this), o = G3(t, void 0);
        let a = !0;
        try {
          i = r(o), a = !1;
        } finally {
          a ? V3(s) : U3(s);
        }
        return K9(s, n), J9(i, s);
      } else if (!t || typeof t != "object") {
        if (i = r(t), i === void 0 && (i = t), i === f5 && (i = void 0), this.autoFreeze_ && g5(i, !0), n) {
          const s = [], o = [];
          Pu("Patches").generateReplacementPatches_(t, i, s, o), n(s, o);
        }
        return i;
      } else
        Wr(1, t);
    }, this.produceWithPatches = (t, r) => {
      if (typeof t == "function")
        return (o, ...a) => this.produceWithPatches(o, (l) => t(l, ...a));
      let n, i;
      return [this.produce(t, r, (o, a) => {
        n = o, i = a;
      }), n, i];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Nl(e) || Wr(8), Cu(e) && (e = jrt(e));
    const t = Z9(this), r = G3(e, void 0);
    return r[Oi].isManual_ = !0, U3(t), r;
  }
  finishDraft(e, t) {
    const r = e && e[Oi];
    (!r || !r.isManual_) && Wr(9);
    const { scope_: n } = r;
    return K9(n, t), J9(void 0, n);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let r;
    for (r = t.length - 1; r >= 0; r--) {
      const i = t[r];
      if (i.path.length === 0 && i.op === "replace") {
        e = i.value;
        break;
      }
    }
    r > -1 && (t = t.slice(r + 1));
    const n = Pu("Patches").applyPatches_;
    return Cu(e) ? n(e, t) : this.produce(
      e,
      (i) => n(i, t)
    );
  }
};
function G3(e, t) {
  const r = W0(e) ? Pu("MapSet").proxyMap_(e, t) : q0(e) ? Pu("MapSet").proxySet_(e, t) : Nrt(e, t);
  return (t ? t.scope_ : OL()).drafts_.push(r), r;
}
function jrt(e) {
  return Cu(e) || Wr(10, e), ML(e);
}
function ML(e) {
  if (!Nl(e) || I2(e))
    return e;
  const t = e[Oi];
  let r;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, r = $3(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    r = $3(e, !0);
  return Vf(r, (n, i) => {
    TL(r, n, ML(i));
  }), t && (t.finalized_ = !1), r;
}
function Frt() {
  process.env.NODE_ENV !== "production" && PL.push(
    'Sets cannot have "replace" patches.',
    function(p) {
      return "Unsupported patch operation: " + p;
    },
    function(p) {
      return "Cannot apply patch, path doesn't resolve: " + p;
    },
    "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
  );
  const t = "replace", r = "add", n = "remove";
  function i(p, y, g, b) {
    switch (p.type_) {
      case 0:
      case 2:
        return o(
          p,
          y,
          g,
          b
        );
      case 1:
        return s(p, y, g, b);
      case 3:
        return a(
          p,
          y,
          g,
          b
        );
    }
  }
  function s(p, y, g, b) {
    let { base_: f, assigned_: E } = p, A = p.copy_;
    A.length < f.length && ([f, A] = [A, f], [g, b] = [b, g]);
    for (let x = 0; x < f.length; x++)
      if (E[x] && A[x] !== f[x]) {
        const m = y.concat([x]);
        g.push({
          op: t,
          path: m,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: u(A[x])
        }), b.push({
          op: t,
          path: m,
          value: u(f[x])
        });
      }
    for (let x = f.length; x < A.length; x++) {
      const m = y.concat([x]);
      g.push({
        op: r,
        path: m,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: u(A[x])
      });
    }
    for (let x = A.length - 1; f.length <= x; --x) {
      const m = y.concat([x]);
      b.push({
        op: n,
        path: m
      });
    }
  }
  function o(p, y, g, b) {
    const { base_: f, copy_: E } = p;
    Vf(p.assigned_, (A, x) => {
      const m = Av(f, A), w = Av(E, A), _ = x ? Uf(f, A) ? t : r : n;
      if (m === w && _ === t)
        return;
      const S = y.concat(A);
      g.push(_ === n ? { op: _, path: S } : { op: _, path: S, value: w }), b.push(
        _ === r ? { op: n, path: S } : _ === n ? { op: r, path: S, value: u(m) } : { op: t, path: S, value: u(m) }
      );
    });
  }
  function a(p, y, g, b) {
    let { base_: f, copy_: E } = p, A = 0;
    f.forEach((x) => {
      if (!E.has(x)) {
        const m = y.concat([A]);
        g.push({
          op: n,
          path: m,
          value: x
        }), b.unshift({
          op: r,
          path: m,
          value: x
        });
      }
      A++;
    }), A = 0, E.forEach((x) => {
      if (!f.has(x)) {
        const m = y.concat([A]);
        g.push({
          op: r,
          path: m,
          value: x
        }), b.unshift({
          op: n,
          path: m,
          value: x
        });
      }
      A++;
    });
  }
  function l(p, y, g, b) {
    g.push({
      op: t,
      path: [],
      value: y === f5 ? void 0 : y
    }), b.push({
      op: t,
      path: [],
      value: p
    });
  }
  function c(p, y) {
    return y.forEach((g) => {
      const { path: b, op: f } = g;
      let E = p;
      for (let w = 0; w < b.length - 1; w++) {
        const _ = Iu(E);
        let S = b[w];
        typeof S != "string" && typeof S != "number" && (S = "" + S), (_ === 0 || _ === 1) && (S === "__proto__" || S === "constructor") && Wr(19), typeof E == "function" && S === "prototype" && Wr(19), E = Av(E, S), typeof E != "object" && Wr(18, b.join("/"));
      }
      const A = Iu(E), x = h(g.value), m = b[b.length - 1];
      switch (f) {
        case t:
          switch (A) {
            case 2:
              return E.set(m, x);
            case 3:
              Wr(16);
            default:
              return E[m] = x;
          }
        case r:
          switch (A) {
            case 1:
              return m === "-" ? E.push(x) : E.splice(m, 0, x);
            case 2:
              return E.set(m, x);
            case 3:
              return E.add(x);
            default:
              return E[m] = x;
          }
        case n:
          switch (A) {
            case 1:
              return E.splice(m, 1);
            case 2:
              return E.delete(m);
            case 3:
              return E.delete(g.value);
            default:
              return delete E[m];
          }
        default:
          Wr(17, f);
      }
    }), p;
  }
  function h(p) {
    if (!Nl(p))
      return p;
    if (Array.isArray(p))
      return p.map(h);
    if (W0(p))
      return new Map(
        Array.from(p.entries()).map(([g, b]) => [g, h(b)])
      );
    if (q0(p))
      return new Set(Array.from(p).map(h));
    const y = Object.create(ku(p));
    for (const g in p)
      y[g] = h(p[g]);
    return Uf(p, pf) && (y[pf] = p[pf]), y;
  }
  function u(p) {
    return Cu(p) ? h(p) : p;
  }
  Ort("Patches", {
    applyPatches_: c,
    generatePatches_: i,
    generateReplacementPatches_: l
  });
}
var Li = new Brt(), $rt = Li.produce, zrt = Li.produceWithPatches.bind(
  Li
);
Li.setAutoFreeze.bind(Li);
Li.setUseStrictShallowCopy.bind(Li);
Li.applyPatches.bind(Li);
Li.createDraft.bind(Li);
Li.finishDraft.bind(Li);
var NL = (e) => {
  throw TypeError(e);
}, DL = (e, t, r) => t.has(e) || NL("Cannot " + r), t7 = (e, t, r) => (DL(e, t, "read from private field"), r ? r.call(e) : t.get(e)), e7 = (e, t, r) => t.has(e) ? NL("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), r7 = (e, t, r, n) => (DL(e, t, "write to private field"), t.set(e, r), r);
const Fm = "[a-fA-F0-9]", jp = "[a-zA-Z0-9-._~]", zs = "[!$&'()*+,;=]", Yu = `%${Fm}${Fm}`, qg = "(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])", y5 = `${qg}\\.${qg}\\.${qg}\\.${qg}`, _r = `${Fm}{1,4}`, zc = `(?:${_r}:${_r}|${y5})`, Vrt = `(?:(?:${_r}:){6}${zc}|::(?:${_r}:){5}${zc}|(?:${_r})?::(?:${_r}:){4}${zc}|(?:(?:${_r}:){0,1}${_r})?::(?:${_r}:){3}${zc}|(?:(?:${_r}:){0,2}${_r})?::(?:${_r}:){2}${zc}|(?:(?:${_r}:){0,3}${_r})?::(?:${_r}:){1}${zc}|(?:(?:${_r}:){0,4}${_r})?::${zc}|(?:(?:${_r}:){0,5}${_r})?::${_r}|(?:(?:${_r}:){0,6}${_r})?::)`, Urt = `v${Fm}+\\.(?:${jp}|${zs}|:)+`, BL = `\\[(?:${Vrt}|${Urt})\\]`, Fp = "(?<scheme>[a-zA-Z][a-zA-Z0-9-+.]*)", jL = ":(?<port>\\d*)", Hrt = `(?:${jp}|${Yu}|${zs})*?`, Grt = `(?<host>${BL}|${y5}|${Hrt})`, Qrt = `(?<userinfo>(?:${jp}|${Yu}|${zs}|:)*)`, b5 = `(?:${jp}|${Yu}|${zs}|:|@)`, FL = `${b5}*?`, $L = `(?:/${FL})*`, v5 = `(?<authority>(?:${Qrt}@)?${Grt}(?:${jL})?)`, w5 = `(?<path>${$L})`, x5 = `(?<path2>${FL}${$L})`, E5 = `(?:\\?(?<query>(?:${b5}|/|\\?)*))?`, zL = `(?:#(?<fragment>(?:${b5}|/|\\?)*))?`, Wrt = `^${Fp}:(?://${v5}${w5}|${x5})${E5}${zL}$`, qrt = `^(?:${Fp}:|)(?://${v5}${w5}|${x5})${E5}${zL}$`, Yrt = `^${Fp}:(?://${v5}${w5}|${x5})${E5}$`, Y0 = "[a-zA-Z0-9-._~\\00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF\\u10000-\\u1FFFD\\u20000-\\u2FFFD\\u30000-\\u3FFFD\\u40000-\\u4FFFD\\u50000-\\u5FFFD\\u60000-\\u6FFFD\\u70000-\\u7FFFD\\u80000-\\u8FFFD\\u90000-\\u9FFFD\\uA0000-\\uAFFFD\\uB0000-\\uBFFFD\\uC0000-\\uCFFFD\\uD0000-\\uDFFFD\\uE1000-\\uEFFFD]", Krt = "[\\uE000-\\uF8FF\\uF0000-\\uFFFFD\\u100000-\\u10FFFD]", Zrt = `(?:${Y0}|${Yu}|${zs})*?`, Jrt = `(?<host>${BL}|${y5}|${Zrt})`, Xrt = `(?<userinfo>(?:${Y0}|${Yu}|${zs}|:)*)`, A5 = `(?:${Y0}|${Yu}|${zs}|:|@)`, VL = `${A5}*?`, UL = `(?:/${VL})*`, S5 = `(?<authority>(?:${Xrt}@)?${Jrt}(?:${jL})?)`, _5 = `(?<path>${UL})`, k5 = `(?<path2>${VL}${UL})`, C5 = `(?:\\?(?<query>(?:${A5}|${Krt}|/|\\?)*))?`, HL = `(?:#(?<fragment>(?:${A5}|/|\\?)*))?`, GL = `^${Fp}:(?://${S5}${_5}|${k5})${C5}${HL}$`, QL = `^(?:${Fp}:|)(?://${S5}${_5}|${k5})${C5}${HL}$`, WL = `^${Fp}:(?://${S5}${_5}|${k5})${C5}$`, tnt = (e) => (t, r) => {
  const n = (
    /** @type IdentifierComponents */
    e.parseReference(t)
  );
  if (n.scheme === void 0) {
    const i = e.parseAbsolute(r);
    n.scheme = i.scheme, n.authority === void 0 && (n.authority = i.authority, n.path === "" ? (n.path = i.path, n.query === void 0 && (n.query = i.query)) : n.path.startsWith("/") || (n.path = ent(n.path, i)));
  }
  return qL(e, n);
}, ent = (e, t) => {
  if (t.authority && t.path === "")
    return "/" + e;
  {
    const r = t.path.lastIndexOf("/");
    return r === -1 ? e : t.path.slice(0, r + 1) + e;
  }
}, rnt = /^\.?\.\/|^\.\.?$/, nnt = /^\/\.(?:\/|$)/, int = /^\/\.\.(?:\/|$)/, snt = (e) => {
  let t = "";
  for (; e.length > 0; )
    if (rnt.test(e))
      e = n7(e);
    else if (nnt.test(e))
      e = i7(e);
    else if (int.test(e))
      e = i7(e), t = ont(t);
    else {
      const r = ant(e);
      e = n7(e), t += r;
    }
  return t;
}, n7 = (e) => {
  const t = e.indexOf("/", 1);
  return t === -1 ? "" : "/" + e.slice(t + 1);
}, i7 = (e) => {
  const t = e.indexOf("/", 1);
  return t === -1 ? "/" : "/" + e.slice(t + 1);
}, ont = (e) => {
  const t = e.lastIndexOf("/");
  return t === -1 ? e : e.slice(0, t);
}, ant = (e) => {
  const t = e.indexOf("/", 1);
  return t === -1 ? e : e.slice(0, t);
}, qL = (e, t) => {
  let r = t.scheme.toLowerCase() + ":";
  return r += t.authority === void 0 ? "" : "//" + t.authority.toLowerCase(), r += e.normalizePath(t.path), r += t.query === void 0 ? "" : "?" + e.normalizeQuery(t.query), r += t.fragment === void 0 ? "" : "#" + e.normalizeFragment(t.fragment), r;
}, YL = new RegExp(Yu, "g"), KL = (e) => (t) => {
  const r = parseInt(t.slice(1), 16), n = String.fromCharCode(r);
  return e(n) ? n : t.toUpperCase();
};
RegExp.prototype.test.bind(new RegExp(`${jp}|${zs}|[:@]`));
const lnt = RegExp.prototype.test.bind(new RegExp(`${Y0}|${zs}|[:@]`)), cnt = (e) => (t) => snt(t).replaceAll(YL, KL(e));
RegExp.prototype.test.bind(new RegExp(`${jp}|${zs}|[:@/?]`));
const s7 = RegExp.prototype.test.bind(new RegExp(`${Y0}|${zs}|[:@/?]`)), o7 = (e) => (t) => t.replaceAll(YL, KL(e));
RegExp.prototype.test.bind(new RegExp(Wrt));
RegExp.prototype.test.bind(new RegExp(qrt));
RegExp.prototype.test.bind(new RegExp(Yrt));
RegExp.prototype.test.bind(new RegExp(GL));
RegExp.prototype.test.bind(new RegExp(QL));
RegExp.prototype.test.bind(new RegExp(WL));
const I5 = (e, t) => (r) => {
  const n = e.exec(r);
  if (n === null)
    throw Error(`Invalid ${t}: ${r}`);
  const i = (
    /** @type Record<string, string> */
    n.groups
  );
  return i.authority === void 0 && (i.path = i.path2), delete i.path2, /** @type A */
  i;
}, P5 = (
  /** @type Parser<IdentifierComponents> */
  I5(new RegExp(GL), "IRI")
), ZL = (
  /** @type Parser<RelativeIdentifierComponents> */
  I5(new RegExp(QL), "IRI-reference")
), unt = (
  /** @type Parser<AbsoluteIdentifierComponents> */
  I5(new RegExp(WL), "absolute-IRI")
), JL = {
  iri: {
    parseAbsolute: unt,
    parseReference: ZL,
    parse: P5,
    normalizePath: cnt(lnt),
    normalizeQuery: o7(s7),
    normalizeFragment: o7(s7)
  }
}, hnt = (e) => (t) => {
  const r = e.parse(t);
  return delete r.fragment, qL(e, r);
}, pu = hnt(JL.iri), Qf = tnt(JL.iri), pnt = "", Q3 = function* (e) {
  if (e.length > 0 && e[0] !== "/")
    throw Error("Invalid JSON Pointer");
  let t = 1, r = 0;
  for (; r < e.length; ) {
    const n = e.indexOf("/", t);
    r = n === -1 ? e.length : n;
    const i = e.slice(t, r);
    t = r + 1, yield gnt(i);
  }
}, dnt = (e, t = void 0) => {
  if (t === void 0) {
    const r = [...Q3(e)];
    return (n) => a7(r, n);
  } else
    return a7(Q3(e), t);
}, a7 = (e, t) => {
  let r = pnt;
  for (const n of e)
    t = ynt(t, n, r), r = Ru(n, r);
  return t;
}, Ru = (e, t) => t + "/" + fnt(e), fnt = (e) => e.toString().replace(/~/g, "~0").replace(/\//g, "~1"), gnt = (e) => e.toString().replace(/~1/g, "/").replace(/~0/g, "~"), mnt = (e, t) => Array.isArray(e) && t === "-" ? e.length : t, ynt = (e, t, r = "") => {
  if (e === void 0)
    throw TypeError(`Value at '${r}' is undefined and does not have property '${t}'`);
  if (e === null)
    throw TypeError(`Value at '${r}' is null and does not have property '${t}'`);
  if (bnt(e))
    throw TypeError(`Value at '${r}' is a ${typeof e} and does not have property '${t}'`);
  {
    const n = mnt(e, t);
    return e[n];
  }
}, bnt = (e) => e === null || typeof e != "object", XL = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return t;
    case "object":
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) === Object.prototype)
        return "object";
    default: {
      const r = t === "object" ? Object.getPrototypeOf(e).constructor.name || "anonymous" : t;
      throw Error(`Not a JSON compatible type: ${r}`);
    }
  }
}, tM = (e) => {
  const t = e.indexOf("#"), r = t === -1 ? e.length : t;
  return e.slice(0, r);
}, eM = (e) => decodeURIComponent(ZL(e).fragment || ""), $m = {}, P2 = (e) => {
  if (e.indexOf("#") !== -1) {
    const t = tM(e);
    return { ...$m[t], id: e };
  }
  return $m[e];
}, vnt = (e, t) => {
  const r = wnt(e, t);
  if (!r)
    throw Error(`Encountered unknown keyword '${e}'`);
  const n = P2(r);
  if (!n)
    throw Error(`Encountered unsupported keyword ${e}. You can provide an implementation for the '${r}' keyword using the 'addKeyword' function.`);
  return n;
}, ne = (e) => {
  $m[e.id] = e;
}, W3 = {}, uc = (e, t) => {
  W3[e] = t;
}, df = {}, q3 = {}, kv = {}, wnt = (e, t) => {
  var r;
  return ((r = rM(t)) == null ? void 0 : r[e]) || (q3[t] || e.startsWith("x-")) && `https://json-schema.org/keyword/unknown#${e}`;
}, Hr = (e, t) => {
  const r = rM(e);
  for (const n in r)
    if (r[n] === t)
      return n;
}, rM = (e) => {
  if (!(e in df))
    throw Error(`Encountered unknown dialect '${e}'`);
  return df[e];
}, nM = (e, t, r = !1, n = !0) => {
  q3[e] = r, kv[e] = kv[e] || n, df[e] = {}, Object.entries(t).forEach(([i, s]) => {
    if (i in W3)
      Object.entries(W3[i]).forEach(([o, a]) => {
        !(a in $m) && !s && (a = `https://json-schema.org/keyword/unknown#${o}`), df[e][o] = a;
      });
    else if (!r || s)
      throw delete df[e], delete q3[e], delete kv[e], Error(`Unrecognized vocabulary: ${i}. You can define this vocabulary with the 'defineVocabulary' function.`);
  });
};
var l7 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function iM(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Yg = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var c7;
function xnt() {
  if (c7) return Yg;
  c7 = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, n = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  Yg.format = o, Yg.parse = a;
  function o(u) {
    if (!u || typeof u != "object")
      throw new TypeError("argument obj is required");
    var p = u.parameters, y = u.type;
    if (!y || !s.test(y))
      throw new TypeError("invalid type");
    var g = y;
    if (p && typeof p == "object")
      for (var b, f = Object.keys(p).sort(), E = 0; E < f.length; E++) {
        if (b = f[E], !r.test(b))
          throw new TypeError("invalid parameter name");
        g += "; " + b + "=" + c(p[b]);
      }
    return g;
  }
  function a(u) {
    if (!u)
      throw new TypeError("argument string is required");
    var p = typeof u == "object" ? l(u) : u;
    if (typeof p != "string")
      throw new TypeError("argument string is required to be a string");
    var y = p.indexOf(";"), g = y !== -1 ? p.slice(0, y).trim() : p.trim();
    if (!s.test(g))
      throw new TypeError("invalid media type");
    var b = new h(g.toLowerCase());
    if (y !== -1) {
      var f, E, A;
      for (e.lastIndex = y; E = e.exec(p); ) {
        if (E.index !== y)
          throw new TypeError("invalid parameter format");
        y += E[0].length, f = E[1].toLowerCase(), A = E[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(n, "$1"))), b.parameters[f] = A;
      }
      if (y !== p.length)
        throw new TypeError("invalid parameter format");
    }
    return b;
  }
  function l(u) {
    var p;
    if (typeof u.getHeader == "function" ? p = u.getHeader("content-type") : typeof u.headers == "object" && (p = u.headers && u.headers["content-type"]), typeof p != "string")
      throw new TypeError("content-type header is missing from object");
    return p;
  }
  function c(u) {
    var p = String(u);
    if (r.test(p))
      return p;
    if (p.length > 0 && !t.test(p))
      throw new TypeError("invalid parameter value");
    return '"' + p.replace(i, "\\$1") + '"';
  }
  function h(u) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = u;
  }
  return Yg;
}
var sM = xnt();
const Ent = /* @__PURE__ */ iM(sM), Wf = {}, oM = (e, t) => {
  Wf[e] = t;
}, Ant = (e) => {
  const t = e.headers.get("content-type");
  if (t === null)
    throw new Pnt("The media type of the response could not be determined. Make sure the response includes a 'Content-Type' header.", { cause: e });
  const r = sM.parse(t);
  for (const n in Wf)
    if (knt(n, r.type))
      return Wf[n].parse(e);
  throw new Int(r.type, `'${r.type}' is not supported. Use the 'addMediaTypePlugin' function to add support for this media type.`, {
    cause: e
  });
}, Snt = "A-Za-z", Cv = `[!#$%&'*\\-_.^\`|~\\d${Snt}]+`, _nt = `(?<type>${Cv})/(?<subType>${Cv}(?:\\+(?<suffix>${Cv}))?)`, u7 = new RegExp(_nt), knt = (e, t) => {
  var r, n;
  if (e === t)
    return !0;
  const i = (r = u7.exec(e)) == null ? void 0 : r.groups;
  if (!i)
    throw Error(`Unable to parse media-range: ${e}`);
  const s = (n = u7.exec(t)) == null ? void 0 : n.groups;
  if (!s)
    throw Error(`Unable to parse media-type: ${t}`);
  return (i.type === s.type || i.type === "*") && (i.subType === s.subType || i.subType === "*" || i.subType === s.suffix);
}, Cnt = () => {
  let e = "";
  for (const t in Wf)
    e = h7(e, t, Wf[t].quality);
  return h7(e, "*/*", "0.001");
}, h7 = (e, t, r) => (e.length > 0 && (e += ", "), e += t, r && (e += `; q=${r}`), e);
let Int = class extends Error {
  constructor(t, r = void 0) {
    super(r), this.name = this.constructor.name, this.mediaType = t;
  }
}, Pnt = class extends Error {
  constructor(t = void 0) {
    super(t), this.name = this.constructor.name;
  }
};
const Rnt = (e, t = void 0) => JSON.parse(e, (r, n) => {
  const i = n !== null && typeof n.$ref == "string" ? new tu(n.$ref) : n;
  return t ? t(r, i) : i;
});
var T1, O1;
let tu = class {
  constructor(t, r = void 0) {
    e7(this, T1), e7(this, O1), r7(this, T1, t), r7(this, O1, r ?? { $ref: t });
  }
  get href() {
    return t7(this, T1);
  }
  toJSON() {
    return t7(this, O1);
  }
};
T1 = /* @__PURE__ */ new WeakMap(), O1 = /* @__PURE__ */ new WeakMap();
const aM = (e) => {
  const t = typeof e;
  switch (t) {
    case "bigint":
      return "number";
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return t;
    case "object":
      if (e instanceof tu)
        return "reference";
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) === Object.prototype || Object.getPrototypeOf(e) === null)
        return "object";
    default: {
      const r = t === "object" ? Object.getPrototypeOf(e).constructor.name || "anonymous" : t;
      throw Error(`Not a JRef compatible type: ${r}`);
    }
  }
}, Tnt = {
  parse: async (e) => ({
    baseUri: e.url,
    root: Rnt(await e.text()),
    anchorLocation: Ont
  }),
  fileMatcher: (e) => /[^/]\.jref$/.test(e)
}, Ont = (e) => decodeURI(e || ""), Y3 = {}, lM = (e, t) => {
  Y3[e] = t;
}, Lnt = (e, t) => {
  e = Qf(e, t);
  const { scheme: r } = P5(e);
  if (!(r in Y3))
    throw new Mnt(r, `The '${r}:' URI scheme is not supported. Use the 'addUriSchemePlugin' function to add support for '${r}:' URIs.`);
  return Y3[r].retrieve(e, t);
};
let Mnt = class extends Error {
  constructor(t, r = void 0) {
    super(r), this.name = this.constructor.name, this.scheme = t;
  }
};
const Nnt = /* @__PURE__ */ new Set([200, 203]), Dnt = async (e) => {
  const t = await fetch(e, { headers: { Accept: Cnt() } });
  if (t.status >= 400)
    throw new p7(t, `Failed to retrieve '${e}'`);
  if (!Nnt.has(t.status))
    throw new p7(t, "Unsupported HTTP response status code");
  return t;
}, cM = { retrieve: Dnt };
let p7 = class extends Error {
  constructor(t, r = void 0) {
    super(`${t.status} ${t.statusText}${r ? ` -- ${r}` : ""}`), this.name = this.constructor.name, this.response = t;
  }
};
var uM = Bnt;
function Bnt(e, t) {
  return function r() {
    t == null && (t = e.length);
    var n = [].slice.call(arguments);
    return n.length >= t ? e.apply(this, n) : function() {
      return r.apply(this, n.concat([].slice.call(arguments)));
    };
  };
}
const jnt = () => {
  var e, t;
  return ((t = (e = globalThis.document) == null ? void 0 : e.location) == null ? void 0 : t.toString()) ?? "";
}, R2 = async (e, t = { _cache: {} }) => {
  var r, n, i;
  const s = ((r = t.document) == null ? void 0 : r.baseUri) ?? jnt();
  e = Qf(e, s);
  const o = pu(e), { fragment: a } = P5(e), l = t._cache[o] ?? ((i = (n = t.document) == null ? void 0 : n.embedded) == null ? void 0 : i[o]);
  if (l)
    t.document = l, t.uri = e, t.cursor = t.document.anchorLocation(a);
  else {
    try {
      const c = await Lnt(e, s);
      t.document = await Ant(c), t.uri = c.url + (a === void 0 ? "" : `#${a}`), t.cursor = t.document.anchorLocation(a);
    } catch (c) {
      const h = t.uri ? ` Referenced from '${t.uri}'.` : "";
      throw new $nt(`Unable to load resource '${e}'.${h}`, c);
    }
    t._cache[o] = t.document;
  }
  return t._value = dnt(t.cursor, t.document.root), hM(t);
}, hM = (e) => aM(Ae(e)) === "reference" ? R2(Ae(e).href, e) : e, Ae = (e) => e._value, pa = (e) => aM(e._value), pM = (e, t) => e in t._value, dM = (e) => e._value.length, Rs = uM((e, t) => hM({
  ...t,
  cursor: Ru(`${e}`, t.cursor),
  _value: t._value[e]
})), hc = async function* (e) {
  for (let t = 0; t < Ae(e).length; t++)
    yield Rs(t, e);
}, K3 = function* (e) {
  for (const t in Ae(e))
    yield t;
}, Fnt = async function* (e) {
  for (const t in Ae(e))
    yield Rs(t, e);
}, Tu = async function* (e) {
  for (const t in Ae(e))
    yield [t, await Rs(t, e)];
};
let $nt = class extends Error {
  constructor(t, r) {
    super(t, { cause: r }), this.name = this.constructor.name;
  }
};
oM("application/reference+json", Tnt);
lM("http", cM);
lM("https", cM);
const znt = {
  parse: async (e) => {
    const t = Ent.parse(e.headers.get("content-type") ?? ""), r = t.parameters.schema ?? t.parameters.profile;
    return Vm(await e.json(), e.url, r);
  },
  fileMatcher: async (e) => /(\.|\/)schema\.json$/.test(e)
}, zm = {}, Vnt = async (e, t = void 0) => {
  t || (t = { _cache: {} });
  for (const n in zm)
    n in t._cache || (t._cache[n] = zm[n]);
  const r = await R2(e, { ...t });
  if (typeof r.document.dialectId != "string")
    throw Error(`The document at ${r.document.baseUri} is not a schema.`);
  return r;
}, Ca = (e, t, r) => {
  e = structuredClone(e);
  const n = Vm(e, t, r);
  if (n.baseUri in zm)
    throw Error(`A schema has already been registered for '${n.baseUri}. You can use 'unregisterSchema' to remove the old schema before registering the new one.`);
  if (n.baseUri.startsWith("file:"))
    throw Error(`Registering a schema with a 'file:' URI scheme is not allowed: ${n.baseUri}`);
  zm[n.baseUri] = n;
}, Vm = (e, t, r, n = {}) => {
  if (typeof e.$schema == "string" && (r = e.$schema, delete e.$schema), !r)
    throw Error("Unable to determine a dialect for the schema. The dialect can be declared in a number of ways, but the recommended way is to use the '$schema' keyword in your schema.");
  r = pu(r);
  const i = Hr(r, "https://json-schema.org/keyword/draft-04/id"), s = Hr(r, "https://json-schema.org/keyword/id") || i;
  if (!e[s] && !t)
    throw Error(`Unable to determine an identifier for the schema. Use the '${s}' keyword or pass a retrievalUri when loading the schema.`);
  const o = Qf(e[s] ?? "", t ?? "");
  t = pu(o), i && o.length > t.length ? e[s] = "#" + eM(o) : delete e[s];
  const a = Hr(r, "https://json-schema.org/keyword/vocabulary");
  if (XL(e[a]) === "object") {
    const u = e[a]["https://json-schema.org/draft/2019-09/vocab/core"] || e[a]["https://json-schema.org/draft/2020-12/vocab/core"];
    nM(t, e[a], u, !1), delete e[a];
  }
  const l = { "": "" }, c = {}, h = Hr(r, "https://json-schema.org/keyword/draft-2019-09/recursiveAnchor");
  return e[h] === !0 && (c[""] = `${t}#`), delete e[h], n[t] = {
    baseUri: t,
    dialectId: r,
    root: Z3(e, t, r, "", n, l, c),
    anchorLocation: (u) => {
      if (u === void 0)
        return "";
      if (u = decodeURI(u), u[0] === "/")
        return u;
      if (u in l)
        return l[u];
      throw Error(`No such anchor '${t}#${encodeURI(u)}'`);
    },
    anchors: l,
    dynamicAnchors: c,
    embedded: n
  }, n[t];
}, Z3 = (e, t, r, n, i, s, o) => {
  if (XL(e) === "object") {
    const a = typeof e.$schema == "string" ? pu(e.$schema) : r, l = Hr(a, "https://json-schema.org/keyword/id");
    if (typeof e[l] == "string") {
      const g = pu(Qf(e[l], t));
      return e[l] = g, i[g] = Vm(e, g, a, i), new tu(g, {});
    }
    const c = Hr(a, "https://json-schema.org/keyword/draft-04/id");
    if (typeof e[c] == "string")
      if (e[c][0] === "#") {
        const g = decodeURIComponent(e[c].slice(1));
        s[g] = n, delete e[c];
      } else {
        const g = pu(Qf(e[c], t));
        return e[c] = g, i[g] = Vm(e, g, a, i), new tu(g, {});
      }
    const h = Hr(r, "https://json-schema.org/keyword/draft-04/ref");
    if (typeof e[h] == "string")
      return new tu(e[h], e);
    const u = Hr(r, "https://json-schema.org/keyword/anchor");
    typeof e[u] == "string" && (s[e[u]] = n, delete e[u]);
    const p = Hr(r, "https://json-schema.org/keyword/dynamicAnchor");
    typeof e[p] == "string" && (o[e[p]] = `${t}#${encodeURI(n)}`, delete e[p]);
    const y = Hr(r, "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor");
    typeof e[y] == "string" && (o[e[y]] = `${t}#${encodeURI(n)}`, s[e[y]] = n, delete e[y]);
    for (const g in e) {
      const b = Hr(r, "https://json-schema.org/keyword/ref");
      g === b && typeof e[g] == "string" ? e[g] = new tu(e[g], e[g]) : e[g] = Z3(e[g], t, r, Ru(g, n), i, s, o);
    }
  } else if (Array.isArray(e))
    for (let a = 0; a < e.length; a++)
      e[a] = Z3(e[a], t, r, Ru(a, n), i, s, o);
  return e;
}, ip = (e) => `${e.document.baseUri}#${encodeURI(e.cursor)}`, $p = (
  /** @type API.curry */
  (e) => (...t) => {
    const r = e.length === 1 ? (
      /** @type Extract<typeof fn, (a: any) => any> */
      e(t[0])
    ) : e(t[0], t[1]), n = (
      /** @type I */
      t[e.length]
    );
    return n === void 0 ? r : r(n);
  }
), fM = $p((e) => function* (t) {
  for (const r of t)
    yield e(r);
}), jn = $p((e) => async function* (t) {
  for await (const r of t)
    yield e(r);
}), gM = $p((e) => function* (t) {
  for (const r of t)
    e(r) && (yield r);
}), Unt = $p((e) => function* (t) {
  let r = 0;
  for (const n of t)
    r++ >= e && (yield n);
}), Hnt = (e) => {
  const t = bM(e).next();
  return t.done ? void 0 : t.value;
}, mM = function* (e, t) {
  for (let r = e; t === void 0; r++)
    yield r;
}, d7 = function* () {
}, R5 = function* (e, t) {
  const r = bM(t);
  for (const n of e)
    yield [n, r.next().value];
}, Gnt = function* (...e) {
  for (const t of e)
    yield* t;
}, yM = (
  /** @type API.reduce */
  $p(
    // eslint-disable-next-line @stylistic/no-extra-parens
    /** @type API.reduce */
    (e, t) => (r) => {
      for (const n of r)
        t = e(
          t,
          /** @type any */
          n
        );
      return t;
    }
  )
), Vs = async (e) => {
  const t = [];
  for await (const r of e)
    t.push(r);
  return t;
}, Qnt = (e) => {
  const t = /* @__PURE__ */ new Set();
  for (const r of e)
    t.add(r);
  return t;
}, J3 = async (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  for await (const [r, n] of e)
    t[r] = n;
  return t;
}, Wnt = $p((e) => (t) => {
  let r = Hnt(t) ?? "";
  for (const n of t)
    r += e + n;
  return r;
}), bM = (e) => {
  if (typeof (e == null ? void 0 : e[Symbol.iterator]) == "function")
    return e[Symbol.iterator]();
  throw TypeError("`iter` is not iterable");
}, cn = (
  /** @type (acc: any, ...fns: ((a: any) => any)[]) => any */
  (e, ...t) => yM((r, n) => n(r), e, t)
), L1 = (e, t = "", r = "", n = void 0) => {
  const i = typeof e;
  switch (i) {
    case "number":
    case "string":
    case "boolean":
      return jd(t, r, e, i, [], n);
    case "object":
      if (e === null)
        return jd(t, r, e, "null", [], n);
      if (Array.isArray(e)) {
        const s = jd(t, r, e, "array", [], n);
        return s.children = e.map((o, a) => L1(o, t, Ru(a, r), s)), s;
      } else if (Object.getPrototypeOf(e) === Object.prototype) {
        const s = jd(t, r, e, "object", [], n);
        return s.children = Object.entries(e).map((o) => {
          const a = Ru(o[0], r), l = jd(t, a, void 0, "property", [], s);
          return l.children = o.map((c) => L1(c, t, a, l)), l;
        }), s;
      } else if (e instanceof tu)
        return L1(e.toJSON(), t, r, n);
    default: {
      const s = i === "object" ? Object.getPrototypeOf(e).constructor.name || "anonymous" : i;
      throw Error(`Not a JSON compatible type: ${s}`);
    }
  }
}, jd = (e, t, r, n, i, s) => {
  const o = {
    baseUri: e ? pu(e) : "",
    pointer: t,
    value: r,
    type: n,
    children: i,
    parent: s,
    valid: !0,
    errors: {},
    annotations: {}
  };
  return o.root = (s == null ? void 0 : s.root) ?? o, o;
}, qnt = (e) => `${e.baseUri}#${encodeURI(e.pointer)}`, wr = (e) => e.value, $e = (e) => e.type, sp = (e, t) => e in t.value, Ku = function* (e) {
  e.type === "array" && (yield* e.children);
}, T5 = function* (e) {
  if (e.type === "object")
    for (const t of e.children)
      yield t.children[0];
}, Ynt = function* (e) {
  if (e.type === "object")
    for (const t of e.children)
      t.children[1] && (yield t.children[1]);
}, pc = function* (e) {
  if (e.type === "object")
    for (const t of e.children)
      t.children.length === 2 && (yield t.children);
}, K0 = (e) => {
  if (e.type === "array")
    return e.children.length;
}, X3 = function* (e) {
  switch (yield e, $e(e)) {
    case "object":
      for (const t of Ynt(e))
        yield* X3(t);
      break;
    case "array":
      for (const t of Ku(e))
        yield* X3(t);
      break;
  }
}, Gh = {};
let Knt = 0;
const Znt = (e, t) => {
  e in Gh || (Gh[e] = {});
  const r = `pubsub_subscription_${Knt++}`;
  return Gh[e][r] = t, r;
}, Jnt = async (e, t) => {
  const r = [];
  for (const n in Gh)
    if (n === e || e.startsWith(`${n}.`))
      for (const i in Gh[n])
        r.push(Gh[e][i](e, t));
  await Promise.all(r);
};
let vM;
const Xnt = () => vM, tit = (e) => {
  vM = e;
};
let eit = class extends Error {
  constructor(t) {
    super("Invalid Schema"), this.name = this.constructor.name, this.output = t;
  }
};
const wM = "https://json-schema.org/evaluation/validate", rit = async (e, t) => {
  await Jnt("validate.metaValidate", e), e.document.baseUri in t.metaData || (t.metaData[e.document.baseUri] = {
    dynamicAnchors: e.document.dynamicAnchors
  });
  const r = ip(e);
  if (!(r in t)) {
    t[r] = !1;
    const n = Ae(e);
    if (!["object", "boolean"].includes(typeof n))
      throw Error(`No schema found at '${r}'`);
    t[r] = typeof n == "boolean" ? n : await cn(
      Tu(e),
      jn(async ([i, s]) => {
        const o = vnt(i, e.document.dialectId), a = await o.compile(s, t, e);
        return [o.id, Ru(i, ip(e)), a];
      }),
      Vs
    );
  }
  return r;
}, nit = (e, t, r, n, i = !1) => {
  n = { ...r.metaData[tM(e)].dynamicAnchors, ...n };
  let s = !0;
  if (typeof r[e] == "boolean")
    s = r[e];
  else
    for (const [o, a, l] of r[e])
      t.valid = P2(o).interpret(l, t, r, n, i, e), t.valid || (i || (t.errors[a] = o), s = !1);
  return s || (t.errors[e] = wM), t.valid = s, s;
}, iit = /* @__PURE__ */ new Set(), sit = (e, t, r, n, i = !1) => {
  if (typeof r[e] == "boolean")
    return r[e] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[e]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedProperties")
      continue;
    const l = P2(o), c = "collectEvaluatedProperties" in l ? l.collectEvaluatedProperties(a, t, r, n, i) : l.interpret(a, t, r, n, !0) && iit;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, oit = /* @__PURE__ */ new Set(), ait = (e, t, r, n, i = !1) => {
  if (typeof r[e] == "boolean")
    return r[e] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[e]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedItems")
      continue;
    const l = P2(o), c = "collectEvaluatedItems" in l ? l.collectEvaluatedItems(a, t, r, n, i) : l.interpret(a, t, r, n, !0) && oit;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, Ut = { id: wM, compile: rit, interpret: nit, collectEvaluatedProperties: sit, collectEvaluatedItems: ait }, Um = {}, lit = (e, t) => {
  if (t in Um)
    return Um[t](e);
  throw Error(`The '${t}' error format is not supported`);
};
Um.FLAG = (e) => ({ valid: e.valid });
Um.BASIC = (e) => {
  const t = {
    valid: e.valid
  };
  if (!e.valid) {
    t.errors = [];
    for (const r of X3(e))
      for (const [n, i] of Object.entries(r.errors).reverse())
        i !== "https://json-schema.org/evaluation/validate" && !r.valid && t.errors.unshift({
          keyword: i,
          absoluteKeywordLocation: n,
          instanceLocation: qnt(r),
          valid: r.valid
        });
  }
  return t;
};
const xM = "FLAG";
tit(xM);
const cit = async (e) => {
  const t = { metaData: {} }, r = await Ut.compile(e, t);
  return { ast: t, schemaUri: r };
}, uit = uM(({ ast: e, schemaUri: t }, r, n = xM) => (Ut.interpret(t, r, e, {}), lit(r, n))), Iv = {};
Znt("validate.metaValidate", async (e, t) => {
  if (!t.document.validated) {
    if (t.document.validated = !0, !(t.document.dialectId in Iv)) {
      const i = await Vnt(t.document.dialectId, t), s = await cit(i);
      Iv[t.document.dialectId] = uit(s);
    }
    const r = L1(t.document.root, t.document.baseUri), n = Iv[t.document.dialectId](r, Xnt());
    if (!n.valid)
      throw new eit(n);
  }
});
const hit = "https://json-schema.org/keyword/additionalProperties", pit = async (e, t, r) => {
  const n = Hr(e.document.dialectId, "https://json-schema.org/keyword/properties"), i = await Rs(n, r), s = pa(i) === "object" ? fM((h) => "^" + dit(h) + "$", K3(i)) : d7(), o = Hr(e.document.dialectId, "https://json-schema.org/keyword/patternProperties"), a = await Rs(o, r), l = pa(a) === "object" ? K3(a) : d7(), c = cn(
    Gnt(s, l),
    Wnt("|")
  ) || "(?!)";
  return [new RegExp(c, "u"), await Ut.compile(e, t)];
}, dit = (e) => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), fit = ([e, t], r, n, i, s) => {
  if ($e(r) !== "object")
    return !0;
  let o = !0;
  for (const [a, l] of pc(r)) {
    const c = wr(a);
    !e.test(c) && !Ut.interpret(t, l, n, i, s) && (o = !1);
  }
  return o;
}, git = ([e, t], r, n, i) => {
  if ($e(r) !== "object")
    return !0;
  const s = /* @__PURE__ */ new Set();
  for (const [o, a] of pc(r)) {
    const l = wr(o);
    if (!e.test(l)) {
      if (!Ut.interpret(t, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, mit = { id: hit, compile: pit, interpret: fit, collectEvaluatedProperties: git }, yit = "https://json-schema.org/keyword/allOf", bit = (e, t) => cn(
  hc(e),
  jn((r) => Ut.compile(r, t)),
  Vs
), vit = (e, t, r, n, i) => {
  let s = !0;
  for (const o of e)
    Ut.interpret(o, t, r, n, i) || (s = !1);
  return s;
}, wit = (e, t, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of e) {
    const o = Ut.collectEvaluatedProperties(s, t, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, xit = (e, t, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of e) {
    const o = Ut.collectEvaluatedItems(s, t, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, Eit = { id: yit, compile: bit, interpret: vit, collectEvaluatedProperties: wit, collectEvaluatedItems: xit }, Ait = { id: "https://json-schema.org/keyword/anchor" }, Sit = "https://json-schema.org/keyword/anyOf", _it = (e, t) => cn(
  hc(e),
  jn((r) => Ut.compile(r, t)),
  Vs
), kit = (e, t, r, n, i) => e.filter((s) => Ut.interpret(s, t, r, n, i)).length > 0, Cit = (e, t, r, n) => {
  let i = !1;
  for (const s of e) {
    const o = Ut.collectEvaluatedProperties(s, t, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, Iit = (e, t, r, n) => {
  let i = !1;
  for (const s of e) {
    const o = Ut.collectEvaluatedItems(s, t, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, Pit = { id: Sit, compile: _it, interpret: kit, collectEvaluatedProperties: Cit, collectEvaluatedItems: Iit }, Rit = "https://json-schema.org/keyword/conditional", Tit = (e, t) => cn(
  hc(e),
  EM,
  jn((r) => Ut.compile(r, t)),
  Vs
), Oit = (e, t, r, n, i) => {
  for (let s = 0; s < e.length; s += 2) {
    const o = Ut.interpret(e[s], t, r, n, i);
    if (s + 1 === e.length)
      return o;
    if (o)
      return Ut.interpret(e[s + 1], t, r, n, i);
  }
  return !0;
}, Lit = (e, t, r, n) => {
  for (let i = 0; i < e.length; i += 2) {
    const s = Ut.collectEvaluatedProperties(e[i], t, r, n);
    if (i + 1 === e.length)
      return s;
    if (s !== !1)
      return Ut.collectEvaluatedProperties(e[i + 1], t, r, n);
  }
  return /* @__PURE__ */ new Set();
}, Mit = (e, t, r, n) => {
  for (let i = 0; i < e.length; i += 2) {
    const s = Ut.collectEvaluatedItems(e[i], t, r, n);
    if (i + 1 === e.length)
      return s;
    if (s !== !1)
      return Ut.collectEvaluatedItems(e[i + 1], t, r, n);
  }
  return /* @__PURE__ */ new Set();
}, EM = async function* (e, t = 1) {
  for await (const r of e)
    t > 0 && pa(r) === "array" ? yield* EM(hc(r), t - 1) : yield r;
}, Nit = { id: Rit, compile: Tit, interpret: Oit, collectEvaluatedProperties: Lit, collectEvaluatedItems: Mit };
var f7, g7;
function Dit() {
  return g7 || (g7 = 1, f7 = {
    space: "",
    cycles: !1,
    replacer: (e, t) => t,
    stringify: JSON.stringify
  }), f7;
}
var m7, y7;
function Vc() {
  return y7 || (y7 = 1, m7 = {
    isArray: Array.isArray,
    assign: Object.assign,
    isObject: (e) => typeof e == "object",
    isFunction: (e) => typeof e == "function",
    isBoolean: (e) => typeof e == "boolean",
    isRegex: (e) => e instanceof RegExp,
    keys: Object.keys
  }), m7;
}
var Pv, b7;
function Bit() {
  if (b7) return Pv;
  b7 = 1;
  const e = Dit(), t = Vc().isFunction, r = Vc().isBoolean, n = Vc().isObject, i = Vc().isArray, s = Vc().isRegex, o = Vc().assign, a = Vc().keys;
  function l(h) {
    return h == null ? h : s(h) ? h.toString() : h.toJSON ? h.toJSON() : h;
  }
  function c(h, u) {
    u = u || o({}, e), t(u) && (u = { compare: u });
    const p = u.space || e.space, y = r(u.cycles) ? u.cycles : e.cycles, g = u.replacer || e.replacer, b = u.stringify || e.stringify, f = u.compare && /* @__PURE__ */ function(A) {
      return function(x) {
        return function(m, w) {
          const _ = { key: m, value: x[m] }, S = { key: w, value: x[w] };
          return A(_, S);
        };
      };
    }(u.compare);
    y || b(h);
    const E = [];
    return function A(x, m, w, _) {
      const S = p ? `
` + new Array(_ + 1).join(p) : "", R = p ? ": " : ":";
      if (w = l(w), w = g.call(x, m, w), w !== void 0) {
        if (!n(w) || w === null) return b(w);
        if (i(w)) {
          const O = [];
          for (let $ = 0; $ < w.length; $++) {
            const z = A(w, $, w[$], _ + 1) || b(null);
            O.push(S + p + z);
          }
          return "[" + O.join(",") + S + "]";
        } else {
          if (y) {
            if (E.indexOf(w) !== -1)
              return b("[Circular]");
            E.push(w);
          }
          const O = a(w).sort(f && f(w)), $ = [];
          for (let z = 0; z < O.length; z++) {
            const F = O[z], Y = A(w, F, w[F], _ + 1);
            if (!Y) continue;
            const rt = b(F) + R + Y;
            $.push(S + p + rt);
          }
          return E.splice(E.indexOf(w), 1), "{" + $.join(",") + S + "}";
        }
      }
    }({ "": h }, "", h, 0);
  }
  return Pv = c, Pv;
}
var jit = Bit();
const Z0 = /* @__PURE__ */ iM(jit), Fit = "https://json-schema.org/keyword/const", $it = (e) => Z0(Ae(e)), zit = (e, t) => Z0(wr(t)) === e, Vit = { id: Fit, compile: $it, interpret: zit }, Uit = "https://json-schema.org/keyword/contains", Hit = async (e, t, r) => {
  const n = await Ut.compile(e, t), i = Hr(e.document.dialectId, "https://json-schema.org/keyword/minContains"), s = await Rs(i, r), o = pa(s) === "number" ? Ae(s) : 1, a = Hr(e.document.dialectId, "https://json-schema.org/keyword/maxContains"), l = await Rs(a, r), c = pa(l) === "number" ? Ae(l) : Number.MAX_SAFE_INTEGER;
  return { contains: n, minContains: o, maxContains: c };
}, AM = ({ contains: e, minContains: t, maxContains: r }, n, i, s, o) => {
  const a = $e(n) !== "array" || cn(
    Ku(n),
    gM((l) => Ut.interpret(e, l, i, s, o)),
    yM((l) => l + 1, 0)
  );
  return a >= t && a <= r;
}, Git = (e, t, r, n) => AM(e, t, r, n, !0) && $e(t) === "array" && cn(
  R5(Ku(t), mM(0)),
  gM(([i]) => Ut.interpret(e.contains, i, r, n, !0)),
  fM(([, i]) => i),
  Qnt
), Qit = { id: Uit, compile: Hit, interpret: AM, collectEvaluatedItems: Git }, Wit = "https://json-schema.org/keyword/comment", qit = () => {
}, Yit = () => !0, Kit = { id: Wit, compile: qit, interpret: Yit }, hs = (e, t, r, n) => {
  t in e.annotations || (e.annotations[t] = {}), e.annotations[t][r] = n;
}, SM = "https://json-schema.org/keyword/contentEncoding", Zit = (e) => Ae(e), Jit = (e, t, r, n, i, s) => (hs(t, SM, s, e), !0), Xit = { id: SM, compile: Zit, interpret: Jit }, _M = "https://json-schema.org/keyword/contentMediaType", tst = (e) => Ae(e), est = (e, t, r, n, i, s) => (hs(t, _M, s, e), !0), rst = { id: _M, compile: tst, interpret: est }, kM = "https://json-schema.org/keyword/contentSchema", nst = (e) => ip(e), ist = (e, t, r, n, i, s) => (hs(t, kM, s, e), !0), sst = { id: kM, compile: nst, interpret: ist }, CM = "https://json-schema.org/keyword/default", ost = (e) => Ae(e), ast = (e, t, r, n, i, s) => (hs(t, CM, s, e), !0), lst = { id: CM, compile: ost, interpret: ast }, cst = "https://json-schema.org/keyword/definitions", ust = (e, t) => cn(
  Fnt(e),
  jn((r) => Ut.compile(r, t)),
  Vs
), hst = () => !0, pst = { id: cst, compile: ust, interpret: hst }, dst = "https://json-schema.org/keyword/dependentRequired", fst = (e) => cn(
  Tu(e),
  jn(([t, r]) => [t, Ae(r)]),
  Vs
), gst = (e, t) => {
  if ($e(t) !== "object")
    return !0;
  let r = !0;
  for (const [n, i] of e)
    sp(n, t) && !i.every((s) => sp(s, t)) && (r = !1);
  return r;
}, mst = { id: dst, compile: fst, interpret: gst }, yst = "https://json-schema.org/keyword/dependentSchemas", bst = (e, t) => cn(
  Tu(e),
  jn(async ([r, n]) => [r, await Ut.compile(n, t)]),
  Vs
), vst = (e, t, r, n, i) => {
  if ($e(t) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of e)
    sp(o, t) && !Ut.interpret(a, t, r, n, i) && (s = !1);
  return s;
}, wst = (e, t, r, n) => {
  if ($e(t) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of e)
    if (sp(s, t)) {
      const a = Ut.collectEvaluatedProperties(o, t, r, n);
      if (a === !1)
        return !1;
      a.forEach(Set.prototype.add.bind(i));
    }
  return i;
}, xst = { id: yst, compile: bst, interpret: vst, collectEvaluatedProperties: wst }, IM = "https://json-schema.org/keyword/deprecated", Est = (e) => Ae(e), Ast = (e, t, r, n, i, s) => (hs(t, IM, s, e), !0), Sst = { id: IM, compile: Est, interpret: Ast }, PM = "https://json-schema.org/keyword/description", _st = (e) => Ae(e), kst = (e, t, r, n, i, s) => (hs(t, PM, s, e), !0), Cst = { id: PM, compile: _st, interpret: kst }, Ist = { id: "https://json-schema.org/keyword/dynamicAnchor" }, Pst = "https://json-schema.org/keyword/dynamicRef", Rst = async (e, t) => {
  const r = Ae(e), n = await R2(e.document.baseUri, e);
  return await Ut.compile(n, t), r;
}, O5 = (e, t, r, n, i, s) => {
  if (!(t in i))
    throw Error(`No dynamic anchor found for "${t}"`);
  return e(i[t], r, n, i, s);
}, Tst = (...e) => O5(Ut.interpret, ...e), Ost = (...e) => O5(Ut.collectEvaluatedProperties, ...e), Lst = (...e) => O5(Ut.collectEvaluatedItems, ...e), Mst = { id: Pst, compile: Rst, interpret: Tst, collectEvaluatedProperties: Ost, collectEvaluatedItems: Lst }, Nst = "https://json-schema.org/keyword/else", Dst = async (e, t, r) => {
  const n = Hr(e.document.dialectId, "https://json-schema.org/keyword/if");
  if (pM(n, r)) {
    const i = await Rs(n, r);
    return [await Ut.compile(i, t), await Ut.compile(e, t)];
  } else
    return [];
}, Bst = ([e, t], r, n, i, s) => e === void 0 || Ut.interpret(e, r, n, i, !0) || Ut.interpret(t, r, n, i, s), jst = ([e, t], r, n, i) => e === void 0 || Ut.interpret(e, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ut.collectEvaluatedProperties(t, r, n, i), Fst = ([e, t], r, n, i) => e === void 0 || Ut.interpret(e, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ut.collectEvaluatedItems(t, r, n, i), $st = { id: Nst, compile: Dst, interpret: Bst, collectEvaluatedProperties: jst, collectEvaluatedItems: Fst }, zst = "https://json-schema.org/keyword/enum", Vst = (e) => cn(
  hc(e),
  jn(Ae),
  jn(Z0),
  Vs
), Ust = (e, t) => {
  const r = Z0(wr(t));
  return e.some((n) => r === n);
}, Hst = { id: zst, compile: Vst, interpret: Ust }, RM = "https://json-schema.org/keyword/examples", Gst = (e) => Ae(e), Qst = (e, t, r, n, i, s) => (hs(t, RM, s, e), !0), Wst = { id: RM, compile: Gst, interpret: Qst }, qst = "https://json-schema.org/keyword/exclusiveMaximum", Yst = (e) => Ae(e), Kst = (e, t) => $e(t) !== "number" || wr(t) < e, Zst = { id: qst, compile: Yst, interpret: Kst }, Jst = "https://json-schema.org/keyword/exclusiveMinimum", Xst = (e) => Ae(e), tot = (e, t) => $e(t) !== "number" || wr(t) > e, eot = { id: Jst, compile: Xst, interpret: tot }, TM = "https://json-schema.org/keyword/format", rot = (e) => Ae(e), not = (e, t, r, n, i, s) => (hs(t, TM, s, e), !0), iot = { id: TM, compile: rot, interpret: not }, sot = { id: "https://json-schema.org/keyword/id" }, oot = "https://json-schema.org/keyword/if", aot = (e, t) => Ut.compile(e, t), lot = (e, t, r, n) => (Ut.interpret(e, t, r, n, !0), !0), cot = (e, t, r, n) => Ut.collectEvaluatedProperties(e, t, r, n) || [], uot = (e, t, r, n) => Ut.collectEvaluatedItems(e, t, r, n) || /* @__PURE__ */ new Set(), hot = { id: oot, compile: aot, interpret: lot, collectEvaluatedProperties: cot, collectEvaluatedItems: uot }, pot = () => {
  const e = ts(!1), t = ts(!0);
  return bn(e, t), { start: e, end: t };
}, dot = (e) => {
  const t = ts(!1), r = ts(!0);
  return vot(t, r, e), { start: t, end: r };
}, fot = (e, t) => e === void 0 ? t : (bn(e.end, t.start), e.end.isEnd = !1, { start: e.start, end: t.end }), got = (e, t) => {
  const r = ts(!1);
  bn(r, e.start), bn(r, t.start);
  const n = ts(!0);
  return bn(e.end, n), e.end.isEnd = !1, bn(t.end, n), t.end.isEnd = !1, { start: r, end: n };
}, mot = (e) => {
  const t = ts(!1), r = ts(!0);
  return bn(t, r), bn(t, e.start), bn(e.end, r), bn(e.end, e.start), e.end.isEnd = !1, { start: t, end: r };
}, yot = (e) => {
  const t = ts(!1), r = ts(!0);
  return bn(t, r), bn(t, e.start), bn(e.end, r), e.end.isEnd = !1, { start: t, end: r };
}, bot = (e) => {
  const t = ts(!1), r = ts(!0);
  return bn(t, e.start), bn(e.end, r), bn(e.end, e.start), e.end.isEnd = !1, { start: t, end: r };
}, bn = (e, t) => {
  e.epsilonTransitions.push(t);
}, vot = (e, t, r) => {
  e.transition[r] = t;
}, ts = (e) => ({
  isEnd: e,
  transition: {},
  epsilonTransitions: []
}), wot = "https://json-schema.org/keyword/itemPattern", OM = async (e, t) => {
  const r = [[]];
  let n = r[0];
  for await (const i of hc(e))
    if (pa(i) === "string") {
      const s = Ae(i);
      if (s === "*")
        n.push(mot(n.pop()));
      else if (s === "?")
        n.push(yot(n.pop()));
      else if (s === "+")
        n.push(bot(n.pop()));
      else if (s === "|")
        n = [], r.push(n);
      else
        throw Error(`Unsupported pattern syntax: ${s}`);
    } else {
      const s = pa(i) === "array" ? OM(i, t) : dot(await Ut.compile(i, t));
      n.push(await s);
    }
  return dM(e) === 0 ? pot() : r.map((i) => i.reduce(fot)).reduce(got);
}, L5 = (e) => (t, r, n, i, s) => {
  if ($e(r) !== "array")
    return !0;
  let o = [];
  t4(t.start, o, []);
  for (const a of Ku(r)) {
    const l = [];
    for (const c of o) {
      const h = xot(e, c.transition, a, n, i, s);
      h && t4(h, l, []);
    }
    o = l;
  }
  return !!o.find((a) => a.isEnd);
}, t4 = (e, t, r) => {
  if (e.epsilonTransitions.length)
    for (const n of e.epsilonTransitions)
      r.find((i) => i === n) || (r.push(n), t4(n, t, r));
  else
    t.push(e);
}, xot = (e, t, r, n, i, s) => {
  for (const o in t)
    if (e(o, r, n, i, s))
      return t[o];
}, Eot = L5(Ut.interpret), Aot = L5(Ut.collectEvaluatedProperties), Sot = L5(Ut.collectEvaluatedItems), _ot = { id: wot, compile: OM, interpret: Eot, collectEvalatedProperties: Aot, collectEvalatedItems: Sot }, kot = "https://json-schema.org/keyword/items", Cot = async (e, t, r) => {
  const n = Hr(e.document.dialectId, "https://json-schema.org/keyword/prefixItems"), i = await Rs(n, r);
  return [pa(i) === "array" ? dM(i) : 0, await Ut.compile(e, t)];
}, LM = ([e, t], r, n, i, s) => {
  if ($e(r) !== "array")
    return !0;
  let o = !0;
  for (const a of Unt(e, Ku(r)))
    Ut.interpret(t, a, n, i, s) || (o = !1);
  return o;
}, Iot = (e, t, r, n) => {
  if (!LM(e, t, r, n, !0))
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (let s = e[0]; s < K0(t); s++)
    i.add(s);
  return i;
}, Pot = { id: kot, compile: Cot, interpret: LM, collectEvaluatedItems: Iot }, Rot = "https://json-schema.org/keyword/maxContains", Tot = (e) => Ae(e), Oot = () => !0, Lot = { id: Rot, compile: Tot, interpret: Oot }, Mot = "https://json-schema.org/keyword/maxItems", Not = (e) => Ae(e), Dot = (e, t) => $e(t) !== "array" || K0(t) <= e, Bot = { id: Mot, compile: Not, interpret: Dot }, jot = "https://json-schema.org/keyword/maxLength", Fot = (e) => Ae(e), $ot = (e, t) => $e(t) !== "string" || [...wr(t)].length <= e, zot = { id: jot, compile: Fot, interpret: $ot }, Vot = "https://json-schema.org/keyword/maxProperties", Uot = (e) => Ae(e), Hot = (e, t) => $e(t) !== "object" || [...T5(t)].length <= e, Got = { id: Vot, compile: Uot, interpret: Hot }, Qot = "https://json-schema.org/keyword/maximum", Wot = (e) => Ae(e), qot = (e, t) => $e(t) !== "number" || wr(t) <= e, Yot = { id: Qot, compile: Wot, interpret: qot }, Kot = "https://json-schema.org/keyword/minContains", Zot = (e) => Ae(e), Jot = () => !0, Xot = { id: Kot, compile: Zot, interpret: Jot }, tat = "https://json-schema.org/keyword/minItems", eat = (e) => Ae(e), rat = (e, t) => $e(t) !== "array" || K0(t) >= e, nat = { id: tat, compile: eat, interpret: rat }, iat = "https://json-schema.org/keyword/minLength", sat = (e) => Ae(e), oat = (e, t) => $e(t) !== "string" || [...wr(t)].length >= e, aat = { id: iat, compile: sat, interpret: oat }, lat = "https://json-schema.org/keyword/minProperties", cat = (e) => Ae(e), uat = (e, t) => $e(t) !== "object" || [...T5(t)].length >= e, hat = { id: lat, compile: cat, interpret: uat }, pat = "https://json-schema.org/keyword/minimum", dat = (e) => Ae(e), fat = (e, t) => $e(t) !== "number" || wr(t) >= e, gat = { id: pat, compile: dat, interpret: fat }, mat = "https://json-schema.org/keyword/multipleOf", yat = (e) => Ae(e), bat = (e, t) => {
  if ($e(t) !== "number")
    return !0;
  const r = wr(t) % e;
  return v7(0, r) || v7(e, r);
}, v7 = (e, t) => Math.abs(e - t) < 11920929e-14, vat = { id: mat, compile: yat, interpret: bat }, wat = "https://json-schema.org/keyword/not", xat = (...e) => Ut.compile(...e), Eat = (...e) => !Ut.interpret(...e), Aat = { id: wat, compile: xat, interpret: Eat }, Sat = "https://json-schema.org/keyword/oneOf", _at = (e, t) => cn(
  hc(e),
  jn((r) => Ut.compile(r, t)),
  Vs
), kat = (e, t, r, n, i) => {
  let s = 0;
  for (const o of e)
    Ut.interpret(o, t, r, n, i) && s++;
  return s === 1;
}, Cat = (e, t, r, n) => {
  let i = !1;
  for (const s of e) {
    const o = Ut.collectEvaluatedProperties(s, t, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, Iat = (e, t, r, n) => {
  let i = !1;
  for (const s of e) {
    const o = Ut.collectEvaluatedItems(s, t, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, Pat = { id: Sat, compile: _at, interpret: kat, collectEvaluatedProperties: Cat, collectEvaluatedItems: Iat }, Rat = "https://json-schema.org/keyword/pattern", Tat = (e) => new RegExp(Ae(e), "u"), Oat = (e, t) => $e(t) !== "string" || e.test(wr(t)), Lat = { id: Rat, compile: Tat, interpret: Oat }, Mat = "https://json-schema.org/keyword/patternProperties", Nat = (e, t) => cn(
  Tu(e),
  jn(async ([r, n]) => [
    new RegExp(r, "u"),
    await Ut.compile(n, t)
  ]),
  Vs
), Dat = (e, t, r, n, i) => {
  if ($e(t) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of e)
    for (const [l, c] of pc(t)) {
      const h = wr(l);
      o.test(h) && !Ut.interpret(a, c, r, n, i) && (s = !1);
    }
  return s;
}, Bat = (e, t, r, n) => {
  if ($e(t) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of e)
    for (const [a, l] of pc(t)) {
      const c = wr(a);
      if (s.test(c)) {
        if (!Ut.interpret(o, l, r, n, !0))
          return !1;
        i.add(c);
      }
    }
  return i;
}, jat = { id: Mat, compile: Nat, interpret: Dat, collectEvaluatedProperties: Bat }, Fat = "https://json-schema.org/keyword/prefixItems", $at = (e, t) => cn(
  hc(e),
  jn((r) => Ut.compile(r, t)),
  Vs
), MM = (e, t, r, n, i) => {
  if ($e(t) !== "array")
    return !0;
  let s = !0, o = 0;
  const a = K0(t);
  for (const [l, c] of R5(e, Ku(t))) {
    if (o >= a)
      break;
    Ut.interpret(l, c, r, n, i) || (s = !1), o++;
  }
  return s;
}, zat = (e, t, r, n) => MM(e, t, r, n, !0) && new Set(e.map((i, s) => s)), Vat = { id: Fat, compile: $at, interpret: MM, collectEvaluatedItems: zat }, Uat = "https://json-schema.org/keyword/properties", Hat = (e, t) => cn(
  Tu(e),
  jn(async ([r, n]) => [r, await Ut.compile(n, t)]),
  J3
), Gat = (e, t, r, n, i) => {
  if ($e(t) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of pc(t)) {
    const l = wr(o);
    l in e && !Ut.interpret(e[l], a, r, n, i) && (s = !1);
  }
  return s;
}, Qat = (e, t, r, n) => {
  if ($e(t) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of pc(t)) {
    const a = wr(s);
    if (a in e) {
      if (!Ut.interpret(e[a], o, r, n, !0))
        return !1;
      i.add(a);
    }
  }
  return i;
}, Wat = { id: Uat, compile: Hat, interpret: Gat, collectEvaluatedProperties: Qat }, qat = "https://json-schema.org/keyword/propertyDependencies", Yat = (e, t) => cn(
  Tu(e),
  jn(async ([r, n]) => [r, await cn(
    Tu(n),
    jn(async ([i, s]) => [i, await Ut.compile(s, t)]),
    J3
  )]),
  J3
), Kat = (e, t, r, n, i) => {
  if ($e(t) !== "object")
    return !0;
  let s = !0;
  const o = wr(t);
  for (const [a, l] of Object.entries(e)) {
    const c = o[a];
    sp(a, t) && c in l && !Ut.interpret(l[c], t, r, n, i) && (s = !1);
  }
  return s;
}, Zat = (e, t, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s in e) {
    const o = wr(t)[s], a = e[s];
    if (sp(s, t) && o in a) {
      const l = Ut.collectEvaluatedProperties(a[o], t, r, n);
      if (!l)
        return !1;
      l.forEach(i.add, i);
    }
  }
  return i;
}, Jat = { id: qat, compile: Yat, interpret: Kat, collectEvaluatedProperties: Zat }, Xat = "https://json-schema.org/keyword/propertyNames", tlt = (e, t) => Ut.compile(e, t), elt = (e, t, r, n) => {
  if ($e(t) !== "object")
    return !0;
  let i = !0;
  for (const s of T5(t))
    Ut.interpret(e, s, r, n, !0) || (i = !1);
  return i;
}, rlt = { id: Xat, compile: tlt, interpret: elt }, NM = "https://json-schema.org/keyword/readOnly", nlt = (e) => Ae(e), ilt = (e, t, r, n, i, s) => (hs(t, NM, s, e), !0), slt = { id: NM, compile: nlt, interpret: ilt }, olt = "https://json-schema.org/keyword/ref", alt = (...e) => Ut.compile(...e), llt = (...e) => Ut.interpret(...e), clt = (...e) => Ut.collectEvaluatedProperties(...e), ult = (...e) => Ut.collectEvaluatedItems(...e), hlt = { id: olt, compile: alt, interpret: llt, collectEvaluatedProperties: clt, collectEvaluatedItems: ult }, plt = "https://json-schema.org/keyword/requireAllExcept", dlt = async (e, t, r) => {
  const n = await Ae(e), i = Hr(e.document.dialectId, "https://json-schema.org/keyword/properties"), s = await Rs(i, r), o = pa(s) === "object" ? K3(s) : [], a = new Set(o);
  return n.forEach((l) => o.remove(l)), [...a];
}, flt = (e, t) => $e(t) !== "object" || e.every((r) => Object.hasOwn(wr(t), r)), glt = { id: plt, compile: dlt, interpret: flt }, mlt = "https://json-schema.org/keyword/required", ylt = (e) => Ae(e), blt = (e, t) => $e(t) !== "object" || e.every((r) => Object.hasOwn(wr(t), r)), vlt = { id: mlt, compile: ylt, interpret: blt }, DM = "https://json-schema.org/keyword/title", wlt = (e) => Ae(e), xlt = (e, t, r, n, i, s) => (hs(t, DM, s, e), !0), Elt = { id: DM, compile: wlt, interpret: xlt }, Alt = "https://json-schema.org/keyword/then", Slt = async (e, t, r) => {
  const n = Hr(e.document.dialectId, "https://json-schema.org/keyword/if");
  if (pM(n, r)) {
    const i = await Rs(n, r);
    return [await Ut.compile(i, t), await Ut.compile(e, t)];
  } else
    return [];
}, _lt = ([e, t], r, n, i, s) => e === void 0 || !Ut.interpret(e, r, n, i, !0) || Ut.interpret(t, r, n, i, s), klt = ([e, t], r, n, i) => e === void 0 || !Ut.interpret(e, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ut.collectEvaluatedProperties(t, r, n, i), Clt = ([e, t], r, n, i) => e === void 0 || !Ut.interpret(e, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ut.collectEvaluatedItems(t, r, n, i), Ilt = { id: Alt, compile: Slt, interpret: _lt, collectEvaluatedProperties: klt, collectEvaluatedItems: Clt }, Plt = "https://json-schema.org/keyword/type", Rlt = (e) => Ae(e), Tlt = (e, t) => typeof e == "string" ? w7(t)(e) : e.some(w7(t)), w7 = (e) => (t) => t === "integer" ? $e(e) === "number" && Number.isInteger(wr(e)) : $e(e) === t, Olt = { id: Plt, compile: Rlt, interpret: Tlt }, Llt = "https://json-schema.org/keyword/unevaluatedItems", Mlt = async (e, t, r) => [ip(r), await Ut.compile(e, t)], Nlt = ([e, t], r, n, i, s) => {
  if ($e(r) !== "array")
    return !0;
  const o = Ut.collectEvaluatedItems(e, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of R5(Ku(r), mM(0)))
    !o.has(c) && !Ut.interpret(t, l, n, i, s) && (a = !1);
  return a;
}, Dlt = (e, t, r, n) => {
  const i = Ut.collectEvaluatedItems(e[0], t, r, n, !0);
  if (!i)
    return !1;
  const s = /* @__PURE__ */ new Set();
  for (let o = 0; o < K0(t); o++)
    i.has(o) || s.add(o);
  return s;
}, Blt = { id: Llt, compile: Mlt, interpret: Nlt, collectEvaluatedItems: Dlt }, jlt = "https://json-schema.org/keyword/unevaluatedProperties", Flt = async (e, t, r) => [ip(r), await Ut.compile(e, t)], $lt = ([e, t], r, n, i, s) => {
  if ($e(r) !== "object")
    return !0;
  const o = Ut.collectEvaluatedProperties(e, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of pc(r)) {
    const h = wr(l);
    !o.has(h) && !Ut.interpret(t, c, n, i, s) && (a = !1);
  }
  return a;
}, zlt = ([e, t], r, n, i) => {
  if ($e(r) !== "object")
    return !0;
  const s = Ut.collectEvaluatedProperties(e, r, n, i, !0);
  if (!s)
    return !1;
  for (const [o, a] of pc(r)) {
    const l = wr(o);
    if (!s.has(l)) {
      if (!Ut.interpret(t, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, Vlt = { id: jlt, compile: Flt, interpret: $lt, collectEvaluatedProperties: zlt }, Ult = "https://json-schema.org/keyword/uniqueItems", Hlt = (e) => Ae(e), Glt = (e, t) => {
  if ($e(t) !== "array" || e === !1)
    return !0;
  const r = wr(t).map(Z0);
  return new Set(r).size === r.length;
}, Qlt = { id: Ult, compile: Hlt, interpret: Glt }, BM = "https://json-schema.org/keyword/unknown", Wlt = (e) => [[...Q3(e.cursor)].pop(), Ae(e)], qlt = ([e, t], r, n, i, s, o) => {
  const a = `${BM}#${e}`;
  return hs(r, a, o, t), !0;
}, Ylt = { id: BM, compile: Wlt, interpret: qlt }, Klt = { id: "https://json-schema.org/keyword/vocabulary" }, jM = "https://json-schema.org/keyword/writeOnly", Zlt = (e) => Ae(e), Jlt = (e, t, r, n, i, s) => (hs(t, jM, s, e), !0), Xlt = { id: jM, compile: Zlt, interpret: Jlt };
oM("application/schema+json", znt);
ne(mit);
ne(Eit);
ne(Ait);
ne(Pit);
ne(Nit);
ne(Vit);
ne(Qit);
ne(Kit);
ne(Xit);
ne(rst);
ne(sst);
ne(lst);
ne(pst);
ne(mst);
ne(xst);
ne(Sst);
ne(Cst);
ne(Ist);
ne(Mst);
ne($st);
ne(Hst);
ne(Wst);
ne(Zst);
ne(eot);
ne(iot);
ne(sot);
ne(hot);
ne(_ot);
ne(Pot);
ne(Lot);
ne(Bot);
ne(zot);
ne(Got);
ne(Yot);
ne(Xot);
ne(nat);
ne(aat);
ne(hat);
ne(gat);
ne(vat);
ne(Aat);
ne(Pat);
ne(Lat);
ne(jat);
ne(Vat);
ne(Wat);
ne(Jat);
ne(rlt);
ne(slt);
ne(hlt);
ne(glt);
ne(vlt);
ne(Elt);
ne(Ilt);
ne(Olt);
ne(Blt);
ne(Vlt);
ne(Qlt);
ne(Ylt);
ne(Klt);
ne(Xlt);
const tct = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://json-schema.org/draft/2020-12/schema",
  $vocabulary: {
    "https://json-schema.org/draft/2020-12/vocab/core": !0,
    "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
    "https://json-schema.org/draft/2020-12/vocab/validation": !0,
    "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
    "https://json-schema.org/draft/2020-12/vocab/content": !0
  },
  $dynamicAnchor: "meta",
  title: "Core and Validation specifications meta-schema",
  allOf: [
    { $ref: "meta/core" },
    { $ref: "meta/applicator" },
    { $ref: "meta/unevaluated" },
    { $ref: "meta/validation" },
    { $ref: "meta/meta-data" },
    { $ref: "meta/format-annotation" },
    { $ref: "meta/content" }
  ],
  type: ["object", "boolean"],
  properties: {
    definitions: {
      $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    dependencies: {
      $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
      type: "object",
      additionalProperties: {
        anyOf: [
          { $dynamicRef: "#meta" },
          { $ref: "meta/validation#/$defs/stringArray" }
        ]
      }
    }
  }
}, ect = {
  $id: "https://json-schema.org/draft/2020-12/meta/core",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Core vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    $id: {
      type: "string",
      format: "uri-reference",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $anchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicRef: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicAnchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        type: "string",
        format: "uri"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    }
  }
}, rct = {
  $id: "https://json-schema.org/draft/2020-12/meta/applicator",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    prefixItems: { $ref: "#/$defs/schemaArray" },
    items: { $dynamicRef: "#meta" },
    contains: { $dynamicRef: "#meta" },
    additionalProperties: { $dynamicRef: "#meta" },
    properties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      propertyNames: { format: "regex" },
      default: {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      }
    },
    propertyNames: { $dynamicRef: "#meta" },
    if: { $dynamicRef: "#meta" },
    then: { $dynamicRef: "#meta" },
    else: { $dynamicRef: "#meta" },
    allOf: { $ref: "#/$defs/schemaArray" },
    anyOf: { $ref: "#/$defs/schemaArray" },
    oneOf: { $ref: "#/$defs/schemaArray" },
    not: { $dynamicRef: "#meta" }
  },
  $defs: {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: { $dynamicRef: "#meta" }
    }
  }
}, nct = {
  $id: "https://json-schema.org/draft/2020-12/meta/validation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Validation vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: { $ref: "#/$defs/nonNegativeInteger" },
    minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: { $ref: "#/$defs/nonNegativeInteger" },
    minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    uniqueItems: {
      type: "boolean",
      default: !1
    },
    maxContains: { $ref: "#/$defs/nonNegativeInteger" },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 1
    },
    maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
    minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    required: { $ref: "#/$defs/stringArray" },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    },
    const: !0,
    enum: {
      type: "array",
      items: !0
    },
    type: {
      anyOf: [
        { $ref: "#/$defs/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/$defs/simpleTypes" },
          minItems: 1,
          uniqueItems: !0
        }
      ]
    }
  },
  $defs: {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 0
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: []
    }
  }
}, ict = {
  $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Meta-data vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    default: !0,
    deprecated: {
      type: "boolean",
      default: !1
    },
    readOnly: {
      type: "boolean",
      default: !1
    },
    writeOnly: {
      type: "boolean",
      default: !1
    },
    examples: {
      type: "array",
      items: !0
    }
  }
}, sct = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for annotation results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, oct = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-assertion",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for assertion results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, act = {
  $id: "https://json-schema.org/draft/2020-12/meta/content",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Content vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    contentSchema: { $dynamicRef: "#meta" }
  }
}, lct = {
  $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Unevaluated applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    unevaluatedItems: { $dynamicRef: "#meta" },
    unevaluatedProperties: { $dynamicRef: "#meta" }
  }
}, cct = { id: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor" }, uct = "https://json-schema.org/keyword/draft-2020-12/dynamicRef", hct = async (e, t) => {
  const r = eM(Ae(e)), n = await R2(Ae(e), e);
  return await Ut.compile(n, t), [n.document.baseUri, r, ip(n)];
}, M5 = (e, [t, r, n], i, s, o, a) => r in s.metaData[t].dynamicAnchors ? (o = { ...s.metaData[t].dynamicAnchors, ...o }, e(o[r], i, s, o, a)) : e(n, i, s, o, a), pct = (...e) => M5(Ut.interpret, ...e), dct = (...e) => M5(Ut.collectEvaluatedProperties, ...e), fct = (...e) => M5(Ut.collectEvaluatedItems, ...e), gct = { id: uct, compile: hct, interpret: pct, collectEvaluatedProperties: dct, collectEvaluatedItems: fct };
ne(gct);
ne(cct);
uc("https://json-schema.org/draft/2020-12/vocab/core", {
  $anchor: "https://json-schema.org/keyword/anchor",
  $comment: "https://json-schema.org/keyword/comment",
  $defs: "https://json-schema.org/keyword/definitions",
  $dynamicAnchor: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor",
  $dynamicRef: "https://json-schema.org/keyword/draft-2020-12/dynamicRef",
  $id: "https://json-schema.org/keyword/id",
  $ref: "https://json-schema.org/keyword/ref",
  $vocabulary: "https://json-schema.org/keyword/vocabulary"
});
uc("https://json-schema.org/draft/2020-12/vocab/applicator", {
  additionalProperties: "https://json-schema.org/keyword/additionalProperties",
  allOf: "https://json-schema.org/keyword/allOf",
  anyOf: "https://json-schema.org/keyword/anyOf",
  contains: "https://json-schema.org/keyword/contains",
  dependentSchemas: "https://json-schema.org/keyword/dependentSchemas",
  if: "https://json-schema.org/keyword/if",
  then: "https://json-schema.org/keyword/then",
  else: "https://json-schema.org/keyword/else",
  items: "https://json-schema.org/keyword/items",
  not: "https://json-schema.org/keyword/not",
  oneOf: "https://json-schema.org/keyword/oneOf",
  patternProperties: "https://json-schema.org/keyword/patternProperties",
  prefixItems: "https://json-schema.org/keyword/prefixItems",
  properties: "https://json-schema.org/keyword/properties",
  propertyNames: "https://json-schema.org/keyword/propertyNames"
});
uc("https://json-schema.org/draft/2020-12/vocab/validation", {
  const: "https://json-schema.org/keyword/const",
  dependentRequired: "https://json-schema.org/keyword/dependentRequired",
  enum: "https://json-schema.org/keyword/enum",
  exclusiveMaximum: "https://json-schema.org/keyword/exclusiveMaximum",
  exclusiveMinimum: "https://json-schema.org/keyword/exclusiveMinimum",
  maxContains: "https://json-schema.org/keyword/maxContains",
  maxItems: "https://json-schema.org/keyword/maxItems",
  maxLength: "https://json-schema.org/keyword/maxLength",
  maxProperties: "https://json-schema.org/keyword/maxProperties",
  maximum: "https://json-schema.org/keyword/maximum",
  minContains: "https://json-schema.org/keyword/minContains",
  minItems: "https://json-schema.org/keyword/minItems",
  minLength: "https://json-schema.org/keyword/minLength",
  minProperties: "https://json-schema.org/keyword/minProperties",
  minimum: "https://json-schema.org/keyword/minimum",
  multipleOf: "https://json-schema.org/keyword/multipleOf",
  pattern: "https://json-schema.org/keyword/pattern",
  required: "https://json-schema.org/keyword/required",
  type: "https://json-schema.org/keyword/type",
  uniqueItems: "https://json-schema.org/keyword/uniqueItems"
});
uc("https://json-schema.org/draft/2020-12/vocab/meta-data", {
  default: "https://json-schema.org/keyword/default",
  deprecated: "https://json-schema.org/keyword/deprecated",
  description: "https://json-schema.org/keyword/description",
  examples: "https://json-schema.org/keyword/examples",
  readOnly: "https://json-schema.org/keyword/readOnly",
  title: "https://json-schema.org/keyword/title",
  writeOnly: "https://json-schema.org/keyword/writeOnly"
});
uc("https://json-schema.org/draft/2020-12/vocab/format-annotation", {
  format: "https://json-schema.org/keyword/format"
});
uc("https://json-schema.org/draft/2020-12/vocab/format-assertion", {
  format: "https://json-schema.org/keyword/format-assertion"
});
uc("https://json-schema.org/draft/2020-12/vocab/content", {
  contentEncoding: "https://json-schema.org/keyword/contentEncoding",
  contentMediaType: "https://json-schema.org/keyword/contentMediaType",
  contentSchema: "https://json-schema.org/keyword/contentSchema"
});
uc("https://json-schema.org/draft/2020-12/vocab/unevaluated", {
  unevaluatedItems: "https://json-schema.org/keyword/unevaluatedItems",
  unevaluatedProperties: "https://json-schema.org/keyword/unevaluatedProperties"
});
nM("https://json-schema.org/draft/2020-12/schema", {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, !0);
Ca(tct);
Ca(ect);
Ca(rct);
Ca(nct);
Ca(ict);
Ca(sct);
Ca(oct);
Ca(act);
Ca(lct);
function Kg(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var x7 = { exports: {} };
/*! jsonpath 1.1.1 */
var E7;
function mct() {
  return E7 || (E7 = 1, function(e, t) {
    (function(r) {
      e.exports = r();
    })(function() {
      return function r(n, i, s) {
        function o(c, h) {
          if (!i[c]) {
            if (!n[c]) {
              var u = typeof Kg == "function" && Kg;
              if (!h && u) return u(c, !0);
              if (a) return a(c, !0);
              var p = new Error("Cannot find module '" + c + "'");
              throw p.code = "MODULE_NOT_FOUND", p;
            }
            var y = i[c] = { exports: {} };
            n[c][0].call(y.exports, function(g) {
              var b = n[c][1][g];
              return o(b || g);
            }, y, y.exports, r, n, i, s);
          }
          return i[c].exports;
        }
        for (var a = typeof Kg == "function" && Kg, l = 0; l < s.length; l++) o(s[l]);
        return o;
      }({ "./aesprim": [function(r, n, i) {
        (function(s, o) {
          o(typeof i < "u" ? i : s.esprima = {});
        })(this, function(s) {
          var o, a, l, c, h, u, p, y, g, b, f, E, A, x, m, w, _, S;
          o = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
          }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
            "(",
            "{",
            "[",
            "in",
            "typeof",
            "instanceof",
            "new",
            "return",
            "case",
            "delete",
            "throw",
            "void",
            // assignment operators
            "=",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "<<=",
            ">>=",
            ">>>=",
            "&=",
            "|=",
            "^=",
            ",",
            // binary/unary operators
            "+",
            "-",
            "*",
            "/",
            "%",
            "++",
            "--",
            "<<",
            ">>",
            ">>>",
            "&",
            "|",
            "^",
            "!",
            "~",
            "&&",
            "||",
            "?",
            ":",
            "===",
            "==",
            ">=",
            "<=",
            "<",
            ">",
            "!=",
            "!=="
          ], c = {
            AssignmentExpression: "AssignmentExpression",
            ArrayExpression: "ArrayExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            Program: "Program",
            Property: "Property",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SwitchStatement: "SwitchStatement",
            SwitchCase: "SwitchCase",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement"
          }, h = {
            Data: 1,
            Get: 2,
            Set: 4
          }, u = {
            UnexpectedToken: "Unexpected token %0",
            UnexpectedNumber: "Unexpected number",
            UnexpectedString: "Unexpected string",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedEOS: "Unexpected end of input",
            NewlineAfterThrow: "Illegal newline after throw",
            InvalidRegExp: "Invalid regular expression",
            UnterminatedRegExp: "Invalid regular expression: missing /",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NoCatchOrFinally: "Missing catch or finally after try",
            UnknownLabel: "Undefined label '%0'",
            Redeclaration: "%0 '%1' has already been declared",
            IllegalContinue: "Illegal continue statement",
            IllegalBreak: "Illegal break statement",
            IllegalReturn: "Illegal return statement",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
            AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
            AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode"
          }, p = {
            NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
            NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
          };
          function R(d, v) {
            if (!d)
              throw new Error("ASSERT: " + v);
          }
          function O(d) {
            return d >= 48 && d <= 57;
          }
          function $(d) {
            return "0123456789abcdefABCDEF".indexOf(d) >= 0;
          }
          function z(d) {
            return "01234567".indexOf(d) >= 0;
          }
          function F(d) {
            return d === 32 || d === 9 || d === 11 || d === 12 || d === 160 || d >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(d) >= 0;
          }
          function Y(d) {
            return d === 10 || d === 13 || d === 8232 || d === 8233;
          }
          function rt(d) {
            return d == 64 || d === 36 || d === 95 || // $ (dollar) and _ (underscore)
            d >= 65 && d <= 90 || // A..Z
            d >= 97 && d <= 122 || // a..z
            d === 92 || // \ (backslash)
            d >= 128 && p.NonAsciiIdentifierStart.test(String.fromCharCode(d));
          }
          function at(d) {
            return d === 36 || d === 95 || // $ (dollar) and _ (underscore)
            d >= 65 && d <= 90 || // A..Z
            d >= 97 && d <= 122 || // a..z
            d >= 48 && d <= 57 || // 0..9
            d === 92 || // \ (backslash)
            d >= 128 && p.NonAsciiIdentifierPart.test(String.fromCharCode(d));
          }
          function pt(d) {
            switch (d) {
              case "class":
              case "enum":
              case "export":
              case "extends":
              case "import":
              case "super":
                return !0;
              default:
                return !1;
            }
          }
          function vt(d) {
            switch (d) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return !0;
              default:
                return !1;
            }
          }
          function _t(d) {
            return d === "eval" || d === "arguments";
          }
          function Ct(d) {
            if (b && vt(d))
              return !0;
            switch (d.length) {
              case 2:
                return d === "if" || d === "in" || d === "do";
              case 3:
                return d === "var" || d === "for" || d === "new" || d === "try" || d === "let";
              case 4:
                return d === "this" || d === "else" || d === "case" || d === "void" || d === "with" || d === "enum";
              case 5:
                return d === "while" || d === "break" || d === "catch" || d === "throw" || d === "const" || d === "yield" || d === "class" || d === "super";
              case 6:
                return d === "return" || d === "typeof" || d === "delete" || d === "switch" || d === "export" || d === "import";
              case 7:
                return d === "default" || d === "finally" || d === "extends";
              case 8:
                return d === "function" || d === "continue" || d === "debugger";
              case 10:
                return d === "instanceof";
              default:
                return !1;
            }
          }
          function It(d, v, I, j, Z) {
            var ht;
            R(typeof I == "number", "Comment must have valid position"), !(_.lastCommentStart >= I) && (_.lastCommentStart = I, ht = {
              type: d,
              value: v
            }, S.range && (ht.range = [I, j]), S.loc && (ht.loc = Z), S.comments.push(ht), S.attachComment && (S.leadingComments.push(ht), S.trailingComments.push(ht)));
          }
          function jt(d) {
            var v, I, j, Z;
            for (v = f - d, I = {
              start: {
                line: E,
                column: f - A - d
              }
            }; f < x; )
              if (j = g.charCodeAt(f), ++f, Y(j)) {
                S.comments && (Z = g.slice(v + d, f - 1), I.end = {
                  line: E,
                  column: f - A - 1
                }, It("Line", Z, v, f - 1, I)), j === 13 && g.charCodeAt(f) === 10 && ++f, ++E, A = f;
                return;
              }
            S.comments && (Z = g.slice(v + d, f), I.end = {
              line: E,
              column: f - A
            }, It("Line", Z, v, f, I));
          }
          function lt() {
            var d, v, I, j;
            for (S.comments && (d = f - 2, v = {
              start: {
                line: E,
                column: f - A - 2
              }
            }); f < x; )
              if (I = g.charCodeAt(f), Y(I))
                I === 13 && g.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && bt({}, u.UnexpectedToken, "ILLEGAL");
              else if (I === 42) {
                if (g.charCodeAt(f + 1) === 47) {
                  ++f, ++f, S.comments && (j = g.slice(d + 2, f - 2), v.end = {
                    line: E,
                    column: f - A
                  }, It("Block", j, d, f, v));
                  return;
                }
                ++f;
              } else
                ++f;
            bt({}, u.UnexpectedToken, "ILLEGAL");
          }
          function L() {
            var d, v;
            for (v = f === 0; f < x; )
              if (d = g.charCodeAt(f), F(d))
                ++f;
              else if (Y(d))
                ++f, d === 13 && g.charCodeAt(f) === 10 && ++f, ++E, A = f, v = !0;
              else if (d === 47)
                if (d = g.charCodeAt(f + 1), d === 47)
                  ++f, ++f, jt(2), v = !0;
                else if (d === 42)
                  ++f, ++f, lt();
                else
                  break;
              else if (v && d === 45)
                if (g.charCodeAt(f + 1) === 45 && g.charCodeAt(f + 2) === 62)
                  f += 3, jt(3);
                else
                  break;
              else if (d === 60)
                if (g.slice(f + 1, f + 4) === "!--")
                  ++f, ++f, ++f, ++f, jt(4);
                else
                  break;
              else
                break;
          }
          function D(d) {
            var v, I, j, Z = 0;
            for (I = d === "u" ? 4 : 2, v = 0; v < I; ++v)
              if (f < x && $(g[f]))
                j = g[f++], Z = Z * 16 + "0123456789abcdef".indexOf(j.toLowerCase());
              else
                return "";
            return String.fromCharCode(Z);
          }
          function tt() {
            var d, v;
            for (d = g.charCodeAt(f++), v = String.fromCharCode(d), d === 92 && (g.charCodeAt(f) !== 117 && bt({}, u.UnexpectedToken, "ILLEGAL"), ++f, d = D("u"), (!d || d === "\\" || !rt(d.charCodeAt(0))) && bt({}, u.UnexpectedToken, "ILLEGAL"), v = d); f < x && (d = g.charCodeAt(f), !!at(d)); )
              ++f, v += String.fromCharCode(d), d === 92 && (v = v.substr(0, v.length - 1), g.charCodeAt(f) !== 117 && bt({}, u.UnexpectedToken, "ILLEGAL"), ++f, d = D("u"), (!d || d === "\\" || !at(d.charCodeAt(0))) && bt({}, u.UnexpectedToken, "ILLEGAL"), v += d);
            return v;
          }
          function et() {
            var d, v;
            for (d = f++; f < x; ) {
              if (v = g.charCodeAt(f), v === 92)
                return f = d, tt();
              if (at(v))
                ++f;
              else
                break;
            }
            return g.slice(d, f);
          }
          function st() {
            var d, v, I;
            return d = f, v = g.charCodeAt(f) === 92 ? tt() : et(), v.length === 1 ? I = o.Identifier : Ct(v) ? I = o.Keyword : v === "null" ? I = o.NullLiteral : v === "true" || v === "false" ? I = o.BooleanLiteral : I = o.Identifier, {
              type: I,
              value: v,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          }
          function X() {
            var d = f, v = g.charCodeAt(f), I, j = g[f], Z, ht, Ot;
            switch (v) {
              case 46:
              case 40:
              case 41:
              case 59:
              case 44:
              case 123:
              case 125:
              case 91:
              case 93:
              case 58:
              case 63:
              case 126:
                return ++f, S.tokenize && (v === 40 ? S.openParenToken = S.tokens.length : v === 123 && (S.openCurlyToken = S.tokens.length)), {
                  type: o.Punctuator,
                  value: String.fromCharCode(v),
                  lineNumber: E,
                  lineStart: A,
                  start: d,
                  end: f
                };
              default:
                if (I = g.charCodeAt(f + 1), I === 61)
                  switch (v) {
                    case 43:
                    case 45:
                    case 47:
                    case 60:
                    case 62:
                    case 94:
                    case 124:
                    case 37:
                    case 38:
                    case 42:
                      return f += 2, {
                        type: o.Punctuator,
                        value: String.fromCharCode(v) + String.fromCharCode(I),
                        lineNumber: E,
                        lineStart: A,
                        start: d,
                        end: f
                      };
                    case 33:
                    case 61:
                      return f += 2, g.charCodeAt(f) === 61 && ++f, {
                        type: o.Punctuator,
                        value: g.slice(d, f),
                        lineNumber: E,
                        lineStart: A,
                        start: d,
                        end: f
                      };
                  }
            }
            if (Ot = g.substr(f, 4), Ot === ">>>=")
              return f += 4, {
                type: o.Punctuator,
                value: Ot,
                lineNumber: E,
                lineStart: A,
                start: d,
                end: f
              };
            if (ht = Ot.substr(0, 3), ht === ">>>" || ht === "<<=" || ht === ">>=")
              return f += 3, {
                type: o.Punctuator,
                value: ht,
                lineNumber: E,
                lineStart: A,
                start: d,
                end: f
              };
            if (Z = ht.substr(0, 2), j === Z[1] && "+-<>&|".indexOf(j) >= 0 || Z === "=>")
              return f += 2, {
                type: o.Punctuator,
                value: Z,
                lineNumber: E,
                lineStart: A,
                start: d,
                end: f
              };
            if ("<>=!+-*%&|^/".indexOf(j) >= 0)
              return ++f, {
                type: o.Punctuator,
                value: j,
                lineNumber: E,
                lineStart: A,
                start: d,
                end: f
              };
            bt({}, u.UnexpectedToken, "ILLEGAL");
          }
          function ot(d) {
            for (var v = ""; f < x && $(g[f]); )
              v += g[f++];
            return v.length === 0 && bt({}, u.UnexpectedToken, "ILLEGAL"), rt(g.charCodeAt(f)) && bt({}, u.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt("0x" + v, 16),
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          }
          function mt(d) {
            for (var v = "0" + g[f++]; f < x && z(g[f]); )
              v += g[f++];
            return (rt(g.charCodeAt(f)) || O(g.charCodeAt(f))) && bt({}, u.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt(v, 8),
              octal: !0,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          }
          function U() {
            var d, v, I;
            if (I = g[f], R(
              O(I.charCodeAt(0)) || I === ".",
              "Numeric literal must start with a decimal digit or a decimal point"
            ), v = f, d = "", I !== ".") {
              if (d = g[f++], I = g[f], d === "0") {
                if (I === "x" || I === "X")
                  return ++f, ot(v);
                if (z(I))
                  return mt(v);
                I && O(I.charCodeAt(0)) && bt({}, u.UnexpectedToken, "ILLEGAL");
              }
              for (; O(g.charCodeAt(f)); )
                d += g[f++];
              I = g[f];
            }
            if (I === ".") {
              for (d += g[f++]; O(g.charCodeAt(f)); )
                d += g[f++];
              I = g[f];
            }
            if (I === "e" || I === "E")
              if (d += g[f++], I = g[f], (I === "+" || I === "-") && (d += g[f++]), O(g.charCodeAt(f)))
                for (; O(g.charCodeAt(f)); )
                  d += g[f++];
              else
                bt({}, u.UnexpectedToken, "ILLEGAL");
            return rt(g.charCodeAt(f)) && bt({}, u.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseFloat(d),
              lineNumber: E,
              lineStart: A,
              start: v,
              end: f
            };
          }
          function J() {
            var d = "", v, I, j, Z, ht, Ot, Gt = !1, fe, ce;
            for (fe = E, ce = A, v = g[f], R(
              v === "'" || v === '"',
              "String literal must starts with a quote"
            ), I = f, ++f; f < x; )
              if (j = g[f++], j === v) {
                v = "";
                break;
              } else if (j === "\\")
                if (j = g[f++], !j || !Y(j.charCodeAt(0)))
                  switch (j) {
                    case "u":
                    case "x":
                      Ot = f, ht = D(j), ht ? d += ht : (f = Ot, d += j);
                      break;
                    case "n":
                      d += `
`;
                      break;
                    case "r":
                      d += "\r";
                      break;
                    case "t":
                      d += "	";
                      break;
                    case "b":
                      d += "\b";
                      break;
                    case "f":
                      d += "\f";
                      break;
                    case "v":
                      d += "\v";
                      break;
                    default:
                      z(j) ? (Z = "01234567".indexOf(j), Z !== 0 && (Gt = !0), f < x && z(g[f]) && (Gt = !0, Z = Z * 8 + "01234567".indexOf(g[f++]), "0123".indexOf(j) >= 0 && f < x && z(g[f]) && (Z = Z * 8 + "01234567".indexOf(g[f++]))), d += String.fromCharCode(Z)) : d += j;
                      break;
                  }
                else
                  ++E, j === "\r" && g[f] === `
` && ++f, A = f;
              else {
                if (Y(j.charCodeAt(0)))
                  break;
                d += j;
              }
            return v !== "" && bt({}, u.UnexpectedToken, "ILLEGAL"), {
              type: o.StringLiteral,
              value: d,
              octal: Gt,
              startLineNumber: fe,
              startLineStart: ce,
              lineNumber: E,
              lineStart: A,
              start: I,
              end: f
            };
          }
          function St(d, v) {
            var I;
            try {
              I = new RegExp(d, v);
            } catch {
              bt({}, u.InvalidRegExp);
            }
            return I;
          }
          function Rt() {
            var d, v, I, j, Z;
            for (d = g[f], R(d === "/", "Regular expression literal must start with a slash"), v = g[f++], I = !1, j = !1; f < x; )
              if (d = g[f++], v += d, d === "\\")
                d = g[f++], Y(d.charCodeAt(0)) && bt({}, u.UnterminatedRegExp), v += d;
              else if (Y(d.charCodeAt(0)))
                bt({}, u.UnterminatedRegExp);
              else if (I)
                d === "]" && (I = !1);
              else if (d === "/") {
                j = !0;
                break;
              } else d === "[" && (I = !0);
            return j || bt({}, u.UnterminatedRegExp), Z = v.substr(1, v.length - 2), {
              value: Z,
              literal: v
            };
          }
          function zt() {
            var d, v, I, j;
            for (v = "", I = ""; f < x && (d = g[f], !!at(d.charCodeAt(0))); )
              if (++f, d === "\\" && f < x)
                if (d = g[f], d === "u") {
                  if (++f, j = f, d = D("u"), d)
                    for (I += d, v += "\\u"; j < f; ++j)
                      v += g[j];
                  else
                    f = j, I += "u", v += "\\u";
                  xt({}, u.UnexpectedToken, "ILLEGAL");
                } else
                  v += "\\", xt({}, u.UnexpectedToken, "ILLEGAL");
              else
                I += d, v += d;
            return {
              value: I,
              literal: v
            };
          }
          function Tt() {
            var d, v, I, j;
            return w = null, L(), d = f, v = Rt(), I = zt(), j = St(v.value, I.value), S.tokenize ? {
              type: o.RegularExpression,
              value: j,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            } : {
              literal: v.literal + I.literal,
              value: j,
              start: d,
              end: f
            };
          }
          function Yt() {
            var d, v, I, j;
            return L(), d = f, v = {
              start: {
                line: E,
                column: f - A
              }
            }, I = Tt(), v.end = {
              line: E,
              column: f - A
            }, S.tokenize || (S.tokens.length > 0 && (j = S.tokens[S.tokens.length - 1], j.range[0] === d && j.type === "Punctuator" && (j.value === "/" || j.value === "/=") && S.tokens.pop()), S.tokens.push({
              type: "RegularExpression",
              value: I.literal,
              range: [d, f],
              loc: v
            })), I;
          }
          function Zt(d) {
            return d.type === o.Identifier || d.type === o.Keyword || d.type === o.BooleanLiteral || d.type === o.NullLiteral;
          }
          function kt() {
            var d, v;
            if (d = S.tokens[S.tokens.length - 1], !d)
              return Yt();
            if (d.type === "Punctuator") {
              if (d.value === "]")
                return X();
              if (d.value === ")")
                return v = S.tokens[S.openParenToken - 1], v && v.type === "Keyword" && (v.value === "if" || v.value === "while" || v.value === "for" || v.value === "with") ? Yt() : X();
              if (d.value === "}") {
                if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                  if (v = S.tokens[S.openCurlyToken - 4], !v)
                    return X();
                } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                  if (v = S.tokens[S.openCurlyToken - 5], !v)
                    return Yt();
                } else
                  return X();
                return l.indexOf(v.value) >= 0 ? X() : Yt();
              }
              return Yt();
            }
            return d.type === "Keyword" ? Yt() : X();
          }
          function _e() {
            var d;
            return L(), f >= x ? {
              type: o.EOF,
              lineNumber: E,
              lineStart: A,
              start: f,
              end: f
            } : (d = g.charCodeAt(f), rt(d) ? st() : d === 40 || d === 41 || d === 59 ? X() : d === 39 || d === 34 ? J() : d === 46 ? O(g.charCodeAt(f + 1)) ? U() : X() : O(d) ? U() : S.tokenize && d === 47 ? kt() : X());
          }
          function Ye() {
            var d, v, I;
            return L(), d = {
              start: {
                line: E,
                column: f - A
              }
            }, v = _e(), d.end = {
              line: E,
              column: f - A
            }, v.type !== o.EOF && (I = g.slice(v.start, v.end), S.tokens.push({
              type: a[v.type],
              value: I,
              range: [v.start, v.end],
              loc: d
            })), v;
          }
          function wt() {
            var d;
            return d = w, f = d.end, E = d.lineNumber, A = d.lineStart, w = typeof S.tokens < "u" ? Ye() : _e(), f = d.end, E = d.lineNumber, A = d.lineStart, d;
          }
          function le() {
            var d, v, I;
            d = f, v = E, I = A, w = typeof S.tokens < "u" ? Ye() : _e(), f = d, E = v, A = I;
          }
          function te(d, v) {
            this.line = d, this.column = v;
          }
          function Se(d, v, I, j) {
            this.start = new te(d, v), this.end = new te(I, j);
          }
          y = {
            name: "SyntaxTree",
            processComment: function(d) {
              var v, I;
              if (!(d.type === c.Program && d.body.length > 0)) {
                for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= d.range[1] ? (I = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= d.range[1] && (I = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= d.range[0]; )
                  v = S.bottomRightStack.pop();
                v ? v.leadingComments && v.leadingComments[v.leadingComments.length - 1].range[1] <= d.range[0] && (d.leadingComments = v.leadingComments, delete v.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= d.range[0] && (d.leadingComments = S.leadingComments, S.leadingComments = []), I && (d.trailingComments = I), S.bottomRightStack.push(d);
              }
            },
            markEnd: function(d, v) {
              return S.range && (d.range = [v.start, f]), S.loc && (d.loc = new Se(
                v.startLineNumber === void 0 ? v.lineNumber : v.startLineNumber,
                v.start - (v.startLineStart === void 0 ? v.lineStart : v.startLineStart),
                E,
                f - A
              ), this.postProcess(d)), S.attachComment && this.processComment(d), d;
            },
            postProcess: function(d) {
              return S.source && (d.loc.source = S.source), d;
            },
            createArrayExpression: function(d) {
              return {
                type: c.ArrayExpression,
                elements: d
              };
            },
            createAssignmentExpression: function(d, v, I) {
              return {
                type: c.AssignmentExpression,
                operator: d,
                left: v,
                right: I
              };
            },
            createBinaryExpression: function(d, v, I) {
              var j = d === "||" || d === "&&" ? c.LogicalExpression : c.BinaryExpression;
              return {
                type: j,
                operator: d,
                left: v,
                right: I
              };
            },
            createBlockStatement: function(d) {
              return {
                type: c.BlockStatement,
                body: d
              };
            },
            createBreakStatement: function(d) {
              return {
                type: c.BreakStatement,
                label: d
              };
            },
            createCallExpression: function(d, v) {
              return {
                type: c.CallExpression,
                callee: d,
                arguments: v
              };
            },
            createCatchClause: function(d, v) {
              return {
                type: c.CatchClause,
                param: d,
                body: v
              };
            },
            createConditionalExpression: function(d, v, I) {
              return {
                type: c.ConditionalExpression,
                test: d,
                consequent: v,
                alternate: I
              };
            },
            createContinueStatement: function(d) {
              return {
                type: c.ContinueStatement,
                label: d
              };
            },
            createDebuggerStatement: function() {
              return {
                type: c.DebuggerStatement
              };
            },
            createDoWhileStatement: function(d, v) {
              return {
                type: c.DoWhileStatement,
                body: d,
                test: v
              };
            },
            createEmptyStatement: function() {
              return {
                type: c.EmptyStatement
              };
            },
            createExpressionStatement: function(d) {
              return {
                type: c.ExpressionStatement,
                expression: d
              };
            },
            createForStatement: function(d, v, I, j) {
              return {
                type: c.ForStatement,
                init: d,
                test: v,
                update: I,
                body: j
              };
            },
            createForInStatement: function(d, v, I) {
              return {
                type: c.ForInStatement,
                left: d,
                right: v,
                body: I,
                each: !1
              };
            },
            createFunctionDeclaration: function(d, v, I, j) {
              return {
                type: c.FunctionDeclaration,
                id: d,
                params: v,
                defaults: I,
                body: j,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createFunctionExpression: function(d, v, I, j) {
              return {
                type: c.FunctionExpression,
                id: d,
                params: v,
                defaults: I,
                body: j,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createIdentifier: function(d) {
              return {
                type: c.Identifier,
                name: d
              };
            },
            createIfStatement: function(d, v, I) {
              return {
                type: c.IfStatement,
                test: d,
                consequent: v,
                alternate: I
              };
            },
            createLabeledStatement: function(d, v) {
              return {
                type: c.LabeledStatement,
                label: d,
                body: v
              };
            },
            createLiteral: function(d) {
              return {
                type: c.Literal,
                value: d.value,
                raw: g.slice(d.start, d.end)
              };
            },
            createMemberExpression: function(d, v, I) {
              return {
                type: c.MemberExpression,
                computed: d === "[",
                object: v,
                property: I
              };
            },
            createNewExpression: function(d, v) {
              return {
                type: c.NewExpression,
                callee: d,
                arguments: v
              };
            },
            createObjectExpression: function(d) {
              return {
                type: c.ObjectExpression,
                properties: d
              };
            },
            createPostfixExpression: function(d, v) {
              return {
                type: c.UpdateExpression,
                operator: d,
                argument: v,
                prefix: !1
              };
            },
            createProgram: function(d) {
              return {
                type: c.Program,
                body: d
              };
            },
            createProperty: function(d, v, I) {
              return {
                type: c.Property,
                key: v,
                value: I,
                kind: d
              };
            },
            createReturnStatement: function(d) {
              return {
                type: c.ReturnStatement,
                argument: d
              };
            },
            createSequenceExpression: function(d) {
              return {
                type: c.SequenceExpression,
                expressions: d
              };
            },
            createSwitchCase: function(d, v) {
              return {
                type: c.SwitchCase,
                test: d,
                consequent: v
              };
            },
            createSwitchStatement: function(d, v) {
              return {
                type: c.SwitchStatement,
                discriminant: d,
                cases: v
              };
            },
            createThisExpression: function() {
              return {
                type: c.ThisExpression
              };
            },
            createThrowStatement: function(d) {
              return {
                type: c.ThrowStatement,
                argument: d
              };
            },
            createTryStatement: function(d, v, I, j) {
              return {
                type: c.TryStatement,
                block: d,
                guardedHandlers: v,
                handlers: I,
                finalizer: j
              };
            },
            createUnaryExpression: function(d, v) {
              return d === "++" || d === "--" ? {
                type: c.UpdateExpression,
                operator: d,
                argument: v,
                prefix: !0
              } : {
                type: c.UnaryExpression,
                operator: d,
                argument: v,
                prefix: !0
              };
            },
            createVariableDeclaration: function(d, v) {
              return {
                type: c.VariableDeclaration,
                declarations: d,
                kind: v
              };
            },
            createVariableDeclarator: function(d, v) {
              return {
                type: c.VariableDeclarator,
                id: d,
                init: v
              };
            },
            createWhileStatement: function(d, v) {
              return {
                type: c.WhileStatement,
                test: d,
                body: v
              };
            },
            createWithStatement: function(d, v) {
              return {
                type: c.WithStatement,
                object: d,
                body: v
              };
            }
          };
          function Kt() {
            var d, v, I, j;
            return d = f, v = E, I = A, L(), j = E !== v, f = d, E = v, A = I, j;
          }
          function bt(d, v) {
            var I, j = Array.prototype.slice.call(arguments, 2), Z = v.replace(
              /%(\d)/g,
              function(ht, Ot) {
                return R(Ot < j.length, "Message reference must be in range"), j[Ot];
              }
            );
            throw typeof d.lineNumber == "number" ? (I = new Error("Line " + d.lineNumber + ": " + Z), I.index = d.start, I.lineNumber = d.lineNumber, I.column = d.start - A + 1) : (I = new Error("Line " + E + ": " + Z), I.index = f, I.lineNumber = E, I.column = f - A + 1), I.description = Z, I;
          }
          function xt() {
            try {
              bt.apply(null, arguments);
            } catch (d) {
              if (S.errors)
                S.errors.push(d);
              else
                throw d;
            }
          }
          function Jt(d) {
            if (d.type === o.EOF && bt(d, u.UnexpectedEOS), d.type === o.NumericLiteral && bt(d, u.UnexpectedNumber), d.type === o.StringLiteral && bt(d, u.UnexpectedString), d.type === o.Identifier && bt(d, u.UnexpectedIdentifier), d.type === o.Keyword) {
              if (pt(d.value))
                bt(d, u.UnexpectedReserved);
              else if (b && vt(d.value)) {
                xt(d, u.StrictReservedWord);
                return;
              }
              bt(d, u.UnexpectedToken, d.value);
            }
            bt(d, u.UnexpectedToken, d.value);
          }
          function k(d) {
            var v = wt();
            (v.type !== o.Punctuator || v.value !== d) && Jt(v);
          }
          function M(d) {
            var v = wt();
            (v.type !== o.Keyword || v.value !== d) && Jt(v);
          }
          function B(d) {
            return w.type === o.Punctuator && w.value === d;
          }
          function it(d) {
            return w.type === o.Keyword && w.value === d;
          }
          function ct() {
            var d;
            return w.type !== o.Punctuator ? !1 : (d = w.value, d === "=" || d === "*=" || d === "/=" || d === "%=" || d === "+=" || d === "-=" || d === "<<=" || d === ">>=" || d === ">>>=" || d === "&=" || d === "^=" || d === "|=");
          }
          function Et() {
            var d;
            if (g.charCodeAt(f) === 59 || B(";")) {
              wt();
              return;
            }
            d = E, L(), E === d && w.type !== o.EOF && !B("}") && Jt(w);
          }
          function Mt(d) {
            return d.type === c.Identifier || d.type === c.MemberExpression;
          }
          function se() {
            var d = [], v;
            for (v = w, k("["); !B("]"); )
              B(",") ? (wt(), d.push(null)) : (d.push(q()), B("]") || k(","));
            return wt(), m.markEnd(m.createArrayExpression(d), v);
          }
          function de(d, v) {
            var I, j, Z;
            return I = b, Z = w, j = ds(), v && b && _t(d[0].name) && xt(v, u.StrictParamName), b = I, m.markEnd(m.createFunctionExpression(null, d, [], j), Z);
          }
          function ke() {
            var d, v;
            return v = w, d = wt(), d.type === o.StringLiteral || d.type === o.NumericLiteral ? (b && d.octal && xt(d, u.StrictOctalLiteral), m.markEnd(m.createLiteral(d), v)) : m.markEnd(m.createIdentifier(d.value), v);
          }
          function Xt() {
            var d, v, I, j, Z, ht;
            if (d = w, ht = w, d.type === o.Identifier)
              return I = ke(), d.value === "get" && !B(":") ? (v = ke(), k("("), k(")"), j = de([]), m.markEnd(m.createProperty("get", v, j), ht)) : d.value === "set" && !B(":") ? (v = ke(), k("("), d = w, d.type !== o.Identifier ? (k(")"), xt(d, u.UnexpectedToken, d.value), j = de([])) : (Z = [ut()], k(")"), j = de(Z, d)), m.markEnd(m.createProperty("set", v, j), ht)) : (k(":"), j = q(), m.markEnd(m.createProperty("init", I, j), ht));
            if (d.type === o.EOF || d.type === o.Punctuator)
              Jt(d);
            else
              return v = ke(), k(":"), j = q(), m.markEnd(m.createProperty("init", v, j), ht);
          }
          function ze() {
            var d = [], v, I, j, Z, ht = {}, Ot = String, Gt;
            for (Gt = w, k("{"); !B("}"); )
              v = Xt(), v.key.type === c.Identifier ? I = v.key.name : I = Ot(v.key.value), Z = v.kind === "init" ? h.Data : v.kind === "get" ? h.Get : h.Set, j = "$" + I, Object.prototype.hasOwnProperty.call(ht, j) ? (ht[j] === h.Data ? b && Z === h.Data ? xt({}, u.StrictDuplicateProperty) : Z !== h.Data && xt({}, u.AccessorDataProperty) : Z === h.Data ? xt({}, u.AccessorDataProperty) : ht[j] & Z && xt({}, u.AccessorGetSet), ht[j] |= Z) : ht[j] = Z, d.push(v), B("}") || k(",");
            return k("}"), m.markEnd(m.createObjectExpression(d), Gt);
          }
          function We() {
            var d;
            return k("("), d = W(), k(")"), d;
          }
          function pr() {
            var d, v, I, j;
            if (B("("))
              return We();
            if (B("["))
              return se();
            if (B("{"))
              return ze();
            if (d = w.type, j = w, d === o.Identifier)
              I = m.createIdentifier(wt().value);
            else if (d === o.StringLiteral || d === o.NumericLiteral)
              b && w.octal && xt(w, u.StrictOctalLiteral), I = m.createLiteral(wt());
            else if (d === o.Keyword) {
              if (it("function"))
                return kd();
              it("this") ? (wt(), I = m.createThisExpression()) : Jt(wt());
            } else d === o.BooleanLiteral ? (v = wt(), v.value = v.value === "true", I = m.createLiteral(v)) : d === o.NullLiteral ? (v = wt(), v.value = null, I = m.createLiteral(v)) : B("/") || B("/=") ? (typeof S.tokens < "u" ? I = m.createLiteral(Yt()) : I = m.createLiteral(Tt()), le()) : Jt(wt());
            return m.markEnd(I, j);
          }
          function Yr() {
            var d = [];
            if (k("("), !B(")"))
              for (; f < x && (d.push(q()), !B(")")); )
                k(",");
            return k(")"), d;
          }
          function ps() {
            var d, v;
            return v = w, d = wt(), Zt(d) || Jt(d), m.markEnd(m.createIdentifier(d.value), v);
          }
          function qe() {
            return k("."), ps();
          }
          function Vi() {
            var d;
            return k("["), d = W(), k("]"), d;
          }
          function T() {
            var d, v, I;
            return I = w, M("new"), d = H(), v = B("(") ? Yr() : [], m.markEnd(m.createNewExpression(d, v), I);
          }
          function V() {
            var d, v, I, j, Z;
            for (Z = w, d = _.allowIn, _.allowIn = !0, v = it("new") ? T() : pr(), _.allowIn = d; ; ) {
              if (B("."))
                j = qe(), v = m.createMemberExpression(".", v, j);
              else if (B("("))
                I = Yr(), v = m.createCallExpression(v, I);
              else if (B("["))
                j = Vi(), v = m.createMemberExpression("[", v, j);
              else
                break;
              m.markEnd(v, Z);
            }
            return v;
          }
          function H() {
            var d, v, I, j;
            for (j = w, d = _.allowIn, v = it("new") ? T() : pr(), _.allowIn = d; B(".") || B("["); )
              B("[") ? (I = Vi(), v = m.createMemberExpression("[", v, I)) : (I = qe(), v = m.createMemberExpression(".", v, I)), m.markEnd(v, j);
            return v;
          }
          function dt() {
            var d, v, I = w;
            return d = V(), w.type === o.Punctuator && (B("++") || B("--")) && !Kt() && (b && d.type === c.Identifier && _t(d.name) && xt({}, u.StrictLHSPostfix), Mt(d) || xt({}, u.InvalidLHSInAssignment), v = wt(), d = m.markEnd(m.createPostfixExpression(v.value, d), I)), d;
          }
          function ft() {
            var d, v, I;
            return w.type !== o.Punctuator && w.type !== o.Keyword ? v = dt() : B("++") || B("--") ? (I = w, d = wt(), v = ft(), b && v.type === c.Identifier && _t(v.name) && xt({}, u.StrictLHSPrefix), Mt(v) || xt({}, u.InvalidLHSInAssignment), v = m.createUnaryExpression(d.value, v), v = m.markEnd(v, I)) : B("+") || B("-") || B("~") || B("!") ? (I = w, d = wt(), v = ft(), v = m.createUnaryExpression(d.value, v), v = m.markEnd(v, I)) : it("delete") || it("void") || it("typeof") ? (I = w, d = wt(), v = ft(), v = m.createUnaryExpression(d.value, v), v = m.markEnd(v, I), b && v.operator === "delete" && v.argument.type === c.Identifier && xt({}, u.StrictDelete)) : v = dt(), v;
          }
          function K(d, v) {
            var I = 0;
            if (d.type !== o.Punctuator && d.type !== o.Keyword)
              return 0;
            switch (d.value) {
              case "||":
                I = 1;
                break;
              case "&&":
                I = 2;
                break;
              case "|":
                I = 3;
                break;
              case "^":
                I = 4;
                break;
              case "&":
                I = 5;
                break;
              case "==":
              case "!=":
              case "===":
              case "!==":
                I = 6;
                break;
              case "<":
              case ">":
              case "<=":
              case ">=":
              case "instanceof":
                I = 7;
                break;
              case "in":
                I = v ? 7 : 0;
                break;
              case "<<":
              case ">>":
              case ">>>":
                I = 8;
                break;
              case "+":
              case "-":
                I = 9;
                break;
              case "*":
              case "/":
              case "%":
                I = 11;
                break;
            }
            return I;
          }
          function C() {
            var d, v, I, j, Z, ht, Ot, Gt, fe, ce;
            if (d = w, fe = ft(), j = w, Z = K(j, _.allowIn), Z === 0)
              return fe;
            for (j.prec = Z, wt(), v = [d, w], Ot = ft(), ht = [fe, j, Ot]; (Z = K(w, _.allowIn)) > 0; ) {
              for (; ht.length > 2 && Z <= ht[ht.length - 2].prec; )
                Ot = ht.pop(), Gt = ht.pop().value, fe = ht.pop(), I = m.createBinaryExpression(Gt, fe, Ot), v.pop(), d = v[v.length - 1], m.markEnd(I, d), ht.push(I);
              j = wt(), j.prec = Z, ht.push(j), v.push(w), I = ft(), ht.push(I);
            }
            for (ce = ht.length - 1, I = ht[ce], v.pop(); ce > 1; )
              I = m.createBinaryExpression(ht[ce - 1].value, ht[ce - 2], I), ce -= 2, d = v.pop(), m.markEnd(I, d);
            return I;
          }
          function N() {
            var d, v, I, j, Z;
            return Z = w, d = C(), B("?") && (wt(), v = _.allowIn, _.allowIn = !0, I = q(), _.allowIn = v, k(":"), j = q(), d = m.createConditionalExpression(d, I, j), m.markEnd(d, Z)), d;
          }
          function q() {
            var d, v, I, j, Z;
            return d = w, Z = w, j = v = N(), ct() && (Mt(v) || xt({}, u.InvalidLHSInAssignment), b && v.type === c.Identifier && _t(v.name) && xt(d, u.StrictLHSAssignment), d = wt(), I = q(), j = m.markEnd(m.createAssignmentExpression(d.value, v, I), Z)), j;
          }
          function W() {
            var d, v = w;
            if (d = q(), B(",")) {
              for (d = m.createSequenceExpression([d]); f < x && B(","); )
                wt(), d.expressions.push(q());
              m.markEnd(d, v);
            }
            return d;
          }
          function G() {
            for (var d = [], v; f < x && !(B("}") || (v = Jr(), typeof v > "u")); )
              d.push(v);
            return d;
          }
          function nt() {
            var d, v;
            return v = w, k("{"), d = G(), k("}"), m.markEnd(m.createBlockStatement(d), v);
          }
          function ut() {
            var d, v;
            return v = w, d = wt(), d.type !== o.Identifier && Jt(d), m.markEnd(m.createIdentifier(d.value), v);
          }
          function gt(d) {
            var v = null, I, j;
            return j = w, I = ut(), b && _t(I.name) && xt({}, u.StrictVarName), d === "const" ? (k("="), v = q()) : B("=") && (wt(), v = q()), m.markEnd(m.createVariableDeclarator(I, v), j);
          }
          function At(d) {
            var v = [];
            do {
              if (v.push(gt(d)), !B(","))
                break;
              wt();
            } while (f < x);
            return v;
          }
          function Nt() {
            var d;
            return M("var"), d = At(), Et(), m.createVariableDeclaration(d, "var");
          }
          function Bt(d) {
            var v, I;
            return I = w, M(d), v = At(d), Et(), m.markEnd(m.createVariableDeclaration(v, d), I);
          }
          function Wt() {
            return k(";"), m.createEmptyStatement();
          }
          function oe() {
            var d = W();
            return Et(), m.createExpressionStatement(d);
          }
          function ie() {
            var d, v, I;
            return M("if"), k("("), d = W(), k(")"), v = Qe(), it("else") ? (wt(), I = Qe()) : I = null, m.createIfStatement(d, v, I);
          }
          function Ce() {
            var d, v, I;
            return M("do"), I = _.inIteration, _.inIteration = !0, d = Qe(), _.inIteration = I, M("while"), k("("), v = W(), k(")"), B(";") && wt(), m.createDoWhileStatement(d, v);
          }
          function De() {
            var d, v, I;
            return M("while"), k("("), d = W(), k(")"), I = _.inIteration, _.inIteration = !0, v = Qe(), _.inIteration = I, m.createWhileStatement(d, v);
          }
          function Dr() {
            var d, v, I;
            return I = w, d = wt(), v = At(), m.markEnd(m.createVariableDeclaration(v, d.value), I);
          }
          function On() {
            var d, v, I, j, Z, ht, Ot;
            return d = v = I = null, M("for"), k("("), B(";") ? wt() : (it("var") || it("let") ? (_.allowIn = !1, d = Dr(), _.allowIn = !0, d.declarations.length === 1 && it("in") && (wt(), j = d, Z = W(), d = null)) : (_.allowIn = !1, d = W(), _.allowIn = !0, it("in") && (Mt(d) || xt({}, u.InvalidLHSInForIn), wt(), j = d, Z = W(), d = null)), typeof j > "u" && k(";")), typeof j > "u" && (B(";") || (v = W()), k(";"), B(")") || (I = W())), k(")"), Ot = _.inIteration, _.inIteration = !0, ht = Qe(), _.inIteration = Ot, typeof j > "u" ? m.createForStatement(d, v, I, ht) : m.createForInStatement(j, Z, ht);
          }
          function Fa() {
            var d = null, v;
            return M("continue"), g.charCodeAt(f) === 59 ? (wt(), _.inIteration || bt({}, u.IllegalContinue), m.createContinueStatement(null)) : Kt() ? (_.inIteration || bt({}, u.IllegalContinue), m.createContinueStatement(null)) : (w.type === o.Identifier && (d = ut(), v = "$" + d.name, Object.prototype.hasOwnProperty.call(_.labelSet, v) || bt({}, u.UnknownLabel, d.name)), Et(), d === null && !_.inIteration && bt({}, u.IllegalContinue), m.createContinueStatement(d));
          }
          function $a() {
            var d = null, v;
            return M("break"), g.charCodeAt(f) === 59 ? (wt(), _.inIteration || _.inSwitch || bt({}, u.IllegalBreak), m.createBreakStatement(null)) : Kt() ? (_.inIteration || _.inSwitch || bt({}, u.IllegalBreak), m.createBreakStatement(null)) : (w.type === o.Identifier && (d = ut(), v = "$" + d.name, Object.prototype.hasOwnProperty.call(_.labelSet, v) || bt({}, u.UnknownLabel, d.name)), Et(), d === null && !(_.inIteration || _.inSwitch) && bt({}, u.IllegalBreak), m.createBreakStatement(d));
          }
          function bd() {
            var d = null;
            return M("return"), _.inFunctionBody || xt({}, u.IllegalReturn), g.charCodeAt(f) === 32 && rt(g.charCodeAt(f + 1)) ? (d = W(), Et(), m.createReturnStatement(d)) : Kt() ? m.createReturnStatement(null) : (B(";") || !B("}") && w.type !== o.EOF && (d = W()), Et(), m.createReturnStatement(d));
          }
          function vd() {
            var d, v;
            return b && (L(), xt({}, u.StrictModeWith)), M("with"), k("("), d = W(), k(")"), v = Qe(), m.createWithStatement(d, v);
          }
          function wd() {
            var d, v = [], I, j;
            for (j = w, it("default") ? (wt(), d = null) : (M("case"), d = W()), k(":"); f < x && !(B("}") || it("default") || it("case")); )
              I = Qe(), v.push(I);
            return m.markEnd(m.createSwitchCase(d, v), j);
          }
          function xd() {
            var d, v, I, j, Z;
            if (M("switch"), k("("), d = W(), k(")"), k("{"), v = [], B("}"))
              return wt(), m.createSwitchStatement(d, v);
            for (j = _.inSwitch, _.inSwitch = !0, Z = !1; f < x && !B("}"); )
              I = wd(), I.test === null && (Z && bt({}, u.MultipleDefaultsInSwitch), Z = !0), v.push(I);
            return _.inSwitch = j, k("}"), m.createSwitchStatement(d, v);
          }
          function Ed() {
            var d;
            return M("throw"), Kt() && bt({}, u.NewlineAfterThrow), d = W(), Et(), m.createThrowStatement(d);
          }
          function Ad() {
            var d, v, I;
            return I = w, M("catch"), k("("), B(")") && Jt(w), d = ut(), b && _t(d.name) && xt({}, u.StrictCatchVariable), k(")"), v = nt(), m.markEnd(m.createCatchClause(d, v), I);
          }
          function Sd() {
            var d, v = [], I = null;
            return M("try"), d = nt(), it("catch") && v.push(Ad()), it("finally") && (wt(), I = nt()), v.length === 0 && !I && bt({}, u.NoCatchOrFinally), m.createTryStatement(d, [], v, I);
          }
          function _d() {
            return M("debugger"), Et(), m.createDebuggerStatement();
          }
          function Qe() {
            var d = w.type, v, I, j, Z;
            if (d === o.EOF && Jt(w), d === o.Punctuator && w.value === "{")
              return nt();
            if (Z = w, d === o.Punctuator)
              switch (w.value) {
                case ";":
                  return m.markEnd(Wt(), Z);
                case "(":
                  return m.markEnd(oe(), Z);
              }
            if (d === o.Keyword)
              switch (w.value) {
                case "break":
                  return m.markEnd($a(), Z);
                case "continue":
                  return m.markEnd(Fa(), Z);
                case "debugger":
                  return m.markEnd(_d(), Z);
                case "do":
                  return m.markEnd(Ce(), Z);
                case "for":
                  return m.markEnd(On(), Z);
                case "function":
                  return m.markEnd(Va(), Z);
                case "if":
                  return m.markEnd(ie(), Z);
                case "return":
                  return m.markEnd(bd(), Z);
                case "switch":
                  return m.markEnd(xd(), Z);
                case "throw":
                  return m.markEnd(Ed(), Z);
                case "try":
                  return m.markEnd(Sd(), Z);
                case "var":
                  return m.markEnd(Nt(), Z);
                case "while":
                  return m.markEnd(De(), Z);
                case "with":
                  return m.markEnd(vd(), Z);
              }
            return v = W(), v.type === c.Identifier && B(":") ? (wt(), j = "$" + v.name, Object.prototype.hasOwnProperty.call(_.labelSet, j) && bt({}, u.Redeclaration, "Label", v.name), _.labelSet[j] = !0, I = Qe(), delete _.labelSet[j], m.markEnd(m.createLabeledStatement(v, I), Z)) : (Et(), m.markEnd(m.createExpressionStatement(v), Z));
          }
          function ds() {
            var d, v = [], I, j, Z, ht, Ot, Gt, fe, ce;
            for (ce = w, k("{"); f < x && !(w.type !== o.StringLiteral || (I = w, d = Jr(), v.push(d), d.expression.type !== c.Literal)); )
              j = g.slice(I.start + 1, I.end - 1), j === "use strict" ? (b = !0, Z && xt(Z, u.StrictOctalLiteral)) : !Z && I.octal && (Z = I);
            for (ht = _.labelSet, Ot = _.inIteration, Gt = _.inSwitch, fe = _.inFunctionBody, _.labelSet = {}, _.inIteration = !1, _.inSwitch = !1, _.inFunctionBody = !0; f < x && !(B("}") || (d = Jr(), typeof d > "u")); )
              v.push(d);
            return k("}"), _.labelSet = ht, _.inIteration = Ot, _.inSwitch = Gt, _.inFunctionBody = fe, m.markEnd(m.createBlockStatement(v), ce);
          }
          function za(d) {
            var v, I = [], j, Z, ht, Ot, Gt;
            if (k("("), !B(")"))
              for (ht = {}; f < x && (j = w, v = ut(), Ot = "$" + j.value, b ? (_t(j.value) && (Z = j, Gt = u.StrictParamName), Object.prototype.hasOwnProperty.call(ht, Ot) && (Z = j, Gt = u.StrictParamDupe)) : d || (_t(j.value) ? (d = j, Gt = u.StrictParamName) : vt(j.value) ? (d = j, Gt = u.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ht, Ot) && (d = j, Gt = u.StrictParamDupe)), I.push(v), ht[Ot] = !0, !B(")")); )
                k(",");
            return k(")"), {
              params: I,
              stricted: Z,
              firstRestricted: d,
              message: Gt
            };
          }
          function Va() {
            var d, v = [], I, j, Z, ht, Ot, Gt, fe, ce;
            return ce = w, M("function"), j = w, d = ut(), b ? _t(j.value) && xt(j, u.StrictFunctionName) : _t(j.value) ? (Ot = j, Gt = u.StrictFunctionName) : vt(j.value) && (Ot = j, Gt = u.StrictReservedWord), ht = za(Ot), v = ht.params, Z = ht.stricted, Ot = ht.firstRestricted, ht.message && (Gt = ht.message), fe = b, I = ds(), b && Ot && bt(Ot, Gt), b && Z && xt(Z, Gt), b = fe, m.markEnd(m.createFunctionDeclaration(d, v, [], I), ce);
          }
          function kd() {
            var d, v = null, I, j, Z, ht, Ot = [], Gt, fe, ce;
            return ce = w, M("function"), B("(") || (d = w, v = ut(), b ? _t(d.value) && xt(d, u.StrictFunctionName) : _t(d.value) ? (j = d, Z = u.StrictFunctionName) : vt(d.value) && (j = d, Z = u.StrictReservedWord)), ht = za(j), Ot = ht.params, I = ht.stricted, j = ht.firstRestricted, ht.message && (Z = ht.message), fe = b, Gt = ds(), b && j && bt(j, Z), b && I && xt(I, Z), b = fe, m.markEnd(m.createFunctionExpression(v, Ot, [], Gt), ce);
          }
          function Jr() {
            if (w.type === o.Keyword)
              switch (w.value) {
                case "const":
                case "let":
                  return Bt(w.value);
                case "function":
                  return Va();
                default:
                  return Qe();
              }
            if (w.type !== o.EOF)
              return Qe();
          }
          function Cd() {
            for (var d, v = [], I, j, Z; f < x && (I = w, !(I.type !== o.StringLiteral || (d = Jr(), v.push(d), d.expression.type !== c.Literal))); )
              j = g.slice(I.start + 1, I.end - 1), j === "use strict" ? (b = !0, Z && xt(Z, u.StrictOctalLiteral)) : !Z && I.octal && (Z = I);
            for (; f < x && (d = Jr(), !(typeof d > "u")); )
              v.push(d);
            return v;
          }
          function Id() {
            var d, v;
            return L(), le(), v = w, b = !1, d = Cd(), m.markEnd(m.createProgram(d), v);
          }
          function Ua() {
            var d, v, I, j = [];
            for (d = 0; d < S.tokens.length; ++d)
              v = S.tokens[d], I = {
                type: v.type,
                value: v.value
              }, S.range && (I.range = v.range), S.loc && (I.loc = v.loc), j.push(I);
            S.tokens = j;
          }
          function Pd(d, v) {
            var I, j, Z;
            I = String, typeof d != "string" && !(d instanceof String) && (d = I(d)), m = y, g = d, f = 0, E = g.length > 0 ? 1 : 0, A = 0, x = g.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, v = v || {}, v.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof v.range == "boolean" && v.range, S.loc = typeof v.loc == "boolean" && v.loc, typeof v.comment == "boolean" && v.comment && (S.comments = []), typeof v.tolerant == "boolean" && v.tolerant && (S.errors = []);
            try {
              if (le(), w.type === o.EOF)
                return S.tokens;
              for (j = wt(); w.type !== o.EOF; )
                try {
                  j = wt();
                } catch (ht) {
                  if (j = w, S.errors) {
                    S.errors.push(ht);
                    break;
                  } else
                    throw ht;
                }
              Ua(), Z = S.tokens, typeof S.comments < "u" && (Z.comments = S.comments), typeof S.errors < "u" && (Z.errors = S.errors);
            } catch (ht) {
              throw ht;
            } finally {
              S = {};
            }
            return Z;
          }
          function Rd(d, v) {
            var I, j;
            j = String, typeof d != "string" && !(d instanceof String) && (d = j(d)), m = y, g = d, f = 0, E = g.length > 0 ? 1 : 0, A = 0, x = g.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, typeof v < "u" && (S.range = typeof v.range == "boolean" && v.range, S.loc = typeof v.loc == "boolean" && v.loc, S.attachComment = typeof v.attachComment == "boolean" && v.attachComment, S.loc && v.source !== null && v.source !== void 0 && (S.source = j(v.source)), typeof v.tokens == "boolean" && v.tokens && (S.tokens = []), typeof v.comment == "boolean" && v.comment && (S.comments = []), typeof v.tolerant == "boolean" && v.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
            try {
              I = Id(), typeof S.comments < "u" && (I.comments = S.comments), typeof S.tokens < "u" && (Ua(), I.tokens = S.tokens), typeof S.errors < "u" && (I.errors = S.errors);
            } catch (Z) {
              throw Z;
            } finally {
              S = {};
            }
            return I;
          }
          s.version = "1.2.2", s.tokenize = Pd, s.parse = Rd, s.Syntax = function() {
            var d, v = {};
            typeof Object.create == "function" && (v = /* @__PURE__ */ Object.create(null));
            for (d in c)
              c.hasOwnProperty(d) && (v[d] = c[d]);
            return typeof Object.freeze == "function" && Object.freeze(v), v;
          }();
        });
      }, {}], 1: [function(r, n, i) {
        (function(s) {
          var o = function() {
            var a = {
              trace: function() {
              },
              yy: {},
              symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
              terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
              productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
              performAction: function(u, p, y, g, b, f, E) {
                g.ast || (g.ast = l, l.initialize());
                var A = f.length - 1;
                switch (b) {
                  case 1:
                    return g.ast.set({ expression: { type: "root", value: f[A] } }), g.ast.unshift(), g.ast.yield();
                  case 2:
                    return g.ast.set({ expression: { type: "root", value: f[A - 1] } }), g.ast.unshift(), g.ast.yield();
                  case 3:
                    return g.ast.unshift(), g.ast.yield();
                  case 4:
                    return g.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), g.ast.unshift(), g.ast.yield();
                  case 5:
                    break;
                  case 6:
                    break;
                  case 7:
                    g.ast.set({ operation: "member" }), g.ast.push();
                    break;
                  case 8:
                    g.ast.set({ operation: "subscript" }), g.ast.push();
                    break;
                  case 9:
                    g.ast.set({ scope: "child" });
                    break;
                  case 10:
                    g.ast.set({ scope: "descendant" });
                    break;
                  case 11:
                    break;
                  case 12:
                    g.ast.set({ scope: "child", operation: "member" });
                    break;
                  case 13:
                    break;
                  case 14:
                    g.ast.set({ expression: { type: "wildcard", value: f[A] } });
                    break;
                  case 15:
                    g.ast.set({ expression: { type: "identifier", value: f[A] } });
                    break;
                  case 16:
                    g.ast.set({ expression: { type: "script_expression", value: f[A] } });
                    break;
                  case 17:
                    g.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                    break;
                  case 18:
                    break;
                  case 19:
                    g.ast.set({ scope: "child" });
                    break;
                  case 20:
                    g.ast.set({ scope: "descendant" });
                    break;
                  case 21:
                    break;
                  case 22:
                    break;
                  case 23:
                    break;
                  case 24:
                    f[A].length > 1 ? g.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                    break;
                  case 25:
                    this.$ = [f[A]];
                    break;
                  case 26:
                    this.$ = f[A - 2].concat(f[A]);
                    break;
                  case 27:
                    this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, g.ast.set(this.$);
                    break;
                  case 28:
                    this.$ = { expression: { type: "string_literal", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 29:
                    this.$ = { expression: { type: "slice", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 30:
                    this.$ = { expression: { type: "wildcard", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 31:
                    this.$ = { expression: { type: "script_expression", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 32:
                    this.$ = { expression: { type: "filter_expression", value: f[A] } }, g.ast.set(this.$);
                    break;
                  case 33:
                    this.$ = f[A];
                    break;
                  case 34:
                    this.$ = f[A];
                    break;
                }
              },
              table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
              defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
              parseError: function(u, p) {
                if (p.recoverable)
                  this.trace(u);
                else
                  throw new Error(u);
              },
              parse: function(u) {
                var p = this, y = [0], g = [null], b = [], f = this.table, E = "", A = 0, x = 0, m = 2, w = 1, _ = b.slice.call(arguments, 1);
                this.lexer.setInput(u), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
                var S = this.lexer.yylloc;
                b.push(S);
                var R = this.lexer.options && this.lexer.options.ranges;
                typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
                function O() {
                  var It;
                  return It = p.lexer.lex() || w, typeof It != "number" && (It = p.symbols_[It] || It), It;
                }
                for (var $, z, F, Y, rt = {}, at, pt, vt, _t; ; ) {
                  if (z = y[y.length - 1], this.defaultActions[z] ? F = this.defaultActions[z] : (($ === null || typeof $ > "u") && ($ = O()), F = f[z] && f[z][$]), typeof F > "u" || !F.length || !F[0]) {
                    var Ct = "";
                    _t = [];
                    for (at in f[z])
                      this.terminals_[at] && at > m && _t.push("'" + this.terminals_[at] + "'");
                    this.lexer.showPosition ? Ct = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + _t.join(", ") + ", got '" + (this.terminals_[$] || $) + "'" : Ct = "Parse error on line " + (A + 1) + ": Unexpected " + ($ == w ? "end of input" : "'" + (this.terminals_[$] || $) + "'"), this.parseError(Ct, {
                      text: this.lexer.match,
                      token: this.terminals_[$] || $,
                      line: this.lexer.yylineno,
                      loc: S,
                      expected: _t
                    });
                  }
                  if (F[0] instanceof Array && F.length > 1)
                    throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + $);
                  switch (F[0]) {
                    case 1:
                      y.push($), g.push(this.lexer.yytext), b.push(this.lexer.yylloc), y.push(F[1]), $ = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                      break;
                    case 2:
                      if (pt = this.productions_[F[1]][1], rt.$ = g[g.length - pt], rt._$ = {
                        first_line: b[b.length - (pt || 1)].first_line,
                        last_line: b[b.length - 1].last_line,
                        first_column: b[b.length - (pt || 1)].first_column,
                        last_column: b[b.length - 1].last_column
                      }, R && (rt._$.range = [
                        b[b.length - (pt || 1)].range[0],
                        b[b.length - 1].range[1]
                      ]), Y = this.performAction.apply(rt, [
                        E,
                        x,
                        A,
                        this.yy,
                        F[1],
                        g,
                        b
                      ].concat(_)), typeof Y < "u")
                        return Y;
                      pt && (y = y.slice(0, -1 * pt * 2), g = g.slice(0, -1 * pt), b = b.slice(0, -1 * pt)), y.push(this.productions_[F[1]][0]), g.push(rt.$), b.push(rt._$), vt = f[y[y.length - 2]][y[y.length - 1]], y.push(vt);
                      break;
                    case 3:
                      return !0;
                  }
                }
                return !0;
              }
            }, l = {
              initialize: function() {
                this._nodes = [], this._node = {}, this._stash = [];
              },
              set: function(u) {
                for (var p in u) this._node[p] = u[p];
                return this._node;
              },
              node: function(u) {
                return arguments.length && (this._node = u), this._node;
              },
              push: function() {
                this._nodes.push(this._node), this._node = {};
              },
              unshift: function() {
                this._nodes.unshift(this._node), this._node = {};
              },
              yield: function() {
                var u = this._nodes;
                return this.initialize(), u;
              }
            }, c = /* @__PURE__ */ function() {
              var u = {
                EOF: 1,
                parseError: function(p, y) {
                  if (this.yy.parser)
                    this.yy.parser.parseError(p, y);
                  else
                    throw new Error(p);
                },
                // resets the lexer, sets new input
                setInput: function(p) {
                  return this._input = p, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                  }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
                },
                // consumes and returns one char from the input
                input: function() {
                  var p = this._input[0];
                  this.yytext += p, this.yyleng++, this.offset++, this.match += p, this.matched += p;
                  var y = p.match(/(?:\r\n?|\n).*/g);
                  return y ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), p;
                },
                // unshifts one char (or a string) into the input
                unput: function(p) {
                  var y = p.length, g = p.split(/(?:\r\n?|\n)/g);
                  this._input = p + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - y - 1), this.offset -= y;
                  var b = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), g.length - 1 && (this.yylineno -= g.length - 1);
                  var f = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: g ? (g.length === b.length ? this.yylloc.first_column : 0) + b[b.length - g.length].length - g[0].length : this.yylloc.first_column - y
                  }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - y]), this.yyleng = this.yytext.length, this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function() {
                  return this._more = !0, this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function() {
                  if (this.options.backtrack_lexer)
                    this._backtrack = !0;
                  else
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                      text: "",
                      token: null,
                      line: this.yylineno
                    });
                  return this;
                },
                // retain first n characters of the match
                less: function(p) {
                  this.unput(this.match.slice(p));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function() {
                  var p = this.matched.substr(0, this.matched.length - this.match.length);
                  return (p.length > 20 ? "..." : "") + p.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function() {
                  var p = this.match;
                  return p.length < 20 && (p += this._input.substr(0, 20 - p.length)), (p.substr(0, 20) + (p.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function() {
                  var p = this.pastInput(), y = new Array(p.length + 1).join("-");
                  return p + this.upcomingInput() + `
` + y + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function(p, y) {
                  var g, b, f;
                  if (this.options.backtrack_lexer && (f = {
                    yylineno: this.yylineno,
                    yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                  }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), b = p[0].match(/(?:\r\n?|\n).*/g), b && (this.yylineno += b.length), this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: b ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + p[0].length
                  }, this.yytext += p[0], this.match += p[0], this.matches = p, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(p[0].length), this.matched += p[0], g = this.performAction.call(this, this.yy, this, y, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), g)
                    return g;
                  if (this._backtrack) {
                    for (var E in f)
                      this[E] = f[E];
                    return !1;
                  }
                  return !1;
                },
                // return next match in input
                next: function() {
                  if (this.done)
                    return this.EOF;
                  this._input || (this.done = !0);
                  var p, y, g, b;
                  this._more || (this.yytext = "", this.match = "");
                  for (var f = this._currentRules(), E = 0; E < f.length; E++)
                    if (g = this._input.match(this.rules[f[E]]), g && (!y || g[0].length > y[0].length)) {
                      if (y = g, b = E, this.options.backtrack_lexer) {
                        if (p = this.test_match(g, f[E]), p !== !1)
                          return p;
                        if (this._backtrack) {
                          y = !1;
                          continue;
                        } else
                          return !1;
                      } else if (!this.options.flex)
                        break;
                    }
                  return y ? (p = this.test_match(y, f[b]), p !== !1 ? p : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                },
                // return next match that has a token
                lex: function() {
                  var p = this.next();
                  return p || this.lex();
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function(p) {
                  this.conditionStack.push(p);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function() {
                  var p = this.conditionStack.length - 1;
                  return p > 0 ? this.conditionStack.pop() : this.conditionStack[0];
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function() {
                  return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function(p) {
                  return p = this.conditionStack.length - 1 - Math.abs(p || 0), p >= 0 ? this.conditionStack[p] : "INITIAL";
                },
                // alias for begin(condition)
                pushState: function(p) {
                  this.begin(p);
                },
                // return the number of states currently on the stack
                stateStackSize: function() {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function(p, y, g, b) {
                  switch (g) {
                    case 0:
                      return 4;
                    case 1:
                      return 14;
                    case 2:
                      return 12;
                    case 3:
                      return 15;
                    case 4:
                      return 16;
                    case 5:
                      return 22;
                    case 6:
                      return 24;
                    case 7:
                      return 28;
                    case 8:
                      return 30;
                    case 9:
                      return 18;
                    case 10:
                      return y.yytext = y.yytext.substr(1, y.yyleng - 2), 32;
                    case 11:
                      return y.yytext = y.yytext.substr(1, y.yyleng - 2), 33;
                    case 12:
                      return 17;
                    case 13:
                      return 31;
                  }
                },
                rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
                conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
              };
              return u;
            }();
            a.lexer = c;
            function h() {
              this.yy = {};
            }
            return h.prototype = a, a.Parser = h, new h();
          }();
          typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
            return o.parse.apply(o, arguments);
          }, i.main = function(a) {
            a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
            var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
            return i.parser.parse(l);
          }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
        }).call(this, r("_process"));
      }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
        n.exports = {
          identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
          integer: "-?(?:0|[1-9][0-9]*)",
          qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
          q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
        };
      }, {}], 3: [function(r, n, i) {
        var s = r("./dict"), o = r("fs"), a = {
          lex: {
            macros: {
              esc: "\\\\",
              int: s.integer
            },
            rules: [
              ["\\$", "return 'DOLLAR'"],
              ["\\.\\.", "return 'DOT_DOT'"],
              ["\\.", "return 'DOT'"],
              ["\\*", "return 'STAR'"],
              [s.identifier, "return 'IDENTIFIER'"],
              ["\\[", "return '['"],
              ["\\]", "return ']'"],
              [",", "return ','"],
              ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
              ["{int}", "return 'INTEGER'"],
              [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
              [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
              ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
              ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
            ]
          },
          start: "JSON_PATH",
          bnf: {
            JSON_PATH: [
              ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
              ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
            ],
            PATH_COMPONENTS: [
              ["PATH_COMPONENT", ""],
              ["PATH_COMPONENTS PATH_COMPONENT", ""]
            ],
            PATH_COMPONENT: [
              ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
              ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
            ],
            MEMBER_COMPONENT: [
              ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_MEMBER_COMPONENT: [
              ["DOT MEMBER_EXPRESSION", ""]
            ],
            LEADING_CHILD_MEMBER_EXPRESSION: [
              ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
            ],
            DESCENDANT_MEMBER_COMPONENT: [
              ["DOT_DOT MEMBER_EXPRESSION", ""]
            ],
            MEMBER_EXPRESSION: [
              ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
              ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
              ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
              ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
              ["END", ""]
            ],
            SUBSCRIPT_COMPONENT: [
              ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_SUBSCRIPT_COMPONENT: [
              ["[ SUBSCRIPT ]", ""]
            ],
            DESCENDANT_SUBSCRIPT_COMPONENT: [
              ["DOT_DOT [ SUBSCRIPT ]", ""]
            ],
            SUBSCRIPT: [
              ["SUBSCRIPT_EXPRESSION", ""],
              ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
            ],
            SUBSCRIPT_EXPRESSION_LIST: [
              ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
              ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
            ],
            SUBSCRIPT_EXPRESSION_LISTABLE: [
              ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
              ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
              ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
            ],
            SUBSCRIPT_EXPRESSION: [
              ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
              ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
              ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
            ],
            STRING_LITERAL: [
              ["QQ_STRING", "$$ = $1"],
              ["Q_STRING", "$$ = $1"]
            ]
          }
        };
        o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
      }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
        var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
          return this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.traverse = y(!0), this.descend = y();
        }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
          var m = [x.operation, x.scope, x.expression.type].join("-"), w = this._fns[m];
          if (!w) throw new Error("couldn't resolve key: " + m);
          return w.bind(this);
        }, c.prototype.register = function(x, m) {
          if (!m instanceof Function)
            throw new Error("handler must be a function");
          this._fns[x] = m;
        }, c.prototype._fns = {
          "member-child-identifier": function(x, m) {
            var w = x.expression.value, _ = m.value;
            if (_ instanceof Object && w in _)
              return [{ value: _[w], path: m.path.concat(w) }];
          },
          "member-descendant-identifier": b(function(x, m, w) {
            return x == w;
          }),
          "subscript-child-numeric_literal": g(function(x, m, w) {
            return x === w;
          }),
          "member-child-numeric_literal": g(function(x, m, w) {
            return String(x) === String(w);
          }),
          "subscript-descendant-numeric_literal": b(function(x, m, w) {
            return x === w;
          }),
          "member-child-wildcard": g(function() {
            return !0;
          }),
          "member-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-child-wildcard": g(function() {
            return !0;
          }),
          "subscript-child-slice": function(x, m) {
            if (u(m.value)) {
              var w = x.expression.value.split(":").map(A), _ = m.value.map(function(S, R) {
                return { value: S, path: m.path.concat(R) };
              });
              return o.apply(null, [_].concat(w));
            }
          },
          "subscript-child-union": function(x, m) {
            var w = [];
            return x.expression.value.forEach(function(_) {
              var S = { operation: "subscript", scope: "child", expression: _.expression }, R = this.resolve(S), O = R(S, m);
              O && (w = w.concat(O));
            }, this), E(w);
          },
          "subscript-descendant-union": function(x, m, w) {
            var _ = r(".."), S = this, R = [], O = _.nodes(m, "$..*").slice(1);
            return O.forEach(function($) {
              R.length >= w || x.expression.value.forEach(function(z) {
                var F = { operation: "subscript", scope: "child", expression: z.expression }, Y = S.resolve(F), rt = Y(F, $);
                R = R.concat(rt);
              });
            }), E(R);
          },
          "subscript-child-filter_expression": function(x, m, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(O, $) {
              return f(S, { "@": $ });
            };
            return this.descend(m, null, R, w);
          },
          "subscript-descendant-filter_expression": function(x, m, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(O, $) {
              return f(S, { "@": $ });
            };
            return this.traverse(m, null, R, w);
          },
          "subscript-child-script_expression": function(x, m) {
            var w = x.expression.value.slice(1, -1);
            return h(m, w, "$[{{value}}]");
          },
          "member-child-script_expression": function(x, m) {
            var w = x.expression.value.slice(1, -1);
            return h(m, w, "$.{{value}}");
          },
          "member-descendant-script_expression": function(x, m) {
            var w = x.expression.value.slice(1, -1);
            return h(m, w, "$..value");
          }
        }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
        function h(x, m, w) {
          var _ = r("./index"), S = s.parse(m).body[0].expression, R = f(S, { "@": x.value }), O = w.replace(/\{\{\s*value\s*\}\}/g, R), $ = _.nodes(x.value, O);
          return $.forEach(function(z) {
            z.path = x.path.concat(z.path.slice(1));
          }), $;
        }
        function u(x) {
          return Array.isArray(x);
        }
        function p(x) {
          return x && !(x instanceof Array) && x instanceof Object;
        }
        function y(x) {
          return function(m, w, _, S) {
            var R = m.value, O = m.path, $ = [], z = (function(F, Y) {
              u(F) ? (F.forEach(function(rt, at) {
                $.length >= S || _(at, rt, w) && $.push({ path: Y.concat(at), value: rt });
              }), F.forEach(function(rt, at) {
                $.length >= S || x && z(rt, Y.concat(at));
              })) : p(F) && (this.keys(F).forEach(function(rt) {
                $.length >= S || _(rt, F[rt], w) && $.push({ path: Y.concat(rt), value: F[rt] });
              }), this.keys(F).forEach(function(rt) {
                $.length >= S || x && z(F[rt], Y.concat(rt));
              }));
            }).bind(this);
            return z(R, O), $;
          };
        }
        function g(x) {
          return function(m, w, _) {
            return this.descend(w, m.expression.value, x, _);
          };
        }
        function b(x) {
          return function(m, w, _) {
            return this.traverse(w, m.expression.value, x, _);
          };
        }
        function f() {
          try {
            return a.apply(this, arguments);
          } catch {
          }
        }
        function E(x) {
          return x = x.filter(function(m) {
            return m;
          }), l(
            x,
            function(m) {
              return m.path.map(function(w) {
                return String(w).replace("-", "--");
              }).join("-");
            }
          );
        }
        function A(x) {
          var m = String(x);
          return m.match(/^-?[0-9]+$/) ? parseInt(m) : null;
        }
        n.exports = c;
      }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
        var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
          this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.parser = new a(), this.handlers = new l();
        }, c.prototype.parse = function(p) {
          return s.ok(h(p), "we need a path"), this.parser.parse(p);
        }, c.prototype.parent = function(p, y) {
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path");
          var g = this.nodes(p, y)[0];
          return g.path.pop(), this.value(p, g.path);
        }, c.prototype.apply = function(p, y, g) {
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path"), s.equal(typeof g, "function", "fn needs to be function");
          var b = this.nodes(p, y).sort(function(f, E) {
            return E.path.length - f.path.length;
          });
          return b.forEach(function(f) {
            var E = f.path.pop(), A = this.value(p, this.stringify(f.path)), x = f.value = g.call(p, A[E]);
            A[E] = x;
          }, this), b;
        }, c.prototype.value = function(p, y, g) {
          if (s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path"), arguments.length >= 3) {
            var b = this.nodes(p, y).shift();
            if (!b) return this._vivify(p, y, g);
            var f = b.path.slice(-1).shift(), E = this.parent(p, this.stringify(b.path));
            E[f] = g;
          }
          return this.query(p, this.stringify(y), 1).shift();
        }, c.prototype._vivify = function(p, y, g) {
          var b = this;
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path");
          var f = this.parser.parse(y).map(function(A) {
            return A.expression.value;
          }), E = function(A, x) {
            var m = A.pop(), w = b.value(p, A);
            w || (E(A.concat(), typeof m == "string" ? {} : []), w = b.value(p, A)), w[m] = x;
          };
          return E(f, g), this.query(p, y)[0];
        }, c.prototype.query = function(p, y, g) {
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(h(y), "we need a path");
          var b = this.nodes(p, y, g).map(function(f) {
            return f.value;
          });
          return b;
        }, c.prototype.paths = function(p, y, g) {
          s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path");
          var b = this.nodes(p, y, g).map(function(f) {
            return f.path;
          });
          return b;
        }, c.prototype.nodes = function(p, y, g) {
          if (s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path"), g === 0) return [];
          var b = this.parser.parse(y), f = this.handlers, E = [{ path: ["$"], value: p }], A = [];
          return b.length && b[0].expression.type == "root" && b.shift(), b.length ? (b.forEach(function(x, m) {
            if (!(A.length >= g)) {
              var w = f.resolve(x), _ = [];
              E.forEach(function(S) {
                if (!(A.length >= g)) {
                  var R = w(x, S, g);
                  m == b.length - 1 ? A = A.concat(R || []) : _ = _.concat(R || []);
                }
              }), E = _;
            }
          }), g ? A.slice(0, g) : A) : E;
        }, c.prototype.stringify = function(p) {
          s.ok(p, "we need a path");
          var y = "$", g = {
            "descendant-member": "..{{value}}",
            "child-member": ".{{value}}",
            "descendant-subscript": "..[{{value}}]",
            "child-subscript": "[{{value}}]"
          };
          return p = this._normalize(p), p.forEach(function(b) {
            if (b.expression.type != "root") {
              var f = [b.scope, b.operation].join("-"), E = g[f], A;
              if (b.expression.type == "string_literal" ? A = JSON.stringify(b.expression.value) : A = b.expression.value, !E) throw new Error("couldn't find template " + f);
              y += E.replace(/{{value}}/, A);
            }
          }), y;
        }, c.prototype._normalize = function(p) {
          if (s.ok(p, "we need a path"), typeof p == "string")
            return this.parser.parse(p);
          if (Array.isArray(p) && typeof p[0] == "string") {
            var y = [{ expression: { type: "root", value: "$" } }];
            return p.forEach(function(g, b) {
              if (!(g == "$" && b === 0))
                if (typeof g == "string" && g.match("^" + o.identifier + "$"))
                  y.push({
                    operation: "member",
                    scope: "child",
                    expression: { value: g, type: "identifier" }
                  });
                else {
                  var f = typeof g == "number" ? "numeric_literal" : "string_literal";
                  y.push({
                    operation: "subscript",
                    scope: "child",
                    expression: { value: g, type: f }
                  });
                }
            }), y;
          } else if (Array.isArray(p) && typeof p[0] == "object")
            return p;
          throw new Error("couldn't understand path " + p);
        };
        function h(p) {
          return Object.prototype.toString.call(p) == "[object String]";
        }
        c.Handlers = l, c.Parser = a;
        var u = new c();
        u.JSONPath = c, n.exports = u;
      }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
        var s = r("./grammar"), o = r("../generated/parser"), a = function() {
          var l = new o.Parser(), c = l.parseError;
          return l.yy.parseError = function() {
            l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
          }, l;
        };
        a.grammar = s, n.exports = a;
      }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
        n.exports = function(o, a, l, c) {
          if (typeof a == "string") throw new Error("start cannot be a string");
          if (typeof l == "string") throw new Error("end cannot be a string");
          if (typeof c == "string") throw new Error("step cannot be a string");
          var h = o.length;
          if (c === 0) throw new Error("step cannot be zero");
          if (c = c ? s(c) : 1, a = a < 0 ? h + a : a, l = l < 0 ? h + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : h - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? h : -1)), a = c > 0 ? Math.max(0, a) : Math.min(h, a), l = c > 0 ? Math.min(l, h) : Math.max(-1, l), c > 0 && l <= a) return [];
          if (c < 0 && a <= l) return [];
          for (var u = [], p = a; p != l && !(c < 0 && p <= l || c > 0 && p >= l); p += c)
            u.push(o[p]);
          return u;
        };
        function s(o) {
          return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
        }
      }, {}], 8: [function(r, n, i) {
        var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = y;
        l.AssertionError = function(m) {
          this.name = "AssertionError", this.actual = m.actual, this.expected = m.expected, this.operator = m.operator, m.message ? (this.message = m.message, this.generatedMessage = !1) : (this.message = u(this), this.generatedMessage = !0);
          var w = m.stackStartFunction || p;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, w);
          else {
            var _ = new Error();
            if (_.stack) {
              var S = _.stack, R = w.name, O = S.indexOf(`
` + R);
              if (O >= 0) {
                var $ = S.indexOf(`
`, O + 1);
                S = S.substring($ + 1);
              }
              this.stack = S;
            }
          }
        }, s.inherits(l.AssertionError, Error);
        function c(m, w) {
          return s.isUndefined(w) ? "" + w : s.isNumber(w) && !isFinite(w) || s.isFunction(w) || s.isRegExp(w) ? w.toString() : w;
        }
        function h(m, w) {
          return s.isString(m) ? m.length < w ? m : m.slice(0, w) : m;
        }
        function u(m) {
          return h(JSON.stringify(m.actual, c), 128) + " " + m.operator + " " + h(JSON.stringify(m.expected, c), 128);
        }
        function p(m, w, _, S, R) {
          throw new l.AssertionError({
            message: _,
            actual: m,
            expected: w,
            operator: S,
            stackStartFunction: R
          });
        }
        l.fail = p;
        function y(m, w) {
          m || p(m, !0, w, "==", l.ok);
        }
        l.ok = y, l.equal = function(m, w, _) {
          m != w && p(m, w, _, "==", l.equal);
        }, l.notEqual = function(m, w, _) {
          m == w && p(m, w, _, "!=", l.notEqual);
        }, l.deepEqual = function(m, w, _) {
          g(m, w) || p(m, w, _, "deepEqual", l.deepEqual);
        };
        function g(m, w) {
          if (m === w)
            return !0;
          if (s.isBuffer(m) && s.isBuffer(w)) {
            if (m.length != w.length) return !1;
            for (var _ = 0; _ < m.length; _++)
              if (m[_] !== w[_]) return !1;
            return !0;
          } else return s.isDate(m) && s.isDate(w) ? m.getTime() === w.getTime() : s.isRegExp(m) && s.isRegExp(w) ? m.source === w.source && m.global === w.global && m.multiline === w.multiline && m.lastIndex === w.lastIndex && m.ignoreCase === w.ignoreCase : !s.isObject(m) && !s.isObject(w) ? m == w : f(m, w);
        }
        function b(m) {
          return Object.prototype.toString.call(m) == "[object Arguments]";
        }
        function f(m, w) {
          if (s.isNullOrUndefined(m) || s.isNullOrUndefined(w) || m.prototype !== w.prototype) return !1;
          if (s.isPrimitive(m) || s.isPrimitive(w))
            return m === w;
          var _ = b(m), S = b(w);
          if (_ && !S || !_ && S)
            return !1;
          if (_)
            return m = o.call(m), w = o.call(w), g(m, w);
          var R = x(m), O = x(w), $, z;
          if (R.length != O.length)
            return !1;
          for (R.sort(), O.sort(), z = R.length - 1; z >= 0; z--)
            if (R[z] != O[z])
              return !1;
          for (z = R.length - 1; z >= 0; z--)
            if ($ = R[z], !g(m[$], w[$])) return !1;
          return !0;
        }
        l.notDeepEqual = function(m, w, _) {
          g(m, w) && p(m, w, _, "notDeepEqual", l.notDeepEqual);
        }, l.strictEqual = function(m, w, _) {
          m !== w && p(m, w, _, "===", l.strictEqual);
        }, l.notStrictEqual = function(m, w, _) {
          m === w && p(m, w, _, "!==", l.notStrictEqual);
        };
        function E(m, w) {
          return !m || !w ? !1 : Object.prototype.toString.call(w) == "[object RegExp]" ? w.test(m) : m instanceof w ? !0 : w.call({}, m) === !0;
        }
        function A(m, w, _, S) {
          var R;
          s.isString(_) && (S = _, _ = null);
          try {
            w();
          } catch (O) {
            R = O;
          }
          if (S = (_ && _.name ? " (" + _.name + ")." : ".") + (S ? " " + S : "."), m && !R && p(R, _, "Missing expected exception" + S), !m && E(R, _) && p(R, _, "Got unwanted exception" + S), m && R && _ && !E(R, _) || !m && R)
            throw R;
        }
        l.throws = function(m, w, _) {
          A.apply(this, [!0].concat(o.call(arguments)));
        }, l.doesNotThrow = function(m, w) {
          A.apply(this, [!1].concat(o.call(arguments)));
        }, l.ifError = function(m) {
          if (m)
            throw m;
        };
        var x = Object.keys || function(m) {
          var w = [];
          for (var _ in m)
            a.call(m, _) && w.push(_);
          return w;
        };
      }, { "util/": 11 }], 9: [function(r, n, i) {
        typeof Object.create == "function" ? n.exports = function(s, o) {
          s.super_ = o, s.prototype = Object.create(o.prototype, {
            constructor: {
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : n.exports = function(s, o) {
          s.super_ = o;
          var a = function() {
          };
          a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
        };
      }, {}], 10: [function(r, n, i) {
        n.exports = function(s) {
          return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
        };
      }, {}], 11: [function(r, n, i) {
        (function(s, o) {
          var a = /%[sdj%]/g;
          i.format = function(L) {
            if (!O(L)) {
              for (var D = [], tt = 0; tt < arguments.length; tt++)
                D.push(h(arguments[tt]));
              return D.join(" ");
            }
            for (var tt = 1, et = arguments, st = et.length, X = String(L).replace(a, function(U) {
              if (U === "%%") return "%";
              if (tt >= st) return U;
              switch (U) {
                case "%s":
                  return String(et[tt++]);
                case "%d":
                  return Number(et[tt++]);
                case "%j":
                  try {
                    return JSON.stringify(et[tt++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return U;
              }
            }), ot = et[tt]; tt < st; ot = et[++tt])
              _(ot) || !Y(ot) ? X += " " + ot : X += " " + h(ot);
            return X;
          }, i.deprecate = function(L, D) {
            if (z(o.process))
              return function() {
                return i.deprecate(L, D).apply(this, arguments);
              };
            if (s.noDeprecation === !0)
              return L;
            var tt = !1;
            function et() {
              if (!tt) {
                if (s.throwDeprecation)
                  throw new Error(D);
                s.traceDeprecation ? console.trace(D) : console.error(D), tt = !0;
              }
              return L.apply(this, arguments);
            }
            return et;
          };
          var l = {}, c;
          i.debuglog = function(L) {
            if (z(c) && (c = s.env.NODE_DEBUG || ""), L = L.toUpperCase(), !l[L])
              if (new RegExp("\\b" + L + "\\b", "i").test(c)) {
                var D = s.pid;
                l[L] = function() {
                  var tt = i.format.apply(i, arguments);
                  console.error("%s %d: %s", L, D, tt);
                };
              } else
                l[L] = function() {
                };
            return l[L];
          };
          function h(L, D) {
            var tt = {
              seen: [],
              stylize: p
            };
            return arguments.length >= 3 && (tt.depth = arguments[2]), arguments.length >= 4 && (tt.colors = arguments[3]), w(D) ? tt.showHidden = D : D && i._extend(tt, D), z(tt.showHidden) && (tt.showHidden = !1), z(tt.depth) && (tt.depth = 2), z(tt.colors) && (tt.colors = !1), z(tt.customInspect) && (tt.customInspect = !0), tt.colors && (tt.stylize = u), g(tt, L, tt.depth);
          }
          i.inspect = h, h.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, h.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function u(L, D) {
            var tt = h.styles[D];
            return tt ? "\x1B[" + h.colors[tt][0] + "m" + L + "\x1B[" + h.colors[tt][1] + "m" : L;
          }
          function p(L, D) {
            return L;
          }
          function y(L) {
            var D = {};
            return L.forEach(function(tt, et) {
              D[tt] = !0;
            }), D;
          }
          function g(L, D, tt) {
            if (L.customInspect && D && pt(D.inspect) && // Filter out the util module, it's inspect function is special
            D.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
            !(D.constructor && D.constructor.prototype === D)) {
              var et = D.inspect(tt, L);
              return O(et) || (et = g(L, et, tt)), et;
            }
            var st = b(L, D);
            if (st)
              return st;
            var X = Object.keys(D), ot = y(X);
            if (L.showHidden && (X = Object.getOwnPropertyNames(D)), at(D) && (X.indexOf("message") >= 0 || X.indexOf("description") >= 0))
              return f(D);
            if (X.length === 0) {
              if (pt(D)) {
                var mt = D.name ? ": " + D.name : "";
                return L.stylize("[Function" + mt + "]", "special");
              }
              if (F(D))
                return L.stylize(RegExp.prototype.toString.call(D), "regexp");
              if (rt(D))
                return L.stylize(Date.prototype.toString.call(D), "date");
              if (at(D))
                return f(D);
            }
            var U = "", J = !1, St = ["{", "}"];
            if (m(D) && (J = !0, St = ["[", "]"]), pt(D)) {
              var Rt = D.name ? ": " + D.name : "";
              U = " [Function" + Rt + "]";
            }
            if (F(D) && (U = " " + RegExp.prototype.toString.call(D)), rt(D) && (U = " " + Date.prototype.toUTCString.call(D)), at(D) && (U = " " + f(D)), X.length === 0 && (!J || D.length == 0))
              return St[0] + U + St[1];
            if (tt < 0)
              return F(D) ? L.stylize(RegExp.prototype.toString.call(D), "regexp") : L.stylize("[Object]", "special");
            L.seen.push(D);
            var zt;
            return J ? zt = E(L, D, tt, ot, X) : zt = X.map(function(Tt) {
              return A(L, D, tt, ot, Tt, J);
            }), L.seen.pop(), x(zt, U, St);
          }
          function b(L, D) {
            if (z(D))
              return L.stylize("undefined", "undefined");
            if (O(D)) {
              var tt = "'" + JSON.stringify(D).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return L.stylize(tt, "string");
            }
            if (R(D))
              return L.stylize("" + D, "number");
            if (w(D))
              return L.stylize("" + D, "boolean");
            if (_(D))
              return L.stylize("null", "null");
          }
          function f(L) {
            return "[" + Error.prototype.toString.call(L) + "]";
          }
          function E(L, D, tt, et, st) {
            for (var X = [], ot = 0, mt = D.length; ot < mt; ++ot)
              lt(D, String(ot)) ? X.push(A(
                L,
                D,
                tt,
                et,
                String(ot),
                !0
              )) : X.push("");
            return st.forEach(function(U) {
              U.match(/^\d+$/) || X.push(A(
                L,
                D,
                tt,
                et,
                U,
                !0
              ));
            }), X;
          }
          function A(L, D, tt, et, st, X) {
            var ot, mt, U;
            if (U = Object.getOwnPropertyDescriptor(D, st) || { value: D[st] }, U.get ? U.set ? mt = L.stylize("[Getter/Setter]", "special") : mt = L.stylize("[Getter]", "special") : U.set && (mt = L.stylize("[Setter]", "special")), lt(et, st) || (ot = "[" + st + "]"), mt || (L.seen.indexOf(U.value) < 0 ? (_(tt) ? mt = g(L, U.value, null) : mt = g(L, U.value, tt - 1), mt.indexOf(`
`) > -1 && (X ? mt = mt.split(`
`).map(function(J) {
              return "  " + J;
            }).join(`
`).substr(2) : mt = `
` + mt.split(`
`).map(function(J) {
              return "   " + J;
            }).join(`
`))) : mt = L.stylize("[Circular]", "special")), z(ot)) {
              if (X && st.match(/^\d+$/))
                return mt;
              ot = JSON.stringify("" + st), ot.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ot = ot.substr(1, ot.length - 2), ot = L.stylize(ot, "name")) : (ot = ot.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ot = L.stylize(ot, "string"));
            }
            return ot + ": " + mt;
          }
          function x(L, D, tt) {
            var et = L.reduce(function(st, X) {
              return X.indexOf(`
`) >= 0, st + X.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return et > 60 ? tt[0] + (D === "" ? "" : D + `
 `) + " " + L.join(`,
  `) + " " + tt[1] : tt[0] + D + " " + L.join(", ") + " " + tt[1];
          }
          function m(L) {
            return Array.isArray(L);
          }
          i.isArray = m;
          function w(L) {
            return typeof L == "boolean";
          }
          i.isBoolean = w;
          function _(L) {
            return L === null;
          }
          i.isNull = _;
          function S(L) {
            return L == null;
          }
          i.isNullOrUndefined = S;
          function R(L) {
            return typeof L == "number";
          }
          i.isNumber = R;
          function O(L) {
            return typeof L == "string";
          }
          i.isString = O;
          function $(L) {
            return typeof L == "symbol";
          }
          i.isSymbol = $;
          function z(L) {
            return L === void 0;
          }
          i.isUndefined = z;
          function F(L) {
            return Y(L) && _t(L) === "[object RegExp]";
          }
          i.isRegExp = F;
          function Y(L) {
            return typeof L == "object" && L !== null;
          }
          i.isObject = Y;
          function rt(L) {
            return Y(L) && _t(L) === "[object Date]";
          }
          i.isDate = rt;
          function at(L) {
            return Y(L) && (_t(L) === "[object Error]" || L instanceof Error);
          }
          i.isError = at;
          function pt(L) {
            return typeof L == "function";
          }
          i.isFunction = pt;
          function vt(L) {
            return L === null || typeof L == "boolean" || typeof L == "number" || typeof L == "string" || typeof L == "symbol" || // ES6 symbol
            typeof L > "u";
          }
          i.isPrimitive = vt, i.isBuffer = r("./support/isBuffer");
          function _t(L) {
            return Object.prototype.toString.call(L);
          }
          function Ct(L) {
            return L < 10 ? "0" + L.toString(10) : L.toString(10);
          }
          var It = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function jt() {
            var L = /* @__PURE__ */ new Date(), D = [
              Ct(L.getHours()),
              Ct(L.getMinutes()),
              Ct(L.getSeconds())
            ].join(":");
            return [L.getDate(), It[L.getMonth()], D].join(" ");
          }
          i.log = function() {
            console.log("%s - %s", jt(), i.format.apply(i, arguments));
          }, i.inherits = r("inherits"), i._extend = function(L, D) {
            if (!D || !Y(D)) return L;
            for (var tt = Object.keys(D), et = tt.length; et--; )
              L[tt[et]] = D[tt[et]];
            return L;
          };
          function lt(L, D) {
            return Object.prototype.hasOwnProperty.call(L, D);
          }
        }).call(this, r("_process"), typeof l7 < "u" ? l7 : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
      }, {}], 13: [function(r, n, i) {
        (function(s) {
          function o(h, u) {
            for (var p = 0, y = h.length - 1; y >= 0; y--) {
              var g = h[y];
              g === "." ? h.splice(y, 1) : g === ".." ? (h.splice(y, 1), p++) : p && (h.splice(y, 1), p--);
            }
            if (u)
              for (; p--; p)
                h.unshift("..");
            return h;
          }
          i.resolve = function() {
            for (var h = "", u = !1, p = arguments.length - 1; p >= -1 && !u; p--) {
              var y = p >= 0 ? arguments[p] : s.cwd();
              if (typeof y != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              y && (h = y + "/" + h, u = y.charAt(0) === "/");
            }
            return h = o(l(h.split("/"), function(g) {
              return !!g;
            }), !u).join("/"), (u ? "/" : "") + h || ".";
          }, i.normalize = function(h) {
            var u = i.isAbsolute(h), p = c(h, -1) === "/";
            return h = o(l(h.split("/"), function(y) {
              return !!y;
            }), !u).join("/"), !h && !u && (h = "."), h && p && (h += "/"), (u ? "/" : "") + h;
          }, i.isAbsolute = function(h) {
            return h.charAt(0) === "/";
          }, i.join = function() {
            var h = Array.prototype.slice.call(arguments, 0);
            return i.normalize(l(h, function(u, p) {
              if (typeof u != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return u;
            }).join("/"));
          }, i.relative = function(h, u) {
            h = i.resolve(h).substr(1), u = i.resolve(u).substr(1);
            function p(x) {
              for (var m = 0; m < x.length && x[m] === ""; m++)
                ;
              for (var w = x.length - 1; w >= 0 && x[w] === ""; w--)
                ;
              return m > w ? [] : x.slice(m, w - m + 1);
            }
            for (var y = p(h.split("/")), g = p(u.split("/")), b = Math.min(y.length, g.length), f = b, E = 0; E < b; E++)
              if (y[E] !== g[E]) {
                f = E;
                break;
              }
            for (var A = [], E = f; E < y.length; E++)
              A.push("..");
            return A = A.concat(g.slice(f)), A.join("/");
          }, i.sep = "/", i.delimiter = ":", i.dirname = function(h) {
            if (typeof h != "string" && (h = h + ""), h.length === 0) return ".";
            for (var u = h.charCodeAt(0), p = u === 47, y = -1, g = !0, b = h.length - 1; b >= 1; --b)
              if (u = h.charCodeAt(b), u === 47) {
                if (!g) {
                  y = b;
                  break;
                }
              } else
                g = !1;
            return y === -1 ? p ? "/" : "." : p && y === 1 ? "/" : h.slice(0, y);
          };
          function a(h) {
            typeof h != "string" && (h = h + "");
            var u = 0, p = -1, y = !0, g;
            for (g = h.length - 1; g >= 0; --g)
              if (h.charCodeAt(g) === 47) {
                if (!y) {
                  u = g + 1;
                  break;
                }
              } else p === -1 && (y = !1, p = g + 1);
            return p === -1 ? "" : h.slice(u, p);
          }
          i.basename = function(h, u) {
            var p = a(h);
            return u && p.substr(-1 * u.length) === u && (p = p.substr(0, p.length - u.length)), p;
          }, i.extname = function(h) {
            typeof h != "string" && (h = h + "");
            for (var u = -1, p = 0, y = -1, g = !0, b = 0, f = h.length - 1; f >= 0; --f) {
              var E = h.charCodeAt(f);
              if (E === 47) {
                if (!g) {
                  p = f + 1;
                  break;
                }
                continue;
              }
              y === -1 && (g = !1, y = f + 1), E === 46 ? u === -1 ? u = f : b !== 1 && (b = 1) : u !== -1 && (b = -1);
            }
            return u === -1 || y === -1 || // We saw a non-dot character immediately before the dot
            b === 0 || // The (right-most) trimmed path component is exactly '..'
            b === 1 && u === y - 1 && u === p + 1 ? "" : h.slice(u, y);
          };
          function l(h, u) {
            if (h.filter) return h.filter(u);
            for (var p = [], y = 0; y < h.length; y++)
              u(h[y], y, h) && p.push(h[y]);
            return p;
          }
          var c = "ab".substr(-1) === "b" ? function(h, u, p) {
            return h.substr(u, p);
          } : function(h, u, p) {
            return u < 0 && (u = h.length + u), h.substr(u, p);
          };
        }).call(this, r("_process"));
      }, { _process: 14 }], 14: [function(r, n, i) {
        var s = n.exports = {}, o, a;
        function l() {
          throw new Error("setTimeout has not been defined");
        }
        function c() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? o = setTimeout : o = l;
          } catch {
            o = l;
          }
          try {
            typeof clearTimeout == "function" ? a = clearTimeout : a = c;
          } catch {
            a = c;
          }
        })();
        function h(m) {
          if (o === setTimeout)
            return setTimeout(m, 0);
          if ((o === l || !o) && setTimeout)
            return o = setTimeout, setTimeout(m, 0);
          try {
            return o(m, 0);
          } catch {
            try {
              return o.call(null, m, 0);
            } catch {
              return o.call(this, m, 0);
            }
          }
        }
        function u(m) {
          if (a === clearTimeout)
            return clearTimeout(m);
          if ((a === c || !a) && clearTimeout)
            return a = clearTimeout, clearTimeout(m);
          try {
            return a(m);
          } catch {
            try {
              return a.call(null, m);
            } catch {
              return a.call(this, m);
            }
          }
        }
        var p = [], y = !1, g, b = -1;
        function f() {
          !y || !g || (y = !1, g.length ? p = g.concat(p) : b = -1, p.length && E());
        }
        function E() {
          if (!y) {
            var m = h(f);
            y = !0;
            for (var w = p.length; w; ) {
              for (g = p, p = []; ++b < w; )
                g && g[b].run();
              b = -1, w = p.length;
            }
            g = null, y = !1, u(m);
          }
        }
        s.nextTick = function(m) {
          var w = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var _ = 1; _ < arguments.length; _++)
              w[_ - 1] = arguments[_];
          p.push(new A(m, w)), p.length === 1 && !y && h(E);
        };
        function A(m, w) {
          this.fun = m, this.array = w;
        }
        A.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
        function x() {
        }
        s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(m) {
          return [];
        }, s.binding = function(m) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(m) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 15: [function(r, n, i) {
        var s = r("escodegen").generate;
        n.exports = function(o, a) {
          a || (a = {});
          var l = {}, c = function h(u, p) {
            if (u.type === "Literal")
              return u.value;
            if (u.type === "UnaryExpression") {
              var y = h(u.argument);
              return u.operator === "+" ? +y : u.operator === "-" ? -y : u.operator === "~" ? ~y : u.operator === "!" ? !y : l;
            } else if (u.type === "ArrayExpression") {
              for (var g = [], b = 0, f = u.elements.length; b < f; b++) {
                var E = h(u.elements[b]);
                if (E === l) return l;
                g.push(E);
              }
              return g;
            } else if (u.type === "ObjectExpression") {
              for (var A = {}, b = 0; b < u.properties.length; b++) {
                var x = u.properties[b], m = x.value === null ? x.value : h(x.value);
                if (m === l) return l;
                A[x.key.value || x.key.name] = m;
              }
              return A;
            } else if (u.type === "BinaryExpression" || u.type === "LogicalExpression") {
              var f = h(u.left);
              if (f === l) return l;
              var w = h(u.right);
              if (w === l) return l;
              var _ = u.operator;
              return _ === "==" ? f == w : _ === "===" ? f === w : _ === "!=" ? f != w : _ === "!==" ? f !== w : _ === "+" ? f + w : _ === "-" ? f - w : _ === "*" ? f * w : _ === "/" ? f / w : _ === "%" ? f % w : _ === "<" ? f < w : _ === "<=" ? f <= w : _ === ">" ? f > w : _ === ">=" ? f >= w : _ === "|" ? f | w : _ === "&" ? f & w : _ === "^" ? f ^ w : _ === "&&" ? f && w : _ === "||" ? f || w : l;
            } else {
              if (u.type === "Identifier")
                return {}.hasOwnProperty.call(a, u.name) ? a[u.name] : l;
              if (u.type === "ThisExpression")
                return {}.hasOwnProperty.call(a, "this") ? a.this : l;
              if (u.type === "CallExpression") {
                var S = h(u.callee);
                if (S === l || typeof S != "function") return l;
                var R = u.callee.object ? h(u.callee.object) : l;
                R === l && (R = null);
                for (var O = [], b = 0, f = u.arguments.length; b < f; b++) {
                  var E = h(u.arguments[b]);
                  if (E === l) return l;
                  O.push(E);
                }
                return S.apply(R, O);
              } else if (u.type === "MemberExpression") {
                var A = h(u.object);
                if (A === l || typeof A == "function")
                  return l;
                if (u.property.type === "Identifier")
                  return A[u.property.name];
                var x = h(u.property);
                return x === l ? l : A[x];
              } else if (u.type === "ConditionalExpression") {
                var y = h(u.test);
                return y === l ? l : h(y ? u.consequent : u.alternate);
              } else if (u.type === "ExpressionStatement") {
                var y = h(u.expression);
                return y === l ? l : y;
              } else {
                if (u.type === "ReturnStatement")
                  return h(u.argument);
                if (u.type === "FunctionExpression") {
                  var $ = u.body.body, z = {};
                  Object.keys(a).forEach(function(It) {
                    z[It] = a[It];
                  });
                  for (var b = 0; b < u.params.length; b++) {
                    var F = u.params[b];
                    if (F.type == "Identifier")
                      a[F.name] = null;
                    else return l;
                  }
                  for (var b in $)
                    if (h($[b]) === l)
                      return l;
                  a = z;
                  var Y = Object.keys(a), rt = Y.map(function(It) {
                    return a[It];
                  });
                  return Function(Y.join(", "), "return " + s(u)).apply(null, rt);
                } else if (u.type === "TemplateLiteral") {
                  for (var at = "", b = 0; b < u.expressions.length; b++)
                    at += h(u.quasis[b]), at += h(u.expressions[b]);
                  return at += h(u.quasis[b]), at;
                } else if (u.type === "TaggedTemplateExpression") {
                  var pt = h(u.tag), vt = u.quasi, _t = vt.quasis.map(h), Ct = vt.expressions.map(h);
                  return pt.apply(null, [_t].concat(Ct));
                } else return u.type === "TemplateElement" ? u.value.cooked : l;
              }
            }
          }(o);
          return c === l ? void 0 : c;
        };
      }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
        n.exports = r("./lib/index");
      }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
    });
  }(x7)), x7.exports;
}
mct();
const yct = "https://fizz.studio/schema/manifest.schema.json", bct = {
  $id: yct
};
bct.$id;
function FM(e) {
  const t = e.datasets[0];
  if (t.data.source !== "inline")
    throw new Error("only manifests with inline data can use this function.");
  const r = {};
  for (const n of t.series)
    r[n.key] = n.records;
  return r;
}
function $M(e) {
  return new Set(...e.map((t) => t.x));
}
function vct(e, t) {
  return e.size === t.size && e.isSubsetOf(t);
}
function wct(e) {
  let t = null;
  for (const r in e) {
    const n = e[r], i = $M(n);
    if (i.size !== n.length)
      return !1;
    if (t === null)
      t = i;
    else if (!vct(i, t))
      return !1;
  }
  return !0;
}
function Cr(e) {
  return e.toLowerCase().replace(/\s+/g, "_").replace(/[^\w-]+/g, "_");
}
const e4 = {
  line: "line",
  stepline: "line",
  bar: "bar",
  column: "bar",
  lollipop: "bar",
  histogram: "histogram",
  scatter: "scatter",
  heatmap: "scatter",
  pie: "pastry",
  donut: "pastry",
  graph: "graph"
};
(() => {
  const e = {
    line: [],
    bar: [],
    pastry: [],
    scatter: [],
    histogram: [],
    graph: []
  };
  for (let t of Object.keys(e4))
    e[e4[t]].push(t);
  return e;
})();
function A7(e) {
  return e4[e] === "pastry";
}
const xct = {
  bar: "column",
  column: "column",
  lollipop: "column",
  histogram: "column",
  line: "line",
  stepline: "line",
  graph: "line",
  scatter: "other",
  heatmap: "other",
  pie: "other",
  donut: "other"
};
let Rv = class extends Error {
  constructor(t) {
    super(`[jimifier]: ${t}`);
  }
}, Ect = class {
  constructor(t, r) {
    if (this._manifest = t, this._dataset = this._manifest.datasets[0], this._dataset.data.source === "inline")
      this._data = FM(this._manifest);
    else if (r)
      this._data = r;
    else
      throw new Rv("JIM cannot be created without external or inline chart data");
    this._seriesKeys = Object.keys(this._data);
  }
  get jim() {
    return this._jim;
  }
  _addSelectorsOrdered(t) {
    let r = 1;
    const n = $M(this._data[this._seriesKeys[0]]);
    this._seriesKeys.forEach((i, s) => {
      n.forEach((o, a) => {
        t[`datapoint${r}`] = {
          dom: `#datapoint-${Cr(o)}_${Cr(i)}`,
          json: [
            `$.datasets[0].series[${s}].name`,
            `$.datasets[0].series[${s}].records[${a}].*`
          ]
        }, r++;
      });
    });
  }
  _addSelectorsUnordered(t) {
    let r = 1;
    Object.keys(this._data).forEach((n, i) => {
      this._data[n].forEach((s, o) => {
        const a = Cr(s.x), l = Cr(s.y);
        t[`datapoint${r}`] = {
          dom: `#datapoint-${a}_${l}_${Cr(n)}`,
          json: [
            `$.datasets[0].series[${i}].name`,
            `$.datasets[0].series[${i}].records[${o}].*`
          ]
        }, r++;
      });
    });
  }
  _renderSelectors() {
    const t = {
      chartTitle: {
        dom: "#chart-title",
        json: "$.datasets[0].title"
      }
    };
    return wct(this._data) ? this._addSelectorsOrdered(t) : this._addSelectorsUnordered(t), t;
  }
  render() {
    const t = {
      title: this._dataset.title,
      facets: this._dataset.facets,
      series: []
    };
    t.series = this._dataset.series.map((i) => ({
      name: i.key,
      type: xct[this._dataset.type],
      records: this._data[i.key]
    }));
    const r = this._renderSelectors(), n = this._renderBehaviors();
    this._jim = {
      datasets: [t],
      selectors: r,
      behaviors: n,
      version: { jim: "0.4.0" }
    };
  }
  addSeriesSummary(t, r) {
    if (!this._jim)
      throw new Rv("JIM must be rendered before adding series summary");
    const n = this._seriesKeys.indexOf(t);
    if (n === -1)
      throw new Rv(`Series key "${t}" not found`);
    this._jim.datasets[0].series[n].description = r;
    const i = `seriesSummary_${Cr(t)}`;
    this._jim.selectors[i] = {
      dom: `#series-${Cr(t)}`,
      json: `$.datasets[0].series[${n}].description`
    };
  }
  _renderBehaviors() {
    const t = [];
    return this._seriesKeys.forEach((r, n) => {
      t.push({
        target: {
          selector: `$.selectors.seriesSummary_${r}`
        },
        enter: {
          haptic: {
            durations: [0, 125, 125, 125, 125, 125, 125, 125],
            repeatInterval: 125
          },
          audio: {
            earcon: "PewPew",
            repeat: "none"
          }
        },
        details: {
          announcement: {
            path: `$.datasets[0].series[${n}].description`
          }
        }
      });
    }), t;
  }
};
var Dl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Zg = {}, zM = {}, T2 = {};
T2.byteLength = _ct;
T2.toByteArray = Cct;
T2.fromByteArray = Rct;
var oo = [], Hi = [], Act = typeof Uint8Array < "u" ? Uint8Array : Array, Tv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var mh = 0, Sct = Tv.length; mh < Sct; ++mh)
  oo[mh] = Tv[mh], Hi[Tv.charCodeAt(mh)] = mh;
Hi[45] = 62;
Hi[95] = 63;
function VM(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function _ct(e) {
  var t = VM(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function kct(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function Cct(e) {
  var t, r = VM(e), n = r[0], i = r[1], s = new Act(kct(e, n, i)), o = 0, a = i > 0 ? n - 4 : n, l;
  for (l = 0; l < a; l += 4)
    t = Hi[e.charCodeAt(l)] << 18 | Hi[e.charCodeAt(l + 1)] << 12 | Hi[e.charCodeAt(l + 2)] << 6 | Hi[e.charCodeAt(l + 3)], s[o++] = t >> 16 & 255, s[o++] = t >> 8 & 255, s[o++] = t & 255;
  return i === 2 && (t = Hi[e.charCodeAt(l)] << 2 | Hi[e.charCodeAt(l + 1)] >> 4, s[o++] = t & 255), i === 1 && (t = Hi[e.charCodeAt(l)] << 10 | Hi[e.charCodeAt(l + 1)] << 4 | Hi[e.charCodeAt(l + 2)] >> 2, s[o++] = t >> 8 & 255, s[o++] = t & 255), s;
}
function Ict(e) {
  return oo[e >> 18 & 63] + oo[e >> 12 & 63] + oo[e >> 6 & 63] + oo[e & 63];
}
function Pct(e, t, r) {
  for (var n, i = [], s = t; s < r; s += 3)
    n = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), i.push(Ict(n));
  return i.join("");
}
function Rct(e) {
  for (var t, r = e.length, n = r % 3, i = [], s = 16383, o = 0, a = r - n; o < a; o += s)
    i.push(Pct(e, o, o + s > a ? a : o + s));
  return n === 1 ? (t = e[r - 1], i.push(
    oo[t >> 2] + oo[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(
    oo[t >> 10] + oo[t >> 4 & 63] + oo[t << 2 & 63] + "="
  )), i.join("");
}
var N5 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
N5.read = function(e, t, r, n, i) {
  var s, o, a = i * 8 - n - 1, l = (1 << a) - 1, c = l >> 1, h = -7, u = r ? i - 1 : 0, p = r ? -1 : 1, y = e[t + u];
  for (u += p, s = y & (1 << -h) - 1, y >>= -h, h += a; h > 0; s = s * 256 + e[t + u], u += p, h -= 8)
    ;
  for (o = s & (1 << -h) - 1, s >>= -h, h += n; h > 0; o = o * 256 + e[t + u], u += p, h -= 8)
    ;
  if (s === 0)
    s = 1 - c;
  else {
    if (s === l)
      return o ? NaN : (y ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, n), s = s - c;
  }
  return (y ? -1 : 1) * o * Math.pow(2, s - n);
};
N5.write = function(e, t, r, n, i, s) {
  var o, a, l, c = s * 8 - i - 1, h = (1 << c) - 1, u = h >> 1, p = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : s - 1, g = n ? 1 : -1, b = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, o = h) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + u >= 1 ? t += p / l : t += p * Math.pow(2, 1 - u), t * l >= 2 && (o++, l /= 2), o + u >= h ? (a = 0, o = h) : o + u >= 1 ? (a = (t * l - 1) * Math.pow(2, i), o = o + u) : (a = t * Math.pow(2, u - 1) * Math.pow(2, i), o = 0)); i >= 8; e[r + y] = a & 255, y += g, a /= 256, i -= 8)
    ;
  for (o = o << i | a, c += i; c > 0; e[r + y] = o & 255, y += g, o /= 256, c -= 8)
    ;
  e[r + y - g] |= b * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = T2, r = N5, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = h, e.SlowBuffer = w, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i;
  const { Uint8Array: s, ArrayBuffer: o, SharedArrayBuffer: a } = globalThis;
  h.TYPED_ARRAY_SUPPORT = l(), !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function l() {
    try {
      const k = new s(1), M = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(M, s.prototype), Object.setPrototypeOf(k, M), k.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(h.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (h.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(h.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (h.isBuffer(this))
        return this.byteOffset;
    }
  });
  function c(k) {
    if (k > i)
      throw new RangeError('The value "' + k + '" is invalid for option "size"');
    const M = new s(k);
    return Object.setPrototypeOf(M, h.prototype), M;
  }
  function h(k, M, B) {
    if (typeof k == "number") {
      if (typeof M == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return g(k);
    }
    return u(k, M, B);
  }
  h.poolSize = 8192;
  function u(k, M, B) {
    if (typeof k == "string")
      return b(k, M);
    if (o.isView(k))
      return E(k);
    if (k == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof k
      );
    if (Se(k, o) || k && Se(k.buffer, o) || typeof a < "u" && (Se(k, a) || k && Se(k.buffer, a)))
      return A(k, M, B);
    if (typeof k == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const it = k.valueOf && k.valueOf();
    if (it != null && it !== k)
      return h.from(it, M, B);
    const ct = x(k);
    if (ct) return ct;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof k[Symbol.toPrimitive] == "function")
      return h.from(k[Symbol.toPrimitive]("string"), M, B);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof k
    );
  }
  h.from = function(k, M, B) {
    return u(k, M, B);
  }, Object.setPrototypeOf(h.prototype, s.prototype), Object.setPrototypeOf(h, s);
  function p(k) {
    if (typeof k != "number")
      throw new TypeError('"size" argument must be of type number');
    if (k < 0)
      throw new RangeError('The value "' + k + '" is invalid for option "size"');
  }
  function y(k, M, B) {
    return p(k), k <= 0 ? c(k) : M !== void 0 ? typeof B == "string" ? c(k).fill(M, B) : c(k).fill(M) : c(k);
  }
  h.alloc = function(k, M, B) {
    return y(k, M, B);
  };
  function g(k) {
    return p(k), c(k < 0 ? 0 : m(k) | 0);
  }
  h.allocUnsafe = function(k) {
    return g(k);
  }, h.allocUnsafeSlow = function(k) {
    return g(k);
  };
  function b(k, M) {
    if ((typeof M != "string" || M === "") && (M = "utf8"), !h.isEncoding(M))
      throw new TypeError("Unknown encoding: " + M);
    const B = _(k, M) | 0;
    let it = c(B);
    const ct = it.write(k, M);
    return ct !== B && (it = it.slice(0, ct)), it;
  }
  function f(k) {
    const M = k.length < 0 ? 0 : m(k.length) | 0, B = c(M);
    for (let it = 0; it < M; it += 1)
      B[it] = k[it] & 255;
    return B;
  }
  function E(k) {
    if (Se(k, s)) {
      const M = new s(k);
      return A(M.buffer, M.byteOffset, M.byteLength);
    }
    return f(k);
  }
  function A(k, M, B) {
    if (M < 0 || k.byteLength < M)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (k.byteLength < M + (B || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let it;
    return M === void 0 && B === void 0 ? it = new s(k) : B === void 0 ? it = new s(k, M) : it = new s(k, M, B), Object.setPrototypeOf(it, h.prototype), it;
  }
  function x(k) {
    if (h.isBuffer(k)) {
      const M = m(k.length) | 0, B = c(M);
      return B.length === 0 || k.copy(B, 0, 0, M), B;
    }
    if (k.length !== void 0)
      return typeof k.length != "number" || Kt(k.length) ? c(0) : f(k);
    if (k.type === "Buffer" && Array.isArray(k.data))
      return f(k.data);
  }
  function m(k) {
    if (k >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return k | 0;
  }
  function w(k) {
    return +k != k && (k = 0), h.alloc(+k);
  }
  h.isBuffer = function(k) {
    return k != null && k._isBuffer === !0 && k !== h.prototype;
  }, h.compare = function(k, M) {
    if (Se(k, s) && (k = h.from(k, k.offset, k.byteLength)), Se(M, s) && (M = h.from(M, M.offset, M.byteLength)), !h.isBuffer(k) || !h.isBuffer(M))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (k === M) return 0;
    let B = k.length, it = M.length;
    for (let ct = 0, Et = Math.min(B, it); ct < Et; ++ct)
      if (k[ct] !== M[ct]) {
        B = k[ct], it = M[ct];
        break;
      }
    return B < it ? -1 : it < B ? 1 : 0;
  }, h.isEncoding = function(k) {
    switch (String(k).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, h.concat = function(k, M) {
    if (!Array.isArray(k))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (k.length === 0)
      return h.alloc(0);
    let B;
    if (M === void 0)
      for (M = 0, B = 0; B < k.length; ++B)
        M += k[B].length;
    const it = h.allocUnsafe(M);
    let ct = 0;
    for (B = 0; B < k.length; ++B) {
      let Et = k[B];
      if (Se(Et, s))
        ct + Et.length > it.length ? (h.isBuffer(Et) || (Et = h.from(Et)), Et.copy(it, ct)) : s.prototype.set.call(
          it,
          Et,
          ct
        );
      else if (h.isBuffer(Et))
        Et.copy(it, ct);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ct += Et.length;
    }
    return it;
  };
  function _(k, M) {
    if (h.isBuffer(k))
      return k.length;
    if (o.isView(k) || Se(k, o))
      return k.byteLength;
    if (typeof k != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof k
      );
    const B = k.length, it = arguments.length > 2 && arguments[2] === !0;
    if (!it && B === 0) return 0;
    let ct = !1;
    for (; ; )
      switch (M) {
        case "ascii":
        case "latin1":
        case "binary":
          return B;
        case "utf8":
        case "utf-8":
          return _e(k).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return B * 2;
        case "hex":
          return B >>> 1;
        case "base64":
          return le(k).length;
        default:
          if (ct)
            return it ? -1 : _e(k).length;
          M = ("" + M).toLowerCase(), ct = !0;
      }
  }
  h.byteLength = _;
  function S(k, M, B) {
    let it = !1;
    if ((M === void 0 || M < 0) && (M = 0), M > this.length || ((B === void 0 || B > this.length) && (B = this.length), B <= 0) || (B >>>= 0, M >>>= 0, B <= M))
      return "";
    for (k || (k = "utf8"); ; )
      switch (k) {
        case "hex":
          return lt(this, M, B);
        case "utf8":
        case "utf-8":
          return vt(this, M, B);
        case "ascii":
          return It(this, M, B);
        case "latin1":
        case "binary":
          return jt(this, M, B);
        case "base64":
          return pt(this, M, B);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return L(this, M, B);
        default:
          if (it) throw new TypeError("Unknown encoding: " + k);
          k = (k + "").toLowerCase(), it = !0;
      }
  }
  h.prototype._isBuffer = !0;
  function R(k, M, B) {
    const it = k[M];
    k[M] = k[B], k[B] = it;
  }
  h.prototype.swap16 = function() {
    const k = this.length;
    if (k % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let M = 0; M < k; M += 2)
      R(this, M, M + 1);
    return this;
  }, h.prototype.swap32 = function() {
    const k = this.length;
    if (k % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let M = 0; M < k; M += 4)
      R(this, M, M + 3), R(this, M + 1, M + 2);
    return this;
  }, h.prototype.swap64 = function() {
    const k = this.length;
    if (k % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let M = 0; M < k; M += 8)
      R(this, M, M + 7), R(this, M + 1, M + 6), R(this, M + 2, M + 5), R(this, M + 3, M + 4);
    return this;
  }, h.prototype.toString = function() {
    const k = this.length;
    return k === 0 ? "" : arguments.length === 0 ? vt(this, 0, k) : S.apply(this, arguments);
  }, h.prototype.toLocaleString = h.prototype.toString, h.prototype.equals = function(k) {
    if (!h.isBuffer(k)) throw new TypeError("Argument must be a Buffer");
    return this === k ? !0 : h.compare(this, k) === 0;
  }, h.prototype.inspect = function() {
    let k = "";
    const M = e.INSPECT_MAX_BYTES;
    return k = this.toString("hex", 0, M).replace(/(.{2})/g, "$1 ").trim(), this.length > M && (k += " ... "), "<Buffer " + k + ">";
  }, n && (h.prototype[n] = h.prototype.inspect), h.prototype.compare = function(k, M, B, it, ct) {
    if (Se(k, s) && (k = h.from(k, k.offset, k.byteLength)), !h.isBuffer(k))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof k
      );
    if (M === void 0 && (M = 0), B === void 0 && (B = k ? k.length : 0), it === void 0 && (it = 0), ct === void 0 && (ct = this.length), M < 0 || B > k.length || it < 0 || ct > this.length)
      throw new RangeError("out of range index");
    if (it >= ct && M >= B)
      return 0;
    if (it >= ct)
      return -1;
    if (M >= B)
      return 1;
    if (M >>>= 0, B >>>= 0, it >>>= 0, ct >>>= 0, this === k) return 0;
    let Et = ct - it, Mt = B - M;
    const se = Math.min(Et, Mt), de = this.slice(it, ct), ke = k.slice(M, B);
    for (let Xt = 0; Xt < se; ++Xt)
      if (de[Xt] !== ke[Xt]) {
        Et = de[Xt], Mt = ke[Xt];
        break;
      }
    return Et < Mt ? -1 : Mt < Et ? 1 : 0;
  };
  function O(k, M, B, it, ct) {
    if (k.length === 0) return -1;
    if (typeof B == "string" ? (it = B, B = 0) : B > 2147483647 ? B = 2147483647 : B < -2147483648 && (B = -2147483648), B = +B, Kt(B) && (B = ct ? 0 : k.length - 1), B < 0 && (B = k.length + B), B >= k.length) {
      if (ct) return -1;
      B = k.length - 1;
    } else if (B < 0)
      if (ct) B = 0;
      else return -1;
    if (typeof M == "string" && (M = h.from(M, it)), h.isBuffer(M))
      return M.length === 0 ? -1 : $(k, M, B, it, ct);
    if (typeof M == "number")
      return M = M & 255, typeof s.prototype.indexOf == "function" ? ct ? s.prototype.indexOf.call(k, M, B) : s.prototype.lastIndexOf.call(k, M, B) : $(k, [M], B, it, ct);
    throw new TypeError("val must be string, number or Buffer");
  }
  function $(k, M, B, it, ct) {
    let Et = 1, Mt = k.length, se = M.length;
    if (it !== void 0 && (it = String(it).toLowerCase(), it === "ucs2" || it === "ucs-2" || it === "utf16le" || it === "utf-16le")) {
      if (k.length < 2 || M.length < 2)
        return -1;
      Et = 2, Mt /= 2, se /= 2, B /= 2;
    }
    function de(Xt, ze) {
      return Et === 1 ? Xt[ze] : Xt.readUInt16BE(ze * Et);
    }
    let ke;
    if (ct) {
      let Xt = -1;
      for (ke = B; ke < Mt; ke++)
        if (de(k, ke) === de(M, Xt === -1 ? 0 : ke - Xt)) {
          if (Xt === -1 && (Xt = ke), ke - Xt + 1 === se) return Xt * Et;
        } else
          Xt !== -1 && (ke -= ke - Xt), Xt = -1;
    } else
      for (B + se > Mt && (B = Mt - se), ke = B; ke >= 0; ke--) {
        let Xt = !0;
        for (let ze = 0; ze < se; ze++)
          if (de(k, ke + ze) !== de(M, ze)) {
            Xt = !1;
            break;
          }
        if (Xt) return ke;
      }
    return -1;
  }
  h.prototype.includes = function(k, M, B) {
    return this.indexOf(k, M, B) !== -1;
  }, h.prototype.indexOf = function(k, M, B) {
    return O(this, k, M, B, !0);
  }, h.prototype.lastIndexOf = function(k, M, B) {
    return O(this, k, M, B, !1);
  };
  function z(k, M, B, it) {
    B = Number(B) || 0;
    const ct = k.length - B;
    it ? (it = Number(it), it > ct && (it = ct)) : it = ct;
    const Et = M.length;
    it > Et / 2 && (it = Et / 2);
    let Mt;
    for (Mt = 0; Mt < it; ++Mt) {
      const se = parseInt(M.substr(Mt * 2, 2), 16);
      if (Kt(se)) return Mt;
      k[B + Mt] = se;
    }
    return Mt;
  }
  function F(k, M, B, it) {
    return te(_e(M, k.length - B), k, B, it);
  }
  function Y(k, M, B, it) {
    return te(Ye(M), k, B, it);
  }
  function rt(k, M, B, it) {
    return te(le(M), k, B, it);
  }
  function at(k, M, B, it) {
    return te(wt(M, k.length - B), k, B, it);
  }
  h.prototype.write = function(k, M, B, it) {
    if (M === void 0)
      it = "utf8", B = this.length, M = 0;
    else if (B === void 0 && typeof M == "string")
      it = M, B = this.length, M = 0;
    else if (isFinite(M))
      M = M >>> 0, isFinite(B) ? (B = B >>> 0, it === void 0 && (it = "utf8")) : (it = B, B = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ct = this.length - M;
    if ((B === void 0 || B > ct) && (B = ct), k.length > 0 && (B < 0 || M < 0) || M > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    it || (it = "utf8");
    let Et = !1;
    for (; ; )
      switch (it) {
        case "hex":
          return z(this, k, M, B);
        case "utf8":
        case "utf-8":
          return F(this, k, M, B);
        case "ascii":
        case "latin1":
        case "binary":
          return Y(this, k, M, B);
        case "base64":
          return rt(this, k, M, B);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return at(this, k, M, B);
        default:
          if (Et) throw new TypeError("Unknown encoding: " + it);
          it = ("" + it).toLowerCase(), Et = !0;
      }
  }, h.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function pt(k, M, B) {
    return M === 0 && B === k.length ? t.fromByteArray(k) : t.fromByteArray(k.slice(M, B));
  }
  function vt(k, M, B) {
    B = Math.min(k.length, B);
    const it = [];
    let ct = M;
    for (; ct < B; ) {
      const Et = k[ct];
      let Mt = null, se = Et > 239 ? 4 : Et > 223 ? 3 : Et > 191 ? 2 : 1;
      if (ct + se <= B) {
        let de, ke, Xt, ze;
        switch (se) {
          case 1:
            Et < 128 && (Mt = Et);
            break;
          case 2:
            de = k[ct + 1], (de & 192) === 128 && (ze = (Et & 31) << 6 | de & 63, ze > 127 && (Mt = ze));
            break;
          case 3:
            de = k[ct + 1], ke = k[ct + 2], (de & 192) === 128 && (ke & 192) === 128 && (ze = (Et & 15) << 12 | (de & 63) << 6 | ke & 63, ze > 2047 && (ze < 55296 || ze > 57343) && (Mt = ze));
            break;
          case 4:
            de = k[ct + 1], ke = k[ct + 2], Xt = k[ct + 3], (de & 192) === 128 && (ke & 192) === 128 && (Xt & 192) === 128 && (ze = (Et & 15) << 18 | (de & 63) << 12 | (ke & 63) << 6 | Xt & 63, ze > 65535 && ze < 1114112 && (Mt = ze));
        }
      }
      Mt === null ? (Mt = 65533, se = 1) : Mt > 65535 && (Mt -= 65536, it.push(Mt >>> 10 & 1023 | 55296), Mt = 56320 | Mt & 1023), it.push(Mt), ct += se;
    }
    return Ct(it);
  }
  const _t = 4096;
  function Ct(k) {
    const M = k.length;
    if (M <= _t)
      return String.fromCharCode.apply(String, k);
    let B = "", it = 0;
    for (; it < M; )
      B += String.fromCharCode.apply(
        String,
        k.slice(it, it += _t)
      );
    return B;
  }
  function It(k, M, B) {
    let it = "";
    B = Math.min(k.length, B);
    for (let ct = M; ct < B; ++ct)
      it += String.fromCharCode(k[ct] & 127);
    return it;
  }
  function jt(k, M, B) {
    let it = "";
    B = Math.min(k.length, B);
    for (let ct = M; ct < B; ++ct)
      it += String.fromCharCode(k[ct]);
    return it;
  }
  function lt(k, M, B) {
    const it = k.length;
    (!M || M < 0) && (M = 0), (!B || B < 0 || B > it) && (B = it);
    let ct = "";
    for (let Et = M; Et < B; ++Et)
      ct += bt[k[Et]];
    return ct;
  }
  function L(k, M, B) {
    const it = k.slice(M, B);
    let ct = "";
    for (let Et = 0; Et < it.length - 1; Et += 2)
      ct += String.fromCharCode(it[Et] + it[Et + 1] * 256);
    return ct;
  }
  h.prototype.slice = function(k, M) {
    const B = this.length;
    k = ~~k, M = M === void 0 ? B : ~~M, k < 0 ? (k += B, k < 0 && (k = 0)) : k > B && (k = B), M < 0 ? (M += B, M < 0 && (M = 0)) : M > B && (M = B), M < k && (M = k);
    const it = this.subarray(k, M);
    return Object.setPrototypeOf(it, h.prototype), it;
  };
  function D(k, M, B) {
    if (k % 1 !== 0 || k < 0) throw new RangeError("offset is not uint");
    if (k + M > B) throw new RangeError("Trying to access beyond buffer length");
  }
  h.prototype.readUintLE = h.prototype.readUIntLE = function(k, M, B) {
    k = k >>> 0, M = M >>> 0, B || D(k, M, this.length);
    let it = this[k], ct = 1, Et = 0;
    for (; ++Et < M && (ct *= 256); )
      it += this[k + Et] * ct;
    return it;
  }, h.prototype.readUintBE = h.prototype.readUIntBE = function(k, M, B) {
    k = k >>> 0, M = M >>> 0, B || D(k, M, this.length);
    let it = this[k + --M], ct = 1;
    for (; M > 0 && (ct *= 256); )
      it += this[k + --M] * ct;
    return it;
  }, h.prototype.readUint8 = h.prototype.readUInt8 = function(k, M) {
    return k = k >>> 0, M || D(k, 1, this.length), this[k];
  }, h.prototype.readUint16LE = h.prototype.readUInt16LE = function(k, M) {
    return k = k >>> 0, M || D(k, 2, this.length), this[k] | this[k + 1] << 8;
  }, h.prototype.readUint16BE = h.prototype.readUInt16BE = function(k, M) {
    return k = k >>> 0, M || D(k, 2, this.length), this[k] << 8 | this[k + 1];
  }, h.prototype.readUint32LE = h.prototype.readUInt32LE = function(k, M) {
    return k = k >>> 0, M || D(k, 4, this.length), (this[k] | this[k + 1] << 8 | this[k + 2] << 16) + this[k + 3] * 16777216;
  }, h.prototype.readUint32BE = h.prototype.readUInt32BE = function(k, M) {
    return k = k >>> 0, M || D(k, 4, this.length), this[k] * 16777216 + (this[k + 1] << 16 | this[k + 2] << 8 | this[k + 3]);
  }, h.prototype.readBigUInt64LE = xt(function(k) {
    k = k >>> 0, Tt(k, "offset");
    const M = this[k], B = this[k + 7];
    (M === void 0 || B === void 0) && Yt(k, this.length - 8);
    const it = M + this[++k] * 2 ** 8 + this[++k] * 2 ** 16 + this[++k] * 2 ** 24, ct = this[++k] + this[++k] * 2 ** 8 + this[++k] * 2 ** 16 + B * 2 ** 24;
    return BigInt(it) + (BigInt(ct) << BigInt(32));
  }), h.prototype.readBigUInt64BE = xt(function(k) {
    k = k >>> 0, Tt(k, "offset");
    const M = this[k], B = this[k + 7];
    (M === void 0 || B === void 0) && Yt(k, this.length - 8);
    const it = M * 2 ** 24 + this[++k] * 2 ** 16 + this[++k] * 2 ** 8 + this[++k], ct = this[++k] * 2 ** 24 + this[++k] * 2 ** 16 + this[++k] * 2 ** 8 + B;
    return (BigInt(it) << BigInt(32)) + BigInt(ct);
  }), h.prototype.readIntLE = function(k, M, B) {
    k = k >>> 0, M = M >>> 0, B || D(k, M, this.length);
    let it = this[k], ct = 1, Et = 0;
    for (; ++Et < M && (ct *= 256); )
      it += this[k + Et] * ct;
    return ct *= 128, it >= ct && (it -= Math.pow(2, 8 * M)), it;
  }, h.prototype.readIntBE = function(k, M, B) {
    k = k >>> 0, M = M >>> 0, B || D(k, M, this.length);
    let it = M, ct = 1, Et = this[k + --it];
    for (; it > 0 && (ct *= 256); )
      Et += this[k + --it] * ct;
    return ct *= 128, Et >= ct && (Et -= Math.pow(2, 8 * M)), Et;
  }, h.prototype.readInt8 = function(k, M) {
    return k = k >>> 0, M || D(k, 1, this.length), this[k] & 128 ? (255 - this[k] + 1) * -1 : this[k];
  }, h.prototype.readInt16LE = function(k, M) {
    k = k >>> 0, M || D(k, 2, this.length);
    const B = this[k] | this[k + 1] << 8;
    return B & 32768 ? B | 4294901760 : B;
  }, h.prototype.readInt16BE = function(k, M) {
    k = k >>> 0, M || D(k, 2, this.length);
    const B = this[k + 1] | this[k] << 8;
    return B & 32768 ? B | 4294901760 : B;
  }, h.prototype.readInt32LE = function(k, M) {
    return k = k >>> 0, M || D(k, 4, this.length), this[k] | this[k + 1] << 8 | this[k + 2] << 16 | this[k + 3] << 24;
  }, h.prototype.readInt32BE = function(k, M) {
    return k = k >>> 0, M || D(k, 4, this.length), this[k] << 24 | this[k + 1] << 16 | this[k + 2] << 8 | this[k + 3];
  }, h.prototype.readBigInt64LE = xt(function(k) {
    k = k >>> 0, Tt(k, "offset");
    const M = this[k], B = this[k + 7];
    (M === void 0 || B === void 0) && Yt(k, this.length - 8);
    const it = this[k + 4] + this[k + 5] * 2 ** 8 + this[k + 6] * 2 ** 16 + (B << 24);
    return (BigInt(it) << BigInt(32)) + BigInt(M + this[++k] * 2 ** 8 + this[++k] * 2 ** 16 + this[++k] * 2 ** 24);
  }), h.prototype.readBigInt64BE = xt(function(k) {
    k = k >>> 0, Tt(k, "offset");
    const M = this[k], B = this[k + 7];
    (M === void 0 || B === void 0) && Yt(k, this.length - 8);
    const it = (M << 24) + // Overflow
    this[++k] * 2 ** 16 + this[++k] * 2 ** 8 + this[++k];
    return (BigInt(it) << BigInt(32)) + BigInt(this[++k] * 2 ** 24 + this[++k] * 2 ** 16 + this[++k] * 2 ** 8 + B);
  }), h.prototype.readFloatLE = function(k, M) {
    return k = k >>> 0, M || D(k, 4, this.length), r.read(this, k, !0, 23, 4);
  }, h.prototype.readFloatBE = function(k, M) {
    return k = k >>> 0, M || D(k, 4, this.length), r.read(this, k, !1, 23, 4);
  }, h.prototype.readDoubleLE = function(k, M) {
    return k = k >>> 0, M || D(k, 8, this.length), r.read(this, k, !0, 52, 8);
  }, h.prototype.readDoubleBE = function(k, M) {
    return k = k >>> 0, M || D(k, 8, this.length), r.read(this, k, !1, 52, 8);
  };
  function tt(k, M, B, it, ct, Et) {
    if (!h.isBuffer(k)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (M > ct || M < Et) throw new RangeError('"value" argument is out of bounds');
    if (B + it > k.length) throw new RangeError("Index out of range");
  }
  h.prototype.writeUintLE = h.prototype.writeUIntLE = function(k, M, B, it) {
    if (k = +k, M = M >>> 0, B = B >>> 0, !it) {
      const Mt = Math.pow(2, 8 * B) - 1;
      tt(this, k, M, B, Mt, 0);
    }
    let ct = 1, Et = 0;
    for (this[M] = k & 255; ++Et < B && (ct *= 256); )
      this[M + Et] = k / ct & 255;
    return M + B;
  }, h.prototype.writeUintBE = h.prototype.writeUIntBE = function(k, M, B, it) {
    if (k = +k, M = M >>> 0, B = B >>> 0, !it) {
      const Mt = Math.pow(2, 8 * B) - 1;
      tt(this, k, M, B, Mt, 0);
    }
    let ct = B - 1, Et = 1;
    for (this[M + ct] = k & 255; --ct >= 0 && (Et *= 256); )
      this[M + ct] = k / Et & 255;
    return M + B;
  }, h.prototype.writeUint8 = h.prototype.writeUInt8 = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 1, 255, 0), this[M] = k & 255, M + 1;
  }, h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 2, 65535, 0), this[M] = k & 255, this[M + 1] = k >>> 8, M + 2;
  }, h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 2, 65535, 0), this[M] = k >>> 8, this[M + 1] = k & 255, M + 2;
  }, h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 4, 4294967295, 0), this[M + 3] = k >>> 24, this[M + 2] = k >>> 16, this[M + 1] = k >>> 8, this[M] = k & 255, M + 4;
  }, h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 4, 4294967295, 0), this[M] = k >>> 24, this[M + 1] = k >>> 16, this[M + 2] = k >>> 8, this[M + 3] = k & 255, M + 4;
  };
  function et(k, M, B, it, ct) {
    zt(M, it, ct, k, B, 7);
    let Et = Number(M & BigInt(4294967295));
    k[B++] = Et, Et = Et >> 8, k[B++] = Et, Et = Et >> 8, k[B++] = Et, Et = Et >> 8, k[B++] = Et;
    let Mt = Number(M >> BigInt(32) & BigInt(4294967295));
    return k[B++] = Mt, Mt = Mt >> 8, k[B++] = Mt, Mt = Mt >> 8, k[B++] = Mt, Mt = Mt >> 8, k[B++] = Mt, B;
  }
  function st(k, M, B, it, ct) {
    zt(M, it, ct, k, B, 7);
    let Et = Number(M & BigInt(4294967295));
    k[B + 7] = Et, Et = Et >> 8, k[B + 6] = Et, Et = Et >> 8, k[B + 5] = Et, Et = Et >> 8, k[B + 4] = Et;
    let Mt = Number(M >> BigInt(32) & BigInt(4294967295));
    return k[B + 3] = Mt, Mt = Mt >> 8, k[B + 2] = Mt, Mt = Mt >> 8, k[B + 1] = Mt, Mt = Mt >> 8, k[B] = Mt, B + 8;
  }
  h.prototype.writeBigUInt64LE = xt(function(k, M = 0) {
    return et(this, k, M, BigInt(0), BigInt("0xffffffffffffffff"));
  }), h.prototype.writeBigUInt64BE = xt(function(k, M = 0) {
    return st(this, k, M, BigInt(0), BigInt("0xffffffffffffffff"));
  }), h.prototype.writeIntLE = function(k, M, B, it) {
    if (k = +k, M = M >>> 0, !it) {
      const se = Math.pow(2, 8 * B - 1);
      tt(this, k, M, B, se - 1, -se);
    }
    let ct = 0, Et = 1, Mt = 0;
    for (this[M] = k & 255; ++ct < B && (Et *= 256); )
      k < 0 && Mt === 0 && this[M + ct - 1] !== 0 && (Mt = 1), this[M + ct] = (k / Et >> 0) - Mt & 255;
    return M + B;
  }, h.prototype.writeIntBE = function(k, M, B, it) {
    if (k = +k, M = M >>> 0, !it) {
      const se = Math.pow(2, 8 * B - 1);
      tt(this, k, M, B, se - 1, -se);
    }
    let ct = B - 1, Et = 1, Mt = 0;
    for (this[M + ct] = k & 255; --ct >= 0 && (Et *= 256); )
      k < 0 && Mt === 0 && this[M + ct + 1] !== 0 && (Mt = 1), this[M + ct] = (k / Et >> 0) - Mt & 255;
    return M + B;
  }, h.prototype.writeInt8 = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 1, 127, -128), k < 0 && (k = 255 + k + 1), this[M] = k & 255, M + 1;
  }, h.prototype.writeInt16LE = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 2, 32767, -32768), this[M] = k & 255, this[M + 1] = k >>> 8, M + 2;
  }, h.prototype.writeInt16BE = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 2, 32767, -32768), this[M] = k >>> 8, this[M + 1] = k & 255, M + 2;
  }, h.prototype.writeInt32LE = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 4, 2147483647, -2147483648), this[M] = k & 255, this[M + 1] = k >>> 8, this[M + 2] = k >>> 16, this[M + 3] = k >>> 24, M + 4;
  }, h.prototype.writeInt32BE = function(k, M, B) {
    return k = +k, M = M >>> 0, B || tt(this, k, M, 4, 2147483647, -2147483648), k < 0 && (k = 4294967295 + k + 1), this[M] = k >>> 24, this[M + 1] = k >>> 16, this[M + 2] = k >>> 8, this[M + 3] = k & 255, M + 4;
  }, h.prototype.writeBigInt64LE = xt(function(k, M = 0) {
    return et(this, k, M, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), h.prototype.writeBigInt64BE = xt(function(k, M = 0) {
    return st(this, k, M, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function X(k, M, B, it, ct, Et) {
    if (B + it > k.length) throw new RangeError("Index out of range");
    if (B < 0) throw new RangeError("Index out of range");
  }
  function ot(k, M, B, it, ct) {
    return M = +M, B = B >>> 0, ct || X(k, M, B, 4), r.write(k, M, B, it, 23, 4), B + 4;
  }
  h.prototype.writeFloatLE = function(k, M, B) {
    return ot(this, k, M, !0, B);
  }, h.prototype.writeFloatBE = function(k, M, B) {
    return ot(this, k, M, !1, B);
  };
  function mt(k, M, B, it, ct) {
    return M = +M, B = B >>> 0, ct || X(k, M, B, 8), r.write(k, M, B, it, 52, 8), B + 8;
  }
  h.prototype.writeDoubleLE = function(k, M, B) {
    return mt(this, k, M, !0, B);
  }, h.prototype.writeDoubleBE = function(k, M, B) {
    return mt(this, k, M, !1, B);
  }, h.prototype.copy = function(k, M, B, it) {
    if (!h.isBuffer(k)) throw new TypeError("argument should be a Buffer");
    if (B || (B = 0), !it && it !== 0 && (it = this.length), M >= k.length && (M = k.length), M || (M = 0), it > 0 && it < B && (it = B), it === B || k.length === 0 || this.length === 0) return 0;
    if (M < 0)
      throw new RangeError("targetStart out of bounds");
    if (B < 0 || B >= this.length) throw new RangeError("Index out of range");
    if (it < 0) throw new RangeError("sourceEnd out of bounds");
    it > this.length && (it = this.length), k.length - M < it - B && (it = k.length - M + B);
    const ct = it - B;
    return this === k && typeof s.prototype.copyWithin == "function" ? this.copyWithin(M, B, it) : s.prototype.set.call(
      k,
      this.subarray(B, it),
      M
    ), ct;
  }, h.prototype.fill = function(k, M, B, it) {
    if (typeof k == "string") {
      if (typeof M == "string" ? (it = M, M = 0, B = this.length) : typeof B == "string" && (it = B, B = this.length), it !== void 0 && typeof it != "string")
        throw new TypeError("encoding must be a string");
      if (typeof it == "string" && !h.isEncoding(it))
        throw new TypeError("Unknown encoding: " + it);
      if (k.length === 1) {
        const Et = k.charCodeAt(0);
        (it === "utf8" && Et < 128 || it === "latin1") && (k = Et);
      }
    } else typeof k == "number" ? k = k & 255 : typeof k == "boolean" && (k = Number(k));
    if (M < 0 || this.length < M || this.length < B)
      throw new RangeError("Out of range index");
    if (B <= M)
      return this;
    M = M >>> 0, B = B === void 0 ? this.length : B >>> 0, k || (k = 0);
    let ct;
    if (typeof k == "number")
      for (ct = M; ct < B; ++ct)
        this[ct] = k;
    else {
      const Et = h.isBuffer(k) ? k : h.from(k, it), Mt = Et.length;
      if (Mt === 0)
        throw new TypeError('The value "' + k + '" is invalid for argument "value"');
      for (ct = 0; ct < B - M; ++ct)
        this[ct + M] = Et[ct % Mt];
    }
    return this;
  };
  const U = {};
  function J(k, M, B) {
    U[k] = class extends B {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: M.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${k}]`, this.stack, delete this.name;
      }
      get code() {
        return k;
      }
      set code(it) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: it,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${k}]: ${this.message}`;
      }
    };
  }
  J(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(k) {
      return k ? `${k} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), J(
    "ERR_INVALID_ARG_TYPE",
    function(k, M) {
      return `The "${k}" argument must be of type number. Received type ${typeof M}`;
    },
    TypeError
  ), J(
    "ERR_OUT_OF_RANGE",
    function(k, M, B) {
      let it = `The value of "${k}" is out of range.`, ct = B;
      return Number.isInteger(B) && Math.abs(B) > 2 ** 32 ? ct = St(String(B)) : typeof B == "bigint" && (ct = String(B), (B > BigInt(2) ** BigInt(32) || B < -(BigInt(2) ** BigInt(32))) && (ct = St(ct)), ct += "n"), it += ` It must be ${M}. Received ${ct}`, it;
    },
    RangeError
  );
  function St(k) {
    let M = "", B = k.length;
    const it = k[0] === "-" ? 1 : 0;
    for (; B >= it + 4; B -= 3)
      M = `_${k.slice(B - 3, B)}${M}`;
    return `${k.slice(0, B)}${M}`;
  }
  function Rt(k, M, B) {
    Tt(M, "offset"), (k[M] === void 0 || k[M + B] === void 0) && Yt(M, k.length - (B + 1));
  }
  function zt(k, M, B, it, ct, Et) {
    if (k > B || k < M) {
      const Mt = typeof M == "bigint" ? "n" : "";
      let se;
      throw M === 0 || M === BigInt(0) ? se = `>= 0${Mt} and < 2${Mt} ** ${(Et + 1) * 8}${Mt}` : se = `>= -(2${Mt} ** ${(Et + 1) * 8 - 1}${Mt}) and < 2 ** ${(Et + 1) * 8 - 1}${Mt}`, new U.ERR_OUT_OF_RANGE("value", se, k);
    }
    Rt(it, ct, Et);
  }
  function Tt(k, M) {
    if (typeof k != "number")
      throw new U.ERR_INVALID_ARG_TYPE(M, "number", k);
  }
  function Yt(k, M, B) {
    throw Math.floor(k) !== k ? (Tt(k, B), new U.ERR_OUT_OF_RANGE("offset", "an integer", k)) : M < 0 ? new U.ERR_BUFFER_OUT_OF_BOUNDS() : new U.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${M}`,
      k
    );
  }
  const Zt = /[^+/0-9A-Za-z-_]/g;
  function kt(k) {
    if (k = k.split("=")[0], k = k.trim().replace(Zt, ""), k.length < 2) return "";
    for (; k.length % 4 !== 0; )
      k = k + "=";
    return k;
  }
  function _e(k, M) {
    M = M || 1 / 0;
    let B;
    const it = k.length;
    let ct = null;
    const Et = [];
    for (let Mt = 0; Mt < it; ++Mt) {
      if (B = k.charCodeAt(Mt), B > 55295 && B < 57344) {
        if (!ct) {
          if (B > 56319) {
            (M -= 3) > -1 && Et.push(239, 191, 189);
            continue;
          } else if (Mt + 1 === it) {
            (M -= 3) > -1 && Et.push(239, 191, 189);
            continue;
          }
          ct = B;
          continue;
        }
        if (B < 56320) {
          (M -= 3) > -1 && Et.push(239, 191, 189), ct = B;
          continue;
        }
        B = (ct - 55296 << 10 | B - 56320) + 65536;
      } else ct && (M -= 3) > -1 && Et.push(239, 191, 189);
      if (ct = null, B < 128) {
        if ((M -= 1) < 0) break;
        Et.push(B);
      } else if (B < 2048) {
        if ((M -= 2) < 0) break;
        Et.push(
          B >> 6 | 192,
          B & 63 | 128
        );
      } else if (B < 65536) {
        if ((M -= 3) < 0) break;
        Et.push(
          B >> 12 | 224,
          B >> 6 & 63 | 128,
          B & 63 | 128
        );
      } else if (B < 1114112) {
        if ((M -= 4) < 0) break;
        Et.push(
          B >> 18 | 240,
          B >> 12 & 63 | 128,
          B >> 6 & 63 | 128,
          B & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Et;
  }
  function Ye(k) {
    const M = [];
    for (let B = 0; B < k.length; ++B)
      M.push(k.charCodeAt(B) & 255);
    return M;
  }
  function wt(k, M) {
    let B, it, ct;
    const Et = [];
    for (let Mt = 0; Mt < k.length && !((M -= 2) < 0); ++Mt)
      B = k.charCodeAt(Mt), it = B >> 8, ct = B % 256, Et.push(ct), Et.push(it);
    return Et;
  }
  function le(k) {
    return t.toByteArray(kt(k));
  }
  function te(k, M, B, it) {
    let ct;
    for (ct = 0; ct < it && !(ct + B >= M.length || ct >= k.length); ++ct)
      M[ct + B] = k[ct];
    return ct;
  }
  function Se(k, M) {
    return k instanceof M || k != null && k.constructor != null && k.constructor.name != null && k.constructor.name === M.name;
  }
  function Kt(k) {
    return k !== k;
  }
  const bt = function() {
    const k = "0123456789abcdef", M = new Array(256);
    for (let B = 0; B < 16; ++B) {
      const it = B * 16;
      for (let ct = 0; ct < 16; ++ct)
        M[it + ct] = k[B] + k[ct];
    }
    return M;
  }();
  function xt(k) {
    return typeof BigInt > "u" ? Jt : k;
  }
  function Jt() {
    throw new Error("BigInt not supported");
  }
})(zM);
const eu = zM.Buffer;
var Ov, S7;
function UM() {
  if (S7) return Ov;
  S7 = 1;
  const e = (o, a, l) => {
    const c = o.length, h = l.length, u = o.substring(0, a), p = o.substring(a + h, c);
    return [u, p];
  }, t = (o, a, l) => {
    const c = o.length, h = l.length, u = eu.alloc(a);
    o.copy(u, 0, 0, a);
    const p = eu.alloc(c - a - h);
    return o.copy(p, 0, a + h, c), [u, p];
  }, r = (o, a) => {
    const l = o.indexOf(a);
    let c = e;
    if (l < 0)
      return [o];
    eu.isBuffer(o) && (c = t);
    const [h, u] = c(o, l, a);
    let p = [];
    return h.length > 0 && (p = [h]), p = [...p, a], u.length > 0 && (p = [...p, u]), p;
  }, n = (o, a) => {
    const l = r(o, a);
    return l.length <= 1 ? l : l.length <= 2 ? [l[0], ...n(l[1], a)] : [l[0], l[1], ...n(l[2], a)];
  }, i = (o, a) => o.flatMap((l) => n(l, a)), s = (o, a) => {
    if (a.length <= 0)
      return o;
    const l = i(o, a[0]);
    return s(l, a.slice(1));
  };
  return Ov = (o, ...a) => s([o], a), Ov;
}
var Jg = { exports: {} }, _7;
function D5() {
  if (_7) return Jg.exports;
  _7 = 1;
  var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(m, w, _) {
    return Function.prototype.apply.call(m, w, _);
  }, r;
  e && typeof e.ownKeys == "function" ? r = e.ownKeys : Object.getOwnPropertySymbols ? r = function(m) {
    return Object.getOwnPropertyNames(m).concat(Object.getOwnPropertySymbols(m));
  } : r = function(m) {
    return Object.getOwnPropertyNames(m);
  };
  function n(m) {
    console && console.warn && console.warn(m);
  }
  var i = Number.isNaN || function(m) {
    return m !== m;
  };
  function s() {
    s.init.call(this);
  }
  Jg.exports = s, Jg.exports.once = E, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var o = 10;
  function a(m) {
    if (typeof m != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof m);
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return o;
    },
    set: function(m) {
      if (typeof m != "number" || m < 0 || i(m))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + m + ".");
      o = m;
    }
  }), s.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(m) {
    if (typeof m != "number" || m < 0 || i(m))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + m + ".");
    return this._maxListeners = m, this;
  };
  function l(m) {
    return m._maxListeners === void 0 ? s.defaultMaxListeners : m._maxListeners;
  }
  s.prototype.getMaxListeners = function() {
    return l(this);
  }, s.prototype.emit = function(m) {
    for (var w = [], _ = 1; _ < arguments.length; _++) w.push(arguments[_]);
    var S = m === "error", R = this._events;
    if (R !== void 0)
      S = S && R.error === void 0;
    else if (!S)
      return !1;
    if (S) {
      var O;
      if (w.length > 0 && (O = w[0]), O instanceof Error)
        throw O;
      var $ = new Error("Unhandled error." + (O ? " (" + O.message + ")" : ""));
      throw $.context = O, $;
    }
    var z = R[m];
    if (z === void 0)
      return !1;
    if (typeof z == "function")
      t(z, this, w);
    else
      for (var F = z.length, Y = g(z, F), _ = 0; _ < F; ++_)
        t(Y[_], this, w);
    return !0;
  };
  function c(m, w, _, S) {
    var R, O, $;
    if (a(_), O = m._events, O === void 0 ? (O = m._events = /* @__PURE__ */ Object.create(null), m._eventsCount = 0) : (O.newListener !== void 0 && (m.emit(
      "newListener",
      w,
      _.listener ? _.listener : _
    ), O = m._events), $ = O[w]), $ === void 0)
      $ = O[w] = _, ++m._eventsCount;
    else if (typeof $ == "function" ? $ = O[w] = S ? [_, $] : [$, _] : S ? $.unshift(_) : $.push(_), R = l(m), R > 0 && $.length > R && !$.warned) {
      $.warned = !0;
      var z = new Error("Possible EventEmitter memory leak detected. " + $.length + " " + String(w) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      z.name = "MaxListenersExceededWarning", z.emitter = m, z.type = w, z.count = $.length, n(z);
    }
    return m;
  }
  s.prototype.addListener = function(m, w) {
    return c(this, m, w, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(m, w) {
    return c(this, m, w, !0);
  };
  function h() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function u(m, w, _) {
    var S = { fired: !1, wrapFn: void 0, target: m, type: w, listener: _ }, R = h.bind(S);
    return R.listener = _, S.wrapFn = R, R;
  }
  s.prototype.once = function(m, w) {
    return a(w), this.on(m, u(this, m, w)), this;
  }, s.prototype.prependOnceListener = function(m, w) {
    return a(w), this.prependListener(m, u(this, m, w)), this;
  }, s.prototype.removeListener = function(m, w) {
    var _, S, R, O, $;
    if (a(w), S = this._events, S === void 0)
      return this;
    if (_ = S[m], _ === void 0)
      return this;
    if (_ === w || _.listener === w)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete S[m], S.removeListener && this.emit("removeListener", m, _.listener || w));
    else if (typeof _ != "function") {
      for (R = -1, O = _.length - 1; O >= 0; O--)
        if (_[O] === w || _[O].listener === w) {
          $ = _[O].listener, R = O;
          break;
        }
      if (R < 0)
        return this;
      R === 0 ? _.shift() : b(_, R), _.length === 1 && (S[m] = _[0]), S.removeListener !== void 0 && this.emit("removeListener", m, $ || w);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(m) {
    var w, _, S;
    if (_ = this._events, _ === void 0)
      return this;
    if (_.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : _[m] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete _[m]), this;
    if (arguments.length === 0) {
      var R = Object.keys(_), O;
      for (S = 0; S < R.length; ++S)
        O = R[S], O !== "removeListener" && this.removeAllListeners(O);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (w = _[m], typeof w == "function")
      this.removeListener(m, w);
    else if (w !== void 0)
      for (S = w.length - 1; S >= 0; S--)
        this.removeListener(m, w[S]);
    return this;
  };
  function p(m, w, _) {
    var S = m._events;
    if (S === void 0)
      return [];
    var R = S[w];
    return R === void 0 ? [] : typeof R == "function" ? _ ? [R.listener || R] : [R] : _ ? f(R) : g(R, R.length);
  }
  s.prototype.listeners = function(m) {
    return p(this, m, !0);
  }, s.prototype.rawListeners = function(m) {
    return p(this, m, !1);
  }, s.listenerCount = function(m, w) {
    return typeof m.listenerCount == "function" ? m.listenerCount(w) : y.call(m, w);
  }, s.prototype.listenerCount = y;
  function y(m) {
    var w = this._events;
    if (w !== void 0) {
      var _ = w[m];
      if (typeof _ == "function")
        return 1;
      if (_ !== void 0)
        return _.length;
    }
    return 0;
  }
  s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? r(this._events) : [];
  };
  function g(m, w) {
    for (var _ = new Array(w), S = 0; S < w; ++S)
      _[S] = m[S];
    return _;
  }
  function b(m, w) {
    for (; w + 1 < m.length; w++)
      m[w] = m[w + 1];
    m.pop();
  }
  function f(m) {
    for (var w = new Array(m.length), _ = 0; _ < w.length; ++_)
      w[_] = m[_].listener || m[_];
    return w;
  }
  function E(m, w) {
    return new Promise(function(_, S) {
      function R($) {
        m.removeListener(w, O), S($);
      }
      function O() {
        typeof m.removeListener == "function" && m.removeListener("error", R), _([].slice.call(arguments));
      }
      x(m, w, O, { once: !0 }), w !== "error" && A(m, R, { once: !0 });
    });
  }
  function A(m, w, _) {
    typeof m.on == "function" && x(m, "error", w, _);
  }
  function x(m, w, _, S) {
    if (typeof m.on == "function")
      S.once ? m.once(w, _) : m.on(w, _);
    else if (typeof m.addEventListener == "function")
      m.addEventListener(w, function R(O) {
        S.once && m.removeEventListener(w, R), _(O);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof m);
  }
  return Jg.exports;
}
var Lv = { exports: {} }, k7;
function Zu() {
  return k7 || (k7 = 1, typeof Object.create == "function" ? Lv.exports = function(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Lv.exports = function(e, t) {
    if (t) {
      e.super_ = t;
      var r = function() {
      };
      r.prototype = t.prototype, e.prototype = new r(), e.prototype.constructor = e;
    }
  }), Lv.exports;
}
function Tct(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var HM = { exports: {} }, Nr = HM.exports = {}, to, eo;
function r4() {
  throw new Error("setTimeout has not been defined");
}
function n4() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? to = setTimeout : to = r4;
  } catch {
    to = r4;
  }
  try {
    typeof clearTimeout == "function" ? eo = clearTimeout : eo = n4;
  } catch {
    eo = n4;
  }
})();
function GM(e) {
  if (to === setTimeout)
    return setTimeout(e, 0);
  if ((to === r4 || !to) && setTimeout)
    return to = setTimeout, setTimeout(e, 0);
  try {
    return to(e, 0);
  } catch {
    try {
      return to.call(null, e, 0);
    } catch {
      return to.call(this, e, 0);
    }
  }
}
function Oct(e) {
  if (eo === clearTimeout)
    return clearTimeout(e);
  if ((eo === n4 || !eo) && clearTimeout)
    return eo = clearTimeout, clearTimeout(e);
  try {
    return eo(e);
  } catch {
    try {
      return eo.call(null, e);
    } catch {
      return eo.call(this, e);
    }
  }
}
var Go = [], Qh = !1, ru, M1 = -1;
function Lct() {
  !Qh || !ru || (Qh = !1, ru.length ? Go = ru.concat(Go) : M1 = -1, Go.length && QM());
}
function QM() {
  if (!Qh) {
    var e = GM(Lct);
    Qh = !0;
    for (var t = Go.length; t; ) {
      for (ru = Go, Go = []; ++M1 < t; )
        ru && ru[M1].run();
      M1 = -1, t = Go.length;
    }
    ru = null, Qh = !1, Oct(e);
  }
}
Nr.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  Go.push(new WM(e, t)), Go.length === 1 && !Qh && GM(QM);
};
function WM(e, t) {
  this.fun = e, this.array = t;
}
WM.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Nr.title = "browser";
Nr.browser = !0;
Nr.env = {};
Nr.argv = [];
Nr.version = "";
Nr.versions = {};
function Ia() {
}
Nr.on = Ia;
Nr.addListener = Ia;
Nr.once = Ia;
Nr.off = Ia;
Nr.removeListener = Ia;
Nr.removeAllListeners = Ia;
Nr.emit = Ia;
Nr.prependListener = Ia;
Nr.prependOnceListener = Ia;
Nr.listeners = function(e) {
  return [];
};
Nr.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Nr.cwd = function() {
  return "/";
};
Nr.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Nr.umask = function() {
  return 0;
};
var Mct = HM.exports;
const je = /* @__PURE__ */ Tct(Mct);
var C7, I7;
function qM() {
  return I7 || (I7 = 1, C7 = D5().EventEmitter), C7;
}
var P7 = {}, R7;
function O2() {
  return R7 || (R7 = 1, function(e) {
    Object.defineProperties(e, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
    var t = {}, r = {};
    r.byteLength = h, r.toByteArray = p, r.fromByteArray = b;
    for (var n = [], i = [], s = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, l = o.length; a < l; ++a)
      n[a] = o[a], i[o.charCodeAt(a)] = a;
    i[45] = 62, i[95] = 63;
    function c(A) {
      var x = A.length;
      if (x % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var m = A.indexOf("=");
      m === -1 && (m = x);
      var w = m === x ? 0 : 4 - m % 4;
      return [m, w];
    }
    function h(A) {
      var x = c(A), m = x[0], w = x[1];
      return (m + w) * 3 / 4 - w;
    }
    function u(A, x, m) {
      return (x + m) * 3 / 4 - m;
    }
    function p(A) {
      var x, m = c(A), w = m[0], _ = m[1], S = new s(u(A, w, _)), R = 0, O = _ > 0 ? w - 4 : w, $;
      for ($ = 0; $ < O; $ += 4)
        x = i[A.charCodeAt($)] << 18 | i[A.charCodeAt($ + 1)] << 12 | i[A.charCodeAt($ + 2)] << 6 | i[A.charCodeAt($ + 3)], S[R++] = x >> 16 & 255, S[R++] = x >> 8 & 255, S[R++] = x & 255;
      return _ === 2 && (x = i[A.charCodeAt($)] << 2 | i[A.charCodeAt($ + 1)] >> 4, S[R++] = x & 255), _ === 1 && (x = i[A.charCodeAt($)] << 10 | i[A.charCodeAt($ + 1)] << 4 | i[A.charCodeAt($ + 2)] >> 2, S[R++] = x >> 8 & 255, S[R++] = x & 255), S;
    }
    function y(A) {
      return n[A >> 18 & 63] + n[A >> 12 & 63] + n[A >> 6 & 63] + n[A & 63];
    }
    function g(A, x, m) {
      for (var w, _ = [], S = x; S < m; S += 3)
        w = (A[S] << 16 & 16711680) + (A[S + 1] << 8 & 65280) + (A[S + 2] & 255), _.push(y(w));
      return _.join("");
    }
    function b(A) {
      for (var x, m = A.length, w = m % 3, _ = [], S = 16383, R = 0, O = m - w; R < O; R += S)
        _.push(g(A, R, R + S > O ? O : R + S));
      return w === 1 ? (x = A[m - 1], _.push(
        n[x >> 2] + n[x << 4 & 63] + "=="
      )) : w === 2 && (x = (A[m - 2] << 8) + A[m - 1], _.push(
        n[x >> 10] + n[x >> 4 & 63] + n[x << 2 & 63] + "="
      )), _.join("");
    }
    var f = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    f.read = function(A, x, m, w, _) {
      var S, R, O = _ * 8 - w - 1, $ = (1 << O) - 1, z = $ >> 1, F = -7, Y = m ? _ - 1 : 0, rt = m ? -1 : 1, at = A[x + Y];
      for (Y += rt, S = at & (1 << -F) - 1, at >>= -F, F += O; F > 0; S = S * 256 + A[x + Y], Y += rt, F -= 8)
        ;
      for (R = S & (1 << -F) - 1, S >>= -F, F += w; F > 0; R = R * 256 + A[x + Y], Y += rt, F -= 8)
        ;
      if (S === 0)
        S = 1 - z;
      else {
        if (S === $)
          return R ? NaN : (at ? -1 : 1) * (1 / 0);
        R = R + Math.pow(2, w), S = S - z;
      }
      return (at ? -1 : 1) * R * Math.pow(2, S - w);
    }, f.write = function(A, x, m, w, _, S) {
      var R, O, $, z = S * 8 - _ - 1, F = (1 << z) - 1, Y = F >> 1, rt = _ === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, at = w ? 0 : S - 1, pt = w ? 1 : -1, vt = x < 0 || x === 0 && 1 / x < 0 ? 1 : 0;
      for (x = Math.abs(x), isNaN(x) || x === 1 / 0 ? (O = isNaN(x) ? 1 : 0, R = F) : (R = Math.floor(Math.log(x) / Math.LN2), x * ($ = Math.pow(2, -R)) < 1 && (R--, $ *= 2), R + Y >= 1 ? x += rt / $ : x += rt * Math.pow(2, 1 - Y), x * $ >= 2 && (R++, $ /= 2), R + Y >= F ? (O = 0, R = F) : R + Y >= 1 ? (O = (x * $ - 1) * Math.pow(2, _), R = R + Y) : (O = x * Math.pow(2, Y - 1) * Math.pow(2, _), R = 0)); _ >= 8; A[m + at] = O & 255, at += pt, O /= 256, _ -= 8)
        ;
      for (R = R << _ | O, z += _; z > 0; A[m + at] = R & 255, at += pt, R /= 256, z -= 8)
        ;
      A[m + at - pt] |= vt * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(A) {
      const x = r, m = f, w = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      A.Buffer = F, A.SlowBuffer = L, A.INSPECT_MAX_BYTES = 50;
      const _ = 2147483647;
      A.kMaxLength = _;
      const { Uint8Array: S, ArrayBuffer: R, SharedArrayBuffer: O } = globalThis;
      F.TYPED_ARRAY_SUPPORT = $(), !F.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
      function $() {
        try {
          const T = new S(1), V = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(V, S.prototype), Object.setPrototypeOf(T, V), T.foo() === 42;
        } catch {
          return !1;
        }
      }
      Object.defineProperty(F.prototype, "parent", {
        enumerable: !0,
        get: function() {
          if (F.isBuffer(this))
            return this.buffer;
        }
      }), Object.defineProperty(F.prototype, "offset", {
        enumerable: !0,
        get: function() {
          if (F.isBuffer(this))
            return this.byteOffset;
        }
      });
      function z(T) {
        if (T > _)
          throw new RangeError('The value "' + T + '" is invalid for option "size"');
        const V = new S(T);
        return Object.setPrototypeOf(V, F.prototype), V;
      }
      function F(T, V, H) {
        if (typeof T == "number") {
          if (typeof V == "string")
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return pt(T);
        }
        return Y(T, V, H);
      }
      F.poolSize = 8192;
      function Y(T, V, H) {
        if (typeof T == "string")
          return vt(T, V);
        if (R.isView(T))
          return Ct(T);
        if (T == null)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T
          );
        if (pr(T, R) || T && pr(T.buffer, R) || typeof O < "u" && (pr(T, O) || T && pr(T.buffer, O)))
          return It(T, V, H);
        if (typeof T == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const dt = T.valueOf && T.valueOf();
        if (dt != null && dt !== T)
          return F.from(dt, V, H);
        const ft = jt(T);
        if (ft) return ft;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof T[Symbol.toPrimitive] == "function")
          return F.from(T[Symbol.toPrimitive]("string"), V, H);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof T
        );
      }
      F.from = function(T, V, H) {
        return Y(T, V, H);
      }, Object.setPrototypeOf(F.prototype, S.prototype), Object.setPrototypeOf(F, S);
      function rt(T) {
        if (typeof T != "number")
          throw new TypeError('"size" argument must be of type number');
        if (T < 0)
          throw new RangeError('The value "' + T + '" is invalid for option "size"');
      }
      function at(T, V, H) {
        return rt(T), T <= 0 ? z(T) : V !== void 0 ? typeof H == "string" ? z(T).fill(V, H) : z(T).fill(V) : z(T);
      }
      F.alloc = function(T, V, H) {
        return at(T, V, H);
      };
      function pt(T) {
        return rt(T), z(T < 0 ? 0 : lt(T) | 0);
      }
      F.allocUnsafe = function(T) {
        return pt(T);
      }, F.allocUnsafeSlow = function(T) {
        return pt(T);
      };
      function vt(T, V) {
        if ((typeof V != "string" || V === "") && (V = "utf8"), !F.isEncoding(V))
          throw new TypeError("Unknown encoding: " + V);
        const H = D(T, V) | 0;
        let dt = z(H);
        const ft = dt.write(T, V);
        return ft !== H && (dt = dt.slice(0, ft)), dt;
      }
      function _t(T) {
        const V = T.length < 0 ? 0 : lt(T.length) | 0, H = z(V);
        for (let dt = 0; dt < V; dt += 1)
          H[dt] = T[dt] & 255;
        return H;
      }
      function Ct(T) {
        if (pr(T, S)) {
          const V = new S(T);
          return It(V.buffer, V.byteOffset, V.byteLength);
        }
        return _t(T);
      }
      function It(T, V, H) {
        if (V < 0 || T.byteLength < V)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (T.byteLength < V + (H || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let dt;
        return V === void 0 && H === void 0 ? dt = new S(T) : H === void 0 ? dt = new S(T, V) : dt = new S(T, V, H), Object.setPrototypeOf(dt, F.prototype), dt;
      }
      function jt(T) {
        if (F.isBuffer(T)) {
          const V = lt(T.length) | 0, H = z(V);
          return H.length === 0 || T.copy(H, 0, 0, V), H;
        }
        if (T.length !== void 0)
          return typeof T.length != "number" || Yr(T.length) ? z(0) : _t(T);
        if (T.type === "Buffer" && Array.isArray(T.data))
          return _t(T.data);
      }
      function lt(T) {
        if (T >= _)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + _.toString(16) + " bytes");
        return T | 0;
      }
      function L(T) {
        return +T != T && (T = 0), F.alloc(+T);
      }
      F.isBuffer = function(T) {
        return T != null && T._isBuffer === !0 && T !== F.prototype;
      }, F.compare = function(T, V) {
        if (pr(T, S) && (T = F.from(T, T.offset, T.byteLength)), pr(V, S) && (V = F.from(V, V.offset, V.byteLength)), !F.isBuffer(T) || !F.isBuffer(V))
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (T === V) return 0;
        let H = T.length, dt = V.length;
        for (let ft = 0, K = Math.min(H, dt); ft < K; ++ft)
          if (T[ft] !== V[ft]) {
            H = T[ft], dt = V[ft];
            break;
          }
        return H < dt ? -1 : dt < H ? 1 : 0;
      }, F.isEncoding = function(T) {
        switch (String(T).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, F.concat = function(T, V) {
        if (!Array.isArray(T))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (T.length === 0)
          return F.alloc(0);
        let H;
        if (V === void 0)
          for (V = 0, H = 0; H < T.length; ++H)
            V += T[H].length;
        const dt = F.allocUnsafe(V);
        let ft = 0;
        for (H = 0; H < T.length; ++H) {
          let K = T[H];
          if (pr(K, S))
            ft + K.length > dt.length ? (F.isBuffer(K) || (K = F.from(K)), K.copy(dt, ft)) : S.prototype.set.call(
              dt,
              K,
              ft
            );
          else if (F.isBuffer(K))
            K.copy(dt, ft);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          ft += K.length;
        }
        return dt;
      };
      function D(T, V) {
        if (F.isBuffer(T))
          return T.length;
        if (R.isView(T) || pr(T, R))
          return T.byteLength;
        if (typeof T != "string")
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof T
          );
        const H = T.length, dt = arguments.length > 2 && arguments[2] === !0;
        if (!dt && H === 0) return 0;
        let ft = !1;
        for (; ; )
          switch (V) {
            case "ascii":
            case "latin1":
            case "binary":
              return H;
            case "utf8":
            case "utf-8":
              return de(T).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return H * 2;
            case "hex":
              return H >>> 1;
            case "base64":
              return ze(T).length;
            default:
              if (ft)
                return dt ? -1 : de(T).length;
              V = ("" + V).toLowerCase(), ft = !0;
          }
      }
      F.byteLength = D;
      function tt(T, V, H) {
        let dt = !1;
        if ((V === void 0 || V < 0) && (V = 0), V > this.length || ((H === void 0 || H > this.length) && (H = this.length), H <= 0) || (H >>>= 0, V >>>= 0, H <= V))
          return "";
        for (T || (T = "utf8"); ; )
          switch (T) {
            case "hex":
              return _e(this, V, H);
            case "utf8":
            case "utf-8":
              return zt(this, V, H);
            case "ascii":
              return Zt(this, V, H);
            case "latin1":
            case "binary":
              return kt(this, V, H);
            case "base64":
              return Rt(this, V, H);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Ye(this, V, H);
            default:
              if (dt) throw new TypeError("Unknown encoding: " + T);
              T = (T + "").toLowerCase(), dt = !0;
          }
      }
      F.prototype._isBuffer = !0;
      function et(T, V, H) {
        const dt = T[V];
        T[V] = T[H], T[H] = dt;
      }
      F.prototype.swap16 = function() {
        const T = this.length;
        if (T % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let V = 0; V < T; V += 2)
          et(this, V, V + 1);
        return this;
      }, F.prototype.swap32 = function() {
        const T = this.length;
        if (T % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let V = 0; V < T; V += 4)
          et(this, V, V + 3), et(this, V + 1, V + 2);
        return this;
      }, F.prototype.swap64 = function() {
        const T = this.length;
        if (T % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let V = 0; V < T; V += 8)
          et(this, V, V + 7), et(this, V + 1, V + 6), et(this, V + 2, V + 5), et(this, V + 3, V + 4);
        return this;
      }, F.prototype.toString = function() {
        const T = this.length;
        return T === 0 ? "" : arguments.length === 0 ? zt(this, 0, T) : tt.apply(this, arguments);
      }, F.prototype.toLocaleString = F.prototype.toString, F.prototype.equals = function(T) {
        if (!F.isBuffer(T)) throw new TypeError("Argument must be a Buffer");
        return this === T ? !0 : F.compare(this, T) === 0;
      }, F.prototype.inspect = function() {
        let T = "";
        const V = A.INSPECT_MAX_BYTES;
        return T = this.toString("hex", 0, V).replace(/(.{2})/g, "$1 ").trim(), this.length > V && (T += " ... "), "<Buffer " + T + ">";
      }, w && (F.prototype[w] = F.prototype.inspect), F.prototype.compare = function(T, V, H, dt, ft) {
        if (pr(T, S) && (T = F.from(T, T.offset, T.byteLength)), !F.isBuffer(T))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof T
          );
        if (V === void 0 && (V = 0), H === void 0 && (H = T ? T.length : 0), dt === void 0 && (dt = 0), ft === void 0 && (ft = this.length), V < 0 || H > T.length || dt < 0 || ft > this.length)
          throw new RangeError("out of range index");
        if (dt >= ft && V >= H)
          return 0;
        if (dt >= ft)
          return -1;
        if (V >= H)
          return 1;
        if (V >>>= 0, H >>>= 0, dt >>>= 0, ft >>>= 0, this === T) return 0;
        let K = ft - dt, C = H - V;
        const N = Math.min(K, C), q = this.slice(dt, ft), W = T.slice(V, H);
        for (let G = 0; G < N; ++G)
          if (q[G] !== W[G]) {
            K = q[G], C = W[G];
            break;
          }
        return K < C ? -1 : C < K ? 1 : 0;
      };
      function st(T, V, H, dt, ft) {
        if (T.length === 0) return -1;
        if (typeof H == "string" ? (dt = H, H = 0) : H > 2147483647 ? H = 2147483647 : H < -2147483648 && (H = -2147483648), H = +H, Yr(H) && (H = ft ? 0 : T.length - 1), H < 0 && (H = T.length + H), H >= T.length) {
          if (ft) return -1;
          H = T.length - 1;
        } else if (H < 0)
          if (ft) H = 0;
          else return -1;
        if (typeof V == "string" && (V = F.from(V, dt)), F.isBuffer(V))
          return V.length === 0 ? -1 : X(T, V, H, dt, ft);
        if (typeof V == "number")
          return V = V & 255, typeof S.prototype.indexOf == "function" ? ft ? S.prototype.indexOf.call(T, V, H) : S.prototype.lastIndexOf.call(T, V, H) : X(T, [V], H, dt, ft);
        throw new TypeError("val must be string, number or Buffer");
      }
      function X(T, V, H, dt, ft) {
        let K = 1, C = T.length, N = V.length;
        if (dt !== void 0 && (dt = String(dt).toLowerCase(), dt === "ucs2" || dt === "ucs-2" || dt === "utf16le" || dt === "utf-16le")) {
          if (T.length < 2 || V.length < 2)
            return -1;
          K = 2, C /= 2, N /= 2, H /= 2;
        }
        function q(G, nt) {
          return K === 1 ? G[nt] : G.readUInt16BE(nt * K);
        }
        let W;
        if (ft) {
          let G = -1;
          for (W = H; W < C; W++)
            if (q(T, W) === q(V, G === -1 ? 0 : W - G)) {
              if (G === -1 && (G = W), W - G + 1 === N) return G * K;
            } else
              G !== -1 && (W -= W - G), G = -1;
        } else
          for (H + N > C && (H = C - N), W = H; W >= 0; W--) {
            let G = !0;
            for (let nt = 0; nt < N; nt++)
              if (q(T, W + nt) !== q(V, nt)) {
                G = !1;
                break;
              }
            if (G) return W;
          }
        return -1;
      }
      F.prototype.includes = function(T, V, H) {
        return this.indexOf(T, V, H) !== -1;
      }, F.prototype.indexOf = function(T, V, H) {
        return st(this, T, V, H, !0);
      }, F.prototype.lastIndexOf = function(T, V, H) {
        return st(this, T, V, H, !1);
      };
      function ot(T, V, H, dt) {
        H = Number(H) || 0;
        const ft = T.length - H;
        dt ? (dt = Number(dt), dt > ft && (dt = ft)) : dt = ft;
        const K = V.length;
        dt > K / 2 && (dt = K / 2);
        let C;
        for (C = 0; C < dt; ++C) {
          const N = parseInt(V.substr(C * 2, 2), 16);
          if (Yr(N)) return C;
          T[H + C] = N;
        }
        return C;
      }
      function mt(T, V, H, dt) {
        return We(de(V, T.length - H), T, H, dt);
      }
      function U(T, V, H, dt) {
        return We(ke(V), T, H, dt);
      }
      function J(T, V, H, dt) {
        return We(ze(V), T, H, dt);
      }
      function St(T, V, H, dt) {
        return We(Xt(V, T.length - H), T, H, dt);
      }
      F.prototype.write = function(T, V, H, dt) {
        if (V === void 0)
          dt = "utf8", H = this.length, V = 0;
        else if (H === void 0 && typeof V == "string")
          dt = V, H = this.length, V = 0;
        else if (isFinite(V))
          V = V >>> 0, isFinite(H) ? (H = H >>> 0, dt === void 0 && (dt = "utf8")) : (dt = H, H = void 0);
        else
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        const ft = this.length - V;
        if ((H === void 0 || H > ft) && (H = ft), T.length > 0 && (H < 0 || V < 0) || V > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        dt || (dt = "utf8");
        let K = !1;
        for (; ; )
          switch (dt) {
            case "hex":
              return ot(this, T, V, H);
            case "utf8":
            case "utf-8":
              return mt(this, T, V, H);
            case "ascii":
            case "latin1":
            case "binary":
              return U(this, T, V, H);
            case "base64":
              return J(this, T, V, H);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return St(this, T, V, H);
            default:
              if (K) throw new TypeError("Unknown encoding: " + dt);
              dt = ("" + dt).toLowerCase(), K = !0;
          }
      }, F.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function Rt(T, V, H) {
        return V === 0 && H === T.length ? x.fromByteArray(T) : x.fromByteArray(T.slice(V, H));
      }
      function zt(T, V, H) {
        H = Math.min(T.length, H);
        const dt = [];
        let ft = V;
        for (; ft < H; ) {
          const K = T[ft];
          let C = null, N = K > 239 ? 4 : K > 223 ? 3 : K > 191 ? 2 : 1;
          if (ft + N <= H) {
            let q, W, G, nt;
            switch (N) {
              case 1:
                K < 128 && (C = K);
                break;
              case 2:
                q = T[ft + 1], (q & 192) === 128 && (nt = (K & 31) << 6 | q & 63, nt > 127 && (C = nt));
                break;
              case 3:
                q = T[ft + 1], W = T[ft + 2], (q & 192) === 128 && (W & 192) === 128 && (nt = (K & 15) << 12 | (q & 63) << 6 | W & 63, nt > 2047 && (nt < 55296 || nt > 57343) && (C = nt));
                break;
              case 4:
                q = T[ft + 1], W = T[ft + 2], G = T[ft + 3], (q & 192) === 128 && (W & 192) === 128 && (G & 192) === 128 && (nt = (K & 15) << 18 | (q & 63) << 12 | (W & 63) << 6 | G & 63, nt > 65535 && nt < 1114112 && (C = nt));
            }
          }
          C === null ? (C = 65533, N = 1) : C > 65535 && (C -= 65536, dt.push(C >>> 10 & 1023 | 55296), C = 56320 | C & 1023), dt.push(C), ft += N;
        }
        return Yt(dt);
      }
      const Tt = 4096;
      function Yt(T) {
        const V = T.length;
        if (V <= Tt)
          return String.fromCharCode.apply(String, T);
        let H = "", dt = 0;
        for (; dt < V; )
          H += String.fromCharCode.apply(
            String,
            T.slice(dt, dt += Tt)
          );
        return H;
      }
      function Zt(T, V, H) {
        let dt = "";
        H = Math.min(T.length, H);
        for (let ft = V; ft < H; ++ft)
          dt += String.fromCharCode(T[ft] & 127);
        return dt;
      }
      function kt(T, V, H) {
        let dt = "";
        H = Math.min(T.length, H);
        for (let ft = V; ft < H; ++ft)
          dt += String.fromCharCode(T[ft]);
        return dt;
      }
      function _e(T, V, H) {
        const dt = T.length;
        (!V || V < 0) && (V = 0), (!H || H < 0 || H > dt) && (H = dt);
        let ft = "";
        for (let K = V; K < H; ++K)
          ft += ps[T[K]];
        return ft;
      }
      function Ye(T, V, H) {
        const dt = T.slice(V, H);
        let ft = "";
        for (let K = 0; K < dt.length - 1; K += 2)
          ft += String.fromCharCode(dt[K] + dt[K + 1] * 256);
        return ft;
      }
      F.prototype.slice = function(T, V) {
        const H = this.length;
        T = ~~T, V = V === void 0 ? H : ~~V, T < 0 ? (T += H, T < 0 && (T = 0)) : T > H && (T = H), V < 0 ? (V += H, V < 0 && (V = 0)) : V > H && (V = H), V < T && (V = T);
        const dt = this.subarray(T, V);
        return Object.setPrototypeOf(dt, F.prototype), dt;
      };
      function wt(T, V, H) {
        if (T % 1 !== 0 || T < 0) throw new RangeError("offset is not uint");
        if (T + V > H) throw new RangeError("Trying to access beyond buffer length");
      }
      F.prototype.readUintLE = F.prototype.readUIntLE = function(T, V, H) {
        T = T >>> 0, V = V >>> 0, H || wt(T, V, this.length);
        let dt = this[T], ft = 1, K = 0;
        for (; ++K < V && (ft *= 256); )
          dt += this[T + K] * ft;
        return dt;
      }, F.prototype.readUintBE = F.prototype.readUIntBE = function(T, V, H) {
        T = T >>> 0, V = V >>> 0, H || wt(T, V, this.length);
        let dt = this[T + --V], ft = 1;
        for (; V > 0 && (ft *= 256); )
          dt += this[T + --V] * ft;
        return dt;
      }, F.prototype.readUint8 = F.prototype.readUInt8 = function(T, V) {
        return T = T >>> 0, V || wt(T, 1, this.length), this[T];
      }, F.prototype.readUint16LE = F.prototype.readUInt16LE = function(T, V) {
        return T = T >>> 0, V || wt(T, 2, this.length), this[T] | this[T + 1] << 8;
      }, F.prototype.readUint16BE = F.prototype.readUInt16BE = function(T, V) {
        return T = T >>> 0, V || wt(T, 2, this.length), this[T] << 8 | this[T + 1];
      }, F.prototype.readUint32LE = F.prototype.readUInt32LE = function(T, V) {
        return T = T >>> 0, V || wt(T, 4, this.length), (this[T] | this[T + 1] << 8 | this[T + 2] << 16) + this[T + 3] * 16777216;
      }, F.prototype.readUint32BE = F.prototype.readUInt32BE = function(T, V) {
        return T = T >>> 0, V || wt(T, 4, this.length), this[T] * 16777216 + (this[T + 1] << 16 | this[T + 2] << 8 | this[T + 3]);
      }, F.prototype.readBigUInt64LE = qe(function(T) {
        T = T >>> 0, ct(T, "offset");
        const V = this[T], H = this[T + 7];
        (V === void 0 || H === void 0) && Et(T, this.length - 8);
        const dt = V + this[++T] * 2 ** 8 + this[++T] * 2 ** 16 + this[++T] * 2 ** 24, ft = this[++T] + this[++T] * 2 ** 8 + this[++T] * 2 ** 16 + H * 2 ** 24;
        return BigInt(dt) + (BigInt(ft) << BigInt(32));
      }), F.prototype.readBigUInt64BE = qe(function(T) {
        T = T >>> 0, ct(T, "offset");
        const V = this[T], H = this[T + 7];
        (V === void 0 || H === void 0) && Et(T, this.length - 8);
        const dt = V * 2 ** 24 + this[++T] * 2 ** 16 + this[++T] * 2 ** 8 + this[++T], ft = this[++T] * 2 ** 24 + this[++T] * 2 ** 16 + this[++T] * 2 ** 8 + H;
        return (BigInt(dt) << BigInt(32)) + BigInt(ft);
      }), F.prototype.readIntLE = function(T, V, H) {
        T = T >>> 0, V = V >>> 0, H || wt(T, V, this.length);
        let dt = this[T], ft = 1, K = 0;
        for (; ++K < V && (ft *= 256); )
          dt += this[T + K] * ft;
        return ft *= 128, dt >= ft && (dt -= Math.pow(2, 8 * V)), dt;
      }, F.prototype.readIntBE = function(T, V, H) {
        T = T >>> 0, V = V >>> 0, H || wt(T, V, this.length);
        let dt = V, ft = 1, K = this[T + --dt];
        for (; dt > 0 && (ft *= 256); )
          K += this[T + --dt] * ft;
        return ft *= 128, K >= ft && (K -= Math.pow(2, 8 * V)), K;
      }, F.prototype.readInt8 = function(T, V) {
        return T = T >>> 0, V || wt(T, 1, this.length), this[T] & 128 ? (255 - this[T] + 1) * -1 : this[T];
      }, F.prototype.readInt16LE = function(T, V) {
        T = T >>> 0, V || wt(T, 2, this.length);
        const H = this[T] | this[T + 1] << 8;
        return H & 32768 ? H | 4294901760 : H;
      }, F.prototype.readInt16BE = function(T, V) {
        T = T >>> 0, V || wt(T, 2, this.length);
        const H = this[T + 1] | this[T] << 8;
        return H & 32768 ? H | 4294901760 : H;
      }, F.prototype.readInt32LE = function(T, V) {
        return T = T >>> 0, V || wt(T, 4, this.length), this[T] | this[T + 1] << 8 | this[T + 2] << 16 | this[T + 3] << 24;
      }, F.prototype.readInt32BE = function(T, V) {
        return T = T >>> 0, V || wt(T, 4, this.length), this[T] << 24 | this[T + 1] << 16 | this[T + 2] << 8 | this[T + 3];
      }, F.prototype.readBigInt64LE = qe(function(T) {
        T = T >>> 0, ct(T, "offset");
        const V = this[T], H = this[T + 7];
        (V === void 0 || H === void 0) && Et(T, this.length - 8);
        const dt = this[T + 4] + this[T + 5] * 2 ** 8 + this[T + 6] * 2 ** 16 + (H << 24);
        return (BigInt(dt) << BigInt(32)) + BigInt(V + this[++T] * 2 ** 8 + this[++T] * 2 ** 16 + this[++T] * 2 ** 24);
      }), F.prototype.readBigInt64BE = qe(function(T) {
        T = T >>> 0, ct(T, "offset");
        const V = this[T], H = this[T + 7];
        (V === void 0 || H === void 0) && Et(T, this.length - 8);
        const dt = (V << 24) + // Overflow
        this[++T] * 2 ** 16 + this[++T] * 2 ** 8 + this[++T];
        return (BigInt(dt) << BigInt(32)) + BigInt(this[++T] * 2 ** 24 + this[++T] * 2 ** 16 + this[++T] * 2 ** 8 + H);
      }), F.prototype.readFloatLE = function(T, V) {
        return T = T >>> 0, V || wt(T, 4, this.length), m.read(this, T, !0, 23, 4);
      }, F.prototype.readFloatBE = function(T, V) {
        return T = T >>> 0, V || wt(T, 4, this.length), m.read(this, T, !1, 23, 4);
      }, F.prototype.readDoubleLE = function(T, V) {
        return T = T >>> 0, V || wt(T, 8, this.length), m.read(this, T, !0, 52, 8);
      }, F.prototype.readDoubleBE = function(T, V) {
        return T = T >>> 0, V || wt(T, 8, this.length), m.read(this, T, !1, 52, 8);
      };
      function le(T, V, H, dt, ft, K) {
        if (!F.isBuffer(T)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (V > ft || V < K) throw new RangeError('"value" argument is out of bounds');
        if (H + dt > T.length) throw new RangeError("Index out of range");
      }
      F.prototype.writeUintLE = F.prototype.writeUIntLE = function(T, V, H, dt) {
        if (T = +T, V = V >>> 0, H = H >>> 0, !dt) {
          const C = Math.pow(2, 8 * H) - 1;
          le(this, T, V, H, C, 0);
        }
        let ft = 1, K = 0;
        for (this[V] = T & 255; ++K < H && (ft *= 256); )
          this[V + K] = T / ft & 255;
        return V + H;
      }, F.prototype.writeUintBE = F.prototype.writeUIntBE = function(T, V, H, dt) {
        if (T = +T, V = V >>> 0, H = H >>> 0, !dt) {
          const C = Math.pow(2, 8 * H) - 1;
          le(this, T, V, H, C, 0);
        }
        let ft = H - 1, K = 1;
        for (this[V + ft] = T & 255; --ft >= 0 && (K *= 256); )
          this[V + ft] = T / K & 255;
        return V + H;
      }, F.prototype.writeUint8 = F.prototype.writeUInt8 = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 1, 255, 0), this[V] = T & 255, V + 1;
      }, F.prototype.writeUint16LE = F.prototype.writeUInt16LE = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 2, 65535, 0), this[V] = T & 255, this[V + 1] = T >>> 8, V + 2;
      }, F.prototype.writeUint16BE = F.prototype.writeUInt16BE = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 2, 65535, 0), this[V] = T >>> 8, this[V + 1] = T & 255, V + 2;
      }, F.prototype.writeUint32LE = F.prototype.writeUInt32LE = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 4, 4294967295, 0), this[V + 3] = T >>> 24, this[V + 2] = T >>> 16, this[V + 1] = T >>> 8, this[V] = T & 255, V + 4;
      }, F.prototype.writeUint32BE = F.prototype.writeUInt32BE = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 4, 4294967295, 0), this[V] = T >>> 24, this[V + 1] = T >>> 16, this[V + 2] = T >>> 8, this[V + 3] = T & 255, V + 4;
      };
      function te(T, V, H, dt, ft) {
        it(V, dt, ft, T, H, 7);
        let K = Number(V & BigInt(4294967295));
        T[H++] = K, K = K >> 8, T[H++] = K, K = K >> 8, T[H++] = K, K = K >> 8, T[H++] = K;
        let C = Number(V >> BigInt(32) & BigInt(4294967295));
        return T[H++] = C, C = C >> 8, T[H++] = C, C = C >> 8, T[H++] = C, C = C >> 8, T[H++] = C, H;
      }
      function Se(T, V, H, dt, ft) {
        it(V, dt, ft, T, H, 7);
        let K = Number(V & BigInt(4294967295));
        T[H + 7] = K, K = K >> 8, T[H + 6] = K, K = K >> 8, T[H + 5] = K, K = K >> 8, T[H + 4] = K;
        let C = Number(V >> BigInt(32) & BigInt(4294967295));
        return T[H + 3] = C, C = C >> 8, T[H + 2] = C, C = C >> 8, T[H + 1] = C, C = C >> 8, T[H] = C, H + 8;
      }
      F.prototype.writeBigUInt64LE = qe(function(T, V = 0) {
        return te(this, T, V, BigInt(0), BigInt("0xffffffffffffffff"));
      }), F.prototype.writeBigUInt64BE = qe(function(T, V = 0) {
        return Se(this, T, V, BigInt(0), BigInt("0xffffffffffffffff"));
      }), F.prototype.writeIntLE = function(T, V, H, dt) {
        if (T = +T, V = V >>> 0, !dt) {
          const N = Math.pow(2, 8 * H - 1);
          le(this, T, V, H, N - 1, -N);
        }
        let ft = 0, K = 1, C = 0;
        for (this[V] = T & 255; ++ft < H && (K *= 256); )
          T < 0 && C === 0 && this[V + ft - 1] !== 0 && (C = 1), this[V + ft] = (T / K >> 0) - C & 255;
        return V + H;
      }, F.prototype.writeIntBE = function(T, V, H, dt) {
        if (T = +T, V = V >>> 0, !dt) {
          const N = Math.pow(2, 8 * H - 1);
          le(this, T, V, H, N - 1, -N);
        }
        let ft = H - 1, K = 1, C = 0;
        for (this[V + ft] = T & 255; --ft >= 0 && (K *= 256); )
          T < 0 && C === 0 && this[V + ft + 1] !== 0 && (C = 1), this[V + ft] = (T / K >> 0) - C & 255;
        return V + H;
      }, F.prototype.writeInt8 = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 1, 127, -128), T < 0 && (T = 255 + T + 1), this[V] = T & 255, V + 1;
      }, F.prototype.writeInt16LE = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 2, 32767, -32768), this[V] = T & 255, this[V + 1] = T >>> 8, V + 2;
      }, F.prototype.writeInt16BE = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 2, 32767, -32768), this[V] = T >>> 8, this[V + 1] = T & 255, V + 2;
      }, F.prototype.writeInt32LE = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 4, 2147483647, -2147483648), this[V] = T & 255, this[V + 1] = T >>> 8, this[V + 2] = T >>> 16, this[V + 3] = T >>> 24, V + 4;
      }, F.prototype.writeInt32BE = function(T, V, H) {
        return T = +T, V = V >>> 0, H || le(this, T, V, 4, 2147483647, -2147483648), T < 0 && (T = 4294967295 + T + 1), this[V] = T >>> 24, this[V + 1] = T >>> 16, this[V + 2] = T >>> 8, this[V + 3] = T & 255, V + 4;
      }, F.prototype.writeBigInt64LE = qe(function(T, V = 0) {
        return te(this, T, V, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), F.prototype.writeBigInt64BE = qe(function(T, V = 0) {
        return Se(this, T, V, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function Kt(T, V, H, dt, ft, K) {
        if (H + dt > T.length) throw new RangeError("Index out of range");
        if (H < 0) throw new RangeError("Index out of range");
      }
      function bt(T, V, H, dt, ft) {
        return V = +V, H = H >>> 0, ft || Kt(T, V, H, 4), m.write(T, V, H, dt, 23, 4), H + 4;
      }
      F.prototype.writeFloatLE = function(T, V, H) {
        return bt(this, T, V, !0, H);
      }, F.prototype.writeFloatBE = function(T, V, H) {
        return bt(this, T, V, !1, H);
      };
      function xt(T, V, H, dt, ft) {
        return V = +V, H = H >>> 0, ft || Kt(T, V, H, 8), m.write(T, V, H, dt, 52, 8), H + 8;
      }
      F.prototype.writeDoubleLE = function(T, V, H) {
        return xt(this, T, V, !0, H);
      }, F.prototype.writeDoubleBE = function(T, V, H) {
        return xt(this, T, V, !1, H);
      }, F.prototype.copy = function(T, V, H, dt) {
        if (!F.isBuffer(T)) throw new TypeError("argument should be a Buffer");
        if (H || (H = 0), !dt && dt !== 0 && (dt = this.length), V >= T.length && (V = T.length), V || (V = 0), dt > 0 && dt < H && (dt = H), dt === H || T.length === 0 || this.length === 0) return 0;
        if (V < 0)
          throw new RangeError("targetStart out of bounds");
        if (H < 0 || H >= this.length) throw new RangeError("Index out of range");
        if (dt < 0) throw new RangeError("sourceEnd out of bounds");
        dt > this.length && (dt = this.length), T.length - V < dt - H && (dt = T.length - V + H);
        const ft = dt - H;
        return this === T && typeof S.prototype.copyWithin == "function" ? this.copyWithin(V, H, dt) : S.prototype.set.call(
          T,
          this.subarray(H, dt),
          V
        ), ft;
      }, F.prototype.fill = function(T, V, H, dt) {
        if (typeof T == "string") {
          if (typeof V == "string" ? (dt = V, V = 0, H = this.length) : typeof H == "string" && (dt = H, H = this.length), dt !== void 0 && typeof dt != "string")
            throw new TypeError("encoding must be a string");
          if (typeof dt == "string" && !F.isEncoding(dt))
            throw new TypeError("Unknown encoding: " + dt);
          if (T.length === 1) {
            const K = T.charCodeAt(0);
            (dt === "utf8" && K < 128 || dt === "latin1") && (T = K);
          }
        } else typeof T == "number" ? T = T & 255 : typeof T == "boolean" && (T = Number(T));
        if (V < 0 || this.length < V || this.length < H)
          throw new RangeError("Out of range index");
        if (H <= V)
          return this;
        V = V >>> 0, H = H === void 0 ? this.length : H >>> 0, T || (T = 0);
        let ft;
        if (typeof T == "number")
          for (ft = V; ft < H; ++ft)
            this[ft] = T;
        else {
          const K = F.isBuffer(T) ? T : F.from(T, dt), C = K.length;
          if (C === 0)
            throw new TypeError('The value "' + T + '" is invalid for argument "value"');
          for (ft = 0; ft < H - V; ++ft)
            this[ft + V] = K[ft % C];
        }
        return this;
      };
      const Jt = {};
      function k(T, V, H) {
        Jt[T] = class extends H {
          constructor() {
            super(), Object.defineProperty(this, "message", {
              value: V.apply(this, arguments),
              writable: !0,
              configurable: !0
            }), this.name = `${this.name} [${T}]`, this.stack, delete this.name;
          }
          get code() {
            return T;
          }
          set code(dt) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: dt,
              writable: !0
            });
          }
          toString() {
            return `${this.name} [${T}]: ${this.message}`;
          }
        };
      }
      k(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(T) {
          return T ? `${T} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ), k(
        "ERR_INVALID_ARG_TYPE",
        function(T, V) {
          return `The "${T}" argument must be of type number. Received type ${typeof V}`;
        },
        TypeError
      ), k(
        "ERR_OUT_OF_RANGE",
        function(T, V, H) {
          let dt = `The value of "${T}" is out of range.`, ft = H;
          return Number.isInteger(H) && Math.abs(H) > 2 ** 32 ? ft = M(String(H)) : typeof H == "bigint" && (ft = String(H), (H > BigInt(2) ** BigInt(32) || H < -(BigInt(2) ** BigInt(32))) && (ft = M(ft)), ft += "n"), dt += ` It must be ${V}. Received ${ft}`, dt;
        },
        RangeError
      );
      function M(T) {
        let V = "", H = T.length;
        const dt = T[0] === "-" ? 1 : 0;
        for (; H >= dt + 4; H -= 3)
          V = `_${T.slice(H - 3, H)}${V}`;
        return `${T.slice(0, H)}${V}`;
      }
      function B(T, V, H) {
        ct(V, "offset"), (T[V] === void 0 || T[V + H] === void 0) && Et(V, T.length - (H + 1));
      }
      function it(T, V, H, dt, ft, K) {
        if (T > H || T < V) {
          const C = typeof V == "bigint" ? "n" : "";
          let N;
          throw V === 0 || V === BigInt(0) ? N = `>= 0${C} and < 2${C} ** ${(K + 1) * 8}${C}` : N = `>= -(2${C} ** ${(K + 1) * 8 - 1}${C}) and < 2 ** ${(K + 1) * 8 - 1}${C}`, new Jt.ERR_OUT_OF_RANGE("value", N, T);
        }
        B(dt, ft, K);
      }
      function ct(T, V) {
        if (typeof T != "number")
          throw new Jt.ERR_INVALID_ARG_TYPE(V, "number", T);
      }
      function Et(T, V, H) {
        throw Math.floor(T) !== T ? (ct(T, H), new Jt.ERR_OUT_OF_RANGE("offset", "an integer", T)) : V < 0 ? new Jt.ERR_BUFFER_OUT_OF_BOUNDS() : new Jt.ERR_OUT_OF_RANGE(
          "offset",
          `>= 0 and <= ${V}`,
          T
        );
      }
      const Mt = /[^+/0-9A-Za-z-_]/g;
      function se(T) {
        if (T = T.split("=")[0], T = T.trim().replace(Mt, ""), T.length < 2) return "";
        for (; T.length % 4 !== 0; )
          T = T + "=";
        return T;
      }
      function de(T, V) {
        V = V || 1 / 0;
        let H;
        const dt = T.length;
        let ft = null;
        const K = [];
        for (let C = 0; C < dt; ++C) {
          if (H = T.charCodeAt(C), H > 55295 && H < 57344) {
            if (!ft) {
              if (H > 56319) {
                (V -= 3) > -1 && K.push(239, 191, 189);
                continue;
              } else if (C + 1 === dt) {
                (V -= 3) > -1 && K.push(239, 191, 189);
                continue;
              }
              ft = H;
              continue;
            }
            if (H < 56320) {
              (V -= 3) > -1 && K.push(239, 191, 189), ft = H;
              continue;
            }
            H = (ft - 55296 << 10 | H - 56320) + 65536;
          } else ft && (V -= 3) > -1 && K.push(239, 191, 189);
          if (ft = null, H < 128) {
            if ((V -= 1) < 0) break;
            K.push(H);
          } else if (H < 2048) {
            if ((V -= 2) < 0) break;
            K.push(
              H >> 6 | 192,
              H & 63 | 128
            );
          } else if (H < 65536) {
            if ((V -= 3) < 0) break;
            K.push(
              H >> 12 | 224,
              H >> 6 & 63 | 128,
              H & 63 | 128
            );
          } else if (H < 1114112) {
            if ((V -= 4) < 0) break;
            K.push(
              H >> 18 | 240,
              H >> 12 & 63 | 128,
              H >> 6 & 63 | 128,
              H & 63 | 128
            );
          } else
            throw new Error("Invalid code point");
        }
        return K;
      }
      function ke(T) {
        const V = [];
        for (let H = 0; H < T.length; ++H)
          V.push(T.charCodeAt(H) & 255);
        return V;
      }
      function Xt(T, V) {
        let H, dt, ft;
        const K = [];
        for (let C = 0; C < T.length && !((V -= 2) < 0); ++C)
          H = T.charCodeAt(C), dt = H >> 8, ft = H % 256, K.push(ft), K.push(dt);
        return K;
      }
      function ze(T) {
        return x.toByteArray(se(T));
      }
      function We(T, V, H, dt) {
        let ft;
        for (ft = 0; ft < dt && !(ft + H >= V.length || ft >= T.length); ++ft)
          V[ft + H] = T[ft];
        return ft;
      }
      function pr(T, V) {
        return T instanceof V || T != null && T.constructor != null && T.constructor.name != null && T.constructor.name === V.name;
      }
      function Yr(T) {
        return T !== T;
      }
      const ps = function() {
        const T = "0123456789abcdef", V = new Array(256);
        for (let H = 0; H < 16; ++H) {
          const dt = H * 16;
          for (let ft = 0; ft < 16; ++ft)
            V[dt + ft] = T[H] + T[ft];
        }
        return V;
      }();
      function qe(T) {
        return typeof BigInt > "u" ? Vi : T;
      }
      function Vi() {
        throw new Error("BigInt not supported");
      }
    })(t);
    const E = t.Buffer;
    e.Blob = t.Blob, e.BlobOptions = t.BlobOptions, e.Buffer = t.Buffer, e.File = t.File, e.FileOptions = t.FileOptions, e.INSPECT_MAX_BYTES = t.INSPECT_MAX_BYTES, e.SlowBuffer = t.SlowBuffer, e.TranscodeEncoding = t.TranscodeEncoding, e.atob = t.atob, e.btoa = t.btoa, e.constants = t.constants, e.default = E, e.isAscii = t.isAscii, e.isUtf8 = t.isUtf8, e.kMaxLength = t.kMaxLength, e.kStringMaxLength = t.kStringMaxLength, e.resolveObjectURL = t.resolveObjectURL, e.transcode = t.transcode;
  }(P7)), P7;
}
var T7 = {}, O7 = {}, L7, M7;
function YM() {
  return M7 || (M7 = 1, L7 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var e = {}, t = Symbol("test"), r = Object(t);
    if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
      return !1;
    var n = 42;
    e[t] = n;
    for (var i in e)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return !1;
    var s = Object.getOwnPropertySymbols(e);
    if (s.length !== 1 || s[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(e, t)
      );
      if (o.value !== n || o.enumerable !== !0)
        return !1;
    }
    return !0;
  }), L7;
}
var Mv, N7;
function L2() {
  if (N7) return Mv;
  N7 = 1;
  var e = YM();
  return Mv = function() {
    return e() && !!Symbol.toStringTag;
  }, Mv;
}
var D7, B7;
function KM() {
  return B7 || (B7 = 1, D7 = Object), D7;
}
var j7, F7;
function Nct() {
  return F7 || (F7 = 1, j7 = Error), j7;
}
var $7, z7;
function Dct() {
  return z7 || (z7 = 1, $7 = EvalError), $7;
}
var V7, U7;
function Bct() {
  return U7 || (U7 = 1, V7 = RangeError), V7;
}
var H7, G7;
function jct() {
  return G7 || (G7 = 1, H7 = ReferenceError), H7;
}
var Q7, W7;
function ZM() {
  return W7 || (W7 = 1, Q7 = SyntaxError), Q7;
}
var q7, Y7;
function J0() {
  return Y7 || (Y7 = 1, q7 = TypeError), q7;
}
var K7, Z7;
function Fct() {
  return Z7 || (Z7 = 1, K7 = URIError), K7;
}
var J7, X7;
function $ct() {
  return X7 || (X7 = 1, J7 = Math.abs), J7;
}
var t_, e_;
function zct() {
  return e_ || (e_ = 1, t_ = Math.floor), t_;
}
var r_, n_;
function Vct() {
  return n_ || (n_ = 1, r_ = Math.max), r_;
}
var i_, s_;
function Uct() {
  return s_ || (s_ = 1, i_ = Math.min), i_;
}
var o_, a_;
function Hct() {
  return a_ || (a_ = 1, o_ = Math.pow), o_;
}
var l_, c_;
function Gct() {
  return c_ || (c_ = 1, l_ = Math.round), l_;
}
var u_, h_;
function Qct() {
  return h_ || (h_ = 1, u_ = Number.isNaN || function(e) {
    return e !== e;
  }), u_;
}
var Nv, p_;
function Wct() {
  if (p_) return Nv;
  p_ = 1;
  var e = /* @__PURE__ */ Qct();
  return Nv = function(t) {
    return e(t) || t === 0 ? t : t < 0 ? -1 : 1;
  }, Nv;
}
var d_, f_;
function qct() {
  return f_ || (f_ = 1, d_ = Object.getOwnPropertyDescriptor), d_;
}
var Dv, g_;
function zp() {
  if (g_) return Dv;
  g_ = 1;
  var e = /* @__PURE__ */ qct();
  if (e)
    try {
      e([], "length");
    } catch {
      e = null;
    }
  return Dv = e, Dv;
}
var Bv, m_;
function M2() {
  if (m_) return Bv;
  m_ = 1;
  var e = Object.defineProperty || !1;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch {
      e = !1;
    }
  return Bv = e, Bv;
}
var jv, y_;
function Yct() {
  if (y_) return jv;
  y_ = 1;
  var e = typeof Symbol < "u" && Symbol, t = YM();
  return jv = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, jv;
}
var b_, v_;
function JM() {
  return v_ || (v_ = 1, b_ = typeof Reflect < "u" && Reflect.getPrototypeOf || null), b_;
}
var Fv, w_;
function XM() {
  if (w_) return Fv;
  w_ = 1;
  var e = /* @__PURE__ */ KM();
  return Fv = e.getPrototypeOf || null, Fv;
}
var $v, x_;
function Kct() {
  if (x_) return $v;
  x_ = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, n = "[object Function]", i = function(a, l) {
    for (var c = [], h = 0; h < a.length; h += 1)
      c[h] = a[h];
    for (var u = 0; u < l.length; u += 1)
      c[u + a.length] = l[u];
    return c;
  }, s = function(a, l) {
    for (var c = [], h = l, u = 0; h < a.length; h += 1, u += 1)
      c[u] = a[h];
    return c;
  }, o = function(a, l) {
    for (var c = "", h = 0; h < a.length; h += 1)
      c += a[h], h + 1 < a.length && (c += l);
    return c;
  };
  return $v = function(a) {
    var l = this;
    if (typeof l != "function" || t.apply(l) !== n)
      throw new TypeError(e + l);
    for (var c = s(arguments, 1), h, u = function() {
      if (this instanceof h) {
        var f = l.apply(
          this,
          i(c, arguments)
        );
        return Object(f) === f ? f : this;
      }
      return l.apply(
        a,
        i(c, arguments)
      );
    }, p = r(0, l.length - c.length), y = [], g = 0; g < p; g++)
      y[g] = "$" + g;
    if (h = Function("binder", "return function (" + o(y, ",") + "){ return binder.apply(this,arguments); }")(u), l.prototype) {
      var b = function() {
      };
      b.prototype = l.prototype, h.prototype = new b(), b.prototype = null;
    }
    return h;
  }, $v;
}
var zv, E_;
function X0() {
  if (E_) return zv;
  E_ = 1;
  var e = Kct();
  return zv = Function.prototype.bind || e, zv;
}
var A_, S_;
function B5() {
  return S_ || (S_ = 1, A_ = Function.prototype.call), A_;
}
var __, k_;
function j5() {
  return k_ || (k_ = 1, __ = Function.prototype.apply), __;
}
var C_, I_;
function Zct() {
  return I_ || (I_ = 1, C_ = typeof Reflect < "u" && Reflect && Reflect.apply), C_;
}
var Vv, P_;
function tN() {
  if (P_) return Vv;
  P_ = 1;
  var e = X0(), t = j5(), r = B5(), n = Zct();
  return Vv = n || e.call(r, t), Vv;
}
var Uv, R_;
function F5() {
  if (R_) return Uv;
  R_ = 1;
  var e = X0(), t = /* @__PURE__ */ J0(), r = B5(), n = tN();
  return Uv = function(i) {
    if (i.length < 1 || typeof i[0] != "function")
      throw new t("a function is required");
    return n(e, r, i);
  }, Uv;
}
var Hv, T_;
function Jct() {
  if (T_) return Hv;
  T_ = 1;
  var e = F5(), t = /* @__PURE__ */ zp(), r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var n = !!r && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, s = i.getPrototypeOf;
  return Hv = n && typeof n.get == "function" ? e([n.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(o) {
      return s(o == null ? o : i(o));
    }
  ) : !1, Hv;
}
var Gv, O_;
function eN() {
  if (O_) return Gv;
  O_ = 1;
  var e = JM(), t = XM(), r = /* @__PURE__ */ Jct();
  return Gv = e ? function(n) {
    return e(n);
  } : t ? function(n) {
    if (!n || typeof n != "object" && typeof n != "function")
      throw new TypeError("getProto: not an object");
    return t(n);
  } : r ? function(n) {
    return r(n);
  } : null, Gv;
}
var Qv, L_;
function rN() {
  if (L_) return Qv;
  L_ = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = X0();
  return Qv = r.call(e, t), Qv;
}
var Wv, M_;
function nN() {
  if (M_) return Wv;
  M_ = 1;
  var e, t = /* @__PURE__ */ KM(), r = /* @__PURE__ */ Nct(), n = /* @__PURE__ */ Dct(), i = /* @__PURE__ */ Bct(), s = /* @__PURE__ */ jct(), o = /* @__PURE__ */ ZM(), a = /* @__PURE__ */ J0(), l = /* @__PURE__ */ Fct(), c = /* @__PURE__ */ $ct(), h = /* @__PURE__ */ zct(), u = /* @__PURE__ */ Vct(), p = /* @__PURE__ */ Uct(), y = /* @__PURE__ */ Hct(), g = /* @__PURE__ */ Gct(), b = /* @__PURE__ */ Wct(), f = Function, E = function(ot) {
    try {
      return f('"use strict"; return (' + ot + ").constructor;")();
    } catch {
    }
  }, A = /* @__PURE__ */ zp(), x = /* @__PURE__ */ M2(), m = function() {
    throw new a();
  }, w = A ? function() {
    try {
      return arguments.callee, m;
    } catch {
      try {
        return A(arguments, "callee").get;
      } catch {
        return m;
      }
    }
  }() : m, _ = Yct()(), S = eN(), R = XM(), O = JM(), $ = j5(), z = B5(), F = {}, Y = typeof Uint8Array > "u" || !S ? e : S(Uint8Array), rt = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": _ && S ? S([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": F,
    "%AsyncGenerator%": F,
    "%AsyncGeneratorFunction%": F,
    "%AsyncIteratorPrototype%": F,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": r,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": n,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": f,
    "%GeneratorFunction%": F,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": _ && S ? S(S([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !_ || !S ? e : S((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": t,
    "%Object.getOwnPropertyDescriptor%": A,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": i,
    "%ReferenceError%": s,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !_ || !S ? e : S((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": _ && S ? S(""[Symbol.iterator]()) : e,
    "%Symbol%": _ ? Symbol : e,
    "%SyntaxError%": o,
    "%ThrowTypeError%": w,
    "%TypedArray%": Y,
    "%TypeError%": a,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": l,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet,
    "%Function.prototype.call%": z,
    "%Function.prototype.apply%": $,
    "%Object.defineProperty%": x,
    "%Object.getPrototypeOf%": R,
    "%Math.abs%": c,
    "%Math.floor%": h,
    "%Math.max%": u,
    "%Math.min%": p,
    "%Math.pow%": y,
    "%Math.round%": g,
    "%Math.sign%": b,
    "%Reflect.getPrototypeOf%": O
  };
  if (S)
    try {
      null.error;
    } catch (ot) {
      var at = S(S(ot));
      rt["%Error.prototype%"] = at;
    }
  var pt = function ot(mt) {
    var U;
    if (mt === "%AsyncFunction%")
      U = E("async function () {}");
    else if (mt === "%GeneratorFunction%")
      U = E("function* () {}");
    else if (mt === "%AsyncGeneratorFunction%")
      U = E("async function* () {}");
    else if (mt === "%AsyncGenerator%") {
      var J = ot("%AsyncGeneratorFunction%");
      J && (U = J.prototype);
    } else if (mt === "%AsyncIteratorPrototype%") {
      var St = ot("%AsyncGenerator%");
      St && S && (U = S(St.prototype));
    }
    return rt[mt] = U, U;
  }, vt = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, _t = X0(), Ct = /* @__PURE__ */ rN(), It = _t.call(z, Array.prototype.concat), jt = _t.call($, Array.prototype.splice), lt = _t.call(z, String.prototype.replace), L = _t.call(z, String.prototype.slice), D = _t.call(z, RegExp.prototype.exec), tt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, et = /\\(\\)?/g, st = function(ot) {
    var mt = L(ot, 0, 1), U = L(ot, -1);
    if (mt === "%" && U !== "%")
      throw new o("invalid intrinsic syntax, expected closing `%`");
    if (U === "%" && mt !== "%")
      throw new o("invalid intrinsic syntax, expected opening `%`");
    var J = [];
    return lt(ot, tt, function(St, Rt, zt, Tt) {
      J[J.length] = zt ? lt(Tt, et, "$1") : Rt || St;
    }), J;
  }, X = function(ot, mt) {
    var U = ot, J;
    if (Ct(vt, U) && (J = vt[U], U = "%" + J[0] + "%"), Ct(rt, U)) {
      var St = rt[U];
      if (St === F && (St = pt(U)), typeof St > "u" && !mt)
        throw new a("intrinsic " + ot + " exists, but is not available. Please file an issue!");
      return {
        alias: J,
        name: U,
        value: St
      };
    }
    throw new o("intrinsic " + ot + " does not exist!");
  };
  return Wv = function(ot, mt) {
    if (typeof ot != "string" || ot.length === 0)
      throw new a("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof mt != "boolean")
      throw new a('"allowMissing" argument must be a boolean');
    if (D(/^%?[^%]*%?$/, ot) === null)
      throw new o("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var U = st(ot), J = U.length > 0 ? U[0] : "", St = X("%" + J + "%", mt), Rt = St.name, zt = St.value, Tt = !1, Yt = St.alias;
    Yt && (J = Yt[0], jt(U, It([0, 1], Yt)));
    for (var Zt = 1, kt = !0; Zt < U.length; Zt += 1) {
      var _e = U[Zt], Ye = L(_e, 0, 1), wt = L(_e, -1);
      if ((Ye === '"' || Ye === "'" || Ye === "`" || wt === '"' || wt === "'" || wt === "`") && Ye !== wt)
        throw new o("property names with quotes must have matching quotes");
      if ((_e === "constructor" || !kt) && (Tt = !0), J += "." + _e, Rt = "%" + J + "%", Ct(rt, Rt))
        zt = rt[Rt];
      else if (zt != null) {
        if (!(_e in zt)) {
          if (!mt)
            throw new a("base intrinsic for " + ot + " exists, but the property is not available.");
          return;
        }
        if (A && Zt + 1 >= U.length) {
          var le = A(zt, _e);
          kt = !!le, kt && "get" in le && !("originalValue" in le.get) ? zt = le.get : zt = zt[_e];
        } else
          kt = Ct(zt, _e), zt = zt[_e];
        kt && !Tt && (rt[Rt] = zt);
      }
    }
    return zt;
  }, Wv;
}
var qv, N_;
function tg() {
  if (N_) return qv;
  N_ = 1;
  var e = /* @__PURE__ */ nN(), t = F5(), r = t([e("%String.prototype.indexOf%")]);
  return qv = function(n, i) {
    var s = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      e(n, !!i)
    );
    return typeof s == "function" && r(n, ".prototype.") > -1 ? t([s]) : s;
  }, qv;
}
var Yv, D_;
function Xct() {
  if (D_) return Yv;
  D_ = 1;
  var e = L2()(), t = /* @__PURE__ */ tg(), r = t("Object.prototype.toString"), n = function(o) {
    return e && o && typeof o == "object" && Symbol.toStringTag in o ? !1 : r(o) === "[object Arguments]";
  }, i = function(o) {
    return n(o) ? !0 : o !== null && typeof o == "object" && "length" in o && typeof o.length == "number" && o.length >= 0 && r(o) !== "[object Array]" && "callee" in o && r(o.callee) === "[object Function]";
  }, s = function() {
    return n(arguments);
  }();
  return n.isLegacyArguments = i, Yv = s ? n : i, Yv;
}
var Kv, B_;
function tut() {
  if (B_) return Kv;
  B_ = 1;
  var e = /* @__PURE__ */ tg(), t = L2()(), r = /* @__PURE__ */ rN(), n = /* @__PURE__ */ zp(), i;
  if (t) {
    var s = e("RegExp.prototype.exec"), o = {}, a = function() {
      throw o;
    }, l = {
      toString: a,
      valueOf: a
    };
    typeof Symbol.toPrimitive == "symbol" && (l[Symbol.toPrimitive] = a), i = function(u) {
      if (!u || typeof u != "object")
        return !1;
      var p = (
        /** @type {NonNullable<typeof gOPD>} */
        n(
          /** @type {{ lastIndex?: unknown }} */
          u,
          "lastIndex"
        )
      ), y = p && r(p, "value");
      if (!y)
        return !1;
      try {
        s(
          u,
          /** @type {string} */
          /** @type {unknown} */
          l
        );
      } catch (g) {
        return g === o;
      }
    };
  } else {
    var c = e("Object.prototype.toString"), h = "[object RegExp]";
    i = function(u) {
      return !u || typeof u != "object" && typeof u != "function" ? !1 : c(u) === h;
    };
  }
  return Kv = i, Kv;
}
var Zv, j_;
function eut() {
  if (j_) return Zv;
  j_ = 1;
  var e = /* @__PURE__ */ tg(), t = tut(), r = e("RegExp.prototype.exec"), n = /* @__PURE__ */ J0();
  return Zv = function(i) {
    if (!t(i))
      throw new n("`regex` must be a RegExp");
    return function(s) {
      return r(i, s) !== null;
    };
  }, Zv;
}
var Jv, F_;
function rut() {
  if (F_) return Jv;
  F_ = 1;
  var e = /* @__PURE__ */ tg(), t = /* @__PURE__ */ eut(), r = t(/^\s*(?:function)?\*/), n = L2()(), i = eN(), s = e("Object.prototype.toString"), o = e("Function.prototype.toString"), a = function() {
    if (!n)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, l;
  return Jv = function(c) {
    if (typeof c != "function")
      return !1;
    if (r(o(c)))
      return !0;
    if (!n) {
      var h = s(c);
      return h === "[object GeneratorFunction]";
    }
    if (!i)
      return !1;
    if (typeof l > "u") {
      var u = a();
      l = u ? (
        /** @type {GeneratorFunctionConstructor} */
        i(u)
      ) : !1;
    }
    return i(c) === l;
  }, Jv;
}
var Xv, $_;
function nut() {
  if ($_) return Xv;
  $_ = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, n;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw n;
        }
      }), n = {}, t(function() {
        throw 42;
      }, null, r);
    } catch (A) {
      A !== n && (t = null);
    }
  else
    t = null;
  var i = /^\s*class\b/, s = function(A) {
    try {
      var x = e.call(A);
      return i.test(x);
    } catch {
      return !1;
    }
  }, o = function(A) {
    try {
      return s(A) ? !1 : (e.call(A), !0);
    } catch {
      return !1;
    }
  }, a = Object.prototype.toString, l = "[object Object]", c = "[object Function]", h = "[object GeneratorFunction]", u = "[object HTMLAllCollection]", p = "[object HTML document.all class]", y = "[object HTMLCollection]", g = typeof Symbol == "function" && !!Symbol.toStringTag, b = !(0 in [,]), f = function() {
    return !1;
  };
  if (typeof document == "object") {
    var E = document.all;
    a.call(E) === a.call(document.all) && (f = function(A) {
      if ((b || !A) && (typeof A > "u" || typeof A == "object"))
        try {
          var x = a.call(A);
          return (x === u || x === p || x === y || x === l) && A("") == null;
        } catch {
        }
      return !1;
    });
  }
  return Xv = t ? function(A) {
    if (f(A))
      return !0;
    if (!A || typeof A != "function" && typeof A != "object")
      return !1;
    try {
      t(A, null, r);
    } catch (x) {
      if (x !== n)
        return !1;
    }
    return !s(A) && o(A);
  } : function(A) {
    if (f(A))
      return !0;
    if (!A || typeof A != "function" && typeof A != "object")
      return !1;
    if (g)
      return o(A);
    if (s(A))
      return !1;
    var x = a.call(A);
    return x !== c && x !== h && !/^\[object HTML/.test(x) ? !1 : o(A);
  }, Xv;
}
var tw, z_;
function iut() {
  if (z_) return tw;
  z_ = 1;
  var e = nut(), t = Object.prototype.toString, r = Object.prototype.hasOwnProperty, n = function(a, l, c) {
    for (var h = 0, u = a.length; h < u; h++)
      r.call(a, h) && (c == null ? l(a[h], h, a) : l.call(c, a[h], h, a));
  }, i = function(a, l, c) {
    for (var h = 0, u = a.length; h < u; h++)
      c == null ? l(a.charAt(h), h, a) : l.call(c, a.charAt(h), h, a);
  }, s = function(a, l, c) {
    for (var h in a)
      r.call(a, h) && (c == null ? l(a[h], h, a) : l.call(c, a[h], h, a));
  }, o = function(a, l, c) {
    if (!e(l))
      throw new TypeError("iterator must be a function");
    var h;
    arguments.length >= 3 && (h = c), t.call(a) === "[object Array]" ? n(a, l, h) : typeof a == "string" ? i(a, l, h) : s(a, l, h);
  };
  return tw = o, tw;
}
var V_, U_;
function sut() {
  return U_ || (U_ = 1, V_ = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), V_;
}
var ew, H_;
function out() {
  if (H_) return ew;
  H_ = 1;
  var e = /* @__PURE__ */ sut(), t = typeof globalThis > "u" ? Dl : globalThis;
  return ew = function() {
    for (var r = [], n = 0; n < e.length; n++)
      typeof t[e[n]] == "function" && (r[r.length] = e[n]);
    return r;
  }, ew;
}
var G_ = { exports: {} }, rw, Q_;
function aut() {
  if (Q_) return rw;
  Q_ = 1;
  var e = /* @__PURE__ */ M2(), t = /* @__PURE__ */ ZM(), r = /* @__PURE__ */ J0(), n = /* @__PURE__ */ zp();
  return rw = function(i, s, o) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new r("`obj` must be an object or a function`");
    if (typeof s != "string" && typeof s != "symbol")
      throw new r("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new r("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new r("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new r("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new r("`loose`, if provided, must be a boolean");
    var a = arguments.length > 3 ? arguments[3] : null, l = arguments.length > 4 ? arguments[4] : null, c = arguments.length > 5 ? arguments[5] : null, h = arguments.length > 6 ? arguments[6] : !1, u = !!n && n(i, s);
    if (e)
      e(i, s, {
        configurable: c === null && u ? u.configurable : !c,
        enumerable: a === null && u ? u.enumerable : !a,
        value: o,
        writable: l === null && u ? u.writable : !l
      });
    else if (h || !a && !l && !c)
      i[s] = o;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, rw;
}
var nw, W_;
function lut() {
  if (W_) return nw;
  W_ = 1;
  var e = /* @__PURE__ */ M2(), t = function() {
    return !!e;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, nw = t, nw;
}
var iw, q_;
function cut() {
  if (q_) return iw;
  q_ = 1;
  var e = /* @__PURE__ */ nN(), t = /* @__PURE__ */ aut(), r = /* @__PURE__ */ lut()(), n = /* @__PURE__ */ zp(), i = /* @__PURE__ */ J0(), s = e("%Math.floor%");
  return iw = function(o, a) {
    if (typeof o != "function")
      throw new i("`fn` is not a function");
    if (typeof a != "number" || a < 0 || a > 4294967295 || s(a) !== a)
      throw new i("`length` must be a positive 32-bit integer");
    var l = arguments.length > 2 && !!arguments[2], c = !0, h = !0;
    if ("length" in o && n) {
      var u = n(o, "length");
      u && !u.configurable && (c = !1), u && !u.writable && (h = !1);
    }
    return (c || h || !l) && (r ? t(
      /** @type {Parameters<define>[0]} */
      o,
      "length",
      a,
      !0,
      !0
    ) : t(
      /** @type {Parameters<define>[0]} */
      o,
      "length",
      a
    )), o;
  }, iw;
}
var sw, Y_;
function uut() {
  if (Y_) return sw;
  Y_ = 1;
  var e = X0(), t = j5(), r = tN();
  return sw = function() {
    return r(e, t, arguments);
  }, sw;
}
var K_;
function hut() {
  return K_ || (K_ = 1, function(e) {
    var t = /* @__PURE__ */ cut(), r = /* @__PURE__ */ M2(), n = F5(), i = uut();
    e.exports = function(s) {
      var o = n(arguments), a = s.length - (arguments.length - 1);
      return t(
        o,
        1 + (a > 0 ? a : 0),
        !0
      );
    }, r ? r(e.exports, "apply", { value: i }) : e.exports.apply = i;
  }(G_)), G_.exports;
}
var ow, Z_;
function iN() {
  if (Z_) return ow;
  Z_ = 1;
  var e = iut(), t = /* @__PURE__ */ out(), r = hut(), n = /* @__PURE__ */ tg(), i = /* @__PURE__ */ zp(), s = n("Object.prototype.toString"), o = L2()(), a = typeof globalThis > "u" ? Dl : globalThis, l = t(), c = n("String.prototype.slice"), h = Object.getPrototypeOf, u = n("Array.prototype.indexOf", !0) || function(b, f) {
    for (var E = 0; E < b.length; E += 1)
      if (b[E] === f)
        return E;
    return -1;
  }, p = { __proto__: null };
  o && i && h ? e(l, function(b) {
    var f = new a[b]();
    if (Symbol.toStringTag in f) {
      var E = h(f), A = i(E, Symbol.toStringTag);
      if (!A) {
        var x = h(E);
        A = i(x, Symbol.toStringTag);
      }
      p["$" + b] = r(A.get);
    }
  }) : e(l, function(b) {
    var f = new a[b](), E = f.slice || f.set;
    E && (p["$" + b] = r(E));
  });
  var y = function(b) {
    var f = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      p,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, A) {
        if (!f)
          try {
            "$" + E(b) === A && (f = c(A, 1));
          } catch {
          }
      }
    ), f;
  }, g = function(b) {
    var f = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      p,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, A) {
        if (!f)
          try {
            E(b), f = c(A, 1);
          } catch {
          }
      }
    ), f;
  };
  return ow = function(b) {
    if (!b || typeof b != "object")
      return !1;
    if (!o) {
      var f = c(s(b), 8, -1);
      return u(l, f) > -1 ? f : f !== "Object" ? !1 : g(b);
    }
    return i ? y(b) : null;
  }, ow;
}
var aw, J_;
function put() {
  if (J_) return aw;
  J_ = 1;
  var e = /* @__PURE__ */ iN();
  return aw = function(t) {
    return !!e(t);
  }, aw;
}
var X_;
function dut() {
  return X_ || (X_ = 1, function(e) {
    var t = /* @__PURE__ */ Xct(), r = rut(), n = /* @__PURE__ */ iN(), i = /* @__PURE__ */ put();
    function s(kt) {
      return kt.call.bind(kt);
    }
    var o = typeof BigInt < "u", a = typeof Symbol < "u", l = s(Object.prototype.toString), c = s(Number.prototype.valueOf), h = s(String.prototype.valueOf), u = s(Boolean.prototype.valueOf);
    if (o)
      var p = s(BigInt.prototype.valueOf);
    if (a)
      var y = s(Symbol.prototype.valueOf);
    function g(kt, _e) {
      if (typeof kt != "object")
        return !1;
      try {
        return _e(kt), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = i;
    function b(kt) {
      return typeof Promise < "u" && kt instanceof Promise || kt !== null && typeof kt == "object" && typeof kt.then == "function" && typeof kt.catch == "function";
    }
    e.isPromise = b;
    function f(kt) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(kt) : i(kt) || L(kt);
    }
    e.isArrayBufferView = f;
    function E(kt) {
      return n(kt) === "Uint8Array";
    }
    e.isUint8Array = E;
    function A(kt) {
      return n(kt) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = A;
    function x(kt) {
      return n(kt) === "Uint16Array";
    }
    e.isUint16Array = x;
    function m(kt) {
      return n(kt) === "Uint32Array";
    }
    e.isUint32Array = m;
    function w(kt) {
      return n(kt) === "Int8Array";
    }
    e.isInt8Array = w;
    function _(kt) {
      return n(kt) === "Int16Array";
    }
    e.isInt16Array = _;
    function S(kt) {
      return n(kt) === "Int32Array";
    }
    e.isInt32Array = S;
    function R(kt) {
      return n(kt) === "Float32Array";
    }
    e.isFloat32Array = R;
    function O(kt) {
      return n(kt) === "Float64Array";
    }
    e.isFloat64Array = O;
    function $(kt) {
      return n(kt) === "BigInt64Array";
    }
    e.isBigInt64Array = $;
    function z(kt) {
      return n(kt) === "BigUint64Array";
    }
    e.isBigUint64Array = z;
    function F(kt) {
      return l(kt) === "[object Map]";
    }
    F.working = typeof Map < "u" && F(/* @__PURE__ */ new Map());
    function Y(kt) {
      return typeof Map > "u" ? !1 : F.working ? F(kt) : kt instanceof Map;
    }
    e.isMap = Y;
    function rt(kt) {
      return l(kt) === "[object Set]";
    }
    rt.working = typeof Set < "u" && rt(/* @__PURE__ */ new Set());
    function at(kt) {
      return typeof Set > "u" ? !1 : rt.working ? rt(kt) : kt instanceof Set;
    }
    e.isSet = at;
    function pt(kt) {
      return l(kt) === "[object WeakMap]";
    }
    pt.working = typeof WeakMap < "u" && pt(/* @__PURE__ */ new WeakMap());
    function vt(kt) {
      return typeof WeakMap > "u" ? !1 : pt.working ? pt(kt) : kt instanceof WeakMap;
    }
    e.isWeakMap = vt;
    function _t(kt) {
      return l(kt) === "[object WeakSet]";
    }
    _t.working = typeof WeakSet < "u" && _t(/* @__PURE__ */ new WeakSet());
    function Ct(kt) {
      return _t(kt);
    }
    e.isWeakSet = Ct;
    function It(kt) {
      return l(kt) === "[object ArrayBuffer]";
    }
    It.working = typeof ArrayBuffer < "u" && It(new ArrayBuffer());
    function jt(kt) {
      return typeof ArrayBuffer > "u" ? !1 : It.working ? It(kt) : kt instanceof ArrayBuffer;
    }
    e.isArrayBuffer = jt;
    function lt(kt) {
      return l(kt) === "[object DataView]";
    }
    lt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && lt(new DataView(new ArrayBuffer(1), 0, 1));
    function L(kt) {
      return typeof DataView > "u" ? !1 : lt.working ? lt(kt) : kt instanceof DataView;
    }
    e.isDataView = L;
    var D = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function tt(kt) {
      return l(kt) === "[object SharedArrayBuffer]";
    }
    function et(kt) {
      return typeof D > "u" ? !1 : (typeof tt.working > "u" && (tt.working = tt(new D())), tt.working ? tt(kt) : kt instanceof D);
    }
    e.isSharedArrayBuffer = et;
    function st(kt) {
      return l(kt) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = st;
    function X(kt) {
      return l(kt) === "[object Map Iterator]";
    }
    e.isMapIterator = X;
    function ot(kt) {
      return l(kt) === "[object Set Iterator]";
    }
    e.isSetIterator = ot;
    function mt(kt) {
      return l(kt) === "[object Generator]";
    }
    e.isGeneratorObject = mt;
    function U(kt) {
      return l(kt) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = U;
    function J(kt) {
      return g(kt, c);
    }
    e.isNumberObject = J;
    function St(kt) {
      return g(kt, h);
    }
    e.isStringObject = St;
    function Rt(kt) {
      return g(kt, u);
    }
    e.isBooleanObject = Rt;
    function zt(kt) {
      return o && g(kt, p);
    }
    e.isBigIntObject = zt;
    function Tt(kt) {
      return a && g(kt, y);
    }
    e.isSymbolObject = Tt;
    function Yt(kt) {
      return J(kt) || St(kt) || Rt(kt) || zt(kt) || Tt(kt);
    }
    e.isBoxedPrimitive = Yt;
    function Zt(kt) {
      return typeof Uint8Array < "u" && (jt(kt) || et(kt));
    }
    e.isAnyArrayBuffer = Zt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(kt) {
      Object.defineProperty(e, kt, {
        enumerable: !1,
        value: function() {
          throw new Error(kt + " is not supported in userland");
        }
      });
    });
  }(O7)), O7;
}
var tk, ek;
function fut() {
  return ek || (ek = 1, tk = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  }), tk;
}
var rk;
function sN() {
  return rk || (rk = 1, function(e) {
    var t = Object.getOwnPropertyDescriptors || function(lt) {
      for (var L = Object.keys(lt), D = {}, tt = 0; tt < L.length; tt++)
        D[L[tt]] = Object.getOwnPropertyDescriptor(lt, L[tt]);
      return D;
    }, r = /%[sdj%]/g;
    e.format = function(lt) {
      if (!w(lt)) {
        for (var L = [], D = 0; D < arguments.length; D++)
          L.push(o(arguments[D]));
        return L.join(" ");
      }
      for (var D = 1, tt = arguments, et = tt.length, st = String(lt).replace(r, function(mt) {
        if (mt === "%%") return "%";
        if (D >= et) return mt;
        switch (mt) {
          case "%s":
            return String(tt[D++]);
          case "%d":
            return Number(tt[D++]);
          case "%j":
            try {
              return JSON.stringify(tt[D++]);
            } catch {
              return "[Circular]";
            }
          default:
            return mt;
        }
      }), X = tt[D]; D < et; X = tt[++D])
        A(X) || !O(X) ? st += " " + X : st += " " + o(X);
      return st;
    }, e.deprecate = function(lt, L) {
      if (typeof je < "u" && je.noDeprecation === !0)
        return lt;
      if (typeof je > "u")
        return function() {
          return e.deprecate(lt, L).apply(this, arguments);
        };
      var D = !1;
      function tt() {
        if (!D) {
          if (je.throwDeprecation)
            throw new Error(L);
          je.traceDeprecation ? console.trace(L) : console.error(L), D = !0;
        }
        return lt.apply(this, arguments);
      }
      return tt;
    };
    var n = {}, i = /^$/;
    if (je.env.NODE_DEBUG) {
      var s = je.env.NODE_DEBUG;
      s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + s + "$", "i");
    }
    e.debuglog = function(lt) {
      if (lt = lt.toUpperCase(), !n[lt])
        if (i.test(lt)) {
          var L = je.pid;
          n[lt] = function() {
            var D = e.format.apply(e, arguments);
            console.error("%s %d: %s", lt, L, D);
          };
        } else
          n[lt] = function() {
          };
      return n[lt];
    };
    function o(lt, L) {
      var D = {
        seen: [],
        stylize: l
      };
      return arguments.length >= 3 && (D.depth = arguments[2]), arguments.length >= 4 && (D.colors = arguments[3]), E(L) ? D.showHidden = L : L && e._extend(D, L), S(D.showHidden) && (D.showHidden = !1), S(D.depth) && (D.depth = 2), S(D.colors) && (D.colors = !1), S(D.customInspect) && (D.customInspect = !0), D.colors && (D.stylize = a), h(D, lt, D.depth);
    }
    e.inspect = o, o.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, o.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function a(lt, L) {
      var D = o.styles[L];
      return D ? "\x1B[" + o.colors[D][0] + "m" + lt + "\x1B[" + o.colors[D][1] + "m" : lt;
    }
    function l(lt, L) {
      return lt;
    }
    function c(lt) {
      var L = {};
      return lt.forEach(function(D, tt) {
        L[D] = !0;
      }), L;
    }
    function h(lt, L, D) {
      if (lt.customInspect && L && F(L.inspect) && // Filter out the util module, it's inspect function is special
      L.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(L.constructor && L.constructor.prototype === L)) {
        var tt = L.inspect(D, lt);
        return w(tt) || (tt = h(lt, tt, D)), tt;
      }
      var et = u(lt, L);
      if (et)
        return et;
      var st = Object.keys(L), X = c(st);
      if (lt.showHidden && (st = Object.getOwnPropertyNames(L)), z(L) && (st.indexOf("message") >= 0 || st.indexOf("description") >= 0))
        return p(L);
      if (st.length === 0) {
        if (F(L)) {
          var ot = L.name ? ": " + L.name : "";
          return lt.stylize("[Function" + ot + "]", "special");
        }
        if (R(L))
          return lt.stylize(RegExp.prototype.toString.call(L), "regexp");
        if ($(L))
          return lt.stylize(Date.prototype.toString.call(L), "date");
        if (z(L))
          return p(L);
      }
      var mt = "", U = !1, J = ["{", "}"];
      if (f(L) && (U = !0, J = ["[", "]"]), F(L)) {
        var St = L.name ? ": " + L.name : "";
        mt = " [Function" + St + "]";
      }
      if (R(L) && (mt = " " + RegExp.prototype.toString.call(L)), $(L) && (mt = " " + Date.prototype.toUTCString.call(L)), z(L) && (mt = " " + p(L)), st.length === 0 && (!U || L.length == 0))
        return J[0] + mt + J[1];
      if (D < 0)
        return R(L) ? lt.stylize(RegExp.prototype.toString.call(L), "regexp") : lt.stylize("[Object]", "special");
      lt.seen.push(L);
      var Rt;
      return U ? Rt = y(lt, L, D, X, st) : Rt = st.map(function(zt) {
        return g(lt, L, D, X, zt, U);
      }), lt.seen.pop(), b(Rt, mt, J);
    }
    function u(lt, L) {
      if (S(L))
        return lt.stylize("undefined", "undefined");
      if (w(L)) {
        var D = "'" + JSON.stringify(L).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return lt.stylize(D, "string");
      }
      if (m(L))
        return lt.stylize("" + L, "number");
      if (E(L))
        return lt.stylize("" + L, "boolean");
      if (A(L))
        return lt.stylize("null", "null");
    }
    function p(lt) {
      return "[" + Error.prototype.toString.call(lt) + "]";
    }
    function y(lt, L, D, tt, et) {
      for (var st = [], X = 0, ot = L.length; X < ot; ++X)
        _t(L, String(X)) ? st.push(g(
          lt,
          L,
          D,
          tt,
          String(X),
          !0
        )) : st.push("");
      return et.forEach(function(mt) {
        mt.match(/^\d+$/) || st.push(g(
          lt,
          L,
          D,
          tt,
          mt,
          !0
        ));
      }), st;
    }
    function g(lt, L, D, tt, et, st) {
      var X, ot, mt;
      if (mt = Object.getOwnPropertyDescriptor(L, et) || { value: L[et] }, mt.get ? mt.set ? ot = lt.stylize("[Getter/Setter]", "special") : ot = lt.stylize("[Getter]", "special") : mt.set && (ot = lt.stylize("[Setter]", "special")), _t(tt, et) || (X = "[" + et + "]"), ot || (lt.seen.indexOf(mt.value) < 0 ? (A(D) ? ot = h(lt, mt.value, null) : ot = h(lt, mt.value, D - 1), ot.indexOf(`
`) > -1 && (st ? ot = ot.split(`
`).map(function(U) {
        return "  " + U;
      }).join(`
`).slice(2) : ot = `
` + ot.split(`
`).map(function(U) {
        return "   " + U;
      }).join(`
`))) : ot = lt.stylize("[Circular]", "special")), S(X)) {
        if (st && et.match(/^\d+$/))
          return ot;
        X = JSON.stringify("" + et), X.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (X = X.slice(1, -1), X = lt.stylize(X, "name")) : (X = X.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), X = lt.stylize(X, "string"));
      }
      return X + ": " + ot;
    }
    function b(lt, L, D) {
      var tt = lt.reduce(function(et, st) {
        return st.indexOf(`
`) >= 0, et + st.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return tt > 60 ? D[0] + (L === "" ? "" : L + `
 `) + " " + lt.join(`,
  `) + " " + D[1] : D[0] + L + " " + lt.join(", ") + " " + D[1];
    }
    e.types = dut();
    function f(lt) {
      return Array.isArray(lt);
    }
    e.isArray = f;
    function E(lt) {
      return typeof lt == "boolean";
    }
    e.isBoolean = E;
    function A(lt) {
      return lt === null;
    }
    e.isNull = A;
    function x(lt) {
      return lt == null;
    }
    e.isNullOrUndefined = x;
    function m(lt) {
      return typeof lt == "number";
    }
    e.isNumber = m;
    function w(lt) {
      return typeof lt == "string";
    }
    e.isString = w;
    function _(lt) {
      return typeof lt == "symbol";
    }
    e.isSymbol = _;
    function S(lt) {
      return lt === void 0;
    }
    e.isUndefined = S;
    function R(lt) {
      return O(lt) && rt(lt) === "[object RegExp]";
    }
    e.isRegExp = R, e.types.isRegExp = R;
    function O(lt) {
      return typeof lt == "object" && lt !== null;
    }
    e.isObject = O;
    function $(lt) {
      return O(lt) && rt(lt) === "[object Date]";
    }
    e.isDate = $, e.types.isDate = $;
    function z(lt) {
      return O(lt) && (rt(lt) === "[object Error]" || lt instanceof Error);
    }
    e.isError = z, e.types.isNativeError = z;
    function F(lt) {
      return typeof lt == "function";
    }
    e.isFunction = F;
    function Y(lt) {
      return lt === null || typeof lt == "boolean" || typeof lt == "number" || typeof lt == "string" || typeof lt == "symbol" || // ES6 symbol
      typeof lt > "u";
    }
    e.isPrimitive = Y, e.isBuffer = fut();
    function rt(lt) {
      return Object.prototype.toString.call(lt);
    }
    function at(lt) {
      return lt < 10 ? "0" + lt.toString(10) : lt.toString(10);
    }
    var pt = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function vt() {
      var lt = /* @__PURE__ */ new Date(), L = [
        at(lt.getHours()),
        at(lt.getMinutes()),
        at(lt.getSeconds())
      ].join(":");
      return [lt.getDate(), pt[lt.getMonth()], L].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", vt(), e.format.apply(e, arguments));
    }, e.inherits = Zu(), e._extend = function(lt, L) {
      if (!L || !O(L)) return lt;
      for (var D = Object.keys(L), tt = D.length; tt--; )
        lt[D[tt]] = L[D[tt]];
      return lt;
    };
    function _t(lt, L) {
      return Object.prototype.hasOwnProperty.call(lt, L);
    }
    var Ct = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(lt) {
      if (typeof lt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (Ct && lt[Ct]) {
        var L = lt[Ct];
        if (typeof L != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(L, Ct, {
          value: L,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), L;
      }
      function L() {
        for (var D, tt, et = new Promise(function(ot, mt) {
          D = ot, tt = mt;
        }), st = [], X = 0; X < arguments.length; X++)
          st.push(arguments[X]);
        st.push(function(ot, mt) {
          ot ? tt(ot) : D(mt);
        });
        try {
          lt.apply(this, st);
        } catch (ot) {
          tt(ot);
        }
        return et;
      }
      return Object.setPrototypeOf(L, Object.getPrototypeOf(lt)), Ct && Object.defineProperty(L, Ct, {
        value: L,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        L,
        t(lt)
      );
    }, e.promisify.custom = Ct;
    function It(lt, L) {
      if (!lt) {
        var D = new Error("Promise was rejected with a falsy value");
        D.reason = lt, lt = D;
      }
      return L(lt);
    }
    function jt(lt) {
      if (typeof lt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function L() {
        for (var D = [], tt = 0; tt < arguments.length; tt++)
          D.push(arguments[tt]);
        var et = D.pop();
        if (typeof et != "function")
          throw new TypeError("The last argument must be of type Function");
        var st = this, X = function() {
          return et.apply(st, arguments);
        };
        lt.apply(this, D).then(
          function(ot) {
            je.nextTick(X.bind(null, null, ot));
          },
          function(ot) {
            je.nextTick(It.bind(null, ot, X));
          }
        );
      }
      return Object.setPrototypeOf(L, Object.getPrototypeOf(lt)), Object.defineProperties(
        L,
        t(lt)
      ), L;
    }
    e.callbackify = jt;
  }(T7)), T7;
}
var lw, nk;
function gut() {
  if (nk) return lw;
  nk = 1;
  function e(g, b) {
    var f = Object.keys(g);
    if (Object.getOwnPropertySymbols) {
      var E = Object.getOwnPropertySymbols(g);
      b && (E = E.filter(function(A) {
        return Object.getOwnPropertyDescriptor(g, A).enumerable;
      })), f.push.apply(f, E);
    }
    return f;
  }
  function t(g) {
    for (var b = 1; b < arguments.length; b++) {
      var f = arguments[b] != null ? arguments[b] : {};
      b % 2 ? e(Object(f), !0).forEach(function(E) {
        r(g, E, f[E]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(g, Object.getOwnPropertyDescriptors(f)) : e(Object(f)).forEach(function(E) {
        Object.defineProperty(g, E, Object.getOwnPropertyDescriptor(f, E));
      });
    }
    return g;
  }
  function r(g, b, f) {
    return b = o(b), b in g ? Object.defineProperty(g, b, { value: f, enumerable: !0, configurable: !0, writable: !0 }) : g[b] = f, g;
  }
  function n(g, b) {
    if (!(g instanceof b))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(g, b) {
    for (var f = 0; f < b.length; f++) {
      var E = b[f];
      E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(g, o(E.key), E);
    }
  }
  function s(g, b, f) {
    return b && i(g.prototype, b), Object.defineProperty(g, "prototype", { writable: !1 }), g;
  }
  function o(g) {
    var b = a(g, "string");
    return typeof b == "symbol" ? b : String(b);
  }
  function a(g, b) {
    if (typeof g != "object" || g === null) return g;
    var f = g[Symbol.toPrimitive];
    if (f !== void 0) {
      var E = f.call(g, b);
      if (typeof E != "object") return E;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(g);
  }
  var l = O2(), c = l.Buffer, h = sN(), u = h.inspect, p = u && u.custom || "inspect";
  function y(g, b, f) {
    c.prototype.copy.call(g, b, f);
  }
  return lw = /* @__PURE__ */ function() {
    function g() {
      n(this, g), this.head = null, this.tail = null, this.length = 0;
    }
    return s(g, [{
      key: "push",
      value: function(b) {
        var f = {
          data: b,
          next: null
        };
        this.length > 0 ? this.tail.next = f : this.head = f, this.tail = f, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(b) {
        var f = {
          data: b,
          next: this.head
        };
        this.length === 0 && (this.tail = f), this.head = f, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var b = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, b;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(b) {
        if (this.length === 0) return "";
        for (var f = this.head, E = "" + f.data; f = f.next; ) E += b + f.data;
        return E;
      }
    }, {
      key: "concat",
      value: function(b) {
        if (this.length === 0) return c.alloc(0);
        for (var f = c.allocUnsafe(b >>> 0), E = this.head, A = 0; E; )
          y(E.data, f, A), A += E.data.length, E = E.next;
        return f;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(b, f) {
        var E;
        return b < this.head.data.length ? (E = this.head.data.slice(0, b), this.head.data = this.head.data.slice(b)) : b === this.head.data.length ? E = this.shift() : E = f ? this._getString(b) : this._getBuffer(b), E;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(b) {
        var f = this.head, E = 1, A = f.data;
        for (b -= A.length; f = f.next; ) {
          var x = f.data, m = b > x.length ? x.length : b;
          if (m === x.length ? A += x : A += x.slice(0, b), b -= m, b === 0) {
            m === x.length ? (++E, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = x.slice(m));
            break;
          }
          ++E;
        }
        return this.length -= E, A;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(b) {
        var f = c.allocUnsafe(b), E = this.head, A = 1;
        for (E.data.copy(f), b -= E.data.length; E = E.next; ) {
          var x = E.data, m = b > x.length ? x.length : b;
          if (x.copy(f, f.length - b, 0, m), b -= m, b === 0) {
            m === x.length ? (++A, E.next ? this.head = E.next : this.head = this.tail = null) : (this.head = E, E.data = x.slice(m));
            break;
          }
          ++A;
        }
        return this.length -= A, f;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: p,
      value: function(b, f) {
        return u(this, t(t({}, f), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), g;
  }(), lw;
}
var cw, ik;
function oN() {
  if (ik) return cw;
  ik = 1;
  function e(o, a) {
    var l = this, c = this._readableState && this._readableState.destroyed, h = this._writableState && this._writableState.destroyed;
    return c || h ? (a ? a(o) : o && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, je.nextTick(i, this, o)) : je.nextTick(i, this, o)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(o || null, function(u) {
      !a && u ? l._writableState ? l._writableState.errorEmitted ? je.nextTick(r, l) : (l._writableState.errorEmitted = !0, je.nextTick(t, l, u)) : je.nextTick(t, l, u) : a ? (je.nextTick(r, l), a(u)) : je.nextTick(r, l);
    }), this);
  }
  function t(o, a) {
    i(o, a), r(o);
  }
  function r(o) {
    o._writableState && !o._writableState.emitClose || o._readableState && !o._readableState.emitClose || o.emit("close");
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function i(o, a) {
    o.emit("error", a);
  }
  function s(o, a) {
    var l = o._readableState, c = o._writableState;
    l && l.autoDestroy || c && c.autoDestroy ? o.destroy(a) : o.emit("error", a);
  }
  return cw = {
    destroy: e,
    undestroy: n,
    errorOrDestroy: s
  }, cw;
}
var uw = {}, sk;
function Vp() {
  if (sk) return uw;
  sk = 1;
  function e(a, l) {
    a.prototype = Object.create(l.prototype), a.prototype.constructor = a, a.__proto__ = l;
  }
  var t = {};
  function r(a, l, c) {
    c || (c = Error);
    function h(p, y, g) {
      return typeof l == "string" ? l : l(p, y, g);
    }
    var u = /* @__PURE__ */ function(p) {
      e(y, p);
      function y(g, b, f) {
        return p.call(this, h(g, b, f)) || this;
      }
      return y;
    }(c);
    u.prototype.name = c.name, u.prototype.code = a, t[a] = u;
  }
  function n(a, l) {
    if (Array.isArray(a)) {
      var c = a.length;
      return a = a.map(function(h) {
        return String(h);
      }), c > 2 ? "one of ".concat(l, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(l, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(l, " ").concat(a[0]);
    } else
      return "of ".concat(l, " ").concat(String(a));
  }
  function i(a, l, c) {
    return a.substr(0, l.length) === l;
  }
  function s(a, l, c) {
    return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - l.length, c) === l;
  }
  function o(a, l, c) {
    return typeof c != "number" && (c = 0), c + l.length > a.length ? !1 : a.indexOf(l, c) !== -1;
  }
  return r("ERR_INVALID_OPT_VALUE", function(a, l) {
    return 'The value "' + l + '" is invalid for option "' + a + '"';
  }, TypeError), r("ERR_INVALID_ARG_TYPE", function(a, l, c) {
    var h;
    typeof l == "string" && i(l, "not ") ? (h = "must not be", l = l.replace(/^not /, "")) : h = "must be";
    var u;
    if (s(a, " argument"))
      u = "The ".concat(a, " ").concat(h, " ").concat(n(l, "type"));
    else {
      var p = o(a, ".") ? "property" : "argument";
      u = 'The "'.concat(a, '" ').concat(p, " ").concat(h, " ").concat(n(l, "type"));
    }
    return u += ". Received type ".concat(typeof c), u;
  }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
    return "The " + a + " method is not implemented";
  }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(a) {
    return "Cannot call " + a + " after a stream was destroyed";
  }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(a) {
    return "Unknown encoding: " + a;
  }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), uw.codes = t, uw;
}
var hw, ok;
function aN() {
  if (ok) return hw;
  ok = 1;
  var e = Vp().codes.ERR_INVALID_OPT_VALUE;
  function t(n, i, s) {
    return n.highWaterMark != null ? n.highWaterMark : i ? n[s] : null;
  }
  function r(n, i, s, o) {
    var a = t(i, o, s);
    if (a != null) {
      if (!(isFinite(a) && Math.floor(a) === a) || a < 0) {
        var l = o ? s : "highWaterMark";
        throw new e(l, a);
      }
      return Math.floor(a);
    }
    return n.objectMode ? 16 : 16 * 1024;
  }
  return hw = {
    getHighWaterMark: r
  }, hw;
}
var pw, ak;
function mut() {
  if (ak) return pw;
  ak = 1, pw = e;
  function e(r, n) {
    if (t("noDeprecation"))
      return r;
    var i = !1;
    function s() {
      if (!i) {
        if (t("throwDeprecation"))
          throw new Error(n);
        t("traceDeprecation") ? console.trace(n) : console.warn(n), i = !0;
      }
      return r.apply(this, arguments);
    }
    return s;
  }
  function t(r) {
    try {
      if (!Dl.localStorage) return !1;
    } catch {
      return !1;
    }
    var n = Dl.localStorage[r];
    return n == null ? !1 : String(n).toLowerCase() === "true";
  }
  return pw;
}
var dw, lk;
function lN() {
  if (lk) return dw;
  lk = 1, dw = R;
  function e(et) {
    var st = this;
    this.next = null, this.entry = null, this.finish = function() {
      tt(st, et);
    };
  }
  var t;
  R.WritableState = _;
  var r = {
    deprecate: mut()
  }, n = qM(), i = O2().Buffer, s = (typeof Dl < "u" ? Dl : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(et) {
    return i.from(et);
  }
  function a(et) {
    return i.isBuffer(et) || et instanceof s;
  }
  var l = oN(), c = aN(), h = c.getHighWaterMark, u = Vp().codes, p = u.ERR_INVALID_ARG_TYPE, y = u.ERR_METHOD_NOT_IMPLEMENTED, g = u.ERR_MULTIPLE_CALLBACK, b = u.ERR_STREAM_CANNOT_PIPE, f = u.ERR_STREAM_DESTROYED, E = u.ERR_STREAM_NULL_VALUES, A = u.ERR_STREAM_WRITE_AFTER_END, x = u.ERR_UNKNOWN_ENCODING, m = l.errorOrDestroy;
  Zu()(R, n);
  function w() {
  }
  function _(et, st, X) {
    t = t || op(), et = et || {}, typeof X != "boolean" && (X = st instanceof t), this.objectMode = !!et.objectMode, X && (this.objectMode = this.objectMode || !!et.writableObjectMode), this.highWaterMark = h(this, et, "writableHighWaterMark", X), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ot = et.decodeStrings === !1;
    this.decodeStrings = !ot, this.defaultEncoding = et.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(mt) {
      pt(st, mt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = et.emitClose !== !1, this.autoDestroy = !!et.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  _.prototype.getBuffer = function() {
    for (var et = this.bufferedRequest, st = []; et; )
      st.push(et), et = et.next;
    return st;
  }, function() {
    try {
      Object.defineProperty(_.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var S;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (S = Function.prototype[Symbol.hasInstance], Object.defineProperty(R, Symbol.hasInstance, {
    value: function(et) {
      return S.call(this, et) ? !0 : this !== R ? !1 : et && et._writableState instanceof _;
    }
  })) : S = function(et) {
    return et instanceof this;
  };
  function R(et) {
    t = t || op();
    var st = this instanceof t;
    if (!st && !S.call(R, this)) return new R(et);
    this._writableState = new _(et, this, st), this.writable = !0, et && (typeof et.write == "function" && (this._write = et.write), typeof et.writev == "function" && (this._writev = et.writev), typeof et.destroy == "function" && (this._destroy = et.destroy), typeof et.final == "function" && (this._final = et.final)), n.call(this);
  }
  R.prototype.pipe = function() {
    m(this, new b());
  };
  function O(et, st) {
    var X = new A();
    m(et, X), je.nextTick(st, X);
  }
  function $(et, st, X, ot) {
    var mt;
    return X === null ? mt = new E() : typeof X != "string" && !st.objectMode && (mt = new p("chunk", ["string", "Buffer"], X)), mt ? (m(et, mt), je.nextTick(ot, mt), !1) : !0;
  }
  R.prototype.write = function(et, st, X) {
    var ot = this._writableState, mt = !1, U = !ot.objectMode && a(et);
    return U && !i.isBuffer(et) && (et = o(et)), typeof st == "function" && (X = st, st = null), U ? st = "buffer" : st || (st = ot.defaultEncoding), typeof X != "function" && (X = w), ot.ending ? O(this, X) : (U || $(this, ot, et, X)) && (ot.pendingcb++, mt = F(this, ot, U, et, st, X)), mt;
  }, R.prototype.cork = function() {
    this._writableState.corked++;
  }, R.prototype.uncork = function() {
    var et = this._writableState;
    et.corked && (et.corked--, !et.writing && !et.corked && !et.bufferProcessing && et.bufferedRequest && Ct(this, et));
  }, R.prototype.setDefaultEncoding = function(et) {
    if (typeof et == "string" && (et = et.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((et + "").toLowerCase()) > -1)) throw new x(et);
    return this._writableState.defaultEncoding = et, this;
  }, Object.defineProperty(R.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function z(et, st, X) {
    return !et.objectMode && et.decodeStrings !== !1 && typeof st == "string" && (st = i.from(st, X)), st;
  }
  Object.defineProperty(R.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function F(et, st, X, ot, mt, U) {
    if (!X) {
      var J = z(st, ot, mt);
      ot !== J && (X = !0, mt = "buffer", ot = J);
    }
    var St = st.objectMode ? 1 : ot.length;
    st.length += St;
    var Rt = st.length < st.highWaterMark;
    if (Rt || (st.needDrain = !0), st.writing || st.corked) {
      var zt = st.lastBufferedRequest;
      st.lastBufferedRequest = {
        chunk: ot,
        encoding: mt,
        isBuf: X,
        callback: U,
        next: null
      }, zt ? zt.next = st.lastBufferedRequest : st.bufferedRequest = st.lastBufferedRequest, st.bufferedRequestCount += 1;
    } else
      Y(et, st, !1, St, ot, mt, U);
    return Rt;
  }
  function Y(et, st, X, ot, mt, U, J) {
    st.writelen = ot, st.writecb = J, st.writing = !0, st.sync = !0, st.destroyed ? st.onwrite(new f("write")) : X ? et._writev(mt, st.onwrite) : et._write(mt, U, st.onwrite), st.sync = !1;
  }
  function rt(et, st, X, ot, mt) {
    --st.pendingcb, X ? (je.nextTick(mt, ot), je.nextTick(L, et, st), et._writableState.errorEmitted = !0, m(et, ot)) : (mt(ot), et._writableState.errorEmitted = !0, m(et, ot), L(et, st));
  }
  function at(et) {
    et.writing = !1, et.writecb = null, et.length -= et.writelen, et.writelen = 0;
  }
  function pt(et, st) {
    var X = et._writableState, ot = X.sync, mt = X.writecb;
    if (typeof mt != "function") throw new g();
    if (at(X), st) rt(et, X, ot, st, mt);
    else {
      var U = It(X) || et.destroyed;
      !U && !X.corked && !X.bufferProcessing && X.bufferedRequest && Ct(et, X), ot ? je.nextTick(vt, et, X, U, mt) : vt(et, X, U, mt);
    }
  }
  function vt(et, st, X, ot) {
    X || _t(et, st), st.pendingcb--, ot(), L(et, st);
  }
  function _t(et, st) {
    st.length === 0 && st.needDrain && (st.needDrain = !1, et.emit("drain"));
  }
  function Ct(et, st) {
    st.bufferProcessing = !0;
    var X = st.bufferedRequest;
    if (et._writev && X && X.next) {
      var ot = st.bufferedRequestCount, mt = new Array(ot), U = st.corkedRequestsFree;
      U.entry = X;
      for (var J = 0, St = !0; X; )
        mt[J] = X, X.isBuf || (St = !1), X = X.next, J += 1;
      mt.allBuffers = St, Y(et, st, !0, st.length, mt, "", U.finish), st.pendingcb++, st.lastBufferedRequest = null, U.next ? (st.corkedRequestsFree = U.next, U.next = null) : st.corkedRequestsFree = new e(st), st.bufferedRequestCount = 0;
    } else {
      for (; X; ) {
        var Rt = X.chunk, zt = X.encoding, Tt = X.callback, Yt = st.objectMode ? 1 : Rt.length;
        if (Y(et, st, !1, Yt, Rt, zt, Tt), X = X.next, st.bufferedRequestCount--, st.writing)
          break;
      }
      X === null && (st.lastBufferedRequest = null);
    }
    st.bufferedRequest = X, st.bufferProcessing = !1;
  }
  R.prototype._write = function(et, st, X) {
    X(new y("_write()"));
  }, R.prototype._writev = null, R.prototype.end = function(et, st, X) {
    var ot = this._writableState;
    return typeof et == "function" ? (X = et, et = null, st = null) : typeof st == "function" && (X = st, st = null), et != null && this.write(et, st), ot.corked && (ot.corked = 1, this.uncork()), ot.ending || D(this, ot, X), this;
  }, Object.defineProperty(R.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function It(et) {
    return et.ending && et.length === 0 && et.bufferedRequest === null && !et.finished && !et.writing;
  }
  function jt(et, st) {
    et._final(function(X) {
      st.pendingcb--, X && m(et, X), st.prefinished = !0, et.emit("prefinish"), L(et, st);
    });
  }
  function lt(et, st) {
    !st.prefinished && !st.finalCalled && (typeof et._final == "function" && !st.destroyed ? (st.pendingcb++, st.finalCalled = !0, je.nextTick(jt, et, st)) : (st.prefinished = !0, et.emit("prefinish")));
  }
  function L(et, st) {
    var X = It(st);
    if (X && (lt(et, st), st.pendingcb === 0 && (st.finished = !0, et.emit("finish"), st.autoDestroy))) {
      var ot = et._readableState;
      (!ot || ot.autoDestroy && ot.endEmitted) && et.destroy();
    }
    return X;
  }
  function D(et, st, X) {
    st.ending = !0, L(et, st), X && (st.finished ? je.nextTick(X) : et.once("finish", X)), st.ended = !0, et.writable = !1;
  }
  function tt(et, st, X) {
    var ot = et.entry;
    for (et.entry = null; ot; ) {
      var mt = ot.callback;
      st.pendingcb--, mt(X), ot = ot.next;
    }
    st.corkedRequestsFree.next = et;
  }
  return Object.defineProperty(R.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(et) {
      this._writableState && (this._writableState.destroyed = et);
    }
  }), R.prototype.destroy = l.destroy, R.prototype._undestroy = l.undestroy, R.prototype._destroy = function(et, st) {
    st(et);
  }, dw;
}
var fw, ck;
function op() {
  if (ck) return fw;
  ck = 1;
  var e = Object.keys || function(c) {
    var h = [];
    for (var u in c) h.push(u);
    return h;
  };
  fw = o;
  var t = cN(), r = lN();
  Zu()(o, t);
  for (var n = e(r.prototype), i = 0; i < n.length; i++) {
    var s = n[i];
    o.prototype[s] || (o.prototype[s] = r.prototype[s]);
  }
  function o(c) {
    if (!(this instanceof o)) return new o(c);
    t.call(this, c), r.call(this, c), this.allowHalfOpen = !0, c && (c.readable === !1 && (this.readable = !1), c.writable === !1 && (this.writable = !1), c.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a)));
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(o.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(o.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function a() {
    this._writableState.ended || je.nextTick(l, this);
  }
  function l(c) {
    c.end();
  }
  return Object.defineProperty(o.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(c) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = c, this._writableState.destroyed = c);
    }
  }), fw;
}
var gw = {}, mw = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var uk;
function yut() {
  return uk || (uk = 1, function(e, t) {
    var r = O2(), n = r.Buffer;
    function i(o, a) {
      for (var l in o)
        a[l] = o[l];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = s);
    function s(o, a, l) {
      return n(o, a, l);
    }
    s.prototype = Object.create(n.prototype), i(n, s), s.from = function(o, a, l) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return n(o, a, l);
    }, s.alloc = function(o, a, l) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var c = n(o);
      return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0), c;
    }, s.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return n(o);
    }, s.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(o);
    };
  }(mw, mw.exports)), mw.exports;
}
var hk;
function pk() {
  if (hk) return gw;
  hk = 1;
  var e = yut().Buffer, t = e.isEncoding || function(E) {
    switch (E = "" + E, E && E.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(E) {
    if (!E) return "utf8";
    for (var A; ; )
      switch (E) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return E;
        default:
          if (A) return;
          E = ("" + E).toLowerCase(), A = !0;
      }
  }
  function n(E) {
    var A = r(E);
    if (typeof A != "string" && (e.isEncoding === t || !t(E))) throw new Error("Unknown encoding: " + E);
    return A || E;
  }
  gw.StringDecoder = i;
  function i(E) {
    this.encoding = n(E);
    var A;
    switch (this.encoding) {
      case "utf16le":
        this.text = u, this.end = p, A = 4;
        break;
      case "utf8":
        this.fillLast = l, A = 4;
        break;
      case "base64":
        this.text = y, this.end = g, A = 3;
        break;
      default:
        this.write = b, this.end = f;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(A);
  }
  i.prototype.write = function(E) {
    if (E.length === 0) return "";
    var A, x;
    if (this.lastNeed) {
      if (A = this.fillLast(E), A === void 0) return "";
      x = this.lastNeed, this.lastNeed = 0;
    } else
      x = 0;
    return x < E.length ? A ? A + this.text(E, x) : this.text(E, x) : A || "";
  }, i.prototype.end = h, i.prototype.text = c, i.prototype.fillLast = function(E) {
    if (this.lastNeed <= E.length)
      return E.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    E.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, E.length), this.lastNeed -= E.length;
  };
  function s(E) {
    return E <= 127 ? 0 : E >> 5 === 6 ? 2 : E >> 4 === 14 ? 3 : E >> 3 === 30 ? 4 : E >> 6 === 2 ? -1 : -2;
  }
  function o(E, A, x) {
    var m = A.length - 1;
    if (m < x) return 0;
    var w = s(A[m]);
    return w >= 0 ? (w > 0 && (E.lastNeed = w - 1), w) : --m < x || w === -2 ? 0 : (w = s(A[m]), w >= 0 ? (w > 0 && (E.lastNeed = w - 2), w) : --m < x || w === -2 ? 0 : (w = s(A[m]), w >= 0 ? (w > 0 && (w === 2 ? w = 0 : E.lastNeed = w - 3), w) : 0));
  }
  function a(E, A, x) {
    if ((A[0] & 192) !== 128)
      return E.lastNeed = 0, "";
    if (E.lastNeed > 1 && A.length > 1) {
      if ((A[1] & 192) !== 128)
        return E.lastNeed = 1, "";
      if (E.lastNeed > 2 && A.length > 2 && (A[2] & 192) !== 128)
        return E.lastNeed = 2, "";
    }
  }
  function l(E) {
    var A = this.lastTotal - this.lastNeed, x = a(this, E);
    if (x !== void 0) return x;
    if (this.lastNeed <= E.length)
      return E.copy(this.lastChar, A, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    E.copy(this.lastChar, A, 0, E.length), this.lastNeed -= E.length;
  }
  function c(E, A) {
    var x = o(this, E, A);
    if (!this.lastNeed) return E.toString("utf8", A);
    this.lastTotal = x;
    var m = E.length - (x - this.lastNeed);
    return E.copy(this.lastChar, 0, m), E.toString("utf8", A, m);
  }
  function h(E) {
    var A = E && E.length ? this.write(E) : "";
    return this.lastNeed ? A + "" : A;
  }
  function u(E, A) {
    if ((E.length - A) % 2 === 0) {
      var x = E.toString("utf16le", A);
      if (x) {
        var m = x.charCodeAt(x.length - 1);
        if (m >= 55296 && m <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = E[E.length - 2], this.lastChar[1] = E[E.length - 1], x.slice(0, -1);
      }
      return x;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = E[E.length - 1], E.toString("utf16le", A, E.length - 1);
  }
  function p(E) {
    var A = E && E.length ? this.write(E) : "";
    if (this.lastNeed) {
      var x = this.lastTotal - this.lastNeed;
      return A + this.lastChar.toString("utf16le", 0, x);
    }
    return A;
  }
  function y(E, A) {
    var x = (E.length - A) % 3;
    return x === 0 ? E.toString("base64", A) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = E[E.length - 1] : (this.lastChar[0] = E[E.length - 2], this.lastChar[1] = E[E.length - 1]), E.toString("base64", A, E.length - x));
  }
  function g(E) {
    var A = E && E.length ? this.write(E) : "";
    return this.lastNeed ? A + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : A;
  }
  function b(E) {
    return E.toString(this.encoding);
  }
  function f(E) {
    return E && E.length ? this.write(E) : "";
  }
  return gw;
}
var yw, dk;
function $5() {
  if (dk) return yw;
  dk = 1;
  var e = Vp().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(s) {
    var o = !1;
    return function() {
      if (!o) {
        o = !0;
        for (var a = arguments.length, l = new Array(a), c = 0; c < a; c++)
          l[c] = arguments[c];
        s.apply(this, l);
      }
    };
  }
  function r() {
  }
  function n(s) {
    return s.setHeader && typeof s.abort == "function";
  }
  function i(s, o, a) {
    if (typeof o == "function") return i(s, null, o);
    o || (o = {}), a = t(a || r);
    var l = o.readable || o.readable !== !1 && s.readable, c = o.writable || o.writable !== !1 && s.writable, h = function() {
      s.writable || p();
    }, u = s._writableState && s._writableState.finished, p = function() {
      c = !1, u = !0, l || a.call(s);
    }, y = s._readableState && s._readableState.endEmitted, g = function() {
      l = !1, y = !0, c || a.call(s);
    }, b = function(A) {
      a.call(s, A);
    }, f = function() {
      var A;
      if (l && !y)
        return (!s._readableState || !s._readableState.ended) && (A = new e()), a.call(s, A);
      if (c && !u)
        return (!s._writableState || !s._writableState.ended) && (A = new e()), a.call(s, A);
    }, E = function() {
      s.req.on("finish", p);
    };
    return n(s) ? (s.on("complete", p), s.on("abort", f), s.req ? E() : s.on("request", E)) : c && !s._writableState && (s.on("end", h), s.on("close", h)), s.on("end", g), s.on("finish", p), o.error !== !1 && s.on("error", b), s.on("close", f), function() {
      s.removeListener("complete", p), s.removeListener("abort", f), s.removeListener("request", E), s.req && s.req.removeListener("finish", p), s.removeListener("end", h), s.removeListener("close", h), s.removeListener("finish", p), s.removeListener("end", g), s.removeListener("error", b), s.removeListener("close", f);
    };
  }
  return yw = i, yw;
}
var bw, fk;
function but() {
  if (fk) return bw;
  fk = 1;
  var e;
  function t(x, m, w) {
    return m = r(m), m in x ? Object.defineProperty(x, m, { value: w, enumerable: !0, configurable: !0, writable: !0 }) : x[m] = w, x;
  }
  function r(x) {
    var m = n(x, "string");
    return typeof m == "symbol" ? m : String(m);
  }
  function n(x, m) {
    if (typeof x != "object" || x === null) return x;
    var w = x[Symbol.toPrimitive];
    if (w !== void 0) {
      var _ = w.call(x, m);
      if (typeof _ != "object") return _;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (m === "string" ? String : Number)(x);
  }
  var i = $5(), s = Symbol("lastResolve"), o = Symbol("lastReject"), a = Symbol("error"), l = Symbol("ended"), c = Symbol("lastPromise"), h = Symbol("handlePromise"), u = Symbol("stream");
  function p(x, m) {
    return {
      value: x,
      done: m
    };
  }
  function y(x) {
    var m = x[s];
    if (m !== null) {
      var w = x[u].read();
      w !== null && (x[c] = null, x[s] = null, x[o] = null, m(p(w, !1)));
    }
  }
  function g(x) {
    je.nextTick(y, x);
  }
  function b(x, m) {
    return function(w, _) {
      x.then(function() {
        if (m[l]) {
          w(p(void 0, !0));
          return;
        }
        m[h](w, _);
      }, _);
    };
  }
  var f = Object.getPrototypeOf(function() {
  }), E = Object.setPrototypeOf((e = {
    get stream() {
      return this[u];
    },
    next: function() {
      var x = this, m = this[a];
      if (m !== null)
        return Promise.reject(m);
      if (this[l])
        return Promise.resolve(p(void 0, !0));
      if (this[u].destroyed)
        return new Promise(function(R, O) {
          je.nextTick(function() {
            x[a] ? O(x[a]) : R(p(void 0, !0));
          });
        });
      var w = this[c], _;
      if (w)
        _ = new Promise(b(w, this));
      else {
        var S = this[u].read();
        if (S !== null)
          return Promise.resolve(p(S, !1));
        _ = new Promise(this[h]);
      }
      return this[c] = _, _;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var x = this;
    return new Promise(function(m, w) {
      x[u].destroy(null, function(_) {
        if (_) {
          w(_);
          return;
        }
        m(p(void 0, !0));
      });
    });
  }), e), f), A = function(x) {
    var m, w = Object.create(E, (m = {}, t(m, u, {
      value: x,
      writable: !0
    }), t(m, s, {
      value: null,
      writable: !0
    }), t(m, o, {
      value: null,
      writable: !0
    }), t(m, a, {
      value: null,
      writable: !0
    }), t(m, l, {
      value: x._readableState.endEmitted,
      writable: !0
    }), t(m, h, {
      value: function(_, S) {
        var R = w[u].read();
        R ? (w[c] = null, w[s] = null, w[o] = null, _(p(R, !1))) : (w[s] = _, w[o] = S);
      },
      writable: !0
    }), m));
    return w[c] = null, i(x, function(_) {
      if (_ && _.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var S = w[o];
        S !== null && (w[c] = null, w[s] = null, w[o] = null, S(_)), w[a] = _;
        return;
      }
      var R = w[s];
      R !== null && (w[c] = null, w[s] = null, w[o] = null, R(p(void 0, !0))), w[l] = !0;
    }), x.on("readable", g.bind(null, w)), w;
  };
  return bw = A, bw;
}
var gk, mk;
function vut() {
  return mk || (mk = 1, gk = function() {
    throw new Error("Readable.from is not available in the browser");
  }), gk;
}
var vw, yk;
function cN() {
  if (yk) return vw;
  yk = 1, vw = O;
  var e;
  O.ReadableState = R, D5().EventEmitter;
  var t = function(U, J) {
    return U.listeners(J).length;
  }, r = qM(), n = O2().Buffer, i = (typeof Dl < "u" ? Dl : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(U) {
    return n.from(U);
  }
  function o(U) {
    return n.isBuffer(U) || U instanceof i;
  }
  var a = sN(), l;
  a && a.debuglog ? l = a.debuglog("stream") : l = function() {
  };
  var c = gut(), h = oN(), u = aN(), p = u.getHighWaterMark, y = Vp().codes, g = y.ERR_INVALID_ARG_TYPE, b = y.ERR_STREAM_PUSH_AFTER_EOF, f = y.ERR_METHOD_NOT_IMPLEMENTED, E = y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, A, x, m;
  Zu()(O, r);
  var w = h.errorOrDestroy, _ = ["error", "close", "destroy", "pause", "resume"];
  function S(U, J, St) {
    if (typeof U.prependListener == "function") return U.prependListener(J, St);
    !U._events || !U._events[J] ? U.on(J, St) : Array.isArray(U._events[J]) ? U._events[J].unshift(St) : U._events[J] = [St, U._events[J]];
  }
  function R(U, J, St) {
    e = e || op(), U = U || {}, typeof St != "boolean" && (St = J instanceof e), this.objectMode = !!U.objectMode, St && (this.objectMode = this.objectMode || !!U.readableObjectMode), this.highWaterMark = p(this, U, "readableHighWaterMark", St), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = U.emitClose !== !1, this.autoDestroy = !!U.autoDestroy, this.destroyed = !1, this.defaultEncoding = U.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, U.encoding && (A || (A = pk().StringDecoder), this.decoder = new A(U.encoding), this.encoding = U.encoding);
  }
  function O(U) {
    if (e = e || op(), !(this instanceof O)) return new O(U);
    var J = this instanceof e;
    this._readableState = new R(U, this, J), this.readable = !0, U && (typeof U.read == "function" && (this._read = U.read), typeof U.destroy == "function" && (this._destroy = U.destroy)), r.call(this);
  }
  Object.defineProperty(O.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(U) {
      this._readableState && (this._readableState.destroyed = U);
    }
  }), O.prototype.destroy = h.destroy, O.prototype._undestroy = h.undestroy, O.prototype._destroy = function(U, J) {
    J(U);
  }, O.prototype.push = function(U, J) {
    var St = this._readableState, Rt;
    return St.objectMode ? Rt = !0 : typeof U == "string" && (J = J || St.defaultEncoding, J !== St.encoding && (U = n.from(U, J), J = ""), Rt = !0), $(this, U, J, !1, Rt);
  }, O.prototype.unshift = function(U) {
    return $(this, U, null, !0, !1);
  };
  function $(U, J, St, Rt, zt) {
    l("readableAddChunk", J);
    var Tt = U._readableState;
    if (J === null)
      Tt.reading = !1, pt(U, Tt);
    else {
      var Yt;
      if (zt || (Yt = F(Tt, J)), Yt)
        w(U, Yt);
      else if (Tt.objectMode || J && J.length > 0)
        if (typeof J != "string" && !Tt.objectMode && Object.getPrototypeOf(J) !== n.prototype && (J = s(J)), Rt)
          Tt.endEmitted ? w(U, new E()) : z(U, Tt, J, !0);
        else if (Tt.ended)
          w(U, new b());
        else {
          if (Tt.destroyed)
            return !1;
          Tt.reading = !1, Tt.decoder && !St ? (J = Tt.decoder.write(J), Tt.objectMode || J.length !== 0 ? z(U, Tt, J, !1) : Ct(U, Tt)) : z(U, Tt, J, !1);
        }
      else Rt || (Tt.reading = !1, Ct(U, Tt));
    }
    return !Tt.ended && (Tt.length < Tt.highWaterMark || Tt.length === 0);
  }
  function z(U, J, St, Rt) {
    J.flowing && J.length === 0 && !J.sync ? (J.awaitDrain = 0, U.emit("data", St)) : (J.length += J.objectMode ? 1 : St.length, Rt ? J.buffer.unshift(St) : J.buffer.push(St), J.needReadable && vt(U)), Ct(U, J);
  }
  function F(U, J) {
    var St;
    return !o(J) && typeof J != "string" && J !== void 0 && !U.objectMode && (St = new g("chunk", ["string", "Buffer", "Uint8Array"], J)), St;
  }
  O.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, O.prototype.setEncoding = function(U) {
    A || (A = pk().StringDecoder);
    var J = new A(U);
    this._readableState.decoder = J, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var St = this._readableState.buffer.head, Rt = ""; St !== null; )
      Rt += J.write(St.data), St = St.next;
    return this._readableState.buffer.clear(), Rt !== "" && this._readableState.buffer.push(Rt), this._readableState.length = Rt.length, this;
  };
  var Y = 1073741824;
  function rt(U) {
    return U >= Y ? U = Y : (U--, U |= U >>> 1, U |= U >>> 2, U |= U >>> 4, U |= U >>> 8, U |= U >>> 16, U++), U;
  }
  function at(U, J) {
    return U <= 0 || J.length === 0 && J.ended ? 0 : J.objectMode ? 1 : U !== U ? J.flowing && J.length ? J.buffer.head.data.length : J.length : (U > J.highWaterMark && (J.highWaterMark = rt(U)), U <= J.length ? U : J.ended ? J.length : (J.needReadable = !0, 0));
  }
  O.prototype.read = function(U) {
    l("read", U), U = parseInt(U, 10);
    var J = this._readableState, St = U;
    if (U !== 0 && (J.emittedReadable = !1), U === 0 && J.needReadable && ((J.highWaterMark !== 0 ? J.length >= J.highWaterMark : J.length > 0) || J.ended))
      return l("read: emitReadable", J.length, J.ended), J.length === 0 && J.ended ? X(this) : vt(this), null;
    if (U = at(U, J), U === 0 && J.ended)
      return J.length === 0 && X(this), null;
    var Rt = J.needReadable;
    l("need readable", Rt), (J.length === 0 || J.length - U < J.highWaterMark) && (Rt = !0, l("length less than watermark", Rt)), J.ended || J.reading ? (Rt = !1, l("reading or ended", Rt)) : Rt && (l("do read"), J.reading = !0, J.sync = !0, J.length === 0 && (J.needReadable = !0), this._read(J.highWaterMark), J.sync = !1, J.reading || (U = at(St, J)));
    var zt;
    return U > 0 ? zt = st(U, J) : zt = null, zt === null ? (J.needReadable = J.length <= J.highWaterMark, U = 0) : (J.length -= U, J.awaitDrain = 0), J.length === 0 && (J.ended || (J.needReadable = !0), St !== U && J.ended && X(this)), zt !== null && this.emit("data", zt), zt;
  };
  function pt(U, J) {
    if (l("onEofChunk"), !J.ended) {
      if (J.decoder) {
        var St = J.decoder.end();
        St && St.length && (J.buffer.push(St), J.length += J.objectMode ? 1 : St.length);
      }
      J.ended = !0, J.sync ? vt(U) : (J.needReadable = !1, J.emittedReadable || (J.emittedReadable = !0, _t(U)));
    }
  }
  function vt(U) {
    var J = U._readableState;
    l("emitReadable", J.needReadable, J.emittedReadable), J.needReadable = !1, J.emittedReadable || (l("emitReadable", J.flowing), J.emittedReadable = !0, je.nextTick(_t, U));
  }
  function _t(U) {
    var J = U._readableState;
    l("emitReadable_", J.destroyed, J.length, J.ended), !J.destroyed && (J.length || J.ended) && (U.emit("readable"), J.emittedReadable = !1), J.needReadable = !J.flowing && !J.ended && J.length <= J.highWaterMark, et(U);
  }
  function Ct(U, J) {
    J.readingMore || (J.readingMore = !0, je.nextTick(It, U, J));
  }
  function It(U, J) {
    for (; !J.reading && !J.ended && (J.length < J.highWaterMark || J.flowing && J.length === 0); ) {
      var St = J.length;
      if (l("maybeReadMore read 0"), U.read(0), St === J.length)
        break;
    }
    J.readingMore = !1;
  }
  O.prototype._read = function(U) {
    w(this, new f("_read()"));
  }, O.prototype.pipe = function(U, J) {
    var St = this, Rt = this._readableState;
    switch (Rt.pipesCount) {
      case 0:
        Rt.pipes = U;
        break;
      case 1:
        Rt.pipes = [Rt.pipes, U];
        break;
      default:
        Rt.pipes.push(U);
        break;
    }
    Rt.pipesCount += 1, l("pipe count=%d opts=%j", Rt.pipesCount, J);
    var zt = (!J || J.end !== !1) && U !== je.stdout && U !== je.stderr, Tt = zt ? Zt : Kt;
    Rt.endEmitted ? je.nextTick(Tt) : St.once("end", Tt), U.on("unpipe", Yt);
    function Yt(bt, xt) {
      l("onunpipe"), bt === St && xt && xt.hasUnpiped === !1 && (xt.hasUnpiped = !0, Ye());
    }
    function Zt() {
      l("onend"), U.end();
    }
    var kt = jt(St);
    U.on("drain", kt);
    var _e = !1;
    function Ye() {
      l("cleanup"), U.removeListener("close", te), U.removeListener("finish", Se), U.removeListener("drain", kt), U.removeListener("error", le), U.removeListener("unpipe", Yt), St.removeListener("end", Zt), St.removeListener("end", Kt), St.removeListener("data", wt), _e = !0, Rt.awaitDrain && (!U._writableState || U._writableState.needDrain) && kt();
    }
    St.on("data", wt);
    function wt(bt) {
      l("ondata");
      var xt = U.write(bt);
      l("dest.write", xt), xt === !1 && ((Rt.pipesCount === 1 && Rt.pipes === U || Rt.pipesCount > 1 && mt(Rt.pipes, U) !== -1) && !_e && (l("false write response, pause", Rt.awaitDrain), Rt.awaitDrain++), St.pause());
    }
    function le(bt) {
      l("onerror", bt), Kt(), U.removeListener("error", le), t(U, "error") === 0 && w(U, bt);
    }
    S(U, "error", le);
    function te() {
      U.removeListener("finish", Se), Kt();
    }
    U.once("close", te);
    function Se() {
      l("onfinish"), U.removeListener("close", te), Kt();
    }
    U.once("finish", Se);
    function Kt() {
      l("unpipe"), St.unpipe(U);
    }
    return U.emit("pipe", St), Rt.flowing || (l("pipe resume"), St.resume()), U;
  };
  function jt(U) {
    return function() {
      var J = U._readableState;
      l("pipeOnDrain", J.awaitDrain), J.awaitDrain && J.awaitDrain--, J.awaitDrain === 0 && t(U, "data") && (J.flowing = !0, et(U));
    };
  }
  O.prototype.unpipe = function(U) {
    var J = this._readableState, St = {
      hasUnpiped: !1
    };
    if (J.pipesCount === 0) return this;
    if (J.pipesCount === 1)
      return U && U !== J.pipes ? this : (U || (U = J.pipes), J.pipes = null, J.pipesCount = 0, J.flowing = !1, U && U.emit("unpipe", this, St), this);
    if (!U) {
      var Rt = J.pipes, zt = J.pipesCount;
      J.pipes = null, J.pipesCount = 0, J.flowing = !1;
      for (var Tt = 0; Tt < zt; Tt++) Rt[Tt].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var Yt = mt(J.pipes, U);
    return Yt === -1 ? this : (J.pipes.splice(Yt, 1), J.pipesCount -= 1, J.pipesCount === 1 && (J.pipes = J.pipes[0]), U.emit("unpipe", this, St), this);
  }, O.prototype.on = function(U, J) {
    var St = r.prototype.on.call(this, U, J), Rt = this._readableState;
    return U === "data" ? (Rt.readableListening = this.listenerCount("readable") > 0, Rt.flowing !== !1 && this.resume()) : U === "readable" && !Rt.endEmitted && !Rt.readableListening && (Rt.readableListening = Rt.needReadable = !0, Rt.flowing = !1, Rt.emittedReadable = !1, l("on readable", Rt.length, Rt.reading), Rt.length ? vt(this) : Rt.reading || je.nextTick(L, this)), St;
  }, O.prototype.addListener = O.prototype.on, O.prototype.removeListener = function(U, J) {
    var St = r.prototype.removeListener.call(this, U, J);
    return U === "readable" && je.nextTick(lt, this), St;
  }, O.prototype.removeAllListeners = function(U) {
    var J = r.prototype.removeAllListeners.apply(this, arguments);
    return (U === "readable" || U === void 0) && je.nextTick(lt, this), J;
  };
  function lt(U) {
    var J = U._readableState;
    J.readableListening = U.listenerCount("readable") > 0, J.resumeScheduled && !J.paused ? J.flowing = !0 : U.listenerCount("data") > 0 && U.resume();
  }
  function L(U) {
    l("readable nexttick read 0"), U.read(0);
  }
  O.prototype.resume = function() {
    var U = this._readableState;
    return U.flowing || (l("resume"), U.flowing = !U.readableListening, D(this, U)), U.paused = !1, this;
  };
  function D(U, J) {
    J.resumeScheduled || (J.resumeScheduled = !0, je.nextTick(tt, U, J));
  }
  function tt(U, J) {
    l("resume", J.reading), J.reading || U.read(0), J.resumeScheduled = !1, U.emit("resume"), et(U), J.flowing && !J.reading && U.read(0);
  }
  O.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function et(U) {
    var J = U._readableState;
    for (l("flow", J.flowing); J.flowing && U.read() !== null; ) ;
  }
  O.prototype.wrap = function(U) {
    var J = this, St = this._readableState, Rt = !1;
    U.on("end", function() {
      if (l("wrapped end"), St.decoder && !St.ended) {
        var Yt = St.decoder.end();
        Yt && Yt.length && J.push(Yt);
      }
      J.push(null);
    }), U.on("data", function(Yt) {
      if (l("wrapped data"), St.decoder && (Yt = St.decoder.write(Yt)), !(St.objectMode && Yt == null) && !(!St.objectMode && (!Yt || !Yt.length))) {
        var Zt = J.push(Yt);
        Zt || (Rt = !0, U.pause());
      }
    });
    for (var zt in U)
      this[zt] === void 0 && typeof U[zt] == "function" && (this[zt] = /* @__PURE__ */ function(Yt) {
        return function() {
          return U[Yt].apply(U, arguments);
        };
      }(zt));
    for (var Tt = 0; Tt < _.length; Tt++)
      U.on(_[Tt], this.emit.bind(this, _[Tt]));
    return this._read = function(Yt) {
      l("wrapped _read", Yt), Rt && (Rt = !1, U.resume());
    }, this;
  }, typeof Symbol == "function" && (O.prototype[Symbol.asyncIterator] = function() {
    return x === void 0 && (x = but()), x(this);
  }), Object.defineProperty(O.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(O.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(O.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(U) {
      this._readableState && (this._readableState.flowing = U);
    }
  }), O._fromList = st, Object.defineProperty(O.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function st(U, J) {
    if (J.length === 0) return null;
    var St;
    return J.objectMode ? St = J.buffer.shift() : !U || U >= J.length ? (J.decoder ? St = J.buffer.join("") : J.buffer.length === 1 ? St = J.buffer.first() : St = J.buffer.concat(J.length), J.buffer.clear()) : St = J.buffer.consume(U, J.decoder), St;
  }
  function X(U) {
    var J = U._readableState;
    l("endReadable", J.endEmitted), J.endEmitted || (J.ended = !0, je.nextTick(ot, J, U));
  }
  function ot(U, J) {
    if (l("endReadableNT", U.endEmitted, U.length), !U.endEmitted && U.length === 0 && (U.endEmitted = !0, J.readable = !1, J.emit("end"), U.autoDestroy)) {
      var St = J._writableState;
      (!St || St.autoDestroy && St.finished) && J.destroy();
    }
  }
  typeof Symbol == "function" && (O.from = function(U, J) {
    return m === void 0 && (m = vut()), m(O, U, J);
  });
  function mt(U, J) {
    for (var St = 0, Rt = U.length; St < Rt; St++)
      if (U[St] === J) return St;
    return -1;
  }
  return vw;
}
var ww, bk;
function uN() {
  if (bk) return ww;
  bk = 1, ww = a;
  var e = Vp().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, r = e.ERR_MULTIPLE_CALLBACK, n = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, i = e.ERR_TRANSFORM_WITH_LENGTH_0, s = op();
  Zu()(a, s);
  function o(h, u) {
    var p = this._transformState;
    p.transforming = !1;
    var y = p.writecb;
    if (y === null)
      return this.emit("error", new r());
    p.writechunk = null, p.writecb = null, u != null && this.push(u), y(h);
    var g = this._readableState;
    g.reading = !1, (g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
  }
  function a(h) {
    if (!(this instanceof a)) return new a(h);
    s.call(this, h), this._transformState = {
      afterTransform: o.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, h && (typeof h.transform == "function" && (this._transform = h.transform), typeof h.flush == "function" && (this._flush = h.flush)), this.on("prefinish", l);
  }
  function l() {
    var h = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, p) {
      c(h, u, p);
    }) : c(this, null, null);
  }
  a.prototype.push = function(h, u) {
    return this._transformState.needTransform = !1, s.prototype.push.call(this, h, u);
  }, a.prototype._transform = function(h, u, p) {
    p(new t("_transform()"));
  }, a.prototype._write = function(h, u, p) {
    var y = this._transformState;
    if (y.writecb = p, y.writechunk = h, y.writeencoding = u, !y.transforming) {
      var g = this._readableState;
      (y.needTransform || g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
    }
  }, a.prototype._read = function(h) {
    var u = this._transformState;
    u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
  }, a.prototype._destroy = function(h, u) {
    s.prototype._destroy.call(this, h, function(p) {
      u(p);
    });
  };
  function c(h, u, p) {
    if (u) return h.emit("error", u);
    if (p != null && h.push(p), h._writableState.length) throw new i();
    if (h._transformState.transforming) throw new n();
    return h.push(null);
  }
  return ww;
}
var xw, vk;
function wut() {
  if (vk) return xw;
  vk = 1, xw = t;
  var e = uN();
  Zu()(t, e);
  function t(r) {
    if (!(this instanceof t)) return new t(r);
    e.call(this, r);
  }
  return t.prototype._transform = function(r, n, i) {
    i(null, r);
  }, xw;
}
var Ew, wk;
function xut() {
  if (wk) return Ew;
  wk = 1;
  var e;
  function t(p) {
    var y = !1;
    return function() {
      y || (y = !0, p.apply(void 0, arguments));
    };
  }
  var r = Vp().codes, n = r.ERR_MISSING_ARGS, i = r.ERR_STREAM_DESTROYED;
  function s(p) {
    if (p) throw p;
  }
  function o(p) {
    return p.setHeader && typeof p.abort == "function";
  }
  function a(p, y, g, b) {
    b = t(b);
    var f = !1;
    p.on("close", function() {
      f = !0;
    }), e === void 0 && (e = $5()), e(p, {
      readable: y,
      writable: g
    }, function(A) {
      if (A) return b(A);
      f = !0, b();
    });
    var E = !1;
    return function(A) {
      if (!f && !E) {
        if (E = !0, o(p)) return p.abort();
        if (typeof p.destroy == "function") return p.destroy();
        b(A || new i("pipe"));
      }
    };
  }
  function l(p) {
    p();
  }
  function c(p, y) {
    return p.pipe(y);
  }
  function h(p) {
    return !p.length || typeof p[p.length - 1] != "function" ? s : p.pop();
  }
  function u() {
    for (var p = arguments.length, y = new Array(p), g = 0; g < p; g++)
      y[g] = arguments[g];
    var b = h(y);
    if (Array.isArray(y[0]) && (y = y[0]), y.length < 2)
      throw new n("streams");
    var f, E = y.map(function(A, x) {
      var m = x < y.length - 1, w = x > 0;
      return a(A, m, w, function(_) {
        f || (f = _), _ && E.forEach(l), !m && (E.forEach(l), b(f));
      });
    });
    return y.reduce(c);
  }
  return Ew = u, Ew;
}
var Aw, xk;
function Eut() {
  if (xk) return Aw;
  xk = 1, Aw = r;
  var e = D5().EventEmitter, t = Zu();
  t(r, e), r.Readable = cN(), r.Writable = lN(), r.Duplex = op(), r.Transform = uN(), r.PassThrough = wut(), r.finished = $5(), r.pipeline = xut(), r.Stream = r;
  function r() {
    e.call(this);
  }
  return r.prototype.pipe = function(n, i) {
    var s = this;
    function o(y) {
      n.writable && n.write(y) === !1 && s.pause && s.pause();
    }
    s.on("data", o);
    function a() {
      s.readable && s.resume && s.resume();
    }
    n.on("drain", a), !n._isStdio && (!i || i.end !== !1) && (s.on("end", c), s.on("close", h));
    var l = !1;
    function c() {
      l || (l = !0, n.end());
    }
    function h() {
      l || (l = !0, typeof n.destroy == "function" && n.destroy());
    }
    function u(y) {
      if (p(), e.listenerCount(this, "error") === 0)
        throw y;
    }
    s.on("error", u), n.on("error", u);
    function p() {
      s.removeListener("data", o), n.removeListener("drain", a), s.removeListener("end", c), s.removeListener("close", h), s.removeListener("error", u), n.removeListener("error", u), s.removeListener("end", p), s.removeListener("close", p), n.removeListener("close", p);
    }
    return s.on("end", p), s.on("close", p), n.on("close", p), n.emit("pipe", s), n;
  }, Aw;
}
var Sw, Ek;
function Aut() {
  if (Ek) return Sw;
  Ek = 1;
  const e = (t, r) => {
    if (r.length <= 0 || t.length <= 0 || t.equals(r))
      return !1;
    for (let n = 1; n <= Math.min(t.length, r.length - 1); n++) {
      const i = t.subarray(t.length - n, t.length);
      if (r.compare(
        i,
        0,
        i.length,
        0,
        n
      ) === 0)
        return !0;
    }
    return !1;
  };
  return Sw = (t, ...r) => r.some((n) => e(t, n)), Sw;
}
var _w, Ak;
function Sut() {
  if (Ak) return _w;
  Ak = 1;
  const e = Eut(), t = UM(), r = Aut();
  let n = eu.alloc(0);
  return _w = (...i) => (s = "utf-8") => {
    const o = i.map((a) => eu.from(a, s));
    return new e.Transform({
      transform(a, l, c) {
        n = eu.concat([n, a]), r(n, ...o) || (t(n, ...o).forEach((h) => this.push(h)), n = eu.alloc(0)), c();
      }
    });
  }, _w;
}
var Sk;
function _ut() {
  if (Sk) return Zg;
  Sk = 1;
  const e = UM(), t = Sut();
  return Zg.tokenator = e, Zg.tokenatorStream = t, Zg;
}
var kut = _ut();
let Cut = class {
  constructor(t, r) {
    this.delimiterStart = t, this.delimiterEnd = r;
  }
  capitalize(t) {
    return t.charAt(0).toUpperCase() + t.slice(1);
  }
  join(t, r) {
    if (t.length === 0)
      return "";
    const n = t.toReversed();
    let i = n.shift(), s = !1;
    for (const o of n)
      s ? i = ", " + i : (i = (n.length === 1 ? " and " : ", and ") + i, s = !0), i = o + i;
    return r && (i = this.capitalize(i)), i;
  }
  parseSlot(t) {
    if (!t)
      throw new Error("Empty Slot");
    const r = t.match(/:/g);
    if (!r || r.length !== 1)
      throw new Error("Type Error in Slot");
    const n = t.split(":"), i = n[0], s = n[1], o = s.match(/#/g);
    let a;
    if (o) {
      if (o.length !== 1)
        throw new Error("Format Error in Slot");
      a = s.split("#")[1];
    }
    return { type: "slot", text: i, format: a };
  }
  parse(t) {
    const r = [], n = kut.tokenator(t, this.delimiterStart, this.delimiterEnd);
    let i = "ground", s = "";
    for (const o of n)
      o === this.delimiterStart ? i === "ground" ? (s && (r.push({ type: "ground", text: s }), s = ""), i = "slot") : s += o : o === this.delimiterEnd && i === "slot" ? (r.push(this.parseSlot(s)), s = "", i = "ground") : s += o;
    if (i === "slot")
      throw new Error("missing delimiter");
    return s && r.push({ type: "ground", text: s }), r;
  }
  resolve(t, r) {
    let n = "";
    for (const i of t)
      if (i.type === "ground")
        n += i.text;
      else {
        const s = r[i.text];
        let o;
        if (Array.isArray(s) ? o = this.join(s) : typeof s > "u" ? o = "" : o = s.toString(), i.format)
          if (i.format === "cap")
            o = o.charAt(0).toUpperCase() + o.slice(1);
          else if (/^\.\d+$/.test(i.format))
            if (typeof s == "number") {
              const a = parseInt(i.format.slice(1));
              o = s.toFixed(a);
            } else
              throw new Error("[templum]: Decimal place format specifier can only be applied to numbers.");
          else
            throw new Error(`[templum]: Unknown format specifier '${i.format}'`);
        n += o;
      }
    return n;
  }
  interpolate(t, r) {
    return this.resolve(this.parse(t), r);
  }
};
const ap = new Cut("${", "}"), Iut = ap.capitalize.bind(ap), Put = ap.join.bind(ap), Dn = ap.interpolate.bind(ap);
var Rut = Object.defineProperty, Tut = (e, t, r) => t in e ? Rut(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Be = (e, t, r) => Tut(e, typeof t != "symbol" ? t + "" : t, r);
function jr(e, t) {
  return t === "raw" || t === "statusBar" ? e.raw : t === "domId" ? Cr(e.raw) : e.value.toString();
}
function ff(e, t) {
  return jr(e.facetBox("x"), t);
}
function z5(e, t) {
  return jr(e.facetBox("y"), t);
}
function qf(e, t) {
  const r = ff(e, t), n = z5(e, t);
  return `${r}, ${n}`;
}
function Out(e, t) {
  return [...e.entries()].map(([r, n]) => jr(n, t)).join(", ");
}
var _k = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Lut(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Xg(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var hN = { exports: {} };
/*! jsonpath 1.1.1 */
(function(e, t) {
  (function(r) {
    e.exports = r();
  })(function() {
    return function r(n, i, s) {
      function o(c, h) {
        if (!i[c]) {
          if (!n[c]) {
            var u = typeof Xg == "function" && Xg;
            if (!h && u) return u(c, !0);
            if (a) return a(c, !0);
            var p = new Error("Cannot find module '" + c + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var y = i[c] = { exports: {} };
          n[c][0].call(y.exports, function(g) {
            var b = n[c][1][g];
            return o(b || g);
          }, y, y.exports, r, n, i, s);
        }
        return i[c].exports;
      }
      for (var a = typeof Xg == "function" && Xg, l = 0; l < s.length; l++) o(s[l]);
      return o;
    }({ "./aesprim": [function(r, n, i) {
      (function(s, o) {
        o(typeof i < "u" ? i : s.esprima = {});
      })(this, function(s) {
        var o, a, l, c, h, u, p, y, g, b, f, E, A, x, m, w, _, S;
        o = {
          BooleanLiteral: 1,
          EOF: 2,
          Identifier: 3,
          Keyword: 4,
          NullLiteral: 5,
          NumericLiteral: 6,
          Punctuator: 7,
          StringLiteral: 8,
          RegularExpression: 9
        }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
          "(",
          "{",
          "[",
          "in",
          "typeof",
          "instanceof",
          "new",
          "return",
          "case",
          "delete",
          "throw",
          "void",
          // assignment operators
          "=",
          "+=",
          "-=",
          "*=",
          "/=",
          "%=",
          "<<=",
          ">>=",
          ">>>=",
          "&=",
          "|=",
          "^=",
          ",",
          // binary/unary operators
          "+",
          "-",
          "*",
          "/",
          "%",
          "++",
          "--",
          "<<",
          ">>",
          ">>>",
          "&",
          "|",
          "^",
          "!",
          "~",
          "&&",
          "||",
          "?",
          ":",
          "===",
          "==",
          ">=",
          "<=",
          "<",
          ">",
          "!=",
          "!=="
        ], c = {
          AssignmentExpression: "AssignmentExpression",
          ArrayExpression: "ArrayExpression",
          BlockStatement: "BlockStatement",
          BinaryExpression: "BinaryExpression",
          BreakStatement: "BreakStatement",
          CallExpression: "CallExpression",
          CatchClause: "CatchClause",
          ConditionalExpression: "ConditionalExpression",
          ContinueStatement: "ContinueStatement",
          DoWhileStatement: "DoWhileStatement",
          DebuggerStatement: "DebuggerStatement",
          EmptyStatement: "EmptyStatement",
          ExpressionStatement: "ExpressionStatement",
          ForStatement: "ForStatement",
          ForInStatement: "ForInStatement",
          FunctionDeclaration: "FunctionDeclaration",
          FunctionExpression: "FunctionExpression",
          Identifier: "Identifier",
          IfStatement: "IfStatement",
          Literal: "Literal",
          LabeledStatement: "LabeledStatement",
          LogicalExpression: "LogicalExpression",
          MemberExpression: "MemberExpression",
          NewExpression: "NewExpression",
          ObjectExpression: "ObjectExpression",
          Program: "Program",
          Property: "Property",
          ReturnStatement: "ReturnStatement",
          SequenceExpression: "SequenceExpression",
          SwitchStatement: "SwitchStatement",
          SwitchCase: "SwitchCase",
          ThisExpression: "ThisExpression",
          ThrowStatement: "ThrowStatement",
          TryStatement: "TryStatement",
          UnaryExpression: "UnaryExpression",
          UpdateExpression: "UpdateExpression",
          VariableDeclaration: "VariableDeclaration",
          VariableDeclarator: "VariableDeclarator",
          WhileStatement: "WhileStatement",
          WithStatement: "WithStatement"
        }, h = {
          Data: 1,
          Get: 2,
          Set: 4
        }, u = {
          UnexpectedToken: "Unexpected token %0",
          UnexpectedNumber: "Unexpected number",
          UnexpectedString: "Unexpected string",
          UnexpectedIdentifier: "Unexpected identifier",
          UnexpectedReserved: "Unexpected reserved word",
          UnexpectedEOS: "Unexpected end of input",
          NewlineAfterThrow: "Illegal newline after throw",
          InvalidRegExp: "Invalid regular expression",
          UnterminatedRegExp: "Invalid regular expression: missing /",
          InvalidLHSInAssignment: "Invalid left-hand side in assignment",
          InvalidLHSInForIn: "Invalid left-hand side in for-in",
          MultipleDefaultsInSwitch: "More than one default clause in switch statement",
          NoCatchOrFinally: "Missing catch or finally after try",
          UnknownLabel: "Undefined label '%0'",
          Redeclaration: "%0 '%1' has already been declared",
          IllegalContinue: "Illegal continue statement",
          IllegalBreak: "Illegal break statement",
          IllegalReturn: "Illegal return statement",
          StrictModeWith: "Strict mode code may not include a with statement",
          StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
          StrictVarName: "Variable name may not be eval or arguments in strict mode",
          StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
          StrictParamDupe: "Strict mode function may not have duplicate parameter names",
          StrictFunctionName: "Function name may not be eval or arguments in strict mode",
          StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
          StrictDelete: "Delete of an unqualified identifier in strict mode.",
          StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
          AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
          AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
          StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
          StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
          StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
          StrictReservedWord: "Use of future reserved word in strict mode"
        }, p = {
          NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
          NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
        };
        function R(d, v) {
          if (!d)
            throw new Error("ASSERT: " + v);
        }
        function O(d) {
          return d >= 48 && d <= 57;
        }
        function $(d) {
          return "0123456789abcdefABCDEF".indexOf(d) >= 0;
        }
        function z(d) {
          return "01234567".indexOf(d) >= 0;
        }
        function F(d) {
          return d === 32 || d === 9 || d === 11 || d === 12 || d === 160 || d >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(d) >= 0;
        }
        function Y(d) {
          return d === 10 || d === 13 || d === 8232 || d === 8233;
        }
        function rt(d) {
          return d == 64 || d === 36 || d === 95 || // $ (dollar) and _ (underscore)
          d >= 65 && d <= 90 || // A..Z
          d >= 97 && d <= 122 || // a..z
          d === 92 || // \ (backslash)
          d >= 128 && p.NonAsciiIdentifierStart.test(String.fromCharCode(d));
        }
        function at(d) {
          return d === 36 || d === 95 || // $ (dollar) and _ (underscore)
          d >= 65 && d <= 90 || // A..Z
          d >= 97 && d <= 122 || // a..z
          d >= 48 && d <= 57 || // 0..9
          d === 92 || // \ (backslash)
          d >= 128 && p.NonAsciiIdentifierPart.test(String.fromCharCode(d));
        }
        function pt(d) {
          switch (d) {
            case "class":
            case "enum":
            case "export":
            case "extends":
            case "import":
            case "super":
              return !0;
            default:
              return !1;
          }
        }
        function vt(d) {
          switch (d) {
            case "implements":
            case "interface":
            case "package":
            case "private":
            case "protected":
            case "public":
            case "static":
            case "yield":
            case "let":
              return !0;
            default:
              return !1;
          }
        }
        function _t(d) {
          return d === "eval" || d === "arguments";
        }
        function Ct(d) {
          if (b && vt(d))
            return !0;
          switch (d.length) {
            case 2:
              return d === "if" || d === "in" || d === "do";
            case 3:
              return d === "var" || d === "for" || d === "new" || d === "try" || d === "let";
            case 4:
              return d === "this" || d === "else" || d === "case" || d === "void" || d === "with" || d === "enum";
            case 5:
              return d === "while" || d === "break" || d === "catch" || d === "throw" || d === "const" || d === "yield" || d === "class" || d === "super";
            case 6:
              return d === "return" || d === "typeof" || d === "delete" || d === "switch" || d === "export" || d === "import";
            case 7:
              return d === "default" || d === "finally" || d === "extends";
            case 8:
              return d === "function" || d === "continue" || d === "debugger";
            case 10:
              return d === "instanceof";
            default:
              return !1;
          }
        }
        function It(d, v, I, j, Z) {
          var ht;
          R(typeof I == "number", "Comment must have valid position"), !(_.lastCommentStart >= I) && (_.lastCommentStart = I, ht = {
            type: d,
            value: v
          }, S.range && (ht.range = [I, j]), S.loc && (ht.loc = Z), S.comments.push(ht), S.attachComment && (S.leadingComments.push(ht), S.trailingComments.push(ht)));
        }
        function jt(d) {
          var v, I, j, Z;
          for (v = f - d, I = {
            start: {
              line: E,
              column: f - A - d
            }
          }; f < x; )
            if (j = g.charCodeAt(f), ++f, Y(j)) {
              S.comments && (Z = g.slice(v + d, f - 1), I.end = {
                line: E,
                column: f - A - 1
              }, It("Line", Z, v, f - 1, I)), j === 13 && g.charCodeAt(f) === 10 && ++f, ++E, A = f;
              return;
            }
          S.comments && (Z = g.slice(v + d, f), I.end = {
            line: E,
            column: f - A
          }, It("Line", Z, v, f, I));
        }
        function lt() {
          var d, v, I, j;
          for (S.comments && (d = f - 2, v = {
            start: {
              line: E,
              column: f - A - 2
            }
          }); f < x; )
            if (I = g.charCodeAt(f), Y(I))
              I === 13 && g.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && bt({}, u.UnexpectedToken, "ILLEGAL");
            else if (I === 42) {
              if (g.charCodeAt(f + 1) === 47) {
                ++f, ++f, S.comments && (j = g.slice(d + 2, f - 2), v.end = {
                  line: E,
                  column: f - A
                }, It("Block", j, d, f, v));
                return;
              }
              ++f;
            } else
              ++f;
          bt({}, u.UnexpectedToken, "ILLEGAL");
        }
        function L() {
          var d, v;
          for (v = f === 0; f < x; )
            if (d = g.charCodeAt(f), F(d))
              ++f;
            else if (Y(d))
              ++f, d === 13 && g.charCodeAt(f) === 10 && ++f, ++E, A = f, v = !0;
            else if (d === 47)
              if (d = g.charCodeAt(f + 1), d === 47)
                ++f, ++f, jt(2), v = !0;
              else if (d === 42)
                ++f, ++f, lt();
              else
                break;
            else if (v && d === 45)
              if (g.charCodeAt(f + 1) === 45 && g.charCodeAt(f + 2) === 62)
                f += 3, jt(3);
              else
                break;
            else if (d === 60)
              if (g.slice(f + 1, f + 4) === "!--")
                ++f, ++f, ++f, ++f, jt(4);
              else
                break;
            else
              break;
        }
        function D(d) {
          var v, I, j, Z = 0;
          for (I = d === "u" ? 4 : 2, v = 0; v < I; ++v)
            if (f < x && $(g[f]))
              j = g[f++], Z = Z * 16 + "0123456789abcdef".indexOf(j.toLowerCase());
            else
              return "";
          return String.fromCharCode(Z);
        }
        function tt() {
          var d, v;
          for (d = g.charCodeAt(f++), v = String.fromCharCode(d), d === 92 && (g.charCodeAt(f) !== 117 && bt({}, u.UnexpectedToken, "ILLEGAL"), ++f, d = D("u"), (!d || d === "\\" || !rt(d.charCodeAt(0))) && bt({}, u.UnexpectedToken, "ILLEGAL"), v = d); f < x && (d = g.charCodeAt(f), !!at(d)); )
            ++f, v += String.fromCharCode(d), d === 92 && (v = v.substr(0, v.length - 1), g.charCodeAt(f) !== 117 && bt({}, u.UnexpectedToken, "ILLEGAL"), ++f, d = D("u"), (!d || d === "\\" || !at(d.charCodeAt(0))) && bt({}, u.UnexpectedToken, "ILLEGAL"), v += d);
          return v;
        }
        function et() {
          var d, v;
          for (d = f++; f < x; ) {
            if (v = g.charCodeAt(f), v === 92)
              return f = d, tt();
            if (at(v))
              ++f;
            else
              break;
          }
          return g.slice(d, f);
        }
        function st() {
          var d, v, I;
          return d = f, v = g.charCodeAt(f) === 92 ? tt() : et(), v.length === 1 ? I = o.Identifier : Ct(v) ? I = o.Keyword : v === "null" ? I = o.NullLiteral : v === "true" || v === "false" ? I = o.BooleanLiteral : I = o.Identifier, {
            type: I,
            value: v,
            lineNumber: E,
            lineStart: A,
            start: d,
            end: f
          };
        }
        function X() {
          var d = f, v = g.charCodeAt(f), I, j = g[f], Z, ht, Ot;
          switch (v) {
            case 46:
            case 40:
            case 41:
            case 59:
            case 44:
            case 123:
            case 125:
            case 91:
            case 93:
            case 58:
            case 63:
            case 126:
              return ++f, S.tokenize && (v === 40 ? S.openParenToken = S.tokens.length : v === 123 && (S.openCurlyToken = S.tokens.length)), {
                type: o.Punctuator,
                value: String.fromCharCode(v),
                lineNumber: E,
                lineStart: A,
                start: d,
                end: f
              };
            default:
              if (I = g.charCodeAt(f + 1), I === 61)
                switch (v) {
                  case 43:
                  case 45:
                  case 47:
                  case 60:
                  case 62:
                  case 94:
                  case 124:
                  case 37:
                  case 38:
                  case 42:
                    return f += 2, {
                      type: o.Punctuator,
                      value: String.fromCharCode(v) + String.fromCharCode(I),
                      lineNumber: E,
                      lineStart: A,
                      start: d,
                      end: f
                    };
                  case 33:
                  case 61:
                    return f += 2, g.charCodeAt(f) === 61 && ++f, {
                      type: o.Punctuator,
                      value: g.slice(d, f),
                      lineNumber: E,
                      lineStart: A,
                      start: d,
                      end: f
                    };
                }
          }
          if (Ot = g.substr(f, 4), Ot === ">>>=")
            return f += 4, {
              type: o.Punctuator,
              value: Ot,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          if (ht = Ot.substr(0, 3), ht === ">>>" || ht === "<<=" || ht === ">>=")
            return f += 3, {
              type: o.Punctuator,
              value: ht,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          if (Z = ht.substr(0, 2), j === Z[1] && "+-<>&|".indexOf(j) >= 0 || Z === "=>")
            return f += 2, {
              type: o.Punctuator,
              value: Z,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          if ("<>=!+-*%&|^/".indexOf(j) >= 0)
            return ++f, {
              type: o.Punctuator,
              value: j,
              lineNumber: E,
              lineStart: A,
              start: d,
              end: f
            };
          bt({}, u.UnexpectedToken, "ILLEGAL");
        }
        function ot(d) {
          for (var v = ""; f < x && $(g[f]); )
            v += g[f++];
          return v.length === 0 && bt({}, u.UnexpectedToken, "ILLEGAL"), rt(g.charCodeAt(f)) && bt({}, u.UnexpectedToken, "ILLEGAL"), {
            type: o.NumericLiteral,
            value: parseInt("0x" + v, 16),
            lineNumber: E,
            lineStart: A,
            start: d,
            end: f
          };
        }
        function mt(d) {
          for (var v = "0" + g[f++]; f < x && z(g[f]); )
            v += g[f++];
          return (rt(g.charCodeAt(f)) || O(g.charCodeAt(f))) && bt({}, u.UnexpectedToken, "ILLEGAL"), {
            type: o.NumericLiteral,
            value: parseInt(v, 8),
            octal: !0,
            lineNumber: E,
            lineStart: A,
            start: d,
            end: f
          };
        }
        function U() {
          var d, v, I;
          if (I = g[f], R(
            O(I.charCodeAt(0)) || I === ".",
            "Numeric literal must start with a decimal digit or a decimal point"
          ), v = f, d = "", I !== ".") {
            if (d = g[f++], I = g[f], d === "0") {
              if (I === "x" || I === "X")
                return ++f, ot(v);
              if (z(I))
                return mt(v);
              I && O(I.charCodeAt(0)) && bt({}, u.UnexpectedToken, "ILLEGAL");
            }
            for (; O(g.charCodeAt(f)); )
              d += g[f++];
            I = g[f];
          }
          if (I === ".") {
            for (d += g[f++]; O(g.charCodeAt(f)); )
              d += g[f++];
            I = g[f];
          }
          if (I === "e" || I === "E")
            if (d += g[f++], I = g[f], (I === "+" || I === "-") && (d += g[f++]), O(g.charCodeAt(f)))
              for (; O(g.charCodeAt(f)); )
                d += g[f++];
            else
              bt({}, u.UnexpectedToken, "ILLEGAL");
          return rt(g.charCodeAt(f)) && bt({}, u.UnexpectedToken, "ILLEGAL"), {
            type: o.NumericLiteral,
            value: parseFloat(d),
            lineNumber: E,
            lineStart: A,
            start: v,
            end: f
          };
        }
        function J() {
          var d = "", v, I, j, Z, ht, Ot, Gt = !1, fe, ce;
          for (fe = E, ce = A, v = g[f], R(
            v === "'" || v === '"',
            "String literal must starts with a quote"
          ), I = f, ++f; f < x; )
            if (j = g[f++], j === v) {
              v = "";
              break;
            } else if (j === "\\")
              if (j = g[f++], !j || !Y(j.charCodeAt(0)))
                switch (j) {
                  case "u":
                  case "x":
                    Ot = f, ht = D(j), ht ? d += ht : (f = Ot, d += j);
                    break;
                  case "n":
                    d += `
`;
                    break;
                  case "r":
                    d += "\r";
                    break;
                  case "t":
                    d += "	";
                    break;
                  case "b":
                    d += "\b";
                    break;
                  case "f":
                    d += "\f";
                    break;
                  case "v":
                    d += "\v";
                    break;
                  default:
                    z(j) ? (Z = "01234567".indexOf(j), Z !== 0 && (Gt = !0), f < x && z(g[f]) && (Gt = !0, Z = Z * 8 + "01234567".indexOf(g[f++]), "0123".indexOf(j) >= 0 && f < x && z(g[f]) && (Z = Z * 8 + "01234567".indexOf(g[f++]))), d += String.fromCharCode(Z)) : d += j;
                    break;
                }
              else
                ++E, j === "\r" && g[f] === `
` && ++f, A = f;
            else {
              if (Y(j.charCodeAt(0)))
                break;
              d += j;
            }
          return v !== "" && bt({}, u.UnexpectedToken, "ILLEGAL"), {
            type: o.StringLiteral,
            value: d,
            octal: Gt,
            startLineNumber: fe,
            startLineStart: ce,
            lineNumber: E,
            lineStart: A,
            start: I,
            end: f
          };
        }
        function St(d, v) {
          var I;
          try {
            I = new RegExp(d, v);
          } catch {
            bt({}, u.InvalidRegExp);
          }
          return I;
        }
        function Rt() {
          var d, v, I, j, Z;
          for (d = g[f], R(d === "/", "Regular expression literal must start with a slash"), v = g[f++], I = !1, j = !1; f < x; )
            if (d = g[f++], v += d, d === "\\")
              d = g[f++], Y(d.charCodeAt(0)) && bt({}, u.UnterminatedRegExp), v += d;
            else if (Y(d.charCodeAt(0)))
              bt({}, u.UnterminatedRegExp);
            else if (I)
              d === "]" && (I = !1);
            else if (d === "/") {
              j = !0;
              break;
            } else d === "[" && (I = !0);
          return j || bt({}, u.UnterminatedRegExp), Z = v.substr(1, v.length - 2), {
            value: Z,
            literal: v
          };
        }
        function zt() {
          var d, v, I, j;
          for (v = "", I = ""; f < x && (d = g[f], !!at(d.charCodeAt(0))); )
            if (++f, d === "\\" && f < x)
              if (d = g[f], d === "u") {
                if (++f, j = f, d = D("u"), d)
                  for (I += d, v += "\\u"; j < f; ++j)
                    v += g[j];
                else
                  f = j, I += "u", v += "\\u";
                xt({}, u.UnexpectedToken, "ILLEGAL");
              } else
                v += "\\", xt({}, u.UnexpectedToken, "ILLEGAL");
            else
              I += d, v += d;
          return {
            value: I,
            literal: v
          };
        }
        function Tt() {
          var d, v, I, j;
          return w = null, L(), d = f, v = Rt(), I = zt(), j = St(v.value, I.value), S.tokenize ? {
            type: o.RegularExpression,
            value: j,
            lineNumber: E,
            lineStart: A,
            start: d,
            end: f
          } : {
            literal: v.literal + I.literal,
            value: j,
            start: d,
            end: f
          };
        }
        function Yt() {
          var d, v, I, j;
          return L(), d = f, v = {
            start: {
              line: E,
              column: f - A
            }
          }, I = Tt(), v.end = {
            line: E,
            column: f - A
          }, S.tokenize || (S.tokens.length > 0 && (j = S.tokens[S.tokens.length - 1], j.range[0] === d && j.type === "Punctuator" && (j.value === "/" || j.value === "/=") && S.tokens.pop()), S.tokens.push({
            type: "RegularExpression",
            value: I.literal,
            range: [d, f],
            loc: v
          })), I;
        }
        function Zt(d) {
          return d.type === o.Identifier || d.type === o.Keyword || d.type === o.BooleanLiteral || d.type === o.NullLiteral;
        }
        function kt() {
          var d, v;
          if (d = S.tokens[S.tokens.length - 1], !d)
            return Yt();
          if (d.type === "Punctuator") {
            if (d.value === "]")
              return X();
            if (d.value === ")")
              return v = S.tokens[S.openParenToken - 1], v && v.type === "Keyword" && (v.value === "if" || v.value === "while" || v.value === "for" || v.value === "with") ? Yt() : X();
            if (d.value === "}") {
              if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                if (v = S.tokens[S.openCurlyToken - 4], !v)
                  return X();
              } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                if (v = S.tokens[S.openCurlyToken - 5], !v)
                  return Yt();
              } else
                return X();
              return l.indexOf(v.value) >= 0 ? X() : Yt();
            }
            return Yt();
          }
          return d.type === "Keyword" ? Yt() : X();
        }
        function _e() {
          var d;
          return L(), f >= x ? {
            type: o.EOF,
            lineNumber: E,
            lineStart: A,
            start: f,
            end: f
          } : (d = g.charCodeAt(f), rt(d) ? st() : d === 40 || d === 41 || d === 59 ? X() : d === 39 || d === 34 ? J() : d === 46 ? O(g.charCodeAt(f + 1)) ? U() : X() : O(d) ? U() : S.tokenize && d === 47 ? kt() : X());
        }
        function Ye() {
          var d, v, I;
          return L(), d = {
            start: {
              line: E,
              column: f - A
            }
          }, v = _e(), d.end = {
            line: E,
            column: f - A
          }, v.type !== o.EOF && (I = g.slice(v.start, v.end), S.tokens.push({
            type: a[v.type],
            value: I,
            range: [v.start, v.end],
            loc: d
          })), v;
        }
        function wt() {
          var d;
          return d = w, f = d.end, E = d.lineNumber, A = d.lineStart, w = typeof S.tokens < "u" ? Ye() : _e(), f = d.end, E = d.lineNumber, A = d.lineStart, d;
        }
        function le() {
          var d, v, I;
          d = f, v = E, I = A, w = typeof S.tokens < "u" ? Ye() : _e(), f = d, E = v, A = I;
        }
        function te(d, v) {
          this.line = d, this.column = v;
        }
        function Se(d, v, I, j) {
          this.start = new te(d, v), this.end = new te(I, j);
        }
        y = {
          name: "SyntaxTree",
          processComment: function(d) {
            var v, I;
            if (!(d.type === c.Program && d.body.length > 0)) {
              for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= d.range[1] ? (I = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= d.range[1] && (I = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= d.range[0]; )
                v = S.bottomRightStack.pop();
              v ? v.leadingComments && v.leadingComments[v.leadingComments.length - 1].range[1] <= d.range[0] && (d.leadingComments = v.leadingComments, delete v.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= d.range[0] && (d.leadingComments = S.leadingComments, S.leadingComments = []), I && (d.trailingComments = I), S.bottomRightStack.push(d);
            }
          },
          markEnd: function(d, v) {
            return S.range && (d.range = [v.start, f]), S.loc && (d.loc = new Se(
              v.startLineNumber === void 0 ? v.lineNumber : v.startLineNumber,
              v.start - (v.startLineStart === void 0 ? v.lineStart : v.startLineStart),
              E,
              f - A
            ), this.postProcess(d)), S.attachComment && this.processComment(d), d;
          },
          postProcess: function(d) {
            return S.source && (d.loc.source = S.source), d;
          },
          createArrayExpression: function(d) {
            return {
              type: c.ArrayExpression,
              elements: d
            };
          },
          createAssignmentExpression: function(d, v, I) {
            return {
              type: c.AssignmentExpression,
              operator: d,
              left: v,
              right: I
            };
          },
          createBinaryExpression: function(d, v, I) {
            var j = d === "||" || d === "&&" ? c.LogicalExpression : c.BinaryExpression;
            return {
              type: j,
              operator: d,
              left: v,
              right: I
            };
          },
          createBlockStatement: function(d) {
            return {
              type: c.BlockStatement,
              body: d
            };
          },
          createBreakStatement: function(d) {
            return {
              type: c.BreakStatement,
              label: d
            };
          },
          createCallExpression: function(d, v) {
            return {
              type: c.CallExpression,
              callee: d,
              arguments: v
            };
          },
          createCatchClause: function(d, v) {
            return {
              type: c.CatchClause,
              param: d,
              body: v
            };
          },
          createConditionalExpression: function(d, v, I) {
            return {
              type: c.ConditionalExpression,
              test: d,
              consequent: v,
              alternate: I
            };
          },
          createContinueStatement: function(d) {
            return {
              type: c.ContinueStatement,
              label: d
            };
          },
          createDebuggerStatement: function() {
            return {
              type: c.DebuggerStatement
            };
          },
          createDoWhileStatement: function(d, v) {
            return {
              type: c.DoWhileStatement,
              body: d,
              test: v
            };
          },
          createEmptyStatement: function() {
            return {
              type: c.EmptyStatement
            };
          },
          createExpressionStatement: function(d) {
            return {
              type: c.ExpressionStatement,
              expression: d
            };
          },
          createForStatement: function(d, v, I, j) {
            return {
              type: c.ForStatement,
              init: d,
              test: v,
              update: I,
              body: j
            };
          },
          createForInStatement: function(d, v, I) {
            return {
              type: c.ForInStatement,
              left: d,
              right: v,
              body: I,
              each: !1
            };
          },
          createFunctionDeclaration: function(d, v, I, j) {
            return {
              type: c.FunctionDeclaration,
              id: d,
              params: v,
              defaults: I,
              body: j,
              rest: null,
              generator: !1,
              expression: !1
            };
          },
          createFunctionExpression: function(d, v, I, j) {
            return {
              type: c.FunctionExpression,
              id: d,
              params: v,
              defaults: I,
              body: j,
              rest: null,
              generator: !1,
              expression: !1
            };
          },
          createIdentifier: function(d) {
            return {
              type: c.Identifier,
              name: d
            };
          },
          createIfStatement: function(d, v, I) {
            return {
              type: c.IfStatement,
              test: d,
              consequent: v,
              alternate: I
            };
          },
          createLabeledStatement: function(d, v) {
            return {
              type: c.LabeledStatement,
              label: d,
              body: v
            };
          },
          createLiteral: function(d) {
            return {
              type: c.Literal,
              value: d.value,
              raw: g.slice(d.start, d.end)
            };
          },
          createMemberExpression: function(d, v, I) {
            return {
              type: c.MemberExpression,
              computed: d === "[",
              object: v,
              property: I
            };
          },
          createNewExpression: function(d, v) {
            return {
              type: c.NewExpression,
              callee: d,
              arguments: v
            };
          },
          createObjectExpression: function(d) {
            return {
              type: c.ObjectExpression,
              properties: d
            };
          },
          createPostfixExpression: function(d, v) {
            return {
              type: c.UpdateExpression,
              operator: d,
              argument: v,
              prefix: !1
            };
          },
          createProgram: function(d) {
            return {
              type: c.Program,
              body: d
            };
          },
          createProperty: function(d, v, I) {
            return {
              type: c.Property,
              key: v,
              value: I,
              kind: d
            };
          },
          createReturnStatement: function(d) {
            return {
              type: c.ReturnStatement,
              argument: d
            };
          },
          createSequenceExpression: function(d) {
            return {
              type: c.SequenceExpression,
              expressions: d
            };
          },
          createSwitchCase: function(d, v) {
            return {
              type: c.SwitchCase,
              test: d,
              consequent: v
            };
          },
          createSwitchStatement: function(d, v) {
            return {
              type: c.SwitchStatement,
              discriminant: d,
              cases: v
            };
          },
          createThisExpression: function() {
            return {
              type: c.ThisExpression
            };
          },
          createThrowStatement: function(d) {
            return {
              type: c.ThrowStatement,
              argument: d
            };
          },
          createTryStatement: function(d, v, I, j) {
            return {
              type: c.TryStatement,
              block: d,
              guardedHandlers: v,
              handlers: I,
              finalizer: j
            };
          },
          createUnaryExpression: function(d, v) {
            return d === "++" || d === "--" ? {
              type: c.UpdateExpression,
              operator: d,
              argument: v,
              prefix: !0
            } : {
              type: c.UnaryExpression,
              operator: d,
              argument: v,
              prefix: !0
            };
          },
          createVariableDeclaration: function(d, v) {
            return {
              type: c.VariableDeclaration,
              declarations: d,
              kind: v
            };
          },
          createVariableDeclarator: function(d, v) {
            return {
              type: c.VariableDeclarator,
              id: d,
              init: v
            };
          },
          createWhileStatement: function(d, v) {
            return {
              type: c.WhileStatement,
              test: d,
              body: v
            };
          },
          createWithStatement: function(d, v) {
            return {
              type: c.WithStatement,
              object: d,
              body: v
            };
          }
        };
        function Kt() {
          var d, v, I, j;
          return d = f, v = E, I = A, L(), j = E !== v, f = d, E = v, A = I, j;
        }
        function bt(d, v) {
          var I, j = Array.prototype.slice.call(arguments, 2), Z = v.replace(
            /%(\d)/g,
            function(ht, Ot) {
              return R(Ot < j.length, "Message reference must be in range"), j[Ot];
            }
          );
          throw typeof d.lineNumber == "number" ? (I = new Error("Line " + d.lineNumber + ": " + Z), I.index = d.start, I.lineNumber = d.lineNumber, I.column = d.start - A + 1) : (I = new Error("Line " + E + ": " + Z), I.index = f, I.lineNumber = E, I.column = f - A + 1), I.description = Z, I;
        }
        function xt() {
          try {
            bt.apply(null, arguments);
          } catch (d) {
            if (S.errors)
              S.errors.push(d);
            else
              throw d;
          }
        }
        function Jt(d) {
          if (d.type === o.EOF && bt(d, u.UnexpectedEOS), d.type === o.NumericLiteral && bt(d, u.UnexpectedNumber), d.type === o.StringLiteral && bt(d, u.UnexpectedString), d.type === o.Identifier && bt(d, u.UnexpectedIdentifier), d.type === o.Keyword) {
            if (pt(d.value))
              bt(d, u.UnexpectedReserved);
            else if (b && vt(d.value)) {
              xt(d, u.StrictReservedWord);
              return;
            }
            bt(d, u.UnexpectedToken, d.value);
          }
          bt(d, u.UnexpectedToken, d.value);
        }
        function k(d) {
          var v = wt();
          (v.type !== o.Punctuator || v.value !== d) && Jt(v);
        }
        function M(d) {
          var v = wt();
          (v.type !== o.Keyword || v.value !== d) && Jt(v);
        }
        function B(d) {
          return w.type === o.Punctuator && w.value === d;
        }
        function it(d) {
          return w.type === o.Keyword && w.value === d;
        }
        function ct() {
          var d;
          return w.type !== o.Punctuator ? !1 : (d = w.value, d === "=" || d === "*=" || d === "/=" || d === "%=" || d === "+=" || d === "-=" || d === "<<=" || d === ">>=" || d === ">>>=" || d === "&=" || d === "^=" || d === "|=");
        }
        function Et() {
          var d;
          if (g.charCodeAt(f) === 59 || B(";")) {
            wt();
            return;
          }
          d = E, L(), E === d && w.type !== o.EOF && !B("}") && Jt(w);
        }
        function Mt(d) {
          return d.type === c.Identifier || d.type === c.MemberExpression;
        }
        function se() {
          var d = [], v;
          for (v = w, k("["); !B("]"); )
            B(",") ? (wt(), d.push(null)) : (d.push(q()), B("]") || k(","));
          return wt(), m.markEnd(m.createArrayExpression(d), v);
        }
        function de(d, v) {
          var I, j, Z;
          return I = b, Z = w, j = ds(), v && b && _t(d[0].name) && xt(v, u.StrictParamName), b = I, m.markEnd(m.createFunctionExpression(null, d, [], j), Z);
        }
        function ke() {
          var d, v;
          return v = w, d = wt(), d.type === o.StringLiteral || d.type === o.NumericLiteral ? (b && d.octal && xt(d, u.StrictOctalLiteral), m.markEnd(m.createLiteral(d), v)) : m.markEnd(m.createIdentifier(d.value), v);
        }
        function Xt() {
          var d, v, I, j, Z, ht;
          if (d = w, ht = w, d.type === o.Identifier)
            return I = ke(), d.value === "get" && !B(":") ? (v = ke(), k("("), k(")"), j = de([]), m.markEnd(m.createProperty("get", v, j), ht)) : d.value === "set" && !B(":") ? (v = ke(), k("("), d = w, d.type !== o.Identifier ? (k(")"), xt(d, u.UnexpectedToken, d.value), j = de([])) : (Z = [ut()], k(")"), j = de(Z, d)), m.markEnd(m.createProperty("set", v, j), ht)) : (k(":"), j = q(), m.markEnd(m.createProperty("init", I, j), ht));
          if (d.type === o.EOF || d.type === o.Punctuator)
            Jt(d);
          else
            return v = ke(), k(":"), j = q(), m.markEnd(m.createProperty("init", v, j), ht);
        }
        function ze() {
          var d = [], v, I, j, Z, ht = {}, Ot = String, Gt;
          for (Gt = w, k("{"); !B("}"); )
            v = Xt(), v.key.type === c.Identifier ? I = v.key.name : I = Ot(v.key.value), Z = v.kind === "init" ? h.Data : v.kind === "get" ? h.Get : h.Set, j = "$" + I, Object.prototype.hasOwnProperty.call(ht, j) ? (ht[j] === h.Data ? b && Z === h.Data ? xt({}, u.StrictDuplicateProperty) : Z !== h.Data && xt({}, u.AccessorDataProperty) : Z === h.Data ? xt({}, u.AccessorDataProperty) : ht[j] & Z && xt({}, u.AccessorGetSet), ht[j] |= Z) : ht[j] = Z, d.push(v), B("}") || k(",");
          return k("}"), m.markEnd(m.createObjectExpression(d), Gt);
        }
        function We() {
          var d;
          return k("("), d = W(), k(")"), d;
        }
        function pr() {
          var d, v, I, j;
          if (B("("))
            return We();
          if (B("["))
            return se();
          if (B("{"))
            return ze();
          if (d = w.type, j = w, d === o.Identifier)
            I = m.createIdentifier(wt().value);
          else if (d === o.StringLiteral || d === o.NumericLiteral)
            b && w.octal && xt(w, u.StrictOctalLiteral), I = m.createLiteral(wt());
          else if (d === o.Keyword) {
            if (it("function"))
              return kd();
            it("this") ? (wt(), I = m.createThisExpression()) : Jt(wt());
          } else d === o.BooleanLiteral ? (v = wt(), v.value = v.value === "true", I = m.createLiteral(v)) : d === o.NullLiteral ? (v = wt(), v.value = null, I = m.createLiteral(v)) : B("/") || B("/=") ? (typeof S.tokens < "u" ? I = m.createLiteral(Yt()) : I = m.createLiteral(Tt()), le()) : Jt(wt());
          return m.markEnd(I, j);
        }
        function Yr() {
          var d = [];
          if (k("("), !B(")"))
            for (; f < x && (d.push(q()), !B(")")); )
              k(",");
          return k(")"), d;
        }
        function ps() {
          var d, v;
          return v = w, d = wt(), Zt(d) || Jt(d), m.markEnd(m.createIdentifier(d.value), v);
        }
        function qe() {
          return k("."), ps();
        }
        function Vi() {
          var d;
          return k("["), d = W(), k("]"), d;
        }
        function T() {
          var d, v, I;
          return I = w, M("new"), d = H(), v = B("(") ? Yr() : [], m.markEnd(m.createNewExpression(d, v), I);
        }
        function V() {
          var d, v, I, j, Z;
          for (Z = w, d = _.allowIn, _.allowIn = !0, v = it("new") ? T() : pr(), _.allowIn = d; ; ) {
            if (B("."))
              j = qe(), v = m.createMemberExpression(".", v, j);
            else if (B("("))
              I = Yr(), v = m.createCallExpression(v, I);
            else if (B("["))
              j = Vi(), v = m.createMemberExpression("[", v, j);
            else
              break;
            m.markEnd(v, Z);
          }
          return v;
        }
        function H() {
          var d, v, I, j;
          for (j = w, d = _.allowIn, v = it("new") ? T() : pr(), _.allowIn = d; B(".") || B("["); )
            B("[") ? (I = Vi(), v = m.createMemberExpression("[", v, I)) : (I = qe(), v = m.createMemberExpression(".", v, I)), m.markEnd(v, j);
          return v;
        }
        function dt() {
          var d, v, I = w;
          return d = V(), w.type === o.Punctuator && (B("++") || B("--")) && !Kt() && (b && d.type === c.Identifier && _t(d.name) && xt({}, u.StrictLHSPostfix), Mt(d) || xt({}, u.InvalidLHSInAssignment), v = wt(), d = m.markEnd(m.createPostfixExpression(v.value, d), I)), d;
        }
        function ft() {
          var d, v, I;
          return w.type !== o.Punctuator && w.type !== o.Keyword ? v = dt() : B("++") || B("--") ? (I = w, d = wt(), v = ft(), b && v.type === c.Identifier && _t(v.name) && xt({}, u.StrictLHSPrefix), Mt(v) || xt({}, u.InvalidLHSInAssignment), v = m.createUnaryExpression(d.value, v), v = m.markEnd(v, I)) : B("+") || B("-") || B("~") || B("!") ? (I = w, d = wt(), v = ft(), v = m.createUnaryExpression(d.value, v), v = m.markEnd(v, I)) : it("delete") || it("void") || it("typeof") ? (I = w, d = wt(), v = ft(), v = m.createUnaryExpression(d.value, v), v = m.markEnd(v, I), b && v.operator === "delete" && v.argument.type === c.Identifier && xt({}, u.StrictDelete)) : v = dt(), v;
        }
        function K(d, v) {
          var I = 0;
          if (d.type !== o.Punctuator && d.type !== o.Keyword)
            return 0;
          switch (d.value) {
            case "||":
              I = 1;
              break;
            case "&&":
              I = 2;
              break;
            case "|":
              I = 3;
              break;
            case "^":
              I = 4;
              break;
            case "&":
              I = 5;
              break;
            case "==":
            case "!=":
            case "===":
            case "!==":
              I = 6;
              break;
            case "<":
            case ">":
            case "<=":
            case ">=":
            case "instanceof":
              I = 7;
              break;
            case "in":
              I = v ? 7 : 0;
              break;
            case "<<":
            case ">>":
            case ">>>":
              I = 8;
              break;
            case "+":
            case "-":
              I = 9;
              break;
            case "*":
            case "/":
            case "%":
              I = 11;
              break;
          }
          return I;
        }
        function C() {
          var d, v, I, j, Z, ht, Ot, Gt, fe, ce;
          if (d = w, fe = ft(), j = w, Z = K(j, _.allowIn), Z === 0)
            return fe;
          for (j.prec = Z, wt(), v = [d, w], Ot = ft(), ht = [fe, j, Ot]; (Z = K(w, _.allowIn)) > 0; ) {
            for (; ht.length > 2 && Z <= ht[ht.length - 2].prec; )
              Ot = ht.pop(), Gt = ht.pop().value, fe = ht.pop(), I = m.createBinaryExpression(Gt, fe, Ot), v.pop(), d = v[v.length - 1], m.markEnd(I, d), ht.push(I);
            j = wt(), j.prec = Z, ht.push(j), v.push(w), I = ft(), ht.push(I);
          }
          for (ce = ht.length - 1, I = ht[ce], v.pop(); ce > 1; )
            I = m.createBinaryExpression(ht[ce - 1].value, ht[ce - 2], I), ce -= 2, d = v.pop(), m.markEnd(I, d);
          return I;
        }
        function N() {
          var d, v, I, j, Z;
          return Z = w, d = C(), B("?") && (wt(), v = _.allowIn, _.allowIn = !0, I = q(), _.allowIn = v, k(":"), j = q(), d = m.createConditionalExpression(d, I, j), m.markEnd(d, Z)), d;
        }
        function q() {
          var d, v, I, j, Z;
          return d = w, Z = w, j = v = N(), ct() && (Mt(v) || xt({}, u.InvalidLHSInAssignment), b && v.type === c.Identifier && _t(v.name) && xt(d, u.StrictLHSAssignment), d = wt(), I = q(), j = m.markEnd(m.createAssignmentExpression(d.value, v, I), Z)), j;
        }
        function W() {
          var d, v = w;
          if (d = q(), B(",")) {
            for (d = m.createSequenceExpression([d]); f < x && B(","); )
              wt(), d.expressions.push(q());
            m.markEnd(d, v);
          }
          return d;
        }
        function G() {
          for (var d = [], v; f < x && !(B("}") || (v = Jr(), typeof v > "u")); )
            d.push(v);
          return d;
        }
        function nt() {
          var d, v;
          return v = w, k("{"), d = G(), k("}"), m.markEnd(m.createBlockStatement(d), v);
        }
        function ut() {
          var d, v;
          return v = w, d = wt(), d.type !== o.Identifier && Jt(d), m.markEnd(m.createIdentifier(d.value), v);
        }
        function gt(d) {
          var v = null, I, j;
          return j = w, I = ut(), b && _t(I.name) && xt({}, u.StrictVarName), d === "const" ? (k("="), v = q()) : B("=") && (wt(), v = q()), m.markEnd(m.createVariableDeclarator(I, v), j);
        }
        function At(d) {
          var v = [];
          do {
            if (v.push(gt(d)), !B(","))
              break;
            wt();
          } while (f < x);
          return v;
        }
        function Nt() {
          var d;
          return M("var"), d = At(), Et(), m.createVariableDeclaration(d, "var");
        }
        function Bt(d) {
          var v, I;
          return I = w, M(d), v = At(d), Et(), m.markEnd(m.createVariableDeclaration(v, d), I);
        }
        function Wt() {
          return k(";"), m.createEmptyStatement();
        }
        function oe() {
          var d = W();
          return Et(), m.createExpressionStatement(d);
        }
        function ie() {
          var d, v, I;
          return M("if"), k("("), d = W(), k(")"), v = Qe(), it("else") ? (wt(), I = Qe()) : I = null, m.createIfStatement(d, v, I);
        }
        function Ce() {
          var d, v, I;
          return M("do"), I = _.inIteration, _.inIteration = !0, d = Qe(), _.inIteration = I, M("while"), k("("), v = W(), k(")"), B(";") && wt(), m.createDoWhileStatement(d, v);
        }
        function De() {
          var d, v, I;
          return M("while"), k("("), d = W(), k(")"), I = _.inIteration, _.inIteration = !0, v = Qe(), _.inIteration = I, m.createWhileStatement(d, v);
        }
        function Dr() {
          var d, v, I;
          return I = w, d = wt(), v = At(), m.markEnd(m.createVariableDeclaration(v, d.value), I);
        }
        function On() {
          var d, v, I, j, Z, ht, Ot;
          return d = v = I = null, M("for"), k("("), B(";") ? wt() : (it("var") || it("let") ? (_.allowIn = !1, d = Dr(), _.allowIn = !0, d.declarations.length === 1 && it("in") && (wt(), j = d, Z = W(), d = null)) : (_.allowIn = !1, d = W(), _.allowIn = !0, it("in") && (Mt(d) || xt({}, u.InvalidLHSInForIn), wt(), j = d, Z = W(), d = null)), typeof j > "u" && k(";")), typeof j > "u" && (B(";") || (v = W()), k(";"), B(")") || (I = W())), k(")"), Ot = _.inIteration, _.inIteration = !0, ht = Qe(), _.inIteration = Ot, typeof j > "u" ? m.createForStatement(d, v, I, ht) : m.createForInStatement(j, Z, ht);
        }
        function Fa() {
          var d = null, v;
          return M("continue"), g.charCodeAt(f) === 59 ? (wt(), _.inIteration || bt({}, u.IllegalContinue), m.createContinueStatement(null)) : Kt() ? (_.inIteration || bt({}, u.IllegalContinue), m.createContinueStatement(null)) : (w.type === o.Identifier && (d = ut(), v = "$" + d.name, Object.prototype.hasOwnProperty.call(_.labelSet, v) || bt({}, u.UnknownLabel, d.name)), Et(), d === null && !_.inIteration && bt({}, u.IllegalContinue), m.createContinueStatement(d));
        }
        function $a() {
          var d = null, v;
          return M("break"), g.charCodeAt(f) === 59 ? (wt(), _.inIteration || _.inSwitch || bt({}, u.IllegalBreak), m.createBreakStatement(null)) : Kt() ? (_.inIteration || _.inSwitch || bt({}, u.IllegalBreak), m.createBreakStatement(null)) : (w.type === o.Identifier && (d = ut(), v = "$" + d.name, Object.prototype.hasOwnProperty.call(_.labelSet, v) || bt({}, u.UnknownLabel, d.name)), Et(), d === null && !(_.inIteration || _.inSwitch) && bt({}, u.IllegalBreak), m.createBreakStatement(d));
        }
        function bd() {
          var d = null;
          return M("return"), _.inFunctionBody || xt({}, u.IllegalReturn), g.charCodeAt(f) === 32 && rt(g.charCodeAt(f + 1)) ? (d = W(), Et(), m.createReturnStatement(d)) : Kt() ? m.createReturnStatement(null) : (B(";") || !B("}") && w.type !== o.EOF && (d = W()), Et(), m.createReturnStatement(d));
        }
        function vd() {
          var d, v;
          return b && (L(), xt({}, u.StrictModeWith)), M("with"), k("("), d = W(), k(")"), v = Qe(), m.createWithStatement(d, v);
        }
        function wd() {
          var d, v = [], I, j;
          for (j = w, it("default") ? (wt(), d = null) : (M("case"), d = W()), k(":"); f < x && !(B("}") || it("default") || it("case")); )
            I = Qe(), v.push(I);
          return m.markEnd(m.createSwitchCase(d, v), j);
        }
        function xd() {
          var d, v, I, j, Z;
          if (M("switch"), k("("), d = W(), k(")"), k("{"), v = [], B("}"))
            return wt(), m.createSwitchStatement(d, v);
          for (j = _.inSwitch, _.inSwitch = !0, Z = !1; f < x && !B("}"); )
            I = wd(), I.test === null && (Z && bt({}, u.MultipleDefaultsInSwitch), Z = !0), v.push(I);
          return _.inSwitch = j, k("}"), m.createSwitchStatement(d, v);
        }
        function Ed() {
          var d;
          return M("throw"), Kt() && bt({}, u.NewlineAfterThrow), d = W(), Et(), m.createThrowStatement(d);
        }
        function Ad() {
          var d, v, I;
          return I = w, M("catch"), k("("), B(")") && Jt(w), d = ut(), b && _t(d.name) && xt({}, u.StrictCatchVariable), k(")"), v = nt(), m.markEnd(m.createCatchClause(d, v), I);
        }
        function Sd() {
          var d, v = [], I = null;
          return M("try"), d = nt(), it("catch") && v.push(Ad()), it("finally") && (wt(), I = nt()), v.length === 0 && !I && bt({}, u.NoCatchOrFinally), m.createTryStatement(d, [], v, I);
        }
        function _d() {
          return M("debugger"), Et(), m.createDebuggerStatement();
        }
        function Qe() {
          var d = w.type, v, I, j, Z;
          if (d === o.EOF && Jt(w), d === o.Punctuator && w.value === "{")
            return nt();
          if (Z = w, d === o.Punctuator)
            switch (w.value) {
              case ";":
                return m.markEnd(Wt(), Z);
              case "(":
                return m.markEnd(oe(), Z);
            }
          if (d === o.Keyword)
            switch (w.value) {
              case "break":
                return m.markEnd($a(), Z);
              case "continue":
                return m.markEnd(Fa(), Z);
              case "debugger":
                return m.markEnd(_d(), Z);
              case "do":
                return m.markEnd(Ce(), Z);
              case "for":
                return m.markEnd(On(), Z);
              case "function":
                return m.markEnd(Va(), Z);
              case "if":
                return m.markEnd(ie(), Z);
              case "return":
                return m.markEnd(bd(), Z);
              case "switch":
                return m.markEnd(xd(), Z);
              case "throw":
                return m.markEnd(Ed(), Z);
              case "try":
                return m.markEnd(Sd(), Z);
              case "var":
                return m.markEnd(Nt(), Z);
              case "while":
                return m.markEnd(De(), Z);
              case "with":
                return m.markEnd(vd(), Z);
            }
          return v = W(), v.type === c.Identifier && B(":") ? (wt(), j = "$" + v.name, Object.prototype.hasOwnProperty.call(_.labelSet, j) && bt({}, u.Redeclaration, "Label", v.name), _.labelSet[j] = !0, I = Qe(), delete _.labelSet[j], m.markEnd(m.createLabeledStatement(v, I), Z)) : (Et(), m.markEnd(m.createExpressionStatement(v), Z));
        }
        function ds() {
          var d, v = [], I, j, Z, ht, Ot, Gt, fe, ce;
          for (ce = w, k("{"); f < x && !(w.type !== o.StringLiteral || (I = w, d = Jr(), v.push(d), d.expression.type !== c.Literal)); )
            j = g.slice(I.start + 1, I.end - 1), j === "use strict" ? (b = !0, Z && xt(Z, u.StrictOctalLiteral)) : !Z && I.octal && (Z = I);
          for (ht = _.labelSet, Ot = _.inIteration, Gt = _.inSwitch, fe = _.inFunctionBody, _.labelSet = {}, _.inIteration = !1, _.inSwitch = !1, _.inFunctionBody = !0; f < x && !(B("}") || (d = Jr(), typeof d > "u")); )
            v.push(d);
          return k("}"), _.labelSet = ht, _.inIteration = Ot, _.inSwitch = Gt, _.inFunctionBody = fe, m.markEnd(m.createBlockStatement(v), ce);
        }
        function za(d) {
          var v, I = [], j, Z, ht, Ot, Gt;
          if (k("("), !B(")"))
            for (ht = {}; f < x && (j = w, v = ut(), Ot = "$" + j.value, b ? (_t(j.value) && (Z = j, Gt = u.StrictParamName), Object.prototype.hasOwnProperty.call(ht, Ot) && (Z = j, Gt = u.StrictParamDupe)) : d || (_t(j.value) ? (d = j, Gt = u.StrictParamName) : vt(j.value) ? (d = j, Gt = u.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ht, Ot) && (d = j, Gt = u.StrictParamDupe)), I.push(v), ht[Ot] = !0, !B(")")); )
              k(",");
          return k(")"), {
            params: I,
            stricted: Z,
            firstRestricted: d,
            message: Gt
          };
        }
        function Va() {
          var d, v = [], I, j, Z, ht, Ot, Gt, fe, ce;
          return ce = w, M("function"), j = w, d = ut(), b ? _t(j.value) && xt(j, u.StrictFunctionName) : _t(j.value) ? (Ot = j, Gt = u.StrictFunctionName) : vt(j.value) && (Ot = j, Gt = u.StrictReservedWord), ht = za(Ot), v = ht.params, Z = ht.stricted, Ot = ht.firstRestricted, ht.message && (Gt = ht.message), fe = b, I = ds(), b && Ot && bt(Ot, Gt), b && Z && xt(Z, Gt), b = fe, m.markEnd(m.createFunctionDeclaration(d, v, [], I), ce);
        }
        function kd() {
          var d, v = null, I, j, Z, ht, Ot = [], Gt, fe, ce;
          return ce = w, M("function"), B("(") || (d = w, v = ut(), b ? _t(d.value) && xt(d, u.StrictFunctionName) : _t(d.value) ? (j = d, Z = u.StrictFunctionName) : vt(d.value) && (j = d, Z = u.StrictReservedWord)), ht = za(j), Ot = ht.params, I = ht.stricted, j = ht.firstRestricted, ht.message && (Z = ht.message), fe = b, Gt = ds(), b && j && bt(j, Z), b && I && xt(I, Z), b = fe, m.markEnd(m.createFunctionExpression(v, Ot, [], Gt), ce);
        }
        function Jr() {
          if (w.type === o.Keyword)
            switch (w.value) {
              case "const":
              case "let":
                return Bt(w.value);
              case "function":
                return Va();
              default:
                return Qe();
            }
          if (w.type !== o.EOF)
            return Qe();
        }
        function Cd() {
          for (var d, v = [], I, j, Z; f < x && (I = w, !(I.type !== o.StringLiteral || (d = Jr(), v.push(d), d.expression.type !== c.Literal))); )
            j = g.slice(I.start + 1, I.end - 1), j === "use strict" ? (b = !0, Z && xt(Z, u.StrictOctalLiteral)) : !Z && I.octal && (Z = I);
          for (; f < x && (d = Jr(), !(typeof d > "u")); )
            v.push(d);
          return v;
        }
        function Id() {
          var d, v;
          return L(), le(), v = w, b = !1, d = Cd(), m.markEnd(m.createProgram(d), v);
        }
        function Ua() {
          var d, v, I, j = [];
          for (d = 0; d < S.tokens.length; ++d)
            v = S.tokens[d], I = {
              type: v.type,
              value: v.value
            }, S.range && (I.range = v.range), S.loc && (I.loc = v.loc), j.push(I);
          S.tokens = j;
        }
        function Pd(d, v) {
          var I, j, Z;
          I = String, typeof d != "string" && !(d instanceof String) && (d = I(d)), m = y, g = d, f = 0, E = g.length > 0 ? 1 : 0, A = 0, x = g.length, w = null, _ = {
            allowIn: !0,
            labelSet: {},
            inFunctionBody: !1,
            inIteration: !1,
            inSwitch: !1,
            lastCommentStart: -1
          }, S = {}, v = v || {}, v.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof v.range == "boolean" && v.range, S.loc = typeof v.loc == "boolean" && v.loc, typeof v.comment == "boolean" && v.comment && (S.comments = []), typeof v.tolerant == "boolean" && v.tolerant && (S.errors = []);
          try {
            if (le(), w.type === o.EOF)
              return S.tokens;
            for (j = wt(); w.type !== o.EOF; )
              try {
                j = wt();
              } catch (ht) {
                if (j = w, S.errors) {
                  S.errors.push(ht);
                  break;
                } else
                  throw ht;
              }
            Ua(), Z = S.tokens, typeof S.comments < "u" && (Z.comments = S.comments), typeof S.errors < "u" && (Z.errors = S.errors);
          } catch (ht) {
            throw ht;
          } finally {
            S = {};
          }
          return Z;
        }
        function Rd(d, v) {
          var I, j;
          j = String, typeof d != "string" && !(d instanceof String) && (d = j(d)), m = y, g = d, f = 0, E = g.length > 0 ? 1 : 0, A = 0, x = g.length, w = null, _ = {
            allowIn: !0,
            labelSet: {},
            inFunctionBody: !1,
            inIteration: !1,
            inSwitch: !1,
            lastCommentStart: -1
          }, S = {}, typeof v < "u" && (S.range = typeof v.range == "boolean" && v.range, S.loc = typeof v.loc == "boolean" && v.loc, S.attachComment = typeof v.attachComment == "boolean" && v.attachComment, S.loc && v.source !== null && v.source !== void 0 && (S.source = j(v.source)), typeof v.tokens == "boolean" && v.tokens && (S.tokens = []), typeof v.comment == "boolean" && v.comment && (S.comments = []), typeof v.tolerant == "boolean" && v.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
          try {
            I = Id(), typeof S.comments < "u" && (I.comments = S.comments), typeof S.tokens < "u" && (Ua(), I.tokens = S.tokens), typeof S.errors < "u" && (I.errors = S.errors);
          } catch (Z) {
            throw Z;
          } finally {
            S = {};
          }
          return I;
        }
        s.version = "1.2.2", s.tokenize = Pd, s.parse = Rd, s.Syntax = function() {
          var d, v = {};
          typeof Object.create == "function" && (v = /* @__PURE__ */ Object.create(null));
          for (d in c)
            c.hasOwnProperty(d) && (v[d] = c[d]);
          return typeof Object.freeze == "function" && Object.freeze(v), v;
        }();
      });
    }, {}], 1: [function(r, n, i) {
      (function(s) {
        var o = function() {
          var a = {
            trace: function() {
            },
            yy: {},
            symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
            terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
            productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
            performAction: function(u, p, y, g, b, f, E) {
              g.ast || (g.ast = l, l.initialize());
              var A = f.length - 1;
              switch (b) {
                case 1:
                  return g.ast.set({ expression: { type: "root", value: f[A] } }), g.ast.unshift(), g.ast.yield();
                case 2:
                  return g.ast.set({ expression: { type: "root", value: f[A - 1] } }), g.ast.unshift(), g.ast.yield();
                case 3:
                  return g.ast.unshift(), g.ast.yield();
                case 4:
                  return g.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), g.ast.unshift(), g.ast.yield();
                case 5:
                  break;
                case 6:
                  break;
                case 7:
                  g.ast.set({ operation: "member" }), g.ast.push();
                  break;
                case 8:
                  g.ast.set({ operation: "subscript" }), g.ast.push();
                  break;
                case 9:
                  g.ast.set({ scope: "child" });
                  break;
                case 10:
                  g.ast.set({ scope: "descendant" });
                  break;
                case 11:
                  break;
                case 12:
                  g.ast.set({ scope: "child", operation: "member" });
                  break;
                case 13:
                  break;
                case 14:
                  g.ast.set({ expression: { type: "wildcard", value: f[A] } });
                  break;
                case 15:
                  g.ast.set({ expression: { type: "identifier", value: f[A] } });
                  break;
                case 16:
                  g.ast.set({ expression: { type: "script_expression", value: f[A] } });
                  break;
                case 17:
                  g.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                  break;
                case 18:
                  break;
                case 19:
                  g.ast.set({ scope: "child" });
                  break;
                case 20:
                  g.ast.set({ scope: "descendant" });
                  break;
                case 21:
                  break;
                case 22:
                  break;
                case 23:
                  break;
                case 24:
                  f[A].length > 1 ? g.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                  break;
                case 25:
                  this.$ = [f[A]];
                  break;
                case 26:
                  this.$ = f[A - 2].concat(f[A]);
                  break;
                case 27:
                  this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, g.ast.set(this.$);
                  break;
                case 28:
                  this.$ = { expression: { type: "string_literal", value: f[A] } }, g.ast.set(this.$);
                  break;
                case 29:
                  this.$ = { expression: { type: "slice", value: f[A] } }, g.ast.set(this.$);
                  break;
                case 30:
                  this.$ = { expression: { type: "wildcard", value: f[A] } }, g.ast.set(this.$);
                  break;
                case 31:
                  this.$ = { expression: { type: "script_expression", value: f[A] } }, g.ast.set(this.$);
                  break;
                case 32:
                  this.$ = { expression: { type: "filter_expression", value: f[A] } }, g.ast.set(this.$);
                  break;
                case 33:
                  this.$ = f[A];
                  break;
                case 34:
                  this.$ = f[A];
                  break;
              }
            },
            table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
            defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
            parseError: function(u, p) {
              if (p.recoverable)
                this.trace(u);
              else
                throw new Error(u);
            },
            parse: function(u) {
              var p = this, y = [0], g = [null], b = [], f = this.table, E = "", A = 0, x = 0, m = 2, w = 1, _ = b.slice.call(arguments, 1);
              this.lexer.setInput(u), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
              var S = this.lexer.yylloc;
              b.push(S);
              var R = this.lexer.options && this.lexer.options.ranges;
              typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
              function O() {
                var It;
                return It = p.lexer.lex() || w, typeof It != "number" && (It = p.symbols_[It] || It), It;
              }
              for (var $, z, F, Y, rt = {}, at, pt, vt, _t; ; ) {
                if (z = y[y.length - 1], this.defaultActions[z] ? F = this.defaultActions[z] : (($ === null || typeof $ > "u") && ($ = O()), F = f[z] && f[z][$]), typeof F > "u" || !F.length || !F[0]) {
                  var Ct = "";
                  _t = [];
                  for (at in f[z])
                    this.terminals_[at] && at > m && _t.push("'" + this.terminals_[at] + "'");
                  this.lexer.showPosition ? Ct = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + _t.join(", ") + ", got '" + (this.terminals_[$] || $) + "'" : Ct = "Parse error on line " + (A + 1) + ": Unexpected " + ($ == w ? "end of input" : "'" + (this.terminals_[$] || $) + "'"), this.parseError(Ct, {
                    text: this.lexer.match,
                    token: this.terminals_[$] || $,
                    line: this.lexer.yylineno,
                    loc: S,
                    expected: _t
                  });
                }
                if (F[0] instanceof Array && F.length > 1)
                  throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + $);
                switch (F[0]) {
                  case 1:
                    y.push($), g.push(this.lexer.yytext), b.push(this.lexer.yylloc), y.push(F[1]), $ = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                    break;
                  case 2:
                    if (pt = this.productions_[F[1]][1], rt.$ = g[g.length - pt], rt._$ = {
                      first_line: b[b.length - (pt || 1)].first_line,
                      last_line: b[b.length - 1].last_line,
                      first_column: b[b.length - (pt || 1)].first_column,
                      last_column: b[b.length - 1].last_column
                    }, R && (rt._$.range = [
                      b[b.length - (pt || 1)].range[0],
                      b[b.length - 1].range[1]
                    ]), Y = this.performAction.apply(rt, [
                      E,
                      x,
                      A,
                      this.yy,
                      F[1],
                      g,
                      b
                    ].concat(_)), typeof Y < "u")
                      return Y;
                    pt && (y = y.slice(0, -1 * pt * 2), g = g.slice(0, -1 * pt), b = b.slice(0, -1 * pt)), y.push(this.productions_[F[1]][0]), g.push(rt.$), b.push(rt._$), vt = f[y[y.length - 2]][y[y.length - 1]], y.push(vt);
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }
          }, l = {
            initialize: function() {
              this._nodes = [], this._node = {}, this._stash = [];
            },
            set: function(u) {
              for (var p in u) this._node[p] = u[p];
              return this._node;
            },
            node: function(u) {
              return arguments.length && (this._node = u), this._node;
            },
            push: function() {
              this._nodes.push(this._node), this._node = {};
            },
            unshift: function() {
              this._nodes.unshift(this._node), this._node = {};
            },
            yield: function() {
              var u = this._nodes;
              return this.initialize(), u;
            }
          }, c = /* @__PURE__ */ function() {
            var u = {
              EOF: 1,
              parseError: function(p, y) {
                if (this.yy.parser)
                  this.yy.parser.parseError(p, y);
                else
                  throw new Error(p);
              },
              // resets the lexer, sets new input
              setInput: function(p) {
                return this._input = p, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                  first_line: 1,
                  first_column: 0,
                  last_line: 1,
                  last_column: 0
                }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
              },
              // consumes and returns one char from the input
              input: function() {
                var p = this._input[0];
                this.yytext += p, this.yyleng++, this.offset++, this.match += p, this.matched += p;
                var y = p.match(/(?:\r\n?|\n).*/g);
                return y ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), p;
              },
              // unshifts one char (or a string) into the input
              unput: function(p) {
                var y = p.length, g = p.split(/(?:\r\n?|\n)/g);
                this._input = p + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - y - 1), this.offset -= y;
                var b = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), g.length - 1 && (this.yylineno -= g.length - 1);
                var f = this.yylloc.range;
                return this.yylloc = {
                  first_line: this.yylloc.first_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.first_column,
                  last_column: g ? (g.length === b.length ? this.yylloc.first_column : 0) + b[b.length - g.length].length - g[0].length : this.yylloc.first_column - y
                }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - y]), this.yyleng = this.yytext.length, this;
              },
              // When called from action, caches matched text and appends it on next action
              more: function() {
                return this._more = !0, this;
              },
              // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
              reject: function() {
                if (this.options.backtrack_lexer)
                  this._backtrack = !0;
                else
                  return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                return this;
              },
              // retain first n characters of the match
              less: function(p) {
                this.unput(this.match.slice(p));
              },
              // displays already matched input, i.e. for error messages
              pastInput: function() {
                var p = this.matched.substr(0, this.matched.length - this.match.length);
                return (p.length > 20 ? "..." : "") + p.substr(-20).replace(/\n/g, "");
              },
              // displays upcoming input, i.e. for error messages
              upcomingInput: function() {
                var p = this.match;
                return p.length < 20 && (p += this._input.substr(0, 20 - p.length)), (p.substr(0, 20) + (p.length > 20 ? "..." : "")).replace(/\n/g, "");
              },
              // displays the character position where the lexing error occurred, i.e. for error messages
              showPosition: function() {
                var p = this.pastInput(), y = new Array(p.length + 1).join("-");
                return p + this.upcomingInput() + `
` + y + "^";
              },
              // test the lexed token: return FALSE when not a match, otherwise return token
              test_match: function(p, y) {
                var g, b, f;
                if (this.options.backtrack_lexer && (f = {
                  yylineno: this.yylineno,
                  yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
                }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), b = p[0].match(/(?:\r\n?|\n).*/g), b && (this.yylineno += b.length), this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: b ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + p[0].length
                }, this.yytext += p[0], this.match += p[0], this.matches = p, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(p[0].length), this.matched += p[0], g = this.performAction.call(this, this.yy, this, y, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), g)
                  return g;
                if (this._backtrack) {
                  for (var E in f)
                    this[E] = f[E];
                  return !1;
                }
                return !1;
              },
              // return next match in input
              next: function() {
                if (this.done)
                  return this.EOF;
                this._input || (this.done = !0);
                var p, y, g, b;
                this._more || (this.yytext = "", this.match = "");
                for (var f = this._currentRules(), E = 0; E < f.length; E++)
                  if (g = this._input.match(this.rules[f[E]]), g && (!y || g[0].length > y[0].length)) {
                    if (y = g, b = E, this.options.backtrack_lexer) {
                      if (p = this.test_match(g, f[E]), p !== !1)
                        return p;
                      if (this._backtrack) {
                        y = !1;
                        continue;
                      } else
                        return !1;
                    } else if (!this.options.flex)
                      break;
                  }
                return y ? (p = this.test_match(y, f[b]), p !== !1 ? p : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              },
              // return next match that has a token
              lex: function() {
                var p = this.next();
                return p || this.lex();
              },
              // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
              begin: function(p) {
                this.conditionStack.push(p);
              },
              // pop the previously active lexer condition state off the condition stack
              popState: function() {
                var p = this.conditionStack.length - 1;
                return p > 0 ? this.conditionStack.pop() : this.conditionStack[0];
              },
              // produce the lexer rule set which is active for the currently active lexer condition state
              _currentRules: function() {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
              },
              // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
              topState: function(p) {
                return p = this.conditionStack.length - 1 - Math.abs(p || 0), p >= 0 ? this.conditionStack[p] : "INITIAL";
              },
              // alias for begin(condition)
              pushState: function(p) {
                this.begin(p);
              },
              // return the number of states currently on the stack
              stateStackSize: function() {
                return this.conditionStack.length;
              },
              options: {},
              performAction: function(p, y, g, b) {
                switch (g) {
                  case 0:
                    return 4;
                  case 1:
                    return 14;
                  case 2:
                    return 12;
                  case 3:
                    return 15;
                  case 4:
                    return 16;
                  case 5:
                    return 22;
                  case 6:
                    return 24;
                  case 7:
                    return 28;
                  case 8:
                    return 30;
                  case 9:
                    return 18;
                  case 10:
                    return y.yytext = y.yytext.substr(1, y.yyleng - 2), 32;
                  case 11:
                    return y.yytext = y.yytext.substr(1, y.yyleng - 2), 33;
                  case 12:
                    return 17;
                  case 13:
                    return 31;
                }
              },
              rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
              conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
            };
            return u;
          }();
          a.lexer = c;
          function h() {
            this.yy = {};
          }
          return h.prototype = a, a.Parser = h, new h();
        }();
        typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
          return o.parse.apply(o, arguments);
        }, i.main = function(a) {
          a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
          var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
          return i.parser.parse(l);
        }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
      }).call(this, r("_process"));
    }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
      n.exports = {
        identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
        integer: "-?(?:0|[1-9][0-9]*)",
        qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
        q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
      };
    }, {}], 3: [function(r, n, i) {
      var s = r("./dict"), o = r("fs"), a = {
        lex: {
          macros: {
            esc: "\\\\",
            int: s.integer
          },
          rules: [
            ["\\$", "return 'DOLLAR'"],
            ["\\.\\.", "return 'DOT_DOT'"],
            ["\\.", "return 'DOT'"],
            ["\\*", "return 'STAR'"],
            [s.identifier, "return 'IDENTIFIER'"],
            ["\\[", "return '['"],
            ["\\]", "return ']'"],
            [",", "return ','"],
            ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
            ["{int}", "return 'INTEGER'"],
            [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
            [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
            ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
            ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
          ]
        },
        start: "JSON_PATH",
        bnf: {
          JSON_PATH: [
            ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
            ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
            ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
            ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
          ],
          PATH_COMPONENTS: [
            ["PATH_COMPONENT", ""],
            ["PATH_COMPONENTS PATH_COMPONENT", ""]
          ],
          PATH_COMPONENT: [
            ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
            ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
          ],
          MEMBER_COMPONENT: [
            ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
            ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
          ],
          CHILD_MEMBER_COMPONENT: [
            ["DOT MEMBER_EXPRESSION", ""]
          ],
          LEADING_CHILD_MEMBER_EXPRESSION: [
            ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
          ],
          DESCENDANT_MEMBER_COMPONENT: [
            ["DOT_DOT MEMBER_EXPRESSION", ""]
          ],
          MEMBER_EXPRESSION: [
            ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
            ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
            ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
            ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
            ["END", ""]
          ],
          SUBSCRIPT_COMPONENT: [
            ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
            ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
          ],
          CHILD_SUBSCRIPT_COMPONENT: [
            ["[ SUBSCRIPT ]", ""]
          ],
          DESCENDANT_SUBSCRIPT_COMPONENT: [
            ["DOT_DOT [ SUBSCRIPT ]", ""]
          ],
          SUBSCRIPT: [
            ["SUBSCRIPT_EXPRESSION", ""],
            ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
          ],
          SUBSCRIPT_EXPRESSION_LIST: [
            ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
            ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
          ],
          SUBSCRIPT_EXPRESSION_LISTABLE: [
            ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
            ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
            ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
          ],
          SUBSCRIPT_EXPRESSION: [
            ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
            ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
            ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
          ],
          STRING_LITERAL: [
            ["QQ_STRING", "$$ = $1"],
            ["Q_STRING", "$$ = $1"]
          ]
        }
      };
      o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
    }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
      var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
        return this.initialize.apply(this, arguments);
      };
      c.prototype.initialize = function() {
        this.traverse = y(!0), this.descend = y();
      }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
        var m = [x.operation, x.scope, x.expression.type].join("-"), w = this._fns[m];
        if (!w) throw new Error("couldn't resolve key: " + m);
        return w.bind(this);
      }, c.prototype.register = function(x, m) {
        if (!m instanceof Function)
          throw new Error("handler must be a function");
        this._fns[x] = m;
      }, c.prototype._fns = {
        "member-child-identifier": function(x, m) {
          var w = x.expression.value, _ = m.value;
          if (_ instanceof Object && w in _)
            return [{ value: _[w], path: m.path.concat(w) }];
        },
        "member-descendant-identifier": b(function(x, m, w) {
          return x == w;
        }),
        "subscript-child-numeric_literal": g(function(x, m, w) {
          return x === w;
        }),
        "member-child-numeric_literal": g(function(x, m, w) {
          return String(x) === String(w);
        }),
        "subscript-descendant-numeric_literal": b(function(x, m, w) {
          return x === w;
        }),
        "member-child-wildcard": g(function() {
          return !0;
        }),
        "member-descendant-wildcard": b(function() {
          return !0;
        }),
        "subscript-descendant-wildcard": b(function() {
          return !0;
        }),
        "subscript-child-wildcard": g(function() {
          return !0;
        }),
        "subscript-child-slice": function(x, m) {
          if (u(m.value)) {
            var w = x.expression.value.split(":").map(A), _ = m.value.map(function(S, R) {
              return { value: S, path: m.path.concat(R) };
            });
            return o.apply(null, [_].concat(w));
          }
        },
        "subscript-child-union": function(x, m) {
          var w = [];
          return x.expression.value.forEach(function(_) {
            var S = { operation: "subscript", scope: "child", expression: _.expression }, R = this.resolve(S), O = R(S, m);
            O && (w = w.concat(O));
          }, this), E(w);
        },
        "subscript-descendant-union": function(x, m, w) {
          var _ = r(".."), S = this, R = [], O = _.nodes(m, "$..*").slice(1);
          return O.forEach(function($) {
            R.length >= w || x.expression.value.forEach(function(z) {
              var F = { operation: "subscript", scope: "child", expression: z.expression }, Y = S.resolve(F), rt = Y(F, $);
              R = R.concat(rt);
            });
          }), E(R);
        },
        "subscript-child-filter_expression": function(x, m, w) {
          var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(O, $) {
            return f(S, { "@": $ });
          };
          return this.descend(m, null, R, w);
        },
        "subscript-descendant-filter_expression": function(x, m, w) {
          var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(O, $) {
            return f(S, { "@": $ });
          };
          return this.traverse(m, null, R, w);
        },
        "subscript-child-script_expression": function(x, m) {
          var w = x.expression.value.slice(1, -1);
          return h(m, w, "$[{{value}}]");
        },
        "member-child-script_expression": function(x, m) {
          var w = x.expression.value.slice(1, -1);
          return h(m, w, "$.{{value}}");
        },
        "member-descendant-script_expression": function(x, m) {
          var w = x.expression.value.slice(1, -1);
          return h(m, w, "$..value");
        }
      }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
      function h(x, m, w) {
        var _ = r("./index"), S = s.parse(m).body[0].expression, R = f(S, { "@": x.value }), O = w.replace(/\{\{\s*value\s*\}\}/g, R), $ = _.nodes(x.value, O);
        return $.forEach(function(z) {
          z.path = x.path.concat(z.path.slice(1));
        }), $;
      }
      function u(x) {
        return Array.isArray(x);
      }
      function p(x) {
        return x && !(x instanceof Array) && x instanceof Object;
      }
      function y(x) {
        return function(m, w, _, S) {
          var R = m.value, O = m.path, $ = [], z = (function(F, Y) {
            u(F) ? (F.forEach(function(rt, at) {
              $.length >= S || _(at, rt, w) && $.push({ path: Y.concat(at), value: rt });
            }), F.forEach(function(rt, at) {
              $.length >= S || x && z(rt, Y.concat(at));
            })) : p(F) && (this.keys(F).forEach(function(rt) {
              $.length >= S || _(rt, F[rt], w) && $.push({ path: Y.concat(rt), value: F[rt] });
            }), this.keys(F).forEach(function(rt) {
              $.length >= S || x && z(F[rt], Y.concat(rt));
            }));
          }).bind(this);
          return z(R, O), $;
        };
      }
      function g(x) {
        return function(m, w, _) {
          return this.descend(w, m.expression.value, x, _);
        };
      }
      function b(x) {
        return function(m, w, _) {
          return this.traverse(w, m.expression.value, x, _);
        };
      }
      function f() {
        try {
          return a.apply(this, arguments);
        } catch {
        }
      }
      function E(x) {
        return x = x.filter(function(m) {
          return m;
        }), l(
          x,
          function(m) {
            return m.path.map(function(w) {
              return String(w).replace("-", "--");
            }).join("-");
          }
        );
      }
      function A(x) {
        var m = String(x);
        return m.match(/^-?[0-9]+$/) ? parseInt(m) : null;
      }
      n.exports = c;
    }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
      var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
        this.initialize.apply(this, arguments);
      };
      c.prototype.initialize = function() {
        this.parser = new a(), this.handlers = new l();
      }, c.prototype.parse = function(p) {
        return s.ok(h(p), "we need a path"), this.parser.parse(p);
      }, c.prototype.parent = function(p, y) {
        s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path");
        var g = this.nodes(p, y)[0];
        return g.path.pop(), this.value(p, g.path);
      }, c.prototype.apply = function(p, y, g) {
        s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path"), s.equal(typeof g, "function", "fn needs to be function");
        var b = this.nodes(p, y).sort(function(f, E) {
          return E.path.length - f.path.length;
        });
        return b.forEach(function(f) {
          var E = f.path.pop(), A = this.value(p, this.stringify(f.path)), x = f.value = g.call(p, A[E]);
          A[E] = x;
        }, this), b;
      }, c.prototype.value = function(p, y, g) {
        if (s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path"), arguments.length >= 3) {
          var b = this.nodes(p, y).shift();
          if (!b) return this._vivify(p, y, g);
          var f = b.path.slice(-1).shift(), E = this.parent(p, this.stringify(b.path));
          E[f] = g;
        }
        return this.query(p, this.stringify(y), 1).shift();
      }, c.prototype._vivify = function(p, y, g) {
        var b = this;
        s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path");
        var f = this.parser.parse(y).map(function(A) {
          return A.expression.value;
        }), E = function(A, x) {
          var m = A.pop(), w = b.value(p, A);
          w || (E(A.concat(), typeof m == "string" ? {} : []), w = b.value(p, A)), w[m] = x;
        };
        return E(f, g), this.query(p, y)[0];
      }, c.prototype.query = function(p, y, g) {
        s.ok(p instanceof Object, "obj needs to be an object"), s.ok(h(y), "we need a path");
        var b = this.nodes(p, y, g).map(function(f) {
          return f.value;
        });
        return b;
      }, c.prototype.paths = function(p, y, g) {
        s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path");
        var b = this.nodes(p, y, g).map(function(f) {
          return f.path;
        });
        return b;
      }, c.prototype.nodes = function(p, y, g) {
        if (s.ok(p instanceof Object, "obj needs to be an object"), s.ok(y, "we need a path"), g === 0) return [];
        var b = this.parser.parse(y), f = this.handlers, E = [{ path: ["$"], value: p }], A = [];
        return b.length && b[0].expression.type == "root" && b.shift(), b.length ? (b.forEach(function(x, m) {
          if (!(A.length >= g)) {
            var w = f.resolve(x), _ = [];
            E.forEach(function(S) {
              if (!(A.length >= g)) {
                var R = w(x, S, g);
                m == b.length - 1 ? A = A.concat(R || []) : _ = _.concat(R || []);
              }
            }), E = _;
          }
        }), g ? A.slice(0, g) : A) : E;
      }, c.prototype.stringify = function(p) {
        s.ok(p, "we need a path");
        var y = "$", g = {
          "descendant-member": "..{{value}}",
          "child-member": ".{{value}}",
          "descendant-subscript": "..[{{value}}]",
          "child-subscript": "[{{value}}]"
        };
        return p = this._normalize(p), p.forEach(function(b) {
          if (b.expression.type != "root") {
            var f = [b.scope, b.operation].join("-"), E = g[f], A;
            if (b.expression.type == "string_literal" ? A = JSON.stringify(b.expression.value) : A = b.expression.value, !E) throw new Error("couldn't find template " + f);
            y += E.replace(/{{value}}/, A);
          }
        }), y;
      }, c.prototype._normalize = function(p) {
        if (s.ok(p, "we need a path"), typeof p == "string")
          return this.parser.parse(p);
        if (Array.isArray(p) && typeof p[0] == "string") {
          var y = [{ expression: { type: "root", value: "$" } }];
          return p.forEach(function(g, b) {
            if (!(g == "$" && b === 0))
              if (typeof g == "string" && g.match("^" + o.identifier + "$"))
                y.push({
                  operation: "member",
                  scope: "child",
                  expression: { value: g, type: "identifier" }
                });
              else {
                var f = typeof g == "number" ? "numeric_literal" : "string_literal";
                y.push({
                  operation: "subscript",
                  scope: "child",
                  expression: { value: g, type: f }
                });
              }
          }), y;
        } else if (Array.isArray(p) && typeof p[0] == "object")
          return p;
        throw new Error("couldn't understand path " + p);
      };
      function h(p) {
        return Object.prototype.toString.call(p) == "[object String]";
      }
      c.Handlers = l, c.Parser = a;
      var u = new c();
      u.JSONPath = c, n.exports = u;
    }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
      var s = r("./grammar"), o = r("../generated/parser"), a = function() {
        var l = new o.Parser(), c = l.parseError;
        return l.yy.parseError = function() {
          l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
        }, l;
      };
      a.grammar = s, n.exports = a;
    }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
      n.exports = function(o, a, l, c) {
        if (typeof a == "string") throw new Error("start cannot be a string");
        if (typeof l == "string") throw new Error("end cannot be a string");
        if (typeof c == "string") throw new Error("step cannot be a string");
        var h = o.length;
        if (c === 0) throw new Error("step cannot be zero");
        if (c = c ? s(c) : 1, a = a < 0 ? h + a : a, l = l < 0 ? h + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : h - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? h : -1)), a = c > 0 ? Math.max(0, a) : Math.min(h, a), l = c > 0 ? Math.min(l, h) : Math.max(-1, l), c > 0 && l <= a) return [];
        if (c < 0 && a <= l) return [];
        for (var u = [], p = a; p != l && !(c < 0 && p <= l || c > 0 && p >= l); p += c)
          u.push(o[p]);
        return u;
      };
      function s(o) {
        return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
      }
    }, {}], 8: [function(r, n, i) {
      var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = y;
      l.AssertionError = function(m) {
        this.name = "AssertionError", this.actual = m.actual, this.expected = m.expected, this.operator = m.operator, m.message ? (this.message = m.message, this.generatedMessage = !1) : (this.message = u(this), this.generatedMessage = !0);
        var w = m.stackStartFunction || p;
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, w);
        else {
          var _ = new Error();
          if (_.stack) {
            var S = _.stack, R = w.name, O = S.indexOf(`
` + R);
            if (O >= 0) {
              var $ = S.indexOf(`
`, O + 1);
              S = S.substring($ + 1);
            }
            this.stack = S;
          }
        }
      }, s.inherits(l.AssertionError, Error);
      function c(m, w) {
        return s.isUndefined(w) ? "" + w : s.isNumber(w) && !isFinite(w) || s.isFunction(w) || s.isRegExp(w) ? w.toString() : w;
      }
      function h(m, w) {
        return s.isString(m) ? m.length < w ? m : m.slice(0, w) : m;
      }
      function u(m) {
        return h(JSON.stringify(m.actual, c), 128) + " " + m.operator + " " + h(JSON.stringify(m.expected, c), 128);
      }
      function p(m, w, _, S, R) {
        throw new l.AssertionError({
          message: _,
          actual: m,
          expected: w,
          operator: S,
          stackStartFunction: R
        });
      }
      l.fail = p;
      function y(m, w) {
        m || p(m, !0, w, "==", l.ok);
      }
      l.ok = y, l.equal = function(m, w, _) {
        m != w && p(m, w, _, "==", l.equal);
      }, l.notEqual = function(m, w, _) {
        m == w && p(m, w, _, "!=", l.notEqual);
      }, l.deepEqual = function(m, w, _) {
        g(m, w) || p(m, w, _, "deepEqual", l.deepEqual);
      };
      function g(m, w) {
        if (m === w)
          return !0;
        if (s.isBuffer(m) && s.isBuffer(w)) {
          if (m.length != w.length) return !1;
          for (var _ = 0; _ < m.length; _++)
            if (m[_] !== w[_]) return !1;
          return !0;
        } else return s.isDate(m) && s.isDate(w) ? m.getTime() === w.getTime() : s.isRegExp(m) && s.isRegExp(w) ? m.source === w.source && m.global === w.global && m.multiline === w.multiline && m.lastIndex === w.lastIndex && m.ignoreCase === w.ignoreCase : !s.isObject(m) && !s.isObject(w) ? m == w : f(m, w);
      }
      function b(m) {
        return Object.prototype.toString.call(m) == "[object Arguments]";
      }
      function f(m, w) {
        if (s.isNullOrUndefined(m) || s.isNullOrUndefined(w) || m.prototype !== w.prototype) return !1;
        if (s.isPrimitive(m) || s.isPrimitive(w))
          return m === w;
        var _ = b(m), S = b(w);
        if (_ && !S || !_ && S)
          return !1;
        if (_)
          return m = o.call(m), w = o.call(w), g(m, w);
        var R = x(m), O = x(w), $, z;
        if (R.length != O.length)
          return !1;
        for (R.sort(), O.sort(), z = R.length - 1; z >= 0; z--)
          if (R[z] != O[z])
            return !1;
        for (z = R.length - 1; z >= 0; z--)
          if ($ = R[z], !g(m[$], w[$])) return !1;
        return !0;
      }
      l.notDeepEqual = function(m, w, _) {
        g(m, w) && p(m, w, _, "notDeepEqual", l.notDeepEqual);
      }, l.strictEqual = function(m, w, _) {
        m !== w && p(m, w, _, "===", l.strictEqual);
      }, l.notStrictEqual = function(m, w, _) {
        m === w && p(m, w, _, "!==", l.notStrictEqual);
      };
      function E(m, w) {
        return !m || !w ? !1 : Object.prototype.toString.call(w) == "[object RegExp]" ? w.test(m) : m instanceof w ? !0 : w.call({}, m) === !0;
      }
      function A(m, w, _, S) {
        var R;
        s.isString(_) && (S = _, _ = null);
        try {
          w();
        } catch (O) {
          R = O;
        }
        if (S = (_ && _.name ? " (" + _.name + ")." : ".") + (S ? " " + S : "."), m && !R && p(R, _, "Missing expected exception" + S), !m && E(R, _) && p(R, _, "Got unwanted exception" + S), m && R && _ && !E(R, _) || !m && R)
          throw R;
      }
      l.throws = function(m, w, _) {
        A.apply(this, [!0].concat(o.call(arguments)));
      }, l.doesNotThrow = function(m, w) {
        A.apply(this, [!1].concat(o.call(arguments)));
      }, l.ifError = function(m) {
        if (m)
          throw m;
      };
      var x = Object.keys || function(m) {
        var w = [];
        for (var _ in m)
          a.call(m, _) && w.push(_);
        return w;
      };
    }, { "util/": 11 }], 9: [function(r, n, i) {
      typeof Object.create == "function" ? n.exports = function(s, o) {
        s.super_ = o, s.prototype = Object.create(o.prototype, {
          constructor: {
            value: s,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
      } : n.exports = function(s, o) {
        s.super_ = o;
        var a = function() {
        };
        a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
      };
    }, {}], 10: [function(r, n, i) {
      n.exports = function(s) {
        return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
      };
    }, {}], 11: [function(r, n, i) {
      (function(s, o) {
        var a = /%[sdj%]/g;
        i.format = function(L) {
          if (!O(L)) {
            for (var D = [], tt = 0; tt < arguments.length; tt++)
              D.push(h(arguments[tt]));
            return D.join(" ");
          }
          for (var tt = 1, et = arguments, st = et.length, X = String(L).replace(a, function(U) {
            if (U === "%%") return "%";
            if (tt >= st) return U;
            switch (U) {
              case "%s":
                return String(et[tt++]);
              case "%d":
                return Number(et[tt++]);
              case "%j":
                try {
                  return JSON.stringify(et[tt++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return U;
            }
          }), ot = et[tt]; tt < st; ot = et[++tt])
            _(ot) || !Y(ot) ? X += " " + ot : X += " " + h(ot);
          return X;
        }, i.deprecate = function(L, D) {
          if (z(o.process))
            return function() {
              return i.deprecate(L, D).apply(this, arguments);
            };
          if (s.noDeprecation === !0)
            return L;
          var tt = !1;
          function et() {
            if (!tt) {
              if (s.throwDeprecation)
                throw new Error(D);
              s.traceDeprecation ? console.trace(D) : console.error(D), tt = !0;
            }
            return L.apply(this, arguments);
          }
          return et;
        };
        var l = {}, c;
        i.debuglog = function(L) {
          if (z(c) && (c = s.env.NODE_DEBUG || ""), L = L.toUpperCase(), !l[L])
            if (new RegExp("\\b" + L + "\\b", "i").test(c)) {
              var D = s.pid;
              l[L] = function() {
                var tt = i.format.apply(i, arguments);
                console.error("%s %d: %s", L, D, tt);
              };
            } else
              l[L] = function() {
              };
          return l[L];
        };
        function h(L, D) {
          var tt = {
            seen: [],
            stylize: p
          };
          return arguments.length >= 3 && (tt.depth = arguments[2]), arguments.length >= 4 && (tt.colors = arguments[3]), w(D) ? tt.showHidden = D : D && i._extend(tt, D), z(tt.showHidden) && (tt.showHidden = !1), z(tt.depth) && (tt.depth = 2), z(tt.colors) && (tt.colors = !1), z(tt.customInspect) && (tt.customInspect = !0), tt.colors && (tt.stylize = u), g(tt, L, tt.depth);
        }
        i.inspect = h, h.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        }, h.styles = {
          special: "cyan",
          number: "yellow",
          boolean: "yellow",
          undefined: "grey",
          null: "bold",
          string: "green",
          date: "magenta",
          // "name": intentionally not styling
          regexp: "red"
        };
        function u(L, D) {
          var tt = h.styles[D];
          return tt ? "\x1B[" + h.colors[tt][0] + "m" + L + "\x1B[" + h.colors[tt][1] + "m" : L;
        }
        function p(L, D) {
          return L;
        }
        function y(L) {
          var D = {};
          return L.forEach(function(tt, et) {
            D[tt] = !0;
          }), D;
        }
        function g(L, D, tt) {
          if (L.customInspect && D && pt(D.inspect) && // Filter out the util module, it's inspect function is special
          D.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
          !(D.constructor && D.constructor.prototype === D)) {
            var et = D.inspect(tt, L);
            return O(et) || (et = g(L, et, tt)), et;
          }
          var st = b(L, D);
          if (st)
            return st;
          var X = Object.keys(D), ot = y(X);
          if (L.showHidden && (X = Object.getOwnPropertyNames(D)), at(D) && (X.indexOf("message") >= 0 || X.indexOf("description") >= 0))
            return f(D);
          if (X.length === 0) {
            if (pt(D)) {
              var mt = D.name ? ": " + D.name : "";
              return L.stylize("[Function" + mt + "]", "special");
            }
            if (F(D))
              return L.stylize(RegExp.prototype.toString.call(D), "regexp");
            if (rt(D))
              return L.stylize(Date.prototype.toString.call(D), "date");
            if (at(D))
              return f(D);
          }
          var U = "", J = !1, St = ["{", "}"];
          if (m(D) && (J = !0, St = ["[", "]"]), pt(D)) {
            var Rt = D.name ? ": " + D.name : "";
            U = " [Function" + Rt + "]";
          }
          if (F(D) && (U = " " + RegExp.prototype.toString.call(D)), rt(D) && (U = " " + Date.prototype.toUTCString.call(D)), at(D) && (U = " " + f(D)), X.length === 0 && (!J || D.length == 0))
            return St[0] + U + St[1];
          if (tt < 0)
            return F(D) ? L.stylize(RegExp.prototype.toString.call(D), "regexp") : L.stylize("[Object]", "special");
          L.seen.push(D);
          var zt;
          return J ? zt = E(L, D, tt, ot, X) : zt = X.map(function(Tt) {
            return A(L, D, tt, ot, Tt, J);
          }), L.seen.pop(), x(zt, U, St);
        }
        function b(L, D) {
          if (z(D))
            return L.stylize("undefined", "undefined");
          if (O(D)) {
            var tt = "'" + JSON.stringify(D).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return L.stylize(tt, "string");
          }
          if (R(D))
            return L.stylize("" + D, "number");
          if (w(D))
            return L.stylize("" + D, "boolean");
          if (_(D))
            return L.stylize("null", "null");
        }
        function f(L) {
          return "[" + Error.prototype.toString.call(L) + "]";
        }
        function E(L, D, tt, et, st) {
          for (var X = [], ot = 0, mt = D.length; ot < mt; ++ot)
            lt(D, String(ot)) ? X.push(A(
              L,
              D,
              tt,
              et,
              String(ot),
              !0
            )) : X.push("");
          return st.forEach(function(U) {
            U.match(/^\d+$/) || X.push(A(
              L,
              D,
              tt,
              et,
              U,
              !0
            ));
          }), X;
        }
        function A(L, D, tt, et, st, X) {
          var ot, mt, U;
          if (U = Object.getOwnPropertyDescriptor(D, st) || { value: D[st] }, U.get ? U.set ? mt = L.stylize("[Getter/Setter]", "special") : mt = L.stylize("[Getter]", "special") : U.set && (mt = L.stylize("[Setter]", "special")), lt(et, st) || (ot = "[" + st + "]"), mt || (L.seen.indexOf(U.value) < 0 ? (_(tt) ? mt = g(L, U.value, null) : mt = g(L, U.value, tt - 1), mt.indexOf(`
`) > -1 && (X ? mt = mt.split(`
`).map(function(J) {
            return "  " + J;
          }).join(`
`).substr(2) : mt = `
` + mt.split(`
`).map(function(J) {
            return "   " + J;
          }).join(`
`))) : mt = L.stylize("[Circular]", "special")), z(ot)) {
            if (X && st.match(/^\d+$/))
              return mt;
            ot = JSON.stringify("" + st), ot.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ot = ot.substr(1, ot.length - 2), ot = L.stylize(ot, "name")) : (ot = ot.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ot = L.stylize(ot, "string"));
          }
          return ot + ": " + mt;
        }
        function x(L, D, tt) {
          var et = L.reduce(function(st, X) {
            return X.indexOf(`
`) >= 0, st + X.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return et > 60 ? tt[0] + (D === "" ? "" : D + `
 `) + " " + L.join(`,
  `) + " " + tt[1] : tt[0] + D + " " + L.join(", ") + " " + tt[1];
        }
        function m(L) {
          return Array.isArray(L);
        }
        i.isArray = m;
        function w(L) {
          return typeof L == "boolean";
        }
        i.isBoolean = w;
        function _(L) {
          return L === null;
        }
        i.isNull = _;
        function S(L) {
          return L == null;
        }
        i.isNullOrUndefined = S;
        function R(L) {
          return typeof L == "number";
        }
        i.isNumber = R;
        function O(L) {
          return typeof L == "string";
        }
        i.isString = O;
        function $(L) {
          return typeof L == "symbol";
        }
        i.isSymbol = $;
        function z(L) {
          return L === void 0;
        }
        i.isUndefined = z;
        function F(L) {
          return Y(L) && _t(L) === "[object RegExp]";
        }
        i.isRegExp = F;
        function Y(L) {
          return typeof L == "object" && L !== null;
        }
        i.isObject = Y;
        function rt(L) {
          return Y(L) && _t(L) === "[object Date]";
        }
        i.isDate = rt;
        function at(L) {
          return Y(L) && (_t(L) === "[object Error]" || L instanceof Error);
        }
        i.isError = at;
        function pt(L) {
          return typeof L == "function";
        }
        i.isFunction = pt;
        function vt(L) {
          return L === null || typeof L == "boolean" || typeof L == "number" || typeof L == "string" || typeof L == "symbol" || // ES6 symbol
          typeof L > "u";
        }
        i.isPrimitive = vt, i.isBuffer = r("./support/isBuffer");
        function _t(L) {
          return Object.prototype.toString.call(L);
        }
        function Ct(L) {
          return L < 10 ? "0" + L.toString(10) : L.toString(10);
        }
        var It = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ];
        function jt() {
          var L = /* @__PURE__ */ new Date(), D = [
            Ct(L.getHours()),
            Ct(L.getMinutes()),
            Ct(L.getSeconds())
          ].join(":");
          return [L.getDate(), It[L.getMonth()], D].join(" ");
        }
        i.log = function() {
          console.log("%s - %s", jt(), i.format.apply(i, arguments));
        }, i.inherits = r("inherits"), i._extend = function(L, D) {
          if (!D || !Y(D)) return L;
          for (var tt = Object.keys(D), et = tt.length; et--; )
            L[tt[et]] = D[tt[et]];
          return L;
        };
        function lt(L, D) {
          return Object.prototype.hasOwnProperty.call(L, D);
        }
      }).call(this, r("_process"), typeof _k < "u" ? _k : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
    }, {}], 13: [function(r, n, i) {
      (function(s) {
        function o(h, u) {
          for (var p = 0, y = h.length - 1; y >= 0; y--) {
            var g = h[y];
            g === "." ? h.splice(y, 1) : g === ".." ? (h.splice(y, 1), p++) : p && (h.splice(y, 1), p--);
          }
          if (u)
            for (; p--; p)
              h.unshift("..");
          return h;
        }
        i.resolve = function() {
          for (var h = "", u = !1, p = arguments.length - 1; p >= -1 && !u; p--) {
            var y = p >= 0 ? arguments[p] : s.cwd();
            if (typeof y != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            y && (h = y + "/" + h, u = y.charAt(0) === "/");
          }
          return h = o(l(h.split("/"), function(g) {
            return !!g;
          }), !u).join("/"), (u ? "/" : "") + h || ".";
        }, i.normalize = function(h) {
          var u = i.isAbsolute(h), p = c(h, -1) === "/";
          return h = o(l(h.split("/"), function(y) {
            return !!y;
          }), !u).join("/"), !h && !u && (h = "."), h && p && (h += "/"), (u ? "/" : "") + h;
        }, i.isAbsolute = function(h) {
          return h.charAt(0) === "/";
        }, i.join = function() {
          var h = Array.prototype.slice.call(arguments, 0);
          return i.normalize(l(h, function(u, p) {
            if (typeof u != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return u;
          }).join("/"));
        }, i.relative = function(h, u) {
          h = i.resolve(h).substr(1), u = i.resolve(u).substr(1);
          function p(x) {
            for (var m = 0; m < x.length && x[m] === ""; m++)
              ;
            for (var w = x.length - 1; w >= 0 && x[w] === ""; w--)
              ;
            return m > w ? [] : x.slice(m, w - m + 1);
          }
          for (var y = p(h.split("/")), g = p(u.split("/")), b = Math.min(y.length, g.length), f = b, E = 0; E < b; E++)
            if (y[E] !== g[E]) {
              f = E;
              break;
            }
          for (var A = [], E = f; E < y.length; E++)
            A.push("..");
          return A = A.concat(g.slice(f)), A.join("/");
        }, i.sep = "/", i.delimiter = ":", i.dirname = function(h) {
          if (typeof h != "string" && (h = h + ""), h.length === 0) return ".";
          for (var u = h.charCodeAt(0), p = u === 47, y = -1, g = !0, b = h.length - 1; b >= 1; --b)
            if (u = h.charCodeAt(b), u === 47) {
              if (!g) {
                y = b;
                break;
              }
            } else
              g = !1;
          return y === -1 ? p ? "/" : "." : p && y === 1 ? "/" : h.slice(0, y);
        };
        function a(h) {
          typeof h != "string" && (h = h + "");
          var u = 0, p = -1, y = !0, g;
          for (g = h.length - 1; g >= 0; --g)
            if (h.charCodeAt(g) === 47) {
              if (!y) {
                u = g + 1;
                break;
              }
            } else p === -1 && (y = !1, p = g + 1);
          return p === -1 ? "" : h.slice(u, p);
        }
        i.basename = function(h, u) {
          var p = a(h);
          return u && p.substr(-1 * u.length) === u && (p = p.substr(0, p.length - u.length)), p;
        }, i.extname = function(h) {
          typeof h != "string" && (h = h + "");
          for (var u = -1, p = 0, y = -1, g = !0, b = 0, f = h.length - 1; f >= 0; --f) {
            var E = h.charCodeAt(f);
            if (E === 47) {
              if (!g) {
                p = f + 1;
                break;
              }
              continue;
            }
            y === -1 && (g = !1, y = f + 1), E === 46 ? u === -1 ? u = f : b !== 1 && (b = 1) : u !== -1 && (b = -1);
          }
          return u === -1 || y === -1 || // We saw a non-dot character immediately before the dot
          b === 0 || // The (right-most) trimmed path component is exactly '..'
          b === 1 && u === y - 1 && u === p + 1 ? "" : h.slice(u, y);
        };
        function l(h, u) {
          if (h.filter) return h.filter(u);
          for (var p = [], y = 0; y < h.length; y++)
            u(h[y], y, h) && p.push(h[y]);
          return p;
        }
        var c = "ab".substr(-1) === "b" ? function(h, u, p) {
          return h.substr(u, p);
        } : function(h, u, p) {
          return u < 0 && (u = h.length + u), h.substr(u, p);
        };
      }).call(this, r("_process"));
    }, { _process: 14 }], 14: [function(r, n, i) {
      var s = n.exports = {}, o, a;
      function l() {
        throw new Error("setTimeout has not been defined");
      }
      function c() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? o = setTimeout : o = l;
        } catch {
          o = l;
        }
        try {
          typeof clearTimeout == "function" ? a = clearTimeout : a = c;
        } catch {
          a = c;
        }
      })();
      function h(m) {
        if (o === setTimeout)
          return setTimeout(m, 0);
        if ((o === l || !o) && setTimeout)
          return o = setTimeout, setTimeout(m, 0);
        try {
          return o(m, 0);
        } catch {
          try {
            return o.call(null, m, 0);
          } catch {
            return o.call(this, m, 0);
          }
        }
      }
      function u(m) {
        if (a === clearTimeout)
          return clearTimeout(m);
        if ((a === c || !a) && clearTimeout)
          return a = clearTimeout, clearTimeout(m);
        try {
          return a(m);
        } catch {
          try {
            return a.call(null, m);
          } catch {
            return a.call(this, m);
          }
        }
      }
      var p = [], y = !1, g, b = -1;
      function f() {
        !y || !g || (y = !1, g.length ? p = g.concat(p) : b = -1, p.length && E());
      }
      function E() {
        if (!y) {
          var m = h(f);
          y = !0;
          for (var w = p.length; w; ) {
            for (g = p, p = []; ++b < w; )
              g && g[b].run();
            b = -1, w = p.length;
          }
          g = null, y = !1, u(m);
        }
      }
      s.nextTick = function(m) {
        var w = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var _ = 1; _ < arguments.length; _++)
            w[_ - 1] = arguments[_];
        p.push(new A(m, w)), p.length === 1 && !y && h(E);
      };
      function A(m, w) {
        this.fun = m, this.array = w;
      }
      A.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
      function x() {
      }
      s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(m) {
        return [];
      }, s.binding = function(m) {
        throw new Error("process.binding is not supported");
      }, s.cwd = function() {
        return "/";
      }, s.chdir = function(m) {
        throw new Error("process.chdir is not supported");
      }, s.umask = function() {
        return 0;
      };
    }, {}], 15: [function(r, n, i) {
      var s = r("escodegen").generate;
      n.exports = function(o, a) {
        a || (a = {});
        var l = {}, c = function h(u, p) {
          if (u.type === "Literal")
            return u.value;
          if (u.type === "UnaryExpression") {
            var y = h(u.argument);
            return u.operator === "+" ? +y : u.operator === "-" ? -y : u.operator === "~" ? ~y : u.operator === "!" ? !y : l;
          } else if (u.type === "ArrayExpression") {
            for (var g = [], b = 0, f = u.elements.length; b < f; b++) {
              var E = h(u.elements[b]);
              if (E === l) return l;
              g.push(E);
            }
            return g;
          } else if (u.type === "ObjectExpression") {
            for (var A = {}, b = 0; b < u.properties.length; b++) {
              var x = u.properties[b], m = x.value === null ? x.value : h(x.value);
              if (m === l) return l;
              A[x.key.value || x.key.name] = m;
            }
            return A;
          } else if (u.type === "BinaryExpression" || u.type === "LogicalExpression") {
            var f = h(u.left);
            if (f === l) return l;
            var w = h(u.right);
            if (w === l) return l;
            var _ = u.operator;
            return _ === "==" ? f == w : _ === "===" ? f === w : _ === "!=" ? f != w : _ === "!==" ? f !== w : _ === "+" ? f + w : _ === "-" ? f - w : _ === "*" ? f * w : _ === "/" ? f / w : _ === "%" ? f % w : _ === "<" ? f < w : _ === "<=" ? f <= w : _ === ">" ? f > w : _ === ">=" ? f >= w : _ === "|" ? f | w : _ === "&" ? f & w : _ === "^" ? f ^ w : _ === "&&" ? f && w : _ === "||" ? f || w : l;
          } else {
            if (u.type === "Identifier")
              return {}.hasOwnProperty.call(a, u.name) ? a[u.name] : l;
            if (u.type === "ThisExpression")
              return {}.hasOwnProperty.call(a, "this") ? a.this : l;
            if (u.type === "CallExpression") {
              var S = h(u.callee);
              if (S === l || typeof S != "function") return l;
              var R = u.callee.object ? h(u.callee.object) : l;
              R === l && (R = null);
              for (var O = [], b = 0, f = u.arguments.length; b < f; b++) {
                var E = h(u.arguments[b]);
                if (E === l) return l;
                O.push(E);
              }
              return S.apply(R, O);
            } else if (u.type === "MemberExpression") {
              var A = h(u.object);
              if (A === l || typeof A == "function")
                return l;
              if (u.property.type === "Identifier")
                return A[u.property.name];
              var x = h(u.property);
              return x === l ? l : A[x];
            } else if (u.type === "ConditionalExpression") {
              var y = h(u.test);
              return y === l ? l : h(y ? u.consequent : u.alternate);
            } else if (u.type === "ExpressionStatement") {
              var y = h(u.expression);
              return y === l ? l : y;
            } else {
              if (u.type === "ReturnStatement")
                return h(u.argument);
              if (u.type === "FunctionExpression") {
                var $ = u.body.body, z = {};
                Object.keys(a).forEach(function(It) {
                  z[It] = a[It];
                });
                for (var b = 0; b < u.params.length; b++) {
                  var F = u.params[b];
                  if (F.type == "Identifier")
                    a[F.name] = null;
                  else return l;
                }
                for (var b in $)
                  if (h($[b]) === l)
                    return l;
                a = z;
                var Y = Object.keys(a), rt = Y.map(function(It) {
                  return a[It];
                });
                return Function(Y.join(", "), "return " + s(u)).apply(null, rt);
              } else if (u.type === "TemplateLiteral") {
                for (var at = "", b = 0; b < u.expressions.length; b++)
                  at += h(u.quasis[b]), at += h(u.expressions[b]);
                return at += h(u.quasis[b]), at;
              } else if (u.type === "TaggedTemplateExpression") {
                var pt = h(u.tag), vt = u.quasi, _t = vt.quasis.map(h), Ct = vt.expressions.map(h);
                return pt.apply(null, [_t].concat(Ct));
              } else return u.type === "TemplateElement" ? u.value.cooked : l;
            }
          }
        }(o);
        return c === l ? void 0 : c;
      };
    }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
      n.exports = r("./lib/index");
    }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
  });
})(hN);
var Mut = hN.exports;
const i4 = /* @__PURE__ */ Lut(Mut);
function Up(e) {
  let t, r, n;
  return t = e, (i, s, o) => {
    if (o.value != null)
      o.value = kk(o.value, t, r, n);
    else if (o.get != null)
      o.get = kk(o.get, t, r, n);
    else
      throw "Only put a Memoize() decorator on a method or get accessor.";
  };
}
const kw = /* @__PURE__ */ new Map();
function kk(e, t, r = 0, n) {
  const i = Symbol("__memoized_map__");
  return function(...s) {
    let o;
    this.hasOwnProperty(i) || Object.defineProperty(this, i, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: /* @__PURE__ */ new Map()
    });
    let a = this[i];
    if (Array.isArray(n))
      for (const l of n)
        kw.has(l) ? kw.get(l).push(a) : kw.set(l, [a]);
    if (t || s.length > 0 || r > 0) {
      let l;
      t === !0 ? l = s.map((u) => u.toString()).join("!") : t ? l = t.apply(this, s) : l = s[0];
      const c = `${l}__timestamp`;
      let h = !1;
      if (r > 0)
        if (!a.has(c))
          h = !0;
        else {
          let u = a.get(c);
          h = Date.now() - u > r;
        }
      a.has(l) && !h ? o = a.get(l) : (o = e.apply(this, s), a.set(l, o), r > 0 && a.set(c, Date.now()));
    } else {
      const l = this;
      a.has(l) ? o = a.get(l) : (o = e.apply(this, s), a.set(l, o));
    }
    return o;
  };
}
var Nut = Object.defineProperty, Dut = (e, t, r) => t in e ? Nut(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, hi = (e, t, r) => Dut(e, typeof t != "symbol" ? t + "" : t, r), But = Object.defineProperty, jut = (e, t, r) => t in e ? But(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, uo = (e, t, r) => (jut(e, typeof t != "symbol" ? t + "" : t, r), r), pN = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(globalThis, () => (() => {
    var r, n = { d: (K, C) => {
      for (var N in C)
        n.o(C, N) && !n.o(K, N) && Object.defineProperty(K, N, { enumerable: !0, get: C[N] });
    }, o: (K, C) => Object.prototype.hasOwnProperty.call(K, C), r: (K) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(K, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(K, "__esModule", { value: !0 });
    } }, i = {};
    async function s(K) {
      const C = new DecompressionStream("gzip"), N = K.stream().pipeThrough(C);
      return await new Response(N).blob();
    }
    n.r(i), n.d(i, { A: () => Se, AP: () => ke, Adv: () => Jt, AdvP: () => ze, C: () => k, CP: () => pr, Constituent: () => w, D: () => bt, DT: () => B, Dependent: () => lt, Dependent_en: () => ps, N: () => te, NO: () => it, NP: () => de, P: () => M, PP: () => We, Phrase: () => It, Phrase_en: () => Et, Pro: () => Kt, Q: () => ct, S: () => se, SP: () => Yr, Terminal: () => at, Terminal_en: () => wt, V: () => xt, VP: () => Xt, addToLexicon: () => h, comp: () => dt, coord: () => ft, dependent: () => qe, det: () => V, exceptionOnWarning: () => Zt, fromJSON: () => st, getElems: () => ot, getLanguage: () => p, getLemma: () => u, getLexicon: () => y, getRules: () => g, getSavedWarnings: () => Ye, isRunningUnderNode: () => Tt, jsRealB_dateCreated: () => zt, jsRealB_version: () => Rt, load: () => mt, loadEn: () => c, mix: () => St, mod: () => H, oneOf: () => J, phrase: () => Mt, ppJSON: () => X, resetSavedWarnings: () => _e, root: () => Vi, savedWarnings: () => Yt, setExceptionOnWarning: () => kt, setQuoteOOV: () => f, setReorderVPcomplements: () => A, subj: () => T, terminal: () => le });
    const o = {}, a = {};
    let l = "en";
    async function c(K = !1) {
      l = "en", await async function() {
        console.log("decompressing lexicon  and grammar rules");
        const C = await (await fetch("data:application/gzip;base64,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")).blob(), N = JSON.parse(await (await s(C)).text()), q = await (await fetch("data:application/gzip;base64,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")).blob(), W = JSON.parse(await (await s(q)).text());
        o.en = N, a.en = W;
      }(), K && console.log("English lexicon and rules loaded");
    }
    function h(K, C, N) {
      let q = y(N);
      if (C !== null)
        return C == null && (C = Object.values(K)[0], K = Object.keys(K)[0]), q[K] !== void 0 && C !== void 0 ? Object.assign(q[K], C) : q[K] = C, q[K];
      q[K] !== void 0 && delete q[K];
    }
    function u(K, C) {
      return y(C)[K];
    }
    function p() {
      return l;
    }
    function y(K) {
      return K !== void 0 ? o[K] : o[l];
    }
    function g(K) {
      return K !== void 0 ? a[K] : a[l];
    }
    let b = !1;
    function f(K) {
      b = K;
    }
    let E = !1;
    function A(K) {
      E = K;
    }
    const x = ["root", "subj", "det", "mod", "comp", "coord"], m = class N1 {
      constructor(C) {
        this.parentConst = null, this.constType = C, this.props = {}, this.realization = null, this.optSource = "";
      }
      initProps() {
        if (this.isA("N", "A", "D", "V", "NO", "Pro", "Q", "DT")) {
          const C = this.defaultProps();
          this.peng = { pe: C.pe, n: C.n, g: C.g, pengNO: N1.pengNO++ }, this.isA("V") && (this.taux = { t: C.t, tauxNO: N1.tauxNO++ });
        }
      }
      clone() {
        return st(this.toJSON(), this.lang);
      }
      error(C) {
        throw `Internal error: this should never have happened, sorry!
` + this.me() + ":: " + C;
      }
      isA(C) {
        if (arguments.length == 1) {
          if (!Array.isArray(C))
            return C == this.constType;
        } else
          C = Array.from(arguments);
        return C.includes(this.constType);
      }
      getProp(C) {
        const N = this.props[C];
        return N !== void 0 ? N : C == "pe" || C == "n" || C == "g" ? this.peng === void 0 ? void 0 : this.peng[C] : C == "t" || C == "aux" ? this.taux === void 0 ? void 0 : this.taux[C] : void 0;
      }
      setProp(C, N, q) {
        C == "pe" || C == "n" || C == "g" ? this.peng !== void 0 && (this.peng[C] = N) : C != "t" && C != "aux" || this.taux !== void 0 && (this.taux[C] = N), ["pe", "n", "g", "t", "aux"].includes(C) && q !== void 0 || (this.props[C] = N);
      }
      getFromPath(C) {
        if (C.length == 0)
          return this;
        const N = C.shift(), q = this.getConst(N);
        return q === void 0 ? typeof N == "object" && N.includes("") && C.length > 0 ? this.getFromPath(C) : void 0 : q.getFromPath(C);
      }
      getTonicPro(C) {
        if (this.isA("Pro")) {
          if (this.props.tn || this.props.c)
            return C !== void 0 ? this.props.c = C : (this.props.tn = "", "c" in this.props && delete this.props.c), this;
          if (this.tonic_forms().includes(this.lemma)) {
            if (C !== void 0)
              return Kt(this.lemma, this.lang).c(C);
          } else if (C !== void 0)
            return Kt(this.realize(), this.lang).c(C);
          return this;
        }
        {
          let N = Kt(this.tonic_pe_1(), this.lang);
          const q = this.getProp("g");
          q !== void 0 && N.g(q);
          const W = this.getProp("n");
          W !== void 0 && N.n(W);
          const G = this.getProp("pe");
          return G !== void 0 && N.pe(G), C === void 0 ? Kt(N.realize(), this.lang).tn("") : Kt(N.realize(), this.lang).c(C);
        }
      }
      getParentLang() {
        return this.lang !== void 0 ? this.lang : this.parentConst === null ? p() : this.parentConst.getParentLang();
      }
      addOptSource(C, N) {
        this.optSource += "." + C + "(" + (N === void 0 ? "" : JSON.stringify(N)) + ")";
      }
      tag(C, N) {
        return N == null || Object.keys(N).length == 0 ? (this.addOptSource("tag", C), N = {}) : this.optSource += ".tag('" + C + "'," + JSON.stringify(N) + ")", this.props.tag === void 0 && (this.props.tag = []), this.props.tag.push([C, N]), this;
      }
      dOpt(C) {
        if (this.addOptSource("dOpt", C), typeof C != "object")
          return this.warn("bad application", ".dOpt", "object", typeof C);
        if (this.isA("DT")) {
          const N = ["year", "month", "date", "day", "hour", "minute", "second", "nat", "det", "rtime"], q = Object.keys(C);
          for (let W = 0; W < q.length; W++) {
            const G = q[W];
            if (!N.includes(G))
              return this.warn("ignored value for option", "DT.dOpt", G);
            {
              const nt = C[G];
              if (G == "rtime")
                if (typeof nt == "boolean")
                  this.props.dOpt.rtime = !!nt && /* @__PURE__ */ new Date();
                else if (typeof nt == "string")
                  this.props.dOpt.rtime = new Date(nt);
                else {
                  if (!(nt instanceof Date))
                    return this.warn("bad application", ".dOpt('rtime')", ["boolean", "string", "Date"], nt);
                  this.props.dOpt.rtime = nt;
                }
              else {
                if (typeof nt != "boolean")
                  return this.warn("bad application", ".dOpt(" + G + ")", "boolean", nt);
                this.props.dOpt[G] = nt;
              }
            }
          }
        } else {
          if (!this.isA("NO"))
            return this.warn("bad application", ".dOpt", ["DT", "NO"], this.constType);
          {
            const N = ["mprecision", "raw", "nat", "ord", "rom"], q = Object.keys(C);
            for (let W = 0; W < q.length; W++) {
              const G = q[W];
              if (!N.includes(G))
                return this.warn("ignored value for option", "NO.dOpt", G);
              {
                const nt = C[G];
                if (G == "mprecision") {
                  if (typeof nt != "number")
                    return this.warn("bad application", "precision", "number", nt);
                  this.props.dOpt.mprecision = nt;
                } else {
                  if (typeof nt != "boolean")
                    return this.warn("bad application", ".dOpt(" + G + ")", "boolean", nt);
                  this.props.dOpt[G] = nt;
                }
              }
            }
          }
        }
        return this;
      }
      nat(C) {
        if (this.addOptSource("nat", C), !this.isA("DT", "NO"))
          return this.warn("bad application", ".nat", ["DT", "NO"], this.constType);
        {
          const N = this.props.dOpt;
          if (C === void 0)
            N.nat = !0;
          else {
            if (typeof C != "boolean")
              return this.warn("bad application", ".nat", "boolean", C);
            N.nat = C;
          }
        }
        return this;
      }
      typ(C) {
        const N = { neg: [!1, !0], pas: [!1, !0], prog: [!1, !0], exc: [!1, !0], perf: [!1, !0], contr: [!1, !0], refl: [!1, !0], mod: [!1, "poss", "perm", "nece", "obli", "will"], int: [!1, "yon", "wos", "wod", "woi", "was", "wad", "wai", "whe", "why", "whn", "how", "muc", "tag"] };
        if (this.addOptSource("typ", C), this.isA("S", "SP", "VP") || this.isA(x))
          if (typeof C == "object") {
            for (let q in C) {
              const W = C[q], G = N[q];
              G === void 0 ? this.warn("unknown type", q, Object.keys(N)) : q == "neg" && this.validate_neg_option(W, C) || G.includes(W) || (this.warn("ignored value for option", ".typ(" + q + ")", W), delete C[q]);
            }
            this.props.typ = C;
          } else
            this.warn("ignored value for option", ".typ", typeof C + ":" + JSON.stringify(C));
        else
          this.warn("bad application", ".typ(" + JSON.stringify(C) + ")", ["S", "SP", "VP", "Dependent"], this.constType);
        return this;
      }
      doFormat(C) {
        const N = g(this.lang).punctuation, q = y(this.lang);
        function W(Bt) {
          const Wt = q[Bt];
          if (Wt !== void 0 && Wt.Pc !== void 0) {
            const oe = Wt.Pc.compl;
            if (oe !== void 0) {
              const ie = Bt, Ce = oe, De = Wt.Pc.tab, Dr = De[0], On = De.length == 2 ? De[1] : q[oe].Pc.tab[0], Fa = N[Dr], $a = N[On];
              return { b: Fa.b + ie + Fa.a, a: $a.b + Ce + $a.a };
            }
            {
              const ie = Wt.Pc.tab[0], Ce = N[ie];
              Bt = Ce.b + Bt + Ce.a;
            }
          }
          return { b: Bt, a: Bt };
        }
        function G(Bt, Wt) {
          C[0].realization = Bt + C[0].realization, C[C.length - 1].realization += Wt;
        }
        (function(Bt) {
          for (let Wt = 0; Wt < Bt.length; )
            Bt[Wt].realization == "" && Bt.length > 1 ? Bt.splice(Wt, 1) : Wt++;
        })(C), (this.isA("VP") || this.isA(x) && this.terminal.isA("V")) && this.doPronounPlacement(C), this.doElision(C);
        const nt = this.props.cap;
        if (nt !== void 0 && nt !== !1) {
          const Bt = C[0].realization;
          Bt.length > 0 && (C[0].realization = Bt.charAt(0).toUpperCase() + Bt.substring(1));
        }
        const ut = this.props.tag;
        ut !== void 0 && ut.forEach(function(Bt) {
          const Wt = Bt[0];
          var oe;
          G((oe = Bt[1], "<" + Wt + Object.entries(oe).map(function(ie) {
            return " " + ie[0] + '="' + ie[1] + '"';
          }).join("") + ">"), "</" + Wt + ">");
        });
        const gt = this.props.a;
        gt !== void 0 && gt.forEach(function(Bt) {
          G("", W(Bt).b);
        });
        const At = this.props.b;
        At !== void 0 && At.forEach(function(Bt) {
          G(W(Bt).b, "");
        });
        const Nt = this.props.en || this.props.ba;
        return Nt !== void 0 && Nt.forEach(function(Bt) {
          const Wt = W(Bt);
          G(Wt.b, Wt.a);
        }), C;
      }
      detokenize(C) {
        let N = "";
        const q = C.length - 1;
        if (q < 0)
          return N;
        for (let W = 0; W < q; W++) {
          const G = C[W];
          G.props.lier === !0 ? N += G.realization + "-" + this.check_for_t(C, W) : /[- ']$/.exec(G.realization) ? N += G.realization : G.realization.length > 0 && (N += G.realization + " ");
        }
        if (N += C[q].realization, this.parentConst == null && (this.isA("S", "root") || this.isA("coord") && this.dependents[0].isA("root")) && N.length > 0 && this.props.cap !== !1) {
          const W = this.sepWordRE().exec(N)[1].length;
          if (W < N.length && (N = N.substring(0, W) + N.charAt(W).toUpperCase() + N.substring(W + 1)), this.props.tag === void 0) {
            const G = /(.)( |(<[^>]+>))*$/.exec(N);
            G == null || "?!.:;/)]}".includes(G[1]) || (N += ". ");
          }
        }
        return N;
      }
      realize(C) {
        C !== void 0 && load(C);
        const N = this.real();
        return this.detokenize(N);
      }
      toString() {
        return N1.debug ? this.toSource() : this.realize();
      }
      indentSep(C, N) {
        return C >= 0 ? (C = C + this.constType.length + 1, N && this.peng !== void 0 && (this.peng.pengNO !== void 0 && (C += ("#" + this.peng.pengNO).length), this.taux && this.taux.tauxNO !== void 0 && (C += ("-" + this.taux.tauxNO).length)), [C, `,
` + " ".repeat(C)]) : [C, ","];
      }
      toSource() {
        return this.optSource;
      }
      toDebug() {
        return Object.keys(this.props).length > 0 ? JSON.stringify(this.props) : "";
      }
      warn(...C) {
        const N = this.warning(C);
        if (Zt)
          throw N;
        return Array.isArray(Yt) ? Yt.push(N) : console.warn(N), this;
      }
    };
    uo(m, "pengNO", 0), uo(m, "tauxNO", 0), uo(m, "debug", !1);
    let w = m;
    function _(K, C, N, q) {
      w.prototype[K] = function(W, G) {
        if (W === void 0 && C !== void 0 && !C.includes(""))
          return this.warn("no value for option", K, C);
        if (q === void 0 && (q = K), this.isA("CP") && !["cap", "lier", "pos"].includes(K)) {
          G == null && this.addOptSource(q, W);
          for (let nt = 0; nt < this.elements.length; nt++) {
            const ut = this.elements[nt];
            (N.length == 0 || ut.isA(N)) && ut[K](W, !0);
          }
          return this;
        }
        if (this.isA("coord") && !["cap", "lier", "pos"].includes(K)) {
          G == null && this.addOptSource(q, W);
          for (let nt = 0; nt < this.dependents.length; nt++) {
            const ut = this.dependents[nt].terminal;
            (N.length == 0 || ut.isA(N)) && ut[K](W, !0);
          }
          return this;
        }
        return N.length == 0 || this.isA(N) || this.isA(x) ? C === void 0 || C.includes(W) ? (C === void 0 && (W === void 0 ? W = !0 : W !== !0 && W !== !1 && (this.warn("ignored value for option", K, W), W = !1)), this.setProp(q, W), G == null && this.addOptSource(K, W ?? void 0), this) : this.warn("ignored value for option", K, W) : b && this.isA("Q") ? this : this.warn("bad const for option", K, this.constType, N);
      };
    }
    function S(K) {
      w.prototype[K] = function(C, N) {
        return this.props[K] === void 0 && (this.props[K] = []), this.props[K].push(C), N == null && this.addOptSource(K, C), this;
      };
    }
    function R(K) {
      var C = ("" + K).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
      return C ? Math.max(0, (C[1] ? C[1].length : 0) - (C[2] ? +C[2] : 0)) : 0;
    }
    function O(K, C) {
      const N = C == "en", q = [{ sing: "mille", plur: "mille" }, { sing: "un million", plur: "millions" }, { sing: "un milliard", plur: "milliards" }, { sing: "un trillion", plur: "trillions" }, { sing: "un quatrillion", plur: "quatrillions" }, { sing: "un quintillion", plur: "quintillions" }], W = [{ sing: "one thousand", plur: "thousand" }, { sing: "one million", plur: "million" }, { sing: "one billion", plur: "billion" }, { sing: "one trillion", plur: "trillion" }, { sing: "one quatrillion", plur: "quatrillion" }, { sing: "one quintillion", plur: "quintillion" }];
      function G(At) {
        return At.length == 0 || At[0] == "000" && G(At.slice(1));
      }
      function nt(At) {
        const Nt = At[0], Bt = At[1];
        switch (Nt) {
          case "0":
            return ut(Bt);
          case "1":
            return (N ? ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"] : ["dix", "onze", "douze", "treize", "quatorze", "quinze", "seize", "dix-sept", "dix-huit", "dix-neuf"])[+Bt];
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
            var Wt = (N ? ["twenty", "thirty", "forty", "fifty", "sixty"] : ["vingt", "trente", "quarante", "cinquante", "soixante"])[Nt - 2];
            return Bt == 0 ? Wt : Wt + (Bt == "1" ? N ? "-one" : " et un" : "-" + ut(Bt));
          case "7":
            return Bt == 0 ? N ? "seventy" : "soixante-dix" : N ? "seventy-" + ut(Bt) : "soixante" + (Bt == 1 ? " et " : "-") + nt("1" + Bt);
          case "8":
            return Bt == 0 ? N ? "eighty" : "quatre-vingts" : (N ? "eighty-" : "quatre-vingt-") + ut(Bt);
          case "9":
            return Bt == 0 ? N ? "ninety" : "quatre-vingt-dix" : N ? "ninety-" + ut(Bt) : "quatre-vingt-" + nt("1" + Bt);
        }
      }
      function ut(At) {
        return (N ? ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"] : ["zro", "un", "deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf"])[+At];
      }
      if (typeof K == "number" && (K = "" + K), !/^-?\d+$/.test(K))
        throw "nombreChaineEnLettres ne traite que des chiffres:" + K;
      let gt = !1;
      if (K[0] == "-" && (gt = !0, K = K.slice(1)), K.length > 21)
        throw "nombreChaineEnLettres ne traite que les nombres d'au plus 21 chiffres:" + K;
      return (gt ? N ? "minus " : "moins " : "") + function At(Nt) {
        const Bt = Nt.length, Wt = Nt[0];
        if (Bt == 1)
          return function(Ce) {
            if (Ce.length == 1)
              return ut(Ce);
            if (Ce.length == 2)
              return nt(Ce);
            const De = Ce[0], Dr = Ce.slice(1);
            if (De == "0")
              return nt(Dr);
            const On = N ? "hundred" : "cent";
            return Dr == "00" ? De == "1" ? (N ? "one " : "") + On : ut(De) + " " + On + (N ? "" : "s") : De == "1" ? (N ? "one " : "") + On + " " + nt(Dr) : ut(De) + " " + On + (N ? " and " : " ") + nt(Dr);
          }(Wt);
        const oe = Nt.slice(1);
        if (Wt == "000")
          return At(oe);
        const ie = N ? W : q;
        return (Wt == "001" ? ie[Bt - 2].sing : At([Wt]) + " " + ie[Bt - 2].plur) + " " + (G(oe) ? "" : At(oe));
      }(function At(Nt) {
        return Nt.length > 3 ? At(Nt.slice(0, Nt.length - 3)).concat([Nt.slice(Nt.length - 3)]) : (Nt.length == 1 ? Nt = "00" + Nt : Nt.length == 2 && (Nt = "0" + Nt), [Nt]);
      }(K)).trim();
    }
    _("pe", [1, 2, 3, "1", "2", "3"], ["D", "Pro", "N", "NP", "A", "AP", "V", "VP", "S", "SP", "CP"]), _("n", ["s", "p", "x"], ["D", "Pro", "N", "NP", "A", "AP", "V", "VP", "S", "SP", "CP"]), _("g", ["m", "f", "n", "x"], ["D", "Pro", "N", "NP", "A", "AP", "V", "VP", "S", "SP", "CP"]), _("t", ["p", "i", "f", "ps", "c", "s", "si", "ip", "pr", "pp", "b", "b-to", "pc", "pq", "cp", "pa", "fa", "spa", "spq", "bp", "bp-to"], ["V", "VP", "S", "SP", "CP"]), _("aux", ["av", "t", "a"], ["V", "VP", "S", "SP", "CP"]), _("f", ["co", "su"], ["A", "Adv"]), _("tn", ["", "refl"], ["Pro"]), _("c", ["nom", "acc", "dat", "refl", "gen"], ["Pro"]), _("pos", ["post", "pre"], ["A", "Adv", ...x]), _("pro", void 0, ["NP", "PP"]), _("ow", ["s", "p", "x"], ["D", "Pro"], "own"), _("cap", void 0, []), _("lier", void 0, []), S("b"), S("a"), S("ba"), S("en");
    var $ = { one: "first", two: "second", three: "third", five: "fifth", eight: "eighth", nine: "ninth", twelve: "twelfth" }, z = { un: "premier", une: "premire", cinq: "cinquime", neuf: "neuvime" };
    function F(K) {
      function C(N, q, W, G) {
        switch (G) {
          case 0:
            return "";
          case 1:
            return N;
          case 2:
            return N + N;
          case 3:
            return N + N + N;
          case 4:
            return N + q;
          case 5:
            return q;
          case 6:
            return q + N;
          case 7:
            return q + N + N;
          case 8:
            return q + N + N + N;
          case 9:
            return N + W;
          case 10:
            return W;
        }
      }
      return K < 0 ? "*too small*" : K <= 10 ? C("I", "V", "X", K) : K <= 100 ? C("X", "L", "C", Math.floor(K / 10)) + F(K % 10) : K <= 1e3 ? C("C", "D", "M", Math.floor(K / 100)) + F(K % 100) : K < 4e3 ? "M".repeat(Math.floor(K / 1e3)) + F(K % 1e3) : "*too big*";
    }
    function Y(K) {
      return typeof K != "string" ? K : K.includes("'") ? K.includes('"') ? '"' + K.replace('"', '\\"') + '"' : '"' + K + '"' : "'" + K + "'";
    }
    const rt = class s4 extends w {
      constructor(C, N) {
        if (super(N), C.length == 0 && N != "DT")
          return this.lang = lang || p(), this.setLemma("", N), void this.warn("bad number of parameters", N, 0);
        C.length == 1 ? (this.lang = p(), this.setLemma(C[0], N)) : C.length != 2 || C[1] != "en" && C[1] != "fr" ? (this.lang = p(), this.setLemma(C[0], N), N != "DT" && this.warn("bad number of parameters", N, C.length)) : (this.lang = C[1], this.setLemma(C[0], N));
      }
      me() {
        return this.constType + "(" + Y(this.lemma) + ")";
      }
      morphoError(C, N) {
        return this.warn("morphology error", C + ` :${this.me()} : ` + JSON.stringify(N)), this.realization = "[[" + this.lemma + "]]", this.constType = "Q", this;
      }
      add() {
        return this.warn("bad application", ".add", "Phrase", this.constType), this;
      }
      setLemma(C, N) {
        N == null && (N = this.constType), typeof C == "string" && (C = C.replace(//g, "oe").replace(//g, "ae")), this.lemma = C, this.peng === void 0 && this.initProps();
        var q = typeof C;
        switch (N) {
          case "DT":
            C == null ? this.date = /* @__PURE__ */ new Date() : q == "string" ? this.date = new Date(C) : C instanceof Date ? (this.date = C, this.lemma = C.toString()) : this.warn("bad parameter", "string, Date", q), this.props.dOpt = { year: !0, month: !0, date: !0, day: !0, hour: !0, minute: !0, second: !0, nat: !0, det: !0, rtime: !1 };
            break;
          case "NO":
            if (q != "string" && q != "number" && (this.warn("bad parameter", "string, number", q), this.lemma = this.value = C = 0), q == "string") {
              let nt = y(this.lang)[C];
              if (nt !== void 0 && nt.value) {
                if (nt.A) {
                  this.lemma = this.value = nt.value, this.props.dOpt = { ord: !0 }, this.addOptSource("ord", !0);
                  break;
                }
                this.lemma = this.value = nt.value, this.props.dOpt = { nat: !0 }, this.addOptSource("nat", !0);
                break;
              }
              /^[-+]?[0-9]+([., ][0-9]*)?([Ee][-+][0-9]+)?$/.test(C) ? (this.lemma = C = C.replace(this.thousand_seps(), ""), this.value = +C) : (this.warn("bad parameter", "number", q), this.lemma = this.value = 0);
            } else
              this.lemma = this.value = C;
            this.nbDecimals = R(C), this.props.dOpt = { mprecision: 2, raw: !1, nat: !1, ord: !1 };
            break;
          case "Q":
            this.lemma = typeof C == "string" ? C : JSON.stringify(C);
            break;
          case "N":
          case "A":
          case "Pro":
          case "D":
          case "V":
          case "Adv":
          case "C":
          case "P":
            if (q != "string")
              return this.tab = null, this.realization = `[[${C}]]`, this.warn("bad parameter", "string", q);
            let G = y(this.lang)[C];
            if (G == null)
              this.tab = null, this.realization = `[[${C}]]`, this.warn("not in lexicon", this.lang), b && (this.lemma = typeof C == "string" ? C : JSON.stringify(C), this.constType = "Q", this.realization = this.lemma);
            else if (G = G[N], G === void 0) {
              this.tab = null, this.realization = `[[${C}]]`;
              let nt = Object.keys(y(this.lang)[C]), ut = nt.indexOf("basic");
              ut >= 0 && nt.splice(ut, 1), this.warn("not in lexicon", this.lang, nt), b && (this.lemma = typeof C == "string" ? C : JSON.stringify(C), this.constType = "Q", this.realization = this.lemma);
            } else {
              const nt = Object.keys(G), ut = g(this.lang);
              for (let gt = 0; gt < nt.length; gt++) {
                const At = nt[gt];
                if (At == "tab") {
                  var W;
                  if (this.tab = G.tab, N != "V") {
                    const Nt = ut.declension[this.tab];
                    if (Nt !== void 0 && (W = Nt.ending, N == "Pro")) {
                      const Bt = Nt.declension, Wt = Bt[0].pe || 3;
                      if (Wt !== 3) {
                        let oe = 1;
                        for (; oe < Bt.length && Bt[oe].pe == Wt; )
                          oe++;
                        oe == Bt.length && this.setProp("pe", Wt);
                      }
                    }
                  } else {
                    const Nt = ut.conjugation[this.tab];
                    Nt !== void 0 ? W = Nt.ending : (W = "", this.warn("bad lexicon table", C, W));
                  }
                  C.endsWith(W) ? this.stem = C.substring(0, C.length - W.length) : (this.tab = null, this.isA("Adv", "C", "P") || this.warn("bad lexicon table", C, W));
                } else {
                  let Nt = G[At];
                  this.setProp(At, Nt, !0);
                }
              }
            }
            break;
          default:
            this.warn("not implemented", N);
        }
        return this;
      }
      grammaticalNumber() {
        return this.isA("NO") ? this.props.dOpt.ord == 1 ? "s" : null : this.warn("bad application", "grammaticalNumber", "NO", this.constType);
      }
      bestMatch(C, N, q) {
        let W = [];
        for (var G = 0; G < N.length; G++) {
          const ut = N[G];
          let gt = 0;
          for (let At in q)
            if (ut[At] !== void 0) {
              const Nt = q[At];
              if (At == "pe" && ut[At] != Nt) {
                gt = 0;
                break;
              }
              ut[At] == Nt ? gt += 2 : ut[At] == "x" && (gt += 1);
            }
          W.push([gt, ut.val]);
        }
        W.sort((ut, gt) => gt[0] - ut[0]);
        const nt = W[0];
        return nt[0] == 0 ? (this.morphoError(C, q), null) : nt[1];
      }
      decline(C) {
        const N = g(this.lang);
        let q = N.declension[this.tab].declension, W = this.stem;
        if (this.isA("A", "Adv"))
          return this.decline_adj_adv(N, q, W);
        if (q.length == 1)
          this.realization = this.stem + q[0].val;
        else {
          let G = this.getProp("g");
          this.isA("D", "N") && G == null && (G = "m");
          let nt = this.getProp("n");
          this.isA("D", "N") && nt == null && (nt = "s");
          let ut = 3;
          if (C) {
            let Wt = this.getProp("pe");
            ut = Wt === void 0 ? 3 : +Wt;
          }
          let gt = C ? { pe: ut, g: G, n: nt } : { g: G, n: nt };
          if (this.props.own !== void 0 && (gt.own = this.props.own), this.isA("Pro")) {
            const Wt = this.props.c;
            Wt !== void 0 && (this.check_bad_pronoun_case(Wt) || (gt.c = Wt));
            const oe = this.props.tn;
            if (oe !== void 0 && (Wt !== void 0 ? this.warn("both tonic and clitic") : gt.tn = oe), Wt !== void 0 || oe !== void 0)
              if (this.lemma == this.tonic_pe_1())
                this.getProp("g") === void 0 && delete gt.g, this.getProp("n") === void 0 && delete gt.n, Wt != "nom" && oe != "" || this.getProp("pe") !== void 0 || (gt.pe = 1, this.setProp("pe", 1));
              else {
                const ie = q[0];
                this.should_set_person_number(Wt) && (this.setProp("g", ie.g || G), this.setProp("n", ie.n || nt), this.setProp("pe", gt.pe = ie.pe || 3));
              }
            else
              this.lemma != "on" && (gt.tn = "");
          }
          const At = this.declension_word(), Nt = this.bestMatch(At, q, gt);
          if (Nt == null)
            return [this.morphoError(At, gt)];
          const Bt = this.check_gender_lexicon(G, nt);
          if (Bt != null)
            return Bt;
          this.realization = this.stem + Nt;
        }
        return [this];
      }
      insertReal(C, N, q) {
        if (N instanceof s4)
          return N.parentConst = this.parentConst, N.realize(), q == null ? C.push(N) : C.splice(q, 0, N), C;
        this.warn("bad Constituent", it(q + 1).dOpt({ ord: !0 }).realize(), typeof N);
      }
      isReflexive() {
        if (!this.isA("V"))
          return this.error("isReflexive() should be called only for a verb,  not a " + this.constType);
        const C = this.getProp("pat");
        if (C !== void 0 && C.length == 1 && C[0] == "rfl")
          return !0;
        let N = this.parentConst;
        for (; N != null; ) {
          if (N.isA("VP", "SP", "S") || N.isA(x) && N.terminal.isA("V")) {
            const q = N.props.typ;
            if (q !== void 0 && q.refl === !0)
              return !!C.includes("rfl") || (this.ignoreRefl = !0, s4.noIgnoredReflVerbs.has(this.lemma) || this.warn("ignored reflexive", C), !1);
            if (!N.isA("VP"))
              return !1;
          }
          N = N.parentConst;
        }
        return !1;
      }
      dateFormat(C, N) {
        const q = /(.*?)\[(.+?)\]|(.+$)/g, W = g(this.lang).date, G = W.format[N.nat ? "natural" : "non_natural"];
        function nt(gt) {
          if (gt.length == 0)
            return "";
          let At = "", Nt = G[gt];
          N.det || (Nt = Nt.slice(Nt.indexOf("[")));
          for (const Bt of Nt.matchAll(q))
            if (Bt[1] == null)
              At += Bt[3];
            else {
              const Wt = (oe) => (oe < 10 ? "0" : "") + oe;
              switch (At += Bt[1], Bt[2]) {
                case "Y":
                  At += C.getFullYear();
                  break;
                case "F":
                  At += W.text.month["" + (C.getMonth() + 1)];
                  break;
                case "M0":
                  At += Wt(C.getMonth() + 1);
                  break;
                case "M":
                  At += C.getMonth() + 1;
                  break;
                case "d0":
                  At += Wt(C.getDate());
                  break;
                case "d":
                  At += C.getDate();
                  break;
                case "l":
                  At += W.text.weekday["" + C.getDay()];
                  break;
                case "A":
                  At += W.text.meridiem[C.getHours() < 12 ? 0 : 1];
                  break;
                case "h":
                  At += C.getHours() % 12;
                  break;
                case "H0":
                  At += Wt(C.getHours());
                  break;
                case "H":
                  At += C.getHours();
                  break;
                case "m0":
                  At += Wt(C.getMinutes());
                  break;
                case "m":
                  At += C.getMinutes();
                  break;
                case "s0":
                  At += Wt(C.getSeconds());
                  break;
                case "s":
                  At += C.getSeconds();
                  break;
                default:
                  console.log("strange field:" + Bt[2]);
              }
            }
          return At;
        }
        let ut;
        if (N.rtime) {
          const gt = W.format.relative_time, At = N.rtime, Nt = Math.ceil((C.getTime() - At.getTime()) / 864e5);
          At.setDate(At + Nt), ut = gt["" + Nt] !== void 0 ? gt["" + Nt].replace("[l]", W.text.weekday[C.getDay()]) : gt[Nt < 0 ? "-" : "+"].replace("[x]", Math.abs(Nt));
        } else
          ut = nt(["year", "month", "date", "day"].filter((gt) => N[gt] == 1).join("-"));
        return [ut, nt(["hour", "minute", "second"].filter((gt) => N[gt] == 1).join(":"))].filter((gt) => gt.length > 0).join(" ");
      }
      real() {
        switch (this.constType) {
          case "N":
          case "A":
            if (this.tab !== null)
              return this.doFormat(this.decline(!1));
            break;
          case "Adv":
            if (this.tab !== null)
              return this.doFormat(this.decline(!1));
            this.realization === null && (this.realization = this.lemma);
            break;
          case "C":
          case "P":
          case "Q":
            this.realization === null && (this.realization = this.lemma);
            break;
          case "D":
          case "Pro":
            if (this.tab !== null)
              return this.doFormat(this.decline(!0));
            break;
          case "V":
            return this.doFormat(this.conjugate());
          case "DT":
            this.realization = this.dateFormat(this.date, this.getProp("dOpt"));
            break;
          case "NO":
            this.setProp("n", this.grammaticalNumber());
            const C = this.getProp("dOpt");
            C.nat == 1 ? this.realization = this.numberToWord(this.value, this.lang, this.peng.g) : C.ord == 1 ? (this.setProp("n", "s"), this.realization = this.numberToOrdinal(this.value, this.lang, this.peng.g)) : C.rom == 1 ? this.realization = this.numberToRoman(this.value) : C.raw == 0 ? this.realization = function(N, q, W) {
              let G = W === void 0 ? 2 : W;
              const nt = g(q).number;
              return G = R(N) > G ? G : R(N), function(ut, gt, At, Nt) {
                ut = (ut + "").replace(/[^0-9+\-Ee.]/g, "");
                var Bt = isFinite(+ut) ? +ut : 0, Wt = isFinite(+gt) ? Math.abs(gt) : 0, oe = Nt === void 0 ? "" : Nt, ie = At === void 0 ? "." : At, Ce = "";
                return (Ce = (Wt ? function(De, Dr) {
                  var On = Math.pow(10, Dr);
                  return "" + (Math.round(De * On) / On).toFixed(Dr);
                }(Bt, Wt) : "" + Math.round(Bt)).split("."))[0].length > 3 && (Ce[0] = Ce[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, oe)), (Ce[1] || "").length < Wt && (Ce[1] = Ce[1] || "", Ce[1] += new Array(Wt - Ce[1].length + 1).join("0")), Ce.join(ie);
              }(N, G, nt.symbol.decimal, nt.symbol.group);
            }(this.value, this.lang, C.mprecision) : this.realization = this.value + "";
            break;
          default:
            this.error("Terminal.real:" + this.constType + ": not implemented");
        }
        return this.doFormat([this]);
      }
      numberToWord(C, N, q) {
        return parseInt(C) !== C ? (this.warn("bad number in word", C), C + "") : this.numberOne(q, C) ?? O(C, N);
      }
      numberToOrdinal(C, N, q) {
        return parseInt(C) !== C || C <= 0 ? (this.warn("bad ordinal", C), `[[${C}]]`) : function(W, G, nt) {
          const ut = G == "en";
          if ((W = O(W, G)) == "zro" || W == "zero")
            return W;
          const gt = /(.*?)(\w+)$/.exec(W), At = gt[2];
          return ut ? At in $ ? gt[1] + $[At] : W.charAt(W.length - 1) == "y" ? W.substring(0, W.length - 1) + "ieth" : W + "th" : W == "un" ? nt == "f" ? "premire" : "premier" : W.endsWith("et un") ? W + "ime" : At in z ? gt[1] + z[At] : W.charAt(W.length - 1) == "e" || W.endsWith("quatre-vingts") ? W.substring(0, W.length - 1) + "ime" : W + "ime";
        }(C, N, q);
      }
      numberToRoman(C) {
        return parseInt(C) !== C || C <= 0 || C >= 4e3 ? (this.warn("bad roman", C), `[[${C}]]`) : F(C);
      }
      toSource() {
        return this.constType + "(" + Y(this.lemma) + ")" + super.toSource();
      }
      toDebug() {
        let C = this.constType + "(" + Y(this.lemma) + ")";
        return this.peng !== void 0 && (this.peng.pengNO !== void 0 && (C += "#" + this.peng.pengNO), this.peng.tauxNO !== void 0 && (C += "-" + this.peng.tauxNO)), C + super.toDebug();
      }
    };
    uo(rt, "noIgnoredReflVerbs", /* @__PURE__ */ new Set(["avoir", "tre", "pouvoir", "devoir", "vouloir"]));
    let at = rt;
    const pt = (K) => class extends K {
      lang() {
        return "en";
      }
      isEn() {
        return !0;
      }
      isFr() {
        return !1;
      }
      defaultProps() {
        return { g: "n", n: "s", pe: 3, t: "p" };
      }
      tonic_forms() {
        return ["us", "her", "you", "him", "them", "it"];
      }
      tonic_pe_1() {
        return "me";
      }
      relative_pronouns() {
        return ["that", "who", "which"];
      }
      validate_neg_option(C, N) {
        return !1;
      }
      sepWordRE() {
        return /((?:[^<\w'-]*(?:<[^>]+>)?)*)([\w'-]+)?(.*)/;
      }
      doElision(C) {
        const N = /^(heir|herb|honest|honou?r(able)?|hour)/i, q = /^(uni.*|ub.*|use.*|usu.*|uv.*)/i, W = /^[A-Z]+$/, G = { "are+not": "aren't", "can+not": "can't", "did+not": "didn't", "do+not": "don't", "does+not": "doesn't", "had+not": "hadn't", "has+not": "hasn't", "have+not": "haven't", "is+not": "isn't", "must+not": "mustn't", "need+not": "needn't", "should+not": "shouldn't", "was+not": "wasn't", "were+not": "weren't", "will+not": "won't", "would+not": "wouldn't", "could+not": "couldn't", "let+us": "let's", "I+am": "I'm", "I+will": "I'll", "I+have": "I've", "I+had": "I'd", "I+would": "I'd", "she+will": "she'll", "he+is": "he's", "he+has": "he's", "she+had": "she'd", "she+would": "she'd", "he+will": "he'll", "she+is": "she's", "she+has": "she's", "he+would": "he'd", "he+had": "he'd", "you+are": "you're", "you+will": "you'll", "you+would": "you'd", "you+had": "you'd", "you+have": "you've", "we+are": "we're", "we+will": "we'll", "we+had": "we'd", "we+would": "we'd", "we+have": "we've", "they+will": "they'll", "they+are": "they're", "they+had": "they'd", "they+would": "they'd", "they+have": "they've", "it+is": "it's", "it+will": "it'll", "it+had": "it'd", "it+would": "it'd", "there+will": "there'll", "there+is": "there's", "there+has": "there's", "there+have": "there've", "that+is": "that's", "that+had": "that'd", "that+would": "that'd", "that+will": "that'll", "what+is": "what's" };
        var nt = C.length - 1;
        if (nt != 0)
          for (var ut = 0; ut < nt; ut++) {
            var gt = this.sepWordRE().exec(C[ut].realization);
            if (gt !== void 0 && gt[2] !== void 0) {
              var At = this.sepWordRE().exec(C[ut + 1].realization);
              if (At !== void 0 && At[2] !== void 0) {
                var Nt = gt[2], Bt = At[2];
                if (Nt != "a" && Nt != "A" || !C[ut].isA("D")) {
                  if (this.contraction !== void 0 && this.contraction === !0)
                    if (Nt == "cannot")
                      C[ut].realization = gt[1] + "can't" + gt[3];
                    else {
                      const Wt = G[Nt + "+" + Bt];
                      Wt != null && (C[ut].realization = gt[1] + Wt + gt[3], C[ut + 1].realization = At[1] + At[3].trim(), ut++);
                    }
                } else
                  (/^[ai]/i.exec(Bt) || /^e/i.exec(Bt) && !/^eu/i.exec(Bt) || /^o/i.exec(Bt) && !/^onc?e/.exec(Bt) || /^u/i.exec(Bt) && !q.exec(Bt) || N.exec(Bt) || W.exec(Bt)) && (C[ut].realization = gt[1] + Nt + "n" + gt[3], ut++);
              }
            }
          }
      }
      check_for_t(C, N) {
        return "";
      }
      warning(C) {
        function N(G) {
          return Array.isArray(G) || (G = [G]), pr.apply(null, [k("or")].concat(G.map((nt) => ct(nt)))).realize();
        }
        const q = { "bad parameter": (G, nt) => se(de(bt("the"), te("parameter")), Xt(xt("be").t("c"), ct(G).a(","), ct("not"), ct(nt))).typ({ mod: "nece" }), "bad application": (G, nt, ut) => se(ct(G), Xt(xt("apply").t("c"), We(M("to"), N(nt)).a(","), ct("not"), We(M("to"), ct(ut)))).typ({ mod: "nece", pas: !0 }), "bad position": (G, nt) => se(ct(G), Xt(xt("be").t("c"), Se("small").f("co"), k("than"), ct(nt))).typ({ mod: "nece" }), "bad const for option": (G, nt, ut) => pr(k("but"), Xt(xt("apply"), de(bt("the"), te("option"), ct(G)), We(M("to"), ct(nt))).typ({ pas: !0 }).a(","), Yr(Xt(xt("be").t("c"), We(M("to"), N(ut)))).typ({ mod: "nece" })), "ignored value for option": (G, nt) => se(ct(nt).a(":"), Xt(xt("ignore"), de(bt("this"), Se("bad").pos("pre"), te("value"), We(M("for"), te("option"), ct(G)))).typ({ pas: !0 })), "unknown type": (G, nt) => se(de(Se("illegal"), te("type"), ct(G).b(":")).a(","), Xt(xt("be").t("c"), N(nt)).typ({ mod: "nece" })), "no value for option": (G, nt) => se(de(bt("no"), te("value"), We(M("for"), te("option"), ct(G))), Xt(xt("be"), We(M("among"), ct(nt)))).typ({ mod: "nece" }), "not found": (G, nt) => se(ze(bt("no"), ct(G)), Xt(xt("find").t("pp"), We(M("in"), ct(nt)))), "bad ordinal": (G) => se(Xt(xt("realize"), ct(G), ze(Jt("as"), bt("a"), te("ordinal")))).typ({ neg: !0, mod: "poss" }), "bad roman": (G) => se(Xt(xt("realize"), ct(G), ze(Jt("as"), de(bt("a"), Se("Roman"), te("number"))))).typ({ neg: !0, mod: "poss" }), "bad number in word": (G) => se(Xt(xt("realize"), ct(G), We(M("in"), te("word").n("p")))).typ({ neg: !0, mod: "poss" }), "no French contraction": () => se(Xt(xt("ignore"), de(te("contraction")), We(M("in"), te("French")))).typ({ pas: !0 }), "morphology error": (G) => se(de(te("error"), We(M("within"), de(bt("the"), te("morphology")))).a(":"), ct(G)), "not implemented": (G) => se(ct(G), Xt(xt("implement"))).typ({ neg: !0, pas: !0 }), "not in lexicon": (G, nt) => se(Jt("not"), xt("find").t("pp"), We(M("within"), bt("the"), Se(G == "en" ? "English" : "French"), te("lexicon")), nt !== void 0 ? ze(Jt("but"), xt("exist"), Jt("as"), N(nt)) : ct("")), "no appropriate pronoun": () => se(Xt(xt("find"), de(bt("a"), Se("appropriate"), te("pronoun")))).typ({ neg: !0, pas: !0, mod: "poss" }), "both tonic and clitic": () => se(pr(k("and"), ct("tn(..)"), ct("c(..)")), Xt(xt("use").n("p"), Jt("together")).typ({ neg: !0, pas: !0, mod: "poss" }).a(","), ct("tn(..)"), Xt(xt("ignore")).typ({ pas: !0 })), "bad Constituent": (G, nt) => se(de(bt("the"), te("parameter"), ct(G)), Xt(xt("be"), ct("Constituent"), Jt("but"), ct(nt))).typ({ neg: !0 }), "bad Dependent": (G, nt) => se(de(bt("the"), te("parameter"), ct(G)), Xt(xt("be"), ct("Dependent"), Jt("but"), ct(nt))).typ({ neg: !0 }), "Dependent needs Terminal": (G) => se(de(bt("the"), it(1).dOpt({ ord: !0 }), te("parameter"), We(M("of"), ct("Dependent"))), Xt(xt("be"), ct("Terminal"), Jt("but"), ct(G))).typ({ neg: !0 }), "bad number of parameters": (G, nt) => se(ct(G), Xt(xt("accept"), de(bt("a"), Se("single"), te("parameter"))).a(","), Yr(k("but"), Kt("I"), Xt(Xt(xt("have"), it(nt))))), "Dependent without params": () => se(ct("Dependent"), We(M("without"), te("parameter"))), "bad lexicon table": (G, nt) => se(de(te("error"), We(M("within"), de(bt("the"), te("lexicon")))).a(":"), Yr(ct(G), Xt(xt("end"), We(M("with"), ct(nt)))).typ({ neg: !0 })), "bad language": (G) => se(de(te("language")), Xt(xt("be"), pr(k("or"), ct('"en"'), ct('"fr"')).a(","), ct("not"), ct(G).en('"'))).typ({ mod: "obli" }), "ignored reflexive": (G) => se(Xt(xt("be"), Se("reflexive")).typ({ mod: "poss", neg: !0 }).a(","), G.length > 0 ? ze(Jt("only"), N(G)) : void 0), "inconsistent dependents within a coord": (G, nt) => se(ct(G), Xt(xt("expect").t("pp"), We(M("within"), de(bt("this"), ct("coord")))), Yr(k("but"), ct(nt), xt("be").t("ps"), xt("find").t("pp"))), "user-warning": (G) => se(ct(typeof G == "string" ? G : G.realize())) }[C.shift()];
        let W = q.apply(null, C).cap(!1);
        return q === void 0 && this.error("warn called with an unknown error message:" + arguments[0]), this.me() + ":: " + W.realize();
      }
    }, vt = (K) => class extends pt(K) {
      thousand_seps() {
        return /,/g;
      }
      grammaticalNumber() {
        return super.grammaticalNumber() ?? (Math.abs(this.value) == 1 && this.nbDecimals == 0 ? "s" : "p");
      }
      decline_adj_adv(C, N, q) {
        this.realization = this.lemma;
        const W = this.getProp("f");
        if (W !== void 0 && W !== !1) {
          if (this.tab == "a1") {
            const G = Jt(W == "co" ? "more" : "most");
            return G.realization = G.lemma, [G, this];
          }
          {
            if (this.tab == "b1") {
              const nt = y(this.lang)[this.lemma].A;
              if (nt === void 0)
                return [this];
              {
                N = C.declension[nt.tab].declension;
                const ut = C.declension[nt.tab].ending;
                q = q.slice(0, q.length - ut.length);
              }
            }
            const G = this.bestMatch("adjective declension", N, { f: W });
            return G == null ? [this.morphoError("decline [en]:A", { f: W })] : (this.realization = q + G, [this]);
          }
        }
        return [this];
      }
      check_bad_pronoun_case(C) {
        return C == "refl" && (this.warn("ignored value for option", "c", C), !0);
      }
      should_set_person_number(C) {
        return C != "gen";
      }
      tonic_forms() {
        return ["us", "her", "you", "him", "them", "it"];
      }
      declension_word() {
        return "declension";
      }
      check_gender_lexicon(C, N) {
        return null;
      }
      conjugate() {
        let C = +this.getProp("pe") || 3;
        const N = this.getProp("n"), q = (this.getProp("g"), this.getProp("t"));
        if (this.tab == null)
          return [this.morphoError("conjugate_en:tab", { pe: C, n: N, t: q })];
        const W = q == "s" ? "p" : q == "si" ? "ps" : q, G = g(this.lang).conjugation[this.tab].t[W];
        let nt = [this];
        if (G !== void 0)
          switch (q) {
            case "p":
            case "ps":
            case "s":
            case "si":
              if (typeof G == "string")
                this.realization = this.stem + G;
              else {
                let ut = G[C - 1 + (N == "p" ? 3 : 0)];
                if (ut == null)
                  return [this.morphoError("conjugate_en:pe", { pe: C, n: N, t: q })];
                q == "s" && C == 3 && (ut = G[0]), this.realization = this.stem + ut;
              }
              break;
            case "b":
            case "pp":
            case "pr":
              this.realization = this.stem + G;
          }
        else if (q == "f")
          this.realization = this.lemma, this.insertReal(nt, xt("will"), 0);
        else if (q == "c")
          this.realization = this.lemma, this.insertReal(nt, xt("will").t("ps"), 0);
        else if (q == "bp" || q == "bp-to") {
          const ut = g(this.lang).conjugation[this.tab].t.pp;
          this.realization = ut !== void 0 ? this.stem + ut : this.lemma, this.insertReal(nt, xt("have").t("b"), 0), q == "bp-to" && this.insertReal(nt, P("to"), 0);
        } else if (q == "b-to")
          this.realization = this.lemma, this.insertReal(nt, P("to"), 0);
        else {
          if (q != "ip")
            return [this.morphoError("conjugate_en: unrecognized tense", { pe: C, n: N, t: q })];
          this.realization = this.lemma, C == 1 && N == "p" && this.insertReal(nt, Q("let's"), 0);
        }
        return nt;
      }
      numberOne(C, N) {
        return null;
      }
    }, _t = { can: "cannot", may: "may not", shall: "shall not", will: "will not", must: "must not", could: "could not", might: "might not", should: "should not", would: "would not" }, Ct = (K) => class extends K {
      word_last() {
        return "last";
      }
      adj_def_pos() {
        return "pre";
      }
      passive_pronoun_subject(C) {
        return C.lemma == "I" ? Kt("me").tn("").g(C.getProp("g")).n(C.getProp("n")).pe(C.getProp("pe")) : C.getTonicPro();
      }
      passive_dummy_subject() {
        return "it";
      }
      passive_context() {
        return "passive context";
      }
      passive_should_link_subject() {
        return !0;
      }
      passive_prep(C) {
        return C ? "to" : "by";
      }
      passive_human_object(C, N) {
        return C == "wod" && N !== void 0 && ["m", "f"].includes(N.getProp("g"));
      }
      should_add_interrogative_prefix(C) {
        return C != "yon";
      }
      and_conj() {
        return "and";
      }
      prepositionsList() {
        return { all: /* @__PURE__ */ new Set(["about", "above", "across", "after", "against", "along", "alongside", "amid", "among", "amongst", "around", "as", "at", "back", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "by", "concerning", "considering", "despite", "down", "during", "except", "for", "from", "in", "inside", "into", "less", "like", "minus", "near", "next", "of", "off", "on", "onto", "outside", "over", "past", "per", "plus", "round", "since", "than", "through", "throughout", "till", "to", "toward", "towards", "under", "underneath", "unlike", "until", "up", "upon", "versus", "with", "within", "without"]), whe: /* @__PURE__ */ new Set(["above", "across", "along", "alongside", "amid", "around", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "in", "inside", "into", "near", "next", "onto", "outside", "over", "past", "toward", "towards", "under", "underneath", "until", "via", "within"]), whn: /* @__PURE__ */ new Set(["after", "before", "during", "since", "till"]) };
      }
      affixHopping(C, N, q, W) {
        const G = C.peng, nt = W.neg === !0;
        let ut = [], gt = [], At = !1;
        N != "f" && N != "c" || (At = !0, N = N == "f" ? "p" : "ps");
        const Nt = W.prog !== void 0 && W.prog !== !1, Bt = W.perf !== void 0 && W.perf !== !1, Wt = W.pas !== void 0 && W.pas !== !1, oe = W.int, ie = W.mod;
        ie !== void 0 && ie !== !1 ? (ut.push(q[ie].aux), gt.push("b")) : At && (ut.push(q.future.aux), gt.push("b")), Bt || Nt || Wt ? (Bt && (ut.push(q.perfect.aux), gt.push(q.perfect.participle)), Nt && (ut.push(q.continuous.aux), gt.push(q.continuous.participle)), Wt && (ut.push(q.passive.aux), gt.push(q.passive.participle))) : oe !== void 0 && oe !== !1 && ut.length == 0 && C.lemma != "be" && C.lemma != "have" && oe != "wos" && oe != "was" && oe != "tag" && (["pp", "pr", "b-to"].includes(N) || (ut.push("do"), gt.push("b"))), ut.push(C.lemma);
        const Ce = ut.shift();
        let De = [];
        if (nt)
          ["pp", "pr", "b", "b-to", "bp", "bp-to"].includes(N) ? (De.push(Jt("not", "en")), N != "b" && N != "bp" || De.push(M("to", "en")), De.push(xt(Ce, "en").t(N))) : N == "ip" && G.pe == 1 && G.n == "p" ? (De.push(ct("let's")), De.push(Jt("not", "en")), De.push(xt(Ce, "en").t("b"))) : Ce in _t ? Ce == "can" && N == "p" ? De.push(ct("cannot")) : (De.push(xt(Ce, "en").t(N)), De.push(Jt("not", "en"))) : Ce == "be" || Ce == "have" && C.lemma != "have" ? (De.push(xt(Ce).t(N)), De.push(Jt("not", "en"))) : (De.push(xt("do", "en").t(N)), De.push(Jt("not", "en")), Ce != "do" && De.push(xt(Ce).t("b")));
        else {
          let Dr = xt(Ce).t(N);
          C.lemma in _t && Dr.pe(1), De.push(Dr);
        }
        for (De[0].peng = G; ut.length > 0; ) {
          const Dr = ut.shift();
          De.push(xt(Dr).t(gt.shift()));
        }
        return W.refl === !0 && N != "pp" && De.push(Kt("myself", "en").pe(C.getProp("pe")).n(C.getProp("n")).g(C.getProp("g"))), De;
      }
      checkAdverbPos(C) {
        function N(gt, At, Nt) {
          C.splice(Nt, 0, ...C.splice(gt, At));
        }
        const q = this.relative_pronouns();
        let W = C.length - 1;
        for (; W >= 0 && (!C[W].isA("Pro") || !q.includes(C[W].lemma)); )
          W--;
        W++;
        const G = C.map((gt, At) => At >= W && gt.isA("Adv") && gt.lemma != "not" ? At : -1).filter((gt) => gt != -1);
        if (G.length == 0)
          return;
        const nt = G[0], ut = C[nt];
        for (let gt = 1; gt < G.length; gt++)
          G[gt] != G[gt - 1] + 1 && G.splice(gt, G.length - gt);
        nt >= W + 2 && ut.props.pos === void 0 && function(gt) {
          for (let At = 0; At < nt - 1; At++) {
            const Nt = C[At];
            if (Nt.isA("V") && gt.includes(Nt.lemma)) {
              if (C[At + 1].isA("V")) {
                if ((Nt.lemma == "will" || Nt.lemma == "shall") && Nt.parentConst !== null && Nt.parentConst.getProp("t") == "f")
                  continue;
                N(nt, G.length, At + 1);
              } else
                C[At + 1].lemma == "not" && C[At + 2].isA("V") && N(nt, G.length, At + 2);
              break;
            }
          }
        }(["have", "can", "will", "shall", "may", "must"]);
      }
      doPronounPlacement() {
      }
    };
    class It extends w {
      constructor(C, N, q) {
        if (super(N), this.lang = q || p(), C = ot(C), this.elements = [], this.elementsSource = [], C.length > 0) {
          const W = C.length - 1;
          for (let G = 0; G < W; G++) {
            let nt = C[G];
            typeof nt == "string" && (nt = ct(nt)), nt instanceof at || nt instanceof It ? (this.addElement(nt), this.elementsSource.push(nt)) : this.warn("bad Constituent", it(G + 1).dOpt({ ord: !0 }).realize(), typeof nt + ":" + JSON.stringify(nt));
          }
          this.add(C[W], void 0, !0);
        }
      }
      addElement(C, N) {
        return C instanceof at || C instanceof It ? (C.parentConst = this, N == null ? this.elements.push(C) : typeof N == "number" && N <= this.elements.length && N >= 0 ? this.elements.splice(N, 0, C) : this.warn("bad position", N, this.elements.length)) : this.warn("bad Constituent", it(N + 1).dOpt({ ord: !0 }).realize(), typeof C), this;
      }
      removeElement(C) {
        if (typeof C == "number" && C < this.elements.length && C >= 0) {
          const N = this.elements.splice(C, 1)[0];
          return N.parentConst = null, N;
        }
        return this.warn("bad position", C, this.elements.length);
      }
      add(C, N, q) {
        function W(G, nt, ut) {
          nt > ut && ([ut, nt] = [nt, ut]);
          for (var gt = nt; gt <= ut; gt++)
            if (!G[gt].isA("A", "N"))
              return !1;
          return !0;
        }
        if (C === null)
          return this;
        if (typeof C == "string" && (C = ct(C)), !(C instanceof w))
          return this.warn("bad Constituent", this.word_last(), typeof C + ":" + JSON.stringify(C));
        q === void 0 ? this.optSource += ".add(" + C.toSource() + (N === void 0 ? "" : "," + N) + ")" : this.elementsSource.push(C), this.addElement(C, N), this.linkProperties();
        for (let G = 0; G < this.elements.length; G++) {
          const nt = this.elements[G];
          if (nt.isA("A")) {
            const ut = this.getIndex("N");
            if (ut >= 0) {
              const gt = nt.props.pos || this.adj_def_pos();
              (gt == "pre" && G > ut || gt == "post" && G < ut) && W(this.elements, G, ut) && this.addElement(this.removeElement(G), ut);
            }
          } else if (nt.isA("Adv") && nt.props.pos !== void 0) {
            const ut = this.getIndex("V");
            if (ut >= 0) {
              const gt = nt.props.pos;
              (gt == "pre" && G > ut || gt == "post" && G < ut) && this.addElement(this.removeElement(G), ut);
            }
          }
        }
        return this;
      }
      grammaticalNumber() {
        return this.error("grammaticalNumber must be called on a NO, not a " + this.constType);
      }
      getHeadIndex(C) {
        let N = C.substring(0, C.length - 1), q = this.getIndex([C, N]);
        return q < 0 && (q = 0), q;
      }
      linkProperties() {
        let C;
        if (this.elements.length == 0)
          return this;
        switch (this.constType) {
          case "NP":
            C = this.getHeadIndex("NP"), this.peng = this.elements[C].peng;
            for (let G = 0; G < this.elements.length; G++)
              if (G != C) {
                const nt = this.elements[G];
                if (this.peng) {
                  if (nt.isA("NO") && G < C)
                    this.peng.n = nt.grammaticalNumber(), nt.peng.g = this.peng.g;
                  else if (nt.isA("D", "A", "V"))
                    this.link_DAV_properties(nt);
                  else if (nt.isA("CP")) {
                    const ut = this;
                    nt.elements.forEach(function(gt) {
                      gt.isA("A", "NO") && (gt.peng = ut.peng);
                    });
                  }
                }
              }
            const N = this.getFromPath([["S", "SP"], "Pro"]);
            if (N !== void 0) {
              const G = N.parentConst.getFromPath(["VP", "V"]);
              G != null && this.link_subj_obj_subordinate(N, G);
            }
            break;
          case "VP":
            C = this.getHeadIndex("VP"), this.peng = this.elements[C].peng, this.taux = this.elements[C].taux;
            break;
          case "AdvP":
          case "PP":
          case "AP":
            C = this.getHeadIndex(this.constType), this.peng = this.elements[C].peng;
            break;
          case "CP":
            this.peng = { pengNO: w.pengNO++ };
            break;
          case "S":
          case "SP":
            let q = this.getFromPath([["", "VP"], "V"]);
            if (q !== void 0 && (this.taux = q.taux, q.getProp("t") == "ip"))
              return this;
            let W = this.getIndex(["NP", "N", "CP", "Pro"]);
            if (W >= 0) {
              let G = this.elements[W];
              if (this.isA("SP") && G.isA("Pro") && ["que", "o", "that"].includes(G.lemma)) {
                const ut = this.elements.slice(W + 1).findIndex((gt) => gt.isA("NP", "N", "CP", "Pro"));
                if (!(ut >= 0))
                  return this;
                G = this.elements[W + 1 + ut];
              }
              this.peng = G.peng;
              const nt = this.linkPengWithSubject("VP", "V", G);
              nt !== void 0 ? (this.taux = nt.taux, this.linkAttributes(nt, this.getFromPath([["VP"], ["CP"]]), G)) : (this.getFromPath(["CP", "VP"]) !== void 0 && this.getConst("CP").elements.forEach(function(ut) {
                ut instanceof It && ut.linkPengWithSubject("VP", "V", G);
              }), this.check_coordinated_object());
            }
            break;
          default:
            this.error("linkProperties	,unimplemented type:" + this.constType);
        }
        return this;
      }
      linkPengWithSubject(C, N, q) {
        if (q.isA("Pro") && q.props.c == "gen")
          return;
        let W = this.getFromPath([C, N]);
        return W !== void 0 ? W.parentConst.peng = W.peng = q.peng : (W = this.getFromPath([N]), W !== void 0 && (W.peng = q.peng)), W;
      }
      me() {
        const C = this.elements.map(function(N) {
          return N.me();
        });
        return this.constType + "(" + C.join() + ")";
      }
      setLemma(C, N) {
        return this.error("***: should never happen: setLemma: called on a Phrase"), this;
      }
      getIndex(C) {
        return typeof C == "string" && (C = [C]), this.elements.findIndex((N) => N.isA(C), this);
      }
      getConst(C) {
        const N = this.getIndex(C);
        if (!(N < 0))
          return this.elements[N];
      }
      findGenderNumberPerson(C) {
        let N, q, W = 3, G = 0;
        for (let nt = 0; nt < this.elements.length; nt++) {
          const ut = this.elements[nt];
          if (ut.isA("NP", "N", "Pro", "Q", "NO")) {
            G += 1;
            const gt = ut.getProp("g");
            N === void 0 && gt !== void 0 && (N = gt), gt == "m" && (N = "m"), ut.getProp("n") == "p" && (q = "p");
            const At = ut.getProp("pe");
            At !== void 0 && At < W && (W = At);
          }
        }
        return G > 1 && C && (q = "p"), { g: N, n: q, pe: W };
      }
      pronominalizeChildren() {
        for (let C of this.elements)
          C.props.pro !== !0 || C.isA("Pro") || C.pronominalize();
      }
      passivate() {
        let C, N, q;
        if (this.isA("VP"))
          C = null, N = this;
        else {
          if (N = this.getConst("VP"), N === void 0)
            return this.warn("not found", "VP", this.passive_context());
          this.elements.length > 0 && this.elements[0].isA("N", "NP", "Pro", "S") ? (C = this.removeElement(0), C.isA("Pro") && (C = this.passive_pronoun_subject(C))) : C = null;
        }
        if (N === void 0)
          return this.warn("not found", "VP", isFr() ? "contexte passif" : "passive context");
        {
          let W = N.getIndex(["NP", "Pro"]);
          if (W >= 0) {
            let G = N.removeElement(W);
            if (G.isA("Pro") ? (G = G.getTonicPro("nom"), W == 0 && (W = N.getIndex("V") + 1)) : G.isA("NP") && G.props.pro === !0 && (G = G.getTonicPro("nom")), q = G, this.addElement(q, 0), this.passive_should_link_subject() && this.linkPengWithSubject("VP", "V", q), C != null) {
              let nt = this.passive_prep(C.isA("S"));
              N.addElement(We(M(nt, this.lang), C), W);
            }
          } else if (C != null) {
            q = Kt(this.passive_dummy_subject(), this.lang).c("nom"), this.addElement(q, 0), this.linkPengWithSubject("VP", "V", q), N.peng = q.peng;
            let G, nt = N.getIndex("V"), ut = this.passive_prep(C.isA("S"));
            G = C.isA("S") ? void 0 : nt + 1, N.addElement(We(M(ut, this.lang), C), G);
          }
          this.passive_agree_auxiliary(N, q);
        }
      }
      processVP(C, N, q) {
        if (this.getFromPath(["CP", "VP"]) !== void 0)
          return void this.getConst("CP").elements.forEach(function(G) {
            G.isA("VP") && G.processVP(C, N, q);
          });
        const W = C[N];
        if (W !== void 0 && W !== !1) {
          let G;
          if (this.isA("VP"))
            G = this;
          else {
            const ut = this.getIndex(["VP"]);
            if (!(ut >= 0))
              return void this.warn("bad const for option", '.typ("' + N + ":" + W + '")', this.constType, ["VP"]);
            G = this.elements[ut];
          }
          const nt = G.getIndex("V");
          if (nt >= 0) {
            const ut = G.elements[nt];
            q(G, nt, ut, W);
          }
        }
      }
      getIdxCtx(C, N) {
        if (this.isA(C)) {
          var q = this.getIndex(N);
          if (q >= 0)
            return [q, this.elements];
        } else if (this.isA("S", "SP")) {
          var W = this.getConst(C);
          if (W !== void 0)
            return W.getIdxCtx(C, N);
        }
        return [void 0, void 0];
      }
      moveAuxToFront() {
        if (this.isEn() && this.isA("S", "SP")) {
          let [C, N] = this.getIdxCtx("VP", "V");
          if (C !== void 0 && !["pp", "pr", "b-to"].includes(this.getProp("t"))) {
            const q = N[0].parentConst.removeElement(0);
            this.addElement(q, 0);
          }
        }
      }
      invertSubject() {
        const C = this.getIndex(["NP", "N", "Pro", "SP", "CP"]);
        if (C >= 0) {
          const N = this.elements[C];
          let q;
          if (N.isA("Pro")) {
            if (N.getProp("pe") == 1 && N.getProp("n") == "s")
              return void this.add(ct("est-ce que"), C);
            q = this.removeElement(C);
          } else
            N.isA("CP") ? (q = Kt("moi", "fr").c("nom").g("m").n("p").pe(3), N.pronoun = q) : q = Kt("moi", "fr").g(N.getProp("g")).n(N.getProp("n")).pe(3).c("nom");
          let [W, G] = this.getIdxCtx("VP", "V");
          if (W !== void 0) {
            let nt = G[W];
            nt.parentConst.addElement(q, W + 1), nt.lier();
          }
        }
      }
      processInt(C) {
        const N = C.int, q = g(this.lang).sentence_type.int, W = q.prefix;
        let G, nt;
        switch (N) {
          case "yon":
          case "how":
          case "why":
          case "muc":
            this.isEn() ? this.moveAuxToFront() : this.invertSubject(), G = W[N];
            break;
          case "wos":
          case "was":
            if (this.isA("S", "SP", "VP")) {
              const ut = this.getIndex(["NP", "N", "Pro", "SP"]);
              if (ut !== void 0) {
                const gt = this.getIndex(["VP", "V"]);
                gt !== void 0 && ut < gt && (this.elements[gt].setProp("pe", 3), this.removeElement(ut));
              }
            }
            G = W[N];
            break;
          case "wod":
          case "wad":
            if (this.isA("S", "SP", "VP")) {
              let ut;
              const [gt, At] = this.getIdxCtx("VP", ["NP", "N", "Pro", "SP"]);
              gt !== void 0 && (ut = At[0].parentConst.removeElement(gt)[nt] = this.passive_subject_par(ut, nt)), G = this.passive_human_object(ut, nt) ? "whom" : W[N], this.isEn() ? this.moveAuxToFront() : this.invertSubject();
            }
            break;
          case "woi":
          case "wai":
          case "whe":
          case "whn":
            if (this.isA("S", "SP", "VP")) {
              const [ut, gt] = this.getIdxCtx("VP", "PP");
              if (G = W[N], ut !== void 0) {
                let At = gt[ut].elements[0];
                if (At.isA("P")) {
                  At = At.lemma;
                  const Nt = this.prepositionsList();
                  N == "whe" ? Nt.whe.has(At) && gt[0].parentConst.removeElement(ut) : N == "whn" ? Nt.whn.has(At) && gt[0].parentConst.removeElement(ut) : Nt.all.has(At) && (this.interrogative_pronoun_woi(int_), gt[0].parentConst.removeElement(ut));
                }
              }
              this.isEn() ? this.moveAuxToFront() : this.invertSubject();
            }
            break;
          case "tag":
            this.isA("S", "SP", "VP") && (this.tag_question(C), G = W[N]);
            break;
          default:
            this.warn("not implemented", "int:" + N);
        }
        this.should_add_interrogative_prefix(N) && this.addElement(ct(G), 0), this.a(q.punctuation, !0);
      }
      processTyp(C) {
        C.pas !== void 0 && C.pas !== !1 && this.passivate(), this.processTyp_verb(C), "int" in C && C.int !== !1 && this.processInt(C);
        const N = C.exc;
        return N !== void 0 && N === !0 && this.a(g(this.lang).sentence_type.exc.punctuation, !0), this;
      }
      cpReal() {
        var C = [];
        let N = this.getIndex("C");
        N < 0 && this.elements[0].isA("Q") && (N = 0);
        const q = this.elements.filter(function(gt, At) {
          return At != N;
        });
        var W = q.length - 1;
        if (W == -1)
          return [];
        if (W == 0)
          return Array.prototype.push.apply(C, q[0].real()), this.setProp("g", q[0].getProp("g")), this.setProp("n", q[0].getProp("n")), this.setProp("pe", q[0].getProp("pe") || 3), this.doFormat(C);
        for (let gt = 0; gt < W; gt++) {
          const At = q[gt];
          (N < 0 || gt < W - 1) && (At.props.a !== void 0 && At.props.a.includes(",") || (At.props.a = [","])), Array.prototype.push.apply(C, At.real());
        }
        let G;
        if (N >= 0 && Array.prototype.push.apply(C, this.elements[N].real()), Array.prototype.push.apply(C, q[W].real()), N >= 0) {
          G = this.elements[N];
          var nt = this.and_conj(), ut = this.findGenderNumberPerson(G.lemma == nt);
          ut.g !== void 0 && this.setProp("g", ut.g), ut.n !== void 0 && this.setProp("n", ut.n), this.setProp("pe", ut.pe), this.pronoun !== void 0 && (this.pronoun.peng = ut, this.pronoun.props.g = ut.g, this.pronoun.props.n = ut.n, this.pronoun.props.pe = ut.pe);
        }
        return this.doFormat(C);
      }
      vpReal() {
        var C = [];
        function N(ut) {
          return ut.map((gt) => gt.lemma.length).reduce((gt, At) => gt + At, 0) + ut.length;
        }
        this.pronominalizeChildren();
        const q = this.elements.length - 1;
        for (var W = q; W >= 0 && !this.elements[W].isA("V"); )
          W--;
        (W < 0 || this.elements[W].getProp("t") == "pp" || ["tre", "be"].includes(this.elements[W].lemma)) && (W = q);
        let G = 0;
        for (; G <= W; )
          Array.prototype.push.apply(C, this.elements[G].real()), G++;
        if (G > q)
          return this.doFormat(C);
        let nt = [];
        for (; G <= q; )
          nt.push(this.elements[G].real()), G++;
        return nt.sort(function(ut, gt) {
          const At = N(ut), Nt = N(gt);
          return Math.min(At, Nt) / Math.max(At, Nt) > 0.75 ? 0 : At - Nt;
        }), nt.forEach((ut) => Array.prototype.push.apply(C, ut)), this.doFormat(C);
      }
      real() {
        let C = [];
        if (this.isA("CP"))
          return this.cpReal();
        {
          this.pronominalizeChildren();
          const q = this.props.typ;
          q !== void 0 && this.processTyp(q);
          const W = this.elements;
          for (let G of W) {
            var N;
            N = G.isA("CP") ? G.cpReal() : G.isA("VP") && E ? G.vpReal() : G.real(), Array.prototype.push.apply(C, N);
          }
          this.isA("VP") && C.length > 1 && this.checkAdverbPos(C);
        }
        return this.doFormat(C);
      }
      toSource(C) {
        C === void 0 && (C = -1);
        let [N, q] = this.indentSep(C), W = this.constType + "(" + this.elementsSource.map((G) => G.toSource(N)).join(q) + ")";
        return W += super.toSource(), W;
      }
      toDebug(C) {
        C === void 0 && (C = -1);
        let [N, q] = this.indentSep(C, !0), W = this.constType;
        return this.peng !== void 0 && (this.peng.pengNO !== void 0 && (W += "#" + this.peng.pengNO), this.taux && this.taux.tauxNO !== void 0 && (W += "-" + this.taux.tauxNO)), W += "(" + this.elements.map((G) => G.toDebug(N)).join(q) + ")", W += super.toSource(), W;
      }
    }
    const jt = (K) => class extends pt(K) {
      link_DAV_properties(C) {
        C.isA("D") && C.lemma == "no" ? this.peng.n = "p" : (this.isA("A") || C.isA("D") && C.getProp("own") === void 0) && (C.peng = this.peng);
      }
      link_subj_obj_subordinate(C, N) {
        ["who", "which", "that"].includes(C.lemma) && (N.peng = this.peng, this.linkAttributes(N, this.getFromPath([["VP"], ["CP"]]), this));
      }
      linkAttributes(C, N, q) {
      }
      check_coordinated_object() {
      }
      pronominalize() {
        if (!this.isA("NP"))
          return this.warn("bad application", ".pro", ["NP"], this.constType);
        const C = this.parentConst;
        let N;
        if (C !== null) {
          let q = this, W = C.elements.findIndex((G) => G == q, this);
          C.getIndex("V"), N = this.peng == C.peng || C.isA("SP") && C.elements[0].isA("Pro") ? this.getTonicPro("nom") : this.getTonicPro("acc"), N.peng = this.peng, Object.assign(N.props, this.props), this.peng == C.peng && (C.peng = N.peng), C.removeElement(W), C.addElement(N, W);
        } else
          N = this.getTonicPro("nom"), N.props = this.props, N.peng = this.peng, this.elements = [N];
        return N;
      }
      passive_agree_auxiliary(C, N) {
      }
      processTyp_verb(C) {
        let N;
        if (this.isA("VP"))
          N = this;
        else {
          const W = this.getIndex(["VP"]);
          if (!(W >= 0))
            return this.warn("bad const for option", ".typ(" + JSON.stringify(C) + ")", this.constType, ["VP"]);
          N = this.elements[W];
        }
        const q = N.getIndex("V");
        if (q >= 0) {
          C.contr !== void 0 && C.contr !== !1 && (N.contraction = !0, this.contraction = !0);
          const W = this.affixHopping(N.elements[q], N.getProp("t"), g(this.lang).compound, C);
          N.removeElement(q);
          for (let G = 0; G < W.length; G++)
            N.addElement(W[G], q + G);
        } else
          this.warn("not found", "V", "VP");
      }
      move_object(C) {
        if (this.isA("S", "SP")) {
          let [N, q] = this.getIdxCtx("VP", "V");
          if (N !== void 0 && !["pp", "pr", "b-to"].includes(this.getProp("t"))) {
            const W = q[0].parentConst.removeElement(0);
            this.addElement(W, 0);
          }
        }
      }
      passive_subject_par(C, N) {
        return [C, N];
      }
      interrogative_pronoun_woi(C) {
        return C == "woi" ? "whom" : "what";
      }
      tag_question(C) {
        let N;
        const q = this.getFromPath(["VP", "V"]);
        if (q !== void 0) {
          N = "mod" in C && C.mod !== !1 ? g(this.lang).compound[C.mod].aux : ["have", "be", "can", "will", "shall", "may", "must"].includes(q.lemma) ? q.lemma : "do";
          let W = "neg" in C && C.neg === !0, G = q.getProp("pe"), nt = q.getProp("t"), ut = q.getProp("n"), gt = q.getProp("g"), At = Kt("I").pe(G).n(ut).g(gt);
          const Nt = this.getIndex(["NP", "N", "Pro", "SP"]);
          if (Nt >= 0) {
            const oe = this.getIndex(["VP", "V"]);
            if (oe >= 0 && Nt < oe) {
              const ie = this.elements[Nt];
              ie.isA("Pro") ? ie.getProp("pe") != 1 || N != "be" || nt != "p" || W ? ["this", "that", "nothing"].includes(ie.lemma) ? At = Kt("I").g("n") : ["somebody", "anybody", "nobody", "everybody", "someone", "anyone", "everyone"].includes(ie.lemma) ? (At = Kt("I").n("p"), ie.lemma == "nobody" && (W = !0)) : At = ie.clone() : G = 2 : (At = ie.clone().pro(), At.g(ie.getProp("g")).n(ie.getProp("n")));
            }
          } else
            nt == "ip" && (N == "do" && (N = "will"), At = Kt("I").pe(2).n(ut).g(gt));
          const Bt = q.parentConst.getConst("Adv");
          let Wt;
          Bt !== void 0 && ["hardly", "scarcely", "never", "seldom"].includes(Bt.lemma) && (W = !0), q.parentConst.a(","), Wt = N != "have" || W ? Xt(xt(N).t(nt).pe(G).n(ut), At).typ({ neg: !W, contr: !0 }) : Xt(xt("have").t(nt).pe(G).n(ut), Jt("not"), At).typ({ contr: !0 }), Wt.peng = At.peng, this.addElement(Wt);
        }
      }
    };
    class lt extends w {
      constructor(C, N, q) {
        if (super(N), this.lang = q || p(), this.dependents = [], this.terminal = ct("*terminal*"), C.length == 0)
          return this.warn("Dependent without params"), null;
        if (typeof C[0] == "string" ? this.terminal = ct(C.shift()) : C[0] instanceof at ? this.terminal = C.shift() : (this.warn("Dependent needs Terminal", C[0].constructor.name), C.shift()), this.terminal.parentConst = this, this.peng = this.terminal.peng, this.terminal.isA("V") && (this.taux = this.terminal.taux), C = ot(C), this.dependentsSource = [], C.length > 0) {
          const W = C.length - 1;
          for (let G = 0; G < W; G++) {
            let nt = C[G];
            nt instanceof lt ? (this.addDependent(nt), this.dependentsSource.push(nt)) : this.warn("bad Dependent", it(G + 2).dOpt({ ord: !0 }).realize(), nt.constructor.name + ":" + JSON.stringify(nt));
          }
          this.add(C[W], void 0, !0);
        }
      }
      addDependent(C, N) {
        return C instanceof lt ? (C.parentConst = this, N == null ? this.dependents.push(C) : typeof N == "number" && N <= this.dependents.length && N >= 0 ? this.dependents.splice(N, 0, C) : this.warn("bad position", N, this.dependents.length)) : this.warn("bad Dependent", it(N + 1).dOpt({ ord: !0 }).realize(), C.constructor.name), this;
      }
      removeDependent(C) {
        if (typeof C == "number" && C < this.dependents.length && C >= 0) {
          const N = this.dependents.splice(C, 1)[0];
          return N.parentConst = null, N;
        }
        return this.warn("bad position", C, this.dependents.length);
      }
      changeDeprel(C) {
        return this.isA("coord") ? this.dependents.forEach((N) => N.constType = C) : this.constType = C, this;
      }
      findIndex(C, N) {
        for (let q = N = N || 0; q < this.dependents.length; q++) {
          const W = this.dependents[q];
          if (W.isA("coord") && W.dependents.length > 0 && C(W.dependents[0]) || C(W))
            return q;
        }
        return -1;
      }
      add(C, N, q) {
        return C instanceof lt ? (q === void 0 ? this.optSource += ".add(" + C.toSource() + (N === void 0 ? "" : "," + N) + ")" : this.dependentsSource.push(C), this.addDependent(C, N), this.linkProperties(), this) : this.warn("bad Dependent", this.word_last(), C.constructor.name);
      }
      me() {
        let C = this.dependents.map(function(N) {
          return N.me();
        });
        return C.unshift(this.terminal.me()), this.constType + "(" + C.join() + ")";
      }
      setPengRecursive(C, N, q) {
        C.peng = q, C.terminal.peng && C.terminal.peng.pengNO == N && (C.terminal.peng = q);
        for (let W of C.dependents)
          this.setPengRecursive(W, N, q);
      }
      linkProperties() {
        if (this.dependents.length == 0)
          return this;
        const C = this.terminal;
        this.isA("coord") && (this.peng = { pengNO: w.pengNO++ }, C.peng = this.peng);
        for (const N of this.dependents) {
          const q = N.terminal;
          switch (N.constType) {
            case "subj":
              C.isA("V") && (C.peng = N.peng);
              break;
            case "det":
              q.isA("D") ? q.peng = this.peng : q.isA("NO") ? q.peng = C.peng : q.isA("P") && q.lemma == "de" && N.dependents.length == 1 && N.dependents[0].isA("mod") && N.dependents[0].terminal.isA("D") && (N.dependents[0].terminal.peng = this.peng);
              break;
            case "mod":
            case "comp":
              if (q.isA("A"))
                this.peng !== void 0 && (q.peng = this.peng), this.link_attributes(q, C);
              else if (q.isA("V")) {
                const W = N.findIndex((G) => G.isA("subj", "comp", "mod") && G.terminal.isA("Pro") && this.relative_pronouns().includes(G.terminal.lemma));
                W >= 0 && (N.dependents[W].constType == "subj" && (q.peng = this.peng), this.link_pp_before(N, C)), this.link_pp_with_head(q);
              } else if (q.isA("Pro") && this.relative_pronouns().includes(q.lemma)) {
                this.peng !== void 0 && (q.peng = this.peng);
                for (let W of N.dependents)
                  W.peng !== void 0 && this.setPengRecursive(W, W.peng.pengNO, this.peng);
              }
              break;
            case "root":
            case "*pre*":
            case "*post*":
              break;
            case "coord":
              if (N.dependents.length > 0) {
                const W = N.dependents[0];
                if (W.isA("subj"))
                  C.peng = N.peng;
                else if (W.isA("det"))
                  N.peng = C.peng;
                else if (W.isA("mod", "comp") && W.terminal.isA("V", "A")) {
                  N.peng = C.peng;
                  for (let G of N.dependents)
                    G.peng = C.peng, G.terminal.peng = C.peng;
                }
              }
              break;
            default:
              this.error("Strange dependent:" + N.constType);
          }
        }
      }
      setLemma(C, N) {
        return this.error("***: should never happen: setLemma: called on a Dependent"), this;
      }
      findGenderNumberPerson(C) {
        let N, q, W = 3, G = 0;
        for (let nt = 0; nt < this.dependents.length; nt++) {
          const ut = this.dependents[nt].terminal;
          if (ut.isA("N", "Pro", "Q", "NO")) {
            G += 1;
            const gt = ut.getProp("g");
            N === void 0 && gt !== void 0 && (N = gt), gt == "m" && (N = "m"), ut.getProp("n") == "p" && (q = "p");
            const At = ut.getProp("pe");
            At !== void 0 && At < W && (W = At);
          }
        }
        return G > 1 && C && (q = "p"), { g: N, n: q, pe: W };
      }
      pronominalizeChildren() {
        for (let C of this.dependents)
          C.props.pro !== !0 || C.terminal.isA("Pro") || C.pronominalize();
      }
      passivate() {
        let C, N, q;
        if (!this.terminal.isA("V"))
          return this.warn("not found", "V", this.passive_context());
        {
          const W = this.findIndex((nt) => nt.isA("subj"));
          if (W >= 0) {
            C = this.dependents[W];
            let nt = C.terminal;
            nt.isA("Pro") && (nt = this.passive_pronoun_subject(nt));
          } else
            C = null;
          const G = this.findIndex((nt) => nt.isA("comp") && nt.terminal.isA("N", "Pro"));
          G >= 0 ? (N = this.dependents[G], N.terminal.isA("Pro") ? N.terminal = N.terminal.getTonicPro("nom") : N.terminal.isA("N") && N.props.pro === !0 && (N = N.getTonicPro("nom")), N.changeDeprel("subj"), this.passive_should_link_subject() && (this.terminal.peng = N.peng), C != null && (C.changeDeprel("mod"), this.removeDependent(W), q = this.passive_prep(C.terminal.isA("V")), this.addDependent(dt(M(q, this.lang), C)))) : C != null && (N = Kt(this.passive_dummy_subject(), this.lang).c("nom"), C.changeDeprel("mod"), this.removeDependent(W), this.addPre(N), this.peng = N.peng, q = this.passive_prep(C.terminal.isA("V")), this.addDependent(dt(M(q, this.lang), C))), this.passive_agree_with_auxiliary(N);
        }
      }
      processV(C, N, q) {
        if (this.isA("coord"))
          this.dependents.forEach(function(W) {
            W.processV(C, q);
          });
        else if (this.terminal.isA("V")) {
          const W = C[N];
          W != null && W !== !1 && q(this, W);
        }
      }
      addPre(C, N) {
        C instanceof at && (C = [C]);
        for (let q of C)
          this.addDependent(qe("*pre*", [q]), N);
        return this;
      }
      addPost(C) {
        C instanceof at && (C = [C]);
        for (let N of C.reverse())
          this.addDependent(qe("*post*", [N]), 0);
        return this;
      }
      processTypInt(C) {
        const N = C.int, q = g(this.lang).sentence_type.int, W = q.prefix;
        let G, nt, ut = this.searchStart;
        switch (ut === void 0 && (ut = 0), N) {
          case "yon":
          case "how":
          case "why":
          case "muc":
            this.move_object(N), G = W[N];
            break;
          case "wos":
          case "was":
            let gt = this.findIndex((Bt) => Bt.isA("subj"), ut);
            gt >= 0 && (this.terminal.setProp("n", "s"), this.terminal.setProp("pe", 3), this.removeDependent(gt)), G = W[N];
            break;
          case "wod":
          case "wad":
            let At;
            for (let Bt = ut; Bt < this.dependents.length; Bt++) {
              const Wt = this.dependents[Bt];
              if (Wt.isA("comp") && Wt.terminal.isA("N") && Wt.findIndex((oe) => oe.terminal.isA("P") && oe.getProp("pos") == "pre") < 0) {
                At = this.removeDependent(Bt);
                break;
              }
            }
            nt = this.check_passive_subject_with_par(), G = this.passive_human_object(N, At) ? "whom" : W[N], this.move_object(N);
            break;
          case "woi":
          case "wai":
          case "whe":
          case "whn":
            let Nt = !1;
            G = W[N];
            for (let Bt = ut; Bt < this.dependents.length; Bt++) {
              const Wt = this.dependents[Bt];
              let oe;
              if (Wt.terminal.isA("P"))
                oe = Wt.terminal.lemma;
              else {
                const ie = Wt.findIndex((Ce) => Ce.terminal.isA("P") && Ce.getProp("pos") == "pre");
                ie >= 0 && (oe = Wt.dependents[ie].terminal.lemma);
              }
              if (Wt.isA("comp", "mod") && oe !== void 0) {
                const ie = this.preposition_list();
                if (N == "whe" && ie.whe.has(oe) || N == "whn" && ie.whn.has(oe) ? Nt = !0 : ie.all.has(oe) && (G = oe + " " + this.interrogative_pronoun_woi(int_), Nt = !0), Nt) {
                  this.removeDependent(Bt);
                  break;
                }
              }
            }
            this.move_object(N);
            break;
          case "tag":
            this.tag_question(C), G = W[N];
            break;
          default:
            this.warn("not implemented", "int:" + N);
        }
        this.should_add_interrogative_prefix(N) && this.addPre(ct(G), 0), nt !== void 0 && (this.addPre(nt, 0), N == "wad" && (this.dependents[1].terminal.lemma = "quoi")), this.a(q.punctuation, !0);
      }
      processTyp(C) {
        C.pas !== void 0 && C.pas !== !1 && this.passivate(), this.processTyp_verb(C), "int" in C && C.int !== !1 && this.processTypInt(C);
        const N = C.exc;
        return N !== void 0 && N === !0 && this.a(g(this.lang).sentence_type.exc.punctuation, !0), this;
      }
      coordReal() {
        let C = [];
        var N = this.dependents.length - 1;
        if (N == -1)
          return [];
        if (N == 0) {
          const gt = this.dependents[0];
          return C = gt.real(), this.setProp("g", gt.getProp("g")), this.setProp("n", gt.getProp("n")), this.setProp("pe", gt.getProp("pe") || 3), this.doFormat(C);
        }
        const q = this.dependents[0].constType, W = this.terminal.lemma == "";
        for (let gt = 0; gt < N; gt++) {
          const At = this.dependents[gt];
          (W || gt < N - 1) && (At.props.a !== void 0 && At.props.a.includes(",") || (At.props.a = [","])), At.isA("coord") ? C.push(...At.coordReal()) : At.isA(q) || q == "coord" ? C.push(...At.real()) : this.warn("inconsistent dependents within a coord", q, At.constType);
        }
        C.push(...this.terminal.real());
        const G = this.dependents[N];
        if (G.isA("coord"))
          return C.push(...G.coordReal()), this.doFormat(C);
        G.isA(q) || q == "coord" || this.warn("inconsistent dependents within a coord", q, G.constType), C.push(...G.real());
        const nt = this.terminal;
        if (nt.isA("C")) {
          const gt = this.and_conj();
          var ut = this.findGenderNumberPerson(nt.lemma == gt);
          ut.g !== void 0 && this.setProp("g", ut.g), ut.n !== void 0 && this.setProp("n", ut.n), this.setProp("pe", ut.pe), nt.pronoun !== void 0 && (nt.pronoun.peng = ut, nt.pronoun.props.g = ut.g, nt.pronoun.props.n = ut.n, nt.pronoun.props.pe = ut.pe);
        } else
          nt.isA("Q") || this.warn("bad parameter", "C", nt.constType);
        return this.doFormat(C);
      }
      depPosition() {
        let C = this.props.pos;
        return C !== void 0 || (C = "post", this.isA("subj", "det", "*pre*") ? C = "pre" : this.isA("mod") && this.terminal.isA("A") && this.parentConst.terminal.isA("N") ? C = this.terminal.props.pos || this.adj_def_pos() : this.isA("coord") && this.dependents.length > 0 && (C = this.dependents[0].depPosition())), C;
      }
      doFrenchPronounPlacement(C) {
        return doFrenchPronounPlacement(C);
      }
      real() {
        let C;
        if (this.isA("coord") && this.parentConst == null)
          C = this.coordReal();
        else {
          this.pronominalizeChildren();
          const N = this.props.typ;
          N !== void 0 && this.processTyp(N);
          const q = this.dependents;
          let W = 0;
          for (let G = 0; G < q.length; G++)
            q[G].depPosition() == "pre" && (W != G && q.splice(W, 0, q.splice(G, 1)[0]), W++);
          if (q.length == 0)
            C = this.terminal.real();
          else if (W == 0) {
            C = this.terminal.real();
            for (let G of q)
              C.push(...G.isA("coord") ? G.coordReal() : G.real());
          } else {
            C = [];
            for (let G = 0; G < q.length; G++) {
              const nt = q[G];
              C.push(...nt.isA("coord") ? nt.coordReal() : nt.real()), G == W - 1 && C.push(...this.terminal.real());
            }
          }
          this.terminal.isA("V") && this.checkAdverbPos(C);
        }
        return this.doFormat(C);
      }
      toSource(C) {
        C === void 0 && (C = -1);
        let [N, q] = this.indentSep(C), W = this.dependentsSource.map((nt) => nt.toSource(N));
        W.unshift(this.terminal.toSource());
        let G = this.constType + "(" + W.join(q) + ")";
        return G += w.prototype.toSource.call(this), G;
      }
      toDebug(C) {
        C === void 0 && (C = -1);
        let [N, q] = this.indentSep(C, !0), W = this.dependents.map((nt) => nt.toDebug(N));
        W.unshift(this.terminal.toDebug());
        let G = this.constType;
        return this.peng !== void 0 && (this.peng.pengNO !== void 0 && (G += "#" + this.peng.pengNO), this.taux && this.taux.tauxNO !== void 0 && (G += "-" + this.taux.tauxNO)), G += "(" + W.join(q) + ")", G += w.prototype.toDebug.call(this), G;
      }
    }
    It.prototype.toDependent = function(K) {
      function C(q, W, G) {
        return q < W ? G.isA("comp") ? G.pos("pre") : !G.isA("mod") || G.isEn() && G.terminal.isA("A") || G.pos("pre") : G.isA("subj", "det") && G.pos("post"), G;
      }
      let N;
      switch (K = K || "root", this.constType) {
        case "NP":
        case "VP":
        case "AP":
        case "PP":
        case "AdvP":
          N = function(ut, gt) {
            let At;
            const Nt = gt.substr(0, gt.length - 1), Bt = ut.getHeadIndex(gt);
            return ut.elements[Bt].isA(Nt) ? (At = qe(K, [ut.elements[Bt]]), ut.elements.forEach(function(Wt, oe) {
              if (oe != Bt) {
                const ie = Wt.toDependent(gt == "VP" ? "comp" : "mod");
                At.add(C(oe, Bt, ie), void 0, !0);
              }
            })) : console.log(`Phrase.toDependent:: ${gt} without ${Nt}`, ut.toSource()), At;
          }(this, this.constType);
          break;
        case "CP":
          const q = this.getIndex("C");
          q >= 0 ? (N = qe("coord", [this.elements[q]]), this.elements.forEach(function(ut, gt) {
            gt != q && N.add(ut.toDependent(K), void 0, !0);
          })) : console.log("Phrase.toDependent:: CP without C", this.toSource());
          break;
        case "S":
        case "SP":
          let W = this.getIndex("VP");
          N = W >= 0 ? this.elements[W].toDependent(K) : qe(K, [ct("")]);
          let G = -1;
          this.isA("SP") && this.isFr() && (G = this.getIndex(["Pro"]), G >= 0 && this.elements[G].lemma == "que" ? N.add(this.elements[G].toDependent("comp").pos("pre"), 0, !0) : G = -1);
          let nt = this.getIndex(["NP", "N", "CP", "Pro"]);
          this.elements.forEach(function(ut, gt) {
            if (gt != W && gt != G) {
              const At = ut.toDependent(gt == nt ? "subj" : "mod");
              N.add(C(gt, W, At), void 0, !0);
            }
          });
          break;
        default:
          console.log(`Phrase.toDependent:: ${this.constType} not yet implemented`);
      }
      return N.props = this.props, N.optSource = function q(W) {
        let G = W.indexOf(".add(");
        if (G < 0)
          return W;
        const nt = W.length;
        let ut = 1, gt = G + 5;
        for (; ut > 0 && gt < nt; ) {
          const At = W.charAt(gt);
          At == "(" ? ut++ : At == ")" && ut--, gt++;
        }
        return W.substring(0, G) + q(W.substring(gt));
      }(this.optSource), this.parentConst !== null || this.isA("S") || N.cap(!1), N;
    }, at.prototype.toDependent = function(K) {
      let C, N = this.parentConst === null;
      return C = this.isA("D", "NO") ? V(this) : qe(K || "root", [this]), N && C.cap(!1), C;
    };
    const L = (K) => class extends pt(K) {
      link_attributes(C, N) {
      }
      relative_pronouns() {
        return ["who", "that"];
      }
      link_pp_before(C, N) {
      }
      link_pp_with_head(C) {
      }
      passive_agree_with_auxiliary(C) {
      }
      check_passive_subject_with_par() {
      }
      pronominalize() {
        let C;
        this.props.pe = 3, C = this.parentConst === null || this.isA("subj") ? this.getTonicPro("nom") : this.getTonicPro("acc"), C.peng = this.peng, C.parentConst = this, this.terminal = C, this.dependents = [], this.dependentsSource = [];
      }
      processTyp_verb(C) {
        C.contr !== void 0 && C.contr !== !1 && (this.contraction = !0);
        const N = this.affixHopping(this.terminal, this.getProp("t"), g(this.lang).compound, C);
        let q = N.pop();
        q.isA("Pro") && q.lemma == "myself" && (this.addPost(q), q = N.pop()), this.terminal = q, this.addPre(N);
      }
      move_object(C) {
        let N = this.findIndex((q) => q.isA("*pre*"));
        if (N >= 0 && !["pp", "pr"].includes(this.getProp("t"))) {
          const q = this.dependents[N].terminal;
          this.removeDependent(N), this.addPre(q, 0);
        } else if (["be", "have"].includes(this.terminal.lemma)) {
          const q = this.findIndex((W) => W.isA("subj"));
          q >= 0 && this.dependents[q].pos("post");
        } else
          this.dependents.length == 0 && this.addDependent(dt(xt("do").pe(3).t("p")));
      }
      tag_question(C) {
        let N;
        const q = this.findIndex((ie) => ie.terminal.isA("V") && ie.depPosition() == "pre"), W = q < 0 ? this.terminal : this.dependents[q].terminal;
        N = "mod" in C && C.mod !== !1 ? g(this.lang).compound[C.mod].aux : ["have", "be", "can", "will", "shall", "may", "must"].includes(W.lemma) ? W.lemma : "do";
        let G = "neg" in C && C.neg === !0, nt = W.getProp("pe"), ut = W.getProp("t"), gt = W.getProp("n"), At = W.getProp("g"), Nt = Kt("I").pe(nt).n(gt).g(At);
        const Bt = this.findIndex((ie) => ie.isA("mod") && ie.terminal.isA("Adv"));
        Bt >= 0 && ["hardly", "scarcely", "never", "seldom"].includes(this.dependents[Bt].terminal.lemma) && (G = !0);
        let Wt = this.findIndex((ie) => ie.isA("subj"));
        if (Wt >= 0) {
          const ie = this.dependents[Wt].terminal;
          ie.isA("Pro") ? (ie.getProp("pe") != 1 || N != "be" || ut != "p" || G ? ["this", "that", "nothing"].includes(ie.lemma) ? Nt = Kt("I").g("n") : ["somebody", "anybody", "nobody", "everybody", "someone", "anyone", "everyone"].includes(ie.lemma) ? (Nt = Kt("I").n("p"), ie.lemma == "nobody" && (G = !0)) : Nt = ie.clone() : nt = 2, Nt = T(Nt).pos("post")) : ie.isA("N") ? (Nt = this.dependents[Wt].clone().pro().pos("post"), Nt.g(ie.getProp("g")).n(ie.getProp("n"))) : Nt = T(Kt("it").c("nom")).pos("post");
        } else
          ut == "ip" ? (N == "do" && (N = "will"), Nt = Kt("I").pe(2).n(gt).g(At)) : Nt = Kt("it").c("nom"), Nt = T(Nt).pos("post");
        let oe = this.dependents.length - 1;
        for (; oe >= 0 && this.dependents[oe].depPosition() != "post"; )
          oe--;
        oe < 0 ? W.a(",") : this.dependents[oe].a(","), N != "have" || G ? this.addDependent(dt(xt(N).t(ut).pe(nt).n(gt), Nt).typ({ neg: !G, contr: !0 })) : this.addDependent(dt(xt("have").t(ut).pe(nt).n(gt), H(Jt("not")), Nt).typ({ contr: !0 }));
      }
    }, D = ["N", "A", "Pro", "D", "V", "Adv", "C", "P", "DT", "NO", "Q"], tt = ["S", "NP", "AP", "VP", "AdvP", "PP", "CP", "SP"], et = ["root", "det", "subj", "comp", "mod", "coord"];
    function st(K, C) {
      if (typeof K != "object" || Array.isArray(K))
        console.log("fromJSON: object expected, but found " + typeof K + ":" + JSON.stringify(K));
      else if (K.lang && (K.lang == "en" ? C = "en" : K.lang == "fr" ? C = "fr" : (console.log("FromJSON: lang should be 'en' or 'fr', not " + K.lang + " 'en' will be used"), C = "en")), "phrase" in K) {
        const N = K.phrase;
        if (tt.includes(N))
          return It.fromJSON(N, K, C);
        console.log("fromJSON: unknown Phrase type:" + N);
      } else if ("dependent" in K) {
        const N = K.dependent;
        if (et.includes(N))
          return lt.fromJSON(N, K, C);
        console.log("fromJSON: unknown Phrase type:" + N);
      } else if ("terminal" in K) {
        const N = K.terminal;
        if (D.includes(N))
          return at.fromJSON(N, K, C);
        console.log("fromJSON: unknown Terminal type:" + N);
      }
    }
    function X(K, C, N) {
      function q(nt) {
        N += nt;
      }
      function W(nt) {
        nt.includes("\\") && (nt = nt.replace(/\\/g, "\\\\")), nt.includes('"') && (nt = nt.replace(/"/g, '\\"')), q('"' + nt + '"');
      }
      switch (arguments.length) {
        case 1:
          return X(K, 0, "");
        case 2:
          return X(K, C, "");
        default:
          switch (typeof K) {
            case "string":
              W(K);
              break;
            case "object":
              if (K === null)
                q("null");
              else if (Array.isArray(K)) {
                q("[");
                const nt = K.length, ut = K.some((gt) => typeof gt == "object" && gt !== null);
                for (var G = 1; G <= nt; G++) {
                  const gt = K[G - 1];
                  ut && G > 1 && q(`
` + " ".repeat(C + 1)), q(X(gt, C + 1, "")), G < nt && q(",");
                }
                q("]");
              } else {
                q("{");
                const nt = Object.keys(K), ut = nt.length;
                for (G = 1; G <= ut; G++) {
                  const gt = nt[G - 1];
                  G > 1 && q(`
` + " ".repeat(C + 1)), W(gt), q(":"), q(X(K[gt], C + 1 + gt.length + 3, "")), G < ut && q(",");
                }
                q("}");
              }
              break;
            default:
              q(K);
          }
      }
      return N;
    }
    function ot(K) {
      let C = [];
      for (const N of K)
        N != null && (Array.isArray(N) ? Array.prototype.push.apply(C, ot(N)) : C.push(N));
      return C;
    }
    function mt(K, C = !1) {
      K == "en" ? c(C) : ct(K).warn("bad language", K);
    }
    w.prototype.setJSONprops = function(K) {
      if ("props" in K) {
        const C = K.props;
        for (let N in C)
          N in this ? Array.isArray(C[N]) ? C[N].forEach((q) => Array.isArray(q) ? w.prototype[N].apply(this, q) : w.prototype[N].call(this, q)) : w.prototype[N].call(this, C[N]) : ["pat", "h"].includes(N) || console.log("Constituent.fromJSON: illegal prop:" + N);
      }
      return this;
    }, It.fromJSON = function(K, C, N) {
      if ("elements" in C) {
        const q = C.elements;
        if (Array.isArray(q)) {
          const W = q.map((G) => st(G, N));
          return new Et(W, K, "en").setJSONprops(C);
        }
        console.log("Phrase.fromJSON: elements should be an array:" + JSON.stringify(C));
      } else
        console.log("Phrase.fromJSON: no elements found in " + JSON.stringify(C));
    }, lt.fromJSON = function(K, C, N) {
      if ("terminal" in C)
        if ("dependents" in C) {
          const q = C.dependents;
          if (Array.isArray(q)) {
            let W = q.map((G) => st(G, N));
            return W.unshift(st(C.terminal, N)), new ps(W, K, "en").setJSONprops(C);
          }
          console.log("Dependent.fromJSON: dependents should be an array:" + JSON.stringify(C));
        } else
          console.log("Dependent.fromJSON: no dependents found in " + JSON.stringify(C));
      else
        console.log("Dependent.fromJSON: no terminal found in Dependent:" + JSON.stringify(C));
    }, at.fromJSON = function(K, C, N) {
      if ("lemma" in C)
        return new wt([C.lemma, "en"], K).setJSONprops(C);
      console.log("Terminal.fromJSON: no lemma found in " + JSON.stringify(C));
    }, It.prototype.toJSON = function() {
      let K = { phrase: this.constType, elements: this.elements.map((C) => C.toJSON()) };
      return Object.keys(this.props).length > 0 && (K.props = this.props), this.parentConst != null && this.lang == this.parentConst.lang || (K.lang = this.lang), K;
    }, lt.prototype.toJSON = function() {
      let K = { dependent: this.constType, terminal: this.terminal.toJSON() };
      return this.dependents && (K.dependents = this.dependents.map((C) => C.toJSON())), Object.keys(this.props).length > 0 && (K.props = this.props), this.parentConst != null && this.lang == this.parentConst.lang || (K.lang = this.lang), K;
    }, at.prototype.toJSON = function() {
      let K = { terminal: this.constType, lemma: this.lemma };
      return Object.keys(this.props).length > 0 && (K.props = this.props), this.parentConst != null && this.lang == this.parentConst.lang || (K.lang = this.lang), K;
    };
    let U = /* @__PURE__ */ new Map();
    function J(K) {
      Array.isArray(K) || (K = Array.from(arguments));
      const C = K.length, N = K.toString();
      let q, W;
      if (U.has(N)) {
        let nt = U.get(N);
        if (nt.length < C) {
          q = [];
          for (let ut = 0; ut < C; ut++)
            nt.indexOf(ut) < 0 && q.push(ut);
        } else {
          const ut = nt[nt.length - 1];
          q = [...Array(C).keys()], q.splice(ut, 1), nt.splice(0);
        }
        W = q[Math.floor(Math.random() * q.length)], nt.push(W);
      } else
        q = [...Array(C).keys()], W = q[Math.floor(Math.random() * q.length)], U.set(N, [W]);
      const G = K[W];
      return typeof G == "function" ? G() : G;
    }
    function St(K) {
      for (let C = (K = Array.isArray(K) ? [...K] : Array.from(arguments)).length - 1; C > 0; C--) {
        const N = Math.floor(Math.random() * (C + 1));
        [K[C], K[N]] = [K[N], K[C]];
      }
      return K.map((C) => typeof C == "function" ? C() : C);
    }
    const Rt = "5.0.1", zt = "2025-09-04, 5:12:12 p.m.", Tt = typeof process < "u" && ((r = process == null ? void 0 : process.versions) == null ? void 0 : r.node);
    let Yt, Zt = !1;
    function kt(K) {
      Zt = K;
    }
    function _e() {
      Yt = [];
    }
    function Ye() {
      return Yt || [];
    }
    class wt extends vt(at) {
    }
    function le(K, C) {
      return C.length == 1 ? p() : C[1], new wt(C, K);
    }
    function te(...K) {
      return le("N", K);
    }
    function Se(...K) {
      return le("A", K);
    }
    function Kt(...K) {
      return le("Pro", K);
    }
    function bt(...K) {
      return le("D", K);
    }
    function xt(...K) {
      return le("V", K);
    }
    function Jt(...K) {
      return le("Adv", K);
    }
    function k(...K) {
      return le("C", K);
    }
    function M(...K) {
      return le("P", K);
    }
    function B(...K) {
      return le("DT", K);
    }
    function it(...K) {
      return le("NO", K);
    }
    function ct(...K) {
      return le("Q", K);
    }
    class Et extends jt(Ct(It)) {
    }
    function Mt(K, C) {
      return new Et(C, K, "en");
    }
    function se(...K) {
      return Mt("S", K);
    }
    function de(...K) {
      return Mt("NP", K);
    }
    function ke(...K) {
      return Mt("AP", K);
    }
    function Xt(...K) {
      return Mt("VP", K);
    }
    function ze(...K) {
      return Mt("AdvP", K);
    }
    function We(...K) {
      return Mt("PP", K);
    }
    function pr(...K) {
      return Mt("CP", K);
    }
    function Yr(...K) {
      return Mt("SP", K);
    }
    class ps extends L(Ct(lt)) {
    }
    function qe(K, C) {
      return new ps(C, K, "en");
    }
    function Vi(...K) {
      return qe("root", K);
    }
    function T(...K) {
      return qe("subj", K);
    }
    function V(...K) {
      return qe("det", K);
    }
    function H(...K) {
      return qe("mod", K);
    }
    function dt(...K) {
      return qe("comp", K);
    }
    function ft(...K) {
      return qe("coord", K);
    }
    return i;
  })());
})(pN);
var xl = pN.exports;
let Fut = class extends Error {
  constructor() {
    super("The first array in a zipped array must not be longer than the second.");
  }
};
function $ut(e, t) {
  if (e.length > t.length)
    throw new Fut();
  return e.map(function(r, n) {
    return [r, t[n]];
  });
}
var or;
((e) => {
  class t extends Error {
  }
  class r extends xl.Terminal_en {
    clone() {
      const F = new this.constructor(this.lemma);
      let Y = this.toJSON();
      return F.setJSONprops(Y), F;
    }
    after(F) {
      return this.a(F.lemma);
    }
    before(F) {
      return this.b(F.lemma);
    }
  }
  e.Terminal = r;
  class n extends r {
    /**
     * Constructs a noun object
     * @param {string} lemma - The base noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "N");
    }
  }
  e.Noun = n;
  class i extends n {
    /**
     * Constructs a proper noun object
     * @param {string} lemma - The base proper noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super(F), this.cap();
    }
  }
  e.ProperNoun = i;
  class s extends r {
    /**
     * Constructs a verb object
     * @param {string} lemma - The base verb to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "V");
    }
    t(F) {
      return F === "present" && (F = "p"), F === "past" && (F = "ps"), F === "future" && (F = "f"), F === "present-participle" && (F = "pr"), F === "past-participle" && (F = "pp"), r.prototype.t.call(this, F);
    }
    /**
     * Provides shorthand for past tense
     */
    past() {
      return this.t("past");
    }
    /**
     * Provides shorthand for present tense
     */
    present() {
      return this.t("present");
    }
    /**
     * Provides shorthand for future tense
     */
    future() {
      return this.t("future");
    }
  }
  e.Verb = s;
  class o extends r {
    /**
     * Constructs an adjective object
     * @param {string} lemma - The base adjective to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "A");
    }
  }
  e.Adjective = o;
  class a extends r {
    /**
     * Constructs a determiner object
     * @param {string} lemma - The base noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "D");
    }
  }
  e.Determiner = a;
  class l extends r {
    /**
     * Constructs a conjunction object
     * @param {string} lemma - The base conjunction to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "C");
    }
  }
  e.Conjunction = l;
  class c extends r {
    /**
     * Constructs a preposition object
     * @param {string} lemma - The base preposition to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "P");
    }
  }
  e.Preposition = c;
  class h extends r {
    /**
     * Constructs a pronoun object
     * @param {string} lemma - The base pronoun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "Pro");
    }
  }
  e.Pronoun = h;
  class u extends r {
    /**
     * Constructs an adverb object
     * @param {string} lemma - The base adverb to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "Adv");
    }
  }
  e.Adverb = u;
  class p extends r {
    /**
     * Constructs a noun object
     * @param {string | Date} lemma - The base date to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      F === void 0 ? super([], "DT") : super([F], "DT");
    }
  }
  e.DateNoun = p;
  class y extends r {
    /**
     * Constructs a noun object
     * @param {string} lemma - The base noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "NO");
    }
  }
  e.NumberNoun = y;
  class g extends r {
    /**
     * Constructs a quoted raw text object
     * @param {string} text - The base text to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F) {
      super([F], "Q");
    }
  }
  e.Quote = g;
  class b extends xl.Phrase_en {
    constructor(F, Y) {
      F = F.filter((rt) => rt != null), super(F, Y, "en");
    }
    clone() {
      const F = this.elements.map((at) => at.clone()), Y = new this.constructor(F);
      let rt = this.toJSON();
      return Y.setJSONprops(rt), Y;
    }
    after(F) {
      return this.a(F.lemma);
    }
    before(F) {
      return this.b(F.lemma);
    }
    realize(F) {
      return super.realize(F).replaceAll(" ,", ",");
    }
  }
  e.Phrase = b;
  class f extends b {
    /**
     * Constructs a noun phrase object
     * @param {MaybeConstituent[]} elements - The elements of the noun phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...F) {
      super(F, "NP");
    }
    /**
     * Finds the determiner of the NP, if it has one
     * NOTE: this method assumes that, if an NP has a determiner, then it has a single D element at
     * the top level
     * @returns {Determiner | null} The NP's determiner, if it has one, and null otherwise
     */
    getDeterminer() {
      for (const F of this.elements)
        if (F instanceof a)
          return F;
      return null;
    }
    /**
     * Finds the head noun of the NP
     * NOTE: as an NP object may contain NP objects as constituents, this method can recurse through
     * the constituent tree
     * @returns {Noun} The NP's head noun
     */
    getHeadNoun() {
      const F = this.elements[this.getHeadIndex("NP")];
      return F instanceof f ? F.getHeadNoun() : F;
    }
    /**
     * Given this NP, supposing it has a CP of NPs as its first element, repeatedly factorizes common
     * elements out of the CP, and returns a simplified NP. If simplification isn't possible, no change
     * is made.
     * @param {Boolean} oxford Whether the CP should use the Oxford comma.
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    factorize(F = !1) {
      if (!(this.elements[0] instanceof w))
        throw new t("only NPs of the form NP(CP(...), ...) can be simplified");
      let Y = this.elements[0];
      const rt = [], at = [];
      let pt = !1;
      for (; !pt; ) {
        const vt = Y.factorize();
        if (vt.length)
          vt[0] instanceof w ? (Y = vt[0], at.unshift(vt[1])) : (rt.push(vt[0]), Y = vt[1]);
        else {
          let _t = Y.clone();
          F && _t.oxfordify(), rt.push(_t), pt = !0;
        }
      }
      return new f(...rt, ...at);
    }
  }
  e.NounPhrase = f;
  class E extends b {
    /**
     * Constructs an adjective phrase object
     * @param {MaybeConstituent[]} elements - The elements of the adjective phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...F) {
      super(F, "AP");
    }
  }
  e.AdjPhrase = E;
  class A extends b {
    /**
     * Constructs a verb phrase object
     * @param {MaybeConstituent[]} elements - The elements of the verb phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...F) {
      super(F, "VP");
    }
  }
  e.VerbPhrase = A;
  class x extends b {
    /**
     * Constructs a prepositional phrase object
     * @param {MaybeConstituent[]} elements - The elements of the prepositional phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...F) {
      super(F, "PP");
    }
  }
  e.PrepPhrase = x;
  class m extends b {
    /**
     * Constructs an adverbal phrase object
     * @param {MaybeConstituent[]} elements - The elements of the adverbal phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...F) {
      super(F, "AdvP");
    }
  }
  e.AdvPhrase = m;
  class w extends b {
    /**
     * Constructs a coordinated phrase object
     * @param {MaybeConstituent[]} elements - The elements of the coordinated phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...F) {
      super(F, "CP");
    }
    /**
     * Adds an Oxford Comma to this CP; does nothing if the phrase has < 3 constituents, an Oxford Comma
     * is already present, or this CP doesn't begin with a C or a Q.
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    oxfordify() {
      if (this.elements[0] instanceof l || this.elements[0] instanceof g) {
        const F = this.elements.slice(1);
        if (F.length > 2) {
          const Y = F[F.length - 2];
          (!Y.props.a || !Y.props.a.includes(",")) && Y.a(",");
        }
      }
      return this;
    }
    /**
     * Factorizes a common element out of this CP. Only possible when this CP is composed of NPs.
     * @returns {[AdjPhrase, CoordPhrase] | [CoordPhrase, Noun] | []}
     * Factorized sequence of common element + CP (in whichever order is appropriate), or the empty array if
     * no factorization was possible. Specifically:
     * 1: [factored-out common AP, remaining CP(conj, NP+)]
     * 2: [remaining CP(conj, N+), factored-out common head N]
     * 3: []
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    factorize() {
      let F = null, Y = null;
      if (this.elements[0] instanceof l || this.elements[0] instanceof g ? (F = this.elements[0], Y = this.elements.slice(1)) : Y = this.elements, !Y.every((rt) => rt instanceof f))
        throw new t("all CP elements must be NPs");
      if (Y = Y, Y.every((rt) => rt.elements[0] instanceof E && rt.elements.slice(1).every((at) => at instanceof n))) {
        const rt = Y[0].elements[0];
        if (Y.every((at) => R(at.elements[0], rt))) {
          const at = Y.map((pt) => new f(...pt.elements.slice(1)));
          return F && at.unshift(F), [rt.clone(), new w(...at)];
        }
      } else if (Y.every((rt) => rt.elements.length > 1 && rt.elements.every((at) => at instanceof n))) {
        const rt = Y[0], at = rt.elements[rt.elements.length - 1];
        if (Y.every(
          (pt) => R(pt.elements[pt.elements.length - 1], at)
        )) {
          const pt = Y.map((vt) => new f(...vt.elements.slice(0, -1)));
          return F && pt.unshift(F), [new w(...pt), at.clone()];
        }
      } else {
        if (Y.every((rt) => rt.elements.length === 1 && rt.elements[0] instanceof n))
          return [];
        throw new t("unrecognized CP structure");
      }
      return [];
    }
  }
  e.CoordPhrase = w;
  class _ extends b {
    /**
     * Constructs an subordinated phrase object.
     * NOTE: `restrictive` should be necessary, but is needed because `.b(',')` does
     *   not work properly in JSRealB. See: https://github.com/rali-udem/jsRealB/issues/54
     * @param {boolean} restrictive - Whether the subordinated phrase is restrictive
     * @param {MaybeConstituent[]} elements - The elements of the subordinated phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(F, ...Y) {
      super(Y, "SP"), this.restrictive = F;
    }
  }
  e.SubordPhrase = _;
  class S extends b {
    /**
     * Constructs a sentence object
     * @param {MaybeConstituent[]} elements - The elements of the sentence
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...F) {
      super(F, "S");
    }
    // (@simonvarey): This override is necessary as a workaround for a JSRealB design decision. See
    //   rali-udem/jsRealB#56 and theseusaurus#57. Note that it will fail if the sentence has more 
    //   than one tag: see theseusaurus#58.
    realize(F) {
      let Y = super.realize(F);
      if ("tag" in this.props) {
        const rt = `</${this.props.tag[0][0]}>`;
        Y = Y.slice(0, -rt.length) + `.${rt} `;
      }
      return Y;
    }
  }
  e.Sentence = S;
  function R(z, F) {
    return z.lang === F.lang && z.constType === F.constType ? z instanceof p ? (F = F, $(z.props.dOpt, F.props.dOpt) ? !1 : O(z, F)) : z instanceof b ? (F = F, z.elements.length !== F.elements.length || $ut(z.elements, F.elements).some((Y) => !R(Y[0], Y[1])) ? !1 : O(z, F)) : z.lemma === F.lemma && O(z, F) : !1;
  }
  e.compareNodes = R;
  function O(z, F) {
    for (const Y of Object.keys(z.props))
      if (Y !== "dOpt" && z.getProp(Y) !== F.getProp(Y))
        return !1;
    return !0;
  }
  function $(z, F) {
    if (F === void 0 || Object.keys(z).length !== Object.keys(F).length)
      return !1;
    for (const Y of Object.keys(z))
      if (z[Y] !== F[Y])
        return !1;
    return !0;
  }
})(or || (or = {}));
const Yd = class pi {
  /*resetSavedWarnings: any;
  getSavedWarnings: any;*/
  /*ppJSON: any;
  jsRealB_version: any;
  jsRealB_dateCreated: any;
  lexiconEn: any;
  loadEn: any;
  lexiconFr: any;
  loadFr: any;*/
  /**
   * Proxies each function of jsRealB as a function of the Theseusaurus class, with options for extension.
   * @constructor
   */
  constructor() {
    uo(this, "oneOf"), uo(this, "setExceptionOnWarning"), this.oneOf = xl.oneOf, this.setExceptionOnWarning = xl.setExceptionOnWarning;
  }
  /**
   * Initializes the Theseusaurus object.
   * @private
   * @memberOf module:@fizz/theseusaurus
   */
  async init() {
    await xl.loadEn(), this._updateLexicon();
  }
  // Helper Functions
  static _addDefToLexicon(t, r, n) {
    const i = {
      N: "n1",
      A: "a1",
      Adv: "b1",
      V: "",
      D: "",
      C: "",
      P: "",
      Pro: "",
      DT: "",
      NO: "",
      Q: ""
    }, s = pi.getLemma(t, "en");
    let o;
    if (s !== void 0) {
      if (s[r] !== void 0) {
        const a = s[r].tab;
        a !== n && n !== "default" && console.warn(`[Theseusaurus]: a different definition of ${t} as a ${r} already exists in the lexicon. Old def: ${a}. New def: ${n}`);
        return;
      }
      n = n === "default" ? i[r] : n, o = { ...s, [r]: { tab: n } };
    } else
      n = n === "default" ? i[r] : n, o = { [r]: { tab: n } };
    pi.addToLexicon(t, o, "en");
  }
  /**
   * Adds chart-specific words and grammar rules to default lexicon.
   * @private
   * @memberOf module:@fizz/theseusaurus
   * NOTE: Previously, 'rising' and 'falling' were added to the lexicon here as adjectives. However,
   *       they are available as the present participle (code: 'pr') forms of the verbs 'rise' and 'fall'.
   */
  _updateLexicon() {
    pi._addDefToLexicon("high", "N", "n1"), pi._addDefToLexicon("x-axis", "N", "n8"), pi._addDefToLexicon("y-axis", "N", "n8"), pi._addDefToLexicon("which", "Adv", "b1"), pi._addDefToLexicon("whose", "Adv", "b1"), pi._addDefToLexicon("what", "Adv", "b1"), pi._addDefToLexicon("worldwide", "Adv", "b1");
  }
  /**
   * Composes a list of words from an array into a coordinated phrase.
   * TODO(?): Allow phrases to be members of the list
   * @param {string[]} wordArray An array of words.
   * @param {new (lemma:string): Terminal} partOfSpeech A terminal constructor for the words with their
   *  part of speech.
   * @param {string} [conjunction] An optional conjunction, such as 'and' (default), 'or', 'nor', 'and then',
   *  or ''; if the empty string, this will make a list without a conjunction.
   * @returns {CoordPhrase} A coordinated phrase. with the tagged words joined with commas and an optional
   *  conjunction.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  composeList(t, r, n = "and") {
    const i = t.slice().map((a) => r(a));
    let s;
    n.includes(" ") ? s = this.Q(n) : n ? s = this.C(n) : s = null;
    const o = this.CP(s, ...i);
    return o.oxfordify(), o;
  }
  // Constituents
  /**
   * Extends the N (noun) function with optional declension parameter
   * @param {string} lemma - The base noun to be processed
   * @param {GramNumber} number - The grammatical number of the noun (e.g. singular/plural). Default is 'singular' ('s').
   * @returns {Noun} - The noun object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  N(t, r = "s", n) {
    n && pi._addDefToLexicon(t, "N", "default");
    const i = new or.Noun(t);
    return i.n(r), i;
  }
  /**
   * Extends the PN (proper noun) function with optional declension parameter
   * @param {string} lemma - The base noun to be processed
   * @param {GramNumber} number - The grammatical number of the noun (e.g. singular/plural). Default is 'singular' ('s').
   * @returns {ProperNoun} - The noun object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  PN(t, r = "s") {
    pi._addDefToLexicon(t, "N", "default");
    const n = new or.ProperNoun(t);
    return n.n(r), n;
  }
  /**
   * Extends the V (verb) function with optional tense parameter
   * @param {string} lemma - The base verb to be processed
   * @param {Tense} tense - The tense of the verb. Default is 'present' ('p').
   * @param {GramNumber} number - The number of the verb. Default is 'singular' ('s'). In English, this is only
   *  relevant for 'is'/'are'.
   * @returns {Verb} - The verb function object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  V(t, r = "p", n = "s") {
    return new or.Verb(t).t(r).n(n);
  }
  /**
   * Extends the A (adjective) function
   * @param {string} lemma - The base adjective to be processed
   * @param {boolean | undefined} addToLexicon - Optional parameter stating whether to add lemma
   *  to lexicon if it does not already exist.
   * @returns {Adjective} - The adjective function object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  A(t, r) {
    return r && pi._addDefToLexicon(t, "A", "default"), new or.Adjective(t);
  }
  /**
   * Extends the D (determiner) function
   * @param {string} lemma - The base determiner to be processed
   * @returns {Determiner} - The determiner object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  D(t) {
    return new or.Determiner(t);
  }
  /**
   * Extends the C (conjunction) function
   * @param {string} lemma - The base conjunction to be processed
   * @returns {Conjunction} - The conjunction object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  C(t) {
    return new or.Conjunction(t);
  }
  /**
   * Extends the P (preposition) function
   * @param {string} lemma - The base preposition to be processed
   * @returns {Preposition} - The preposition object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  P(t) {
    return new or.Preposition(t);
  }
  /**
   * Extends the Adv (adverb) function
   * @param {string} lemma - The base adverb to be processed
   * @returns {Adverb} - The adverb object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  Adv(t) {
    return new or.Adverb(t);
  }
  /**
   * Extends the Pro (pronoun) function
   * @param {string} lemma - The base pronoun to be processed
   * @returns {Pronoun} - The pronoun object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  Pro(t) {
    return new or.Pronoun(t);
  }
  /**
   * Extends the Q (quote) function
   * @param {string} lemma - The raw text to be processed
   * @returns {Quote} - The quote object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  Q(t) {
    return new or.Quote(t);
  }
  /**
   * Extends the NP (noun phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the noun phrase
   * @returns {NounPhrase} - The noun phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  NP(...t) {
    return new or.NounPhrase(...t);
  }
  /**
   * Extends the VP (verb phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the verb phrase
   * @returns {VerbPhrase} - The verb phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  VP(...t) {
    return new or.VerbPhrase(...t);
  }
  /**
   * Extends the AP (adjective phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the adjective phrase
   * @returns {AdjPhrase} - The adjective phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  AP(...t) {
    return new or.AdjPhrase(...t);
  }
  /**
   * Extends the PP (prepositional phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the prepositional phrase
   * @returns {PrepPhrase} - The prepositional phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  PP(...t) {
    return new or.PrepPhrase(...t);
  }
  /**
   * Extends the AdvP (adverbial phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the adverbial phrase
   * @returns {AdvPhrase} - The adverbial phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  AdvP(...t) {
    return new or.AdvPhrase(...t);
  }
  /**
   * Extends the CP (coordinated phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the coordinated phrase
   * @returns {CoordPhrase} - The coordinated phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  CP(...t) {
    return new or.CoordPhrase(...t);
  }
  /**
   * Extends the DT (date) function with year-only handling and optional preposition parameter
   * @param {string | number | Date} lemma - The base date to be processed
   * @param {string} opt - Options for formating. If 'p' is value, will add a preposition to a year-only lemma.
   * @returns {DateNoun} - The date object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  DT(t, r) {
    let n;
    if (t === void 0)
      n = new or.DateNoun();
    else if (t instanceof Date)
      n = new or.DateNoun(t);
    else {
      const s = t.toString();
      if (s.match(/^\d+$/)) {
        const o = `${s}/01/01`;
        n = new or.DateNoun(o).dOpt({
          year: !0,
          month: !1,
          date: !1,
          day: !1,
          hour: !1,
          minute: !1,
          second: !1,
          rtime: !1
        });
      } else
        n = new or.DateNoun(s);
    }
    let i = !1;
    return r === "p" && (i = !0), n.dOpt({ nat: i, det: i });
  }
  /**
   * Extends the NO (number) function
   * @param {number} number - The base number to be processed
   * @returns {NumberNoun} - The number object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  NO(t) {
    const r = t.toString();
    return new or.NumberNoun(r).dOpt({ raw: !0 });
  }
  /**
   * Extends the SP (subordinated phrase) function
   * NOTE: `restrictive` should be necessary, but is needed because `.b(',')` does
   *   not work properly in JSRealB. See: https://github.com/rali-udem/jsRealB/issues/54
   * @param {boolean} restrictive - Whether the subordinated phrase is restrictive
   * @param {Constituent[]} constituents - The constituents of the subordinated phrase
   * @returns {SubordPhrase} - The subordinated phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  SP(t, ...r) {
    return new or.SubordPhrase(t, ...r);
  }
  /**
   * Extends the S (sentence) function
   * @param {Constituent[]} constituents - The constituents of the sentence
   * @returns {Sentence} - The sentence object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  S(...t) {
    return new or.Sentence(...t);
  }
};
uo(Yd, "fromJSON", xl.fromJSON), uo(Yd, "addToLexicon", xl.addToLexicon), uo(Yd, "getLemma", xl.getLemma), /**
* Compares two syntax tree nodes for equality.
* @param {Constituent} nodeA First node to check.
* @param {Constituent} nodeB Second node to check.
* @returns {boolean} Equality test result.
* @public
* @memberOf module:@fizz/theseusaurus
*/
uo(Yd, "compareNodes", or.compareNodes);
let zut = Yd;
function bi(e, t, r, n, i) {
  return da(t, ((s, o) => {
    const a = s[o];
    if (a === void 0)
      throw new TypeError(NE(o));
    return a;
  })(e, t), r, n, i);
}
function da(e, t, r, n, i, s) {
  const o = Kf(t, r, n);
  if (i && t !== o)
    throw new RangeError(kD(e, t, r, n, s));
  return o;
}
function si(e) {
  return e !== null && /object|function/.test(typeof e);
}
function es(e, t = Map) {
  const r = new t();
  return (n, ...i) => {
    if (r.has(n))
      return r.get(n);
    const s = e(n, ...i);
    return r.set(n, s), s;
  };
}
function Yf(e) {
  return lp({
    name: e
  }, 1);
}
function lp(e, t) {
  return fa((r) => ({
    value: r,
    configurable: 1,
    writable: !t
  }), e);
}
function Vut(e) {
  return fa((t) => ({
    get: t,
    configurable: 1
  }), e);
}
function V5(e) {
  return {
    [Symbol.toStringTag]: {
      value: e,
      configurable: 1
    }
  };
}
function Hp(e, t) {
  const r = {};
  let n = e.length;
  for (const i of t)
    r[e[--n]] = i;
  return r;
}
function fa(e, t, r) {
  const n = {};
  for (const i in t)
    n[i] = e(t[i], i, r);
  return n;
}
function N2(e, t, r) {
  const n = {};
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    n[s] = e(s, i, r);
  }
  return n;
}
function dN(e, t, r) {
  const n = {};
  for (let i = 0; i < e.length; i++)
    n[t[i]] = r[e[i]];
  return n;
}
function Us(e, t) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const n of e)
    r[n] = t[n];
  return r;
}
function Ck(e, t) {
  for (const r of t)
    if (r in e)
      return 1;
  return 0;
}
function fN(e, t, r) {
  for (const n of e)
    if (t[n] !== r[n])
      return 0;
  return 1;
}
function gN(e, t, r) {
  const n = {
    ...r
  };
  for (let i = 0; i < t; i++)
    n[e[i]] = 0;
  return n;
}
function Je(e, ...t) {
  return (...r) => e(...t, ...r);
}
function Ik(e) {
  return e[0].toUpperCase() + e.substring(1);
}
function eg(e) {
  return e.slice().sort();
}
function Hm(e, t) {
  return String(t).padStart(e, "0");
}
function El(e, t) {
  return Math.sign(e - t);
}
function Kf(e, t, r) {
  return Math.min(Math.max(e, t), r);
}
function ta(e, t) {
  return [Math.floor(e / t), gf(e, t)];
}
function gf(e, t) {
  return (e % t + t) % t;
}
function Bl(e, t) {
  return [D2(e, t), U5(e, t)];
}
function D2(e, t) {
  return Math.trunc(e / t) || 0;
}
function U5(e, t) {
  return e % t || 0;
}
function t1(e) {
  return Math.abs(e % 1) === 0.5;
}
function mN(e, t, r) {
  let n = 0, i = 0;
  for (let a = 0; a <= t; a++) {
    const l = e[r[a]], c = So[a], h = Tr / c, [u, p] = Bl(l, h);
    n += p * c, i += u;
  }
  const [s, o] = Bl(n, Tr);
  return [i + s, o];
}
function B2(e, t, r) {
  const n = {};
  for (let i = t; i >= 0; i--) {
    const s = So[i];
    n[r[i]] = D2(e, s), e = U5(e, s);
  }
  return n;
}
function Uut(e) {
  if (e !== void 0)
    return $n(e);
}
function Hut(e) {
  if (e !== void 0)
    return Qo(e);
}
function yN(e) {
  if (e !== void 0)
    return H5(e);
}
function Qo(e) {
  return wN(H5(e));
}
function H5(e) {
  return vN(tdt(e));
}
function bN(e, t) {
  if (t == null)
    throw new RangeError(NE(e));
  return t;
}
function rg(e) {
  if (!si(e))
    throw new TypeError(_pt);
  return e;
}
function G5(e, t, r = e) {
  if (typeof t !== e)
    throw new TypeError(bc(r, t));
  return t;
}
function vN(e, t = "number") {
  if (!Number.isInteger(e))
    throw new RangeError(vpt(t, e));
  return e || 0;
}
function wN(e, t = "number") {
  if (e <= 0)
    throw new RangeError(wpt(t, e));
  return e;
}
function Q5(e) {
  if (typeof e == "symbol")
    throw new TypeError(Spt);
  return String(e);
}
function D1(e, t) {
  return si(e) ? String(e) : $n(e, t);
}
function W5(e) {
  if (typeof e == "string")
    return BigInt(e);
  if (typeof e != "bigint")
    throw new TypeError(Apt(e));
  return e;
}
function xN(e, t = "number") {
  if (typeof e == "bigint")
    throw new TypeError(Ept(t));
  if (e = Number(e), !Number.isFinite(e))
    throw new RangeError(xpt(t, e));
  return e;
}
function Qn(e, t) {
  return Math.trunc(xN(e, t)) || 0;
}
function q5(e, t) {
  return vN(xN(e, t), t);
}
function Pk(e, t) {
  return wN(Qn(e, t), t);
}
function Y5(e, t) {
  let [r, n] = Bl(t, Tr), i = e + r;
  const s = Math.sign(i);
  return s && s === -Math.sign(n) && (i -= s, n += s * Tr), [i, n];
}
function cp(e, t, r = 1) {
  return Y5(e[0] + t[0] * r, e[1] + t[1] * r);
}
function Ou(e, t) {
  return Y5(e[0], e[1] + t);
}
function Eo(e, t) {
  return cp(t, e, -1);
}
function rs(e, t) {
  return El(e[0], t[0]) || El(e[1], t[1]);
}
function EN(e, t, r) {
  return rs(e, t) === -1 || rs(e, r) === 1;
}
function K5(e, t = 1) {
  const r = BigInt(Tr / t);
  return [Number(e / r), Number(e % r) * t];
}
function Gm(e, t = 1) {
  const r = Tr / t, [n, i] = Bl(e, r);
  return [n, i * t];
}
function Ao(e, t = 1, r) {
  const [n, i] = e, [s, o] = Bl(i, t);
  return n * (Tr / t) + (s + (r ? o / t : 0));
}
function Z5(e, t, r = ta) {
  const [n, i] = e, [s, o] = r(i, t);
  return [n * (Tr / t) + s, o];
}
function J5(e) {
  return bi(e, "isoYear", r0, e0, 1), e.isoYear === r0 ? bi(e, "isoMonth", 4, 12, 1) : e.isoYear === e0 && bi(e, "isoMonth", 1, 9, 1), e;
}
function As(e) {
  return Mi({
    ...e,
    ...Ni,
    isoHour: 12
  }), e;
}
function Mi(e) {
  const t = bi(e, "isoYear", r0, e0, 1), r = t === r0 ? 1 : t === e0 ? -1 : 0;
  return r && No(wn({
    ...e,
    isoDay: e.isoDay + r,
    isoNanosecond: e.isoNanosecond - r
  })), e;
}
function No(e) {
  if (!e || EN(e, ldt, adt))
    throw new RangeError(vc);
  return e;
}
function jl(e) {
  return mN(e, 5, Qs)[1];
}
function j2(e) {
  const [t, r] = ta(e, Tr);
  return [B2(r, 5, Qs), t];
}
function Rk(e) {
  return Z5(e, fo);
}
function Zn(e) {
  return Gp(e.isoYear, e.isoMonth, e.isoDay, e.isoHour, e.isoMinute, e.isoSecond, e.isoMillisecond);
}
function wn(e) {
  const t = Zn(e);
  if (t !== void 0) {
    const [r, n] = Bl(t, _i);
    return [r, n * Ta + (e.isoMicrosecond || 0) * cg + (e.isoNanosecond || 0)];
  }
}
function X5(e, t) {
  const [r, n] = j2(jl(e) - t);
  return No(wn({
    ...e,
    isoDay: e.isoDay + n,
    ...r
  }));
}
function Qm(...e) {
  return Gp(...e) / ND;
}
function Gp(...e) {
  const [t, r] = AN(...e), n = t.valueOf();
  if (!isNaN(n))
    return n - r * _i;
}
function AN(e, t = 1, r = 1, n = 0, i = 0, s = 0, o = 0) {
  const a = e === r0 ? 1 : e === e0 ? -1 : 0, l = /* @__PURE__ */ new Date();
  return l.setUTCHours(n, i, s, o), l.setUTCFullYear(e, t - 1, r + a), [l, a];
}
function Qp(e, t) {
  let [r, n] = Ou(e, t);
  n < 0 && (n += Tr, r -= 1);
  const [i, s] = ta(n, Ta), [o, a] = ta(s, cg);
  return F2(r * _i + i, o, a);
}
function F2(e, t = 0, r = 0) {
  const n = Math.ceil(Math.max(0, Math.abs(e) - odt) / _i) * Math.sign(e), i = new Date(e - n * _i);
  return Hp(ob, [i.getUTCFullYear(), i.getUTCMonth() + 1, i.getUTCDate() + n, i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds(), t, r]);
}
function tE(e, t) {
  if (t < -864e13)
    throw new RangeError(vc);
  const r = e.formatToParts(t), n = {};
  for (const i of r)
    n[i.type] = i.value;
  return n;
}
function eE(e) {
  return [e.isoYear, e.isoMonth, e.isoDay];
}
function SN(e, t) {
  return [t, 0];
}
function _N() {
  return Za;
}
function kN(e, t) {
  switch (t) {
    case 2:
      return rE(e) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function CN(e) {
  return rE(e) ? 366 : 365;
}
function rE(e) {
  return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);
}
function IN(e) {
  const [t, r] = AN(e.isoYear, e.isoMonth, e.isoDay);
  return gf(t.getUTCDay() - r, 7) || 7;
}
function PN(e) {
  return this.id === td ? (({ isoYear: t }) => t < 1 ? ["gregory-inverse", 1 - t] : ["gregory", t])(e) : this.id === zl ? hdt(e) : [];
}
function Gut(e) {
  const t = Zn(e);
  if (t < udt) {
    const { isoYear: s } = e;
    return s < 1 ? ["japanese-inverse", 1 - s] : ["japanese", s];
  }
  const r = tE(e8(zl), t), { era: n, eraYear: i } = gD(r, zl);
  return [n, i];
}
function $2(e) {
  return Ju(e), Wp(e, 1), e;
}
function Ju(e) {
  return RN(e, 1), e;
}
function Tk(e) {
  return fN(HE, e, RN(e));
}
function RN(e, t) {
  const { isoYear: r } = e, n = bi(e, "isoMonth", 1, _N(), t);
  return {
    isoYear: r,
    isoMonth: n,
    isoDay: bi(e, "isoDay", 1, kN(r, n), t)
  };
}
function Wp(e, t) {
  return Hp(Qs, [bi(e, "isoHour", 0, 23, t), bi(e, "isoMinute", 0, 59, t), bi(e, "isoSecond", 0, 59, t), bi(e, "isoMillisecond", 0, 999, t), bi(e, "isoMicrosecond", 0, 999, t), bi(e, "isoNanosecond", 0, 999, t)]);
}
function cr(e) {
  return e === void 0 ? 0 : ZD(rg(e));
}
function z2(e, t = 0) {
  e = Do(e);
  const r = JD(e), n = xdt(e, t);
  return [ZD(e), n, r];
}
function qp(e, t, r, n = 9, i = 0, s = 4) {
  t = Do(t);
  let o = KD(t, n, i), a = sE(t), l = pg(t, s);
  const c = hg(t, n, i, 1);
  return o == null ? o = Math.max(r, c) : MN(o, c), a = oE(a, c, 1), e && (l = ((h) => h < 4 ? (h + 2) % 4 : h)(l)), [o, c, a, l];
}
function V2(e, t = 6, r) {
  let n = sE(e = U2(e, Jm));
  const i = pg(e, 7);
  let s = hg(e, t);
  return s = bN(Jm, s), n = oE(n, s, void 0, r), [s, n, i];
}
function nE(e) {
  return QE(Do(e));
}
function TN(e, t) {
  return iE(Do(e), t);
}
function Qut(e) {
  const t = U2(e, Mw), r = dc(Mw, vdt, t, 0);
  if (!r)
    throw new RangeError(bc(Mw, r));
  return r;
}
function iE(e, t = 4) {
  const r = LN(e);
  return [pg(e, 4), ...ON(hg(e, t), r)];
}
function ON(e, t) {
  return e != null ? [So[e], e < 4 ? 9 - 3 * e : -1] : [t === void 0 ? 1 : 10 ** (9 - t), t];
}
function sE(e) {
  const t = e[mf];
  return t === void 0 ? 1 : Qn(t, mf);
}
function oE(e, t, r, n) {
  const i = n ? Tr : So[t + 1];
  if (i) {
    const s = So[t];
    if (i % ((e = da(mf, e, 1, i / s - (n ? 0 : 1), 1)) * s))
      throw new RangeError(bc(mf, e));
  } else
    e = da(mf, e, 1, r ? 10 ** 9 : 1, 1);
  return e;
}
function LN(e) {
  let t = e[Lw];
  if (t !== void 0) {
    if (typeof t != "number") {
      if (Q5(t) === "auto")
        return;
      throw new RangeError(bc(Lw, t));
    }
    t = da(Lw, Math.floor(t), 0, 9, 1);
  }
  return t;
}
function Do(e) {
  return e === void 0 ? {} : rg(e);
}
function U2(e, t) {
  return typeof e == "string" ? {
    [t]: e
  } : rg(e);
}
function H2(e) {
  return {
    overflow: pdt[e]
  };
}
function aE(e, t, r = 9, n = 0, i) {
  let s = t[e];
  if (s === void 0)
    return i ? n : void 0;
  if (s = Q5(s), s === "auto")
    return i ? n : null;
  let o = c4[s];
  if (o === void 0 && (o = ndt[s]), o === void 0)
    throw new RangeError(ID(e, s, c4));
  return da(e, o, n, r, 1, DE), o;
}
function dc(e, t, r, n = 0) {
  const i = r[e];
  if (i === void 0)
    return n;
  const s = Q5(i), o = t[s];
  if (o === void 0)
    throw new RangeError(ID(e, s, t));
  return o;
}
function MN(e, t) {
  if (t > e)
    throw new RangeError(Qpt);
}
function Pa(e) {
  return {
    branding: KE,
    epochNanoseconds: e
  };
}
function Hs(e, t, r) {
  return {
    branding: wc,
    calendar: r,
    timeZone: t,
    epochNanoseconds: e
  };
}
function Gs(e, t = e.calendar) {
  return {
    branding: ed,
    calendar: t,
    ...Us(idt, e)
  };
}
function Ra(e, t = e.calendar) {
  return {
    branding: dg,
    calendar: t,
    ...Us(GE, e)
  };
}
function Zf(e, t = e.calendar) {
  return {
    branding: WE,
    calendar: t,
    ...Us(GE, e)
  };
}
function Wm(e, t = e.calendar) {
  return {
    branding: qE,
    calendar: t,
    ...Us(GE, e)
  };
}
function Bo(e) {
  return {
    branding: YE,
    ...Us(GD, e)
  };
}
function un(e) {
  return {
    branding: ZE,
    sign: fc(e),
    ...Us(zE, e)
  };
}
function lE(e) {
  return Z5(e.epochNanoseconds, Ta)[0];
}
function Wut(e) {
  return ((t, r = 1) => {
    const [n, i] = t, s = Math.floor(i / r), o = Tr / r;
    return BigInt(n) * BigInt(o) + BigInt(s);
  })(e.epochNanoseconds);
}
function NN(e) {
  return e.epochNanoseconds;
}
function qut(e, t, r, n, i) {
  const s = Lu(n), [o, a] = ((E, A) => {
    const x = A((E = U2(E, p4))[qD]);
    let m = wdt(E);
    return m = bN(p4, m), [m, x];
  })(i, e), l = Math.max(o, s);
  if (!a && Xf(l, a))
    return Ok(n, o);
  if (!a)
    throw new RangeError(nb);
  if (!n.sign)
    return 0;
  const [c, h, u] = Y2(t, r, a), p = yE(u), y = K2(u), g = bE(u), b = y(h, c, n);
  up(a) || (Mi(c), Mi(b));
  const f = g(h, c, b, o);
  return Xf(o, a) ? Ok(f, o) : ((E, A, x, m, w, _, S) => {
    const R = fc(E), [O, $] = cE(m, UE(x, E), x, R, w, _, S), z = uE(A, O, $);
    return E[gr[x]] + z * R;
  })(f, p(b), o, h, c, p, y);
}
function Ok(e, t) {
  return Ao(_n(e), So[t], 1);
}
function cE(e, t, r, n, i, s, o) {
  const a = gr[r], l = {
    ...t,
    [a]: t[a] + n
  }, c = o(e, i, t), h = o(e, i, l);
  return [s(c), s(h)];
}
function uE(e, t, r) {
  const n = Ao(Eo(t, r));
  if (!n)
    throw new RangeError(Xp);
  return Ao(Eo(t, e)) / n;
}
function Yut(e, t) {
  const [r, n, i] = V2(t, 5, 1);
  return Pa(Q2(e.epochNanoseconds, r, n, i, 1));
}
function Kut(e, t, r) {
  let { epochNanoseconds: n, timeZone: i, calendar: s } = t;
  const [o, a, l] = V2(r);
  if (o === 0 && a === 1)
    return t;
  const c = e(i);
  if (o === 6)
    n = ((h, u, p, y) => {
      const g = is(p, u), [b, f] = h(g), E = p.epochNanoseconds, A = $l(u, b), x = $l(u, f);
      if (EN(E, A, x))
        throw new RangeError(Xp);
      return $N(uE(E, A, x), y) ? x : A;
    })(jN, c, t, l);
  else {
    const h = c.R(n);
    n = Yp(c, DN(Qp(n, h), o, a, l), h, 2, 0, 1);
  }
  return Hs(n, i, s);
}
function Zut(e, t) {
  return Gs(DN(e, ...V2(t)), e.calendar);
}
function Jut(e, t) {
  const [r, n, i] = V2(t, 5);
  var s;
  return Bo((s = i, hE(e, ng(r, n), s)[0]));
}
function Xut(e, t) {
  const r = e(t.timeZone), n = is(t, r), [i, s] = jN(n), o = Ao(Eo($l(r, i), $l(r, s)), sb, 1);
  if (o <= 0)
    throw new RangeError(Xp);
  return o;
}
function tht(e, t) {
  const { timeZone: r, calendar: n } = t, i = ((s, o, a) => $l(o, s(is(a, o))))(FN, e(r), t);
  return Hs(i, r, n);
}
function DN(e, t, r, n) {
  return BN(e, ng(t, r), n);
}
function BN(e, t, r) {
  const [n, i] = hE(e, t, r);
  return Mi({
    ...Xu(e, i),
    ...n
  });
}
function hE(e, t, r) {
  return j2(Fl(jl(e), t, r));
}
function qm(e) {
  return Fl(e, ib, 7);
}
function ng(e, t) {
  return So[e] * t;
}
function jN(e) {
  const t = FN(e);
  return [t, Xu(t, 1)];
}
function FN(e) {
  return sdt(6, e);
}
function eht(e, t, r) {
  const n = Math.min(Lu(e), 6);
  return Kp(W2(_n(e, n), t, r), n);
}
function G2(e, t, r, n, i, s, o, a, l, c) {
  if (n === 0 && i === 1)
    return e;
  const h = Xf(n, a) ? up(a) && n < 6 && r >= 6 ? nht : rht : iht;
  let [u, p, y] = h(e, t, r, n, i, s, o, a, l, c);
  return y && n !== 7 && (u = ((g, b, f, E, A, x, m, w) => {
    const _ = fc(g);
    for (let S = E + 1; S <= f; S++) {
      if (S === 7 && f !== 7)
        continue;
      const R = UE(S, g);
      R[gr[S]] += _;
      const O = Ao(Eo(m(w(A, x, R)), b));
      if (O && Math.sign(O) !== _)
        break;
      g = R;
    }
    return g;
  })(u, p, r, Math.max(6, n), o, a, l, c)), u;
}
function Q2(e, t, r, n, i) {
  if (t === 6) {
    const s = ((o) => o[0] + o[1] / Tr)(e);
    return [Fl(s, r, n), 0];
  }
  return W2(e, ng(t, r), n, i);
}
function W2(e, t, r, n) {
  let [i, s] = e;
  n && s < 0 && (s += Tr, i -= 1);
  const [o, a] = ta(Fl(s, t, r), Tr);
  return Y5(i + o, a);
}
function Fl(e, t, r) {
  return $N(e / t, r) * t;
}
function $N(e, t) {
  return Sdt[t](e);
}
function rht(e, t, r, n, i, s) {
  const o = fc(e), a = _n(e), l = Q2(a, n, i, s), c = Eo(a, l), h = Math.sign(l[0] - a[0]) === o, u = Kp(l, Math.min(r, 6));
  return [{
    ...e,
    ...u
  }, cp(t, c), h];
}
function nht(e, t, r, n, i, s, o, a, l, c) {
  const h = fc(e) || 1, u = Ao(_n(e, 5)), p = ng(n, i);
  let y = Fl(u, p, s);
  const [g, b] = cE(o, {
    ...e,
    ...VE
  }, 6, h, a, l, c), f = y - Ao(Eo(g, b));
  let E = 0;
  f && Math.sign(f) !== h ? t = Ou(g, y) : (E += h, y = Fl(f, p, s), t = Ou(b, y));
  const A = Z2(y);
  return [{
    ...e,
    ...A,
    days: e.days + E
  }, t, !!E];
}
function iht(e, t, r, n, i, s, o, a, l, c) {
  const h = fc(e), u = gr[n], p = UE(n, e);
  n === 7 && (e = {
    ...e,
    weeks: e.weeks + Math.trunc(e.days / 7)
  });
  const y = D2(e[u], i) * i;
  p[u] = y;
  const [g, b] = cE(o, p, n, i * h, a, l, c), f = y + uE(t, g, b) * h * i, E = Fl(f, i, s), A = Math.sign(E - f) === h;
  return p[u] = E, [p, A ? b : g, A];
}
function Lk(e, t, r, n) {
  const [i, s, o, a] = ((c) => {
    const h = iE(c = Do(c));
    return [c.timeZone, ...h];
  })(n), l = i !== void 0;
  return ((c, h, u, p, y, g) => {
    u = W2(u, y, p, 1);
    const b = h.R(u);
    return pE(Qp(u, b), g) + (c ? ig(qm(b)) : "Z");
  })(l, t(l ? e(i) : nh), r.epochNanoseconds, s, o, a);
}
function Mk(e, t, r) {
  const [n, i, s, o, a, l] = ((c) => {
    c = Do(c);
    const h = QE(c), u = LN(c), p = Adt(c), y = pg(c, 4), g = hg(c, 4);
    return [h, Edt(c), p, y, ...ON(g, u)];
  })(r);
  return ((c, h, u, p, y, g, b, f, E, A) => {
    p = W2(p, E, f, 1);
    const x = c(u).R(p);
    return pE(Qp(p, x), A) + ig(qm(x), b) + ((m, w) => w !== 1 ? "[" + (w === 2 ? "!" : "") + m + "]" : "")(u, g) + dE(h, y);
  })(e, t.calendar, t.timeZone, t.epochNanoseconds, n, i, s, o, a, l);
}
function Nk(e, t) {
  const [r, n, i, s] = ((c) => (c = Do(c), [QE(c), ...iE(c)]))(t);
  return o = e.calendar, a = r, l = s, pE(BN(e, i, n), l) + dE(o, a);
  var o, a, l;
}
function Dk(e, t) {
  return r = e.calendar, n = e, i = nE(t), Ym(n) + dE(r, i);
  var r, n, i;
}
function Bk(e, t) {
  return zN(e.calendar, VN, e, nE(t));
}
function jk(e, t) {
  return zN(e.calendar, sht, e, nE(t));
}
function Fk(e, t) {
  const [r, n, i] = TN(t);
  return s = i, UN(hE(e, n, r)[0], s);
  var s;
}
function Cw(e, t) {
  const [r, n, i] = TN(t, 3);
  return n > 1 && th(e = {
    ...e,
    ...eht(e, n, r)
  }), ((s, o) => {
    const { sign: a } = s, l = a === -1 ? oi(s) : s, { hours: c, minutes: h } = l, [u, p] = Z5(_n(l, 3), fo, Bl);
    WN(u);
    const y = fE(p, o), g = o >= 0 || !a || y;
    return (a < 0 ? "-" : "") + "P" + $k({
      Y: Uc(l.years),
      M: Uc(l.months),
      W: Uc(l.weeks),
      D: Uc(l.days)
    }) + (c || h || u || g ? "T" + $k({
      H: Uc(c),
      M: Uc(h),
      S: Uc(u, g) + y
    }) : "");
  })(e, i);
}
function zN(e, t, r, n) {
  const i = n > 1 || n === 0 && e !== ir;
  return n === 1 ? e === ir ? t(r) : Ym(r) : i ? Ym(r) + HN(e, n === 2) : t(r);
}
function $k(e) {
  const t = [];
  for (const r in e) {
    const n = e[r];
    n && t.push(n, r);
  }
  return t.join("");
}
function pE(e, t) {
  return Ym(e) + "T" + UN(e, t);
}
function Ym(e) {
  return VN(e) + "-" + Ss(e.isoDay);
}
function VN(e) {
  const { isoYear: t } = e;
  return (t < 0 || t > 9999 ? GN(t) + Hm(6, Math.abs(t)) : Hm(4, t)) + "-" + Ss(e.isoMonth);
}
function sht(e) {
  return Ss(e.isoMonth) + "-" + Ss(e.isoDay);
}
function UN(e, t) {
  const r = [Ss(e.isoHour), Ss(e.isoMinute)];
  return t !== -1 && r.push(Ss(e.isoSecond) + ((n, i, s, o) => fE(n * Ta + i * cg + s, o))(e.isoMillisecond, e.isoMicrosecond, e.isoNanosecond, t)), r.join(":");
}
function ig(e, t = 0) {
  if (t === 1)
    return "";
  const [r, n] = ta(Math.abs(e), sb), [i, s] = ta(n, ib), [o, a] = ta(s, fo);
  return GN(e) + Ss(r) + ":" + Ss(i) + (o || a ? ":" + Ss(o) + fE(a) : "");
}
function dE(e, t) {
  return t !== 1 && (t > 1 || t === 0 && e !== ir) ? HN(e, t === 2) : "";
}
function HN(e, t) {
  return "[" + (t ? "!" : "") + "u-ca=" + e + "]";
}
function fE(e, t) {
  let r = Hm(9, e);
  return r = t === void 0 ? r.replace(Cdt, "") : r.slice(0, t), r ? "." + r : "";
}
function GN(e) {
  return e < 0 ? "-" : "+";
}
function Uc(e, t) {
  return e || t ? e.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function oht(e, t) {
  const { epochNanoseconds: r } = e, n = (t.R ? t : t(e.timeZone)).R(r), i = Qp(r, n);
  return {
    calendar: e.calendar,
    ...i,
    offsetNanoseconds: n
  };
}
function Yp(e, t, r, n = 0, i = 0, s, o) {
  if (r !== void 0 && n === 1 && (n === 1 || o))
    return X5(t, r);
  const a = e.I(t);
  if (r !== void 0 && n !== 3) {
    const l = ((c, h, u, p) => {
      const y = wn(h);
      p && (u = qm(u));
      for (const g of c) {
        let b = Ao(Eo(g, y));
        if (p && (b = qm(b)), b === u)
          return g;
      }
    })(a, t, r, s);
    if (l !== void 0)
      return l;
    if (n === 0)
      throw new RangeError($pt);
  }
  return o ? wn(t) : sg(e, t, i, a);
}
function sg(e, t, r = 0, n = e.I(t)) {
  if (n.length === 1)
    return n[0];
  if (r === 1)
    throw new RangeError(zpt);
  if (n.length)
    return n[r === 3 ? 1 : 0];
  const i = wn(t), s = ((a, l) => {
    const c = a.R(Ou(l, -864e11));
    return ((h) => {
      if (h > Tr)
        throw new RangeError(Fpt);
      return h;
    })(a.R(Ou(l, Tr)) - c);
  })(e, i), o = s * (r === 2 ? -1 : 1);
  return (n = e.I(Qp(i, o)))[r === 2 ? 0 : n.length - 1];
}
function $l(e, t) {
  const r = e.I(t);
  if (r.length)
    return r[0];
  const n = Ou(wn(t), -864e11);
  return e.O(n, 1);
}
function zk(e, t, r) {
  return Pa(No(cp(t.epochNanoseconds, ((n) => {
    if (qN(n))
      throw new RangeError(Hpt);
    return _n(n, 5);
  })(e ? oi(r) : r))));
}
function Vk(e, t, r, n, i, s = /* @__PURE__ */ Object.create(null)) {
  const o = t(n.timeZone), a = e(n.calendar);
  return {
    ...n,
    ...gE(o, a, n, r ? oi(i) : i, s)
  };
}
function Uk(e, t, r, n, i = /* @__PURE__ */ Object.create(null)) {
  const { calendar: s } = r;
  return Gs(mE(e(s), r, t ? oi(n) : n, i), s);
}
function Hk(e, t, r, n, i) {
  const { calendar: s } = r;
  return Ra(q2(e(s), r, t ? oi(n) : n, i), s);
}
function Gk(e, t, r, n, i) {
  const s = r.calendar, o = e(s);
  let a = As(Jf(o, r));
  t && (n = vE(n)), n.sign < 0 && (a = o.P(a, {
    ...kn,
    months: 1
  }), a = Xu(a, -1));
  const l = o.P(a, n, i);
  return Zf(Jf(o, l), s);
}
function Qk(e, t, r) {
  return Bo(QN(t, e ? oi(r) : r)[0]);
}
function gE(e, t, r, n, i) {
  const s = _n(n, 5);
  let o = r.epochNanoseconds;
  if (qN(n)) {
    const a = is(r, e);
    o = cp(sg(e, {
      ...q2(t, a, {
        ...n,
        ...VE
      }, i),
      ...Us(Qs, a)
    }), s);
  } else
    o = cp(o, s), cr(i);
  return {
    epochNanoseconds: No(o)
  };
}
function mE(e, t, r, n) {
  const [i, s] = QN(t, r);
  return Mi({
    ...q2(e, t, {
      ...r,
      ...VE,
      days: r.days + s
    }, n),
    ...i
  });
}
function q2(e, t, r, n) {
  if (r.years || r.months || r.weeks)
    return e.P(t, r, n);
  cr(n);
  const i = r.days + _n(r, 5)[0];
  return i ? As(Xu(t, i)) : t;
}
function Jf(e, t, r = 1) {
  return Xu(t, r - e.day(t));
}
function QN(e, t) {
  const [r, n] = _n(t, 5), [i, s] = j2(jl(e) + n);
  return [i, r + s];
}
function Xu(e, t) {
  return t ? {
    ...e,
    ...F2(Zn(e) + t * _i)
  } : e;
}
function Y2(e, t, r) {
  const n = e(r.calendar);
  return up(r) ? [r, n, t(r.timeZone)] : [{
    ...r,
    ...Ni
  }, n];
}
function yE(e) {
  return e ? NN : wn;
}
function K2(e) {
  return e ? Je(gE, e) : mE;
}
function bE(e) {
  return e ? Je(Rht, e) : Tht;
}
function up(e) {
  return e && e.epochNanoseconds;
}
function Xf(e, t) {
  return e <= 6 - (up(t) ? 1 : 0);
}
function Wk(e, t, r, n, i, s, o) {
  const a = e(Do(o).relativeTo), l = Math.max(Lu(i), Lu(s));
  if (Xf(l, a))
    return un(th(((b, f, E, A) => {
      const x = cp(_n(b), _n(f), A ? -1 : 1);
      if (!Number.isFinite(x[0]))
        throw new RangeError(vc);
      return {
        ...kn,
        ...Kp(x, E)
      };
    })(i, s, l, n)));
  if (!a)
    throw new RangeError(nb);
  n && (s = oi(s));
  const [c, h, u] = Y2(t, r, a), p = K2(u), y = bE(u), g = p(h, c, i);
  return un(y(h, c, p(h, g, s), l));
}
function aht(e, t, r, n, i) {
  const s = Lu(n), [o, a, l, c, h] = ((_, S, R) => {
    _ = U2(_, Jm);
    let O = KD(_);
    const $ = R(_[qD]);
    let z = sE(_);
    const F = pg(_, 7);
    let Y = hg(_);
    if (O === void 0 && Y === void 0)
      throw new RangeError(Gpt);
    if (Y == null && (Y = 0), O == null && (O = Math.max(Y, S)), MN(O, Y), z = oE(z, Y, 1), z > 1 && Y > 5 && O !== Y)
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    return [O, Y, z, F, $];
  })(i, s, e), u = Math.max(s, o);
  if (!h && u <= 6)
    return un(th(((_, S, R, O, $) => {
      const z = Q2(_n(_), R, O, $);
      return {
        ...kn,
        ...Kp(z, S)
      };
    })(n, o, a, l, c)));
  if (!up(h) && !n.sign)
    return n;
  if (!h)
    throw new RangeError(nb);
  const [p, y, g] = Y2(t, r, h), b = yE(g), f = K2(g), E = bE(g), A = f(y, p, n);
  up(h) || (Mi(p), Mi(A));
  let x = E(y, p, A, o);
  const m = n.sign, w = fc(x);
  if (m && w && m !== w)
    throw new RangeError(Xp);
  return x = G2(x, b(A), o, a, l, c, y, p, b, f), un(x);
}
function lht(e) {
  return e.sign === -1 ? vE(e) : e;
}
function vE(e) {
  return un(oi(e));
}
function oi(e) {
  const t = {};
  for (const r of gr)
    t[r] = -1 * e[r] || 0;
  return t;
}
function cht(e) {
  return !e.sign;
}
function fc(e, t = gr) {
  let r = 0;
  for (const n of t) {
    const i = Math.sign(e[n]);
    if (i) {
      if (r && r !== i)
        throw new RangeError(Upt);
      r = i;
    }
  }
  return r;
}
function th(e) {
  for (const t of rdt)
    da(t, e[t], -4294967295, Idt, 1);
  return WN(Ao(_n(e), fo)), e;
}
function WN(e) {
  if (!Number.isSafeInteger(e))
    throw new RangeError(Vpt);
}
function _n(e, t = 6) {
  return mN(e, t, gr);
}
function Kp(e, t = 6) {
  const [r, n] = e, i = B2(n, t, gr);
  if (i[gr[t]] += r * (Tr / So[t]), !Number.isFinite(i[gr[t]]))
    throw new RangeError(vc);
  return i;
}
function Z2(e, t = 5) {
  return B2(e, t, gr);
}
function qN(e) {
  return !!fc(e, HD);
}
function Lu(e) {
  let t = 9;
  for (; t > 0 && !e[gr[t]]; t--)
    ;
  return t;
}
function uht(e, t) {
  return [e, t];
}
function qk(e) {
  const t = Math.floor(e / j1) * j1;
  return [t, t + j1];
}
function hht(e) {
  const t = gc(e = D1(e));
  if (!t)
    throw new RangeError(xi(e));
  let r;
  if (t.j)
    r = 0;
  else {
    if (!t.offset)
      throw new RangeError(xi(e));
    r = eh(t.offset);
  }
  return t.timeZone && SE(t.timeZone, 1), Pa(X5($2(t), r));
}
function pht(e) {
  const t = gc($n(e));
  if (!t)
    throw new RangeError(xi(e));
  if (t.timeZone)
    return YN(t, t.offset ? eh(t.offset) : void 0);
  if (t.j)
    throw new RangeError(xi(e));
  return ZN(t);
}
function dht(e, t) {
  const r = gc($n(e));
  if (!r || !r.timeZone)
    throw new RangeError(xi(e));
  const { offset: n } = r, i = n ? eh(n) : void 0, [, s, o] = z2(t);
  return YN(r, i, s, o);
}
function eh(e) {
  const t = SE(e);
  if (t === void 0)
    throw new RangeError(xi(e));
  return t;
}
function fht(e) {
  const t = gc($n(e));
  if (!t || t.j)
    throw new RangeError(xi(e));
  return Gs(KN(t));
}
function wE(e, t, r) {
  let n = gc($n(e));
  if (!n || n.j)
    throw new RangeError(xi(e));
  return t ? n.calendar === ir && (n = n.isoYear === -271821 && n.isoMonth === 4 ? {
    ...n,
    isoDay: 20,
    ...Ni
  } : {
    ...n,
    isoDay: 1,
    ...Ni
  }) : r && n.calendar === ir && (n = {
    ...n,
    isoYear: ra
  }), Ra(n.C ? KN(n) : ZN(n));
}
function ght(e, t) {
  const r = EE($n(t));
  if (r)
    return xE(r), Zf(J5(Ju(r)));
  const n = wE(t, 1);
  return Zf(Jf(e(n.calendar), n));
}
function xE(e) {
  if (e.calendar !== ir)
    throw new RangeError(ea(e.calendar));
}
function mht(e, t) {
  const r = AE($n(t));
  if (r)
    return xE(r), Wm(Ju(r));
  const n = wE(t, 0, 1), { calendar: i } = n, s = e(i), [o, a, l] = s.v(n), [c, h] = s.q(o, a), [u, p] = s.G(c, h, l);
  return Wm(As(s.V(u, p, l)), i);
}
function yht(e) {
  let t, r = ((n) => {
    const i = Ndt.exec(n);
    return i ? (J2(i[10]), tD(i)) : void 0;
  })($n(e));
  if (!r) {
    if (r = gc(e), !r)
      throw new RangeError(xi(e));
    if (!r.C)
      throw new RangeError(xi(e));
    if (r.j)
      throw new RangeError(ea("Z"));
    xE(r);
  }
  if ((t = EE(e)) && Tk(t))
    throw new RangeError(xi(e));
  if ((t = AE(e)) && Tk(t))
    throw new RangeError(xi(e));
  return Bo(Wp(r, 1));
}
function bht(e) {
  const t = ((r) => {
    const n = jdt.exec(r);
    return n ? ((i) => {
      function s(h, u, p) {
        let y = 0, g = 0;
        if (p && ([y, l] = ta(l, So[p])), h !== void 0) {
          if (a)
            throw new RangeError(ea(h));
          g = ((b) => {
            const f = parseInt(b);
            if (!Number.isFinite(f))
              throw new RangeError(ea(b));
            return f;
          })(h), o = 1, u && (l = _E(u) * (So[p] / fo), a = 1);
        }
        return y + g;
      }
      let o = 0, a = 0, l = 0, c = {
        ...Hp(gr, [s(i[2]), s(i[3]), s(i[4]), s(i[5]), s(i[6], i[7], 5), s(i[8], i[9], 4), s(i[10], i[11], 3)]),
        ...B2(l, 2, gr)
      };
      if (!o)
        throw new RangeError(CD(gr));
      return kE(i[1]) < 0 && (c = oi(c)), c;
    })(n) : void 0;
  })($n(e));
  if (!t)
    throw new RangeError(xi(e));
  return un(th(t));
}
function vht(e) {
  const t = gc(e) || EE(e) || AE(e);
  return t ? t.calendar : e;
}
function wht(e) {
  const t = gc(e);
  return t && (t.timeZone || t.j && nh || t.offset) || e;
}
function YN(e, t, r = 0, n = 0) {
  const i = CE(e.timeZone), s = Ue(i);
  let o;
  return $2(e), o = e.C ? Yp(s, e, t, r, n, !s.$, e.j) : $l(s, e), Hs(o, i, rb(e.calendar));
}
function KN(e) {
  return JN(Mi($2(e)));
}
function ZN(e) {
  return JN(As(Ju(e)));
}
function JN(e) {
  return {
    ...e,
    calendar: rb(e.calendar)
  };
}
function gc(e) {
  const t = Mdt.exec(e);
  return t ? ((r) => {
    const n = r[10], i = (n || "").toUpperCase() === "Z";
    return {
      isoYear: XN(r),
      isoMonth: parseInt(r[4]),
      isoDay: parseInt(r[5]),
      ...tD(r.slice(5)),
      ...J2(r[16]),
      C: !!r[6],
      j: i,
      offset: i ? void 0 : n
    };
  })(t) : void 0;
}
function EE(e) {
  const t = Odt.exec(e);
  return t ? ((r) => ({
    isoYear: XN(r),
    isoMonth: parseInt(r[4]),
    isoDay: 1,
    ...J2(r[5])
  }))(t) : void 0;
}
function AE(e) {
  const t = Ldt.exec(e);
  return t ? ((r) => ({
    isoYear: ra,
    isoMonth: parseInt(r[1]),
    isoDay: parseInt(r[2]),
    ...J2(r[3])
  }))(t) : void 0;
}
function SE(e, t) {
  const r = Ddt.exec(e);
  return r ? ((n, i) => {
    const s = n[4] || n[5];
    if (i && s)
      throw new RangeError(ea(s));
    return ((o) => {
      if (Math.abs(o) >= Tr)
        throw new RangeError(jpt);
      return o;
    })((Wh(n[2]) * sb + Wh(n[3]) * ib + Wh(n[4]) * fo + _E(n[5] || "")) * kE(n[1]));
  })(r, t) : void 0;
}
function XN(e) {
  const t = kE(e[1]), r = parseInt(e[2] || e[3]);
  if (t < 0 && !r)
    throw new RangeError(ea(-0));
  return t * r;
}
function tD(e) {
  const t = Wh(e[3]);
  return {
    ...j2(_E(e[4] || ""))[0],
    isoHour: Wh(e[1]),
    isoMinute: Wh(e[2]),
    isoSecond: t === 60 ? 59 : t
  };
}
function J2(e) {
  let t, r;
  const n = [];
  if (e.replace(Bdt, (i, s, o) => {
    const a = !!s, [l, c] = o.split("=").reverse();
    if (c) {
      if (c === "u-ca")
        n.push(l), t || (t = a);
      else if (a || /[A-Z]/.test(c))
        throw new RangeError(ea(i));
    } else {
      if (r)
        throw new RangeError(ea(i));
      r = l;
    }
    return "";
  }), n.length > 1 && t)
    throw new RangeError(ea(e));
  return {
    timeZone: r,
    calendar: n[0] || ir
  };
}
function _E(e) {
  return parseInt(e.padEnd(9, "0"));
}
function Zp(e) {
  return new RegExp(`^${e}$`, "i");
}
function kE(e) {
  return e && e !== "+" ? -1 : 1;
}
function Wh(e) {
  return e === void 0 ? 0 : parseInt(e);
}
function xht(e) {
  return CE($n(e));
}
function CE(e) {
  const t = IE(e);
  return typeof t == "number" ? ig(t) : t ? ((r) => {
    if (zdt.test(r))
      throw new RangeError(OD(r));
    if ($dt.test(r))
      throw new RangeError(Bpt);
    return r.toLowerCase().split("/").map((n, i) => (n.length <= 3 || /\d/.test(n)) && !/etc|yap/.test(n) ? n.toUpperCase() : n.replace(/baja|dumont|[a-z]+/g, (s, o) => s.length <= 2 && !i || s === "in" || s === "chat" ? s.toUpperCase() : s.length > 2 || !o ? Ik(s).replace(/island|noronha|murdo|rivadavia|urville/, Ik) : s)).join("/");
  })(e) : nh;
}
function Yk(e) {
  const t = IE(e);
  return typeof t == "number" ? t : t ? t.resolvedOptions().timeZone : nh;
}
function IE(e) {
  const t = SE(e = e.toUpperCase(), 1);
  return t !== void 0 ? t : e !== nh ? Fdt(e) : void 0;
}
function eD(e, t) {
  return rs(e.epochNanoseconds, t.epochNanoseconds);
}
function rD(e, t) {
  return rs(e.epochNanoseconds, t.epochNanoseconds);
}
function Eht(e, t, r, n, i, s) {
  const o = e(Do(s).relativeTo), a = Math.max(Lu(n), Lu(i));
  if (fN(gr, n, i))
    return 0;
  if (Xf(a, o))
    return rs(_n(n), _n(i));
  if (!o)
    throw new RangeError(nb);
  const [l, c, h] = Y2(t, r, o), u = yE(h), p = K2(h);
  return rs(u(p(c, l, n)), u(p(c, l, i)));
}
function nD(e, t) {
  return Jp(e, t) || PE(e, t);
}
function Jp(e, t) {
  return El(Zn(e), Zn(t));
}
function PE(e, t) {
  return El(jl(e), jl(t));
}
function Aht(e, t) {
  return !eD(e, t);
}
function Sht(e, t) {
  return !rD(e, t) && !!iD(e.timeZone, t.timeZone) && e.calendar === t.calendar;
}
function _ht(e, t) {
  return !nD(e, t) && e.calendar === t.calendar;
}
function kht(e, t) {
  return !Jp(e, t) && e.calendar === t.calendar;
}
function Cht(e, t) {
  return !Jp(e, t) && e.calendar === t.calendar;
}
function Iht(e, t) {
  return !Jp(e, t) && e.calendar === t.calendar;
}
function Pht(e, t) {
  return !PE(e, t);
}
function iD(e, t) {
  if (e === t)
    return 1;
  try {
    return Yk(e) === Yk(t);
  } catch {
  }
}
function Kk(e, t, r, n) {
  const i = qp(e, n, 3, 5), s = X2(t.epochNanoseconds, r.epochNanoseconds, ...i);
  return un(e ? oi(s) : s);
}
function Zk(e, t, r, n, i, s) {
  const o = eb(n.calendar, i.calendar), [a, l, c, h] = qp(r, s, 5), u = n.epochNanoseconds, p = i.epochNanoseconds, y = rs(p, u);
  let g;
  if (y)
    if (a < 6)
      g = X2(u, p, a, l, c, h);
    else {
      const b = t(((E, A) => {
        if (!iD(E, A))
          throw new RangeError(LD);
        return E;
      })(n.timeZone, i.timeZone)), f = e(o);
      g = oD(f, b, n, i, y, a, s), g = G2(g, p, a, l, c, h, f, n, NN, Je(gE, b));
    }
  else
    g = kn;
  return un(r ? oi(g) : g);
}
function Jk(e, t, r, n, i) {
  const s = eb(r.calendar, n.calendar), [o, a, l, c] = qp(t, i, 6), h = wn(r), u = wn(n), p = rs(u, h);
  let y;
  if (p)
    if (o <= 6)
      y = X2(h, u, o, a, l, c);
    else {
      const g = e(s);
      y = aD(g, r, n, p, o, i), y = G2(y, u, o, a, l, c, g, r, wn, mE);
    }
  else
    y = kn;
  return un(t ? oi(y) : y);
}
function Xk(e, t, r, n, i) {
  const s = eb(r.calendar, n.calendar);
  return sD(t, () => e(s), r, n, ...qp(t, i, 6, 9, 6));
}
function tC(e, t, r, n, i) {
  const s = eb(r.calendar, n.calendar), o = qp(t, i, 9, 9, 8), a = e(s), l = Jf(a, r), c = Jf(a, n);
  return l.isoYear === c.isoYear && l.isoMonth === c.isoMonth && l.isoDay === c.isoDay ? un(kn) : sD(t, () => a, As(l), As(c), ...o, 8);
}
function sD(e, t, r, n, i, s, o, a, l = 6) {
  const c = wn(r), h = wn(n);
  if (c === void 0 || h === void 0)
    throw new RangeError(vc);
  let u;
  if (rs(h, c))
    if (i === 6)
      u = X2(c, h, i, s, o, a);
    else {
      const p = t();
      u = p.N(r, n, i), s === l && o === 1 || (u = G2(u, h, i, s, o, a, p, r, wn, q2));
    }
  else
    u = kn;
  return un(e ? oi(u) : u);
}
function eC(e, t, r, n) {
  const [i, s, o, a] = qp(e, n, 5, 5), l = Fl(RE(t, r), ng(s, o), a), c = {
    ...kn,
    ...Z2(l, i)
  };
  return un(e ? oi(c) : c);
}
function Rht(e, t, r, n, i, s) {
  const o = rs(n.epochNanoseconds, r.epochNanoseconds);
  return o ? i < 6 ? lD(r.epochNanoseconds, n.epochNanoseconds, i) : oD(t, e, r, n, o, i, s) : kn;
}
function Tht(e, t, r, n, i) {
  const s = wn(t), o = wn(r), a = rs(o, s);
  return a ? n <= 6 ? lD(s, o, n) : aD(e, t, r, a, n, i) : kn;
}
function oD(e, t, r, n, i, s, o) {
  const [a, l, c] = ((p, y, g, b) => {
    function f() {
      return S = {
        ...Xu(x, w++ * -b),
        ...A
      }, R = sg(p, S), rs(m, R) === -b;
    }
    const E = is(y, p), A = Us(Qs, E), x = is(g, p), m = g.epochNanoseconds;
    let w = 0;
    const _ = RE(E, x);
    let S, R;
    if (Math.sign(_) === -b && w++, f() && (b === -1 || f()))
      throw new RangeError(Xp);
    const O = Ao(Eo(R, m));
    return [E, S, O];
  })(t, r, n, i);
  var h, u;
  return {
    ...s === 6 ? (h = a, u = l, {
      ...kn,
      days: cD(h, u)
    }) : e.N(a, l, s, o),
    ...Z2(c)
  };
}
function aD(e, t, r, n, i, s) {
  const [o, a, l] = ((c, h, u) => {
    let p = h, y = RE(c, h);
    return Math.sign(y) === -u && (p = Xu(h, -u), y += Tr * u), [c, p, y];
  })(t, r, n);
  return {
    ...e.N(o, a, i, s),
    ...Z2(l)
  };
}
function X2(e, t, r, n, i, s) {
  return {
    ...kn,
    ...Kp(Q2(Eo(e, t), n, i, s), r)
  };
}
function lD(e, t, r) {
  return {
    ...kn,
    ...Kp(Eo(e, t), r)
  };
}
function cD(e, t) {
  return tb(Zn(e), Zn(t));
}
function tb(e, t) {
  return Math.trunc((t - e) / _i);
}
function RE(e, t) {
  return jl(t) - jl(e);
}
function eb(e, t) {
  if (e !== t)
    throw new RangeError(TD);
  return e;
}
function uD(e) {
  return this.m(e)[0];
}
function hD(e) {
  return this.m(e)[1];
}
function TE(e) {
  const [t] = this.v(e);
  return tb(this.p(t), Zn(e)) + 1;
}
function OE(e) {
  const t = Vdt.exec(e);
  if (!t)
    throw new RangeError(Npt(e));
  return [parseInt(t[1]), !!t[2]];
}
function og(e, t) {
  return "M" + Ss(e) + (t ? "L" : "");
}
function Km(e, t, r) {
  return e + (t || r && e >= r ? 1 : 0);
}
function LE(e, t) {
  return e - (t && e >= t ? 1 : 0);
}
function pD(e, t) {
  return (t + e) * (Math.sign(t) || 1) || 0;
}
function o4(e) {
  return VD[fD(e)];
}
function dD(e) {
  return Jpt[fD(e)];
}
function fD(e) {
  return Mu(e.id || ir);
}
function Oht(e) {
  function t(i) {
    return ((s, o) => ({
      ...gD(s, o),
      o: s.month,
      day: parseInt(s.day)
    }))(tE(r, i), n);
  }
  const r = e8(e), n = Mu(e);
  return {
    id: e,
    h: Lht(t),
    l: Mht(t)
  };
}
function Lht(e) {
  return es((t) => {
    const r = Zn(t);
    return e(r);
  }, WeakMap);
}
function Mht(e) {
  const t = e(0).year - cdt;
  return es((r) => {
    let n, i = Gp(r - t), s = 0;
    const o = [], a = [];
    do
      i += 400 * _i;
    while ((n = e(i)).year <= r);
    do
      if (i += (1 - n.day) * _i, n.year === r && (o.push(i), a.push(n.o)), i -= _i, ++s > 100 || i < -864e13)
        throw new RangeError(Xp);
    while ((n = e(i)).year >= r);
    return {
      i: o.reverse(),
      u: MD(a.reverse())
    };
  });
}
function gD(e, t) {
  let r, n, i = mD(e);
  if (e.era) {
    const s = VD[t], o = UD[t] || {};
    s !== void 0 && (r = t === "islamic" ? "ah" : e.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), r === "bc" || r === "b" ? r = "bce" : r === "ad" || r === "a" ? r = "ce" : r === "beforeroc" && (r = "broc"), r = o[r] || r, n = i, i = pD(n, s[r] || 0));
  }
  return {
    era: r,
    eraYear: n,
    year: i
  };
}
function mD(e) {
  return parseInt(e.relatedYear || e.year);
}
function Zm(e) {
  const { year: t, o: r, day: n } = this.h(e), { u: i } = this.l(t);
  return [t, i[r] + 1, n];
}
function t0(e, t = 1, r = 1) {
  return this.l(e).i[t - 1] + (r - 1) * _i;
}
function yD(e, t) {
  const r = B1.call(this, e);
  return [LE(t, r), r === t];
}
function B1(e) {
  const t = nC(this, e), r = nC(this, e - 1), n = t.length;
  if (n > r.length) {
    const i = dD(this);
    if (i < 0)
      return -i;
    for (let s = 0; s < n; s++)
      if (t[s] !== r[s])
        return s + 1;
  }
}
function e1(e) {
  return tb(t0.call(this, e), t0.call(this, e + 1));
}
function rC(e, t) {
  const { i: r } = this.l(e);
  let n = t + 1, i = r;
  return n > r.length && (n = 1, i = this.l(e + 1).i), tb(r[t - 1], i[n - 1]);
}
function r1(e) {
  return this.l(e).i.length;
}
function bD(e) {
  const t = this.h(e);
  return [t.era, t.eraYear];
}
function nC(e, t) {
  return Object.keys(e.l(t).u);
}
function ag(e) {
  return rb($n(e));
}
function rb(e) {
  if ((e = e.toLowerCase()) !== ir && e !== td) {
    const t = e8(e).resolvedOptions().calendar;
    if (Mu(e) !== Mu(t))
      throw new RangeError(RD(e));
    return t;
  }
  return e;
}
function Mu(e) {
  return e === "islamicc" && (e = "islamic"), e.split("-")[0];
}
function vD(e, t) {
  return (r) => r === ir ? e : r === td || r === zl ? Object.assign(Object.create(e), {
    id: r
  }) : Object.assign(Object.create(t), Udt(r));
}
function Nht(e, t, r, n) {
  const i = mc(r, n, La, [], jD);
  if (i.timeZone !== void 0) {
    const s = r.F(i), o = lg(i), a = e(i.timeZone);
    return {
      epochNanoseconds: Yp(t(a), {
        ...s,
        ...o
      }, i.offset !== void 0 ? eh(i.offset) : void 0),
      timeZone: a
    };
  }
  return {
    ...r.F(i),
    ...Ni
  };
}
function Dht(e, t, r, n, i, s) {
  const o = mc(r, i, La, DD, jD), a = e(o.timeZone), [l, c, h] = z2(s), u = r.F(o, H2(l)), p = lg(o, l);
  return Hs(Yp(t(a), {
    ...u,
    ...p
  }, o.offset !== void 0 ? eh(o.offset) : void 0, c, h), a, n);
}
function Bht(e, t, r) {
  const n = mc(e, t, La, [], Oa), i = cr(r);
  return Gs(Mi({
    ...e.F(n, H2(i)),
    ...lg(n, i)
  }));
}
function jht(e, t, r, n = []) {
  const i = mc(e, t, La, n);
  return e.F(i, r);
}
function Fht(e, t, r, n) {
  const i = mc(e, t, $E, n);
  return e.K(i, r);
}
function $ht(e, t, r, n) {
  const i = mc(e, r, La, ug);
  return t && i.month !== void 0 && i.monthCode === void 0 && i.year === void 0 && (i.year = ra), e._(i, n);
}
function zht(e, t) {
  return Bo(lg(ns(e, u4, [], 1), cr(t)));
}
function Vht(e) {
  const t = ns(e, zE);
  return un(th({
    ...kn,
    ...t
  }));
}
function mc(e, t, r, n = [], i = []) {
  return ns(t, [...e.fields(r), ...i].sort(), n);
}
function ns(e, t, r, n = !r) {
  const i = {};
  let s, o = 0;
  for (const a of t) {
    if (a === s)
      throw new RangeError(Cpt(a));
    if (a === "constructor" || a === "__proto__")
      throw new RangeError(kpt(a));
    let l = e[a];
    if (l !== void 0)
      o = 1, iC[a] && (l = iC[a](l, a)), i[a] = l;
    else if (r) {
      if (r.includes(a))
        throw new TypeError(NE(a));
      i[a] = zD[a];
    }
    s = a;
  }
  if (n && !o)
    throw new TypeError(CD(t));
  return i;
}
function lg(e, t) {
  return Wp(r8({
    ...zD,
    ...e
  }), t);
}
function Uht(e, t, r, n, i) {
  const { calendar: s, timeZone: o } = r, a = e(s), l = t(o), c = [...a.fields(La), ...BD].sort(), h = ((E) => {
    const A = is(E, Ue), x = ig(A.offsetNanoseconds), m = lb(E.calendar), [w, _, S] = m.v(A), [R, O] = m.q(w, _), $ = og(R, O);
    return {
      ...Zdt(A),
      year: w,
      monthCode: $,
      day: S,
      offset: x
    };
  })(r), u = ns(n, c), p = a.k(h, u), y = {
    ...h,
    ...u
  }, [g, b, f] = z2(i, 2);
  return Hs(Yp(l, {
    ...a.F(p, H2(g)),
    ...Wp(r8(y), g)
  }, eh(y.offset), b, f), o, s);
}
function Hht(e, t, r, n) {
  const i = e(t.calendar), s = [...i.fields(La), ...Oa].sort(), o = {
    ...xD(a = t),
    hour: a.isoHour,
    minute: a.isoMinute,
    second: a.isoSecond,
    millisecond: a.isoMillisecond,
    microsecond: a.isoMicrosecond,
    nanosecond: a.isoNanosecond
  };
  var a;
  const l = ns(r, s), c = cr(n), h = i.k(o, l), u = {
    ...o,
    ...l
  };
  return Gs(Mi({
    ...i.F(h, H2(c)),
    ...Wp(r8(u), c)
  }));
}
function Ght(e, t, r, n) {
  const i = e(t.calendar), s = i.fields(La).sort(), o = xD(t), a = ns(r, s), l = i.k(o, a);
  return i.F(l, n);
}
function Qht(e, t, r, n) {
  const i = e(t.calendar), s = i.fields($E).sort(), o = ((c) => {
    const h = lb(c.calendar), [u, p] = h.v(c), [y, g] = h.q(u, p);
    return {
      year: u,
      monthCode: og(y, g)
    };
  })(t), a = ns(r, s), l = i.k(o, a);
  return i.K(l, n);
}
function Wht(e, t, r, n) {
  const i = e(t.calendar), s = i.fields(La).sort(), o = ((c) => {
    const h = lb(c.calendar), [u, p, y] = h.v(c), [g, b] = h.q(u, p);
    return {
      monthCode: og(g, b),
      day: y
    };
  })(t), a = ns(r, s), l = i.k(o, a);
  return i._(l, n);
}
function qht(e, t, r) {
  return Bo(((n, i, s) => lg({
    ...Us(u4, n),
    ...ns(i, u4)
  }, cr(s)))(e, t, r));
}
function Yht(e, t) {
  return un((r = e, n = t, th({
    ...r,
    ...ns(n, zE)
  })));
  var r, n;
}
function wD(e, t, r, n, i) {
  t = Us(r = e.fields(r), t), n = ns(n, i = e.fields(i), []);
  let s = e.k(t, n);
  return s = ns(s, [...r, ...i].sort(), []), e.F(s);
}
function Iw(e, t) {
  const r = o4(e), n = UD[e.id || ""] || {};
  let { era: i, eraYear: s, year: o } = t;
  if (i !== void 0 || s !== void 0) {
    if (i === void 0 || s === void 0)
      throw new TypeError(Tpt);
    if (!r)
      throw new RangeError(Rpt);
    const a = r[n[i] || i];
    if (a === void 0)
      throw new RangeError(Lpt(i));
    const l = pD(s, a);
    if (o !== void 0 && o !== l)
      throw new RangeError(Opt);
    o = l;
  } else if (o === void 0)
    throw new TypeError(Mpt(r));
  return o;
}
function n1(e, t, r, n) {
  let { month: i, monthCode: s } = t;
  if (s !== void 0) {
    const o = ((a, l, c, h) => {
      const u = a.L(c), [p, y] = OE(l);
      let g = Km(p, y, u);
      if (y) {
        const b = dD(a);
        if (b === void 0)
          throw new RangeError($d);
        if (b > 0) {
          if (g > b)
            throw new RangeError($d);
          if (u === void 0) {
            if (h === 1)
              throw new RangeError($d);
            g--;
          }
        } else {
          if (g !== -b)
            throw new RangeError($d);
          if (u === void 0 && h === 1)
            throw new RangeError($d);
        }
      }
      return g;
    })(e, s, r, n);
    if (i !== void 0 && i !== o)
      throw new RangeError(Dpt);
    i = o, n = 1;
  } else if (i === void 0)
    throw new TypeError(PD);
  return da("month", i, 1, e.B(r), n);
}
function Pw(e, t, r, n, i) {
  return bi(t, "day", 1, e.U(n, r), i);
}
function Rw(e, t, r, n) {
  let i = 0;
  const s = [];
  for (const o of r)
    t[o] !== void 0 ? i = 1 : s.push(o);
  if (Object.assign(e, t), i)
    for (const o of n || s)
      delete e[o];
}
function xD(e) {
  const t = lb(e.calendar), [r, n, i] = t.v(e), [s, o] = t.q(r, n);
  return {
    year: r,
    monthCode: og(s, o),
    day: i
  };
}
function Kht(e) {
  return Pa(No(K5(W5(e))));
}
function Zht(e, t, r, n, i = ir) {
  return Hs(No(K5(W5(r))), t(n), e(i));
}
function Jht(e, t, r, n, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, h = ir) {
  return Gs(Mi($2(fa(Qn, Hp(ob, [t, r, n, i, s, o, a, l, c])))), e(h));
}
function Xht(e, t, r, n, i = ir) {
  return Ra(As(Ju(fa(Qn, {
    isoYear: t,
    isoMonth: r,
    isoDay: n
  }))), e(i));
}
function tpt(e, t, r, n = ir, i = 1) {
  const s = Qn(t), o = Qn(r), a = e(n);
  return Zf(J5(Ju({
    isoYear: s,
    isoMonth: o,
    isoDay: Qn(i)
  })), a);
}
function ept(e, t, r, n = ir, i = ra) {
  const s = Qn(t), o = Qn(r), a = e(n);
  return Wm(As(Ju({
    isoYear: Qn(i),
    isoMonth: s,
    isoDay: o
  })), a);
}
function rpt(e = 0, t = 0, r = 0, n = 0, i = 0, s = 0) {
  return Bo(Wp(fa(Qn, Hp(Qs, [e, t, r, n, i, s])), 1));
}
function npt(e = 0, t = 0, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0) {
  return un(th(fa(q5, Hp(gr, [e, t, r, n, i, s, o, a, l, c]))));
}
function ipt(e, t, r = ir) {
  return Hs(e.epochNanoseconds, t, r);
}
function spt(e) {
  return Pa(e.epochNanoseconds);
}
function ED(e, t) {
  return Gs(is(t, e));
}
function AD(e, t) {
  return Ra(is(t, e));
}
function SD(e, t) {
  return Bo(is(t, e));
}
function opt(e, t, r, n) {
  const i = ((s, o, a, l) => {
    const c = ((h) => JD(Do(h)))(l);
    return sg(s(o), a, c);
  })(e, r, t, n);
  return Hs(No(i), r, t.calendar);
}
function apt(e, t, r, n, i) {
  const s = e(i.timeZone), o = i.plainTime, a = o !== void 0 ? t(o) : void 0, l = r(s);
  let c;
  return c = a ? sg(l, {
    ...n,
    ...a
  }) : $l(l, {
    ...n,
    ...Ni
  }), Hs(c, s, n.calendar);
}
function lpt(e, t = Ni) {
  return Gs(Mi({
    ...e,
    ...t
  }));
}
function cpt(e, t, r) {
  return ((n, i) => {
    const s = mc(n, i, FD);
    return n.K(s, void 0);
  })(e(t.calendar), r);
}
function upt(e, t, r) {
  return ((n, i) => {
    const s = mc(n, i, $D);
    return n._(s);
  })(e(t.calendar), r);
}
function hpt(e, t, r, n) {
  return ((i, s, o) => wD(i, s, FD, rg(o), ug))(e(t.calendar), r, n);
}
function ppt(e, t, r, n) {
  return ((i, s, o) => wD(i, s, $D, rg(o), BE))(e(t.calendar), r, n);
}
function dpt(e) {
  return Pa(No(Gm(q5(e), Ta)));
}
function fpt(e) {
  return Pa(No(K5(W5(e))));
}
function rh(e, t, r) {
  const n = new Set(r);
  return (i, s) => {
    const o = r && Ck(i, r);
    if (!Ck(i = ((a, l) => {
      const c = {};
      for (const h in l)
        a.has(h) || (c[h] = l[h]);
      return c;
    })(n, i), e)) {
      if (s && o)
        throw new TypeError("Invalid formatting options");
      i = {
        ...t,
        ...i
      };
    }
    return r && (i.timeZone = nh, ["full", "long"].includes(i.J) && (i.J = "medium")), i;
  };
}
function yc(e, t = _D, r = 0) {
  const [n, , , i] = e;
  return (s, o = mft, ...a) => {
    const l = t(i && i(...a), s, o, n, r), c = l.resolvedOptions();
    return [l, ...gpt(e, c, a)];
  };
}
function _D(e, t, r, n, i) {
  if (r = n(r, i), e) {
    if (r.timeZone !== void 0)
      throw new TypeError(qpt);
    r.timeZone = e;
  }
  return new Al(t, r);
}
function gpt(e, t, r) {
  const [, n, i] = e;
  return r.map((s) => (s.calendar && ((o, a, l) => {
    if ((l || o !== ir) && o !== a)
      throw new RangeError(TD);
  })(s.calendar, t.calendar, i), n(s, t)));
}
function mpt(e, t, r) {
  const n = t.timeZone, i = e(n), s = {
    ...is(t, i),
    ...r || Ni
  };
  let o;
  return o = r ? Yp(i, s, s.offsetNanoseconds, 2) : $l(i, s), Hs(o, n, t.calendar);
}
function ypt(e, t = Ni) {
  return Gs(Mi({
    ...e,
    ...t
  }));
}
function ME(e, t) {
  return {
    ...e,
    calendar: t
  };
}
function bpt(e, t) {
  return {
    ...e,
    timeZone: t
  };
}
function Tw(e) {
  const t = a4();
  return Qp(t, e.R(t));
}
function a4() {
  return Gm(Date.now(), Ta);
}
function Fd() {
  return sC || (sC = new Al().resolvedOptions().timeZone);
}
const vpt = (e, t) => `Non-integer ${e}: ${t}`, wpt = (e, t) => `Non-positive ${e}: ${t}`, xpt = (e, t) => `Non-finite ${e}: ${t}`, Ept = (e) => `Cannot convert bigint to ${e}`, Apt = (e) => `Invalid bigint: ${e}`, Spt = "Cannot convert Symbol to string", _pt = "Invalid object", kD = (e, t, r, n, i) => i ? kD(e, i[t], i[r], i[n]) : bc(e, t) + `; must be between ${r}-${n}`, bc = (e, t) => `Invalid ${e}: ${t}`, NE = (e) => `Missing ${e}`, kpt = (e) => `Invalid field ${e}`, Cpt = (e) => `Duplicate field ${e}`, CD = (e) => "No valid fields: " + e.join(), Ipt = "Invalid bag", ID = (e, t, r) => bc(e, t) + "; must be " + Object.keys(r).join(), Ppt = "Cannot use valueOf", l4 = "Invalid calling context", Rpt = "Forbidden era/eraYear", Tpt = "Mismatching era/eraYear", Opt = "Mismatching year/eraYear", Lpt = (e) => `Invalid era: ${e}`, Mpt = (e) => "Missing year" + (e ? "/era/eraYear" : ""), Npt = (e) => `Invalid monthCode: ${e}`, Dpt = "Mismatching month/monthCode", PD = "Missing month/monthCode", $d = "Invalid leap month", Xp = "Invalid protocol results", RD = (e) => bc("Calendar", e), TD = "Mismatching Calendars", OD = (e) => bc("TimeZone", e), LD = "Mismatching TimeZones", Bpt = "Forbidden ICU TimeZone", jpt = "Out-of-bounds offset", Fpt = "Out-of-bounds TimeZone gap", $pt = "Invalid TimeZone offset", zpt = "Ambiguous offset", vc = "Out-of-bounds date", Vpt = "Out-of-bounds duration", Upt = "Cannot mix duration signs", nb = "Missing relativeTo", Hpt = "Cannot use large units", Gpt = "Required smallestUnit or largestUnit", Qpt = "smallestUnit > largestUnit", xi = (e) => `Cannot parse: ${e}`, ea = (e) => `Invalid substring: ${e}`, Wpt = (e) => `Cannot format ${e}`, Ow = "Mismatching types for formatting", qpt = "Cannot specify TimeZone", MD = /* @__PURE__ */ Je(N2, (e, t) => t), hp = /* @__PURE__ */ Je(N2, (e, t, r) => r), Ss = /* @__PURE__ */ Je(Hm, 2), c4 = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, DE = /* @__PURE__ */ Object.keys(c4), _i = 864e5, ND = 1e3, cg = 1e3, Ta = 1e6, fo = 1e9, ib = 6e10, sb = 36e11, Tr = 864e11, So = [1, cg, Ta, fo, ib, sb, Tr], Oa = /* @__PURE__ */ DE.slice(0, 6), u4 = /* @__PURE__ */ eg(Oa), Ypt = ["offset"], DD = ["timeZone"], BD = /* @__PURE__ */ Oa.concat(Ypt), jD = /* @__PURE__ */ BD.concat(DD), h4 = ["era", "eraYear"], Kpt = /* @__PURE__ */ h4.concat(["year"]), BE = ["year"], jE = ["monthCode"], FE = /* @__PURE__ */ ["month"].concat(jE), ug = ["day"], $E = /* @__PURE__ */ FE.concat(BE), FD = /* @__PURE__ */ jE.concat(BE), La = /* @__PURE__ */ ug.concat($E), Zpt = /* @__PURE__ */ ug.concat(FE), $D = /* @__PURE__ */ ug.concat(jE), zD = /* @__PURE__ */ hp(Oa, 0), ir = "iso8601", td = "gregory", zl = "japanese", VD = {
  [td]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [zl]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, UD = {
  [td]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [zl]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
}, Jpt = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, $n = /* @__PURE__ */ Je(G5, "string"), Xpt = /* @__PURE__ */ Je(G5, "boolean"), tdt = /* @__PURE__ */ Je(G5, "number"), gr = /* @__PURE__ */ DE.map((e) => e + "s"), zE = /* @__PURE__ */ eg(gr), edt = /* @__PURE__ */ gr.slice(0, 6), HD = /* @__PURE__ */ gr.slice(6), rdt = /* @__PURE__ */ HD.slice(1), ndt = /* @__PURE__ */ MD(gr), kn = /* @__PURE__ */ hp(gr, 0), VE = /* @__PURE__ */ hp(edt, 0), UE = /* @__PURE__ */ Je(gN, gr), Qs = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"], HE = ["isoDay", "isoMonth", "isoYear"], ob = /* @__PURE__ */ Qs.concat(HE), GE = /* @__PURE__ */ eg(HE), GD = /* @__PURE__ */ eg(Qs), idt = /* @__PURE__ */ eg(ob), Ni = /* @__PURE__ */ hp(GD, 0), sdt = /* @__PURE__ */ Je(gN, ob), QD = 1e8, odt = QD * _i, adt = [QD, 0], ldt = [-1e8, 0], e0 = 275760, r0 = -271821, Al = Intl.DateTimeFormat, WD = "en-GB", cdt = 1970, ra = 1972, Za = 12, udt = /* @__PURE__ */ Gp(1868, 9, 8), hdt = /* @__PURE__ */ es(Gut, WeakMap), Jm = "smallestUnit", p4 = "unit", mf = "roundingIncrement", Lw = "fractionalSecondDigits", qD = "relativeTo", Mw = "direction", YD = {
  constrain: 0,
  reject: 1
}, pdt = /* @__PURE__ */ Object.keys(YD), ddt = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}, fdt = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}, gdt = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}, mdt = {
  auto: 0,
  never: 1,
  critical: 2
}, ydt = {
  auto: 0,
  never: 1
}, bdt = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}, vdt = {
  previous: -1,
  next: 1
}, hg = /* @__PURE__ */ Je(aE, Jm), KD = /* @__PURE__ */ Je(aE, "largestUnit"), wdt = /* @__PURE__ */ Je(aE, p4), ZD = /* @__PURE__ */ Je(dc, "overflow", YD), JD = /* @__PURE__ */ Je(dc, "disambiguation", ddt), xdt = /* @__PURE__ */ Je(dc, "offset", fdt), QE = /* @__PURE__ */ Je(dc, "calendarName", gdt), Edt = /* @__PURE__ */ Je(dc, "timeZoneName", mdt), Adt = /* @__PURE__ */ Je(dc, "offset", ydt), pg = /* @__PURE__ */ Je(dc, "roundingMode", bdt), WE = "PlainYearMonth", qE = "PlainMonthDay", dg = "PlainDate", ed = "PlainDateTime", YE = "PlainTime", wc = "ZonedDateTime", KE = "Instant", ZE = "Duration", Sdt = [Math.floor, (e) => t1(e) ? Math.floor(e) : Math.round(e), Math.ceil, (e) => t1(e) ? Math.ceil(e) : Math.round(e), Math.trunc, (e) => t1(e) ? Math.trunc(e) || 0 : Math.round(e), (e) => e < 0 ? Math.floor(e) : Math.ceil(e), (e) => Math.sign(e) * Math.round(Math.abs(e)) || 0, (e) => t1(e) ? (e = Math.trunc(e) || 0) + e % 2 : Math.round(e)], nh = "UTC", j1 = 5184e3, _dt = /* @__PURE__ */ Qm(1847), kdt = /* @__PURE__ */ Qm(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10), Cdt = /0+$/, is = /* @__PURE__ */ es(oht, WeakMap), Idt = 2 ** 32 - 1, Ue = /* @__PURE__ */ es((e) => {
  const t = IE(e);
  return typeof t == "object" ? new Rdt(t) : new Pdt(t || 0);
});
class Pdt {
  constructor(t) {
    this.$ = t;
  }
  R() {
    return this.$;
  }
  I(t) {
    return ((r) => {
      const n = wn({
        ...r,
        ...Ni
      });
      if (!n || Math.abs(n[0]) > 1e8)
        throw new RangeError(vc);
    })(t), [X5(t, this.$)];
  }
  O() {
  }
}
class Rdt {
  constructor(t) {
    this.nn = ((r) => {
      function n(c) {
        const h = Kf(c, a, l), [u, p] = qk(h), y = s(u), g = s(p);
        return y === g ? y : i(o(u, p), y, g, c);
      }
      function i(c, h, u, p) {
        let y, g;
        for (; (p === void 0 || (y = p < c[0] ? h : p >= c[1] ? u : void 0) === void 0) && (g = c[1] - c[0]); ) {
          const b = c[0] + Math.floor(g / 2);
          r(b) === u ? c[1] = b : c[0] = b + 1;
        }
        return y;
      }
      const s = es(r), o = es(uht);
      let a = _dt, l = kdt;
      return {
        tn(c) {
          const h = n(c - 86400), u = n(c + 86400), p = c - h, y = c - u;
          if (h === u)
            return [p];
          const g = n(p);
          return g === n(y) ? [c - g] : h > u ? [p, y] : [];
        },
        rn: n,
        O(c, h) {
          const u = Kf(c, a, l);
          let [p, y] = qk(u);
          const g = j1 * h, b = h < 0 ? () => y > a || (a = u, 0) : () => p < l || (l = u, 0);
          for (; b(); ) {
            const f = s(p), E = s(y);
            if (f !== E) {
              const A = o(p, y);
              i(A, f, E);
              const x = A[0];
              if ((El(x, c) || 1) === h)
                return x;
            }
            p += g, y += g;
          }
        }
      };
    })(/* @__PURE__ */ ((r) => (n) => {
      const i = tE(r, n * ND);
      return Qm(mD(i), parseInt(i.month), parseInt(i.day), parseInt(i.hour), parseInt(i.minute), parseInt(i.second)) - n;
    })(t));
  }
  R(t) {
    return this.nn.rn(((r) => Rk(r)[0])(t)) * fo;
  }
  I(t) {
    const [r, n] = [Qm((i = t).isoYear, i.isoMonth, i.isoDay, i.isoHour, i.isoMinute, i.isoSecond), i.isoMillisecond * Ta + i.isoMicrosecond * cg + i.isoNanosecond];
    var i;
    return this.nn.tn(r).map((s) => No(Ou(Gm(s, fo), n)));
  }
  O(t, r) {
    const [n, i] = Rk(t), s = this.nn.O(n + (r > 0 || i ? 1 : 0), r);
    if (s !== void 0)
      return Gm(s, fo);
  }
}
const JE = "([+-])", F1 = "(?:[.,](\\d{1,9}))?", XD = `(?:(?:${JE}(\\d{6}))|(\\d{4}))-?(\\d{2})`, XE = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + F1 + ")?)?", t8 = JE + XE, Tdt = XD + "-?(\\d{2})(?:[T ]" + XE + "(Z|" + t8 + ")?)?", tB = "\\[(!?)([^\\]]*)\\]", ab = `((?:${tB}){0,9})`, Odt = /* @__PURE__ */ Zp(XD + ab), Ldt = /* @__PURE__ */ Zp("(?:--)?(\\d{2})-?(\\d{2})" + ab), Mdt = /* @__PURE__ */ Zp(Tdt + ab), Ndt = /* @__PURE__ */ Zp("T?" + XE + "(?:" + t8 + ")?" + ab), Ddt = /* @__PURE__ */ Zp(t8), Bdt = /* @__PURE__ */ new RegExp(tB, "g"), jdt = /* @__PURE__ */ Zp(`${JE}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${F1}H)?(?:(\\d+)${F1}M)?(?:(\\d+)${F1}S)?)?`), Fdt = /* @__PURE__ */ es((e) => new Al(WD, {
  timeZone: e,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
})), $dt = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, zdt = /[^\w\/:+-]+/, Vdt = /^M(\d{2})(L?)$/, Udt = /* @__PURE__ */ es(Oht), e8 = /* @__PURE__ */ es((e) => new Al(WD, {
  calendar: e,
  timeZone: nh,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
})), eB = {
  P(e, t, r) {
    const n = cr(r);
    let i, { years: s, months: o, weeks: a, days: l } = t;
    if (l += _n(t, 5)[0], s || o)
      i = ((c, h, u, p, y) => {
        let [g, b, f] = c.v(h);
        if (u) {
          const [E, A] = c.q(g, b);
          g += u, b = Km(E, A, c.L(g)), b = da("month", b, 1, c.B(g), y);
        }
        return p && ([g, b] = c.un(g, b, p)), f = da("day", f, 1, c.U(g, b), y), c.p(g, b, f);
      })(this, e, s, o, n);
    else {
      if (!a && !l)
        return e;
      i = Zn(e);
    }
    if (i === void 0)
      throw new RangeError(vc);
    return i += (7 * a + l) * _i, As(F2(i));
  },
  N(e, t, r) {
    if (r <= 7) {
      let l = 0, c = cD({
        ...e,
        ...Ni
      }, {
        ...t,
        ...Ni
      });
      return r === 7 && ([l, c] = Bl(c, 7)), {
        ...kn,
        weeks: l,
        days: c
      };
    }
    const n = this.v(e), i = this.v(t);
    let [s, o, a] = ((l, c, h, u, p, y, g) => {
      let b = p - c, f = y - h, E = g - u;
      if (b || f) {
        const A = Math.sign(b || f);
        let x = l.U(p, y), m = 0;
        if (Math.sign(E) === -A) {
          const w = x;
          [p, y] = l.un(p, y, -A), b = p - c, f = y - h, x = l.U(p, y), m = A < 0 ? -w : x;
        }
        if (E = g - Math.min(u, x) + m, b) {
          const [w, _] = l.q(c, h), [S, R] = l.q(p, y);
          if (f = S - w || Number(R) - Number(_), Math.sign(f) === -A) {
            const O = A < 0 && -l.B(p);
            b = (p -= A) - c, f = y - Km(w, _, l.L(p)) + (O || l.B(p));
          }
        }
      }
      return [b, f, E];
    })(this, ...n, ...i);
    return r === 8 && (o += this.cn(s, n[0]), s = 0), {
      ...kn,
      years: s,
      months: o,
      days: a
    };
  },
  F(e, t) {
    const r = cr(t), n = Iw(this, e), i = n1(this, e, n, r), s = Pw(this, e, i, n, r);
    return Ra(As(this.V(n, i, s)), this.id || ir);
  },
  K(e, t) {
    const r = cr(t), n = Iw(this, e), i = n1(this, e, n, r);
    return Zf(J5(this.V(n, i, 1)), this.id || ir);
  },
  _(e, t) {
    const r = cr(t);
    let n, i, s, o = e.eraYear !== void 0 || e.year !== void 0 ? Iw(this, e) : void 0;
    const a = !this.id;
    if (o === void 0 && a && (o = ra), o !== void 0) {
      const u = n1(this, e, o, r);
      n = Pw(this, e, u, o, r);
      const p = this.L(o);
      i = LE(u, p), s = u === p;
    } else {
      if (e.monthCode === void 0)
        throw new TypeError(PD);
      if ([i, s] = OE(e.monthCode), this.id && this.id !== td && this.id !== zl)
        if (this.id && Mu(this.id) === "coptic" && r === 0) {
          const u = s || i !== 13 ? 30 : 6;
          n = e.day, n = Kf(n, 1, u);
        } else if (this.id && Mu(this.id) === "chinese" && r === 0) {
          const u = !s || i !== 1 && i !== 9 && i !== 10 && i !== 11 && i !== 12 ? 30 : 29;
          n = e.day, n = Kf(n, 1, u);
        } else
          n = e.day;
      else
        n = Pw(this, e, n1(this, e, ra, r), ra, r);
    }
    const l = this.G(i, s, n);
    if (!l)
      throw new RangeError("Cannot guess year");
    const [c, h] = l;
    return Wm(As(this.V(c, h, n)), this.id || ir);
  },
  fields(e) {
    return o4(this) && e.includes("year") ? [...e, ...h4] : e;
  },
  k(e, t) {
    const r = Object.assign(/* @__PURE__ */ Object.create(null), e);
    return Rw(r, t, FE), o4(this) && (Rw(r, t, Kpt), this.id === zl && Rw(r, t, Zpt, h4)), r;
  },
  inLeapYear(e) {
    const [t] = this.v(e);
    return this.sn(t);
  },
  monthsInYear(e) {
    const [t] = this.v(e);
    return this.B(t);
  },
  daysInMonth(e) {
    const [t, r] = this.v(e);
    return this.U(t, r);
  },
  daysInYear(e) {
    const [t] = this.v(e);
    return this.fn(t);
  },
  dayOfYear: TE,
  era(e) {
    return this.hn(e)[0];
  },
  eraYear(e) {
    return this.hn(e)[1];
  },
  monthCode(e) {
    const [t, r] = this.v(e), [n, i] = this.q(t, r);
    return og(n, i);
  },
  dayOfWeek: IN,
  daysInWeek() {
    return 7;
  }
}, Hdt = {
  v: eE,
  hn: PN,
  q: SN
}, Gdt = {
  dayOfYear: TE,
  v: eE,
  p: Gp
}, Qdt = /* @__PURE__ */ Object.assign({}, Gdt, {
  weekOfYear: uD,
  yearOfWeek: hD,
  m(e) {
    function t(y) {
      return (7 - y < n ? 7 : 0) - y;
    }
    function r(y) {
      const g = CN(p + y), b = y || 1, f = t(gf(l + g * b, 7));
      return h = (g + (f - c) * b) / 7;
    }
    const n = this.id ? 1 : 4, i = IN(e), s = this.dayOfYear(e), o = gf(i - 1, 7), a = s - 1, l = gf(o - a, 7), c = t(l);
    let h, u = Math.floor((a - c) / 7) + 1, p = e.isoYear;
    return u ? u > r(0) && (u = 1, p++) : (u = r(-1), p--), [u, p, h];
  }
}), Wdt = /* @__PURE__ */ Object.assign({}, eB, Qdt, {
  v: eE,
  hn: PN,
  q: SN,
  G(e, t) {
    if (!t)
      return [ra, e];
  },
  sn: rE,
  L() {
  },
  B: _N,
  cn: (e) => e * Za,
  U: kN,
  fn: CN,
  V: (e, t, r) => ({
    isoYear: e,
    isoMonth: t,
    isoDay: r
  }),
  p: Gp,
  un: (e, t, r) => (e += D2(r, Za), (t += U5(r, Za)) < 1 ? (e--, t += Za) : t > Za && (e++, t -= Za), [e, t]),
  year(e) {
    return e.isoYear;
  },
  month(e) {
    return e.isoMonth;
  },
  day: (e) => e.isoDay
}), qdt = {
  v: Zm,
  hn: bD,
  q: yD
}, Ydt = {
  dayOfYear: TE,
  v: Zm,
  p: t0,
  weekOfYear: uD,
  yearOfWeek: hD,
  m() {
    return [];
  }
}, Kdt = /* @__PURE__ */ Object.assign({}, eB, Ydt, {
  v: Zm,
  hn: bD,
  q: yD,
  G(e, t, r) {
    const n = this.id && Mu(this.id) === "chinese" ? ((c, h, u) => {
      if (h)
        switch (c) {
          case 1:
            return 1651;
          case 2:
            return u < 30 ? 1947 : 1765;
          case 3:
            return u < 30 ? 1966 : 1955;
          case 4:
            return u < 30 ? 1963 : 1944;
          case 5:
            return u < 30 ? 1971 : 1952;
          case 6:
            return u < 30 ? 1960 : 1941;
          case 7:
            return u < 30 ? 1968 : 1938;
          case 8:
            return u < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      return 1972;
    })(e, t, r) : ra;
    let [i, s, o] = Zm.call(this, {
      isoYear: n,
      isoMonth: Za,
      isoDay: 31
    });
    const a = B1.call(this, i), l = s === a;
    (El(e, LE(s, a)) || El(Number(t), Number(l)) || El(r, o)) === 1 && i--;
    for (let c = 0; c < 100; c++) {
      const h = i - c, u = B1.call(this, h), p = Km(e, t, u);
      if (t === (p === u) && r <= rC.call(this, h, p))
        return [h, p];
    }
  },
  sn(e) {
    const t = e1.call(this, e);
    return t > e1.call(this, e - 1) && t > e1.call(this, e + 1);
  },
  L: B1,
  B: r1,
  cn(e, t) {
    const r = t + e, n = Math.sign(e), i = n < 0 ? -1 : 0;
    let s = 0;
    for (let o = t; o !== r; o += n)
      s += r1.call(this, o + i);
    return s;
  },
  U: rC,
  fn: e1,
  V(e, t, r) {
    return F2(t0.call(this, e, t, r));
  },
  p: t0,
  un(e, t, r) {
    if (r) {
      if (t += r, !Number.isSafeInteger(t))
        throw new RangeError(vc);
      if (r < 0)
        for (; t < 1; )
          t += r1.call(this, --e);
      else {
        let n;
        for (; t > (n = r1.call(this, e)); )
          t -= n, e++;
      }
    }
    return [e, t];
  },
  year(e) {
    return this.h(e).year;
  },
  month(e) {
    const { year: t, o: r } = this.h(e), { u: n } = this.l(t);
    return n[r] + 1;
  },
  day(e) {
    return this.h(e).day;
  }
}), lb = /* @__PURE__ */ vD(Hdt, qdt), Me = /* @__PURE__ */ vD(Wdt, Kdt), iC = {
  era: D1,
  eraYear: Qn,
  year: Qn,
  month: Pk,
  monthCode(e) {
    const t = D1(e);
    return OE(t), t;
  },
  day: Pk,
  .../* @__PURE__ */ hp(Oa, Qn),
  .../* @__PURE__ */ hp(gr, q5),
  offset(e) {
    const t = D1(e);
    return eh(t), t;
  }
}, r8 = /* @__PURE__ */ Je(dN, Oa, Qs), Zdt = /* @__PURE__ */ Je(dN, Qs, Oa), Sl = "numeric", fg = ["timeZoneName"], rB = {
  month: Sl,
  day: Sl
}, n8 = {
  year: Sl,
  month: Sl
}, i8 = /* @__PURE__ */ Object.assign({}, n8, {
  day: Sl
}), s8 = {
  hour: Sl,
  minute: Sl,
  second: Sl
}, o8 = /* @__PURE__ */ Object.assign({}, i8, s8), Jdt = /* @__PURE__ */ Object.assign({}, o8, {
  timeZoneName: "short"
}), Xdt = /* @__PURE__ */ Object.keys(n8), tft = /* @__PURE__ */ Object.keys(rB), eft = /* @__PURE__ */ Object.keys(i8), rft = /* @__PURE__ */ Object.keys(s8), a8 = ["dateStyle"], nft = /* @__PURE__ */ Xdt.concat(a8), ift = /* @__PURE__ */ tft.concat(a8), l8 = /* @__PURE__ */ eft.concat(a8, ["weekday"]), gg = /* @__PURE__ */ rft.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]), c8 = /* @__PURE__ */ l8.concat(gg), sft = /* @__PURE__ */ fg.concat(gg), oft = /* @__PURE__ */ fg.concat(l8), aft = /* @__PURE__ */ fg.concat(["day", "weekday"], gg), lft = /* @__PURE__ */ fg.concat(["year", "weekday"], gg), cft = /* @__PURE__ */ rh(c8, o8), uft = /* @__PURE__ */ rh(c8, Jdt), hft = /* @__PURE__ */ rh(c8, o8, fg), pft = /* @__PURE__ */ rh(l8, i8, sft), dft = /* @__PURE__ */ rh(gg, s8, oft), fft = /* @__PURE__ */ rh(nft, n8, aft), gft = /* @__PURE__ */ rh(ift, rB, lft), mft = {}, nB = new Al(void 0, {
  calendar: ir
}).resolvedOptions().calendar === ir, iB = [cft, lE], yft = [uft, lE, 0, (e, t) => {
  const r = e.timeZone;
  if (t && t.timeZone !== r)
    throw new RangeError(LD);
  return r;
}], sB = [hft, Zn], oB = [pft, Zn], aB = [dft, (e) => jl(e) / Ta], lB = [fft, Zn, nB], cB = [gft, Zn, nB];
let sC;
function xc(e, t, r, n, i) {
  function s(...l) {
    if (!(this instanceof s))
      throw new TypeError(l4);
    lC(this, t(...l));
  }
  function o(l, c) {
    return Object.defineProperties(function(...h) {
      return l.call(this, a(this), ...h);
    }, Yf(c));
  }
  function a(l) {
    const c = ai(l);
    if (!c || c.branding !== e)
      throw new TypeError(l4);
    return c;
  }
  return Object.defineProperties(s.prototype, {
    ...Vut(fa(o, r)),
    ...lp(fa(o, n)),
    ...V5("Temporal." + e)
  }), Object.defineProperties(s, {
    ...lp(i),
    ...Yf(e)
  }), [s, (l) => {
    const c = Object.create(s.prototype);
    return lC(c, l), c;
  }, a];
}
function rd(e) {
  if (ai(e) || e.calendar !== void 0 || e.timeZone !== void 0)
    throw new TypeError(Ipt);
  return e;
}
function mg(e) {
  return uB(e) || ir;
}
function uB(e) {
  const { calendar: t } = e;
  if (t !== void 0)
    return cb(t);
}
function cb(e) {
  if (si(e)) {
    const { calendar: t } = ai(e) || {};
    if (!t)
      throw new TypeError(RD(e));
    return t;
  }
  return ((t) => rb(vht($n(t))))(e);
}
function u8(e) {
  const t = {};
  for (const r in e)
    t[r] = (n) => {
      const { calendar: i } = n;
      return Me(i)[r](n);
    };
  return t;
}
function Ec() {
  throw new TypeError(Ppt);
}
function Wi(e) {
  if (si(e)) {
    const { timeZone: t } = ai(e) || {};
    if (!t)
      throw new TypeError(OD(e));
    return t;
  }
  return ((t) => CE(wht($n(t))))(e);
}
function tn(e) {
  if (si(e)) {
    const t = ai(e);
    return t && t.branding === ZE ? t : Vht(e);
  }
  return bht(e);
}
function zd(e) {
  if (e !== void 0) {
    if (si(e)) {
      const t = ai(e) || {};
      switch (t.branding) {
        case wc:
        case dg:
          return t;
        case ed:
          return Ra(t);
      }
      const r = mg(e);
      return {
        ...Nht(Wi, Ue, Me(r), e),
        calendar: r
      };
    }
    return pht(e);
  }
}
function Ja(e, t) {
  if (si(e)) {
    const n = ai(e) || {};
    switch (n.branding) {
      case YE:
        return cr(t), n;
      case ed:
        return cr(t), Bo(n);
      case wc:
        return cr(t), SD(Ue, n);
    }
    return zht(e, t);
  }
  const r = yht(e);
  return cr(t), r;
}
function h8(e) {
  return e === void 0 ? void 0 : Ja(e);
}
function yh(e, t) {
  if (si(e)) {
    const n = ai(e) || {};
    switch (n.branding) {
      case ed:
        return cr(t), n;
      case dg:
        return cr(t), Gs({
          ...n,
          ...Ni
        });
      case wc:
        return cr(t), ED(Ue, n);
    }
    return Bht(Me(mg(e)), e, t);
  }
  const r = fht(e);
  return cr(t), r;
}
function oC(e, t) {
  if (si(e)) {
    const n = ai(e);
    if (n && n.branding === qE)
      return cr(t), n;
    const i = uB(e);
    return $ht(Me(i || ir), !i, e, t);
  }
  const r = mht(Me, e);
  return cr(t), r;
}
function bh(e, t) {
  if (si(e)) {
    const n = ai(e);
    return n && n.branding === WE ? (cr(t), n) : Fht(Me(mg(e)), e, t);
  }
  const r = ght(Me, e);
  return cr(t), r;
}
function vh(e, t) {
  if (si(e)) {
    const n = ai(e) || {};
    switch (n.branding) {
      case dg:
        return cr(t), n;
      case ed:
        return cr(t), Ra(n);
      case wc:
        return cr(t), AD(Ue, n);
    }
    return jht(Me(mg(e)), e, t);
  }
  const r = wE(e);
  return cr(t), r;
}
function wh(e, t) {
  if (si(e)) {
    const r = ai(e);
    if (r && r.branding === wc)
      return z2(t), r;
    const n = mg(e);
    return Dht(Wi, Ue, Me(n), n, e, t);
  }
  return dht(e, t);
}
function aC(e) {
  return fa((t) => (r) => t(d4(r)), e);
}
function d4(e) {
  return is(e, Ue);
}
function xh(e) {
  if (si(e)) {
    const t = ai(e);
    if (t)
      switch (t.branding) {
        case KE:
          return t;
        case wc:
          return Pa(t.epochNanoseconds);
      }
  }
  return hht(e);
}
function bft() {
  function e(s, o) {
    return new t(s, o);
  }
  function t(s, o = /* @__PURE__ */ Object.create(null)) {
    ey.set(this, ((a, l) => {
      const c = new Al(a, l), h = c.resolvedOptions(), u = h.locale, p = Us(Object.keys(l), h), y = es(xft), g = (b, ...f) => {
        if (b) {
          if (f.length !== 2)
            throw new TypeError(Ow);
          for (const m of f)
            if (m === void 0)
              throw new TypeError(Ow);
        }
        b || f[0] !== void 0 || (f = []);
        const E = f.map((m) => ai(m) || Number(m));
        let A, x = 0;
        for (const m of E) {
          const w = typeof m == "object" ? m.branding : void 0;
          if (x++ && w !== A)
            throw new TypeError(Ow);
          A = w;
        }
        return A ? y(A)(u, p, ...E) : [c, ...E];
      };
      return g.X = c, g;
    })(s, o));
  }
  const r = Al.prototype, n = Object.getOwnPropertyDescriptors(r), i = Object.getOwnPropertyDescriptors(Al);
  for (const s in n) {
    const o = n[s], a = s.startsWith("format") && vft(s);
    typeof o.value == "function" ? o.value = s === "constructor" ? e : a || wft(s) : a && (o.get = function() {
      if (!ey.has(this))
        throw new TypeError(l4);
      return (...l) => a.apply(this, l);
    }, Object.defineProperties(o.get, Yf(`get ${s}`)));
  }
  return i.prototype.value = t.prototype = Object.create({}, n), Object.defineProperties(e, i), e;
}
function vft(e) {
  return Object.defineProperties(function(...t) {
    const r = ey.get(this), [n, ...i] = r(e.includes("Range"), ...t);
    return n[e](...i);
  }, Yf(e));
}
function wft(e) {
  return Object.defineProperties(function(...t) {
    return ey.get(this).X[e](...t);
  }, Yf(e));
}
function xft(e) {
  const t = Cft[e];
  if (!t)
    throw new TypeError(Wpt(e));
  return yc(t, es(_D), 1);
}
const Xm = /* @__PURE__ */ new WeakMap(), ai = /* @__PURE__ */ Xm.get.bind(Xm), lC = /* @__PURE__ */ Xm.set.bind(Xm), hB = {
  era: Uut,
  eraYear: yN,
  year: H5,
  month: Qo,
  daysInMonth: Qo,
  daysInYear: Qo,
  inLeapYear: Xpt,
  monthsInYear: Qo
}, p8 = {
  monthCode: $n
}, pB = {
  day: Qo
}, Eft = {
  dayOfWeek: Qo,
  dayOfYear: Qo,
  weekOfYear: Hut,
  yearOfWeek: yN,
  daysInWeek: Qo
}, d8 = /* @__PURE__ */ u8(/* @__PURE__ */ Object.assign({}, hB, p8, pB, Eft)), Aft = /* @__PURE__ */ u8({
  ...hB,
  ...p8
}), Sft = /* @__PURE__ */ u8({
  ...p8,
  ...pB
}), yg = {
  calendarId: (e) => e.calendar
}, _ft = /* @__PURE__ */ N2((e) => (t) => t[e], gr.concat("sign")), f8 = /* @__PURE__ */ N2((e, t) => (r) => r[Qs[t]], Oa), dB = {
  epochMilliseconds: lE,
  epochNanoseconds: Wut
}, [kft, Gr, Q5t] = xc(ZE, npt, {
  ..._ft,
  blank: cht
}, {
  with: (e, t) => Gr(Yht(e, t)),
  negated: (e) => Gr(vE(e)),
  abs: (e) => Gr(lht(e)),
  add: (e, t, r) => Gr(Wk(zd, Me, Ue, 0, e, tn(t), r)),
  subtract: (e, t, r) => Gr(Wk(zd, Me, Ue, 1, e, tn(t), r)),
  round: (e, t) => Gr(aht(zd, Me, Ue, e, t)),
  total: (e, t) => qut(zd, Me, Ue, e, t),
  toLocaleString(e, t, r) {
    return Intl.DurationFormat ? new Intl.DurationFormat(t, r).format(this) : Cw(e);
  },
  toString: Cw,
  toJSON: (e) => Cw(e),
  valueOf: Ec
}, {
  from: (e) => Gr(tn(e)),
  compare: (e, t, r) => Eht(zd, Me, Ue, tn(e), tn(t), r)
}), Cft = {
  Instant: iB,
  PlainDateTime: sB,
  PlainDate: oB,
  PlainTime: aB,
  PlainYearMonth: lB,
  PlainMonthDay: cB
}, Ift = /* @__PURE__ */ yc(iB), Pft = /* @__PURE__ */ yc(yft), Rft = /* @__PURE__ */ yc(sB), Tft = /* @__PURE__ */ yc(oB), Oft = /* @__PURE__ */ yc(aB), Lft = /* @__PURE__ */ yc(lB), Mft = /* @__PURE__ */ yc(cB), [Nft, ll] = xc(YE, rpt, f8, {
  with(e, t, r) {
    return ll(qht(this, rd(t), r));
  },
  add: (e, t) => ll(Qk(0, e, tn(t))),
  subtract: (e, t) => ll(Qk(1, e, tn(t))),
  until: (e, t, r) => Gr(eC(0, e, Ja(t), r)),
  since: (e, t, r) => Gr(eC(1, e, Ja(t), r)),
  round: (e, t) => ll(Jut(e, t)),
  equals: (e, t) => Pht(e, Ja(t)),
  toLocaleString(e, t, r) {
    const [n, i] = Oft(t, r, e);
    return n.format(i);
  },
  toString: Fk,
  toJSON: (e) => Fk(e),
  valueOf: Ec
}, {
  from: (e, t) => ll(Ja(e, t)),
  compare: (e, t) => PE(Ja(e), Ja(t))
}), [Dft, ro] = xc(ed, Je(Jht, ag), {
  ...yg,
  ...d8,
  ...f8
}, {
  with: (e, t, r) => ro(Hht(Me, e, rd(t), r)),
  withCalendar: (e, t) => ro(ME(e, cb(t))),
  withPlainTime: (e, t) => ro(ypt(e, h8(t))),
  add: (e, t, r) => ro(Uk(Me, 0, e, tn(t), r)),
  subtract: (e, t, r) => ro(Uk(Me, 1, e, tn(t), r)),
  until: (e, t, r) => Gr(Jk(Me, 0, e, yh(t), r)),
  since: (e, t, r) => Gr(Jk(Me, 1, e, yh(t), r)),
  round: (e, t) => ro(Zut(e, t)),
  equals: (e, t) => _ht(e, yh(t)),
  toZonedDateTime: (e, t, r) => Un(opt(Ue, e, Wi(t), r)),
  toPlainDate: (e) => ao(Ra(e)),
  toPlainTime: (e) => ll(Bo(e)),
  toLocaleString(e, t, r) {
    const [n, i] = Rft(t, r, e);
    return n.format(i);
  },
  toString: Nk,
  toJSON: (e) => Nk(e),
  valueOf: Ec
}, {
  from: (e, t) => ro(yh(e, t)),
  compare: (e, t) => nD(yh(e), yh(t))
}), [Bft, f4, W5t] = xc(qE, Je(ept, ag), {
  ...yg,
  ...Sft
}, {
  with: (e, t, r) => f4(Wht(Me, e, rd(t), r)),
  equals: (e, t) => Iht(e, oC(t)),
  toPlainDate(e, t) {
    return ao(ppt(Me, e, this, t));
  },
  toLocaleString(e, t, r) {
    const [n, i] = Mft(t, r, e);
    return n.format(i);
  },
  toString: jk,
  toJSON: (e) => jk(e),
  valueOf: Ec
}, {
  from: (e, t) => f4(oC(e, t))
}), [jft, Kd, q5t] = xc(WE, Je(tpt, ag), {
  ...yg,
  ...Aft
}, {
  with: (e, t, r) => Kd(Qht(Me, e, rd(t), r)),
  add: (e, t, r) => Kd(Gk(Me, 0, e, tn(t), r)),
  subtract: (e, t, r) => Kd(Gk(Me, 1, e, tn(t), r)),
  until: (e, t, r) => Gr(tC(Me, 0, e, bh(t), r)),
  since: (e, t, r) => Gr(tC(Me, 1, e, bh(t), r)),
  equals: (e, t) => Cht(e, bh(t)),
  toPlainDate(e, t) {
    return ao(hpt(Me, e, this, t));
  },
  toLocaleString(e, t, r) {
    const [n, i] = Lft(t, r, e);
    return n.format(i);
  },
  toString: Bk,
  toJSON: (e) => Bk(e),
  valueOf: Ec
}, {
  from: (e, t) => Kd(bh(e, t)),
  compare: (e, t) => Jp(bh(e), bh(t))
}), [Fft, ao, Y5t] = xc(dg, Je(Xht, ag), {
  ...yg,
  ...d8
}, {
  with: (e, t, r) => ao(Ght(Me, e, rd(t), r)),
  withCalendar: (e, t) => ao(ME(e, cb(t))),
  add: (e, t, r) => ao(Hk(Me, 0, e, tn(t), r)),
  subtract: (e, t, r) => ao(Hk(Me, 1, e, tn(t), r)),
  until: (e, t, r) => Gr(Xk(Me, 0, e, vh(t), r)),
  since: (e, t, r) => Gr(Xk(Me, 1, e, vh(t), r)),
  equals: (e, t) => kht(e, vh(t)),
  toZonedDateTime(e, t) {
    const r = si(t) ? t : {
      timeZone: t
    };
    return Un(apt(Wi, Ja, Ue, e, r));
  },
  toPlainDateTime: (e, t) => ro(lpt(e, h8(t))),
  toPlainYearMonth(e) {
    return Kd(cpt(Me, e, this));
  },
  toPlainMonthDay(e) {
    return f4(upt(Me, e, this));
  },
  toLocaleString(e, t, r) {
    const [n, i] = Tft(t, r, e);
    return n.format(i);
  },
  toString: Dk,
  toJSON: (e) => Dk(e),
  valueOf: Ec
}, {
  from: (e, t) => ao(vh(e, t)),
  compare: (e, t) => Jp(vh(e), vh(t))
}), [$ft, Un] = xc(wc, Je(Zht, ag, xht), {
  ...dB,
  ...yg,
  ...aC(d8),
  ...aC(f8),
  offset: (e) => ig(d4(e).offsetNanoseconds),
  offsetNanoseconds: (e) => d4(e).offsetNanoseconds,
  timeZoneId: (e) => e.timeZone,
  hoursInDay: (e) => Xut(Ue, e)
}, {
  with: (e, t, r) => Un(Uht(Me, Ue, e, rd(t), r)),
  withCalendar: (e, t) => Un(ME(e, cb(t))),
  withTimeZone: (e, t) => Un(bpt(e, Wi(t))),
  withPlainTime: (e, t) => Un(mpt(Ue, e, h8(t))),
  add: (e, t, r) => Un(Vk(Me, Ue, 0, e, tn(t), r)),
  subtract: (e, t, r) => Un(Vk(Me, Ue, 1, e, tn(t), r)),
  until: (e, t, r) => Gr(un(Zk(Me, Ue, 0, e, wh(t), r))),
  since: (e, t, r) => Gr(un(Zk(Me, Ue, 1, e, wh(t), r))),
  round: (e, t) => Un(Kut(Ue, e, t)),
  startOfDay: (e) => Un(tht(Ue, e)),
  equals: (e, t) => Sht(e, wh(t)),
  toInstant: (e) => Xa(spt(e)),
  toPlainDateTime: (e) => ro(ED(Ue, e)),
  toPlainDate: (e) => ao(AD(Ue, e)),
  toPlainTime: (e) => ll(SD(Ue, e)),
  toLocaleString(e, t, r = {}) {
    const [n, i] = Pft(t, r, e);
    return n.format(i);
  },
  toString: (e, t) => Mk(Ue, e, t),
  toJSON: (e) => Mk(Ue, e),
  valueOf: Ec,
  getTimeZoneTransition(e, t) {
    const { timeZone: r, epochNanoseconds: n } = e, i = Qut(t), s = Ue(r).O(n, i);
    return s ? Un({
      ...e,
      epochNanoseconds: s
    }) : null;
  }
}, {
  from: (e, t) => Un(wh(e, t)),
  compare: (e, t) => rD(wh(e), wh(t))
}), [zft, Xa, K5t] = xc(KE, Kht, dB, {
  add: (e, t) => Xa(zk(0, e, tn(t))),
  subtract: (e, t) => Xa(zk(1, e, tn(t))),
  until: (e, t, r) => Gr(Kk(0, e, xh(t), r)),
  since: (e, t, r) => Gr(Kk(1, e, xh(t), r)),
  round: (e, t) => Xa(Yut(e, t)),
  equals: (e, t) => Aht(e, xh(t)),
  toZonedDateTimeISO: (e, t) => Un(ipt(e, Wi(t))),
  toLocaleString(e, t, r) {
    const [n, i] = Ift(t, r, e);
    return n.format(i);
  },
  toString: (e, t) => Lk(Wi, Ue, e, t),
  toJSON: (e) => Lk(Wi, Ue, e),
  valueOf: Ec
}, {
  from: (e) => Xa(xh(e)),
  fromEpochMilliseconds: (e) => Xa(dpt(e)),
  fromEpochNanoseconds: (e) => Xa(fpt(e)),
  compare: (e, t) => eD(xh(e), xh(t))
}), Vft = /* @__PURE__ */ Object.defineProperties({}, {
  ...V5("Temporal.Now"),
  ...lp({
    timeZoneId: () => Fd(),
    instant: () => Xa(Pa(a4())),
    zonedDateTimeISO: (e = Fd()) => Un(Hs(a4(), Wi(e), ir)),
    plainDateTimeISO: (e = Fd()) => ro(Gs(Tw(Ue(Wi(e))), ir)),
    plainDateISO: (e = Fd()) => ao(Ra(Tw(Ue(Wi(e))), ir)),
    plainTimeISO: (e = Fd()) => ll(Bo(Tw(Ue(Wi(e)))))
  })
}), ty = /* @__PURE__ */ Object.defineProperties({}, {
  ...V5("Temporal"),
  ...lp({
    PlainYearMonth: jft,
    PlainMonthDay: Bft,
    PlainDate: Fft,
    PlainTime: Nft,
    PlainDateTime: Dft,
    ZonedDateTime: $ft,
    Instant: zft,
    Duration: kft,
    Now: Vft
  })
}), Uft = /* @__PURE__ */ bft(), ey = /* @__PURE__ */ new WeakMap();
lp({
  DateTimeFormat: Uft
});
function ub(e) {
  Object.freeze(e);
  for (const t in e)
    typeof e == "object" && ub(e[t]);
}
function Hft(e) {
  return Object.keys(e).length === 0;
}
function Mh(e) {
  return { type: "connective", real: yr(e) };
}
function $1(e, t, r) {
  return {
    type: "simple-category",
    subtype: "currency",
    noun: yr(e),
    symbol: t,
    pos: r
  };
}
function gi(e, t) {
  return t ? { type: "direction", direction: yr(e), aux: t } : { type: "direction", direction: yr(e) };
}
function yr(e) {
  return { en: e };
}
const Nh = function(e, t) {
  const r = { type: "simple-category" };
  if (Hft(e))
    throw new Error("[grammatize-information]: The category helper function must be called with at least one lemma.");
  for (const n in e) {
    const i = n;
    r[i] = yr(e[i]);
  }
  return t && (r.quasiname = !0), r;
};
function kr(e) {
  return { type: "simple-category", noun: yr(e) };
}
function Dh(e, t) {
  return { type: "simple-category", adj: yr(e), inessential: t ?? !1 };
}
function fB(e) {
  return { type: "simple-category", pastParticiple: yr(e) };
}
function Mn(e, t) {
  return t ? { type: "predicate", pred: yr(e), aux: yr(t) } : { type: "predicate", pred: yr(e) };
}
function z1(e) {
  return { type: "simple-category", subtype: "unit", noun: yr(e) };
}
function Yc(e) {
  return { type: "simple-category", subtype: "scale", noun: yr(e) };
}
function Bh(e, t) {
  return { type: "quantifier", quantifier: yr(e), aux: t ? yr(t) : void 0 };
}
const cC = gi("back"), uC = gi("up"), Pt = {
  // Predicates
  SHOW: Mn("show"),
  PEAK: Mn("peak"),
  BOTTOM_OUT: Mn("bottom", "out"),
  COMPARE: Mn("compare"),
  COPULA: Mn("be"),
  START: Mn("start"),
  END: Mn("end"),
  HAS: Mn("have"),
  REBOUND: Mn("rebound"),
  FALL_pred: Mn("fall"),
  RISE_pred: Mn("rise"),
  CLUSTER: Mn("cluster"),
  TRACK: Mn("track"),
  INTERSECT: Mn("intersect"),
  //TODO: combine with INTERSECTION
  // Categories
  LINE: kr("line"),
  CHART: kr("chart"),
  PRICE: kr("price"),
  PERIOD: kr("period"),
  RATE: kr("rate"),
  INFLATION: kr("inflation"),
  INTERSECTION: kr("intersection"),
  NUMBER: Yc("number"),
  TREND: kr("trend"),
  JUMP: kr("jump"),
  DISTRIBUTION: kr("distribution"),
  OUTLIER: kr("outlier"),
  RECORD: kr("record"),
  XAXIS: kr("x-axis"),
  YAXIS: kr("y-axis"),
  PERCENT: Yc("percent"),
  PERCENTAGE: kr("percentage"),
  BAR: kr("bar"),
  SLICE: kr("slice"),
  PIE: kr("pie"),
  GROUP: kr("group"),
  TIME: kr("time"),
  THOUSAND: Yc("thousand"),
  MILLION: Yc("million"),
  BILLION: Yc("billion"),
  TRILLION: Yc("trillion"),
  OVERALL: Dh("overall"),
  LARGE: Dh("large"),
  DIFFERENT: Dh("different"),
  ENTIRE: Dh("entire"),
  STEPPED: Dh("stepped"),
  FOLLOWED: fB("follow"),
  HIGH: Nh({ noun: "high", adj: "high" }),
  LOW: Nh({ noun: "low", adj: "low" }),
  STABLE: Nh({ noun: "stable", adj: "stable" }),
  RISE: Nh({ noun: "rise", participle: "rise" }),
  FALL: Nh({ noun: "fall", participle: "fall" }),
  // Units
  POINT: z1("point"),
  YEAR: z1("year"),
  QUARTER: z1("quarter"),
  // Directions
  OVER: gi("over"),
  IN: gi("in"),
  AT: gi("at"),
  ON: gi("on"),
  BACK: cC,
  UP: uC,
  BACK_UP: { ...cC, aux: uC },
  BY: gi("by"),
  FROM: gi("from"),
  TO: gi("to"),
  BETWEEN: gi("between"),
  EXCEPT: gi("except"),
  ALONG: gi("along"),
  // Connectives
  AND: Mh("and"),
  FOLLOWED_BY: Mh("followed by"),
  AND_THEN: Mh("and then"),
  BEFORE: Mh("before"),
  WHILE: Mh("while"),
  // Manners & Modes
  TOGETHER: { type: "manner", manner: yr("together") },
  TEMPORARILY: { type: "manner", manner: yr("temporarily") },
  AGAIN: { type: "manner", manner: yr("again") },
  WORLDWIDE: { type: "manner", manner: yr("worldwide") },
  POSSIBLY: { type: "mode", mode: yr("possibly") },
  // Quantifiers
  ALL: Bh("all"),
  AROUND: { ...Bh("around"), adverb: !0 },
  ALMOST: { ...Bh("almost"), adverb: !0 },
  MORE_THAN: Bh("more", "than"),
  EACH: Bh("each"),
  // Pronouns
  EACH_OTHER: { type: "pronoun-entity", determiner: yr("each"), number: "plural", pronoun: yr("other") }
};
ub(Pt);
const V1 = {
  DOLLAR: $1("dollar", "$", "prefix"),
  US_DOLLAR: $1("U.S. dollar", "$", "prefix"),
  SK_WON: $1("South Korean won", "", "prefix")
};
ub(V1);
const dl = {
  "0.01": Pt.PERCENT,
  1: Pt.NUMBER,
  1e3: Pt.THOUSAND,
  1e6: Pt.MILLION,
  1e9: Pt.BILLION,
  1e12: Pt.TRILLION
};
ub(dl);
const di = class fi {
  static participle(t) {
    return { type: "simple-category", participle: yr(t) };
  }
  // * Entities *
  // Helpers for Entities Helpers
  static _num(t) {
    let r;
    return t === "s" ? r = "singular" : t === "p" ? r = "plural" : r = t, r;
  }
  static _entityHelperBuilder(t, r, n, i) {
    return {
      type: "simple-entity",
      detType: t,
      number: fi._num(r),
      category: n,
      mods: i
    };
  }
  // Simple Entities
  static the(t, r, n) {
    return fi._entityHelperBuilder("definite", t, r, n ?? []);
  }
  static a(t, r, n) {
    return fi._entityHelperBuilder("indefinite", t, r, n ?? []);
  }
  static this_(t, r, n) {
    return fi._entityHelperBuilder("proximal", t, r, n ?? []);
  }
  static that(t, r, n) {
    return fi._entityHelperBuilder("distal", t, r, n ?? []);
  }
  static proper(t, r) {
    return fi._entityHelperBuilder("proper", "singular", t, r ?? []);
  }
  // Number Entities
  static numberEntity(t, r, n) {
    return {
      type: "number-entity",
      number: t,
      scale: r,
      mods: n
    };
  }
  // Money Values
  static moneyValue(t, r, n, i) {
    return {
      type: "simple-entity",
      subtype: "money-value",
      detType: "bare",
      number: t,
      scale: r,
      category: n,
      mods: i
    };
  }
  // Quantity Values
  static quantValue(t, r, n, i) {
    return {
      type: "simple-entity",
      subtype: "quant-value",
      detType: "indefinite",
      number: t,
      scale: r,
      category: n,
      mods: i
    };
  }
  // Plain Date Points
  static year(t) {
    const r = t.toString().padStart(4, "0");
    return {
      type: "plain-date-time",
      datetime: ty.PlainDateTime.from(`${r}0101`),
      unit: "year"
    };
  }
  static quarter(t, r) {
    const n = t.toString().padStart(4, "0");
    if (![1, 2, 3, 4].includes(r))
      throw new Error(`[Grammatize-Information]: quarter number must be 1, 2, 3, or 4, not ${r}`);
    const i = ((r - 1) * 3 + 1).toString().padStart(2, "0");
    return {
      type: "plain-date-time",
      datetime: ty.PlainDateTime.from(`${n}${i}01`),
      unit: "quarter"
    };
  }
  // * Modifiers *
  // Misc Modifiers
  static of(t) {
    return { type: "possession", possessor: t };
  }
  static for_(t) {
    return { type: "purpose", subtype: "for", purpose: t };
  }
  static with(t) {
    return { type: "purpose", subtype: "with", purpose: t };
  }
  static as(t) {
    return { type: "purpose", subtype: "as", purpose: t };
  }
  static ordinal(t) {
    return { type: "ordinal", ordinal: t };
  }
  static _pointLocationHelperBuilder(t, r) {
    return { type: "point-location", direction: t, point: r };
  }
  static over(t) {
    return fi._pointLocationHelperBuilder(Pt.OVER, t);
  }
  static on(t) {
    return fi._pointLocationHelperBuilder(Pt.ON, t);
  }
  static at(t) {
    return fi._pointLocationHelperBuilder(Pt.AT, t);
  }
  static in_(t) {
    return fi._pointLocationHelperBuilder(Pt.IN, t);
  }
  static by(t) {
    return fi._pointLocationHelperBuilder(Pt.BY, t);
  }
  static path(t, r) {
    return { type: "path-location", start: t, end: r };
  }
  // * Statements *
  static svo(t, r, n, ...i) {
    return {
      type: "simple-statement",
      subject: t,
      clause: {
        type: "simple-clause",
        pred: r,
        object: n
      },
      mods: i
    };
  }
  // Coordinated Phrases
  static coord(t, ...r) {
    return { type: "coordinated-phrase", conn: t, coords: r };
  }
  static and(...t) {
    return fi.coord(Pt.AND, ...t);
  }
  // * Tags *
  static tag(t, r, n) {
    return t.tag = { name: r, attributes: n }, t;
  }
};
hi(di, "en", yr), // * Categories *
// Simple Categories
hi(di, "category", Nh), hi(di, "noun", kr), hi(di, "adj", Dh), hi(di, "pastParticiple", fB), // Units
hi(di, "unit", z1), // Scales
hi(di, "scale", Yc), // Currencies
hi(di, "currency", $1), hi(di, "quantifier", Bh), // Locations
hi(di, "dir", gi), // * Predicates *
hi(di, "pred", Mn), // * Coordination *
// Connectives
hi(di, "conn", Mh);
let yt = di;
var me;
((e) => {
  function t(D) {
    return n(D) || u(D) || at(D) || m(D) || c(D) || pt(D) || _t(D) || lt(D) || jt(D) || L(D, t);
  }
  e.isComponent = t;
  function r(D) {
    return typeof D == "object" && !!D && "type" in D && t(D);
  }
  e.isComponentGuard = r;
  function n(D) {
    return i(D) || s(D) || o(D) || a(D) || l(D) || L(D, n);
  }
  e.isCategory = n;
  function i(D) {
    return D.type === "simple-category";
  }
  e.isSimpleCategory = i;
  function s(D) {
    return i(D) && "noun" in D && D.subtype === "unit";
  }
  e.isUnit = s;
  function o(D) {
    return i(D) && "noun" in D && D.subtype === "currency";
  }
  e.isCurrency = o;
  function a(D) {
    return i(D) && "noun" in D && D.subtype === "scale";
  }
  e.isScale = a;
  function l(D) {
    return D.type === "ordinal";
  }
  e.isOrdinal = l;
  function c(D) {
    return D.type === "quantifier";
  }
  e.isQuantifier = c;
  function h(D) {
    return typeof D == "number" ? D === 1 ? "s" : "p" : D === "singular" ? "s" : D === "plural" ? "p" : D;
  }
  e.normalizeNumber = h;
  function u(D) {
    return y(D) || g(D) || b(D) || x(D) || A(D) || L(D, u);
  }
  e.DET = {
    proper: { en: null },
    definite: { en: "the" },
    indefinite: { en: "a" },
    proximal: { en: "this" },
    distal: { en: "that" },
    bare: { en: null }
  };
  function p(D) {
    if (y(D) || g(D) || A(D))
      return h(D.number);
    if (x(D))
      return "s";
    if (L(D, u))
      return "p";
  }
  e.entityNumber = p;
  function y(D) {
    return D.type === "simple-entity";
  }
  e.isSimpleEntity = y;
  function g(D) {
    return D.type === "pronoun-entity";
  }
  e.isPronounEntity = g;
  function b(D) {
    return E(D) || f(D);
  }
  function f(D) {
    return y(D) && D.subtype === "quant-value";
  }
  e.isQuantValue = f;
  function E(D) {
    return y(D) && D.subtype === "money-value";
  }
  e.isMoneyValue = E;
  function A(D) {
    return D.type === "number-entity";
  }
  e.isNumberEntity = A;
  function x(D) {
    return D.type === "plain-date-time";
  }
  e.isPlainDateTime = x;
  function m(D) {
    return n(D) || _(D) || S(D) || R(D) || z(D) || O(D) || jt(D) || L(D, m);
  }
  function w(D) {
    if (n(D))
      return "prepend";
    if (_(D) || S(D) || R(D) || z(D))
      return "postpend";
    if (O(D))
      return D.prepend ? "prepend" : "postpend";
    if ($(D))
      return "prepend";
    if (jt(D))
      return "postpend";
    if (L(D, m))
      return w(D.coords[0]);
  }
  e.modPosition = w;
  function _(D) {
    return D.type === "possession";
  }
  e.isPossession = _, e.POSS_AUX = {
    en: "of"
  }, e.REL = {
    zero: { en: null },
    which: { en: "which" },
    that: { en: "that" },
    while: { en: "while" }
  };
  function S(D) {
    return D.type === "relative-clause";
  }
  e.isRelative = S;
  function R(D) {
    return D.type === "purpose";
  }
  e.isPurpose = R, e.PURPOSE_AUX = {
    for: yt.en("for"),
    as: yt.en("as"),
    with: yt.en("with")
  };
  function O(D) {
    return D.type === "manner";
  }
  e.isManner = O;
  function $(D) {
    return D.type === "mode";
  }
  e.isMode = $;
  function z(D) {
    return F(D) || Y(D) || rt(D);
  }
  e.isLocation = z;
  function F(D) {
    return D.type === "direction";
  }
  e.isDirection = F;
  function Y(D) {
    return D.type === "point-location";
  }
  e.isPointLocation = Y;
  function rt(D) {
    return D.type === "path-location";
  }
  e.isPathLocation = rt;
  function at(D) {
    return D.type === "predicate";
  }
  e.isPredicate = at;
  function pt(D) {
    return vt(D) || L(D, pt);
  }
  function vt(D) {
    return D.type === "simple-clause";
  }
  e.isSimpleClause = vt;
  function _t(D) {
    return Ct(D) || It(D) || L(D, Ct);
  }
  e.isStatement = _t;
  function Ct(D) {
    return D.type === "simple-statement";
  }
  e.isSimpleStatement = Ct;
  function It(D) {
    return D.type === "label";
  }
  e.isLabel = It;
  function jt(D) {
    return D.type === "quote";
  }
  e.isQuote = jt;
  function lt(D) {
    return D.type === "connective";
  }
  e.isConnective = lt;
  function L(D, tt) {
    return D.type === "coordinated-phrase" && tt(D.coords[0]);
  }
  e.isCoordinated = L;
})(me || (me = {}));
const Gft = [
  { cat: { noun: "Canada", adj: "Canadian" } },
  { cat: { noun: "nation", adj: "national" } },
  { cat: { noun: "Indonesia", adj: "Indonesian" } },
  { cat: { noun: "region", adj: "regional" } },
  { cat: { noun: "U.S.", adj: "U.S." }, quasiname: !0, synonyms: ["US", "United States"] },
  { cat: { noun: "Vietnam", adj: "Vietnamese" } },
  { cat: { noun: "world", adj: "global" }, quasiname: !0 }
];
function Qft(e) {
  const t = {};
  for (const r of e) {
    const n = yt.category(r.cat, r.quasiname);
    t[r.cat.noun] = n, t[r.cat.adj] = n;
    for (const i of r.synonyms ?? [])
      t[i] = n;
  }
  return t;
}
Qft(Gft);
const Fr = new zut(), hC = Fr.N, Wft = Fr.A, qft = Fr.Pro, i1 = Fr.D, Nw = Fr.V, Eh = Fr.Adv, Ah = Fr.P, Yft = Fr.C, Hc = Fr.Q, Dw = Fr.S, Kft = Fr.SP, Zft = Fr.CP, Bw = Fr.VP, fs = Fr.NP, Jft = Fr.AP, Sh = Fr.PP, pC = Fr.AdvP, dC = Fr.DT, Ha = Fr.NO;
function Xft(e, t) {
  const r = [], n = [];
  for (const i of e)
    t(i) ? r.push(i) : n.push(i);
  return [r, n];
}
function ry(e) {
  if (Array.isArray(e))
    return e.map((t) => ry(t));
  if (e instanceof ty.PlainDateTime || Object.prototype.toString.call(e) === "[object Temporal.PlainDateTime]")
    return ty.PlainDateTime.from(e);
  if (typeof e == "object") {
    const t = {};
    for (const r in e)
      t[r] = ry(e[r]);
    return t;
  }
  return e;
}
function g4(e) {
  const t = ry(e);
  for (const r in e)
    ["tag", "detTag", "auxTag", "startTag", "endTag"].includes(r) ? delete t[r] : me.isComponentGuard(e[r]) && (t[r] = g4(e[r]));
  return t;
}
function Zd(e, t) {
  const r = g4(e), n = g4(t);
  return JSON.stringify(r) === JSON.stringify(n);
}
function t0t(e, t) {
  return e.some((r) => Zd(r, t));
}
async function e0t() {
  await Fr.init();
}
class r0t {
  // Dispatch
  grammatizeMultiple(t, r) {
    return t.map((n) => this.grammatize(n, r));
  }
  grammatize(t, r, n) {
    let i = this.grammatizeDispatch(t, r, n);
    return "tag" in t && i.tag(t.tag.name, t.tag.attributes), i;
  }
  grammatizeDispatch(t, r, n) {
    if (me.isCategory(t))
      return this.grammatizeCategory(t, r, n);
    if (me.isQuantValue(t))
      return this.grammatizeQuantValue(t, r);
    if (me.isMoneyValue(t))
      return this.grammatizeMoneyValue(t, r);
    if (me.isSimpleEntity(t))
      return this.grammatizeSimpleEntity(t, r);
    if (me.isPronounEntity(t))
      return this.grammatizePronounEntity(t, r);
    if (me.isNumberEntity(t))
      return this.grammatizeNumberEntity(t, r);
    if (me.isPlainDateTime(t))
      return this.grammatizePlainDateTime(t, r);
    if (me.isPossession(t))
      return this.grammatizePoss(t, r);
    if (me.isRelative(t))
      return this.grammatizeRelative(t, r);
    if (me.isPurpose(t))
      return this.grammatizePurpose(t, r);
    if (me.isManner(t))
      return this.grammatizeManner(t, r);
    if (me.isMode(t))
      return this.grammatizeMode(t, r);
    if (me.isDirection(t))
      return this.grammatizeDir(t, r);
    if (me.isPointLocation(t))
      return this.grammatizeLoc(t, r);
    if (me.isPathLocation(t))
      return this.grammatizePath(t, r);
    if (me.isPredicate(t))
      return this.grammatizePredicate(t, r, n);
    if (me.isSimpleClause(t))
      return this.grammatizeSimpleClause(t, r, n);
    if (me.isSimpleStatement(t))
      return this.grammatizeSimpleStatement(t, r);
    if (me.isQuantifier(t))
      return this.grammatizeQuantifier(t, r);
    if (me.isLabel(t))
      return this.grammatizeLabel(t, r);
    if (me.isQuote(t))
      return this.grammatizeQuote(t, r);
    if (me.isConnective(t))
      return this.grammatizeConnective(t, r);
    if (me.isCoordinated(t, me.isComponent))
      return this.grammatizeCoord(t, r);
  }
  // Helpers
  _grammatizeAdj(t, r) {
    console.assert("adj" in t);
    const n = t.adj[r], i = Wft(n, !0);
    return (t.comparative === "comparative" || t.comparative === "superlative") && i.f(t.comparative === "comparative" ? "co" : "su"), i;
  }
  // Categories
  grammatizeCategory(t, r, n = "s") {
    return me.isSimpleCategory(t) ? this.grammatizeSimpleCategory(t, r, n) : me.isOrdinal(t) ? this.grammatizeOrdinal(t, r) : me.isUnit(t) ? this.grammatizeUnit(t, r) : me.isCurrency(t) ? this.grammatizeCurrencySymbol(t, r) : me.isScale(t) ? this.grammatizeScale(t, r) : me.isCoordinated(t, me.isCategory) ? this.grammatizeCoord(t, r, n) : t;
  }
  grammatizeSimpleCategory(t, r, n) {
    console.assert("adj" in t || "noun" in t || "participle" in t || "pastParticiple" in t);
    let i;
    "force" in t && t.force !== void 0 ? (console.assert(t.force in t), i = t.force) : "adj" in t && "comparative" in t ? i = "adj" : "noun" in t ? i = "noun" : "adj" in t ? i = "adj" : "participle" in t ? i = "participle" : i = "pastParticiple";
    let s;
    return i === "noun" ? s = fs(hC(t.noun[r], n, !0)) : i === "participle" ? s = Bw(Nw(t.participle[r], "present-participle")) : i === "pastParticiple" ? s = Bw(Nw(t.pastParticiple[r], "past-participle")) : s = Jft(this._grammatizeAdj(t, r)), this.grammatizeMods(s, r, t.mods), s;
  }
  // This should return a (Number)Adjective. See https://github.com/fizzstudio/theseusaurus/issues/54
  grammatizeOrdinal(t, r) {
    return Ha(t.ordinal).dOpt({ ord: !0 });
  }
  grammatizeUnit(t, r) {
    const n = {
      ...t,
      noun: t.noun
    };
    return this.grammatizeCategory(n, r);
  }
  grammatizeCurrencySymbol(t, r) {
    return Hc(t.symbol);
  }
  grammatizeScale(t, r) {
    const n = {
      ...t,
      noun: t.noun
    };
    return this.grammatizeCategory(n, r);
  }
  // Entities
  grammatizeSimpleEntity(t, r) {
    if (t.detType === "proper" && t.number !== "singular")
      throw new Error("Proper nouns can only be singular");
    const n = t.quantifier ? this.grammatize(t.quantifier, r) : null, i = t.number === "singular" || t.number === 1 ? "s" : "p";
    let s;
    t.number === "plural" && t.detType === "indefinite" || t.detType === "proper" || t.detType === "bare" || typeof t.number == "number" && t.detType === "indefinite" ? s = null : (console.assert(me.DET[t.detType][r] !== null, "nullish determiner"), s = i1(me.DET[t.detType][r]), t.detTag && s.tag(t.detTag.name, t.detTag.attributes));
    const o = t.number === "singular" || t.number === "plural" ? null : Ha(t.number), a = this.grammatize(t.category, r, i), l = t.scale && !Zd(t.scale, dl[1]) ? this.grammatize(t.scale, r) : null;
    return this.grammatizeEntityMods(n, s, o, a, l, r, t.mods);
  }
  grammatizePronounEntity(t, r) {
    const n = qft(t.pronoun[r]);
    return t.determiner ? fs(i1(t.determiner[r]), n) : fs(n);
  }
  grammatizeQuantValue(t, r) {
    const n = {
      ...t,
      type: "simple-entity",
      detType: "indefinite"
    };
    return this.grammatizeSimpleEntity(n, r);
  }
  grammatizeNumberEntity(t, r) {
    const n = t.quantifier ? this.grammatize(t.quantifier, r) : null;
    let i;
    return Zd(t.scale, dl[1]) ? i = fs(n, Ha(t.number)) : Zd(t.scale, dl[0.01]) ? i = fs(n, Ha(t.number).after(Hc("%"))) : i = fs(n, Ha(t.number), this.grammatize(t.scale, r)), this.grammatizeMods(i, r, t.mods), i;
  }
  grammatizeMoneyValue(t, r) {
    const n = t.category.pos === "prefix" ? Ha(t.number).before(this.grammatizeCurrencySymbol(t.category, r)) : Ha(t.number).after(this.grammatizeCurrencySymbol(t.category, r));
    let i;
    return "scale" in t && t.scale !== void 0 && !Zd(t.scale, dl[1]) ? i = fs(n, this.grammatize(t.scale, r)) : i = fs(n), this.grammatizeMods(i, r, t.mods), i;
  }
  grammatizePlainDateTime(t, r) {
    if (t.unit === "year")
      return dC(`${t.datetime.year}`);
    if (t.unit === "quarter") {
      const n = (t.datetime.month - 1) / 3 + 1;
      if (![1, 2, 3, 4].includes(n))
        throw new Error(`[Grammatize-Information]: PlainDateTime ${t.datetime} does not represent a quarter.`);
      return fs(i1("the"), Ha(n).dOpt({ ord: !0 }), hC("quarter"), Sh(Ah("of"), dC(`${t.datetime.year}`)));
    }
    t.unit;
  }
  grammatizeMods(t, r, n) {
    const i = n ?? [], s = i.filter((a) => me.modPosition(a) === "prepend"), o = i.filter((a) => me.modPosition(a) === "postpend");
    for (const a of s.reverse())
      t.add(this.grammatize(a, r), 0);
    for (const a of o)
      t.add(this.grammatize(a, r));
  }
  grammatizeEntityMods(t, r, n, i, s, o, a) {
    const [l, c] = Xft(
      a ?? [],
      (u) => me.modPosition(u) === "prepend"
    );
    this.grammatizeMods(i, o, l);
    const h = fs(t, r, n, s, i);
    return this.grammatizeMods(h, o, c), h;
  }
  grammatizePoss(t, r) {
    const n = Ah(me.POSS_AUX[r]);
    return "auxTag" in t && n.tag(t.auxTag.name, t.auxTag.attributes), Sh(n, this.grammatize(t.possessor, r));
  }
  grammatizeRelative(t, r) {
    const n = me.REL[t.relativizer][r], i = n ? Eh(n) : null;
    "auxTag" in t && i && i.tag(t.auxTag.name, t.auxTag.attributes);
    const s = Kft(t.restrictive, i, this.grammatize(t.clause, r));
    return t.restrictive || s.before(Hc(",")), s;
  }
  grammatizePurpose(t, r) {
    const n = Ah(me.PURPOSE_AUX[t.subtype][r]);
    return "auxTag" in t && n.tag(t.auxTag.name, t.auxTag.attributes), Sh(n, this.grammatize(t.purpose, r));
  }
  grammatizeManner(t, r) {
    const n = Eh(t.manner[r]);
    return t.aux ? pC(n, Ah(t.aux[r])) : n;
  }
  grammatizeQuantifier(t, r) {
    const n = t.quantifier[r], i = t.adverb ? Eh(n) : i1(n);
    return t.aux ? pC(i, Ah(t.aux[r])) : i;
  }
  grammatizeMode(t, r) {
    return Eh(t.mode[r]);
  }
  grammatizeDir(t, r) {
    const n = t.aux ? this.grammatize(t.aux, r) : null;
    return Sh(Ah(t.direction[r]), n);
  }
  grammatizeLoc(t, r) {
    return Sh(this.grammatize(t.direction, r), this.grammatize(t.point, r));
  }
  grammatizePath(t, r) {
    const n = this.grammatize(Pt.FROM, r);
    t.startTag && n.tag(t.startTag.name, t.startTag.attributes);
    const i = this.grammatize(Pt.TO, r);
    return t.endTag && i.tag(t.endTag.name, t.endTag.attributes), Sh(
      n,
      this.grammatize(t.start, r),
      i,
      this.grammatize(t.end, r)
    );
  }
  grammatizePredicate(t, r, n = "s") {
    return t.forceNumber && (n = me.normalizeNumber(t.forceNumber)), Nw(t.pred[r], t.tense, n);
  }
  grammatizeSimpleClause(t, r, n = "s") {
    var i;
    const s = t.pred ? this.grammatize(t.pred, r, n) : void 0, o = (i = t.pred) != null && i.aux ? Eh(t.pred.aux[r]) : void 0, a = t.object ? this.grammatize(t.object, r) : void 0, l = Bw(s, o, a);
    return this.grammatizeMods(l, r, t.mods), l;
  }
  grammatizeSimpleStatement(t, r) {
    const n = t.subject ? this.grammatize(t.subject, r) : Eh("there"), i = t.subject ? me.entityNumber(t.subject) : "p", s = Dw(n, this.grammatize(t.clause, r, i));
    return this.grammatizeMods(s, r, t.mods), s;
  }
  grammatizeLabel(t, r) {
    return Dw(Hc(t.text).a(":"));
  }
  grammatizeQuote(t, r) {
    return Hc(t.text);
  }
  grammatizeConnective(t, r) {
    const n = t.real[r];
    return n.includes(" ") ? Hc(n) : Yft(n);
  }
  /*if (this.abbrevs.includes('DROP-COMMON-SUBJ') &&
    this.lhs instanceof SimpleStatement &&
    this.rhs instanceof SimpleStatement &&
    this.lhs.subjectEquals(this.rhs) &&
    this.rhs.clause.object !== null
  ) {
    return S(this.lhs.grammatize(lang), this.conn.grammatize(lang), this.rhs.grammatizeVP(lang));
  }*/
  grammatizeCoord(t, r, n) {
    const i = t.coords.map((a) => this.grammatize(a, r, n)), s = this.grammatize(t.conn, r);
    t.firstComma && i.length === 2 && i[0].after(Hc(","));
    const o = Zft(s, ...i).oxfordify();
    return me.isSimpleStatement(t.coords[0]) ? Dw(o) : me.isCategory(t.coords[0]) ? fs(o) : o;
  }
}
class n0t extends r0t {
  constructor() {
    super(...arguments), hi(this, "mentioned", []);
  }
  words(t) {
    return t.trim().split(" ");
  }
  allSame(t) {
    const r = t[0];
    return r === void 0 ? !1 : t.every((n) => n === r);
  }
  getMiddle(t) {
    return this.words(t).slice(1, -1).join(" ");
  }
  grammatizeSimpleEntity(t, r) {
    if (t0t(this.mentioned, t)) {
      if (!t.mods || t.mods.length === 0)
        return super.grammatizeSimpleEntity(t, r);
      const n = ry(t);
      return n.mods = n.mods.filter(
        (i) => !me.isPossession(i) && !(me.isSimpleCategory(i) && i.inessential) && !(me.isLocation(i) && i.inessential)
      ), super.grammatizeSimpleEntity(n, r);
    }
    return this.mentioned.push(t), super.grammatizeSimpleEntity(t, r);
  }
  grammatizeCoord(t, r, n) {
    if (me.isSimpleEntity(t.coords[0])) {
      const i = t.coords;
      if (i.some((l) => !me.isSimpleCategory(l.category)))
        return super.grammatizeCoord(t, r, n);
      const s = i.map((l) => l.category.noun[r]), o = s.map((l) => this.words(l).at(0)), a = s.map((l) => this.words(l).at(-1));
      if (this.allSame(o) && this.allSame(a) && o[0] !== a[0]) {
        const l = o[0], c = a[0], h = s.map((y) => this.getMiddle(y)).map((y) => yt.noun(y)), u = yt.and(...h), p = {
          type: "simple-entity",
          detType: "indefinite",
          //FIXME: is this always the wanted determiner?
          number: "plural",
          category: yt.noun(c),
          mods: [yt.adj(l), u]
        };
        return this.grammatize(p, r, n);
      }
    }
    return super.grammatizeCoord(t, r, n);
  }
  grammatizeMultiple(t, r) {
    const n = t.map((i) => this.grammatize(i, r));
    return this.mentioned = [], n;
  }
}
class i0t extends Error {
}
class Kc extends Error {
  constructor(t) {
    super(`[ParaSummary]: Problem processesing summary request.
` + t);
  }
}
const gB = Symbol.for("filter-series"), mB = Symbol.for("filter-datapoint"), s0t = Symbol.for("filter-series-datapoint"), yB = Symbol.for("filter-series-intersection"), fC = {
  [gB]: { name: "series", pattern: /^\?\(@.key === '(.+)'\)$/ },
  [mB]: { name: "datapoint", pattern: /^\?\(@.label === '(.+)' && @.value === '(.+)'\)$/ },
  [s0t]: { name: "series-datapoint", pattern: /^\?\(@.label === '(.+)'\)$/ },
  [yB]: { name: "series-intersection", pattern: /^\?\(@.series.includes\('(.+)'\)\)$/ }
};
function o0t(e, t) {
  const r = t.pattern.exec(e);
  if (r === null)
    throw new Kc(
      `Filter expression '${e}' in request did not match pattern for ${t.name}`
    );
  return r.slice(1);
}
const ny = Symbol.for("number"), nu = Symbol.for("end-of-request"), a0t = {
  "*": "allSeries",
  [gB]: {
    trend: "seriesTrend",
    stats: {
      max: "seriesMax",
      min: "seriesMin",
      extremes: "seriesExtremes"
    },
    datapoints: {
      [ny]: "seriesDatapoint"
    },
    record_count: "seriesRecordCount",
    ranking: "seriesRanking",
    [nu]: "specificSeries"
  }
}, l0t = {
  $: {
    datasets: {
      0: {
        series: a0t,
        datapoints: {
          [mB]: "datapoint"
        },
        axes: {
          dependent: {
            [nu]: "dependentAxis",
            __label: "dependentAxisLabel"
          },
          independent: {
            [nu]: "independentAxis"
          }
        },
        intersections: {
          "*": "allIntersection",
          [ny]: "intersection",
          [yB]: {
            [nu]: "seriesIntersections"
          }
        },
        clusters: {
          "*": "allCluster"
        },
        trackingGroups: {
          "*": "allTrackingGroup"
        },
        theme: "chartTheme",
        labels: "chartLabels",
        stats: {
          max: "chartMax",
          min: "chartMin",
          extremes: "chartExtremes"
        },
        trend: "onlySeriesTrend",
        highestRanking: "highestRanking",
        [nu]: "chart"
      }
    }
  }
};
class c0t {
  constructor(t, r) {
    Be(this, "cursor", 0), Be(this, "tree", l0t), Be(this, "args", []), this.request = t, this.parsedRequest = r;
  }
  get remainingRequest() {
    return this.parsedRequest.slice(this.cursor);
  }
  dispatch() {
    for (; ; ) {
      const t = this.processSegment();
      if (typeof t == "string")
        return [t, this.args];
      this.tree = t, this.cursor++;
    }
  }
  processSegment() {
    if (this.remainingRequest.length === 0)
      return this.endOfRequest();
    const t = this.remainingRequest[0].expression;
    if (t.type === "root")
      return this.root();
    if (t.type === "wildcard")
      return this.wildcard();
    if (t.type === "identifier") {
      const r = this.trySpecificIdentifier(t.value);
      if (r !== null)
        return r;
      throw new iy(`identifier: ${t.value}`);
    }
    if (t.type === "numeric_literal") {
      const r = t.value, n = this.trySpecificNumber(r);
      return n !== null ? n : this.anyNumber(r);
    }
    if (t.type === "filter_expression")
      return this.filter();
    throw new iy("other segment");
  }
  endOfRequest() {
    if (nu in this.tree)
      return this.tree[nu];
    throw new Kc("Request ended too early. Expected one of: " + Object.keys(this.tree));
  }
  root() {
    if ("$" in this.tree)
      return this.tree.$;
    throw new Kc(`The root segment "$" is not allowed at segment ${this.cursor}`);
  }
  wildcard() {
    if ("*" in this.tree)
      return this.tree["*"];
    throw new Kc(`The wildcard segment "*" is not allowed at segment ${this.cursor}`);
  }
  trySpecificIdentifier(t) {
    return t in this.tree ? this.tree[t] : null;
  }
  trySpecificNumber(t) {
    return t in this.tree ? this.tree[t] : null;
  }
  anyNumber(t) {
    if (ny in this.tree)
      return this.args.push(String(t)), this.tree[ny];
    throw new Kc(`The numeric index "${t}" is not allowed at segment ${this.cursor}`);
  }
  filter() {
    const t = this.remainingRequest[0].expression.value, r = Object.getOwnPropertySymbols(fC).filter(
      (s) => s in this.tree
    );
    if (r.length === 0)
      throw new Kc(`The filter expression "${t}" is not allowed at segment ${this.cursor}`);
    if (r.length > 1)
      throw new Kc(`Unreachable: multiple filter expression should not exist in a tree (segment ${this.cursor})`);
    const n = r[0], i = o0t(t, fC[n]);
    return this.args.push(...i), this.tree[n];
  }
}
function n0(e) {
  return {
    name: "span",
    attributes: {
      "data-navcode": e
    }
  };
}
function Ge(e, t) {
  return yt.tag({ ...e }, "span", { "data-navcode": t });
}
const bB = new DOMParser();
function u0t(e, t) {
  const r = e.querySelector("parsererror");
  if (r)
    throw new Error(`[ParaSummary Internal]: Error in highlight parsing. 
 Error: ${r.textContent} 
 Text: ${t}`);
}
function h0t(e, t) {
  let r = bB.parseFromString(`<p>${e}</p>`, "text/xml");
  if (u0t(r, e), r.documentElement.childNodes.length < 2)
    return e;
  let n = null, i = null, s = "";
  for (const o of r.documentElement.childNodes)
    if (n === null)
      n = o, i = n.getAttribute("data-navcode");
    else {
      const a = o.getAttribute("data-navcode");
      if (i !== null && a !== null && i === a || o.textContent === " " || o.textContent === ", " || o.textContent === ". " || o.textContent === ".  ") {
        n.textContent = n.textContent + o.textContent;
        const l = o.getAttribute("data-phrasecode"), c = t.findIndex((p) => p.phrasecode === l), h = n.getAttribute("data-phrasecode"), u = t.find((p) => p.phrasecode === h);
        u.end = t[c].end, t.splice(c, 1);
      } else
        s += n.outerHTML, n = o, i = n.getAttribute("data-navcode");
    }
  return s += n.outerHTML, s;
}
function m4(e) {
  let t = bB.parseFromString(`<p>${e}</p>`, "text/xml");
  const r = t.querySelector("parsererror");
  if (r)
    throw new Error(`[ParaSummary Internal]: Error in highlight parsing. 
 Error: ${r.textContent} 
 Text: ${e}`);
  let n = "", i = "";
  const s = [];
  let o = 0;
  for (const a of t.documentElement.childNodes) {
    const l = n.length;
    n += a.textContent;
    const c = n.length, h = o;
    if (o++, a.nodeName === "#text")
      i += `<span data-phrasecode="${h}">${a.textContent}</span>`, s.push({ start: l, end: c, phrasecode: `${h}` });
    else {
      const u = a.getAttribute("data-navcode");
      a.setAttribute("data-phrasecode", `${h}`), i += a.outerHTML, s.push({ start: l, end: c, phrasecode: `${h}`, navcode: u });
    }
  }
  return i = h0t(i, s), { text: n, html: i, highlights: s };
}
var p0t = Object.defineProperty, d0t = Object.getOwnPropertyDescriptor, vB = (e, t, r, n) => {
  for (var i = d0t(t, r), s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(t, r, i) || i);
  return i && p0t(t, r, i), i;
};
class iy extends Error {
  constructor(t) {
    super(`Not implemented yet: ${t}`);
  }
}
let $r = class extends Error {
  constructor(t) {
    super("[ParaSummary]: " + t);
  }
};
function Kr(e) {
  return console.warn(`[ParaSummary]: ${e}`), [];
}
function jw(e) {
  return console.warn(`[ParaSummary]: ${e}`), { text: "", html: "" };
}
const Gc = {
  seriesChartMin: "Series low and chart low",
  seriesMin: "Series low",
  seriesChartMax: "Series high and chart high",
  seriesMax: "Series high",
  firstDatapoint: "First datapoint in ${seriesLabel:string}",
  lastDatapoint: "Last datapoint in ${seriesLabel:string}",
  intersection: "Intersection between ${intersectLabels:string[]} at this point"
};
async function f0t() {
  await e0t();
}
class hb {
  constructor(t) {
    Be(this, "grammatizator", new n0t()), this._model = t;
  }
  /**
   * Determines whether an y-value is the highest/lowest value on a series/the chart. Note: a chart
   * max/min must also be a series max/min
   * @param value The y-value
   * @param seriesKey The series being considered
   * @returns Whether the  y-value is the highest/lowest value on a series/the chart
   */
  getDatapointMinMax(t, r) {
    const n = [], i = this._model.atKey(r).getFacetStats("y").min.value, s = this._model.getFacetStats("y").min.value, o = this._model.atKey(r).getFacetStats("y").max.value, a = this._model.getFacetStats("y").max.value;
    return t === s ? n.push(Gc.seriesChartMin) : t === i && n.push(Gc.seriesMin), t === a ? n.push(Gc.seriesChartMax) : t === o && n.push(Gc.seriesMax), n;
  }
  intersectionKeys(t) {
    const r = /* @__PURE__ */ new Set();
    if (!this._model.isPlaneModel())
      return r;
    for (const n of this._model.intersections)
      n.record.labelValue !== null && n.record.labelValue === t.facetValueAsNumber("x") && n.value === t.facetValueAsNumber("y") && (r.add(n.series[0]), r.add(n.series[1]));
    return r;
  }
  getDatapointSummary(t, r) {
    const n = [], i = t.seriesKey;
    n.push(Out(t, r));
    const s = t.facetValueAsNumber("y"), o = this.getDatapointMinMax(s, i);
    o.length && n.push(...o);
    const a = this._model.atKey(i).getLabel();
    t.datapointIndex === 0 ? n.push(Dn(Gc.firstDatapoint, { seriesLabel: a })) : t.datapointIndex === this._model.atKey(i).length - 1 && n.push(Dn(Gc.lastDatapoint, { seriesLabel: a }));
    const l = Array.from(this.intersectionKeys(t)).map((c) => this._model.atKey(c).getLabel());
    return l.length > 0 && n.push(Dn(Gc.intersection, { intersectLabels: l })), n.join(". ") + ".";
  }
  getDatapointSummaryAllPoints(t, r) {
    return `${this._model.atKey(t.seriesKey).getLabel()}, ${t.datapointIndex}, all points`;
  }
  parseRequest(t) {
    let r;
    try {
      r = i4.parse(t);
    } catch (n) {
      throw n instanceof Error && (n.message.startsWith("Parse error") || n.message.startsWith("Lexical error")) ? new i0t(`[ParaSummary]: Summary request is not a valid JSONPath
` + n.message) : n;
    }
    return r;
  }
  dispatchRequest(t, r) {
    return new c0t(t, r).dispatch();
  }
  async requestSummary(t) {
    const r = this.parseRequest(t), [n, i] = this.dispatchRequest(t, r), s = this.getSummarizer()[n].call(this.getSummarizer(), ...i);
    return Promise.resolve(s);
  }
  async requestSummaries(t) {
    const r = t.map((n) => this.requestSummary(n));
    return Promise.all(r).then((n) => n.flat());
  }
  grammatizeComponents(t) {
    return this.grammatizator.grammatizeMultiple(t, "en").map((r) => r.toString()).join(" ").trim();
  }
  highlightComponents(t) {
    const r = this.grammatizeComponents(t);
    return m4(r);
  }
  async grammatizeSummaries(t) {
    const r = await this.requestSummaries(t);
    return this.grammatizeComponents(r);
  }
  async highlightSummaries(t) {
    const r = await this.grammatizeSummaries(t);
    return m4(r);
  }
}
vB([
  Up()
], hb.prototype, "getDatapointSummary");
vB([
  Up()
], hb.prototype, "getDatapointSummaryAllPoints");
function g0t(e) {
  if (e.length === 0)
    return 0;
  var t = e[0], r = 0, n;
  if (typeof t != "number")
    return Number.NaN;
  for (var i = 1; i < e.length; i++) {
    if (typeof e[i] != "number")
      return Number.NaN;
    n = t + e[i], Math.abs(t) >= Math.abs(e[i]) ? r += t - n + e[i] : r += e[i] - n + t, t = n;
  }
  return t + r;
}
function m0t(e) {
  if (e.length === 0)
    throw new Error("mean requires at least one data point");
  return g0t(e) / e.length;
}
function y0t(e, t) {
  const r = [];
  for (let n = 0; n < e; n++)
    r.push(t(n));
  return r;
}
function vi(e, t, r, n, i) {
  return ga(t, ((s, o) => {
    const a = s[o];
    if (a === void 0)
      throw new TypeError(lA(o));
    return a;
  })(e, t), r, n, i);
}
function ga(e, t, r, n, i, s) {
  const o = s0(t, r, n);
  if (i && t !== o)
    throw new RangeError(Lj(e, t, r, n, s));
  return o;
}
function li(e) {
  return e !== null && /object|function/.test(typeof e);
}
function ss(e, t = Map) {
  const r = new t();
  return (n, ...i) => {
    if (r.has(n))
      return r.get(n);
    const s = e(n, ...i);
    return r.set(n, s), s;
  };
}
function i0(e) {
  return pp({
    name: e
  }, 1);
}
function pp(e, t) {
  return ma((r) => ({
    value: r,
    configurable: 1,
    writable: !t
  }), e);
}
function b0t(e) {
  return ma((t) => ({
    get: t,
    configurable: 1
  }), e);
}
function g8(e) {
  return {
    [Symbol.toStringTag]: {
      value: e,
      configurable: 1
    }
  };
}
function nd(e, t) {
  const r = {};
  let n = e.length;
  for (const i of t)
    r[e[--n]] = i;
  return r;
}
function ma(e, t, r) {
  const n = {};
  for (const i in t)
    n[i] = e(t[i], i, r);
  return n;
}
function pb(e, t, r) {
  const n = {};
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    n[s] = e(s, i, r);
  }
  return n;
}
function wB(e, t, r) {
  const n = {};
  for (let i = 0; i < e.length; i++)
    n[t[i]] = r[e[i]];
  return n;
}
function Ws(e, t) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const n of e)
    r[n] = t[n];
  return r;
}
function gC(e, t) {
  for (const r of t)
    if (r in e)
      return 1;
  return 0;
}
function xB(e, t, r) {
  for (const n of e)
    if (t[n] !== r[n])
      return 0;
  return 1;
}
function EB(e, t, r) {
  const n = {
    ...r
  };
  for (let i = 0; i < t; i++)
    n[e[i]] = 0;
  return n;
}
function Xe(e, ...t) {
  return (...r) => e(...t, ...r);
}
function mC(e) {
  return e[0].toUpperCase() + e.substring(1);
}
function bg(e) {
  return e.slice().sort();
}
function sy(e, t) {
  return String(t).padStart(e, "0");
}
function _l(e, t) {
  return Math.sign(e - t);
}
function s0(e, t, r) {
  return Math.min(Math.max(e, t), r);
}
function na(e, t) {
  return [Math.floor(e / t), yf(e, t)];
}
function yf(e, t) {
  return (e % t + t) % t;
}
function Vl(e, t) {
  return [db(e, t), m8(e, t)];
}
function db(e, t) {
  return Math.trunc(e / t) || 0;
}
function m8(e, t) {
  return e % t || 0;
}
function s1(e) {
  return Math.abs(e % 1) === 0.5;
}
function AB(e, t, r) {
  let n = 0, i = 0;
  for (let a = 0; a <= t; a++) {
    const l = e[r[a]], c = Co[a], h = Or / c, [u, p] = Vl(l, h);
    n += p * c, i += u;
  }
  const [s, o] = Vl(n, Or);
  return [i + s, o];
}
function fb(e, t, r) {
  const n = {};
  for (let i = t; i >= 0; i--) {
    const s = Co[i];
    n[r[i]] = db(e, s), e = m8(e, s);
  }
  return n;
}
function v0t(e) {
  if (e !== void 0)
    return zn(e);
}
function w0t(e) {
  if (e !== void 0)
    return Wo(e);
}
function SB(e) {
  if (e !== void 0)
    return y8(e);
}
function Wo(e) {
  return CB(y8(e));
}
function y8(e) {
  return kB(R1t(e));
}
function _B(e, t) {
  if (t == null)
    throw new RangeError(lA(e));
  return t;
}
function vg(e) {
  if (!li(e))
    throw new TypeError(e1t);
  return e;
}
function b8(e, t, r = e) {
  if (typeof t !== e)
    throw new TypeError(Ic(r, t));
  return t;
}
function kB(e, t = "number") {
  if (!Number.isInteger(e))
    throw new RangeError(Ygt(t, e));
  return e || 0;
}
function CB(e, t = "number") {
  if (e <= 0)
    throw new RangeError(Kgt(t, e));
  return e;
}
function v8(e) {
  if (typeof e == "symbol")
    throw new TypeError(t1t);
  return String(e);
}
function U1(e, t) {
  return li(e) ? String(e) : zn(e, t);
}
function w8(e) {
  if (typeof e == "string")
    return BigInt(e);
  if (typeof e != "bigint")
    throw new TypeError(Xgt(e));
  return e;
}
function IB(e, t = "number") {
  if (typeof e == "bigint")
    throw new TypeError(Jgt(t));
  if (e = Number(e), !Number.isFinite(e))
    throw new RangeError(Zgt(t, e));
  return e;
}
function Wn(e, t) {
  return Math.trunc(IB(e, t)) || 0;
}
function x8(e, t) {
  return kB(IB(e, t), t);
}
function yC(e, t) {
  return CB(Wn(e, t), t);
}
function E8(e, t) {
  let [r, n] = Vl(t, Or), i = e + r;
  const s = Math.sign(i);
  return s && s === -Math.sign(n) && (i -= s, n += s * Or), [i, n];
}
function dp(e, t, r = 1) {
  return E8(e[0] + t[0] * r, e[1] + t[1] * r);
}
function Nu(e, t) {
  return E8(e[0], e[1] + t);
}
function _o(e, t) {
  return dp(t, e, -1);
}
function os(e, t) {
  return _l(e[0], t[0]) || _l(e[1], t[1]);
}
function PB(e, t, r) {
  return os(e, t) === -1 || os(e, r) === 1;
}
function A8(e, t = 1) {
  const r = BigInt(Or / t);
  return [Number(e / r), Number(e % r) * t];
}
function oy(e, t = 1) {
  const r = Or / t, [n, i] = Vl(e, r);
  return [n, i * t];
}
function ko(e, t = 1, r) {
  const [n, i] = e, [s, o] = Vl(i, t);
  return n * (Or / t) + (s + (r ? o / t : 0));
}
function S8(e, t, r = na) {
  const [n, i] = e, [s, o] = r(i, t);
  return [n * (Or / t) + s, o];
}
function _8(e) {
  return vi(e, "isoYear", h0, u0, 1), e.isoYear === h0 ? vi(e, "isoMonth", 4, 12, 1) : e.isoYear === u0 && vi(e, "isoMonth", 1, 9, 1), e;
}
function _s(e) {
  return Di({
    ...e,
    ...Bi,
    isoHour: 12
  }), e;
}
function Di(e) {
  const t = vi(e, "isoYear", h0, u0, 1), r = t === h0 ? 1 : t === u0 ? -1 : 0;
  return r && jo(xn({
    ...e,
    isoDay: e.isoDay + r,
    isoNanosecond: e.isoNanosecond - r
  })), e;
}
function jo(e) {
  if (!e || PB(e, j1t, B1t))
    throw new RangeError(Pc);
  return e;
}
function Ul(e) {
  return AB(e, 5, Ks)[1];
}
function gb(e) {
  const [t, r] = na(e, Or);
  return [fb(r, 5, Ks), t];
}
function bC(e) {
  return S8(e, go);
}
function Jn(e) {
  return id(e.isoYear, e.isoMonth, e.isoDay, e.isoHour, e.isoMinute, e.isoSecond, e.isoMillisecond);
}
function xn(e) {
  const t = Jn(e);
  if (t !== void 0) {
    const [r, n] = Vl(t, ki);
    return [r, n * Da + (e.isoMicrosecond || 0) * kg + (e.isoNanosecond || 0)];
  }
}
function k8(e, t) {
  const [r, n] = gb(Ul(e) - t);
  return jo(xn({
    ...e,
    isoDay: e.isoDay + n,
    ...r
  }));
}
function ay(...e) {
  return id(...e) / Vj;
}
function id(...e) {
  const [t, r] = RB(...e), n = t.valueOf();
  if (!isNaN(n))
    return n - r * ki;
}
function RB(e, t = 1, r = 1, n = 0, i = 0, s = 0, o = 0) {
  const a = e === h0 ? 1 : e === u0 ? -1 : 0, l = /* @__PURE__ */ new Date();
  return l.setUTCHours(n, i, s, o), l.setUTCFullYear(e, t - 1, r + a), [l, a];
}
function sd(e, t) {
  let [r, n] = Nu(e, t);
  n < 0 && (n += Or, r -= 1);
  const [i, s] = na(n, Da), [o, a] = na(s, kg);
  return mb(r * ki + i, o, a);
}
function mb(e, t = 0, r = 0) {
  const n = Math.ceil(Math.max(0, Math.abs(e) - D1t) / ki) * Math.sign(e), i = new Date(e - n * ki);
  return nd(Bb, [i.getUTCFullYear(), i.getUTCMonth() + 1, i.getUTCDate() + n, i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds(), t, r]);
}
function C8(e, t) {
  if (t < -864e13)
    throw new RangeError(Pc);
  const r = e.formatToParts(t), n = {};
  for (const i of r)
    n[i.type] = i.value;
  return n;
}
function I8(e) {
  return [e.isoYear, e.isoMonth, e.isoDay];
}
function TB(e, t) {
  return [t, 0];
}
function OB() {
  return tl;
}
function LB(e, t) {
  switch (t) {
    case 2:
      return P8(e) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function MB(e) {
  return P8(e) ? 366 : 365;
}
function P8(e) {
  return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);
}
function NB(e) {
  const [t, r] = RB(e.isoYear, e.isoMonth, e.isoDay);
  return yf(t.getUTCDay() - r, 7) || 7;
}
function DB(e) {
  return this.id === dd ? (({ isoYear: t }) => t < 1 ? ["gregory-inverse", 1 - t] : ["gregory", t])(e) : this.id === Ql ? z1t(e) : [];
}
function x0t(e) {
  const t = Jn(e);
  if (t < $1t) {
    const { isoYear: s } = e;
    return s < 1 ? ["japanese-inverse", 1 - s] : ["japanese", s];
  }
  const r = C8(IA(Ql), t), { era: n, eraYear: i } = Ej(r, Ql);
  return [n, i];
}
function yb(e) {
  return ih(e), od(e, 1), e;
}
function ih(e) {
  return BB(e, 1), e;
}
function vC(e) {
  return xB(yA, e, BB(e));
}
function BB(e, t) {
  const { isoYear: r } = e, n = vi(e, "isoMonth", 1, OB(), t);
  return {
    isoYear: r,
    isoMonth: n,
    isoDay: vi(e, "isoDay", 1, LB(r, n), t)
  };
}
function od(e, t) {
  return nd(Ks, [vi(e, "isoHour", 0, 23, t), vi(e, "isoMinute", 0, 59, t), vi(e, "isoSecond", 0, 59, t), vi(e, "isoMillisecond", 0, 999, t), vi(e, "isoMicrosecond", 0, 999, t), vi(e, "isoNanosecond", 0, 999, t)]);
}
function ur(e) {
  return e === void 0 ? 0 : iF(vg(e));
}
function bb(e, t = 0) {
  e = Fo(e);
  const r = sF(e), n = Z1t(e, t);
  return [iF(e), n, r];
}
function ad(e, t, r, n = 9, i = 0, s = 4) {
  t = Fo(t);
  let o = nF(t, n, i), a = O8(t), l = Pg(t, s);
  const c = Ig(t, n, i, 1);
  return o == null ? o = Math.max(r, c) : zB(o, c), a = L8(a, c, 1), e && (l = ((h) => h < 4 ? (h + 2) % 4 : h)(l)), [o, c, a, l];
}
function vb(e, t = 6, r) {
  let n = O8(e = wb(e, dy));
  const i = Pg(e, 7);
  let s = Ig(e, t);
  return s = _B(dy, s), n = L8(n, s, void 0, r), [s, n, i];
}
function R8(e) {
  return vA(Fo(e));
}
function jB(e, t) {
  return T8(Fo(e), t);
}
function E0t(e) {
  const t = wb(e, Qw), r = Ac(Qw, Y1t, t, 0);
  if (!r)
    throw new RangeError(Ic(Qw, r));
  return r;
}
function T8(e, t = 4) {
  const r = $B(e);
  return [Pg(e, 4), ...FB(Ig(e, t), r)];
}
function FB(e, t) {
  return e != null ? [Co[e], e < 4 ? 9 - 3 * e : -1] : [t === void 0 ? 1 : 10 ** (9 - t), t];
}
function O8(e) {
  const t = e[bf];
  return t === void 0 ? 1 : Wn(t, bf);
}
function L8(e, t, r, n) {
  const i = n ? Or : Co[t + 1];
  if (i) {
    const s = Co[t];
    if (i % ((e = ga(bf, e, 1, i / s - (n ? 0 : 1), 1)) * s))
      throw new RangeError(Ic(bf, e));
  } else
    e = ga(bf, e, 1, r ? 10 ** 9 : 1, 1);
  return e;
}
function $B(e) {
  let t = e[Gw];
  if (t !== void 0) {
    if (typeof t != "number") {
      if (v8(t) === "auto")
        return;
      throw new RangeError(Ic(Gw, t));
    }
    t = ga(Gw, Math.floor(t), 0, 9, 1);
  }
  return t;
}
function Fo(e) {
  return e === void 0 ? {} : vg(e);
}
function wb(e, t) {
  return typeof e == "string" ? {
    [t]: e
  } : vg(e);
}
function xb(e) {
  return {
    overflow: V1t[e]
  };
}
function M8(e, t, r = 9, n = 0, i) {
  let s = t[e];
  if (s === void 0)
    return i ? n : void 0;
  if (s = v8(s), s === "auto")
    return i ? n : null;
  let o = w4[s];
  if (o === void 0 && (o = L1t[s]), o === void 0)
    throw new RangeError(Nj(e, s, w4));
  return ga(e, o, n, r, 1, cA), o;
}
function Ac(e, t, r, n = 0) {
  const i = r[e];
  if (i === void 0)
    return n;
  const s = v8(i), o = t[s];
  if (o === void 0)
    throw new RangeError(Nj(e, s, t));
  return o;
}
function zB(e, t) {
  if (t > e)
    throw new RangeError(E1t);
}
function Ma(e) {
  return {
    branding: AA,
    epochNanoseconds: e
  };
}
function qs(e, t, r) {
  return {
    branding: Rc,
    calendar: r,
    timeZone: t,
    epochNanoseconds: e
  };
}
function Ys(e, t = e.calendar) {
  return {
    branding: fd,
    calendar: t,
    ...Ws(M1t, e)
  };
}
function Na(e, t = e.calendar) {
  return {
    branding: Rg,
    calendar: t,
    ...Ws(bA, e)
  };
}
function o0(e, t = e.calendar) {
  return {
    branding: wA,
    calendar: t,
    ...Ws(bA, e)
  };
}
function ly(e, t = e.calendar) {
  return {
    branding: xA,
    calendar: t,
    ...Ws(bA, e)
  };
}
function $o(e) {
  return {
    branding: EA,
    ...Ws(Jj, e)
  };
}
function hn(e) {
  return {
    branding: SA,
    sign: Sc(e),
    ...Ws(fA, e)
  };
}
function N8(e) {
  return S8(e.epochNanoseconds, Da)[0];
}
function A0t(e) {
  return ((t, r = 1) => {
    const [n, i] = t, s = Math.floor(i / r), o = Or / r;
    return BigInt(n) * BigInt(o) + BigInt(s);
  })(e.epochNanoseconds);
}
function VB(e) {
  return e.epochNanoseconds;
}
function S0t(e, t, r, n, i) {
  const s = Du(n), [o, a] = ((E, A) => {
    const x = A((E = wb(E, A4))[eF]);
    let m = K1t(E);
    return m = _B(A4, m), [m, x];
  })(i, e), l = Math.max(o, s);
  if (!a && l0(l, a))
    return wC(n, o);
  if (!a)
    throw new RangeError(Mb);
  if (!n.sign)
    return 0;
  const [c, h, u] = kb(t, r, a), p = H8(u), y = Cb(u), g = G8(u), b = y(h, c, n);
  fp(a) || (Di(c), Di(b));
  const f = g(h, c, b, o);
  return l0(o, a) ? wC(f, o) : ((E, A, x, m, w, _, S) => {
    const R = Sc(E), [O, $] = D8(m, mA(x, E), x, R, w, _, S), z = B8(A, O, $);
    return E[mr[x]] + z * R;
  })(f, p(b), o, h, c, p, y);
}
function wC(e, t) {
  return ko(Cn(e), Co[t], 1);
}
function D8(e, t, r, n, i, s, o) {
  const a = mr[r], l = {
    ...t,
    [a]: t[a] + n
  }, c = o(e, i, t), h = o(e, i, l);
  return [s(c), s(h)];
}
function B8(e, t, r) {
  const n = ko(_o(t, r));
  if (!n)
    throw new RangeError(pd);
  return ko(_o(t, e)) / n;
}
function _0t(e, t) {
  const [r, n, i] = vb(t, 5, 1);
  return Ma(Ab(e.epochNanoseconds, r, n, i, 1));
}
function k0t(e, t, r) {
  let { epochNanoseconds: n, timeZone: i, calendar: s } = t;
  const [o, a, l] = vb(r);
  if (o === 0 && a === 1)
    return t;
  const c = e(i);
  if (o === 6)
    n = ((h, u, p, y) => {
      const g = ls(p, u), [b, f] = h(g), E = p.epochNanoseconds, A = Gl(u, b), x = Gl(u, f);
      if (PB(E, A, x))
        throw new RangeError(pd);
      return WB(B8(E, A, x), y) ? x : A;
    })(GB, c, t, l);
  else {
    const h = c.R(n);
    n = ld(c, UB(sd(n, h), o, a, l), h, 2, 0, 1);
  }
  return qs(n, i, s);
}
function C0t(e, t) {
  return Ys(UB(e, ...vb(t)), e.calendar);
}
function I0t(e, t) {
  const [r, n, i] = vb(t, 5);
  var s;
  return $o((s = i, j8(e, wg(r, n), s)[0]));
}
function P0t(e, t) {
  const r = e(t.timeZone), n = ls(t, r), [i, s] = GB(n), o = ko(_o(Gl(r, i), Gl(r, s)), Db, 1);
  if (o <= 0)
    throw new RangeError(pd);
  return o;
}
function R0t(e, t) {
  const { timeZone: r, calendar: n } = t, i = ((s, o, a) => Gl(o, s(ls(a, o))))(QB, e(r), t);
  return qs(i, r, n);
}
function UB(e, t, r, n) {
  return HB(e, wg(t, r), n);
}
function HB(e, t, r) {
  const [n, i] = j8(e, t, r);
  return Di({
    ...sh(e, i),
    ...n
  });
}
function j8(e, t, r) {
  return gb(Hl(Ul(e), t, r));
}
function cy(e) {
  return Hl(e, Nb, 7);
}
function wg(e, t) {
  return Co[e] * t;
}
function GB(e) {
  const t = QB(e);
  return [t, sh(t, 1)];
}
function QB(e) {
  return N1t(6, e);
}
function T0t(e, t, r) {
  const n = Math.min(Du(e), 6);
  return cd(Sb(Cn(e, n), t, r), n);
}
function Eb(e, t, r, n, i, s, o, a, l, c) {
  if (n === 0 && i === 1)
    return e;
  const h = l0(n, a) ? fp(a) && n < 6 && r >= 6 ? L0t : O0t : M0t;
  let [u, p, y] = h(e, t, r, n, i, s, o, a, l, c);
  return y && n !== 7 && (u = ((g, b, f, E, A, x, m, w) => {
    const _ = Sc(g);
    for (let S = E + 1; S <= f; S++) {
      if (S === 7 && f !== 7)
        continue;
      const R = mA(S, g);
      R[mr[S]] += _;
      const O = ko(_o(m(w(A, x, R)), b));
      if (O && Math.sign(O) !== _)
        break;
      g = R;
    }
    return g;
  })(u, p, r, Math.max(6, n), o, a, l, c)), u;
}
function Ab(e, t, r, n, i) {
  if (t === 6) {
    const s = ((o) => o[0] + o[1] / Or)(e);
    return [Hl(s, r, n), 0];
  }
  return Sb(e, wg(t, r), n, i);
}
function Sb(e, t, r, n) {
  let [i, s] = e;
  n && s < 0 && (s += Or, i -= 1);
  const [o, a] = na(Hl(s, t, r), Or);
  return E8(i + o, a);
}
function Hl(e, t, r) {
  return WB(e / t, r) * t;
}
function WB(e, t) {
  return tmt[t](e);
}
function O0t(e, t, r, n, i, s) {
  const o = Sc(e), a = Cn(e), l = Ab(a, n, i, s), c = _o(a, l), h = Math.sign(l[0] - a[0]) === o, u = cd(l, Math.min(r, 6));
  return [{
    ...e,
    ...u
  }, dp(t, c), h];
}
function L0t(e, t, r, n, i, s, o, a, l, c) {
  const h = Sc(e) || 1, u = ko(Cn(e, 5)), p = wg(n, i);
  let y = Hl(u, p, s);
  const [g, b] = D8(o, {
    ...e,
    ...gA
  }, 6, h, a, l, c), f = y - ko(_o(g, b));
  let E = 0;
  f && Math.sign(f) !== h ? t = Nu(g, y) : (E += h, y = Hl(f, p, s), t = Nu(b, y));
  const A = Ib(y);
  return [{
    ...e,
    ...A,
    days: e.days + E
  }, t, !!E];
}
function M0t(e, t, r, n, i, s, o, a, l, c) {
  const h = Sc(e), u = mr[n], p = mA(n, e);
  n === 7 && (e = {
    ...e,
    weeks: e.weeks + Math.trunc(e.days / 7)
  });
  const y = db(e[u], i) * i;
  p[u] = y;
  const [g, b] = D8(o, p, n, i * h, a, l, c), f = y + B8(t, g, b) * h * i, E = Hl(f, i, s), A = Math.sign(E - f) === h;
  return p[u] = E, [p, A ? b : g, A];
}
function xC(e, t, r, n) {
  const [i, s, o, a] = ((c) => {
    const h = T8(c = Fo(c));
    return [c.timeZone, ...h];
  })(n), l = i !== void 0;
  return ((c, h, u, p, y, g) => {
    u = Sb(u, y, p, 1);
    const b = h.R(u);
    return F8(sd(u, b), g) + (c ? xg(cy(b)) : "Z");
  })(l, t(l ? e(i) : ch), r.epochNanoseconds, s, o, a);
}
function EC(e, t, r) {
  const [n, i, s, o, a, l] = ((c) => {
    c = Fo(c);
    const h = vA(c), u = $B(c), p = X1t(c), y = Pg(c, 4), g = Ig(c, 4);
    return [h, J1t(c), p, y, ...FB(g, u)];
  })(r);
  return ((c, h, u, p, y, g, b, f, E, A) => {
    p = Sb(p, E, f, 1);
    const x = c(u).R(p);
    return F8(sd(p, x), A) + xg(cy(x), b) + ((m, w) => w !== 1 ? "[" + (w === 2 ? "!" : "") + m + "]" : "")(u, g) + $8(h, y);
  })(e, t.calendar, t.timeZone, t.epochNanoseconds, n, i, s, o, a, l);
}
function AC(e, t) {
  const [r, n, i, s] = ((c) => (c = Fo(c), [vA(c), ...T8(c)]))(t);
  return o = e.calendar, a = r, l = s, F8(HB(e, i, n), l) + $8(o, a);
  var o, a, l;
}
function SC(e, t) {
  return r = e.calendar, n = e, i = R8(t), uy(n) + $8(r, i);
  var r, n, i;
}
function _C(e, t) {
  return qB(e.calendar, YB, e, R8(t));
}
function kC(e, t) {
  return qB(e.calendar, N0t, e, R8(t));
}
function CC(e, t) {
  const [r, n, i] = jB(t);
  return s = i, KB(j8(e, n, r)[0], s);
  var s;
}
function Fw(e, t) {
  const [r, n, i] = jB(t, 3);
  return n > 1 && oh(e = {
    ...e,
    ...T0t(e, n, r)
  }), ((s, o) => {
    const { sign: a } = s, l = a === -1 ? ci(s) : s, { hours: c, minutes: h } = l, [u, p] = S8(Cn(l, 3), go, Vl);
    tj(u);
    const y = z8(p, o), g = o >= 0 || !a || y;
    return (a < 0 ? "-" : "") + "P" + IC({
      Y: Qc(l.years),
      M: Qc(l.months),
      W: Qc(l.weeks),
      D: Qc(l.days)
    }) + (c || h || u || g ? "T" + IC({
      H: Qc(c),
      M: Qc(h),
      S: Qc(u, g) + y
    }) : "");
  })(e, i);
}
function qB(e, t, r, n) {
  const i = n > 1 || n === 0 && e !== sr;
  return n === 1 ? e === sr ? t(r) : uy(r) : i ? uy(r) + ZB(e, n === 2) : t(r);
}
function IC(e) {
  const t = [];
  for (const r in e) {
    const n = e[r];
    n && t.push(n, r);
  }
  return t.join("");
}
function F8(e, t) {
  return uy(e) + "T" + KB(e, t);
}
function uy(e) {
  return YB(e) + "-" + ks(e.isoDay);
}
function YB(e) {
  const { isoYear: t } = e;
  return (t < 0 || t > 9999 ? JB(t) + sy(6, Math.abs(t)) : sy(4, t)) + "-" + ks(e.isoMonth);
}
function N0t(e) {
  return ks(e.isoMonth) + "-" + ks(e.isoDay);
}
function KB(e, t) {
  const r = [ks(e.isoHour), ks(e.isoMinute)];
  return t !== -1 && r.push(ks(e.isoSecond) + ((n, i, s, o) => z8(n * Da + i * kg + s, o))(e.isoMillisecond, e.isoMicrosecond, e.isoNanosecond, t)), r.join(":");
}
function xg(e, t = 0) {
  if (t === 1)
    return "";
  const [r, n] = na(Math.abs(e), Db), [i, s] = na(n, Nb), [o, a] = na(s, go);
  return JB(e) + ks(r) + ":" + ks(i) + (o || a ? ":" + ks(o) + z8(a) : "");
}
function $8(e, t) {
  return t !== 1 && (t > 1 || t === 0 && e !== sr) ? ZB(e, t === 2) : "";
}
function ZB(e, t) {
  return "[" + (t ? "!" : "") + "u-ca=" + e + "]";
}
function z8(e, t) {
  let r = sy(9, e);
  return r = t === void 0 ? r.replace(nmt, "") : r.slice(0, t), r ? "." + r : "";
}
function JB(e) {
  return e < 0 ? "-" : "+";
}
function Qc(e, t) {
  return e || t ? e.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function D0t(e, t) {
  const { epochNanoseconds: r } = e, n = (t.R ? t : t(e.timeZone)).R(r), i = sd(r, n);
  return {
    calendar: e.calendar,
    ...i,
    offsetNanoseconds: n
  };
}
function ld(e, t, r, n = 0, i = 0, s, o) {
  if (r !== void 0 && n === 1 && (n === 1 || o))
    return k8(t, r);
  const a = e.I(t);
  if (r !== void 0 && n !== 3) {
    const l = ((c, h, u, p) => {
      const y = xn(h);
      p && (u = cy(u));
      for (const g of c) {
        let b = ko(_o(g, y));
        if (p && (b = cy(b)), b === u)
          return g;
      }
    })(a, t, r, s);
    if (l !== void 0)
      return l;
    if (n === 0)
      throw new RangeError(m1t);
  }
  return o ? xn(t) : Eg(e, t, i, a);
}
function Eg(e, t, r = 0, n = e.I(t)) {
  if (n.length === 1)
    return n[0];
  if (r === 1)
    throw new RangeError(y1t);
  if (n.length)
    return n[r === 3 ? 1 : 0];
  const i = xn(t), s = ((a, l) => {
    const c = a.R(Nu(l, -864e11));
    return ((h) => {
      if (h > Or)
        throw new RangeError(g1t);
      return h;
    })(a.R(Nu(l, Or)) - c);
  })(e, i), o = s * (r === 2 ? -1 : 1);
  return (n = e.I(sd(i, o)))[r === 2 ? 0 : n.length - 1];
}
function Gl(e, t) {
  const r = e.I(t);
  if (r.length)
    return r[0];
  const n = Nu(xn(t), -864e11);
  return e.O(n, 1);
}
function PC(e, t, r) {
  return Ma(jo(dp(t.epochNanoseconds, ((n) => {
    if (ej(n))
      throw new RangeError(w1t);
    return Cn(n, 5);
  })(e ? ci(r) : r))));
}
function RC(e, t, r, n, i, s = /* @__PURE__ */ Object.create(null)) {
  const o = t(n.timeZone), a = e(n.calendar);
  return {
    ...n,
    ...V8(o, a, n, r ? ci(i) : i, s)
  };
}
function TC(e, t, r, n, i = /* @__PURE__ */ Object.create(null)) {
  const { calendar: s } = r;
  return Ys(U8(e(s), r, t ? ci(n) : n, i), s);
}
function OC(e, t, r, n, i) {
  const { calendar: s } = r;
  return Na(_b(e(s), r, t ? ci(n) : n, i), s);
}
function LC(e, t, r, n, i) {
  const s = r.calendar, o = e(s);
  let a = _s(a0(o, r));
  t && (n = Q8(n)), n.sign < 0 && (a = o.P(a, {
    ...In,
    months: 1
  }), a = sh(a, -1));
  const l = o.P(a, n, i);
  return o0(a0(o, l), s);
}
function MC(e, t, r) {
  return $o(XB(t, e ? ci(r) : r)[0]);
}
function V8(e, t, r, n, i) {
  const s = Cn(n, 5);
  let o = r.epochNanoseconds;
  if (ej(n)) {
    const a = ls(r, e);
    o = dp(Eg(e, {
      ..._b(t, a, {
        ...n,
        ...gA
      }, i),
      ...Ws(Ks, a)
    }), s);
  } else
    o = dp(o, s), ur(i);
  return {
    epochNanoseconds: jo(o)
  };
}
function U8(e, t, r, n) {
  const [i, s] = XB(t, r);
  return Di({
    ..._b(e, t, {
      ...r,
      ...gA,
      days: r.days + s
    }, n),
    ...i
  });
}
function _b(e, t, r, n) {
  if (r.years || r.months || r.weeks)
    return e.P(t, r, n);
  ur(n);
  const i = r.days + Cn(r, 5)[0];
  return i ? _s(sh(t, i)) : t;
}
function a0(e, t, r = 1) {
  return sh(t, r - e.day(t));
}
function XB(e, t) {
  const [r, n] = Cn(t, 5), [i, s] = gb(Ul(e) + n);
  return [i, r + s];
}
function sh(e, t) {
  return t ? {
    ...e,
    ...mb(Jn(e) + t * ki)
  } : e;
}
function kb(e, t, r) {
  const n = e(r.calendar);
  return fp(r) ? [r, n, t(r.timeZone)] : [{
    ...r,
    ...Bi
  }, n];
}
function H8(e) {
  return e ? VB : xn;
}
function Cb(e) {
  return e ? Xe(V8, e) : U8;
}
function G8(e) {
  return e ? Xe(ogt, e) : agt;
}
function fp(e) {
  return e && e.epochNanoseconds;
}
function l0(e, t) {
  return e <= 6 - (fp(t) ? 1 : 0);
}
function NC(e, t, r, n, i, s, o) {
  const a = e(Fo(o).relativeTo), l = Math.max(Du(i), Du(s));
  if (l0(l, a))
    return hn(oh(((b, f, E, A) => {
      const x = dp(Cn(b), Cn(f), A ? -1 : 1);
      if (!Number.isFinite(x[0]))
        throw new RangeError(Pc);
      return {
        ...In,
        ...cd(x, E)
      };
    })(i, s, l, n)));
  if (!a)
    throw new RangeError(Mb);
  n && (s = ci(s));
  const [c, h, u] = kb(t, r, a), p = Cb(u), y = G8(u), g = p(h, c, i);
  return hn(y(h, c, p(h, g, s), l));
}
function B0t(e, t, r, n, i) {
  const s = Du(n), [o, a, l, c, h] = ((_, S, R) => {
    _ = wb(_, dy);
    let O = nF(_);
    const $ = R(_[eF]);
    let z = O8(_);
    const F = Pg(_, 7);
    let Y = Ig(_);
    if (O === void 0 && Y === void 0)
      throw new RangeError(x1t);
    if (Y == null && (Y = 0), O == null && (O = Math.max(Y, S)), zB(O, Y), z = L8(z, Y, 1), z > 1 && Y > 5 && O !== Y)
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    return [O, Y, z, F, $];
  })(i, s, e), u = Math.max(s, o);
  if (!h && u <= 6)
    return hn(oh(((_, S, R, O, $) => {
      const z = Ab(Cn(_), R, O, $);
      return {
        ...In,
        ...cd(z, S)
      };
    })(n, o, a, l, c)));
  if (!fp(h) && !n.sign)
    return n;
  if (!h)
    throw new RangeError(Mb);
  const [p, y, g] = kb(t, r, h), b = H8(g), f = Cb(g), E = G8(g), A = f(y, p, n);
  fp(h) || (Di(p), Di(A));
  let x = E(y, p, A, o);
  const m = n.sign, w = Sc(x);
  if (m && w && m !== w)
    throw new RangeError(pd);
  return x = Eb(x, b(A), o, a, l, c, y, p, b, f), hn(x);
}
function j0t(e) {
  return e.sign === -1 ? Q8(e) : e;
}
function Q8(e) {
  return hn(ci(e));
}
function ci(e) {
  const t = {};
  for (const r of mr)
    t[r] = -1 * e[r] || 0;
  return t;
}
function F0t(e) {
  return !e.sign;
}
function Sc(e, t = mr) {
  let r = 0;
  for (const n of t) {
    const i = Math.sign(e[n]);
    if (i) {
      if (r && r !== i)
        throw new RangeError(v1t);
      r = i;
    }
  }
  return r;
}
function oh(e) {
  for (const t of O1t)
    ga(t, e[t], -4294967295, imt, 1);
  return tj(ko(Cn(e), go)), e;
}
function tj(e) {
  if (!Number.isSafeInteger(e))
    throw new RangeError(b1t);
}
function Cn(e, t = 6) {
  return AB(e, t, mr);
}
function cd(e, t = 6) {
  const [r, n] = e, i = fb(n, t, mr);
  if (i[mr[t]] += r * (Or / Co[t]), !Number.isFinite(i[mr[t]]))
    throw new RangeError(Pc);
  return i;
}
function Ib(e, t = 5) {
  return fb(e, t, mr);
}
function ej(e) {
  return !!Sc(e, Zj);
}
function Du(e) {
  let t = 9;
  for (; t > 0 && !e[mr[t]]; t--)
    ;
  return t;
}
function $0t(e, t) {
  return [e, t];
}
function DC(e) {
  const t = Math.floor(e / G1) * G1;
  return [t, t + G1];
}
function z0t(e) {
  const t = _c(e = U1(e));
  if (!t)
    throw new RangeError(Ei(e));
  let r;
  if (t.j)
    r = 0;
  else {
    if (!t.offset)
      throw new RangeError(Ei(e));
    r = ah(t.offset);
  }
  return t.timeZone && Z8(t.timeZone, 1), Ma(k8(yb(t), r));
}
function V0t(e) {
  const t = _c(zn(e));
  if (!t)
    throw new RangeError(Ei(e));
  if (t.timeZone)
    return rj(t, t.offset ? ah(t.offset) : void 0);
  if (t.j)
    throw new RangeError(Ei(e));
  return ij(t);
}
function U0t(e, t) {
  const r = _c(zn(e));
  if (!r || !r.timeZone)
    throw new RangeError(Ei(e));
  const { offset: n } = r, i = n ? ah(n) : void 0, [, s, o] = bb(t);
  return rj(r, i, s, o);
}
function ah(e) {
  const t = Z8(e);
  if (t === void 0)
    throw new RangeError(Ei(e));
  return t;
}
function H0t(e) {
  const t = _c(zn(e));
  if (!t || t.j)
    throw new RangeError(Ei(e));
  return Ys(nj(t));
}
function W8(e, t, r) {
  let n = _c(zn(e));
  if (!n || n.j)
    throw new RangeError(Ei(e));
  return t ? n.calendar === sr && (n = n.isoYear === -271821 && n.isoMonth === 4 ? {
    ...n,
    isoDay: 20,
    ...Bi
  } : {
    ...n,
    isoDay: 1,
    ...Bi
  }) : r && n.calendar === sr && (n = {
    ...n,
    isoYear: sa
  }), Na(n.C ? nj(n) : ij(n));
}
function G0t(e, t) {
  const r = Y8(zn(t));
  if (r)
    return q8(r), o0(_8(ih(r)));
  const n = W8(t, 1);
  return o0(a0(e(n.calendar), n));
}
function q8(e) {
  if (e.calendar !== sr)
    throw new RangeError(ia(e.calendar));
}
function Q0t(e, t) {
  const r = K8(zn(t));
  if (r)
    return q8(r), ly(ih(r));
  const n = W8(t, 0, 1), { calendar: i } = n, s = e(i), [o, a, l] = s.v(n), [c, h] = s.q(o, a), [u, p] = s.G(c, h, l);
  return ly(_s(s.V(u, p, l)), i);
}
function W0t(e) {
  let t, r = ((n) => {
    const i = hmt.exec(n);
    return i ? (Pb(i[10]), aj(i)) : void 0;
  })(zn(e));
  if (!r) {
    if (r = _c(e), !r)
      throw new RangeError(Ei(e));
    if (!r.C)
      throw new RangeError(Ei(e));
    if (r.j)
      throw new RangeError(ia("Z"));
    q8(r);
  }
  if ((t = Y8(e)) && vC(t))
    throw new RangeError(Ei(e));
  if ((t = K8(e)) && vC(t))
    throw new RangeError(Ei(e));
  return $o(od(r, 1));
}
function q0t(e) {
  const t = ((r) => {
    const n = fmt.exec(r);
    return n ? ((i) => {
      function s(h, u, p) {
        let y = 0, g = 0;
        if (p && ([y, l] = na(l, Co[p])), h !== void 0) {
          if (a)
            throw new RangeError(ia(h));
          g = ((b) => {
            const f = parseInt(b);
            if (!Number.isFinite(f))
              throw new RangeError(ia(b));
            return f;
          })(h), o = 1, u && (l = J8(u) * (Co[p] / go), a = 1);
        }
        return y + g;
      }
      let o = 0, a = 0, l = 0, c = {
        ...nd(mr, [s(i[2]), s(i[3]), s(i[4]), s(i[5]), s(i[6], i[7], 5), s(i[8], i[9], 4), s(i[10], i[11], 3)]),
        ...fb(l, 2, mr)
      };
      if (!o)
        throw new RangeError(Mj(mr));
      return X8(i[1]) < 0 && (c = ci(c)), c;
    })(n) : void 0;
  })(zn(e));
  if (!t)
    throw new RangeError(Ei(e));
  return hn(oh(t));
}
function Y0t(e) {
  const t = _c(e) || Y8(e) || K8(e);
  return t ? t.calendar : e;
}
function K0t(e) {
  const t = _c(e);
  return t && (t.timeZone || t.j && ch || t.offset) || e;
}
function rj(e, t, r = 0, n = 0) {
  const i = tA(e.timeZone), s = He(i);
  let o;
  return yb(e), o = e.C ? ld(s, e, t, r, n, !s.$, e.j) : Gl(s, e), qs(o, i, Lb(e.calendar));
}
function nj(e) {
  return sj(Di(yb(e)));
}
function ij(e) {
  return sj(_s(ih(e)));
}
function sj(e) {
  return {
    ...e,
    calendar: Lb(e.calendar)
  };
}
function _c(e) {
  const t = umt.exec(e);
  return t ? ((r) => {
    const n = r[10], i = (n || "").toUpperCase() === "Z";
    return {
      isoYear: oj(r),
      isoMonth: parseInt(r[4]),
      isoDay: parseInt(r[5]),
      ...aj(r.slice(5)),
      ...Pb(r[16]),
      C: !!r[6],
      j: i,
      offset: i ? void 0 : n
    };
  })(t) : void 0;
}
function Y8(e) {
  const t = lmt.exec(e);
  return t ? ((r) => ({
    isoYear: oj(r),
    isoMonth: parseInt(r[4]),
    isoDay: 1,
    ...Pb(r[5])
  }))(t) : void 0;
}
function K8(e) {
  const t = cmt.exec(e);
  return t ? ((r) => ({
    isoYear: sa,
    isoMonth: parseInt(r[1]),
    isoDay: parseInt(r[2]),
    ...Pb(r[3])
  }))(t) : void 0;
}
function Z8(e, t) {
  const r = pmt.exec(e);
  return r ? ((n, i) => {
    const s = n[4] || n[5];
    if (i && s)
      throw new RangeError(ia(s));
    return ((o) => {
      if (Math.abs(o) >= Or)
        throw new RangeError(f1t);
      return o;
    })((qh(n[2]) * Db + qh(n[3]) * Nb + qh(n[4]) * go + J8(n[5] || "")) * X8(n[1]));
  })(r, t) : void 0;
}
function oj(e) {
  const t = X8(e[1]), r = parseInt(e[2] || e[3]);
  if (t < 0 && !r)
    throw new RangeError(ia(-0));
  return t * r;
}
function aj(e) {
  const t = qh(e[3]);
  return {
    ...gb(J8(e[4] || ""))[0],
    isoHour: qh(e[1]),
    isoMinute: qh(e[2]),
    isoSecond: t === 60 ? 59 : t
  };
}
function Pb(e) {
  let t, r;
  const n = [];
  if (e.replace(dmt, (i, s, o) => {
    const a = !!s, [l, c] = o.split("=").reverse();
    if (c) {
      if (c === "u-ca")
        n.push(l), t || (t = a);
      else if (a || /[A-Z]/.test(c))
        throw new RangeError(ia(i));
    } else {
      if (r)
        throw new RangeError(ia(i));
      r = l;
    }
    return "";
  }), n.length > 1 && t)
    throw new RangeError(ia(e));
  return {
    timeZone: r,
    calendar: n[0] || sr
  };
}
function J8(e) {
  return parseInt(e.padEnd(9, "0"));
}
function ud(e) {
  return new RegExp(`^${e}$`, "i");
}
function X8(e) {
  return e && e !== "+" ? -1 : 1;
}
function qh(e) {
  return e === void 0 ? 0 : parseInt(e);
}
function Z0t(e) {
  return tA(zn(e));
}
function tA(e) {
  const t = eA(e);
  return typeof t == "number" ? xg(t) : t ? ((r) => {
    if (ymt.test(r))
      throw new RangeError(Fj(r));
    if (mmt.test(r))
      throw new RangeError(d1t);
    return r.toLowerCase().split("/").map((n, i) => (n.length <= 3 || /\d/.test(n)) && !/etc|yap/.test(n) ? n.toUpperCase() : n.replace(/baja|dumont|[a-z]+/g, (s, o) => s.length <= 2 && !i || s === "in" || s === "chat" ? s.toUpperCase() : s.length > 2 || !o ? mC(s).replace(/island|noronha|murdo|rivadavia|urville/, mC) : s)).join("/");
  })(e) : ch;
}
function BC(e) {
  const t = eA(e);
  return typeof t == "number" ? t : t ? t.resolvedOptions().timeZone : ch;
}
function eA(e) {
  const t = Z8(e = e.toUpperCase(), 1);
  return t !== void 0 ? t : e !== ch ? gmt(e) : void 0;
}
function lj(e, t) {
  return os(e.epochNanoseconds, t.epochNanoseconds);
}
function cj(e, t) {
  return os(e.epochNanoseconds, t.epochNanoseconds);
}
function J0t(e, t, r, n, i, s) {
  const o = e(Fo(s).relativeTo), a = Math.max(Du(n), Du(i));
  if (xB(mr, n, i))
    return 0;
  if (l0(a, o))
    return os(Cn(n), Cn(i));
  if (!o)
    throw new RangeError(Mb);
  const [l, c, h] = kb(t, r, o), u = H8(h), p = Cb(h);
  return os(u(p(c, l, n)), u(p(c, l, i)));
}
function uj(e, t) {
  return hd(e, t) || rA(e, t);
}
function hd(e, t) {
  return _l(Jn(e), Jn(t));
}
function rA(e, t) {
  return _l(Ul(e), Ul(t));
}
function X0t(e, t) {
  return !lj(e, t);
}
function tgt(e, t) {
  return !cj(e, t) && !!hj(e.timeZone, t.timeZone) && e.calendar === t.calendar;
}
function egt(e, t) {
  return !uj(e, t) && e.calendar === t.calendar;
}
function rgt(e, t) {
  return !hd(e, t) && e.calendar === t.calendar;
}
function ngt(e, t) {
  return !hd(e, t) && e.calendar === t.calendar;
}
function igt(e, t) {
  return !hd(e, t) && e.calendar === t.calendar;
}
function sgt(e, t) {
  return !rA(e, t);
}
function hj(e, t) {
  if (e === t)
    return 1;
  try {
    return BC(e) === BC(t);
  } catch {
  }
}
function jC(e, t, r, n) {
  const i = ad(e, n, 3, 5), s = Rb(t.epochNanoseconds, r.epochNanoseconds, ...i);
  return hn(e ? ci(s) : s);
}
function FC(e, t, r, n, i, s) {
  const o = Ob(n.calendar, i.calendar), [a, l, c, h] = ad(r, s, 5), u = n.epochNanoseconds, p = i.epochNanoseconds, y = os(p, u);
  let g;
  if (y)
    if (a < 6)
      g = Rb(u, p, a, l, c, h);
    else {
      const b = t(((E, A) => {
        if (!hj(E, A))
          throw new RangeError($j);
        return E;
      })(n.timeZone, i.timeZone)), f = e(o);
      g = dj(f, b, n, i, y, a, s), g = Eb(g, p, a, l, c, h, f, n, VB, Xe(V8, b));
    }
  else
    g = In;
  return hn(r ? ci(g) : g);
}
function $C(e, t, r, n, i) {
  const s = Ob(r.calendar, n.calendar), [o, a, l, c] = ad(t, i, 6), h = xn(r), u = xn(n), p = os(u, h);
  let y;
  if (p)
    if (o <= 6)
      y = Rb(h, u, o, a, l, c);
    else {
      const g = e(s);
      y = fj(g, r, n, p, o, i), y = Eb(y, u, o, a, l, c, g, r, xn, U8);
    }
  else
    y = In;
  return hn(t ? ci(y) : y);
}
function zC(e, t, r, n, i) {
  const s = Ob(r.calendar, n.calendar);
  return pj(t, () => e(s), r, n, ...ad(t, i, 6, 9, 6));
}
function VC(e, t, r, n, i) {
  const s = Ob(r.calendar, n.calendar), o = ad(t, i, 9, 9, 8), a = e(s), l = a0(a, r), c = a0(a, n);
  return l.isoYear === c.isoYear && l.isoMonth === c.isoMonth && l.isoDay === c.isoDay ? hn(In) : pj(t, () => a, _s(l), _s(c), ...o, 8);
}
function pj(e, t, r, n, i, s, o, a, l = 6) {
  const c = xn(r), h = xn(n);
  if (c === void 0 || h === void 0)
    throw new RangeError(Pc);
  let u;
  if (os(h, c))
    if (i === 6)
      u = Rb(c, h, i, s, o, a);
    else {
      const p = t();
      u = p.N(r, n, i), s === l && o === 1 || (u = Eb(u, h, i, s, o, a, p, r, xn, _b));
    }
  else
    u = In;
  return hn(e ? ci(u) : u);
}
function UC(e, t, r, n) {
  const [i, s, o, a] = ad(e, n, 5, 5), l = Hl(nA(t, r), wg(s, o), a), c = {
    ...In,
    ...Ib(l, i)
  };
  return hn(e ? ci(c) : c);
}
function ogt(e, t, r, n, i, s) {
  const o = os(n.epochNanoseconds, r.epochNanoseconds);
  return o ? i < 6 ? gj(r.epochNanoseconds, n.epochNanoseconds, i) : dj(t, e, r, n, o, i, s) : In;
}
function agt(e, t, r, n, i) {
  const s = xn(t), o = xn(r), a = os(o, s);
  return a ? n <= 6 ? gj(s, o, n) : fj(e, t, r, a, n, i) : In;
}
function dj(e, t, r, n, i, s, o) {
  const [a, l, c] = ((p, y, g, b) => {
    function f() {
      return S = {
        ...sh(x, w++ * -b),
        ...A
      }, R = Eg(p, S), os(m, R) === -b;
    }
    const E = ls(y, p), A = Ws(Ks, E), x = ls(g, p), m = g.epochNanoseconds;
    let w = 0;
    const _ = nA(E, x);
    let S, R;
    if (Math.sign(_) === -b && w++, f() && (b === -1 || f()))
      throw new RangeError(pd);
    const O = ko(_o(R, m));
    return [E, S, O];
  })(t, r, n, i);
  var h, u;
  return {
    ...s === 6 ? (h = a, u = l, {
      ...In,
      days: mj(h, u)
    }) : e.N(a, l, s, o),
    ...Ib(c)
  };
}
function fj(e, t, r, n, i, s) {
  const [o, a, l] = ((c, h, u) => {
    let p = h, y = nA(c, h);
    return Math.sign(y) === -u && (p = sh(h, -u), y += Or * u), [c, p, y];
  })(t, r, n);
  return {
    ...e.N(o, a, i, s),
    ...Ib(l)
  };
}
function Rb(e, t, r, n, i, s) {
  return {
    ...In,
    ...cd(Ab(_o(e, t), n, i, s), r)
  };
}
function gj(e, t, r) {
  return {
    ...In,
    ...cd(_o(e, t), r)
  };
}
function mj(e, t) {
  return Tb(Jn(e), Jn(t));
}
function Tb(e, t) {
  return Math.trunc((t - e) / ki);
}
function nA(e, t) {
  return Ul(t) - Ul(e);
}
function Ob(e, t) {
  if (e !== t)
    throw new RangeError(jj);
  return e;
}
function yj(e) {
  return this.m(e)[0];
}
function bj(e) {
  return this.m(e)[1];
}
function iA(e) {
  const [t] = this.v(e);
  return Tb(this.p(t), Jn(e)) + 1;
}
function sA(e) {
  const t = bmt.exec(e);
  if (!t)
    throw new RangeError(h1t(e));
  return [parseInt(t[1]), !!t[2]];
}
function Ag(e, t) {
  return "M" + ks(e) + (t ? "L" : "");
}
function hy(e, t, r) {
  return e + (t || r && e >= r ? 1 : 0);
}
function oA(e, t) {
  return e - (t && e >= t ? 1 : 0);
}
function vj(e, t) {
  return (t + e) * (Math.sign(t) || 1) || 0;
}
function y4(e) {
  return Yj[xj(e)];
}
function wj(e) {
  return I1t[xj(e)];
}
function xj(e) {
  return Bu(e.id || sr);
}
function lgt(e) {
  function t(i) {
    return ((s, o) => ({
      ...Ej(s, o),
      o: s.month,
      day: parseInt(s.day)
    }))(C8(r, i), n);
  }
  const r = IA(e), n = Bu(e);
  return {
    id: e,
    h: cgt(t),
    l: ugt(t)
  };
}
function cgt(e) {
  return ss((t) => {
    const r = Jn(t);
    return e(r);
  }, WeakMap);
}
function ugt(e) {
  const t = e(0).year - F1t;
  return ss((r) => {
    let n, i = id(r - t), s = 0;
    const o = [], a = [];
    do
      i += 400 * ki;
    while ((n = e(i)).year <= r);
    do
      if (i += (1 - n.day) * ki, n.year === r && (o.push(i), a.push(n.o)), i -= ki, ++s > 100 || i < -864e13)
        throw new RangeError(pd);
    while ((n = e(i)).year >= r);
    return {
      i: o.reverse(),
      u: zj(a.reverse())
    };
  });
}
function Ej(e, t) {
  let r, n, i = Aj(e);
  if (e.era) {
    const s = Yj[t], o = Kj[t] || {};
    s !== void 0 && (r = t === "islamic" ? "ah" : e.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), r === "bc" || r === "b" ? r = "bce" : r === "ad" || r === "a" ? r = "ce" : r === "beforeroc" && (r = "broc"), r = o[r] || r, n = i, i = vj(n, s[r] || 0));
  }
  return {
    era: r,
    eraYear: n,
    year: i
  };
}
function Aj(e) {
  return parseInt(e.relatedYear || e.year);
}
function py(e) {
  const { year: t, o: r, day: n } = this.h(e), { u: i } = this.l(t);
  return [t, i[r] + 1, n];
}
function c0(e, t = 1, r = 1) {
  return this.l(e).i[t - 1] + (r - 1) * ki;
}
function Sj(e, t) {
  const r = H1.call(this, e);
  return [oA(t, r), r === t];
}
function H1(e) {
  const t = GC(this, e), r = GC(this, e - 1), n = t.length;
  if (n > r.length) {
    const i = wj(this);
    if (i < 0)
      return -i;
    for (let s = 0; s < n; s++)
      if (t[s] !== r[s])
        return s + 1;
  }
}
function o1(e) {
  return Tb(c0.call(this, e), c0.call(this, e + 1));
}
function HC(e, t) {
  const { i: r } = this.l(e);
  let n = t + 1, i = r;
  return n > r.length && (n = 1, i = this.l(e + 1).i), Tb(r[t - 1], i[n - 1]);
}
function a1(e) {
  return this.l(e).i.length;
}
function _j(e) {
  const t = this.h(e);
  return [t.era, t.eraYear];
}
function GC(e, t) {
  return Object.keys(e.l(t).u);
}
function Sg(e) {
  return Lb(zn(e));
}
function Lb(e) {
  if ((e = e.toLowerCase()) !== sr && e !== dd) {
    const t = IA(e).resolvedOptions().calendar;
    if (Bu(e) !== Bu(t))
      throw new RangeError(Bj(e));
    return t;
  }
  return e;
}
function Bu(e) {
  return e === "islamicc" && (e = "islamic"), e.split("-")[0];
}
function kj(e, t) {
  return (r) => r === sr ? e : r === dd || r === Ql ? Object.assign(Object.create(e), {
    id: r
  }) : Object.assign(Object.create(t), vmt(r));
}
function hgt(e, t, r, n) {
  const i = kc(r, n, ja, [], Gj);
  if (i.timeZone !== void 0) {
    const s = r.F(i), o = _g(i), a = e(i.timeZone);
    return {
      epochNanoseconds: ld(t(a), {
        ...s,
        ...o
      }, i.offset !== void 0 ? ah(i.offset) : void 0),
      timeZone: a
    };
  }
  return {
    ...r.F(i),
    ...Bi
  };
}
function pgt(e, t, r, n, i, s) {
  const o = kc(r, i, ja, Uj, Gj), a = e(o.timeZone), [l, c, h] = bb(s), u = r.F(o, xb(l)), p = _g(o, l);
  return qs(ld(t(a), {
    ...u,
    ...p
  }, o.offset !== void 0 ? ah(o.offset) : void 0, c, h), a, n);
}
function dgt(e, t, r) {
  const n = kc(e, t, ja, [], Ba), i = ur(r);
  return Ys(Di({
    ...e.F(n, xb(i)),
    ..._g(n, i)
  }));
}
function fgt(e, t, r, n = []) {
  const i = kc(e, t, ja, n);
  return e.F(i, r);
}
function ggt(e, t, r, n) {
  const i = kc(e, t, dA, n);
  return e.K(i, r);
}
function mgt(e, t, r, n) {
  const i = kc(e, r, ja, Cg);
  return t && i.month !== void 0 && i.monthCode === void 0 && i.year === void 0 && (i.year = sa), e._(i, n);
}
function ygt(e, t) {
  return $o(_g(as(e, x4, [], 1), ur(t)));
}
function bgt(e) {
  const t = as(e, fA);
  return hn(oh({
    ...In,
    ...t
  }));
}
function kc(e, t, r, n = [], i = []) {
  return as(t, [...e.fields(r), ...i].sort(), n);
}
function as(e, t, r, n = !r) {
  const i = {};
  let s, o = 0;
  for (const a of t) {
    if (a === s)
      throw new RangeError(n1t(a));
    if (a === "constructor" || a === "__proto__")
      throw new RangeError(r1t(a));
    let l = e[a];
    if (l !== void 0)
      o = 1, QC[a] && (l = QC[a](l, a)), i[a] = l;
    else if (r) {
      if (r.includes(a))
        throw new TypeError(lA(a));
      i[a] = qj[a];
    }
    s = a;
  }
  if (n && !o)
    throw new TypeError(Mj(t));
  return i;
}
function _g(e, t) {
  return od(PA({
    ...qj,
    ...e
  }), t);
}
function vgt(e, t, r, n, i) {
  const { calendar: s, timeZone: o } = r, a = e(s), l = t(o), c = [...a.fields(ja), ...Hj].sort(), h = ((E) => {
    const A = ls(E, He), x = xg(A.offsetNanoseconds), m = Fb(E.calendar), [w, _, S] = m.v(A), [R, O] = m.q(w, _), $ = Ag(R, O);
    return {
      ...Cmt(A),
      year: w,
      monthCode: $,
      day: S,
      offset: x
    };
  })(r), u = as(n, c), p = a.k(h, u), y = {
    ...h,
    ...u
  }, [g, b, f] = bb(i, 2);
  return qs(ld(l, {
    ...a.F(p, xb(g)),
    ...od(PA(y), g)
  }, ah(y.offset), b, f), o, s);
}
function wgt(e, t, r, n) {
  const i = e(t.calendar), s = [...i.fields(ja), ...Ba].sort(), o = {
    ...Ij(a = t),
    hour: a.isoHour,
    minute: a.isoMinute,
    second: a.isoSecond,
    millisecond: a.isoMillisecond,
    microsecond: a.isoMicrosecond,
    nanosecond: a.isoNanosecond
  };
  var a;
  const l = as(r, s), c = ur(n), h = i.k(o, l), u = {
    ...o,
    ...l
  };
  return Ys(Di({
    ...i.F(h, xb(c)),
    ...od(PA(u), c)
  }));
}
function xgt(e, t, r, n) {
  const i = e(t.calendar), s = i.fields(ja).sort(), o = Ij(t), a = as(r, s), l = i.k(o, a);
  return i.F(l, n);
}
function Egt(e, t, r, n) {
  const i = e(t.calendar), s = i.fields(dA).sort(), o = ((c) => {
    const h = Fb(c.calendar), [u, p] = h.v(c), [y, g] = h.q(u, p);
    return {
      year: u,
      monthCode: Ag(y, g)
    };
  })(t), a = as(r, s), l = i.k(o, a);
  return i.K(l, n);
}
function Agt(e, t, r, n) {
  const i = e(t.calendar), s = i.fields(ja).sort(), o = ((c) => {
    const h = Fb(c.calendar), [u, p, y] = h.v(c), [g, b] = h.q(u, p);
    return {
      monthCode: Ag(g, b),
      day: y
    };
  })(t), a = as(r, s), l = i.k(o, a);
  return i._(l, n);
}
function Sgt(e, t, r) {
  return $o(((n, i, s) => _g({
    ...Ws(x4, n),
    ...as(i, x4)
  }, ur(s)))(e, t, r));
}
function _gt(e, t) {
  return hn((r = e, n = t, oh({
    ...r,
    ...as(n, fA)
  })));
  var r, n;
}
function Cj(e, t, r, n, i) {
  t = Ws(r = e.fields(r), t), n = as(n, i = e.fields(i), []);
  let s = e.k(t, n);
  return s = as(s, [...r, ...i].sort(), []), e.F(s);
}
function $w(e, t) {
  const r = y4(e), n = Kj[e.id || ""] || {};
  let { era: i, eraYear: s, year: o } = t;
  if (i !== void 0 || s !== void 0) {
    if (i === void 0 || s === void 0)
      throw new TypeError(a1t);
    if (!r)
      throw new RangeError(o1t);
    const a = r[n[i] || i];
    if (a === void 0)
      throw new RangeError(c1t(i));
    const l = vj(s, a);
    if (o !== void 0 && o !== l)
      throw new RangeError(l1t);
    o = l;
  } else if (o === void 0)
    throw new TypeError(u1t(r));
  return o;
}
function l1(e, t, r, n) {
  let { month: i, monthCode: s } = t;
  if (s !== void 0) {
    const o = ((a, l, c, h) => {
      const u = a.L(c), [p, y] = sA(l);
      let g = hy(p, y, u);
      if (y) {
        const b = wj(a);
        if (b === void 0)
          throw new RangeError(Ud);
        if (b > 0) {
          if (g > b)
            throw new RangeError(Ud);
          if (u === void 0) {
            if (h === 1)
              throw new RangeError(Ud);
            g--;
          }
        } else {
          if (g !== -b)
            throw new RangeError(Ud);
          if (u === void 0 && h === 1)
            throw new RangeError(Ud);
        }
      }
      return g;
    })(e, s, r, n);
    if (i !== void 0 && i !== o)
      throw new RangeError(p1t);
    i = o, n = 1;
  } else if (i === void 0)
    throw new TypeError(Dj);
  return ga("month", i, 1, e.B(r), n);
}
function zw(e, t, r, n, i) {
  return vi(t, "day", 1, e.U(n, r), i);
}
function Vw(e, t, r, n) {
  let i = 0;
  const s = [];
  for (const o of r)
    t[o] !== void 0 ? i = 1 : s.push(o);
  if (Object.assign(e, t), i)
    for (const o of n || s)
      delete e[o];
}
function Ij(e) {
  const t = Fb(e.calendar), [r, n, i] = t.v(e), [s, o] = t.q(r, n);
  return {
    year: r,
    monthCode: Ag(s, o),
    day: i
  };
}
function kgt(e) {
  return Ma(jo(A8(w8(e))));
}
function Cgt(e, t, r, n, i = sr) {
  return qs(jo(A8(w8(r))), t(n), e(i));
}
function Igt(e, t, r, n, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, h = sr) {
  return Ys(Di(yb(ma(Wn, nd(Bb, [t, r, n, i, s, o, a, l, c])))), e(h));
}
function Pgt(e, t, r, n, i = sr) {
  return Na(_s(ih(ma(Wn, {
    isoYear: t,
    isoMonth: r,
    isoDay: n
  }))), e(i));
}
function Rgt(e, t, r, n = sr, i = 1) {
  const s = Wn(t), o = Wn(r), a = e(n);
  return o0(_8(ih({
    isoYear: s,
    isoMonth: o,
    isoDay: Wn(i)
  })), a);
}
function Tgt(e, t, r, n = sr, i = sa) {
  const s = Wn(t), o = Wn(r), a = e(n);
  return ly(_s(ih({
    isoYear: Wn(i),
    isoMonth: s,
    isoDay: o
  })), a);
}
function Ogt(e = 0, t = 0, r = 0, n = 0, i = 0, s = 0) {
  return $o(od(ma(Wn, nd(Ks, [e, t, r, n, i, s])), 1));
}
function Lgt(e = 0, t = 0, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0) {
  return hn(oh(ma(x8, nd(mr, [e, t, r, n, i, s, o, a, l, c]))));
}
function Mgt(e, t, r = sr) {
  return qs(e.epochNanoseconds, t, r);
}
function Ngt(e) {
  return Ma(e.epochNanoseconds);
}
function Pj(e, t) {
  return Ys(ls(t, e));
}
function Rj(e, t) {
  return Na(ls(t, e));
}
function Tj(e, t) {
  return $o(ls(t, e));
}
function Dgt(e, t, r, n) {
  const i = ((s, o, a, l) => {
    const c = ((h) => sF(Fo(h)))(l);
    return Eg(s(o), a, c);
  })(e, r, t, n);
  return qs(jo(i), r, t.calendar);
}
function Bgt(e, t, r, n, i) {
  const s = e(i.timeZone), o = i.plainTime, a = o !== void 0 ? t(o) : void 0, l = r(s);
  let c;
  return c = a ? Eg(l, {
    ...n,
    ...a
  }) : Gl(l, {
    ...n,
    ...Bi
  }), qs(c, s, n.calendar);
}
function jgt(e, t = Bi) {
  return Ys(Di({
    ...e,
    ...t
  }));
}
function Fgt(e, t, r) {
  return ((n, i) => {
    const s = kc(n, i, Qj);
    return n.K(s, void 0);
  })(e(t.calendar), r);
}
function $gt(e, t, r) {
  return ((n, i) => {
    const s = kc(n, i, Wj);
    return n._(s);
  })(e(t.calendar), r);
}
function zgt(e, t, r, n) {
  return ((i, s, o) => Cj(i, s, Qj, vg(o), Cg))(e(t.calendar), r, n);
}
function Vgt(e, t, r, n) {
  return ((i, s, o) => Cj(i, s, Wj, vg(o), uA))(e(t.calendar), r, n);
}
function Ugt(e) {
  return Ma(jo(oy(x8(e), Da)));
}
function Hgt(e) {
  return Ma(jo(A8(w8(e))));
}
function lh(e, t, r) {
  const n = new Set(r);
  return (i, s) => {
    const o = r && gC(i, r);
    if (!gC(i = ((a, l) => {
      const c = {};
      for (const h in l)
        a.has(h) || (c[h] = l[h]);
      return c;
    })(n, i), e)) {
      if (s && o)
        throw new TypeError("Invalid formatting options");
      i = {
        ...t,
        ...i
      };
    }
    return r && (i.timeZone = ch, ["full", "long"].includes(i.J) && (i.J = "medium")), i;
  };
}
function Cc(e, t = Oj, r = 0) {
  const [n, , , i] = e;
  return (s, o = Qmt, ...a) => {
    const l = t(i && i(...a), s, o, n, r), c = l.resolvedOptions();
    return [l, ...Ggt(e, c, a)];
  };
}
function Oj(e, t, r, n, i) {
  if (r = n(r, i), e) {
    if (r.timeZone !== void 0)
      throw new TypeError(S1t);
    r.timeZone = e;
  }
  return new kl(t, r);
}
function Ggt(e, t, r) {
  const [, n, i] = e;
  return r.map((s) => (s.calendar && ((o, a, l) => {
    if ((l || o !== sr) && o !== a)
      throw new RangeError(jj);
  })(s.calendar, t.calendar, i), n(s, t)));
}
function Qgt(e, t, r) {
  const n = t.timeZone, i = e(n), s = {
    ...ls(t, i),
    ...r || Bi
  };
  let o;
  return o = r ? ld(i, s, s.offsetNanoseconds, 2) : Gl(i, s), qs(o, n, t.calendar);
}
function Wgt(e, t = Bi) {
  return Ys(Di({
    ...e,
    ...t
  }));
}
function aA(e, t) {
  return {
    ...e,
    calendar: t
  };
}
function qgt(e, t) {
  return {
    ...e,
    timeZone: t
  };
}
function Uw(e) {
  const t = b4();
  return sd(t, e.R(t));
}
function b4() {
  return oy(Date.now(), Da);
}
function Vd() {
  return WC || (WC = new kl().resolvedOptions().timeZone);
}
const Ygt = (e, t) => `Non-integer ${e}: ${t}`, Kgt = (e, t) => `Non-positive ${e}: ${t}`, Zgt = (e, t) => `Non-finite ${e}: ${t}`, Jgt = (e) => `Cannot convert bigint to ${e}`, Xgt = (e) => `Invalid bigint: ${e}`, t1t = "Cannot convert Symbol to string", e1t = "Invalid object", Lj = (e, t, r, n, i) => i ? Lj(e, i[t], i[r], i[n]) : Ic(e, t) + `; must be between ${r}-${n}`, Ic = (e, t) => `Invalid ${e}: ${t}`, lA = (e) => `Missing ${e}`, r1t = (e) => `Invalid field ${e}`, n1t = (e) => `Duplicate field ${e}`, Mj = (e) => "No valid fields: " + e.join(), i1t = "Invalid bag", Nj = (e, t, r) => Ic(e, t) + "; must be " + Object.keys(r).join(), s1t = "Cannot use valueOf", v4 = "Invalid calling context", o1t = "Forbidden era/eraYear", a1t = "Mismatching era/eraYear", l1t = "Mismatching year/eraYear", c1t = (e) => `Invalid era: ${e}`, u1t = (e) => "Missing year" + (e ? "/era/eraYear" : ""), h1t = (e) => `Invalid monthCode: ${e}`, p1t = "Mismatching month/monthCode", Dj = "Missing month/monthCode", Ud = "Invalid leap month", pd = "Invalid protocol results", Bj = (e) => Ic("Calendar", e), jj = "Mismatching Calendars", Fj = (e) => Ic("TimeZone", e), $j = "Mismatching TimeZones", d1t = "Forbidden ICU TimeZone", f1t = "Out-of-bounds offset", g1t = "Out-of-bounds TimeZone gap", m1t = "Invalid TimeZone offset", y1t = "Ambiguous offset", Pc = "Out-of-bounds date", b1t = "Out-of-bounds duration", v1t = "Cannot mix duration signs", Mb = "Missing relativeTo", w1t = "Cannot use large units", x1t = "Required smallestUnit or largestUnit", E1t = "smallestUnit > largestUnit", Ei = (e) => `Cannot parse: ${e}`, ia = (e) => `Invalid substring: ${e}`, A1t = (e) => `Cannot format ${e}`, Hw = "Mismatching types for formatting", S1t = "Cannot specify TimeZone", zj = /* @__PURE__ */ Xe(pb, (e, t) => t), gp = /* @__PURE__ */ Xe(pb, (e, t, r) => r), ks = /* @__PURE__ */ Xe(sy, 2), w4 = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, cA = /* @__PURE__ */ Object.keys(w4), ki = 864e5, Vj = 1e3, kg = 1e3, Da = 1e6, go = 1e9, Nb = 6e10, Db = 36e11, Or = 864e11, Co = [1, kg, Da, go, Nb, Db, Or], Ba = /* @__PURE__ */ cA.slice(0, 6), x4 = /* @__PURE__ */ bg(Ba), _1t = ["offset"], Uj = ["timeZone"], Hj = /* @__PURE__ */ Ba.concat(_1t), Gj = /* @__PURE__ */ Hj.concat(Uj), E4 = ["era", "eraYear"], k1t = /* @__PURE__ */ E4.concat(["year"]), uA = ["year"], hA = ["monthCode"], pA = /* @__PURE__ */ ["month"].concat(hA), Cg = ["day"], dA = /* @__PURE__ */ pA.concat(uA), Qj = /* @__PURE__ */ hA.concat(uA), ja = /* @__PURE__ */ Cg.concat(dA), C1t = /* @__PURE__ */ Cg.concat(pA), Wj = /* @__PURE__ */ Cg.concat(hA), qj = /* @__PURE__ */ gp(Ba, 0), sr = "iso8601", dd = "gregory", Ql = "japanese", Yj = {
  [dd]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [Ql]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, Kj = {
  [dd]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [Ql]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
}, I1t = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, zn = /* @__PURE__ */ Xe(b8, "string"), P1t = /* @__PURE__ */ Xe(b8, "boolean"), R1t = /* @__PURE__ */ Xe(b8, "number"), mr = /* @__PURE__ */ cA.map((e) => e + "s"), fA = /* @__PURE__ */ bg(mr), T1t = /* @__PURE__ */ mr.slice(0, 6), Zj = /* @__PURE__ */ mr.slice(6), O1t = /* @__PURE__ */ Zj.slice(1), L1t = /* @__PURE__ */ zj(mr), In = /* @__PURE__ */ gp(mr, 0), gA = /* @__PURE__ */ gp(T1t, 0), mA = /* @__PURE__ */ Xe(EB, mr), Ks = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"], yA = ["isoDay", "isoMonth", "isoYear"], Bb = /* @__PURE__ */ Ks.concat(yA), bA = /* @__PURE__ */ bg(yA), Jj = /* @__PURE__ */ bg(Ks), M1t = /* @__PURE__ */ bg(Bb), Bi = /* @__PURE__ */ gp(Jj, 0), N1t = /* @__PURE__ */ Xe(EB, Bb), Xj = 1e8, D1t = Xj * ki, B1t = [Xj, 0], j1t = [-1e8, 0], u0 = 275760, h0 = -271821, kl = Intl.DateTimeFormat, tF = "en-GB", F1t = 1970, sa = 1972, tl = 12, $1t = /* @__PURE__ */ id(1868, 9, 8), z1t = /* @__PURE__ */ ss(x0t, WeakMap), dy = "smallestUnit", A4 = "unit", bf = "roundingIncrement", Gw = "fractionalSecondDigits", eF = "relativeTo", Qw = "direction", rF = {
  constrain: 0,
  reject: 1
}, V1t = /* @__PURE__ */ Object.keys(rF), U1t = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}, H1t = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}, G1t = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}, Q1t = {
  auto: 0,
  never: 1,
  critical: 2
}, W1t = {
  auto: 0,
  never: 1
}, q1t = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}, Y1t = {
  previous: -1,
  next: 1
}, Ig = /* @__PURE__ */ Xe(M8, dy), nF = /* @__PURE__ */ Xe(M8, "largestUnit"), K1t = /* @__PURE__ */ Xe(M8, A4), iF = /* @__PURE__ */ Xe(Ac, "overflow", rF), sF = /* @__PURE__ */ Xe(Ac, "disambiguation", U1t), Z1t = /* @__PURE__ */ Xe(Ac, "offset", H1t), vA = /* @__PURE__ */ Xe(Ac, "calendarName", G1t), J1t = /* @__PURE__ */ Xe(Ac, "timeZoneName", Q1t), X1t = /* @__PURE__ */ Xe(Ac, "offset", W1t), Pg = /* @__PURE__ */ Xe(Ac, "roundingMode", q1t), wA = "PlainYearMonth", xA = "PlainMonthDay", Rg = "PlainDate", fd = "PlainDateTime", EA = "PlainTime", Rc = "ZonedDateTime", AA = "Instant", SA = "Duration", tmt = [Math.floor, (e) => s1(e) ? Math.floor(e) : Math.round(e), Math.ceil, (e) => s1(e) ? Math.ceil(e) : Math.round(e), Math.trunc, (e) => s1(e) ? Math.trunc(e) || 0 : Math.round(e), (e) => e < 0 ? Math.floor(e) : Math.ceil(e), (e) => Math.sign(e) * Math.round(Math.abs(e)) || 0, (e) => s1(e) ? (e = Math.trunc(e) || 0) + e % 2 : Math.round(e)], ch = "UTC", G1 = 5184e3, emt = /* @__PURE__ */ ay(1847), rmt = /* @__PURE__ */ ay(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10), nmt = /0+$/, ls = /* @__PURE__ */ ss(D0t, WeakMap), imt = 2 ** 32 - 1, He = /* @__PURE__ */ ss((e) => {
  const t = eA(e);
  return typeof t == "object" ? new omt(t) : new smt(t || 0);
});
class smt {
  constructor(t) {
    this.$ = t;
  }
  R() {
    return this.$;
  }
  I(t) {
    return ((r) => {
      const n = xn({
        ...r,
        ...Bi
      });
      if (!n || Math.abs(n[0]) > 1e8)
        throw new RangeError(Pc);
    })(t), [k8(t, this.$)];
  }
  O() {
  }
}
class omt {
  constructor(t) {
    this.nn = ((r) => {
      function n(c) {
        const h = s0(c, a, l), [u, p] = DC(h), y = s(u), g = s(p);
        return y === g ? y : i(o(u, p), y, g, c);
      }
      function i(c, h, u, p) {
        let y, g;
        for (; (p === void 0 || (y = p < c[0] ? h : p >= c[1] ? u : void 0) === void 0) && (g = c[1] - c[0]); ) {
          const b = c[0] + Math.floor(g / 2);
          r(b) === u ? c[1] = b : c[0] = b + 1;
        }
        return y;
      }
      const s = ss(r), o = ss($0t);
      let a = emt, l = rmt;
      return {
        tn(c) {
          const h = n(c - 86400), u = n(c + 86400), p = c - h, y = c - u;
          if (h === u)
            return [p];
          const g = n(p);
          return g === n(y) ? [c - g] : h > u ? [p, y] : [];
        },
        rn: n,
        O(c, h) {
          const u = s0(c, a, l);
          let [p, y] = DC(u);
          const g = G1 * h, b = h < 0 ? () => y > a || (a = u, 0) : () => p < l || (l = u, 0);
          for (; b(); ) {
            const f = s(p), E = s(y);
            if (f !== E) {
              const A = o(p, y);
              i(A, f, E);
              const x = A[0];
              if ((_l(x, c) || 1) === h)
                return x;
            }
            p += g, y += g;
          }
        }
      };
    })(/* @__PURE__ */ ((r) => (n) => {
      const i = C8(r, n * Vj);
      return ay(Aj(i), parseInt(i.month), parseInt(i.day), parseInt(i.hour), parseInt(i.minute), parseInt(i.second)) - n;
    })(t));
  }
  R(t) {
    return this.nn.rn(((r) => bC(r)[0])(t)) * go;
  }
  I(t) {
    const [r, n] = [ay((i = t).isoYear, i.isoMonth, i.isoDay, i.isoHour, i.isoMinute, i.isoSecond), i.isoMillisecond * Da + i.isoMicrosecond * kg + i.isoNanosecond];
    var i;
    return this.nn.tn(r).map((s) => jo(Nu(oy(s, go), n)));
  }
  O(t, r) {
    const [n, i] = bC(t), s = this.nn.O(n + (r > 0 || i ? 1 : 0), r);
    if (s !== void 0)
      return oy(s, go);
  }
}
const _A = "([+-])", Q1 = "(?:[.,](\\d{1,9}))?", oF = `(?:(?:${_A}(\\d{6}))|(\\d{4}))-?(\\d{2})`, kA = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + Q1 + ")?)?", CA = _A + kA, amt = oF + "-?(\\d{2})(?:[T ]" + kA + "(Z|" + CA + ")?)?", aF = "\\[(!?)([^\\]]*)\\]", jb = `((?:${aF}){0,9})`, lmt = /* @__PURE__ */ ud(oF + jb), cmt = /* @__PURE__ */ ud("(?:--)?(\\d{2})-?(\\d{2})" + jb), umt = /* @__PURE__ */ ud(amt + jb), hmt = /* @__PURE__ */ ud("T?" + kA + "(?:" + CA + ")?" + jb), pmt = /* @__PURE__ */ ud(CA), dmt = /* @__PURE__ */ new RegExp(aF, "g"), fmt = /* @__PURE__ */ ud(`${_A}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${Q1}H)?(?:(\\d+)${Q1}M)?(?:(\\d+)${Q1}S)?)?`), gmt = /* @__PURE__ */ ss((e) => new kl(tF, {
  timeZone: e,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
})), mmt = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, ymt = /[^\w\/:+-]+/, bmt = /^M(\d{2})(L?)$/, vmt = /* @__PURE__ */ ss(lgt), IA = /* @__PURE__ */ ss((e) => new kl(tF, {
  calendar: e,
  timeZone: ch,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
})), lF = {
  P(e, t, r) {
    const n = ur(r);
    let i, { years: s, months: o, weeks: a, days: l } = t;
    if (l += Cn(t, 5)[0], s || o)
      i = ((c, h, u, p, y) => {
        let [g, b, f] = c.v(h);
        if (u) {
          const [E, A] = c.q(g, b);
          g += u, b = hy(E, A, c.L(g)), b = ga("month", b, 1, c.B(g), y);
        }
        return p && ([g, b] = c.un(g, b, p)), f = ga("day", f, 1, c.U(g, b), y), c.p(g, b, f);
      })(this, e, s, o, n);
    else {
      if (!a && !l)
        return e;
      i = Jn(e);
    }
    if (i === void 0)
      throw new RangeError(Pc);
    return i += (7 * a + l) * ki, _s(mb(i));
  },
  N(e, t, r) {
    if (r <= 7) {
      let l = 0, c = mj({
        ...e,
        ...Bi
      }, {
        ...t,
        ...Bi
      });
      return r === 7 && ([l, c] = Vl(c, 7)), {
        ...In,
        weeks: l,
        days: c
      };
    }
    const n = this.v(e), i = this.v(t);
    let [s, o, a] = ((l, c, h, u, p, y, g) => {
      let b = p - c, f = y - h, E = g - u;
      if (b || f) {
        const A = Math.sign(b || f);
        let x = l.U(p, y), m = 0;
        if (Math.sign(E) === -A) {
          const w = x;
          [p, y] = l.un(p, y, -A), b = p - c, f = y - h, x = l.U(p, y), m = A < 0 ? -w : x;
        }
        if (E = g - Math.min(u, x) + m, b) {
          const [w, _] = l.q(c, h), [S, R] = l.q(p, y);
          if (f = S - w || Number(R) - Number(_), Math.sign(f) === -A) {
            const O = A < 0 && -l.B(p);
            b = (p -= A) - c, f = y - hy(w, _, l.L(p)) + (O || l.B(p));
          }
        }
      }
      return [b, f, E];
    })(this, ...n, ...i);
    return r === 8 && (o += this.cn(s, n[0]), s = 0), {
      ...In,
      years: s,
      months: o,
      days: a
    };
  },
  F(e, t) {
    const r = ur(t), n = $w(this, e), i = l1(this, e, n, r), s = zw(this, e, i, n, r);
    return Na(_s(this.V(n, i, s)), this.id || sr);
  },
  K(e, t) {
    const r = ur(t), n = $w(this, e), i = l1(this, e, n, r);
    return o0(_8(this.V(n, i, 1)), this.id || sr);
  },
  _(e, t) {
    const r = ur(t);
    let n, i, s, o = e.eraYear !== void 0 || e.year !== void 0 ? $w(this, e) : void 0;
    const a = !this.id;
    if (o === void 0 && a && (o = sa), o !== void 0) {
      const u = l1(this, e, o, r);
      n = zw(this, e, u, o, r);
      const p = this.L(o);
      i = oA(u, p), s = u === p;
    } else {
      if (e.monthCode === void 0)
        throw new TypeError(Dj);
      if ([i, s] = sA(e.monthCode), this.id && this.id !== dd && this.id !== Ql)
        if (this.id && Bu(this.id) === "coptic" && r === 0) {
          const u = s || i !== 13 ? 30 : 6;
          n = e.day, n = s0(n, 1, u);
        } else if (this.id && Bu(this.id) === "chinese" && r === 0) {
          const u = !s || i !== 1 && i !== 9 && i !== 10 && i !== 11 && i !== 12 ? 30 : 29;
          n = e.day, n = s0(n, 1, u);
        } else
          n = e.day;
      else
        n = zw(this, e, l1(this, e, sa, r), sa, r);
    }
    const l = this.G(i, s, n);
    if (!l)
      throw new RangeError("Cannot guess year");
    const [c, h] = l;
    return ly(_s(this.V(c, h, n)), this.id || sr);
  },
  fields(e) {
    return y4(this) && e.includes("year") ? [...e, ...E4] : e;
  },
  k(e, t) {
    const r = Object.assign(/* @__PURE__ */ Object.create(null), e);
    return Vw(r, t, pA), y4(this) && (Vw(r, t, k1t), this.id === Ql && Vw(r, t, C1t, E4)), r;
  },
  inLeapYear(e) {
    const [t] = this.v(e);
    return this.sn(t);
  },
  monthsInYear(e) {
    const [t] = this.v(e);
    return this.B(t);
  },
  daysInMonth(e) {
    const [t, r] = this.v(e);
    return this.U(t, r);
  },
  daysInYear(e) {
    const [t] = this.v(e);
    return this.fn(t);
  },
  dayOfYear: iA,
  era(e) {
    return this.hn(e)[0];
  },
  eraYear(e) {
    return this.hn(e)[1];
  },
  monthCode(e) {
    const [t, r] = this.v(e), [n, i] = this.q(t, r);
    return Ag(n, i);
  },
  dayOfWeek: NB,
  daysInWeek() {
    return 7;
  }
}, wmt = {
  v: I8,
  hn: DB,
  q: TB
}, xmt = {
  dayOfYear: iA,
  v: I8,
  p: id
}, Emt = /* @__PURE__ */ Object.assign({}, xmt, {
  weekOfYear: yj,
  yearOfWeek: bj,
  m(e) {
    function t(y) {
      return (7 - y < n ? 7 : 0) - y;
    }
    function r(y) {
      const g = MB(p + y), b = y || 1, f = t(yf(l + g * b, 7));
      return h = (g + (f - c) * b) / 7;
    }
    const n = this.id ? 1 : 4, i = NB(e), s = this.dayOfYear(e), o = yf(i - 1, 7), a = s - 1, l = yf(o - a, 7), c = t(l);
    let h, u = Math.floor((a - c) / 7) + 1, p = e.isoYear;
    return u ? u > r(0) && (u = 1, p++) : (u = r(-1), p--), [u, p, h];
  }
}), Amt = /* @__PURE__ */ Object.assign({}, lF, Emt, {
  v: I8,
  hn: DB,
  q: TB,
  G(e, t) {
    if (!t)
      return [sa, e];
  },
  sn: P8,
  L() {
  },
  B: OB,
  cn: (e) => e * tl,
  U: LB,
  fn: MB,
  V: (e, t, r) => ({
    isoYear: e,
    isoMonth: t,
    isoDay: r
  }),
  p: id,
  un: (e, t, r) => (e += db(r, tl), (t += m8(r, tl)) < 1 ? (e--, t += tl) : t > tl && (e++, t -= tl), [e, t]),
  year(e) {
    return e.isoYear;
  },
  month(e) {
    return e.isoMonth;
  },
  day: (e) => e.isoDay
}), Smt = {
  v: py,
  hn: _j,
  q: Sj
}, _mt = {
  dayOfYear: iA,
  v: py,
  p: c0,
  weekOfYear: yj,
  yearOfWeek: bj,
  m() {
    return [];
  }
}, kmt = /* @__PURE__ */ Object.assign({}, lF, _mt, {
  v: py,
  hn: _j,
  q: Sj,
  G(e, t, r) {
    const n = this.id && Bu(this.id) === "chinese" ? ((c, h, u) => {
      if (h)
        switch (c) {
          case 1:
            return 1651;
          case 2:
            return u < 30 ? 1947 : 1765;
          case 3:
            return u < 30 ? 1966 : 1955;
          case 4:
            return u < 30 ? 1963 : 1944;
          case 5:
            return u < 30 ? 1971 : 1952;
          case 6:
            return u < 30 ? 1960 : 1941;
          case 7:
            return u < 30 ? 1968 : 1938;
          case 8:
            return u < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      return 1972;
    })(e, t, r) : sa;
    let [i, s, o] = py.call(this, {
      isoYear: n,
      isoMonth: tl,
      isoDay: 31
    });
    const a = H1.call(this, i), l = s === a;
    (_l(e, oA(s, a)) || _l(Number(t), Number(l)) || _l(r, o)) === 1 && i--;
    for (let c = 0; c < 100; c++) {
      const h = i - c, u = H1.call(this, h), p = hy(e, t, u);
      if (t === (p === u) && r <= HC.call(this, h, p))
        return [h, p];
    }
  },
  sn(e) {
    const t = o1.call(this, e);
    return t > o1.call(this, e - 1) && t > o1.call(this, e + 1);
  },
  L: H1,
  B: a1,
  cn(e, t) {
    const r = t + e, n = Math.sign(e), i = n < 0 ? -1 : 0;
    let s = 0;
    for (let o = t; o !== r; o += n)
      s += a1.call(this, o + i);
    return s;
  },
  U: HC,
  fn: o1,
  V(e, t, r) {
    return mb(c0.call(this, e, t, r));
  },
  p: c0,
  un(e, t, r) {
    if (r) {
      if (t += r, !Number.isSafeInteger(t))
        throw new RangeError(Pc);
      if (r < 0)
        for (; t < 1; )
          t += a1.call(this, --e);
      else {
        let n;
        for (; t > (n = a1.call(this, e)); )
          t -= n, e++;
      }
    }
    return [e, t];
  },
  year(e) {
    return this.h(e).year;
  },
  month(e) {
    const { year: t, o: r } = this.h(e), { u: n } = this.l(t);
    return n[r] + 1;
  },
  day(e) {
    return this.h(e).day;
  }
}), Fb = /* @__PURE__ */ kj(wmt, Smt), Ne = /* @__PURE__ */ kj(Amt, kmt), QC = {
  era: U1,
  eraYear: Wn,
  year: Wn,
  month: yC,
  monthCode(e) {
    const t = U1(e);
    return sA(t), t;
  },
  day: yC,
  .../* @__PURE__ */ gp(Ba, Wn),
  .../* @__PURE__ */ gp(mr, x8),
  offset(e) {
    const t = U1(e);
    return ah(t), t;
  }
}, PA = /* @__PURE__ */ Xe(wB, Ba, Ks), Cmt = /* @__PURE__ */ Xe(wB, Ks, Ba), Cl = "numeric", Tg = ["timeZoneName"], cF = {
  month: Cl,
  day: Cl
}, RA = {
  year: Cl,
  month: Cl
}, TA = /* @__PURE__ */ Object.assign({}, RA, {
  day: Cl
}), OA = {
  hour: Cl,
  minute: Cl,
  second: Cl
}, LA = /* @__PURE__ */ Object.assign({}, TA, OA), Imt = /* @__PURE__ */ Object.assign({}, LA, {
  timeZoneName: "short"
}), Pmt = /* @__PURE__ */ Object.keys(RA), Rmt = /* @__PURE__ */ Object.keys(cF), Tmt = /* @__PURE__ */ Object.keys(TA), Omt = /* @__PURE__ */ Object.keys(OA), MA = ["dateStyle"], Lmt = /* @__PURE__ */ Pmt.concat(MA), Mmt = /* @__PURE__ */ Rmt.concat(MA), NA = /* @__PURE__ */ Tmt.concat(MA, ["weekday"]), Og = /* @__PURE__ */ Omt.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]), DA = /* @__PURE__ */ NA.concat(Og), Nmt = /* @__PURE__ */ Tg.concat(Og), Dmt = /* @__PURE__ */ Tg.concat(NA), Bmt = /* @__PURE__ */ Tg.concat(["day", "weekday"], Og), jmt = /* @__PURE__ */ Tg.concat(["year", "weekday"], Og), Fmt = /* @__PURE__ */ lh(DA, LA), $mt = /* @__PURE__ */ lh(DA, Imt), zmt = /* @__PURE__ */ lh(DA, LA, Tg), Vmt = /* @__PURE__ */ lh(NA, TA, Nmt), Umt = /* @__PURE__ */ lh(Og, OA, Dmt), Hmt = /* @__PURE__ */ lh(Lmt, RA, Bmt), Gmt = /* @__PURE__ */ lh(Mmt, cF, jmt), Qmt = {}, uF = new kl(void 0, {
  calendar: sr
}).resolvedOptions().calendar === sr, hF = [Fmt, N8], Wmt = [$mt, N8, 0, (e, t) => {
  const r = e.timeZone;
  if (t && t.timeZone !== r)
    throw new RangeError($j);
  return r;
}], pF = [zmt, Jn], dF = [Vmt, Jn], fF = [Umt, (e) => Ul(e) / Da], gF = [Hmt, Jn, uF], mF = [Gmt, Jn, uF];
let WC;
function Tc(e, t, r, n, i) {
  function s(...l) {
    if (!(this instanceof s))
      throw new TypeError(v4);
    KC(this, t(...l));
  }
  function o(l, c) {
    return Object.defineProperties(function(...h) {
      return l.call(this, a(this), ...h);
    }, i0(c));
  }
  function a(l) {
    const c = ui(l);
    if (!c || c.branding !== e)
      throw new TypeError(v4);
    return c;
  }
  return Object.defineProperties(s.prototype, {
    ...b0t(ma(o, r)),
    ...pp(ma(o, n)),
    ...g8("Temporal." + e)
  }), Object.defineProperties(s, {
    ...pp(i),
    ...i0(e)
  }), [s, (l) => {
    const c = Object.create(s.prototype);
    return KC(c, l), c;
  }, a];
}
function gd(e) {
  if (ui(e) || e.calendar !== void 0 || e.timeZone !== void 0)
    throw new TypeError(i1t);
  return e;
}
function Lg(e) {
  return yF(e) || sr;
}
function yF(e) {
  const { calendar: t } = e;
  if (t !== void 0)
    return $b(t);
}
function $b(e) {
  if (li(e)) {
    const { calendar: t } = ui(e) || {};
    if (!t)
      throw new TypeError(Bj(e));
    return t;
  }
  return ((t) => Lb(Y0t(zn(t))))(e);
}
function BA(e) {
  const t = {};
  for (const r in e)
    t[r] = (n) => {
      const { calendar: i } = n;
      return Ne(i)[r](n);
    };
  return t;
}
function Oc() {
  throw new TypeError(s1t);
}
function qi(e) {
  if (li(e)) {
    const { timeZone: t } = ui(e) || {};
    if (!t)
      throw new TypeError(Fj(e));
    return t;
  }
  return ((t) => tA(K0t(zn(t))))(e);
}
function en(e) {
  if (li(e)) {
    const t = ui(e);
    return t && t.branding === SA ? t : bgt(e);
  }
  return q0t(e);
}
function Hd(e) {
  if (e !== void 0) {
    if (li(e)) {
      const t = ui(e) || {};
      switch (t.branding) {
        case Rc:
        case Rg:
          return t;
        case fd:
          return Na(t);
      }
      const r = Lg(e);
      return {
        ...hgt(qi, He, Ne(r), e),
        calendar: r
      };
    }
    return V0t(e);
  }
}
function el(e, t) {
  if (li(e)) {
    const n = ui(e) || {};
    switch (n.branding) {
      case EA:
        return ur(t), n;
      case fd:
        return ur(t), $o(n);
      case Rc:
        return ur(t), Tj(He, n);
    }
    return ygt(e, t);
  }
  const r = W0t(e);
  return ur(t), r;
}
function jA(e) {
  return e === void 0 ? void 0 : el(e);
}
function _h(e, t) {
  if (li(e)) {
    const n = ui(e) || {};
    switch (n.branding) {
      case fd:
        return ur(t), n;
      case Rg:
        return ur(t), Ys({
          ...n,
          ...Bi
        });
      case Rc:
        return ur(t), Pj(He, n);
    }
    return dgt(Ne(Lg(e)), e, t);
  }
  const r = H0t(e);
  return ur(t), r;
}
function qC(e, t) {
  if (li(e)) {
    const n = ui(e);
    if (n && n.branding === xA)
      return ur(t), n;
    const i = yF(e);
    return mgt(Ne(i || sr), !i, e, t);
  }
  const r = Q0t(Ne, e);
  return ur(t), r;
}
function kh(e, t) {
  if (li(e)) {
    const n = ui(e);
    return n && n.branding === wA ? (ur(t), n) : ggt(Ne(Lg(e)), e, t);
  }
  const r = G0t(Ne, e);
  return ur(t), r;
}
function Ch(e, t) {
  if (li(e)) {
    const n = ui(e) || {};
    switch (n.branding) {
      case Rg:
        return ur(t), n;
      case fd:
        return ur(t), Na(n);
      case Rc:
        return ur(t), Rj(He, n);
    }
    return fgt(Ne(Lg(e)), e, t);
  }
  const r = W8(e);
  return ur(t), r;
}
function Ih(e, t) {
  if (li(e)) {
    const r = ui(e);
    if (r && r.branding === Rc)
      return bb(t), r;
    const n = Lg(e);
    return pgt(qi, He, Ne(n), n, e, t);
  }
  return U0t(e, t);
}
function YC(e) {
  return ma((t) => (r) => t(S4(r)), e);
}
function S4(e) {
  return ls(e, He);
}
function Ph(e) {
  if (li(e)) {
    const t = ui(e);
    if (t)
      switch (t.branding) {
        case AA:
          return t;
        case Rc:
          return Ma(t.epochNanoseconds);
      }
  }
  return z0t(e);
}
function qmt() {
  function e(s, o) {
    return new t(s, o);
  }
  function t(s, o = /* @__PURE__ */ Object.create(null)) {
    gy.set(this, ((a, l) => {
      const c = new kl(a, l), h = c.resolvedOptions(), u = h.locale, p = Ws(Object.keys(l), h), y = ss(Zmt), g = (b, ...f) => {
        if (b) {
          if (f.length !== 2)
            throw new TypeError(Hw);
          for (const m of f)
            if (m === void 0)
              throw new TypeError(Hw);
        }
        b || f[0] !== void 0 || (f = []);
        const E = f.map((m) => ui(m) || Number(m));
        let A, x = 0;
        for (const m of E) {
          const w = typeof m == "object" ? m.branding : void 0;
          if (x++ && w !== A)
            throw new TypeError(Hw);
          A = w;
        }
        return A ? y(A)(u, p, ...E) : [c, ...E];
      };
      return g.X = c, g;
    })(s, o));
  }
  const r = kl.prototype, n = Object.getOwnPropertyDescriptors(r), i = Object.getOwnPropertyDescriptors(kl);
  for (const s in n) {
    const o = n[s], a = s.startsWith("format") && Ymt(s);
    typeof o.value == "function" ? o.value = s === "constructor" ? e : a || Kmt(s) : a && (o.get = function() {
      if (!gy.has(this))
        throw new TypeError(v4);
      return (...l) => a.apply(this, l);
    }, Object.defineProperties(o.get, i0(`get ${s}`)));
  }
  return i.prototype.value = t.prototype = Object.create({}, n), Object.defineProperties(e, i), e;
}
function Ymt(e) {
  return Object.defineProperties(function(...t) {
    const r = gy.get(this), [n, ...i] = r(e.includes("Range"), ...t);
    return n[e](...i);
  }, i0(e));
}
function Kmt(e) {
  return Object.defineProperties(function(...t) {
    return gy.get(this).X[e](...t);
  }, i0(e));
}
function Zmt(e) {
  const t = nyt[e];
  if (!t)
    throw new TypeError(A1t(e));
  return Cc(t, ss(Oj), 1);
}
const fy = /* @__PURE__ */ new WeakMap(), ui = /* @__PURE__ */ fy.get.bind(fy), KC = /* @__PURE__ */ fy.set.bind(fy), bF = {
  era: v0t,
  eraYear: SB,
  year: y8,
  month: Wo,
  daysInMonth: Wo,
  daysInYear: Wo,
  inLeapYear: P1t,
  monthsInYear: Wo
}, FA = {
  monthCode: zn
}, vF = {
  day: Wo
}, Jmt = {
  dayOfWeek: Wo,
  dayOfYear: Wo,
  weekOfYear: w0t,
  yearOfWeek: SB,
  daysInWeek: Wo
}, $A = /* @__PURE__ */ BA(/* @__PURE__ */ Object.assign({}, bF, FA, vF, Jmt)), Xmt = /* @__PURE__ */ BA({
  ...bF,
  ...FA
}), tyt = /* @__PURE__ */ BA({
  ...FA,
  ...vF
}), Mg = {
  calendarId: (e) => e.calendar
}, eyt = /* @__PURE__ */ pb((e) => (t) => t[e], mr.concat("sign")), zA = /* @__PURE__ */ pb((e, t) => (r) => r[Ks[t]], Ba), wF = {
  epochMilliseconds: N8,
  epochNanoseconds: A0t
}, [ryt, Qr, J5t] = Tc(SA, Lgt, {
  ...eyt,
  blank: F0t
}, {
  with: (e, t) => Qr(_gt(e, t)),
  negated: (e) => Qr(Q8(e)),
  abs: (e) => Qr(j0t(e)),
  add: (e, t, r) => Qr(NC(Hd, Ne, He, 0, e, en(t), r)),
  subtract: (e, t, r) => Qr(NC(Hd, Ne, He, 1, e, en(t), r)),
  round: (e, t) => Qr(B0t(Hd, Ne, He, e, t)),
  total: (e, t) => S0t(Hd, Ne, He, e, t),
  toLocaleString(e, t, r) {
    return Intl.DurationFormat ? new Intl.DurationFormat(t, r).format(this) : Fw(e);
  },
  toString: Fw,
  toJSON: (e) => Fw(e),
  valueOf: Oc
}, {
  from: (e) => Qr(en(e)),
  compare: (e, t, r) => J0t(Hd, Ne, He, en(e), en(t), r)
}), nyt = {
  Instant: hF,
  PlainDateTime: pF,
  PlainDate: dF,
  PlainTime: fF,
  PlainYearMonth: gF,
  PlainMonthDay: mF
}, iyt = /* @__PURE__ */ Cc(hF), syt = /* @__PURE__ */ Cc(Wmt), oyt = /* @__PURE__ */ Cc(pF), ayt = /* @__PURE__ */ Cc(dF), lyt = /* @__PURE__ */ Cc(fF), cyt = /* @__PURE__ */ Cc(gF), uyt = /* @__PURE__ */ Cc(mF), [hyt, cl] = Tc(EA, Ogt, zA, {
  with(e, t, r) {
    return cl(Sgt(this, gd(t), r));
  },
  add: (e, t) => cl(MC(0, e, en(t))),
  subtract: (e, t) => cl(MC(1, e, en(t))),
  until: (e, t, r) => Qr(UC(0, e, el(t), r)),
  since: (e, t, r) => Qr(UC(1, e, el(t), r)),
  round: (e, t) => cl(I0t(e, t)),
  equals: (e, t) => sgt(e, el(t)),
  toLocaleString(e, t, r) {
    const [n, i] = lyt(t, r, e);
    return n.format(i);
  },
  toString: CC,
  toJSON: (e) => CC(e),
  valueOf: Oc
}, {
  from: (e, t) => cl(el(e, t)),
  compare: (e, t) => rA(el(e), el(t))
}), [pyt, no] = Tc(fd, Xe(Igt, Sg), {
  ...Mg,
  ...$A,
  ...zA
}, {
  with: (e, t, r) => no(wgt(Ne, e, gd(t), r)),
  withCalendar: (e, t) => no(aA(e, $b(t))),
  withPlainTime: (e, t) => no(Wgt(e, jA(t))),
  add: (e, t, r) => no(TC(Ne, 0, e, en(t), r)),
  subtract: (e, t, r) => no(TC(Ne, 1, e, en(t), r)),
  until: (e, t, r) => Qr($C(Ne, 0, e, _h(t), r)),
  since: (e, t, r) => Qr($C(Ne, 1, e, _h(t), r)),
  round: (e, t) => no(C0t(e, t)),
  equals: (e, t) => egt(e, _h(t)),
  toZonedDateTime: (e, t, r) => Hn(Dgt(He, e, qi(t), r)),
  toPlainDate: (e) => lo(Na(e)),
  toPlainTime: (e) => cl($o(e)),
  toLocaleString(e, t, r) {
    const [n, i] = oyt(t, r, e);
    return n.format(i);
  },
  toString: AC,
  toJSON: (e) => AC(e),
  valueOf: Oc
}, {
  from: (e, t) => no(_h(e, t)),
  compare: (e, t) => uj(_h(e), _h(t))
}), [dyt, _4, X5t] = Tc(xA, Xe(Tgt, Sg), {
  ...Mg,
  ...tyt
}, {
  with: (e, t, r) => _4(Agt(Ne, e, gd(t), r)),
  equals: (e, t) => igt(e, qC(t)),
  toPlainDate(e, t) {
    return lo(Vgt(Ne, e, this, t));
  },
  toLocaleString(e, t, r) {
    const [n, i] = uyt(t, r, e);
    return n.format(i);
  },
  toString: kC,
  toJSON: (e) => kC(e),
  valueOf: Oc
}, {
  from: (e, t) => _4(qC(e, t))
}), [fyt, Jd, tEt] = Tc(wA, Xe(Rgt, Sg), {
  ...Mg,
  ...Xmt
}, {
  with: (e, t, r) => Jd(Egt(Ne, e, gd(t), r)),
  add: (e, t, r) => Jd(LC(Ne, 0, e, en(t), r)),
  subtract: (e, t, r) => Jd(LC(Ne, 1, e, en(t), r)),
  until: (e, t, r) => Qr(VC(Ne, 0, e, kh(t), r)),
  since: (e, t, r) => Qr(VC(Ne, 1, e, kh(t), r)),
  equals: (e, t) => ngt(e, kh(t)),
  toPlainDate(e, t) {
    return lo(zgt(Ne, e, this, t));
  },
  toLocaleString(e, t, r) {
    const [n, i] = cyt(t, r, e);
    return n.format(i);
  },
  toString: _C,
  toJSON: (e) => _C(e),
  valueOf: Oc
}, {
  from: (e, t) => Jd(kh(e, t)),
  compare: (e, t) => hd(kh(e), kh(t))
}), [gyt, lo, eEt] = Tc(Rg, Xe(Pgt, Sg), {
  ...Mg,
  ...$A
}, {
  with: (e, t, r) => lo(xgt(Ne, e, gd(t), r)),
  withCalendar: (e, t) => lo(aA(e, $b(t))),
  add: (e, t, r) => lo(OC(Ne, 0, e, en(t), r)),
  subtract: (e, t, r) => lo(OC(Ne, 1, e, en(t), r)),
  until: (e, t, r) => Qr(zC(Ne, 0, e, Ch(t), r)),
  since: (e, t, r) => Qr(zC(Ne, 1, e, Ch(t), r)),
  equals: (e, t) => rgt(e, Ch(t)),
  toZonedDateTime(e, t) {
    const r = li(t) ? t : {
      timeZone: t
    };
    return Hn(Bgt(qi, el, He, e, r));
  },
  toPlainDateTime: (e, t) => no(jgt(e, jA(t))),
  toPlainYearMonth(e) {
    return Jd(Fgt(Ne, e, this));
  },
  toPlainMonthDay(e) {
    return _4($gt(Ne, e, this));
  },
  toLocaleString(e, t, r) {
    const [n, i] = ayt(t, r, e);
    return n.format(i);
  },
  toString: SC,
  toJSON: (e) => SC(e),
  valueOf: Oc
}, {
  from: (e, t) => lo(Ch(e, t)),
  compare: (e, t) => hd(Ch(e), Ch(t))
}), [myt, Hn] = Tc(Rc, Xe(Cgt, Sg, Z0t), {
  ...wF,
  ...Mg,
  ...YC($A),
  ...YC(zA),
  offset: (e) => xg(S4(e).offsetNanoseconds),
  offsetNanoseconds: (e) => S4(e).offsetNanoseconds,
  timeZoneId: (e) => e.timeZone,
  hoursInDay: (e) => P0t(He, e)
}, {
  with: (e, t, r) => Hn(vgt(Ne, He, e, gd(t), r)),
  withCalendar: (e, t) => Hn(aA(e, $b(t))),
  withTimeZone: (e, t) => Hn(qgt(e, qi(t))),
  withPlainTime: (e, t) => Hn(Qgt(He, e, jA(t))),
  add: (e, t, r) => Hn(RC(Ne, He, 0, e, en(t), r)),
  subtract: (e, t, r) => Hn(RC(Ne, He, 1, e, en(t), r)),
  until: (e, t, r) => Qr(hn(FC(Ne, He, 0, e, Ih(t), r))),
  since: (e, t, r) => Qr(hn(FC(Ne, He, 1, e, Ih(t), r))),
  round: (e, t) => Hn(k0t(He, e, t)),
  startOfDay: (e) => Hn(R0t(He, e)),
  equals: (e, t) => tgt(e, Ih(t)),
  toInstant: (e) => rl(Ngt(e)),
  toPlainDateTime: (e) => no(Pj(He, e)),
  toPlainDate: (e) => lo(Rj(He, e)),
  toPlainTime: (e) => cl(Tj(He, e)),
  toLocaleString(e, t, r = {}) {
    const [n, i] = syt(t, r, e);
    return n.format(i);
  },
  toString: (e, t) => EC(He, e, t),
  toJSON: (e) => EC(He, e),
  valueOf: Oc,
  getTimeZoneTransition(e, t) {
    const { timeZone: r, epochNanoseconds: n } = e, i = E0t(t), s = He(r).O(n, i);
    return s ? Hn({
      ...e,
      epochNanoseconds: s
    }) : null;
  }
}, {
  from: (e, t) => Hn(Ih(e, t)),
  compare: (e, t) => cj(Ih(e), Ih(t))
}), [yyt, rl, rEt] = Tc(AA, kgt, wF, {
  add: (e, t) => rl(PC(0, e, en(t))),
  subtract: (e, t) => rl(PC(1, e, en(t))),
  until: (e, t, r) => Qr(jC(0, e, Ph(t), r)),
  since: (e, t, r) => Qr(jC(1, e, Ph(t), r)),
  round: (e, t) => rl(_0t(e, t)),
  equals: (e, t) => X0t(e, Ph(t)),
  toZonedDateTimeISO: (e, t) => Hn(Mgt(e, qi(t))),
  toLocaleString(e, t, r) {
    const [n, i] = iyt(t, r, e);
    return n.format(i);
  },
  toString: (e, t) => xC(qi, He, e, t),
  toJSON: (e) => xC(qi, He, e),
  valueOf: Oc
}, {
  from: (e) => rl(Ph(e)),
  fromEpochMilliseconds: (e) => rl(Ugt(e)),
  fromEpochNanoseconds: (e) => rl(Hgt(e)),
  compare: (e, t) => lj(Ph(e), Ph(t))
}), byt = /* @__PURE__ */ Object.defineProperties({}, {
  ...g8("Temporal.Now"),
  ...pp({
    timeZoneId: () => Vd(),
    instant: () => rl(Ma(b4())),
    zonedDateTimeISO: (e = Vd()) => Hn(qs(b4(), qi(e), sr)),
    plainDateTimeISO: (e = Vd()) => no(Ys(Uw(He(qi(e))), sr)),
    plainDateISO: (e = Vd()) => lo(Na(Uw(He(qi(e))), sr)),
    plainTimeISO: (e = Vd()) => cl($o(Uw(He(qi(e)))))
  })
}), c1 = /* @__PURE__ */ Object.defineProperties({}, {
  ...g8("Temporal"),
  ...pp({
    PlainYearMonth: fyt,
    PlainMonthDay: dyt,
    PlainDate: gyt,
    PlainTime: hyt,
    PlainDateTime: pyt,
    ZonedDateTime: myt,
    Instant: yyt,
    Duration: ryt,
    Now: byt
  })
}), vyt = /* @__PURE__ */ qmt(), gy = /* @__PURE__ */ new WeakMap();
pp({
  DateTimeFormat: vyt
});
var k4 = 9e15, Lc = 1e9, C4 = "0123456789abcdef", my = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", yy = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", I4 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -9e15,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: k4,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, xF, qo, Re = !0, zb = "[DecimalError] ", ju = zb + "Invalid argument: ", EF = zb + "Precision limit exceeded", AF = zb + "crypto unavailable", Pn = Math.floor, gn = Math.pow, wyt = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, xyt = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, Eyt = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, Ayt = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Cs = 1e7, be = 7, Syt = 9007199254740991, _yt = my.length - 1, P4 = yy.length - 1, $t = { name: "[object Decimal]" };
$t.absoluteValue = $t.abs = function() {
  var e = new this.constructor(this);
  return e.s < 0 && (e.s = 1), pe(e);
};
$t.ceil = function() {
  return pe(new this.constructor(this), this.e + 1, 2);
};
$t.comparedTo = $t.cmp = function(e) {
  var t, r, n, i, s = this, o = s.d, a = (e = new s.constructor(e)).d, l = s.s, c = e.s;
  if (!o || !a)
    return !l || !c ? NaN : l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? l : a[0] ? -c : 0;
  if (l !== c) return l;
  if (s.e !== e.e) return s.e > e.e ^ l < 0 ? 1 : -1;
  for (n = o.length, i = a.length, t = 0, r = n < i ? n : i; t < r; ++t)
    if (o[t] !== a[t]) return o[t] > a[t] ^ l < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
};
$t.cosine = $t.cos = function() {
  var e, t, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + be, n.rounding = 1, r = kyt(n, IF(n, r)), n.precision = e, n.rounding = t, pe(qo == 2 || qo == 3 ? r.neg() : r, e, t, !0)) : new n(1) : new n(NaN);
};
$t.cubeRoot = $t.cbrt = function() {
  var e, t, r, n, i, s, o, a, l, c, h = this, u = h.constructor;
  if (!h.isFinite() || h.isZero()) return new u(h);
  for (Re = !1, s = h.s * Math.pow(h.s * h, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = nn(h.d), e = h.e, (s = (e - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Math.pow(r, 1 / 3), e = Pn((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + e : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new u(r), n.s = h.s) : n = new u(s.toString()), o = (e = u.precision) + 3; ; )
    if (a = n, l = a.times(a).times(a), c = l.plus(h), n = er(c.plus(h).times(a), c.plus(l), o + 2, 1), nn(a.d).slice(0, o) === (r = nn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (pe(a, e + 1, 0), a.times(a).times(a).eq(h))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (pe(n, e + 1, 1), t = !n.times(n).times(n).eq(h));
        break;
      }
  return Re = !0, pe(n, e, u.rounding, t);
};
$t.decimalPlaces = $t.dp = function() {
  var e, t = this.d, r = NaN;
  if (t) {
    if (e = t.length - 1, r = (e - Pn(this.e / be)) * be, e = t[e], e) for (; e % 10 == 0; e /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
$t.dividedBy = $t.div = function(e) {
  return er(this, new this.constructor(e));
};
$t.dividedToIntegerBy = $t.divToInt = function(e) {
  var t = this, r = t.constructor;
  return pe(er(t, new r(e), 0, 1, 1), r.precision, r.rounding);
};
$t.equals = $t.eq = function(e) {
  return this.cmp(e) === 0;
};
$t.floor = function() {
  return pe(new this.constructor(this), this.e + 1, 3);
};
$t.greaterThan = $t.gt = function(e) {
  return this.cmp(e) > 0;
};
$t.greaterThanOrEqualTo = $t.gte = function(e) {
  var t = this.cmp(e);
  return t == 1 || t === 0;
};
$t.hyperbolicCosine = $t.cosh = function() {
  var e, t, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (e = Math.ceil(i / 3), t = Math.pow(4, -e).toString()) : (e = 16, t = "2.3283064365386962890625e-10"), s = mp(o, 1, s.times(t), new o(1), !0);
  for (var l, c = e, h = new o(8); c--; )
    l = s.times(s), s = a.minus(l.times(h.minus(l.times(h))));
  return pe(s, o.precision = r, o.rounding = n, !0);
};
$t.hyperbolicSine = $t.sinh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero()) return new s(i);
  if (t = s.precision, r = s.rounding, s.precision = t + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = mp(s, 2, i, i, !0);
  else {
    e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(Math.pow(5, -e)), i = mp(s, 2, i, i, !0);
    for (var o, a = new s(5), l = new s(16), c = new s(20); e--; )
      o = i.times(i), i = i.times(a.plus(o.times(l.times(o).plus(c))));
  }
  return s.precision = t, s.rounding = r, pe(i, t, r, !0);
};
$t.hyperbolicTangent = $t.tanh = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, er(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s);
};
$t.inverseCosine = $t.acos = function() {
  var e, t = this, r = t.constructor, n = t.abs().cmp(1), i = r.precision, s = r.rounding;
  return n !== -1 ? n === 0 ? t.isNeg() ? ys(r, i, s) : new r(0) : new r(NaN) : t.isZero() ? ys(r, i + 4, s).times(0.5) : (r.precision = i + 6, r.rounding = 1, t = t.asin(), e = ys(r, i + 4, s).times(0.5), r.precision = i, r.rounding = s, e.minus(t));
};
$t.inverseHyperbolicCosine = $t.acosh = function() {
  var e, t, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, Re = !1, r = r.times(r).minus(1).sqrt().plus(r), Re = !0, n.precision = e, n.rounding = t, r.ln()) : new n(r);
};
$t.inverseHyperbolicSine = $t.asinh = function() {
  var e, t, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, Re = !1, r = r.times(r).plus(1).sqrt().plus(r), Re = !0, n.precision = e, n.rounding = t, r.ln());
};
$t.inverseHyperbolicTangent = $t.atanh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = s.precision, t = s.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? pe(new s(i), e, t, !0) : (s.precision = r = n - i.e, i = er(i.plus(1), new s(1).minus(i), r + e, 1), s.precision = e + 4, s.rounding = 1, i = i.ln(), s.precision = e, s.rounding = t, i.times(0.5))) : new s(NaN);
};
$t.inverseSine = $t.asin = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (t = i.abs().cmp(1), r = s.precision, n = s.rounding, t !== -1 ? t === 0 ? (e = ys(s, r + 4, n).times(0.5), e.s = i.s, e) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
$t.inverseTangent = $t.atan = function() {
  var e, t, r, n, i, s, o, a, l, c = this, h = c.constructor, u = h.precision, p = h.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new h(c);
    if (c.abs().eq(1) && u + 4 <= P4)
      return o = ys(h, u + 4, p).times(0.25), o.s = c.s, o;
  } else {
    if (!c.s) return new h(NaN);
    if (u + 4 <= P4)
      return o = ys(h, u + 4, p).times(0.5), o.s = c.s, o;
  }
  for (h.precision = a = u + 10, h.rounding = 1, r = Math.min(28, a / be + 2 | 0), e = r; e; --e) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (Re = !1, t = Math.ceil(a / be), n = 1, l = c.times(c), o = new h(c), i = c; e !== -1; )
    if (i = i.times(l), s = o.minus(i.div(n += 2)), i = i.times(l), o = s.plus(i.div(n += 2)), o.d[t] !== void 0) for (e = t; o.d[e] === s.d[e] && e--; ) ;
  return r && (o = o.times(2 << r - 1)), Re = !0, pe(o, h.precision = u, h.rounding = p, !0);
};
$t.isFinite = function() {
  return !!this.d;
};
$t.isInteger = $t.isInt = function() {
  return !!this.d && Pn(this.e / be) > this.d.length - 2;
};
$t.isNaN = function() {
  return !this.s;
};
$t.isNegative = $t.isNeg = function() {
  return this.s < 0;
};
$t.isPositive = $t.isPos = function() {
  return this.s > 0;
};
$t.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
$t.lessThan = $t.lt = function(e) {
  return this.cmp(e) < 0;
};
$t.lessThanOrEqualTo = $t.lte = function(e) {
  return this.cmp(e) < 1;
};
$t.logarithm = $t.log = function(e) {
  var t, r, n, i, s, o, a, l, c = this, h = c.constructor, u = h.precision, p = h.rounding, y = 5;
  if (e == null)
    e = new h(10), t = !0;
  else {
    if (e = new h(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1)) return new h(NaN);
    t = e.eq(10);
  }
  if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1))
    return new h(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (t)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      s = i !== 1;
    }
  if (Re = !1, a = u + y, o = fl(c, a), n = t ? by(h, a + 10) : fl(e, a), l = er(o, n, a, 1), p0(l.d, i = u, p))
    do
      if (a += 10, o = fl(c, a), n = t ? by(h, a + 10) : fl(e, a), l = er(o, n, a, 1), !s) {
        +nn(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = pe(l, u + 1, 0));
        break;
      }
    while (p0(l.d, i += 10, p));
  return Re = !0, pe(l, u, p);
};
$t.minus = $t.sub = function(e) {
  var t, r, n, i, s, o, a, l, c, h, u, p, y = this, g = y.constructor;
  if (e = new g(e), !y.d || !e.d)
    return !y.s || !e.s ? e = new g(NaN) : y.d ? e.s = -e.s : e = new g(e.d || y.s !== e.s ? y : NaN), e;
  if (y.s != e.s)
    return e.s = -e.s, y.plus(e);
  if (c = y.d, p = e.d, a = g.precision, l = g.rounding, !c[0] || !p[0]) {
    if (p[0]) e.s = -e.s;
    else if (c[0]) e = new g(y);
    else return new g(l === 3 ? -0 : 0);
    return Re ? pe(e, a, l) : e;
  }
  if (r = Pn(e.e / be), h = Pn(y.e / be), c = c.slice(), s = h - r, s) {
    for (u = s < 0, u ? (t = c, s = -s, o = p.length) : (t = p, r = h, o = c.length), n = Math.max(Math.ceil(a / be), o) + 2, s > n && (s = n, t.length = 1), t.reverse(), n = s; n--; ) t.push(0);
    t.reverse();
  } else {
    for (n = c.length, o = p.length, u = n < o, u && (o = n), n = 0; n < o; n++)
      if (c[n] != p[n]) {
        u = c[n] < p[n];
        break;
      }
    s = 0;
  }
  for (u && (t = c, c = p, p = t, e.s = -e.s), o = c.length, n = p.length - o; n > 0; --n) c[o++] = 0;
  for (n = p.length; n > s; ) {
    if (c[--n] < p[n]) {
      for (i = n; i && c[--i] === 0; ) c[i] = Cs - 1;
      --c[i], c[n] += Cs;
    }
    c[n] -= p[n];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --r;
  return c[0] ? (e.d = c, e.e = Vb(c, r), Re ? pe(e, a, l) : e) : new g(l === 3 ? -0 : 0);
};
$t.modulo = $t.mod = function(e) {
  var t, r = this, n = r.constructor;
  return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? pe(new n(r), n.precision, n.rounding) : (Re = !1, n.modulo == 9 ? (t = er(r, e.abs(), 0, 3, 1), t.s *= e.s) : t = er(r, e, 0, n.modulo, 1), t = t.times(e), Re = !0, r.minus(t));
};
$t.naturalExponential = $t.exp = function() {
  return R4(this);
};
$t.naturalLogarithm = $t.ln = function() {
  return fl(this);
};
$t.negated = $t.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s, pe(e);
};
$t.plus = $t.add = function(e) {
  var t, r, n, i, s, o, a, l, c, h, u = this, p = u.constructor;
  if (e = new p(e), !u.d || !e.d)
    return !u.s || !e.s ? e = new p(NaN) : u.d || (e = new p(e.d || u.s === e.s ? u : NaN)), e;
  if (u.s != e.s)
    return e.s = -e.s, u.minus(e);
  if (c = u.d, h = e.d, a = p.precision, l = p.rounding, !c[0] || !h[0])
    return h[0] || (e = new p(u)), Re ? pe(e, a, l) : e;
  if (s = Pn(u.e / be), n = Pn(e.e / be), c = c.slice(), i = s - n, i) {
    for (i < 0 ? (r = c, i = -i, o = h.length) : (r = h, n = s, o = c.length), s = Math.ceil(a / be), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = c.length, i = h.length, o - i < 0 && (i = o, r = h, h = c, c = r), t = 0; i; )
    t = (c[--i] = c[i] + h[i] + t) / Cs | 0, c[i] %= Cs;
  for (t && (c.unshift(t), ++n), o = c.length; c[--o] == 0; ) c.pop();
  return e.d = c, e.e = Vb(c, n), Re ? pe(e, a, l) : e;
};
$t.precision = $t.sd = function(e) {
  var t, r = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(ju + e);
  return r.d ? (t = SF(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
};
$t.round = function() {
  var e = this, t = e.constructor;
  return pe(new t(e), e.e + 1, t.rounding);
};
$t.sine = $t.sin = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + be, n.rounding = 1, r = Iyt(n, IF(n, r)), n.precision = e, n.rounding = t, pe(qo > 2 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
$t.squareRoot = $t.sqrt = function() {
  var e, t, r, n, i, s, o = this, a = o.d, l = o.e, c = o.s, h = o.constructor;
  if (c !== 1 || !a || !a[0])
    return new h(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (Re = !1, c = Math.sqrt(+o), c == 0 || c == 1 / 0 ? (t = nn(a), (t.length + l) % 2 == 0 && (t += "0"), c = Math.sqrt(t), l = Pn((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? t = "1e" + l : (t = c.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + l), n = new h(t)) : n = new h(c.toString()), r = (l = h.precision) + 3; ; )
    if (s = n, n = s.plus(er(o, s, r + 2, 1)).times(0.5), nn(s.d).slice(0, r) === (t = nn(n.d)).slice(0, r))
      if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
        if (!i && (pe(s, l + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+t || !+t.slice(1) && t.charAt(0) == "5") && (pe(n, l + 1, 1), e = !n.times(n).eq(o));
        break;
      }
  return Re = !0, pe(n, l, h.rounding, e);
};
$t.tangent = $t.tan = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = er(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, pe(qo == 2 || qo == 4 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
$t.times = $t.mul = function(e) {
  var t, r, n, i, s, o, a, l, c, h = this, u = h.constructor, p = h.d, y = (e = new u(e)).d;
  if (e.s *= h.s, !p || !p[0] || !y || !y[0])
    return new u(!e.s || p && !p[0] && !y || y && !y[0] && !p ? NaN : !p || !y ? e.s / 0 : e.s * 0);
  for (r = Pn(h.e / be) + Pn(e.e / be), l = p.length, c = y.length, l < c && (s = p, p = y, y = s, o = l, l = c, c = o), s = [], o = l + c, n = o; n--; ) s.push(0);
  for (n = c; --n >= 0; ) {
    for (t = 0, i = l + n; i > n; )
      a = s[i] + y[n] * p[i - n - 1] + t, s[i--] = a % Cs | 0, t = a / Cs | 0;
    s[i] = (s[i] + t) % Cs | 0;
  }
  for (; !s[--o]; ) s.pop();
  return t ? ++r : s.shift(), e.d = s, e.e = Vb(s, r), Re ? pe(e, u.precision, u.rounding) : e;
};
$t.toBinary = function(e, t) {
  return VA(this, 2, e, t);
};
$t.toDecimalPlaces = $t.toDP = function(e, t) {
  var r = this, n = r.constructor;
  return r = new n(r), e === void 0 ? r : (Xn(e, 0, Lc), t === void 0 ? t = n.rounding : Xn(t, 0, 8), pe(r, e + r.e + 1, t));
};
$t.toExponential = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = Io(n, !0) : (Xn(e, 0, Lc), t === void 0 ? t = i.rounding : Xn(t, 0, 8), n = pe(new i(n), e + 1, t), r = Io(n, !0, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
$t.toFixed = function(e, t) {
  var r, n, i = this, s = i.constructor;
  return e === void 0 ? r = Io(i) : (Xn(e, 0, Lc), t === void 0 ? t = s.rounding : Xn(t, 0, 8), n = pe(new s(i), e + i.e + 1, t), r = Io(n, !1, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
$t.toFraction = function(e) {
  var t, r, n, i, s, o, a, l, c, h, u, p, y = this, g = y.d, b = y.constructor;
  if (!g) return new b(y);
  if (c = r = new b(1), n = l = new b(0), t = new b(n), s = t.e = SF(g) - y.e - 1, o = s % be, t.d[0] = gn(10, o < 0 ? be + o : o), e == null)
    e = s > 0 ? t : c;
  else {
    if (a = new b(e), !a.isInt() || a.lt(c)) throw Error(ju + a);
    e = a.gt(t) ? s > 0 ? t : c : a;
  }
  for (Re = !1, a = new b(nn(g)), h = b.precision, b.precision = s = g.length * be * 2; u = er(a, t, 0, 1, 1), i = r.plus(u.times(n)), i.cmp(e) != 1; )
    r = n, n = i, i = c, c = l.plus(u.times(i)), l = i, i = t, t = a.minus(u.times(i)), a = i;
  return i = er(e.minus(r), n, 0, 1, 1), l = l.plus(i.times(c)), r = r.plus(i.times(n)), l.s = c.s = y.s, p = er(c, n, s, 1).minus(y).abs().cmp(er(l, r, s, 1).minus(y).abs()) < 1 ? [c, n] : [l, r], b.precision = h, Re = !0, p;
};
$t.toHexadecimal = $t.toHex = function(e, t) {
  return VA(this, 16, e, t);
};
$t.toNearest = function(e, t) {
  var r = this, n = r.constructor;
  if (r = new n(r), e == null) {
    if (!r.d) return r;
    e = new n(1), t = n.rounding;
  } else {
    if (e = new n(e), t === void 0 ? t = n.rounding : Xn(t, 0, 8), !r.d) return e.s ? r : e;
    if (!e.d)
      return e.s && (e.s = r.s), e;
  }
  return e.d[0] ? (Re = !1, r = er(r, e, 0, t, 1).times(e), Re = !0, pe(r)) : (e.s = r.s, r = e), r;
};
$t.toNumber = function() {
  return +this;
};
$t.toOctal = function(e, t) {
  return VA(this, 8, e, t);
};
$t.toPower = $t.pow = function(e) {
  var t, r, n, i, s, o, a = this, l = a.constructor, c = +(e = new l(e));
  if (!a.d || !e.d || !a.d[0] || !e.d[0]) return new l(gn(+a, c));
  if (a = new l(a), a.eq(1)) return a;
  if (n = l.precision, s = l.rounding, e.eq(1)) return pe(a, n, s);
  if (t = Pn(e.e / be), t >= e.d.length - 1 && (r = c < 0 ? -c : c) <= Syt)
    return i = _F(l, a, r, n), e.s < 0 ? new l(1).div(i) : pe(i, n, s);
  if (o = a.s, o < 0) {
    if (t < e.d.length - 1) return new l(NaN);
    if (!(e.d[t] & 1) && (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = gn(+a, c), t = r == 0 || !isFinite(r) ? Pn(c * (Math.log("0." + nn(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, t > l.maxE + 1 || t < l.minE - 1 ? new l(t > 0 ? o / 0 : 0) : (Re = !1, l.rounding = a.s = 1, r = Math.min(12, (t + "").length), i = R4(e.times(fl(a, n + r)), n), i.d && (i = pe(i, n + 5, 1), p0(i.d, n, s) && (t = n + 10, i = pe(R4(e.times(fl(a, t + r)), t), t + 5, 1), +nn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = pe(i, n + 1, 0)))), i.s = o, Re = !0, l.rounding = s, pe(i, n, s));
};
$t.toPrecision = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = Io(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (Xn(e, 1, Lc), t === void 0 ? t = i.rounding : Xn(t, 0, 8), n = pe(new i(n), e, t), r = Io(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
$t.toSignificantDigits = $t.toSD = function(e, t) {
  var r = this, n = r.constructor;
  return e === void 0 ? (e = n.precision, t = n.rounding) : (Xn(e, 1, Lc), t === void 0 ? t = n.rounding : Xn(t, 0, 8)), pe(new n(r), e, t);
};
$t.toString = function() {
  var e = this, t = e.constructor, r = Io(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() && !e.isZero() ? "-" + r : r;
};
$t.truncated = $t.trunc = function() {
  return pe(new this.constructor(this), this.e + 1, 1);
};
$t.valueOf = $t.toJSON = function() {
  var e = this, t = e.constructor, r = Io(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() ? "-" + r : r;
};
function nn(e) {
  var t, r, n, i = e.length - 1, s = "", o = e[0];
  if (i > 0) {
    for (s += o, t = 1; t < i; t++)
      n = e[t] + "", r = be - n.length, r && (s += nl(r)), s += n;
    o = e[t], n = o + "", r = be - n.length, r && (s += nl(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function Xn(e, t, r) {
  if (e !== ~~e || e < t || e > r)
    throw Error(ju + e);
}
function p0(e, t, r, n) {
  var i, s, o, a;
  for (s = e[0]; s >= 10; s /= 10) --t;
  return --t < 0 ? (t += be, i = 0) : (i = Math.ceil((t + 1) / be), t %= be), s = gn(10, be - t), a = e[i] % s | 0, n == null ? t < 3 ? (t == 0 ? a = a / 100 | 0 : t == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 100 | 0) == gn(10, t - 2) - 1 || (a == s / 2 || a == 0) && (e[i + 1] / s / 100 | 0) == 0 : t < 4 ? (t == 0 ? a = a / 1e3 | 0 : t == 1 ? a = a / 100 | 0 : t == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 1e3 | 0) == gn(10, t - 3) - 1, o;
}
function W1(e, t, r) {
  for (var n, i = [0], s, o = 0, a = e.length; o < a; ) {
    for (s = i.length; s--; ) i[s] *= t;
    for (i[0] += C4.indexOf(e.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function kyt(e, t) {
  var r, n, i = t.d.length;
  i < 32 ? (r = Math.ceil(i / 3), n = Math.pow(4, -r).toString()) : (r = 16, n = "2.3283064365386962890625e-10"), e.precision += r, t = mp(e, 1, t.times(n), new e(1));
  for (var s = r; s--; ) {
    var o = t.times(t);
    t = o.times(o).minus(o).times(8).plus(1);
  }
  return e.precision -= r, t;
}
var er = /* @__PURE__ */ function() {
  function e(n, i, s) {
    var o, a = 0, l = n.length;
    for (n = n.slice(); l--; )
      o = n[l] * i + a, n[l] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function t(n, i, s, o) {
    var a, l;
    if (s != o)
      l = s > o ? 1 : -1;
    else
      for (a = l = 0; a < s; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, o, a, l) {
    var c, h, u, p, y, g, b, f, E, A, x, m, w, _, S, R, O, $, z, F, Y = n.constructor, rt = n.s == i.s ? 1 : -1, at = n.d, pt = i.d;
    if (!at || !at[0] || !pt || !pt[0])
      return new Y(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (at ? pt && at[0] == pt[0] : !pt) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          at && at[0] == 0 || !pt ? rt * 0 : rt / 0
        )
      );
    for (l ? (y = 1, h = n.e - i.e) : (l = Cs, y = be, h = Pn(n.e / y) - Pn(i.e / y)), z = pt.length, O = at.length, E = new Y(rt), A = E.d = [], u = 0; pt[u] == (at[u] || 0); u++) ;
    if (pt[u] > (at[u] || 0) && h--, s == null ? (_ = s = Y.precision, o = Y.rounding) : a ? _ = s + (n.e - i.e) + 1 : _ = s, _ < 0)
      A.push(1), g = !0;
    else {
      if (_ = _ / y + 2 | 0, u = 0, z == 1) {
        for (p = 0, pt = pt[0], _++; (u < O || p) && _--; u++)
          S = p * l + (at[u] || 0), A[u] = S / pt | 0, p = S % pt | 0;
        g = p || u < O;
      } else {
        for (p = l / (pt[0] + 1) | 0, p > 1 && (pt = e(pt, p, l), at = e(at, p, l), z = pt.length, O = at.length), R = z, x = at.slice(0, z), m = x.length; m < z; ) x[m++] = 0;
        F = pt.slice(), F.unshift(0), $ = pt[0], pt[1] >= l / 2 && ++$;
        do
          p = 0, c = t(pt, x, z, m), c < 0 ? (w = x[0], z != m && (w = w * l + (x[1] || 0)), p = w / $ | 0, p > 1 ? (p >= l && (p = l - 1), b = e(pt, p, l), f = b.length, m = x.length, c = t(b, x, f, m), c == 1 && (p--, r(b, z < f ? F : pt, f, l))) : (p == 0 && (c = p = 1), b = pt.slice()), f = b.length, f < m && b.unshift(0), r(x, b, m, l), c == -1 && (m = x.length, c = t(pt, x, z, m), c < 1 && (p++, r(x, z < m ? F : pt, m, l))), m = x.length) : c === 0 && (p++, x = [0]), A[u++] = p, c && x[0] ? x[m++] = at[R] || 0 : (x = [at[R]], m = 1);
        while ((R++ < O || x[0] !== void 0) && _--);
        g = x[0] !== void 0;
      }
      A[0] || A.shift();
    }
    if (y == 1)
      E.e = h, xF = g;
    else {
      for (u = 1, p = A[0]; p >= 10; p /= 10) u++;
      E.e = u + h * y - 1, pe(E, a ? s + E.e + 1 : s, o, g);
    }
    return E;
  };
}();
function pe(e, t, r, n) {
  var i, s, o, a, l, c, h, u, p, y = e.constructor;
  t: if (t != null) {
    if (u = e.d, !u) return e;
    for (i = 1, a = u[0]; a >= 10; a /= 10) i++;
    if (s = t - i, s < 0)
      s += be, o = t, h = u[p = 0], l = h / gn(10, i - o - 1) % 10 | 0;
    else if (p = Math.ceil((s + 1) / be), a = u.length, p >= a)
      if (n) {
        for (; a++ <= p; ) u.push(0);
        h = l = 0, i = 1, s %= be, o = s - be + 1;
      } else
        break t;
    else {
      for (h = a = u[p], i = 1; a >= 10; a /= 10) i++;
      s %= be, o = s - be + i, l = o < 0 ? 0 : h / gn(10, i - o - 1) % 10 | 0;
    }
    if (n = n || t < 0 || u[p + 1] !== void 0 || (o < 0 ? h : h % gn(10, i - o - 1)), c = r < 4 ? (l || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? h / gn(10, i - o) : 0 : u[p - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !u[0])
      return u.length = 0, c ? (t -= e.e + 1, u[0] = gn(10, (be - t % be) % be), e.e = -t || 0) : u[0] = e.e = 0, e;
    if (s == 0 ? (u.length = p, a = 1, p--) : (u.length = p + 1, a = gn(10, be - s), u[p] = o > 0 ? (h / gn(10, i - o) % gn(10, o) | 0) * a : 0), c)
      for (; ; )
        if (p == 0) {
          for (s = 1, o = u[0]; o >= 10; o /= 10) s++;
          for (o = u[0] += a, a = 1; o >= 10; o /= 10) a++;
          s != a && (e.e++, u[0] == Cs && (u[0] = 1));
          break;
        } else {
          if (u[p] += a, u[p] != Cs) break;
          u[p--] = 0, a = 1;
        }
    for (s = u.length; u[--s] === 0; ) u.pop();
  }
  return Re && (e.e > y.maxE ? (e.d = null, e.e = NaN) : e.e < y.minE && (e.e = 0, e.d = [0])), e;
}
function Io(e, t, r) {
  if (!e.isFinite()) return CF(e);
  var n, i = e.e, s = nn(e.d), o = s.length;
  return t ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + nl(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (s = "0." + nl(-i - 1) + s, r && (n = r - o) > 0 && (s += nl(n))) : i >= o ? (s += nl(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + nl(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += nl(n))), s;
}
function Vb(e, t) {
  var r = e[0];
  for (t *= be; r >= 10; r /= 10) t++;
  return t;
}
function by(e, t, r) {
  if (t > _yt)
    throw Re = !0, r && (e.precision = r), Error(EF);
  return pe(new e(my), t, 1, !0);
}
function ys(e, t, r) {
  if (t > P4) throw Error(EF);
  return pe(new e(yy), t, r, !0);
}
function SF(e) {
  var t = e.length - 1, r = t * be + 1;
  if (t = e[t], t) {
    for (; t % 10 == 0; t /= 10) r--;
    for (t = e[0]; t >= 10; t /= 10) r++;
  }
  return r;
}
function nl(e) {
  for (var t = ""; e--; ) t += "0";
  return t;
}
function _F(e, t, r, n) {
  var i, s = new e(1), o = Math.ceil(n / be + 4);
  for (Re = !1; ; ) {
    if (r % 2 && (s = s.times(t), XC(s.d, o) && (i = !0)), r = Pn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    t = t.times(t), XC(t.d, o);
  }
  return Re = !0, s;
}
function ZC(e) {
  return e.d[e.d.length - 1] & 1;
}
function kF(e, t, r) {
  for (var n, i = new e(t[0]), s = 0; ++s < t.length; )
    if (n = new e(t[s]), n.s)
      i[r](n) && (i = n);
    else {
      i = n;
      break;
    }
  return i;
}
function R4(e, t) {
  var r, n, i, s, o, a, l, c = 0, h = 0, u = 0, p = e.constructor, y = p.rounding, g = p.precision;
  if (!e.d || !e.d[0] || e.e > 17)
    return new p(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
  for (t == null ? (Re = !1, l = g) : l = t, a = new p(0.03125); e.e > -2; )
    e = e.times(a), u += 5;
  for (n = Math.log(gn(2, u)) / Math.LN10 * 2 + 5 | 0, l += n, r = s = o = new p(1), p.precision = l; ; ) {
    if (s = pe(s.times(e), l, 1), r = r.times(++h), a = o.plus(er(s, r, l, 1)), nn(a.d).slice(0, l) === nn(o.d).slice(0, l)) {
      for (i = u; i--; ) o = pe(o.times(o), l, 1);
      if (t == null)
        if (c < 3 && p0(o.d, l - n, y, c))
          p.precision = l += 10, r = s = a = new p(1), h = 0, c++;
        else
          return pe(o, p.precision = g, y, Re = !0);
      else
        return p.precision = g, o;
    }
    o = a;
  }
}
function fl(e, t) {
  var r, n, i, s, o, a, l, c, h, u, p, y = 1, g = 10, b = e, f = b.d, E = b.constructor, A = E.rounding, x = E.precision;
  if (b.s < 0 || !f || !f[0] || !b.e && f[0] == 1 && f.length == 1)
    return new E(f && !f[0] ? -1 / 0 : b.s != 1 ? NaN : f ? 0 : b);
  if (t == null ? (Re = !1, h = x) : h = t, E.precision = h += g, r = nn(f), n = r.charAt(0), Math.abs(s = b.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      b = b.times(e), r = nn(b.d), n = r.charAt(0), y++;
    s = b.e, n > 1 ? (b = new E("0." + r), s++) : b = new E(n + "." + r.slice(1));
  } else
    return c = by(E, h + 2, x).times(s + ""), b = fl(new E(n + "." + r.slice(1)), h - g).plus(c), E.precision = x, t == null ? pe(b, x, A, Re = !0) : b;
  for (u = b, l = o = b = er(b.minus(1), b.plus(1), h, 1), p = pe(b.times(b), h, 1), i = 3; ; ) {
    if (o = pe(o.times(p), h, 1), c = l.plus(er(o, new E(i), h, 1)), nn(c.d).slice(0, h) === nn(l.d).slice(0, h))
      if (l = l.times(2), s !== 0 && (l = l.plus(by(E, h + 2, x).times(s + ""))), l = er(l, new E(y), h, 1), t == null)
        if (p0(l.d, h - g, A, a))
          E.precision = h += g, c = o = b = er(u.minus(1), u.plus(1), h, 1), p = pe(b.times(b), h, 1), i = a = 1;
        else
          return pe(l, E.precision = x, A, Re = !0);
      else
        return E.precision = x, l;
    l = c, i += 2;
  }
}
function CF(e) {
  return String(e.s * e.s / 0);
}
function JC(e, t) {
  var r, n, i;
  for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0; t.charCodeAt(n) === 48; n++) ;
  for (i = t.length; t.charCodeAt(i - 1) === 48; --i) ;
  if (t = t.slice(n, i), t) {
    if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % be, r < 0 && (n += be), n < i) {
      for (n && e.d.push(+t.slice(0, n)), i -= be; n < i; ) e.d.push(+t.slice(n, n += be));
      t = t.slice(n), n = be - t.length;
    } else
      n -= i;
    for (; n--; ) t += "0";
    e.d.push(+t), Re && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
  } else
    e.e = 0, e.d = [0];
  return e;
}
function Cyt(e, t) {
  var r, n, i, s, o, a, l, c, h;
  if (t === "Infinity" || t === "NaN")
    return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
  if (xyt.test(t))
    r = 16, t = t.toLowerCase();
  else if (wyt.test(t))
    r = 2;
  else if (Eyt.test(t))
    r = 8;
  else
    throw Error(ju + t);
  for (s = t.search(/p/i), s > 0 ? (l = +t.slice(s + 1), t = t.substring(2, s)) : t = t.slice(2), s = t.indexOf("."), o = s >= 0, n = e.constructor, o && (t = t.replace(".", ""), a = t.length, s = a - s, i = _F(n, new n(r), s, s * 2)), c = W1(t, r, Cs), h = c.length - 1, s = h; c[s] === 0; --s) c.pop();
  return s < 0 ? new n(e.s * 0) : (e.e = Vb(c, h), e.d = c, Re = !1, o && (e = er(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? Math.pow(2, l) : Ub.pow(2, l))), Re = !0, e);
}
function Iyt(e, t) {
  var r, n = t.d.length;
  if (n < 3) return mp(e, 2, t, t);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(Math.pow(5, -r)), t = mp(e, 2, t, t);
  for (var i, s = new e(5), o = new e(16), a = new e(20); r--; )
    i = t.times(t), t = t.times(s.plus(i.times(o.times(i).minus(a))));
  return t;
}
function mp(e, t, r, n, i) {
  var s, o, a, l, c = e.precision, h = Math.ceil(c / be);
  for (Re = !1, l = r.times(r), a = new e(n); ; ) {
    if (o = er(a.times(l), new e(t++ * t++), c, 1), a = i ? n.plus(o) : n.minus(o), n = er(o.times(l), new e(t++ * t++), c, 1), o = a.plus(n), o.d[h] !== void 0) {
      for (s = h; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = n, n = o, o = s;
  }
  return Re = !0, o.d.length = h + 1, o;
}
function IF(e, t) {
  var r, n = t.s < 0, i = ys(e, e.precision, 1), s = i.times(0.5);
  if (t = t.abs(), t.lte(s))
    return qo = n ? 4 : 1, t;
  if (r = t.divToInt(i), r.isZero())
    qo = n ? 3 : 2;
  else {
    if (t = t.minus(r.times(i)), t.lte(s))
      return qo = ZC(r) ? n ? 2 : 3 : n ? 4 : 1, t;
    qo = ZC(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return t.minus(i).abs();
}
function VA(e, t, r, n) {
  var i, s, o, a, l, c, h, u, p, y = e.constructor, g = r !== void 0;
  if (g ? (Xn(r, 1, Lc), n === void 0 ? n = y.rounding : Xn(n, 0, 8)) : (r = y.precision, n = y.rounding), !e.isFinite())
    h = CF(e);
  else {
    for (h = Io(e), o = h.indexOf("."), g ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, o >= 0 && (h = h.replace(".", ""), p = new y(1), p.e = h.length - o, p.d = W1(Io(p), 10, i), p.e = p.d.length), u = W1(h, 10, i), s = l = u.length; u[--l] == 0; ) u.pop();
    if (!u[0])
      h = g ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (e = new y(e), e.d = u, e.e = s, e = er(e, p, r, n, 0, i), u = e.d, s = e.e, c = xF), o = u[r], a = i / 2, c = c || u[r + 1] !== void 0, c = n < 4 ? (o !== void 0 || c) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || c || n === 6 && u[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), u.length = r, c)
        for (; ++u[--r] > i - 1; )
          u[r] = 0, r || (++s, u.unshift(1));
      for (l = u.length; !u[l - 1]; --l) ;
      for (o = 0, h = ""; o < l; o++) h += C4.charAt(u[o]);
      if (g) {
        if (l > 1)
          if (t == 16 || t == 8) {
            for (o = t == 16 ? 4 : 3, --l; l % o; l++) h += "0";
            for (u = W1(h, i, t), l = u.length; !u[l - 1]; --l) ;
            for (o = 1, h = "1."; o < l; o++) h += C4.charAt(u[o]);
          } else
            h = h.charAt(0) + "." + h.slice(1);
        h = h + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) h = "0" + h;
        h = "0." + h;
      } else if (++s > l) for (s -= l; s--; ) h += "0";
      else s < l && (h = h.slice(0, s) + "." + h.slice(s));
    }
    h = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + h;
  }
  return e.s < 0 ? "-" + h : h;
}
function XC(e, t) {
  if (e.length > t)
    return e.length = t, !0;
}
function Pyt(e) {
  return new this(e).abs();
}
function Ryt(e) {
  return new this(e).acos();
}
function Tyt(e) {
  return new this(e).acosh();
}
function Oyt(e, t) {
  return new this(e).plus(t);
}
function Lyt(e) {
  return new this(e).asin();
}
function Myt(e) {
  return new this(e).asinh();
}
function Nyt(e) {
  return new this(e).atan();
}
function Dyt(e) {
  return new this(e).atanh();
}
function Byt(e, t) {
  e = new this(e), t = new this(t);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !e.s || !t.s ? r = new this(NaN) : !e.d && !t.d ? (r = ys(this, s, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t.d || e.isZero() ? (r = t.s < 0 ? ys(this, n, i) : new this(0), r.s = e.s) : !e.d || t.isZero() ? (r = ys(this, s, 1).times(0.5), r.s = e.s) : t.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(er(e, t, s, 1)), t = ys(this, s, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(er(e, t, s, 1)), r;
}
function jyt(e) {
  return new this(e).cbrt();
}
function Fyt(e) {
  return pe(e = new this(e), e.e + 1, 2);
}
function $yt(e) {
  if (!e || typeof e != "object") throw Error(zb + "Object expected");
  var t, r, n, i = e.defaults === !0, s = [
    "precision",
    1,
    Lc,
    "rounding",
    0,
    8,
    "toExpNeg",
    -9e15,
    0,
    "toExpPos",
    0,
    k4,
    "maxE",
    0,
    k4,
    "minE",
    -9e15,
    0,
    "modulo",
    0,
    9
  ];
  for (t = 0; t < s.length; t += 3)
    if (r = s[t], i && (this[r] = I4[r]), (n = e[r]) !== void 0)
      if (Pn(n) === n && n >= s[t + 1] && n <= s[t + 2]) this[r] = n;
      else throw Error(ju + r + ": " + n);
  if (r = "crypto", i && (this[r] = I4[r]), (n = e[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(AF);
      else
        this[r] = !1;
    else
      throw Error(ju + r + ": " + n);
  return this;
}
function zyt(e) {
  return new this(e).cos();
}
function Vyt(e) {
  return new this(e).cosh();
}
function PF(e) {
  var t, r, n;
  function i(s) {
    var o, a, l, c = this;
    if (!(c instanceof i)) return new i(s);
    if (c.constructor = i, s instanceof i) {
      c.s = s.s, c.e = s.e, c.d = (s = s.d) ? s.slice() : s;
      return;
    }
    if (l = typeof s, l === "number") {
      if (s === 0) {
        c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        c.e = o, c.d = [s];
        return;
      } else if (s * 0 !== 0) {
        s || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return JC(c, s.toString());
    } else if (l !== "string")
      throw Error(ju + s);
    return s.charCodeAt(0) === 45 ? (s = s.slice(1), c.s = -1) : c.s = 1, Ayt.test(s) ? JC(c, s) : Cyt(c, s);
  }
  if (i.prototype = $t, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = $yt, i.clone = PF, i.isDecimal = Wyt, i.abs = Pyt, i.acos = Ryt, i.acosh = Tyt, i.add = Oyt, i.asin = Lyt, i.asinh = Myt, i.atan = Nyt, i.atanh = Dyt, i.atan2 = Byt, i.cbrt = jyt, i.ceil = Fyt, i.cos = zyt, i.cosh = Vyt, i.div = Uyt, i.exp = Hyt, i.floor = Gyt, i.hypot = Qyt, i.ln = qyt, i.log = Yyt, i.log10 = Zyt, i.log2 = Kyt, i.max = Jyt, i.min = Xyt, i.mod = t2t, i.mul = e2t, i.pow = r2t, i.random = n2t, i.round = i2t, i.sign = s2t, i.sin = o2t, i.sinh = a2t, i.sqrt = l2t, i.sub = c2t, i.tan = u2t, i.tanh = h2t, i.trunc = p2t, e === void 0 && (e = {}), e && e.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0; t < n.length; ) e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
  return i.config(e), i;
}
function Uyt(e, t) {
  return new this(e).div(t);
}
function Hyt(e) {
  return new this(e).exp();
}
function Gyt(e) {
  return pe(e = new this(e), e.e + 1, 3);
}
function Qyt() {
  var e, t, r = new this(0);
  for (Re = !1, e = 0; e < arguments.length; )
    if (t = new this(arguments[e++]), t.d)
      r.d && (r = r.plus(t.times(t)));
    else {
      if (t.s)
        return Re = !0, new this(1 / 0);
      r = t;
    }
  return Re = !0, r.sqrt();
}
function Wyt(e) {
  return e instanceof Ub || e && e.name === "[object Decimal]" || !1;
}
function qyt(e) {
  return new this(e).ln();
}
function Yyt(e, t) {
  return new this(e).log(t);
}
function Kyt(e) {
  return new this(e).log(2);
}
function Zyt(e) {
  return new this(e).log(10);
}
function Jyt() {
  return kF(this, arguments, "lt");
}
function Xyt() {
  return kF(this, arguments, "gt");
}
function t2t(e, t) {
  return new this(e).mod(t);
}
function e2t(e, t) {
  return new this(e).mul(t);
}
function r2t(e, t) {
  return new this(e).pow(t);
}
function n2t(e) {
  var t, r, n, i, s = 0, o = new this(1), a = [];
  if (e === void 0 ? e = this.precision : Xn(e, 1, Lc), n = Math.ceil(e / be), this.crypto)
    if (crypto.getRandomValues)
      for (t = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = t[s], i >= 429e7 ? t[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (t = crypto.randomBytes(n *= 4); s < n; )
        i = t[s] + (t[s + 1] << 8) + (t[s + 2] << 16) + ((t[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(t, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(AF);
  else for (; s < n; ) a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], e %= be, n && e && (i = gn(10, be - e), a[s] = (n / i | 0) * i); a[s] === 0; s--) a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= be) a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
    n < be && (r -= be - n);
  }
  return o.e = r, o.d = a, o;
}
function i2t(e) {
  return pe(e = new this(e), e.e + 1, this.rounding);
}
function s2t(e) {
  return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
}
function o2t(e) {
  return new this(e).sin();
}
function a2t(e) {
  return new this(e).sinh();
}
function l2t(e) {
  return new this(e).sqrt();
}
function c2t(e, t) {
  return new this(e).sub(t);
}
function u2t(e) {
  return new this(e).tan();
}
function h2t(e) {
  return new this(e).tanh();
}
function p2t(e) {
  return pe(e = new this(e), e.e + 1, 1);
}
var Ub = PF(I4);
my = new Ub(my);
yy = new Ub(yy);
var T4 = /* @__PURE__ */ ((e) => (e[e.UP = 1] = "UP", e[e.NONE = 0] = "NONE", e[e.DOWN = -1] = "DOWN", e))(T4 || {});
const O4 = {
  dollar: V1.DOLLAR,
  "U.S. dollar": V1.US_DOLLAR,
  "South Korean won": V1.SK_WON
}, vy = {
  year: { ...yt.noun("year"), subtype: "unit" },
  quarter: { ...yt.noun("quarter"), subtype: "unit" }
}, L4 = {
  "0.01": { type: "simple-category", subtype: "scale", noun: yt.en("percent") },
  1: { type: "simple-category", subtype: "scale", noun: yt.en("number") },
  1e3: { type: "simple-category", subtype: "scale", noun: yt.en("thousand") },
  1e6: { type: "simple-category", subtype: "scale", noun: yt.en("million") },
  1e9: { type: "simple-category", subtype: "scale", noun: yt.en("billion") },
  1e12: { type: "simple-category", subtype: "scale", noun: yt.en("trillion") }
};
function Yo(e, t) {
  if (t in vy)
    return {
      type: "plain-date-time",
      datetime: e,
      unit: t
    };
  if (t === "point")
    return yt.quantValue(e, dl[1], yt.unit("point"));
  throw new Error(`Undefined X unit ${t}`);
}
class Hb {
  constructor(t, r, n, i) {
    this.start = t, this.end = r, this.unit = n, this.approx = i;
  }
  path() {
    return this.approx ? {
      type: "point-location",
      direction: Pt.BETWEEN,
      point: yt.and(Yo(this.start, this.unit), Yo(this.end, this.unit))
    } : yt.path(
      Yo(this.start, this.unit),
      Yo(this.end, this.unit)
    );
  }
}
function UA(e, t) {
  return e instanceof Hb ? e.path() : yt.in_(Yo(e, t));
}
function d2t(e, t, r) {
  const n = e.indepBox.value, i = t.indepBox.value;
  return n.equals(i.subtract(r));
}
function f2t(e, t, r) {
  return yX(
    e,
    (n, i) => d2t(n, i, t)
  ).map((n) => {
    if (n instanceof P3) {
      if (n.points.length < 2)
        throw new $r("Internal: Ranges must have 2 or more points.");
      return new RF(n.points, r);
    }
    return n;
  });
}
class RF {
  constructor(t, r, n) {
    Be(this, "start"), Be(this, "end"), Be(this, "startTime"), Be(this, "endTime"), this.points = t, this.unit = r, this.approx = n, this.start = this.points[0], this.end = this.points.at(-1), this.startTime = this.start.indepBox.value, this.endTime = this.end.indepBox.value;
  }
  path() {
    return this.toTimeRange().path();
  }
  toTimeRange() {
    return new Hb(this.startTime, this.endTime, this.unit, this.approx);
  }
  getNavcode() {
    return this.points.reduce((t, r) => t + `-${r.datapointIndex}`, `datapoint-${this.start.seriesKey}`);
  }
}
class g2t {
  constructor(t, r, n, i, s, o) {
    this.startPoint = t, this.endPoint = r, this.timeUnit = n, this.startValue = i, this.endValue = s, this.depUnits = o;
  }
  path() {
    const t = this.startPoint.indepBox.value, r = this.endPoint.indepBox.value, n = Ge(
      wy(t, this.timeUnit, this.startValue, this.depUnits),
      this.startPoint.getNavcode()
    ), i = Ge(
      wy(r, this.timeUnit, this.endValue, this.depUnits),
      this.endPoint.getNavcode()
    );
    return {
      type: "path-location",
      start: n,
      end: i,
      startTag: n0(this.startPoint.getNavcode()),
      endTag: n0(this.endPoint.getNavcode())
    };
  }
}
function TF(e, t) {
  let r = null, n = null;
  if (t !== "number") {
    if (t !== void 0 && t in O4)
      n = O4[t];
    else if (t !== void 0 && t in vy)
      r = vy[t];
    else if (t === "point")
      r = Pt.POINT;
    else if (t !== void 0) throw new Error(`[ParaSummary]: Undefined dependent unit ${t}`);
  }
  let i = yt.numberEntity(
    e.number,
    L4[e.scale]
  );
  return e.roundingDirection === T4.UP && (i.quantifier = Pt.ALMOST), e.roundingDirection === T4.DOWN && (i.quantifier = Pt.MORE_THAN), n !== null ? i = {
    ...i,
    type: "simple-entity",
    subtype: "money-value",
    detType: "bare",
    category: n
  } : r !== null && (i = {
    ...i,
    type: "simple-entity",
    subtype: "quant-value",
    detType: "indefinite",
    category: r
  }), i;
}
function wy(e, t, r, n) {
  const i = UA(e, t), s = TF(r, n);
  return s.mods = [i], s;
}
function OF(e, t) {
  return e.record.labelValue === null ? new Hb(
    uf(e.record.beforeValue),
    uf(e.record.afterValue),
    t,
    !0
  ) : uf(e.record.labelValue);
}
function m2t(e, t) {
  return UA(OF(e, t), t);
}
function y2t(e, t, r, n) {
  return yt.at(wy(
    OF(e, t),
    t,
    r,
    n.units
  ));
}
function Gi(e, t) {
  const r = e.messageSeqs[t].start, n = e.messageSeqs[t].end;
  return `sequence-${e.seriesKey}-${r}-${n}`;
}
const Xd = Pt.FALL, u1 = Pt.RISE, h1 = { ...Pt.PERIOD, mods: [Pt.STABLE] };
function b2t(e) {
  return e === "Rise" || e === "Fall" || e === "Stable";
}
function v2t(e) {
  return e === "BigJump" || e === "BigFall";
}
function w2t(e) {
  return e === "ReversalToRise" || e === "ReversalToFall";
}
function x2t(e) {
  return e === "PossibleReversalToRise" || e === "PossibleReversalToFall";
}
function E2t(e) {
  return e === "EmergingRise" || e === "EmergingFall";
}
function A2t(e) {
  return e === "PossibleEmergingRise" || e === "PossibleEmergingFall";
}
function S2t(e) {
  return e === "RiseToStable" || e === "FallToStable";
}
function _2t(e) {
  return e === "PossibleRiseToStable" || e === "PossibleFallToStable";
}
function k2t(e) {
  return w2t(e) || E2t(e) || S2t(e);
}
function C2t(e) {
  return x2t(e) || A2t(e) || _2t(e);
}
function I2t(e) {
  return e === "Rebound" || e === "TemporaryJump";
}
function P2t(e) {
  return e === "PossibleRebound" || e === "PossibleTemporaryJump";
}
const R2t = {
  Rise: { ...Pt.RISE, force: "participle" },
  Fall: { ...Pt.FALL, force: "participle" },
  Stable: Pt.STABLE
};
function T2t(e, t, r) {
  const n = { ...Pt.TREND, mods: [Pt.OVERALL, R2t[e]] };
  let i = yt.a("singular", n);
  return r && (i = Ge(i, Gi(t, 0))), i;
}
const O2t = {
  BigJump: Pt.JUMP,
  BigFall: Xd
};
function L2t(e, t, r) {
  const n = {
    ...O2t[e],
    mods: [Pt.LARGE]
  };
  let i = yt.a("singular", n);
  return r && (i = Ge(i, Gi(t, 0))), i;
}
const M2t = {
  ReversalToRise: [Xd, u1],
  ReversalToFall: [u1, Xd],
  EmergingRise: [h1, u1],
  EmergingFall: [h1, Xd],
  RiseToStable: [u1, h1],
  FallToStable: [Xd, h1]
};
function tI(e, t, r, n) {
  const [i, s] = M2t[e], o = [yt.by(yt.a("singular", s))];
  n && o.unshift(Pt.POSSIBLY);
  let a = {
    type: "relative-clause",
    relativizer: "zero",
    clause: {
      type: "simple-clause",
      pred: null,
      object: { ...Pt.FOLLOWED, mods: o }
    },
    restrictive: !1
  }, l = Pt.HAS, c = yt.a("singular", i);
  return r && (a = Ge(a, Gi(t, 1)), l = Ge(l, Gi(t, 0)), c = Ge(c, Gi(t, 0))), {
    type: "simple-clause",
    pred: l,
    object: c,
    mods: [a]
  };
}
const tf = {
  Rebound: {
    first: { ...Pt.RISE, force: "participle" },
    second: {
      type: "simple-clause",
      pred: { ...Pt.FALL_pred, tense: "present-participle" },
      object: null
    },
    third: {
      type: "simple-clause",
      pred: { ...Pt.REBOUND, tense: "present-participle" },
      object: null,
      mods: [Pt.BACK_UP]
    }
  },
  TemporaryJump: {
    first: { ...Pt.FALL, force: "participle" },
    second: {
      type: "simple-clause",
      pred: { ...Pt.RISE_pred, tense: "present-participle" },
      object: null,
      mods: [Pt.TEMPORARILY]
    },
    third: {
      type: "simple-clause",
      pred: { ...Pt.FALL_pred, tense: "present-participle" },
      object: null,
      mods: [Pt.AGAIN]
    }
  }
}, N2t = {
  Rebound: {
    ...tf.Rebound,
    third: {
      ...tf.Rebound.third,
      mods: [Pt.POSSIBLY, Pt.BACK_UP]
    }
  },
  TemporaryJump: {
    ...tf.TemporaryJump,
    third: {
      ...tf.TemporaryJump.third,
      mods: [Pt.POSSIBLY, Pt.AGAIN]
    }
  }
};
function eI(e, t, r, n) {
  const i = n ? N2t[e] : tf[e];
  let s = {
    type: "simple-clause",
    pred: Pt.HAS,
    object: yt.a("singular", { ...Pt.TREND, mods: [i.first] })
  };
  r && (s = Ge(s, Gi(t, 0)));
  const o = r ? Ge(Pt.BEFORE, Gi(t, 1)) : Pt.BEFORE, a = r ? Ge(i.second, Gi(t, 1)) : i.second, l = {
    ...yt.coord(o, s, a),
    firstComma: !0
  }, c = r ? Ge(Pt.AND_THEN, Gi(t, 2)) : Pt.AND_THEN, h = r ? Ge(i.third, Gi(t, 2)) : i.third;
  return yt.coord(c, l, h);
}
function rI(e, t = !0) {
  const r = e.message;
  if (I2t(r))
    return eI(r, e, t);
  if (P2t(r))
    return eI(r.substring(8), e, t, !0);
  if (k2t(r))
    return tI(r, e, t);
  if (C2t(r))
    return tI(r.substring(8), e, t, !0);
  let n;
  return b2t(r) ? n = T2t(r, e, t) : v2t(r) && (n = L2t(r, e, t)), {
    type: "simple-clause",
    pred: t ? Ge(Pt.HAS, Gi(e, 0)) : Pt.HAS,
    object: n
  };
}
const LF = ["entity", "items", "locale"], D2t = {
  entity: "genus",
  items: "genus",
  locale: "genus"
};
function Ww(e, t) {
  const r = new Set(
    e.series.map((n) => e.getSeriesTheme(n.key)[t]).filter((n) => n !== void 0)
  );
  return r.size === 1 ? "genus" : r.size === e.numSeries ? "differentia" : "neither";
}
function MF(e) {
  const t = {
    entity: Ww(e, "entity"),
    items: Ww(e, "items"),
    locale: Ww(e, "locale")
  };
  for (const r in t) {
    const n = e.getChartTheme();
    n && r in n && t[r] === "neither" && (t[r] = "genus");
  }
  return t;
}
function Ng(e) {
  return Array.isArray(e) ? yt.and(...e.map(yt.noun)) : yt.noun(e);
}
function B2t(e, t, r) {
  if (e[t] === void 0 || r === "neither")
    return null;
  const n = r === "differentia", i = {
    type: "simple-entity",
    detType: {
      entity: n ? "indefinite" : "proper",
      items: "indefinite",
      locale: n ? "indefinite" : "proper"
    }[t],
    number: n || t === "items" ? "plural" : "singular",
    category: Ng(e[t])
  };
  return n && (i.mods = [Pt.DIFFERENT]), i;
}
function j2t(e, t, r) {
  if (r !== "differentia")
    return null;
  const n = e.series.map((s) => {
    const o = e.getSeriesTheme(s.key)[t];
    return Ge(
      Ng(o),
      `series-${s.key}`
    );
  });
  let i;
  return Array.isArray(n) ? (i = yt.and(...n), i.conn = Ge(i.conn, `series-${e.series.at(-1).key}`)) : i = n, {
    type: "simple-entity",
    detType: "bare",
    number: t === "items" ? "plural" : "singular",
    category: i
  };
}
function F2t(e, t, r) {
  let n = D2t;
  r && (n = MF(r));
  const i = LF.flatMap((s) => {
    const o = B2t(t, s, n[s]);
    return o === null ? [] : [s === "locale" ? { ...yt.in_(o), inessential: !0 } : yt.of(o)];
  });
  e.mods.push(...i);
}
function $2t(e, t) {
  var r;
  const n = MF(t), i = LF.flatMap((o) => {
    const a = j2t(t, o, n[o]);
    if (a === null)
      return [];
    const l = [];
    if (o === "locale") {
      const c = yt.in_(a);
      c.direction = Ge(c.direction, `series-${t[0].key}`), l.push(c);
    } else {
      const c = yt.of(a);
      c.auxTag = n0(`series-${t[0].key}`), l.push(c);
    }
    return l;
  });
  e.mods.push(...i);
  const s = (r = t.getChartTheme()) == null ? void 0 : r.aggregate;
  if (s) {
    const o = Array.isArray(s) ? s : [s];
    e.mods.push(...o.map((a) => yt.adj(a)));
  }
}
function z2t(e, t) {
  return {
    type: "simple-entity",
    detType: "definite",
    number: t ? "plural" : "singular",
    category: Ng(e.baseQuantity),
    mods: []
  };
}
function V2t(e, t) {
  const r = Ng(e.baseQuantity);
  return {
    type: "simple-entity",
    detType: "definite",
    number: t || Array.isArray(e.baseQuantity) ? "plural" : "singular",
    category: Pt.RATE,
    mods: [r]
  };
}
function U2t(e, t) {
  return {
    type: "simple-entity",
    detType: "definite",
    number: t || Array.isArray(e.baseQuantity) ? "plural" : "singular",
    category: dl[1]
  };
}
function H2t(e, t) {
  let r;
  return Array.isArray(e.baseQuantity) ? r = yt.and(...e.baseQuantity.map((n) => yt.a("plural", yt.noun(n)))) : r = yt.a("plural", yt.noun(e.baseQuantity)), { ...U2t(e, t), mods: [yt.of(r)] };
}
function G2t(e, t) {
  const r = Ng(e.baseQuantity);
  return {
    type: "simple-entity",
    detType: "definite",
    number: "singular",
    category: Pt.DISTRIBUTION,
    mods: [yt.of(yt.the("singular", r))]
  };
}
function HA(e, t) {
  switch (e.baseKind) {
    case "dimensioned":
      return z2t(e, t);
    case "rate":
      return V2t(e, t);
    case "number":
      return H2t(e, t);
    case "proportion":
      return G2t(e);
  }
}
function Q2t(e) {
  return e.baseKind === "proportion" ? {
    type: "simple-entity",
    detType: "definite",
    //'bare',
    number: "singular",
    category: Pt.DISTRIBUTION
    //D.PERCENTAGE
  } : {
    ...HA(e, !1)
    /*detType: 'bare'*/
  };
}
function GA(e, t) {
  const r = HA(e, t !== void 0);
  if (F2t(r, e, t), e.aggregate !== void 0) {
    const n = Array.isArray(e.aggregate) ? e.aggregate : [e.aggregate];
    r.mods.push(...n.map((i) => yt.adj(i)));
  }
  return r;
}
function M4(e) {
  return GA(e.getChartTheme(), e);
}
function NF(e) {
  return GA(e);
}
function DF(e, t, r) {
  const n = GA(e, t);
  return n.mods.push({ type: "quote", text: r }), n;
}
const BF = yt.over({
  type: "simple-entity",
  detType: "bare",
  number: "singular",
  category: Pt.TIME
}), qw = { ...Pt.HIGH, comparative: "superlative" }, jF = {
  type: "point-location",
  direction: yt.dir("across"),
  point: yt.the("singular", Pt.CHART, [yt.adj("whole")])
}, FF = {
  line: yt.this_("singular", { ...Pt.CHART, mods: [Pt.LINE] }),
  stepline: yt.this_("singular", { ...Pt.CHART, mods: [yt.adj("stepped"), Pt.LINE] }),
  bar: yt.this_("singular", { ...Pt.CHART, mods: [yt.noun("bar")] }),
  column: yt.this_("singular", { ...Pt.CHART, mods: [yt.noun("bar")] }),
  lollipop: yt.this_("singular", { ...Pt.CHART, mods: [yt.noun("bar")] }),
  histogram: yt.this_("singular", yt.noun("histogram"))
  // FIXME: add scatter
}, W2t = {
  line: yt.this_("singular", Pt.LINE),
  stepline: yt.this_("singular", Pt.LINE, [yt.adj("stepped")]),
  bar: yt.this_("plural", yt.noun("bar")),
  //H.this_('plural', H.noun('segment'), [H.adj('bar')]);
  lollipop: yt.this_("plural", yt.noun("bar")),
  //H.this_('plural', H.noun('segment'), [H.adj('bar')]);
  column: yt.this_("plural", yt.noun("bar")),
  //H.this_('plural', H.noun('segment'), [H.adj('bar')]);
  histogram: yt.this_("plural", yt.noun("bar"))
  // FIXME: add scatter
};
class q2t {
  constructor(t, r, n, i, s, o, a, l, c, h, u, p, y) {
    Be(this, "seriesTheme"), Be(this, "isTimeSeries"), Be(this, "seriesLabel"), this.key = t, this.seriesMetadata = r, this.model = n, this.values = i, this.statsValues = s, this.indepUnit = o, this.firstPoint = a, this.lastPoint = l, this.depFacet = c, this.depFacetKey = h, this.indepFacet = u, this.indepFacetKey = p, this.intersectionValues = y, this.seriesTheme = NF(this.model.getSeriesTheme(t)), this.isTimeSeries = this.indepFacet.datatype === "date", this.seriesLabel = this.seriesMetadata.getLabel();
  }
  // Data Helpers
  /*private _getSubSeriesMetadata<T extends object>(request: string): T {
    const requestResult = jp.query(this.fullMetadata, request);
    if (requestResult.length === 0) {
      throw new ChartDataError(`The series key "${this.key}" does not exist in this graph`);
    }
    if (requestResult.length > 1) {
      throw new ChartDataError(`Request matches multiple series in this graph`);
    }
    return requestResult[0];
  }*/
  _getEarliestTime(t) {
    const r = t.map((n) => n.indepBox.value);
    return r.sort(c1.PlainDateTime.compare), r[0];
  }
  _determineFirstExtremeDirection() {
    const t = this.seriesMetadata.getFacetStats(this.depFacetKey).min, r = this.seriesMetadata.getFacetStats(this.depFacetKey).max, n = this._getEarliestTime(t.datapoints), i = this._getEarliestTime(r.datapoints);
    return c1.PlainDateTime.compare(n, i) === -1 ? "min" : "max";
  }
  // Subsentential
  _fromTo(t, r) {
    return new g2t(
      this.firstPoint,
      this.lastPoint,
      this.indepUnit,
      t,
      r,
      this.depFacet.units
    ).path();
  }
  // Sentences
  // Overall Series Summary Sentence
  summarizeSeries(t = !1) {
    const r = t ? FF[this.model.type] : W2t[this.model.type];
    if (!r)
      return console.error(`[ParaSummary]: series summaries are not implemented for ${this.model.type} charts yet`), [];
    let n = [];
    return this.isTimeSeries ? n = [BF, this._fromTo(this.statsValues.start, this.statsValues.end)] : n = [yt.over({
      type: "simple-entity",
      detType: "bare",
      number: "singular",
      category: yt.noun(this.indepFacet.description),
      mods: [yt.adj("several")]
    })], [{
      type: "simple-statement",
      subject: r,
      clause: {
        type: "simple-clause",
        pred: Pt.SHOW,
        object: this.seriesTheme,
        mods: n
      }
    }];
  }
  _extremeTimeSeriesClause(t) {
    const r = this.seriesMetadata.getFacetStats(this.depFacetKey)[t];
    let n = !1;
    const i = this.indepUnit === "year" ? c1.Duration.from({ years: 1 }) : c1.Duration.from({ months: 3 }), s = f2t(
      r.datapoints,
      i,
      this.indepUnit
    ).map((u) => u instanceof RF ? (n = !0, u.toTimeRange()) : u.indepBox.value).map((u) => UA(
      u,
      this.indepUnit
    ));
    let o;
    if (s.length === 1)
      o = s[0];
    else if (n)
      o = yt.and(...s);
    else {
      const u = s.map(
        (p) => p.point
      );
      o = yt.in_(yt.and(...u));
    }
    const a = this.statsValues[t], l = TF(a, this.depFacet.units);
    l.mods = [o];
    const c = {
      type: "simple-clause",
      pred: t === "min" ? Pt.BOTTOM_OUT : Pt.PEAK,
      object: yt.at(l)
    }, h = r.datapoints.map((u) => u.datapointIndex);
    return Ge(c, `datapoint-${this.key}-${h.join("-")}`);
  }
  _extremeTimeBoth() {
    const t = this._determineFirstExtremeDirection(), r = t === "min" ? "max" : "min", n = this._extremeTimeSeriesClause(t), i = this._extremeTimeSeriesClause(r);
    return {
      type: "simple-statement",
      subject: {
        ...this.seriesTheme,
        tag: n.tag
      },
      clause: {
        type: "coordinated-phrase",
        conn: { ...Pt.AND, tag: i.tag },
        coords: [n, i]
      }
    };
  }
  // "The {theme} {"bottoms out"/"peaks"} at {value} {"in" {time}}*. "
  _extremeTimeSeries(t) {
    if (t === "both")
      return this._extremeTimeBoth();
    const r = this._extremeTimeSeriesClause(t), n = {
      type: "simple-statement",
      subject: this.seriesTheme,
      clause: r
    };
    return n.tag = r.tag, n;
  }
  // TODO: Add back rating comparisons: https://github.com/fizzstudio/ParaSummary/issues/9
  _extremeNonTimeSeries(t) {
    if (t === "both") {
      const l = this._determineFirstExtremeDirection(), c = l === "min" ? "max" : "min", h = this._extremeNonTimeSeries(l), u = this._extremeNonTimeSeries(c);
      return yt.and(h, u);
    }
    const r = t === "min" ? { ...Pt.LOW, comparative: "superlative" } : { ...Pt.HIGH, comparative: "superlative" }, n = yt.noun(this.indepFacet.label.toLocaleLowerCase()), i = yt.the("singular", n, [r]), s = this.seriesMetadata.getFacetStats(this.depFacetKey)[t], o = s.datapoints[0].facetValue(this.indepFacetKey), a = s.value;
    return yt.svo(
      i,
      Pt.COPULA,
      yt.proper(yt.noun(o)),
      yt.at({
        type: "simple-entity",
        subtype: "quant-value",
        detType: "indefinite",
        number: a,
        category: yt.unit("point")
      })
      //{ type: 'quote', text: `, where ${closestPoint} is ${closestRating}.` }
    );
  }
  extreme(t) {
    return this.isTimeSeries ? [this._extremeTimeSeries(t)] : [this._extremeNonTimeSeries(t)];
  }
  datapoint(t) {
    if (t >= this.values.length)
      throw new $r(`The datapoint index ${t} is too large`);
    const r = { type: "label", text: this.seriesMetadata.getLabel() }, n = this.seriesMetadata.datapoints[t].facetValue("x"), i = this.values[t], s = wy(n, this.indepUnit, i, this.depFacet.units);
    return [r, s];
  }
  intersections() {
    const t = i4.query(this.model, `$.intersections[?(@.series.includes('${this.key}'))]`);
    return [{
      type: "simple-statement",
      subject: yt.this_("singular", Pt.LINE),
      clause: {
        type: "simple-clause",
        pred: Pt.HAS,
        object: {
          type: "simple-entity",
          detType: "indefinite",
          number: t.length,
          category: Pt.INTERSECTION
        }
      }
    }];
  }
  recordCount() {
    return this.model.family === "line" ? this._recordCountLine() : this.model.family === "bar" ? this._recordCountBar() : (console.error(`[ParaSummary]: record count summaries are not implemented for ${this.model.type} charts yet`), []);
  }
  _recordCountLine() {
    return [{
      type: "simple-statement",
      subject: yt.this_("singular", Pt.LINE),
      clause: {
        type: "simple-clause",
        pred: Pt.HAS,
        object: {
          type: "simple-entity",
          detType: "indefinite",
          number: this.seriesMetadata.length,
          category: Pt.RECORD
        }
      }
    }];
  }
  // There are _ bars for this category
  _recordCountBar() {
    const t = (
      /*this.fullMetadata.series.length === 1 
      ?*/
      yt.noun("bar")
    );
    return [{
      type: "simple-statement",
      subject: null,
      clause: {
        type: "simple-clause",
        pred: { ...Pt.COPULA },
        //number: 'plural'
        object: {
          type: "simple-entity",
          detType: "indefinite",
          number: this.seriesMetadata.length,
          category: t,
          mods: [yt.for_(yt.this_("singular", yt.noun("category")))]
        }
      }
    }];
  }
  async trend() {
    if (this.model.family === "scatter")
      return Kr("Trend summaries are not implemented for these chart families");
    const t = await this.model.getSeriesAnalysis(this.key);
    if (t === null)
      return Kr(`The series "${this.key}" does not have an analysis`);
    const r = t.message;
    if (r === null)
      return Kr(`The series "${this.key}" does not convey a trend message`);
    const n = t.messageSeqs.map(
      (a) => t.sequences[a]
    ), i = {
      seriesKey: this.key,
      message: r,
      messageSeqs: n
    }, s = rI(i), o = this.seriesTheme;
    return [{
      type: "simple-statement",
      subject: Ge(o, Gi(i, 0)),
      clause: s
    }];
  }
  _rankingOrdinal(t) {
    return t === 1 ? [] : [yt.ordinal(t)];
  }
  // Full: "{this-label} starts as the {Nth} highest line, (intersects with {label} {at time})*, 
  //   and ends as the {Mth} highest line." For series summaries
  // Abbrev: "{this-label} starts as the {Nth} highest line, ({"crosses over"/"touches"} {label})*, 
  //   and ends as the {Mth} highest line." For whole chart summaries
  // Special case (highest throughout chart): "{this-label} is the highest across the whole chart"
  ranking(t) {
    const r = yt.proper(yt.noun(this.seriesLabel)), n = this.model.getChordAt(
      this.indepFacetKey,
      this.seriesMetadata.datapoints[0].facetBox(this.indepFacetKey)
    );
    n.sort(
      (p, y) => y.facetValueNumericized(this.depFacetKey) - p.facetValueNumericized(this.depFacetKey)
    );
    const i = n.findIndex((p) => p.seriesKey === this.key) + 1, s = i4.query(this.model, `$.intersections[?(@.series.includes('${this.key}'))]`);
    s.sort((p, y) => p.value - y.value);
    const o = this.model.getChordAt(
      this.indepFacetKey,
      this.seriesMetadata.datapoints.at(-1).facetBox(this.indepFacetKey)
    );
    o.sort(
      (p, y) => y.facetValueNumericized(this.depFacetKey) - p.facetValueNumericized(this.depFacetKey)
    );
    const a = o.findIndex((p) => p.seriesKey === this.key) + 1;
    if (i === 1 && a === 1 && s.length === 0)
      return [Ge(yt.svo(r, Pt.COPULA, qw, jF), `series-${this.key}`)];
    const l = Ge({
      type: "simple-clause",
      pred: Pt.START,
      object: {
        type: "purpose",
        subtype: "as",
        purpose: yt.the(
          "singular",
          { ...Pt.LINE, mods: [qw] },
          this._rankingOrdinal(i)
        )
      }
    }, `datapoint-${this.key}-0`), c = [];
    for (const [p, y] of Nn(s)) {
      const g = p.series.filter((A) => A !== this.key)[0], b = this.model.atKey(g).getLabel();
      let f;
      t ? f = {
        type: "simple-clause",
        pred: p.transversality.kind === "touch" ? yt.pred("touch") : yt.pred("cross", "over"),
        object: yt.proper(yt.noun(b))
      } : f = {
        type: "simple-clause",
        pred: Pt.INTERSECT,
        object: yt.with(
          yt.proper(yt.noun(b))
        ),
        mods: [m2t(p, this.indepUnit)]
      };
      let E = `intersection-${this.key}-${y}`;
      if (p.record.labelValue !== null) {
        const A = this.seriesMetadata.datapoints.findIndex(
          (x) => x.indepBox.asNumber() === p.record.labelValue
        );
        `${this.key}${A}`;
      }
      c.push(Ge(f, E));
    }
    const h = Ge({
      type: "simple-clause",
      pred: Pt.END,
      object: {
        type: "purpose",
        subtype: "as",
        purpose: yt.the(
          "singular",
          { ...Pt.LINE, mods: [qw] },
          this._rankingOrdinal(a)
        )
      }
    }, `datapoint-${this.key}-${this.seriesMetadata.length - 1}`), u = yt.and(l, ...c, h);
    return [{
      type: "simple-statement",
      subject: r,
      clause: u
    }];
  }
  // "The {Nth} {"and final"}? sequence goes from {start-time} to {end-time} and has a {trend-direction} trend."
  async sequence(t, r) {
    const n = this.seriesMetadata.datapoints[t].facetValue(this.indepFacetKey), i = this.seriesMetadata.datapoints[r - 1].facetValue(this.indepFacetKey), s = await this.model.getSeriesAnalysis(this.key), o = s.sequences.findIndex(
      (y) => y.start === t && y.end === r
    );
    if (o < 0)
      throw new $r(`sequence in ${this.key} could not be found at start point ${t} and end point ${r}`);
    const a = s.sequences[o];
    let l = null;
    a.message !== null && (l = {
      seriesKey: this.key,
      message: a.message,
      messageSeqs: [a]
    });
    const c = o === s.sequences.length - 1 ? yt.and(yt.ordinal(o + 1), yt.adj("final")) : yt.ordinal(o + 1), h = yt.the("singular", yt.noun("sequence"), [c]), u = {
      type: "simple-clause",
      pred: yt.pred("go"),
      object: yt.path(
        Yo(n, this.indepUnit),
        Yo(i, this.indepUnit)
      )
    }, p = l === null ? [] : [rI(l, !1)];
    return {
      type: "simple-statement",
      subject: h,
      clause: yt.and(
        u,
        ...p
      )
    };
  }
}
var Y2t = Object.defineProperty, K2t = Object.getOwnPropertyDescriptor, $F = (e, t, r, n) => {
  for (var i = K2t(t, r), s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(t, r, i) || i);
  return i && Y2t(t, r, i), i;
};
const Z2t = yt.the("plural", Pt.LINE), nI = {
  type: "simple-entity",
  quantifier: Pt.ALL,
  detType: "definite",
  number: "plural",
  category: Pt.LINE
}, J2t = [
  "$.datasets[0]",
  "$.datasets[0].trend",
  "$.datasets[0].stats.extremes",
  "$.datasets[0].axes.dependent",
  "$.datasets[0].axes.independent",
  "$.datasets[0].labels"
], X2t = [
  "$.datasets[0]",
  "$.datasets[0].series.*",
  "$.datasets[0].axes.dependent",
  "$.datasets[0].axes.independent",
  "$.datasets[0].labels"
  //'$.datasets[0].series.highestAverage',
], tbt = [
  "$.datasets[0]",
  "$.datasets[0].series.*",
  "$.datasets[0].clusters.*",
  "$.datasets[0].trackingGroups.*",
  "$.datasets[0].highestRanking"
  //'$.datasets[0].axes.dependent',
  //'$.datasets[0].axes.independent',
  //'$.datasets[0].labels',
  //'$.datasets[0].series.highestAverage',
], ebt = [
  "$.datasets[0].series[?(@.key === '${seriesKey}')]",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].trend",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.extremes",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].record_count"
], rbt = [
  "$.datasets[0].series[?(@.key === '${seriesKey}')]",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].trend",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.extremes"
  //"$.datasets[0].intersections[?(@.series.includes('${seriesKey}'))]",
  //"$.datasets[0].series[?(@.key === '${seriesKey}')].record_count",
], nbt = [
  "$.datasets[0].series[?(@.key === '${seriesKey}')]",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].trend",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.max",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.min",
  //"$.datasets[0].intersections[?(@.series.includes('${seriesKey}'))]",
  //"$.datasets[0].series[?(@.key === '${seriesKey}')].record_count",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].ranking"
];
class Gb extends hb {
  /**
   * @param model - The data model for the chart
   */
  constructor(t) {
    super(t), Be(this, "summarizer"), this.summarizer = new ibt(t);
  }
  getSummarizer() {
    return this.summarizer;
  }
  async getChartSummary() {
    if (this._model.description)
      return { text: this._model.description, html: this._model.description };
    let t;
    return this._model.multi ? this._model.family === "line" ? t = tbt : t = X2t : t = J2t, this.highlightSummaries(t);
  }
  async getSeriesSummary(t) {
    let r;
    this._model.multi ? this._model.family === "line" ? r = nbt : r = rbt : r = ebt;
    const n = r.map((s) => s.replaceAll("${seriesKey}", t)), i = this._model.atKey(t).getLabel();
    return this.grammatizeSummaries(n).then((s) => `${i}: ${s}`).then((s) => m4(s));
  }
  async getSequenceSummary(t) {
    if (!this._model.seriesKeys.includes(t.seriesKey))
      throw new $r(`No series with the key ${t.seriesKey} exists in this chart.`);
    const r = await this.summarizer.sequence(t.seriesKey, `${t.start}`, `${t.end}`);
    return this.highlightComponents(r);
  }
}
$F([
  Up()
], Gb.prototype, "getChartSummary");
$F([
  Up()
], Gb.prototype, "getSeriesSummary");
class ibt {
  //private spanIndex = -1;
  // * Initialization *
  constructor(t) {
    Be(this, "multi"), Be(this, "indepFacetKey"), Be(this, "indepFacet"), Be(this, "indepUnit"), Be(this, "firstPoint"), Be(this, "lastPoint"), Be(this, "indepAxisOrient"), Be(this, "depFacetKey"), Be(this, "depFacet"), Be(this, "seriesKeys"), Be(this, "seriesValues"), Be(this, "seriesStatsValues"), Be(this, "seriesMetadata"), Be(this, "seriesSummarizers"), Be(this, "intersectionValues"), Be(this, "isTimeSeries"), this.model = t, this.indepFacetKey = this.model.independentFacetKeys[0], this.indepFacet = this.model.getFacet(this.indepFacetKey), this.indepUnit = this.indepFacet.units ?? "NO-UNIT", this.isTimeSeries = this.indepFacet.datatype === "date", this.firstPoint = this.model[0][0], this.lastPoint = this.model[0][this.model[0].length - 1];
    const r = this.model.getAxisFacet("horiz") ?? this.indepFacet;
    this.indepAxisOrient = r.label === this.indepFacet.label ? "horiz" : "vert", this.depFacetKey = this.model.dependentFacetKeys[0], this.depFacet = this.model.getFacet(this.depFacetKey), this.multi = this.model.multi, this.seriesKeys = this.model.seriesKeys, this.seriesSummarizers = {}, this.seriesMetadata = {}, this.seriesValues = this.model.seriesScaledValues ?? this.makeEmptyMap(), this.seriesStatsValues = this.model.seriesStatsScaledValues ?? this.makeEmptyMap(), this.intersectionValues = this.model.intersectionScaledValues ?? [];
    for (const n of this.seriesKeys)
      this.seriesMetadata[n] = this.model.atKey(n), this.seriesSummarizers[n] = new q2t(
        n,
        this.seriesMetadata[n],
        this.model,
        this.seriesValues[n],
        this.seriesStatsValues[n],
        this.indepUnit,
        this.firstPoint,
        this.lastPoint,
        this.depFacet,
        this.depFacetKey,
        this.indepFacet,
        this.indepFacetKey,
        this.intersectionValues
      );
  }
  makeEmptyMap() {
    const t = {};
    for (const r of this.seriesKeys)
      t[r] = null;
    return t;
  }
  // @simonvarey: This can be deleted when we feel that we won't need span indexes set in summarizers, instead of in `convertToHighlighted`
  /*private newSpanIndex(): number {
    this.spanIndex += 1;
    return this.spanIndex;
  }*/
  // * Data Helpers *
  _getOnlySeriesSummarizer() {
    if (this.multi)
      throw new $r("Cannot call `_getOnlySeriesSummarizer` on multi series chart.");
    return this.seriesSummarizers[this.seriesKeys[0]];
  }
  // * Summary Helpers *
  // Substatement
  // "___, _____, and _________" (main case) 
  // OR "the lines" (if group.length === series.length === 2)
  // OR "all the lines" (if group.length === series.length > 2)
  // @simonvarey: `tag` was originally added for `allCluster` sentences, but then I decided I didn't
  //   need it there, but I have kept it in this method in case it is useful in the future
  _seriesGroupLine(t, r) {
    if (t.length < 2)
      throw new $r("Cannot call `_seriesGroupLine` with fewer than 2 keys.");
    const n = `series-${t.join("-")}`;
    if (t.length === this.model.numSeries) {
      const o = t.length === 2 ? Z2t : nI;
      return r ? Ge(o, n) : o;
    }
    const i = t.map((o) => {
      const a = this.model.atKey(o).getLabel();
      return yt.proper(yt.noun(a));
    }), s = yt.and(...i);
    return r ? Ge(s, n) : s;
  }
  _allSeriesSubjectsBar() {
    return this.model.grouped ? {
      ...Pt.BAR,
      mods: [yt.of({
        type: "simple-entity",
        quantifier: Pt.EACH,
        detType: "bare",
        number: "singular",
        category: Pt.GROUP
      })]
    } : {
      type: "simple-category",
      noun: yt.en("segment"),
      mods: [yt.of({
        type: "simple-entity",
        quantifier: Pt.EACH,
        detType: "bare",
        number: "singular",
        category: Pt.BAR
      })]
    };
  }
  _allSeriesSubjects() {
    return this.model.family === "line" ? Pt.LINE : this.model.family === "bar" ? this._allSeriesSubjectsBar() : null;
  }
  // Statement
  // Overall Chart Summary Sentence
  // 'This {chart type} chart compares the {quantity type}s of different {topic}s over time from {start x} to {end x}.'
  _chartMultiTimeSeries(t) {
    return {
      type: "simple-statement",
      subject: t,
      clause: {
        type: "simple-clause",
        pred: Pt.COMPARE,
        object: M4(
          this.model
          /*, this.differentia!*/
        ),
        mods: [BF, yt.path(
          Yo(this.firstPoint.indepBox.value, this.indepUnit),
          Yo(this.lastPoint.indepBox.value, this.indepUnit)
        )]
      }
      //tag: makeSpan(`nochart-${this.newSpanIndex()}`)
    };
  }
  _chartMultiNonTimeSeries(t) {
    return {
      type: "simple-statement",
      subject: t,
      clause: {
        type: "simple-clause",
        pred: Pt.COMPARE,
        object: DF(
          this.model.getChartTheme(),
          this.model,
          `of ${this.model.getChartTheme().entity}`
        )
      }
    };
  }
  _chartMultiSeries() {
    const t = FF[this.model.type];
    return t ? this.isTimeSeries ? [this._chartMultiTimeSeries(t)] : [this._chartMultiNonTimeSeries(t)] : (console.error(`[ParaSummary]: whole chart summaries are not implemented for ${this.model.type} charts yet`), []);
  }
  _extreme(t) {
    throw new iy("extreme");
  }
  _intersectionAtIndex(t) {
    const r = this.model.intersections[t], n = yt.and(yt.proper(yt.noun(r.series[0])), yt.proper(yt.noun(r.series[1]))), i = this.intersectionValues[t];
    return yt.svo(
      n,
      { ...Pt.INTERSECT },
      y2t(r, this.indepUnit, i, this.depFacet)
    );
  }
  // ___, _____, and ______ track each other from ________ to ______
  _trackingGroup(t) {
    const r = t.valueInterval[0], n = this.model.series[0].datapoints[0].facetValueAsNumber(this.indepFacetKey), i = t.valueInterval[1], s = this.model.series[0].datapoints.at(-1).facetValueAsNumber(this.indepFacetKey);
    let o;
    if (r === n && i === s)
      o = jF;
    else {
      const l = uf(r), c = uf(i);
      o = new Hb(
        l,
        c,
        this.indepUnit
      ).path();
    }
    const a = this._seriesGroupLine(t.keys);
    return Ge(yt.svo(
      a,
      Pt.TRACK,
      //number: 'p'
      Pt.EACH_OTHER,
      o
    ), `series-${t.keys.join("-")}`);
  }
  // * Summary Generation *
  // All Chart
  chart() {
    return this.multi ? this._chartMultiSeries() : this._getOnlySeriesSummarizer().summarizeSeries(!0);
  }
  // Series Topics Sentence
  //The {number of series} {lines/segments of each bar/bars of each group} show the {quantity type}s of {series 1 topic}, {series 2 topic} ... 
  allSeries() {
    var t;
    const r = this._allSeriesSubjects();
    if (!r)
      return Kr(`[ParaSummary]: all series summaries are not implemented for ${this.model.type} charts yet`);
    const n = `series-${this.model[0].key}`, i = HA(this.model.getChartTheme(), !0);
    i.detTag = n0(n), i.category = Ge(i.category, n), i.mods = (t = i.mods) == null ? void 0 : t.map((o) => Ge(o, n)), $2t(i, this.model);
    const s = {
      type: "simple-clause",
      pred: Ge(Pt.SHOW, n),
      object: i
    };
    return [{
      type: "simple-statement",
      subject: Ge(yt.the(this.model.numSeries, r), n),
      clause: s
    }];
  }
  chartMin() {
    return this.multi ? this._extreme("min") : this._getOnlySeriesSummarizer().extreme("min");
  }
  chartMax() {
    return this.multi ? this._extreme("max") : this._getOnlySeriesSummarizer().extreme("max");
  }
  chartExtremes() {
    return this.multi ? this._extreme("both") : this._getOnlySeriesSummarizer().extreme("both");
  }
  onlySeriesTrend() {
    if (this.multi)
      throw new $r("`onlySeriesTrend` cannot be called on charts with multiple series.");
    return this._getOnlySeriesSummarizer().trend();
  }
  // Series
  specificSeries(t) {
    return this.seriesSummarizers[t].summarizeSeries();
  }
  seriesTrend(t) {
    return this.seriesSummarizers[t].trend();
  }
  seriesMax(t) {
    return this.seriesSummarizers[t].extreme("max");
  }
  seriesMin(t) {
    return this.seriesSummarizers[t].extreme("min");
  }
  seriesExtremes(t) {
    return this.seriesSummarizers[t].extreme("both");
  }
  seriesDatapoint(t, r) {
    const n = this.seriesSummarizers[t], i = parseInt(r);
    return n.datapoint(i);
  }
  seriesIntersections(t) {
    if (!this.multi)
      throw new $r("Series-Intersection can not be requested in single-series charts.");
    if (!this.seriesKeys.includes(t))
      throw new $r(`No series with the key ${t} exists in this chart.`);
    return this.seriesSummarizers[t].intersections(
      /*this.differentia!*/
    );
  }
  seriesRecordCount(t) {
    if (!this.seriesKeys.includes(t))
      throw new $r(`No series with the key ${t} exists in this chart.`);
    return this.seriesSummarizers[t].recordCount(
      /*this.differentia!*/
    );
  }
  seriesRanking(t) {
    if (!this.seriesKeys.includes(t))
      throw new $r(`No series with the key ${t} exists in this chart.`);
    return this.seriesSummarizers[t].ranking(!1);
  }
  // Other
  dependentAxis() {
    if (this.model.type === "pie")
      return [];
    const t = this.indepAxisOrient === "horiz" ? Pt.YAXIS : Pt.XAXIS;
    return [yt.svo(
      yt.the("singular", t),
      Pt.SHOW,
      this.dependentAxisLabel()[0]
    )];
  }
  independentAxis() {
    if (this.model.type === "pie")
      return [];
    const t = this.indepAxisOrient === "horiz" ? Pt.XAXIS : Pt.YAXIS;
    let r;
    return this.isTimeSeries ? r = {
      type: "simple-entity",
      detType: "definite",
      number: "singular",
      category: yt.noun("time"),
      mods: [yt.in_(yt.a("plural", yt.noun(this.indepUnit)))]
    } : r = {
      type: "simple-entity",
      detType: "definite",
      number: "singular",
      category: yt.noun(this.indepFacet.label.toLocaleLowerCase())
    }, [yt.svo(
      yt.the("singular", t),
      Pt.SHOW,
      r
    )];
  }
  intersection(t) {
    if (!this.multi)
      throw new $r("No intersections on single series charts.");
    const r = parseInt(t);
    if (r < 0 || r > this.model.intersections.length)
      throw new $r(`No intersection with the index ${r} exists on this chart.`);
    return [this._intersectionAtIndex(r)];
  }
  allIntersection() {
    if (!this.multi)
      throw new $r("No intersections on single series charts.");
    return y0t(this.model.intersections.length, this._intersectionAtIndex.bind(this));
  }
  //The lines for {series topic}, {series topic} ... cluster together while the line for {series topic} is an outlier.
  // OR All the lines except {series topic} cluster together.
  allCluster() {
    if (!this.multi)
      return Kr("No clusters on single series charts.");
    if (this.model.clusters.length !== 1)
      return Kr("All cluster when there are more than 1 cluster are not implemented.");
    const t = this.model.clusters[0], r = t.map((u) => this.seriesMetadata[u].facetAverage(this.depFacetKey)), n = m0t(r), i = this.model.clusterOutliers.length === 1, s = {
      type: "simple-clause",
      pred: Pt.CLUSTER,
      //, number: 'p' }
      object: null,
      mods: [Pt.TOGETHER]
    }, o = `series-${t.join("-")}`;
    let a, l, c;
    if (i && (a = this.model.clusterOutliers[0], l = yt.proper(yt.noun(a)), c = this.seriesMetadata[a].facetAverage(this.depFacetKey) > n ? yt.dir("above") : yt.dir("below")), i && t.length + 1 === this.model.series.length && t.length > 2) {
      const u = {
        ...nI,
        mods: [{
          type: "point-location",
          direction: Pt.EXCEPT,
          point: l
        }]
      }, p = Ge({
        type: "simple-statement",
        subject: u,
        clause: s
      }, o), y = Ge(yt.svo(l, yt.pred("lie"), c), `series-${a}`), g = yt.coord(Pt.WHILE, p, y);
      return g.conn = Ge(g.conn, `series-${a}`), [g];
    }
    let h = Ge({
      type: "simple-statement",
      subject: this._seriesGroupLine(t),
      clause: s
    }, o);
    if (this.model.clusterOutliers.length === 1) {
      const u = `series-${this.model.clusterOutliers[0]}`, p = Ge(yt.svo(
        l,
        Pt.COPULA,
        yt.a("singular", Pt.OUTLIER),
        c
      ), u);
      h = yt.coord({ ...Pt.WHILE, tag: n0(u) }, h, p);
    }
    return [h];
  }
  allTrackingGroup() {
    return this.multi ? this.model.trackingGroups.map((t) => this._trackingGroup(t)) : Kr("No tracking groups on single series charts.");
  }
  datapoint(t, r) {
    const n = this.model.allPoints.filter((i) => i.facetValue("x") === t && i.facetValue("y") === r).map((i) => i.seriesKey).map((i) => this.model.atKey(i).getLabel());
    return [{
      type: "label",
      text: `X: ${t}, Y: ${r}, Series: ${n.join(", ")}`
    }];
  }
  async sequence(t, r, n) {
    return [await this.seriesSummarizers[t].sequence(parseInt(r), parseInt(n))];
  }
  chartLabels() {
    const t = this.indepAxisOrient === "horiz" ? Pt.XAXIS : Pt.YAXIS;
    let r;
    return this.model.type === "pie" ? r = {
      type: "simple-entity",
      detType: "indefinite",
      number: this.model[0].length,
      category: yt.noun("slice")
    } : r = {
      type: "simple-entity",
      detType: "indefinite",
      number: this.model[0].length,
      category: Pt.RECORD,
      mods: [{ type: "point-location", direction: Pt.ALONG, point: yt.the("singular", t) }]
    }, [{
      type: "simple-statement",
      subject: yt.the("singular", Pt.CHART),
      clause: {
        type: "simple-clause",
        pred: Pt.HAS,
        object: r
      }
    }];
  }
  highestRanking() {
    const t = this.model.series.toSorted((r, n) => n.facetAverage(this.depFacetKey) - r.facetAverage(this.depFacetKey))[0].key;
    return this.seriesSummarizers[t].ranking(!0);
  }
  // Substatement
  chartTheme() {
    return [M4(this.model)];
  }
  dependentAxisLabel() {
    const t = Q2t(this.model.getChartTheme());
    if (this.depFacet.units !== void 0 && (this.depFacet.units in O4 || this.depFacet.units in vy)) {
      let r = yt.a("plural", yt.noun(this.depFacet.units));
      this.depFacet.multiplier !== void 0 && (r = {
        type: "simple-entity",
        detType: "indefinite",
        number: "plural",
        category: L4[this.depFacet.multiplier],
        mods: [yt.of(r)]
      }), t.mods = [yt.in_(r)];
    } else if (this.depFacet.multiplier !== void 0 && this.model.getChartTheme().baseKind === "number") {
      const r = {
        type: "simple-entity",
        detType: "indefinite",
        number: "plural",
        category: L4[this.depFacet.multiplier]
      };
      t.mods ?? (t.mods = []), t.mods.push(yt.in_(r));
    }
    return [t];
  }
}
const sbt = {
  pie: yt.this_("singular", yt.noun("slice")),
  donut: yt.this_("singular", yt.noun("slice"))
}, zF = {
  pie: yt.this_("singular", { ...Pt.CHART, mods: [yt.noun("pie")] }),
  donut: yt.this_("singular", { ...Pt.CHART, mods: [yt.noun("donut")] })
};
class obt {
  constructor(t, r, n, i, s) {
    Be(this, "seriesThemePhrase"), Be(this, "seriesLabel"), this.key = t, this.seriesMetadata = r, this.model = n, this.depFacetKey = i, this.indepFacetKey = s, this.seriesThemePhrase = NF(this.model.getSeriesTheme(this.key)), this.seriesLabel = this.seriesMetadata.getLabel();
  }
  // Sentences
  // Overall Series Summary Sentence
  summarizeSeries(t = !1) {
    const r = t ? zF[this.model.type] : sbt[this.model.type];
    return r ? [{
      type: "simple-statement",
      subject: r,
      clause: {
        type: "simple-clause",
        pred: Pt.SHOW,
        object: this.seriesThemePhrase
      }
    }] : (console.error(`[ParaSummary]: series summaries are not implemented for ${this.model.type} charts yet`), []);
  }
  _extremePie(t) {
    if (t === "both")
      return yt.and(this._extremePie("max"), this._extremePie("min"));
    const r = this.seriesMetadata.getFacetStats(this.depFacetKey)[t], n = r.datapoints.map(
      (h) => yt.proper(yt.noun(h.facetValue(this.indepFacetKey)))
    ), i = n.length, s = i === 1 ? n[0] : yt.and(...n), o = i === 1 ? "singular" : "plural", a = r.value, l = t === "min" ? { ...yt.adj("small"), comparative: "superlative" } : { ...Pt.LARGE, comparative: "superlative" }, c = yt.the(o, yt.noun("slice"), [l]);
    return yt.svo(
      c,
      {
        ...Pt.COPULA
        /*number: extremeGramNumber*/
      },
      s,
      yt.at({
        type: "number-entity",
        number: a,
        scale: dl[0.01]
      })
    );
  }
  extreme(t) {
    return [this._extremePie(t)];
  }
  datapoint(t) {
    if (t >= this.seriesMetadata.length)
      throw new $r(`The datapoint index ${t} is too large`);
    const r = { type: "label", text: this.seriesLabel }, n = this.seriesMetadata.datapoints[t].facetValue(this.indepFacetKey), i = { type: "quote", text: `${this.seriesMetadata.datapoints[t].facetValue(this.depFacetKey)} at ${n}.` };
    return [r, i];
  }
  intersections() {
    return console.error("Pastry charts do not have intersections and therefore do not have intersection summaries"), [];
  }
  recordCount() {
    return console.error(`[ParaSummary]: record count summaries are not implemented for ${this.model.type} charts yet`), [];
  }
  async trend() {
    return console.error("Pastry charts do not have trends and therefore do not have trends summaries"), [];
  }
}
var abt = Object.defineProperty, lbt = Object.getOwnPropertyDescriptor, VF = (e, t, r, n) => {
  for (var i = lbt(t, r), s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(t, r, i) || i);
  return i && abt(t, r, i), i;
};
const cbt = [
  "$.datasets[0]",
  "$.datasets[0].stats.extremes",
  "$.datasets[0].labels"
];
class Qb extends hb {
  /**
   * @param model - The data model for the chart
   */
  constructor(t) {
    super(t), Be(this, "summarizer"), this.summarizer = new ubt(t);
  }
  getSummarizer() {
    return this.summarizer;
  }
  async getChartSummary() {
    return this._model.multi ? jw("Summaries are not implemented for multi-series pastry charts") : this._model.description ? { text: this._model.description, html: this._model.description } : this.highlightSummaries(cbt);
  }
  async getSeriesSummary(t) {
    return jw("Series summaries are not implemented for pastry charts");
  }
  async getSequenceSummary(t) {
    return jw("sequence is not defined for pastry charts");
  }
}
VF([
  Up()
], Qb.prototype, "getChartSummary");
VF([
  Up()
], Qb.prototype, "getSeriesSummary");
class ubt {
  // * Initialization *
  constructor(t) {
    Be(this, "multi"), Be(this, "indepFacetKey"), Be(this, "depFacetKey"), Be(this, "seriesKeys"), Be(this, "seriesMetadata"), Be(this, "seriesSummarizers"), this.model = t, this.multi = this.model.multi, this.indepFacetKey = this.model.independentFacetKeys[0], this.depFacetKey = this.model.dependentFacetKeys[0], this.seriesKeys = this.model.seriesKeys, this.seriesSummarizers = {}, this.seriesMetadata = {};
    for (const r of this.seriesKeys)
      this.seriesMetadata[r] = this.model.atKey(r), this.seriesSummarizers[r] = new obt(
        r,
        this.seriesMetadata[r],
        this.model,
        this.depFacetKey,
        this.indepFacetKey
      );
  }
  // * Data Helpers *
  _getOnlySeriesSummarizer() {
    if (this.multi)
      throw new $r("Cannot call `_getOnlySeriesSummarizer` on multi series chart.");
    return this.seriesSummarizers[this.seriesKeys[0]];
  }
  // * Summary Helpers *
  // Statement
  // Overall Chart Summary Sentence
  // 'This {chart type} chart compares {theme of entity}.'
  _chartMultiNonTimeSeries(t) {
    return {
      type: "simple-statement",
      subject: t,
      clause: {
        type: "simple-clause",
        pred: Pt.COMPARE,
        object: DF(
          this.model.getChartTheme(),
          this.model,
          `of ${this.model.getChartTheme().entity}`
        )
      }
    };
  }
  _extreme(t) {
    throw new iy("extreme");
  }
  // * Summary Generation *
  // All Chart
  chart() {
    if (this.multi) {
      const t = zF[this.model.type];
      return t ? [this._chartMultiNonTimeSeries(t)] : (console.error(`[ParaSummary]: whole chart summaries are not implemented for ${this.model.type} charts yet`), []);
    } else
      return this._getOnlySeriesSummarizer().summarizeSeries(!0);
  }
  // Series Topics Sentence
  //The {number of series} {lines/bar segments} show the {quantity type}s of {series 1 topic}, {series 2 topic} ... 
  allSeries() {
    return console.error(`[ParaSummary]: all series summaries are not implemented for ${this.model.type} charts yet`), [];
  }
  chartMin() {
    return this.multi ? this._extreme("min") : this._getOnlySeriesSummarizer().extreme("min");
  }
  chartMax() {
    return this.multi ? this._extreme("max") : this._getOnlySeriesSummarizer().extreme("max");
  }
  chartExtremes() {
    return this.multi ? this._extreme("both") : this._getOnlySeriesSummarizer().extreme("both");
  }
  async onlySeriesTrend() {
    return Kr("onlySeriesTrend is not defined for pastry charts");
  }
  // Series
  specificSeries(t) {
    return this.seriesSummarizers[t].summarizeSeries();
  }
  seriesMax(t) {
    return this.seriesSummarizers[t].extreme("max");
  }
  seriesMin(t) {
    return this.seriesSummarizers[t].extreme("min");
  }
  seriesExtremes(t) {
    return this.seriesSummarizers[t].extreme("both");
  }
  seriesDatapoint(t, r) {
    const n = this.seriesSummarizers[t], i = parseInt(r);
    return n.datapoint(i);
  }
  seriesIntersections(t) {
    if (!this.multi)
      throw new $r("Series-Intersection can not be requested in single-series charts.");
    if (!this.seriesKeys.includes(t))
      throw new $r(`No series with the key ${t} exists in this chart.`);
    return this.seriesSummarizers[t].intersections(
      /*this.differentia!*/
    );
  }
  seriesRecordCount(t) {
    if (!this.seriesKeys.includes(t))
      throw new $r(`No series with the key ${t} exists in this chart.`);
    return this.seriesSummarizers[t].recordCount(
      /*this.differentia!*/
    );
  }
  async seriesTrend(t) {
    return Kr("seriesTrend is not defined for pastry charts");
  }
  seriesRanking(t) {
    return Kr("seriesRanking is not defined for pastry charts");
  }
  // Other
  dependentAxis() {
    return Kr("Pastry charts do not have axes and therefore do not have dependent axis summaries");
  }
  independentAxis() {
    return Kr("Pastry charts do not have axes and therefore do not have independent axis summaries");
  }
  intersection(t) {
    return Kr("Pastry charts do not have intersections and therefore do not have intersection summaries");
  }
  allIntersection() {
    return Kr("Pastry charts do not have intersections and therefore do not have intersection summaries");
  }
  allCluster() {
    return Kr("Pastry charts do not have clusters and therefore do not have cluster summaries");
  }
  allTrackingGroup() {
    return Kr("Pastry charts do not have tracking groups and therefore do not have cluster summaries");
  }
  datapoint(t, r) {
    const n = this.model.allPoints.filter((i) => i.facetValue("x") === t && i.facetValue("y") === r).map((i) => i.seriesKey).map((i) => this.model.atKey(i).getLabel());
    return [{
      type: "label",
      text: `X: ${t}, Y: ${r}, Series: ${n.join(", ")}`
    }];
  }
  async sequence(t, r, n) {
    return Kr("Sequence summaries not implemented for pastry charts");
  }
  chartLabels() {
    const t = {
      type: "simple-entity",
      detType: "indefinite",
      number: this.model[0].length,
      category: yt.noun("slice")
    };
    return [{
      type: "simple-statement",
      subject: yt.the("singular", Pt.CHART),
      clause: {
        type: "simple-clause",
        pred: Pt.HAS,
        object: t
      }
    }];
  }
  highestRanking() {
    return Kr("highestRanking is not defined for pastry charts");
  }
  // Substatement
  chartTheme() {
    return [M4(this.model)];
  }
  dependentAxisLabel() {
    return console.error("Pastry charts do not have axes and therefore do not have dependent axis labels"), [];
  }
}
const hbt = ["up", "down", "left", "right", "in", "out"], pbt = {
  horizTick: "axis.horiz.ticks.labelFormat",
  vertTick: "axis.vert.ticks.labelFormat",
  linePoint: "type.line.pointLabelFormat",
  scatterPoint: "type.scatter.pointLabelFormat",
  histogramPoint: "type.histogram.pointLabelFormat",
  heatmapPoint: "type.histogram.pointLabelFormat",
  barCluster: "type.bar.clusterLabelFormat",
  pieSliceLabel: "type.pie.sliceLabelFormat",
  pieSliceValue: "type.pie.sliceValueFormat",
  donutSliceLabel: "type.donut.sliceLabelFormat",
  gaugeSliceLabel: "type.gauge.sliceLabelFormat",
  steplinePoint: "type.stepline.pointLabelFormat",
  lollipopPoint: "type.lollipop.pointLabelFormat",
  lollipopCluster: "type.lollipop.clusterLabelFormat",
  jimX: "jim.xValueFormat",
  dataTableX: "dataTable.xValueFormat",
  dataTableY: "dataTable.yValueFormat",
  statusBar: "statusBar.valueFormat",
  domId: "NA"
};
class dr {
  static hydrateInput(t) {
    const r = {};
    for (const [n, i] of Object.entries(t))
      dr.set(n, i, r, !0);
    return r;
  }
  /**
   * Generate a list of setting [key, value] pairs that would need to be applied
   * to `this` to turn it into `other`.
   * @param other - Another setting store object.
   * @returns List of [key, value] pairs. 
   */
  /*diff(other: SettingStore): [string, Setting | undefined][] {
      return this.diffGroup(this.settings, other.settings);
    }
  
    private diffGroup<T extends SettingGroup>(group: Partial<T>, withGroup: T, path = '') {
      let diff: [string, Setting | undefined][] = [];
      const keys = Object.keys(withGroup) as (keyof T)[];
      for (const key of keys) {
        const pathPlusKey = `${path ? path + '.' : ''}${key as string}`;
        if (group.hasOwnProperty(key)) {
          if (typeof group[key] === 'object') {
            if (typeof withGroup[key] !== 'object') {
              throw new Error(`type of setting '${key as string}' must be ${typeof withGroup[key]}`);
            }
            diff = diff.concat(this.diffGroup(group[key] as SettingGroup, withGroup[key] as SettingGroup, 
              pathPlusKey));
          } else if (group[key] !== withGroup[key]) {
            diff.push([pathPlusKey, withGroup[key] as Setting | undefined]);
          } 
        } else {
          // withGroup is guaranteed to have the key
          if (typeof withGroup[key] === 'object') {
            diff = diff.concat(this.diffGroup({}, withGroup[key] as SettingGroup, 
              `${path}.${key as string}`));
          } else {
            diff.push([pathPlusKey, withGroup[key] as Setting | undefined]);
          }
        }
      }
      return diff;
    }
  
    /**
     * Given a group path, return the object for it.
     * @param path - Dotted path to the group.
     * @param group - Optional group to start search from (default: root of the setting tree).
     * @param create - Optionally create groups that don't exist.
     * @returns Setting group object.
     */
  static getGroup(t, r, n = !1) {
    const i = t.split(".");
    let s = r, o = null;
    for (const a of i)
      if (o = s, s = s[a], typeof s != "object")
        if (n && s === void 0)
          s = {}, o[a] = s;
        else
          throw new Error(`invalid setting group type '${typeof s}' in '${t}'`);
    return s;
  }
  static getGroupLink(t, r) {
    return dr.getGroup(t, r);
  }
  /**
   * Given a full setting path, return the group that immediately
   * contains the setting.
   * @param path - Dotted path to the setting.
   * @param group - Optional group to start search from (default: root of the setting tree).
   * @param create - Optionally create groups that don't exist.
   * @returns Setting group.
   */
  static getGroupForSetting(t, r, n = !1) {
    const i = t.split(".");
    if (i.length < 2)
      throw new Error("setting path must have at least two elements");
    return dr.getGroup(i.slice(0, -1).join("."), r, n);
  }
  static get(t, r) {
    const n = dr.getGroupForSetting(t, r)[t.split(".").at(-1)];
    if (typeof n == "object")
      throw new Error("can only get settings, not groups");
    return n;
  }
  static set(t, r, n, i = !1) {
    const s = t.split("."), o = dr.getGroupForSetting(t, n, i);
    o[s.at(-1)] = r;
  }
  static cloneSettings(t) {
    const r = {}, n = Object.keys(t);
    for (const i of n)
      dr.cloneProp(r, t, i);
    return r;
  }
  static cloneProp(t, r, n) {
    typeof r[n] == "object" ? t[n] = dr.cloneSettings(r[n]) : t[n] = r[n];
  }
  static suppleteSettings(t, r) {
    const n = Object.keys(r);
    for (const i of n)
      if (t.hasOwnProperty(i))
        if (typeof t[i] == "object") {
          if (typeof r[i] != "object")
            throw new Error(`type of setting '${i}' must be ${typeof r[i]}`);
          this.suppleteSettings(t[i], r[i]);
        } else if (t[i] === void 0)
          dr.cloneProp(t, r, i);
        else
          continue;
      else
        dr.cloneProp(t, r, i);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const UF = Symbol.for(""), dbt = (e) => {
  if ((e == null ? void 0 : e.r) === UF) return e == null ? void 0 : e._$litStatic$;
}, Zc = (e, ...t) => ({ _$litStatic$: t.reduce((r, n, i) => r + ((s) => {
  if (s._$litStatic$ !== void 0) return s._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${s}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(n) + e[i + 1], e[0]), r: UF }), iI = /* @__PURE__ */ new Map(), HF = (e) => (t, ...r) => {
  const n = r.length;
  let i, s;
  const o = [], a = [];
  let l, c = 0, h = !1;
  for (; c < n; ) {
    for (l = t[c]; c < n && (s = r[c], (i = dbt(s)) !== void 0); ) l += i + t[++c], h = !0;
    c !== n && a.push(s), o.push(l), c++;
  }
  if (c === n && o.push(t[n]), h) {
    const u = o.join("$$lit$$");
    (t = iI.get(u)) === void 0 && (o.raw = o, iI.set(u, t = o)), r = a;
  }
  return e(t, ...r);
}, fbt = HF(Ht), gbt = HF(Ie);
var mbt = Object.defineProperty, ybt = (e, t, r, n) => {
  for (var i = void 0, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(t, r, i) || i);
  return i && mbt(t, r, i), i;
};
const bbt = {
  textfield: Zc`para-textfield-setting-control`,
  dropdown: Zc`para-dropdown-setting-control`,
  checkbox: Zc`para-checkbox-setting-control`,
  radio: Zc`para-radio-setting-control`,
  slider: Zc`para-slider-setting-control`,
  button: Zc`para-button-setting-control`
};
class GF extends Rm {
  constructor(t) {
    super(), this._store = t, this._settingControlInfo = {};
  }
  add(t) {
    this._settingControlInfo = $rt(this._settingControlInfo, (r) => {
      const n = {}, i = bbt[t.type];
      n.key = t.key, n.parentView = t.parentView, n.options = t.options, n.validator = t.validator, n.render = () => fbt`
        <${i}
          .value=${t.value ?? dr.get(t.key, this._store.settings)}
          .label=${t.label}
          .info=${n}
          .store=${this._store}
          ?hidden=${t.hidden}
          id="setting-${Cr(t.key)}"
        ></${i}>
      `, r[t.key] = n;
    });
  }
  info(t) {
    return this._settingControlInfo[t];
  }
  // value<T extends Setting>(key: string) {
  //   const controlInfo = this.info(key);
  //   if (!controlInfo) {
  //     throw new Error(`no setting control info for key '${key}'`);
  //   }
  //   return controlInfo.settingControlRef.value!.value as T;
  // }
  // setVisible(key: string, visible: boolean) {
  //   const controlInfo = this.info(key);
  //   if (!controlInfo) {
  //     throw new Error(`no setting control info for key '${key}'`);
  //   }
  //   if (visible) {
  //     controlInfo.settingControlRef.value!.removeAttribute('hidden');
  //   } else {
  //     controlInfo.settingControlRef.value!.setAttribute('hidden', 'hidden');
  //   }
  // }
  getContent(t) {
    return Object.values(this._settingControlInfo).filter((r) => r.parentView === t).map((r) => r.render());
  }
  /**
   * Update the control (if any) for a setting with a new value.
   * @returns Setting keys.
   */
  // update(key: string, value: Setting | undefined) {
  //   const controlInfo = this._settingControlInfo[key];
  //   if (controlInfo) {
  //     const control = controlInfo.settingControlRef.value!;
  //     if (control) {
  //       control.value = value;
  //     }
  //   } else {
  //     this.log(`no setting control for key '${key}'`);
  //   }
  // }
  // updateOptions(key: string, options: SettingControlOptionsType<any>) {
  //   const controlInfo = this._settingControlInfo[key];
  //   if (controlInfo) {
  //     const control = controlInfo.settingControlRef.value!;
  //     if (control) {
  //       if (!controlInfo.options) {
  //         controlInfo.options = {};
  //       }
  //       for (const prop in options) {
  //         const key = prop as keyof typeof options;
  //         controlInfo.options[key] = options[key];
  //       }
  //       control.requestUpdate();
  //     }
  //   } else {
  //     this.log(`no setting control for key '${key}'`);
  //   }
  // }
}
ybt([
  vr()
], GF.prototype, "_settingControlInfo");
const N4 = [
  16.3516,
  17.32391,
  18.35405,
  19.44544,
  20.60172,
  21.82676,
  23.12465,
  24.49971,
  25.95654,
  27.5,
  29.13524,
  30.86771,
  // octave 0
  32.7032,
  34.64783,
  36.7081,
  38.89087,
  41.20344,
  43.65353,
  46.2493,
  48.99943,
  51.91309,
  55,
  58.27047,
  61.73541,
  // octave 1
  65.40639,
  69.29566,
  73.41619,
  77.78175,
  82.40689,
  87.30706,
  92.49861,
  97.99886,
  103.8262,
  110,
  116.5409,
  123.4708,
  // octave 2
  130.8128,
  138.5913,
  146.8324,
  155.5635,
  164.8138,
  174.6141,
  184.9972,
  195.9977,
  207.6523,
  220,
  233.0819,
  246.9417,
  // octave 3
  261.6256,
  277.1826,
  293.6648,
  311.127,
  329.6276,
  349.2282,
  369.9944,
  391.9954,
  415.3047,
  440,
  466.1638,
  493.8833,
  // octave 4
  523.2511,
  554.3653,
  587.3295,
  622.254,
  659.2551,
  698.4565,
  739.9888,
  783.9909,
  830.6094,
  880,
  932.3275,
  987.7666,
  // octave 5
  1046.502,
  1108.731,
  1174.659,
  1244.508,
  1318.51,
  1396.913,
  1479.978,
  1567.982,
  1661.219,
  1760,
  1864.655,
  1975.533,
  // octave 6
  2093.005,
  2217.461,
  2349.318,
  2489.016,
  2637.02,
  2793.826,
  2959.955,
  3135.963,
  3322.438,
  3520,
  3729.31,
  3951.066,
  // octave 7
  4186.009,
  4434.922,
  4698.636,
  4978.032,
  5274.041,
  5587.652,
  5919.911,
  6271.927,
  6644.875,
  7040,
  7458.62,
  7902.133
  // octave 8
], Fh = "http://www.w3.org/2000/svg", sI = {
  bar: {
    "chart.orientation": "east",
    "axis.vert.labelOrder": "northToSouth",
    "axis.horiz.ticks.isDrawTicks": !1,
    "grid.isDrawHorizLines": !1
  },
  column: {
    "axis.horiz.ticks.isDrawTicks": !0,
    "axis.vert.line.isDrawOverhang": !0,
    "grid.isDrawVertLines": !1
  },
  line: {
    "grid.isDrawVertLines": !1
  }
}, vbt = {
  chart: {
    type: "bar",
    size: {
      width: 600,
      height: 450
    },
    title: {
      isDrawTitle: !0,
      margin: 40,
      fontSize: "12pt",
      align: "center",
      position: "top"
    },
    orientation: "north",
    padding: "8 20",
    //chartType: 'line'
    fontFamily: "Helvetica, sans-serif",
    fontWeight: "300",
    fontScale: 1,
    stroke: "purple",
    strokeWidth: 4,
    strokeHighlightScale: 1.5,
    symbolStrokeWidth: 2,
    symbolHighlightScale: 1.5,
    hasDirectLabels: !0,
    directLabelFontSize: "10pt",
    hasLegendWithDirectLabels: !1,
    isDrawSymbols: !0,
    isStatic: !1,
    isShowVisitedDatapointsOnly: !1,
    showPopups: !1
  },
  axis: {
    minInterval: 25,
    datapointMargin: 3,
    horiz: {
      isDrawAxis: !0,
      position: "south",
      title: {
        isDrawTitle: !1,
        gap: 8,
        fontSize: "12pt"
      },
      ticks: {
        isDrawTicks: !1,
        padding: 3,
        opacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        length: 10,
        labelFormat: "raw",
        labels: {
          isDrawTickLabels: !0,
          fontSize: "10pt",
          angle: -45,
          offsetGap: 4,
          gap: 0
        },
        step: 1
      },
      line: {
        isDrawAxisLine: !0,
        isDrawOverhang: !0,
        strokeWidth: 2,
        strokeLinecap: "round"
      },
      labelOrder: "westToEast",
      interval: "unset"
    },
    vert: {
      isDrawAxis: !0,
      position: "west",
      title: {
        isDrawTitle: !0,
        gap: 8,
        fontSize: "12pt"
      },
      ticks: {
        isDrawTicks: !0,
        padding: 3,
        opacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        length: 10,
        labelFormat: "raw",
        labels: {
          isDrawTickLabels: !0,
          fontSize: "10pt",
          angle: 0,
          offsetGap: 0,
          gap: 0
        },
        step: 1
      },
      line: {
        isDrawAxisLine: !0,
        isDrawOverhang: !0,
        strokeWidth: 2,
        strokeLinecap: "round"
      },
      labelOrder: "southToNorth"
    },
    x: {
      minValue: "unset",
      maxValue: "unset",
      interval: "unset"
    },
    y: {
      minValue: "unset",
      maxValue: "unset",
      interval: "unset"
    }
  },
  legend: {
    isDrawLegend: !0,
    isDrawLegendWhenNeeded: !0,
    isAlwaysDrawLegend: !1,
    boxStyle: {
      outline: "none",
      //outline: 'gray',
      outlineWidth: 1,
      fill: "none"
      //fill: 'aliceblue',
    },
    padding: 10,
    symbolLabelGap: 5,
    pairGap: 30,
    position: "east",
    margin: 20,
    itemOrder: "series",
    fontSize: "10pt"
  },
  plotArea: {
    size: {
      width: 600,
      height: 250
    }
  },
  popup: {
    opacity: 1,
    leftPadding: 10,
    rightPadding: 10,
    upPadding: 10,
    downPadding: 10,
    margin: 40,
    maxWidth: 175,
    shape: "boxWithArrow",
    activation: "onHover",
    borderRadius: 10,
    backgroundColor: "dark"
  },
  type: {
    bar: {
      stacking: "standard",
      barWidth: 20,
      colorByDatapoint: !1,
      isDrawTotalLabels: !0,
      stackLabelGap: 10,
      isDrawRecordLabels: !1,
      isDrawDataLabels: !1,
      dataLabelPosition: "center",
      clusterBy: void 0,
      clusterGap: 0,
      isAbbrevSeries: !0,
      orderBy: void 0,
      barGap: 2,
      //stackInsideGap: 4,
      clusterLabelFormat: "raw",
      lineWidth: 5,
      showPopups: !1,
      labelFontSize: "8pt"
    },
    column: {
      stacking: "standard",
      barWidth: 10,
      colorByDatapoint: !1,
      isDrawTotalLabels: !1,
      isDrawRecordLabels: !1,
      isDrawDataLabels: !1,
      dataLabelPosition: "center",
      stackLabelGap: 10,
      clusterBy: void 0,
      clusterGap: 2,
      isAbbrevSeries: !0,
      orderBy: void 0,
      barGap: 20,
      //stackInsideGap: 0,
      clusterLabelFormat: "raw",
      lineWidth: 5,
      showPopups: !1,
      labelFontSize: "8pt"
    },
    line: {
      lineWidth: 5,
      lineWidthMax: 25,
      lowVisionLineWidth: 15,
      lineHighlightScale: 1.5,
      baseSymbolSize: 10,
      seriesLabelPadding: 5,
      pointLabelFormat: "raw",
      leaderLineLength: 30,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      },
      isDrawSymbols: !0,
      showPopups: !1,
      isTrendNavigationModeEnabled: !1
    },
    scatter: {
      isDrawTrendLine: !1,
      isShowOutliers: !1,
      pointLabelFormat: "raw",
      symbolStrokeWidth: 2,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      }
    },
    histogram: {
      pointLabelFormat: "raw",
      bins: 20,
      displayAxis: "x",
      groupingAxis: "",
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      },
      relativeAxes: "Counts"
    },
    heatmap: {
      pointLabelFormat: "raw",
      resolution: 20,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      }
    },
    pie: {
      outsideLabels: {
        vertGap: 10,
        arcGap: 10,
        horizShift: 15,
        horizPadding: 10,
        leaderStyle: "direct",
        format: "raw",
        underlineGap: 2,
        contents: "percentage:(value)"
      },
      insideLabels: {
        format: "raw",
        position: 0.9,
        contents: "category"
      },
      isRenderCenterLabel: !0,
      annularThickness: 1,
      centerLabel: "none",
      centerLabelPadding: 10,
      orientationAngleOffset: 90,
      explode: "",
      explodeDistance: 20
    },
    donut: {
      outsideLabels: {
        vertGap: 10,
        arcGap: 10,
        horizShift: 15,
        horizPadding: 10,
        leaderStyle: "direct",
        format: "raw",
        underlineGap: 2,
        contents: "percentage:(value)"
      },
      insideLabels: {
        format: "raw",
        position: 0.85,
        contents: "category"
      },
      isRenderCenterLabel: !0,
      annularThickness: 0.5,
      centerLabel: "title",
      centerLabelPadding: 15,
      orientationAngleOffset: 90,
      explode: "",
      explodeDistance: 20
    },
    gauge: {
      outsideLabels: {
        vertGap: 4,
        arcGap: 10,
        horizShift: 15,
        horizPadding: 10,
        leaderStyle: "direct",
        format: "raw",
        underlineGap: 6,
        contents: "percentage:(value)"
      },
      insideLabels: {
        format: "raw",
        position: 0.85,
        contents: "category"
      },
      isRenderCenterLabel: !0,
      annularThickness: 0.5,
      centerLabel: "none",
      centerLabelPadding: 10,
      orientationAngleOffset: 90,
      explode: "",
      explodeDistance: 20
    },
    stepline: {
      lineWidth: 5,
      lineWidthMax: 25,
      baseSymbolSize: 10,
      seriesLabelPadding: 5,
      pointLabelFormat: "raw",
      leaderLineLength: 30,
      symbolStrokeWidth: 2,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      }
    },
    lollipop: {
      stacking: "standard",
      barWidth: 10,
      minBarWidth: 6,
      colorByDatapoint: !1,
      isDrawTotalLabels: !1,
      stackLabelGap: 10,
      isDrawRecordLabels: !1,
      isDrawDataLabels: !1,
      dataLabelPosition: "end",
      lineWidth: 5,
      clusterBy: void 0,
      clusterGap: 5,
      isAbbrevSeries: !0,
      orderBy: void 0,
      barGap: 0.25,
      //stackInsideGap: 4,
      clusterLabelFormat: "raw",
      showPopups: !1,
      labelFontSize: "8pt"
    }
  },
  grid: {
    isDrawHorizLines: !0,
    isDrawVertLines: !0,
    isDrawHorizAxisOppositeLine: !0,
    isDrawVertAxisOppositeLine: !0
  },
  ui: {
    isVoicingEnabled: !1,
    isNarrativeHighlightEnabled: !1,
    isNarrativeHighlightPaused: !1,
    isAnnouncementEnabled: !0,
    speechRate: 1,
    isFullscreenEnabled: !1,
    isLowVisionModeEnabled: !1,
    isFocusRingEnabled: !1,
    focusRingGap: 10,
    navRunTimeoutMs: 125
  },
  animation: {
    isAnimationEnabled: !0,
    animateRevealTimeMs: 2500,
    popInAnimateRevealTimeMs: 1500,
    animationType: "uniform",
    animationOrigin: "initialValue",
    animationOriginValue: 0,
    expandPoints: !0,
    lineSnake: !1,
    symbolPopIn: !1
  },
  scrollytelling: {
    isScrollytellingEnabled: !0,
    isScrollyAnnouncementsEnabled: !0,
    isScrollySoniEnabled: !0
  },
  controlPanel: {
    isControlPanelDefaultOpen: !0,
    tabLabelStyle: "label",
    isCaptionVisible: !0,
    isExplorationBarVisible: !0,
    caption: {
      isCaptionExternalWhenControlPanelClosed: !0,
      hasBorder: !1,
      isExplorationBarBeside: !0
    },
    isSparkBrailleVisible: !1,
    isSparkBrailleControlVisible: !0,
    isMDRAnnotationsVisible: !1,
    isDataTabVisible: !0,
    isColorsTabVisible: !0,
    isAudioTabVisible: !0,
    isControlsTabVisible: !0,
    isChartTabVisible: !0,
    isAnnotationsTabVisible: !0,
    isAnalysisTabVisible: !0,
    isColorPaletteControlVisible: !0,
    isCVDControlVisible: !0
  },
  color: {
    colorVisionMode: "normal",
    isDarkModeEnabled: !1,
    contrastLevel: 1,
    colorPalette: "diva"
  },
  jim: {
    xValueFormat: "raw"
  },
  dataTable: {
    xValueFormat: "raw",
    yValueFormat: "raw"
  },
  statusBar: {
    valueFormat: "raw"
  },
  sonification: {
    isSoniEnabled: !1,
    isRiffEnabled: !0,
    isNotificationEnabled: !0,
    hertzLower: 35,
    hertzUpper: N4.length - 12,
    soniPlaySpeed: 3,
    riffSpeed: "medium",
    riffSpeedIndex: 2,
    isArpeggiateChords: !0
  },
  dev: {
    isDebug: !1,
    isShowGridTerritories: !1
  }
};
class QF {
  constructor(t) {
    this._store = t, this.keys = /* @__PURE__ */ new Map(), this._colorMap = null, this.primary = "hsl(270, 50%, 50%)", this.accent = "hsl(270, 50%, 25%)", this.active = "hsl(270, 50%, 65%)", this._prevSelectedColor = "", this.palettes = [
      {
        key: "diva",
        title: "diva (color-blind safe)",
        colors: [
          {
            value: "hsl(227, 26%, 52%)",
            name: "blue-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(13, 58%, 35%)",
            name: "red-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(109, 93%, 24%)",
            name: "green-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(300, 50%, 50%)",
            name: "purple-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(180, 100%, 25%)",
            name: "blue-green-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(40, 98%, 69%)",
            name: "yellow",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(215, 37%, 66%)",
            name: "light blue",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(63, 100%, 23%)",
            name: "olive green",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(34, 57%, 46%)",
            name: "caramel",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(51, 56%, 64%)",
            name: "tan",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(85, 65%, 36%)",
            name: "forest green"
          },
          {
            value: "hsl(12, 56%, 51%)",
            name: "red-orange"
          },
          {
            value: "hsl(30, 42%, 35%)",
            name: "brown"
          },
          {
            value: "hsl(240, 100%, 50%)",
            name: "bright blue"
          },
          {
            value: "hsl(120, 100%, 50%)",
            name: "lime green"
          },
          {
            value: "hsl(39, 100%, 50%)",
            name: "orange",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(300, 100%, 25%)",
            name: "royal purple"
          },
          {
            value: "hsl(51, 100%, 50%)",
            name: "lemon yellow"
          },
          {
            value: "hsl(328, 100%, 54%)",
            name: "fuschia"
          },
          {
            value: "hsl(177, 70%, 41%)",
            name: "cyan"
          },
          {
            value: "hsl(234, 20.5%, 47.8%)",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "warm",
        title: "warm hues (color-blind safe)",
        colors: [
          {
            value: "hsl(38, 96%, 58%)",
            name: "orange"
          },
          {
            value: "hsl(82, 77%, 40%)",
            name: "green"
          },
          {
            value: "hsl(54, 81%, 73%)",
            name: "yellow"
          },
          {
            value: "hsl(22, 97%, 51%)",
            name: "red"
          },
          {
            value: "hsl(77, 98%, 25%)",
            name: "forest green"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "cold",
        title: "cold hues (color-blind safe)",
        colors: [
          {
            value: "hsl(223, 100%, 70%)",
            name: "blue"
          },
          {
            value: "hsl(331, 72%, 51%)",
            name: "pink"
          },
          {
            value: "hsl(23, 100%, 50%)",
            name: "tangerine"
          },
          {
            value: "hsl(251, 83%, 65%)",
            name: "purple"
          },
          {
            value: "hsl(41, 100%, 50%)",
            name: "orange"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "rainbow",
        title: "rainbow (color-blind safe)",
        colors: [
          {
            value: "hsl(270, 100%, 29%)",
            name: "purple"
          },
          {
            value: "hsl(330, 100%, 71%)",
            name: "pink"
          },
          {
            value: "hsl(30, 100%, 43%)",
            name: "cinnamon"
          },
          {
            value: "hsl(180, 100%, 14%)",
            name: "green"
          },
          {
            value: "hsl(210, 100%, 43%)",
            name: "blue"
          },
          {
            value: "hsl(0, 100%, 29%)",
            name: "red"
          },
          {
            value: "hsl(120, 100%, 57%)",
            name: "pale green"
          },
          {
            value: "hsl(60, 100%, 71%)",
            name: "pale yellow"
          },
          {
            value: "hsl(330, 100%, 86%)",
            name: "pale pink"
          },
          {
            value: "hsl(210, 100%, 86%)",
            name: "pale blue"
          },
          {
            value: "hsl(30, 100%, 29%)",
            name: "brown"
          },
          {
            value: "hsl(180, 100%, 29%)",
            name: "blue-gree"
          },
          {
            value: "hsl(270, 100%, 71%)",
            name: "lavendar"
          },
          {
            value: "hsl(210, 100%, 71%)",
            name: "light blue"
          },
          {
            value: "hsl(0, 0%, 0%)",
            name: "black"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "ffb",
        title: "FFB",
        colors: [
          {
            value: "hsl(4, 50%, 52%)",
            //'rgb(210,67,62)',
            name: "red",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(39, 70%, 44%)",
            // rgb(246,171,6)',
            name: "yellow",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(131, 100%, 18%)",
            // 'rgb(33,131,57)',
            name: "green",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(210, 25%, 25%)",
            //'rgb(38,121,153)',
            name: "blue",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(4, 50%, 52%)",
            //'rgb(42,64,81)',
            name: "indigo",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "rgb(13,53,67)",
            name: "slate",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "rgb(48,64,69)",
            name: "dark gray",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(0, 0%, 80%)",
            // 'rgb(204,204,204)',
            name: "light gray",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            name: "no_opinion",
            value: "hsl(0, 0%, 80%)",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            name: "very_unrewarding",
            value: "hsl(4, 50%, 52%)"
          },
          {
            name: "neutral",
            value: "hsl(39, 70%, 44%)"
          },
          {
            name: "somewhat_rewarding",
            value: "hsl(131, 100%, 18%)"
          },
          {
            name: "very_rewarding",
            value: "hsl(210, 25%, 25%)"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "deutan",
        title: "deutan",
        cvd: !0,
        colors: [
          {
            value: "hsl(300, 100%, 25%)",
            name: ""
          },
          {
            value: "hsl(300, 100%, 50%)",
            name: ""
          },
          {
            value: "hsl(320, 100%, 40%)",
            name: ""
          },
          {
            value: "hsl(329, 100%, 49%)",
            name: ""
          },
          {
            value: "hsl(300, 100%, 35%)",
            name: ""
          },
          {
            value: "hsl(210, 43%, 47%)",
            name: ""
          },
          {
            value: "hsl(353, 80%, 67%)",
            name: ""
          },
          {
            value: "hsl(130, 60%, 33%)",
            name: ""
          },
          {
            value: "hsl(52, 57%, 53%)",
            name: ""
          },
          {
            value: "hsl(195, 80%, 67%)",
            name: ""
          },
          {
            value: "hsl(326, 54%, 43%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "protan",
        title: "protan",
        cvd: !0,
        colors: [
          {
            value: "hsl(39, 70%, 54%)",
            name: ""
          },
          {
            value: "hsl(206, 68%, 66%)",
            name: ""
          },
          {
            value: "hsl(154, 39%, 44%)",
            name: ""
          },
          {
            value: "hsl(56, 81%, 66%)",
            name: ""
          },
          {
            value: "hsl(209, 57%, 43%)",
            name: ""
          },
          {
            value: "hsl(24, 68%, 46%)",
            name: ""
          },
          {
            value: "hsl(324, 35%, 62%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "tritan",
        title: "tritan",
        cvd: !0,
        colors: [
          {
            value: "hsl(210, 60%, 67%)",
            name: ""
          },
          {
            value: "hsl(200, 100%, 80%)",
            name: ""
          },
          {
            value: "hsl(163, 47%, 50%)",
            name: ""
          },
          {
            value: "hsl(67, 60%, 50%)",
            name: ""
          },
          {
            value: "hsl(60, 100%, 33%)",
            name: ""
          },
          {
            value: "hsl(50, 75%, 73%)",
            name: ""
          },
          {
            value: "hsl(348, 100%, 83%)",
            name: ""
          },
          {
            value: "hsl(210, 60%, 67%)",
            name: ""
          },
          {
            value: "hsl(200, 100%, 80%)",
            name: ""
          },
          {
            value: "hsl(163, 47%, 50%)",
            name: ""
          },
          {
            value: "hsl(67, 60%, 50%)",
            name: ""
          },
          {
            value: "hsl(60, 100%, 33%)",
            name: ""
          },
          {
            value: "hsl(50, 75%, 73%)",
            name: ""
          },
          {
            value: "hsl(348, 100%, 83%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "grayscale",
        title: "grayscale",
        cvd: !0,
        colors: [
          {
            value: "hsl(0, 0%, 15%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 35%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 50%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 63%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 73%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 83%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 93%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 15%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 35%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 50%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 63%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 73%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 83%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 93%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "pattern",
        title: "pattern",
        isPattern: !0,
        colors: [
          {
            value: "hsl(225, 30%, 52%)",
            name: "blue"
          },
          {
            value: "hsl(12, 69%, 35%)",
            name: "red"
          },
          {
            value: "hsl(75, 43%, 45%)",
            name: "green"
          },
          {
            value: "hsl(40, 98%, 69%)",
            name: "yellow"
          },
          {
            value: "hsl(215, 37%, 66%)",
            name: "light blue"
          },
          {
            value: "hsl(63, 100%, 23%)",
            name: "olive green"
          },
          {
            value: "hsl(34, 57%, 46%)",
            name: "caramel"
          },
          {
            value: "hsl(51, 56%, 64%)",
            name: "tan"
          },
          {
            value: "hsl(253, 26%, 43%)",
            name: "purple"
          },
          {
            value: "hsl(85, 65%, 36%)",
            name: "forest green"
          },
          {
            value: "hsl(12, 56%, 51%)",
            name: "red-orange"
          },
          {
            value: "hsl(30, 42%, 35%)",
            name: "brown"
          },
          {
            value: "hsl(240, 100%, 50%)",
            name: "bright blue"
          },
          {
            value: "hsl(120, 100%, 50%)",
            name: "lime green"
          },
          {
            value: "hsl(39, 100%, 50%)",
            name: "orange"
          },
          {
            value: "hsl(300, 100%, 25%)",
            name: "royal purple"
          },
          {
            value: "hsl(51, 100%, 50%)",
            name: "lemon yellow"
          },
          {
            value: "hsl(328, 100%, 54%)",
            name: "fuschia"
          },
          {
            value: "hsl(177, 70%, 41%)",
            name: "cyan"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ],
        patterns: [
          {
            value: Ie`
              <pattern id="Pattern0"  patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(45)">
                <line class="pattern" x1="0" y="0" x2="0" y2="10" stroke='hsl(225, 30%, 52%)' stroke-width="5" />
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "diagonal_lines"
          },
          {
            value: Ie`
              <pattern id="Pattern1" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10">
                <circle cx="5" cy="5" r="2" fill='hsl(12, 69%, 35%)' />
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "dots"
          },
          {
            value: Ie`
              <pattern id="Pattern2" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10">
                <path d="M 10 0 L 0 0 0 10" fill="none" stroke='hsl(75, 43%, 45%)' stroke-width="5"/>
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "grid"
          },
          {
            value: Ie`
              <pattern id="Pattern3" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10">
                <path d="M 0 0 L 10 10 M 10 0 L 0 10" stroke='hsl(40, 98%, 69%)' stroke-width="3"/>
              </pattern>
               `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "crosshatch"
          },
          {
            value: Ie`
              <pattern id="Pattern4" class="pattern" patternUnits="userSpaceOnUse" width="20" height="10">
                <path d="M 0 5 Q 5 0, 10 5 T 20 5" fill="none" stroke='hsl(215, 37%, 66%)' stroke-width="3"/>
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "waves"
          },
          {
            value: Ie`
              <pattern id="Pattern5" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(135)">
                <line x1="0" y="0" x2="0" y2="10" stroke='hsl(63, 100%, 23%)' stroke-width="5" />
              </pattern>`,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "diagonal_lines2"
          },
          {
            value: Ie`
              <pattern id="Pattern6" class="pattern" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
              <circle cx="10" cy="10" r="10" fill='hsl(34, 57%, 46%)'" />
              </pattern>`,
            contrastValue: "hsl(0, 0%, 0%)",
            name: ""
          },
          {
            value: Ie`hsl(0, 100%, 50%)`,
            name: "visit"
          }
        ]
      },
      {
        key: "low-vision",
        title: "low-vision",
        colors: [
          {
            value: "hsl(240, 100%, 60%)",
            name: "blue-2",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(13, 58%, 35%)",
            name: "red-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(120, 100%, 33%)",
            name: "green-2",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(300, 77%, 54%)",
            name: "magenta-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(39, 100%, 31%)",
            name: "brown-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(40, 98%, 69%)",
            name: "yellow",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(215, 37%, 66%)",
            name: "light blue",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(63, 100%, 23%)",
            name: "olive green",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(34, 57%, 46%)",
            name: "caramel",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(51, 56%, 64%)",
            name: "tan",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(85, 65%, 36%)",
            name: "forest green"
          },
          {
            value: "hsl(12, 56%, 51%)",
            name: "red-orange"
          },
          {
            value: "hsl(30, 42%, 35%)",
            name: "brown"
          },
          {
            value: "hsl(240, 100%, 50%)",
            name: "bright blue"
          },
          {
            value: "hsl(120, 100%, 50%)",
            name: "lime green"
          },
          {
            value: "hsl(39, 100%, 50%)",
            name: "orange",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(300, 100%, 25%)",
            name: "royal purple"
          },
          {
            value: "hsl(51, 100%, 50%)",
            name: "lemon yellow"
          },
          {
            value: "hsl(328, 100%, 54%)",
            name: "fuschia"
          },
          {
            value: "hsl(177, 70%, 41%)",
            name: "cyan"
          },
          {
            value: "hsl(234, 20.5%, 47.8%)",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      }
    ], t.settings.color.colorMap && this.setColorMap(...t.settings.color.colorMap.split(",").map((r) => r.trim()));
  }
  get paletteKey() {
    return this._store.settings.color.colorVisionMode === "normal" ? this._store.settings.color.colorPalette : this._store.settings.color.colorVisionMode;
  }
  get palette() {
    const t = this.palettes[this.indexOfPalette(this.paletteKey)];
    if (t)
      return t;
    throw new Error(`no palette named '${this.paletteKey}'`);
  }
  get prevSelectedColor() {
    return this._prevSelectedColor;
  }
  setColorMap(...t) {
    t.includes("visit") || t.push("visit");
    for (const r of t) {
      const n = this.colorIndex(r);
      if (n === -1)
        throw new Error(`no color named '${r}' in current palette`);
      this._colorMap || (this._colorMap = []), this._colorMap.push(n);
    }
  }
  addPalette(t) {
    this.palettes.push(t);
  }
  indexOfPalette(t) {
    return this.palettes.findIndex((r) => r.key === t);
  }
  colorAt(t) {
    var r;
    return ((r = this.palette.colors[t]) == null ? void 0 : r.name) ?? "default";
  }
  /**
   * Wrap color index if out of range.
   * @param index
   * @returns valid index
   */
  wrapColorIndex(t) {
    return t % this.palette.colors.length;
  }
  /**
   * Get palette index of a color.
   * @param name
   * @returns index or -1 if not found
   */
  colorIndex(t) {
    return this.palette.colors.findIndex((r) => r.name === t);
  }
  /**
   * Get palette index of a color value.
   * @param value
   * @returns index or -1 if not found
   */
  colorValueIndex(t) {
    return this.palette.colors.findIndex((r) => r.value === t);
  }
  colorValue(t) {
    if (t === "default")
      return "hsl(0, 0%, 50%)";
    const r = this.palette.colors.find((n) => n.name === t);
    if (!r)
      throw new Error(`no color named '${t}'`);
    return r.value;
  }
  colorValueAt(t) {
    const r = this._colorMap ? this._colorMap.map((n) => this.palette.colors[n]) : this.palette.colors;
    return t === -1 ? r.at(-1).value : t === -2 ? r.at(-2).value : r[t % (r.length - 1)].value;
  }
  patternValueAt(t) {
    const r = this.palette.patterns;
    return t === -1 ? r.at(-1).value : r[t % (r.length - 1)].value;
  }
  contrastValueAt(t) {
    const r = this.palette.isPattern ? this.palette.patterns : this._colorMap ? this._colorMap.map((n) => this.palette.colors[n]) : this.palette.colors;
    return t === -1 ? r.at(-1).contrastValue : r[t % (r.length - 1)].contrastValue ?? "hsl(0, 0%, 100%)";
  }
  registerKey(t) {
    this.keys.has(t) || this.keys.set(t, {
      index: this.keys.size,
      base: null,
      light: null,
      dark: null
    });
  }
  getPaletteList() {
  }
  // set_colors(color_obj: Colors) {
  //   if (!color_obj.palette) {
  //     // if no palette, use the default palette
  //     this.setPalette(0);
  //   } else {
  //     // if palette, append the default palette to the supplied palette, for more values
  //     this.palette = color_obj.palette.concat(this.palette);
  //   }
  //   this.primary = color_obj.primary;
  //   this.accent = color_obj.accent;
  //   this.active = color_obj.active;
  // }
  selectPaletteWithKey(t) {
    this._prevSelectedColor = this.paletteKey, this._store.updateSettings((r) => {
      r.color.colorPalette = t;
    });
  }
  /*get_palettes  ( palette_ids ) {
      if (!palette_ids) {
        return this.palettes;
      }
  
      if ( `string` === typeof palette_ids) {
        return this.palettes[palette_ids];
      }
  
      let palettes = [];
      for (let i = 0, i_len = palette_ids.length; i_len > i; ++i) {
        let palette = this.palettes[palette_ids[i]];
        if (!palette) {
          palette = this.palettes[`palette-${palette_ids[i]}`];
        }
  
        if (palette) {
          palettes.push(palette);
        }
      }
      return palettes;
    }*/
  /*set_palette_color_by_index  ( palette_id, index, color ) {
    let palette = this.palettes[palette_id];
    if (palette) {
      palette[index] = color;
    }
  }*/
  /*create_palette  ( id, colors, metadata ) {
    let palette = this.palettes[id];
    if (!palette) {
      this.palettes[id] = {};
      palette = this.palettes[id];
    }
    palette.name = metadata.name;
    palette.title = metadata.title;
    palette.type = metadata.type;
    palette.colors = colors;
  }*/
  getHslComponents(t) {
    let r = /hsl[a]?\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/, n = t.match(r);
    return {
      hue: +n[1],
      h: +n[1],
      saturation: +n[2],
      s: +n[2],
      lightness: +n[3],
      l: +n[3],
      alpha: 1,
      a: 1
    };
  }
  lighten(t, r) {
    let n = this.getHslComponents(t), i = n.hue, s = n.saturation, o = n.lightness;
    const a = Math.min(o + r * 5, 100);
    return `hsl(${i}, ${s}%, ${a}%)`;
  }
  generateSequentialPalette(t, r, n) {
    let i = this.getHslComponents(t), s = i.hue, o = i.saturation, a = i.lightness, l = o - 15;
    n && (l = 85 - o);
    let c = Math.round(l / r / 5), h = a - 15;
    n && (h = 85 - a);
    let u = Math.round(h / r), p = [];
    for (let y = 0, g = r; g > y; ++y)
      p.push(`hsl(${s}, ${o}%, ${a}%)`), n ? (o += c, a += u) : (o -= c, a -= u);
    return p;
  }
  /*generate_interpolation_palette  ( hsl1, hsl2, count, palette_id ) {
      let hsl_comp1 = this.getHslComponents(hsl1);
      let h1 = hsl_comp1.hue;
      let s1 = hsl_comp1.saturation;
      let l1 = hsl_comp1.lightness;
  
      let hsl_comp2 = this.getHslComponents(hsl2);
      let h2 = hsl_comp2.hue;
      let s2 = hsl_comp2.saturation;
      let l2 = hsl_comp2.lightness;
  
      count -= 1;
  
      let h_range = h1 - h2;
      let h_interval = h_range/count;
  
      let s_range = s1 - s2;
      let s_interval = s_range/count;
  
      let l_range = l1 - l2;
      let l_interval = l_range/count;
  
      let palette = [];
      for (let i = 0, i_len = count; i_len > i; ++i) {
        palette.push(`hsl(${Math.round(h1)}, ${Math.round(s1)}%, ${Math.round(l1)}%)`);
        h1 -= h_interval;
        s1 -= s_interval;
        l1 -= l_interval;
      }
      palette.push(`hsl(${h2}, ${s2}%, ${l2}% )`);
  
      this.create_palette( palette_id, palette,
        {
          name: palette_id,
          title: palette_id,
          type: `numeric`
        }
      )
    }*/
  /*hsl_to_hex (h, s, l) {
    // function credit to https://stackoverflow.com/questions/7609130/set-the-value-of-an-input-field
    h /= 360;
    s /= 100;
    l /= 100;
    let r, g, b;
    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    const toHex = x => {
      const hex = Math.round(x * 255).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }*/
  //https://stackoverflow.com/questions/46432335/hex-to-hsl-convert-javascript
  /*hex_to_hsl (hex, is_formatted) {
      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  
      let r = parseInt(result[1], 16);
      let g = parseInt(result[2], 16);
      let b = parseInt(result[3], 16);
  
      r /= 255, g /= 255, b /= 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
  
      if(max == min){
          h = s = 0; // achromatic
      } else {
          let d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch(max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
      }
  
      s = s*100;
      s = Math.round(s);
      l = l*100;
      l = Math.round(l);
      h = Math.round(360*h);
  
      let colorInHSL=[h,s,l];
      if (!is_formatted) {
        return colorInHSL;
      } else {
        return `hsl(${h}, ${s}%, ${l}%)`;
      }
    }*/
}
const wbt = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left",
  topLeft: "bottomRight",
  topRight: "bottomLeft",
  bottomRight: "topLeft",
  bottomLeft: "topRight"
};
function xbt(e, t = 2, r = !0) {
  return r && Math.trunc(e) === e ? e.toString() : e.toFixed(t);
}
function ee(e, ...t) {
  if (t.length === 0)
    return e[0];
  const r = e.slice(0, -1).map((n, i) => n + (typeof t[i] == "number" ? xbt(t[i]) : t[i]));
  return r.push(e.at(-1)), r.join("");
}
function nEt(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function Ebt(e, t) {
  e = e.replace(/\s+/g, "_").replace(/[^\w-]+/g, "");
  let r = 0, n = e;
  for (; t.idList[n]; )
    n = e + "-" + ++r;
  return t.idList[n] = !0, n;
}
function iEt() {
  return null;
}
function sEt(...e) {
  return new DOMRect(
    Math.min(...e.map((t) => t.left)),
    Math.min(...e.map((t) => t.top)),
    Math.max(...e.map((t) => t.width)),
    Math.max(...e.map((t) => t.height))
  );
}
function D4(...e) {
  const t = Math.min(...e.map((s) => s.left)), r = Math.max(...e.map((s) => s.right)), n = Math.min(...e.map((s) => s.top)), i = Math.max(...e.map((s) => s.bottom));
  return new DOMRect(
    t,
    n,
    r - t,
    i - n
  );
}
function oEt(e, t, r) {
  return e.seriesKey === t && e.index === r;
}
function Abt(e) {
  return wbt[e];
}
function Sbt(e, t) {
  return !(t.offsetX - e.documentView.padding.left - e.documentView.chartLayers.x < 0 || t.offsetX - e.documentView.padding.left - e.documentView.chartLayers.x > e.documentView.chartLayers.width || t.offsetY - e.documentView.padding.top - e.documentView.chartLayers.y < 0 || t.offsetY - e.documentView.padding.top - e.documentView.chartLayers.y > e.documentView.chartLayers.height);
}
class qt {
  constructor(t = 0, r = 0) {
    this._x = t, this._y = r;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t;
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t;
  }
  clone() {
    return new qt(this._x, this._y);
  }
  equal(t) {
    return this._x === t._x && this._y === t._y;
  }
  setX(t) {
    return new qt(t, this._y);
  }
  setY(t) {
    return new qt(this._x, t);
  }
  add(t) {
    return new qt(
      this._x + t._x,
      this._y + t._y
    );
  }
  addScalar(t) {
    return new qt(
      this._x + t,
      this._y + t
    );
  }
  addX(t) {
    return new qt(
      this._x + t,
      this._y
    );
  }
  addY(t) {
    return new qt(
      this._x,
      this._y + t
    );
  }
  subtract(t) {
    return new qt(
      this._x - t._x,
      this._y - t._y
    );
  }
  subtractScalar(t) {
    return new qt(
      this._x - t,
      this._y - t
    );
  }
  subtractX(t) {
    return new qt(
      this._x - t,
      this._y
    );
  }
  subtractY(t) {
    return new qt(
      this._x,
      this._y - t
    );
  }
  multiply(t) {
    return new qt(
      this._x * t._x,
      this._y * t._y
    );
  }
  multiplyScalar(t) {
    return new qt(
      this._x * t,
      this._y * t
    );
  }
  divide(t) {
    return new qt(
      this._x / t._x,
      this._y / t._y
    );
  }
  divideScalar(t) {
    return new qt(
      this._x / t,
      this._y / t
    );
  }
  dot(t) {
    return this._x * t._x + this._y * t._y;
  }
  length() {
    return Math.sqrt(this.dot(this));
  }
  normalize() {
    return this.divideScalar(this.length());
  }
  project(t) {
    return t.multiplyScalar(this.dot(t) / t.dot(t));
  }
  rotate(t) {
    const r = Math.cos(t), n = Math.sin(t), i = -n, s = r;
    return new qt(
      this._x * r + this._y * n,
      this._x * i + this._y * s
    );
  }
  lerp(t, r) {
    return new qt(
      this._x * (1 - r) + t._x * r,
      this._y * (1 - r) + t._y * r
    );
  }
}
class _bt {
  constructor(t, r, n, i) {
    this._centerDiffX = t, this._centerDiffY = r, this._rSumX = n, this._rSumY = i;
  }
  // {+x, -x, +y, -y}, shortest
  escape() {
    const r = [0, 0, 0, 0];
    this._centerDiffX > 0 ? (r[0] = this._rSumX - this._centerDiffX + 1e-3, r[1] = -(this._rSumX + this._centerDiffX + 1e-3)) : (r[0] = this._rSumX - this._centerDiffX + 1e-3, r[1] = -(this._rSumX + this._centerDiffX + 1e-3)), this._centerDiffY > 0 ? (r[2] = this._rSumY - this._centerDiffY + 1e-3, r[3] = -(this._rSumY + this._centerDiffY + 1e-3)) : (r[2] = this._rSumY - this._centerDiffY + 1e-3, r[3] = -(this._rSumY + this._centerDiffY + 1e-3));
    let n = 0;
    for (let i = 1; i < 4; i++)
      Math.abs(r[i]) < Math.abs(r[n]) && (n = i);
    return {
      dists: r,
      shortest: n
    };
  }
  escapeVector() {
    const r = this._rSumX - Math.abs(this._centerDiffX), n = this._rSumY - Math.abs(this._centerDiffY), i = { x: 0, y: 0 };
    return r < n ? i.x = this._centerDiffX > 0 ? r + 1e-3 : -r - 1e-3 : i.y = this._centerDiffY > 0 ? n + 1e-3 : -n - 1e-3, i;
  }
}
class kbt {
  constructor() {
    this.isContainer = !1;
  }
  get id() {
    return "";
  }
  get x() {
    return 0;
  }
  get y() {
    return 0;
  }
  get width() {
    return 0;
  }
  get height() {
    return 0;
  }
  set width(t) {
  }
  set height(t) {
  }
  get children() {
    return [];
  }
  get padding() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  set padding(t) {
  }
  get hidden() {
    return !1;
  }
  set hidden(t) {
  }
  get el() {
    return null;
  }
  get styleInfo() {
    return {};
  }
  get classInfo() {
    return {};
  }
  renderChildren() {
    return Ie`${this.children.map((t) => t.render())}`;
  }
  content(...t) {
    return this.renderChildren();
  }
  render(...t) {
    return this.hidden ? Ie`` : this.content(...t);
  }
}
class Er extends kbt {
  constructor(t) {
    super(), this.paraview = t, this._parent = null, this._prev = null, this._next = null, this._children = [], this._loc = new qt(), this._locOffset = new qt(), this._width = -1, this._height = -1, this._canWidthFlex = !1, this._canHeightFlex = !1, this._isBubbleSizeChange = !1, this._currFocus = null, this._padding = { top: 0, bottom: 0, left: 0, right: 0 }, this._hidden = !1, this._styleInfo = {}, this._classInfo = {}, this._isObserveStore = !1, this._isObserveNotices = !1;
  }
  get id() {
    return this._id;
  }
  set id(t) {
    this._id = t, this.paraview.requestUpdate();
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    if (t && this._parent)
      throw new Error("parent already set");
    if (!t) {
      if (this._parent) {
        this._parent._children.splice(this.index, 1);
        const r = this._parent;
        this._parent = null, this._prev && (this._prev._next = this._next), this._next && (this._next._prev = this._prev), this._prev = null, this._next = null, this._removedFromParent(), r._didRemoveChild(this);
      }
      return;
    }
    this._width === -1 && this._height === -1 && this.updateSize(), this._parent = t, this.index && (this._prev = t.children[this.index - 1], this._prev._next = this), this._next = t._children[this.index + 1] ?? null, this._next && (this._next._prev = this), this._addedToParent(), this._parent._didAddChild(this), this._id || (this.id = this._createId());
  }
  _createId(...t) {
    return "";
  }
  _addedToParent() {
  }
  _removedFromParent() {
  }
  _didAddChild(t) {
  }
  _didRemoveChild(t) {
  }
  get children() {
    return this._children;
  }
  get index() {
    var t;
    return ((t = this._parent) == null ? void 0 : t._children.indexOf(this)) ?? -1;
  }
  get isFocused() {
    return this._parent.currFocus === this;
  }
  get loc() {
    return this._loc.clone();
  }
  set loc(t) {
    this._loc = t;
  }
  get locOffset() {
    return this._locOffset.clone();
  }
  set locOffset(t) {
    this._locOffset = t;
  }
  // XXX These next 4 accessors are for legacy compatibility
  get _x() {
    return this._loc.x;
  }
  set _x(t) {
    this._loc.x = t;
  }
  get _y() {
    return this._loc.y;
  }
  set _y(t) {
    this._loc.y = t;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(t) {
    this._x = t;
  }
  set y(t) {
    this._y = t;
  }
  get width() {
    return this._hidden ? 0 : this._width;
  }
  get height() {
    return this._hidden ? 0 : this._height;
  }
  set width(t) {
    const r = this._width;
    this._width = t, r !== t && this._boundingSizeDidChange(r, this._height);
  }
  set height(t) {
    const r = this._height;
    this._height = t, r !== t && this._boundingSizeDidChange(this._width, r);
  }
  get paddedWidth() {
    return this._hidden ? 0 : this.width + this._padding.left + this._padding.right;
  }
  get paddedHeight() {
    return this._hidden ? 0 : this.height + this._padding.top + this._padding.bottom;
  }
  get padding() {
    return this._padding;
  }
  set padding(t) {
    const r = this._padding.top + this._padding.bottom, n = this._padding.left + this._padding.right;
    this._padding = this._expandPadding(t), (r !== this._padding.top + this._padding.bottom || n !== this._padding.left + this._padding.right) && this._boundingSizeDidChange(n + this._width, r + this._height);
  }
  _expandPadding(t, r) {
    if (typeof t == "number")
      return { top: t, bottom: t, left: t, right: t };
    {
      let n = {};
      return t.all !== void 0 && (n = { top: t.all, bottom: t.all, left: t.all, right: t.all }), t.horiz !== void 0 && (n.left = t.horiz, n.right = t.horiz), t.vert !== void 0 && (n.top = t.vert, n.bottom = t.vert), t.top !== void 0 && (n.top = t.top), t.bottom !== void 0 && (n.bottom = t.bottom), t.left !== void 0 && (n.left = t.left), t.right !== void 0 && (n.right = t.right), n.left === void 0 && (n.left = (r == null ? void 0 : r.left) ?? 0), n.right === void 0 && (n.right = (r == null ? void 0 : r.right) ?? 0), n.top === void 0 && (n.top = (r == null ? void 0 : r.top) ?? 0), n.bottom === void 0 && (n.bottom = (r == null ? void 0 : r.bottom) ?? 0), n;
    }
  }
  get canWidthFlex() {
    return this._canWidthFlex;
  }
  set canWidthFlex(t) {
    this._canWidthFlex = t;
  }
  get canHeightFlex() {
    return this._canHeightFlex;
  }
  set canHeightFlex(t) {
    this._canHeightFlex = t;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(t) {
    const r = this.paddedWidth, n = this.paddedHeight;
    this._hidden = t, (r || n) && this._boundingSizeDidChange(r, n);
  }
  get left() {
    return this._x - this._locOffset.x;
  }
  set left(t) {
    this._x = t + this._locOffset.x;
  }
  get paddedLeft() {
    return this.left - this._padding.left;
  }
  set paddedLeft(t) {
    this._x = t + this._padding.left + this._locOffset.x;
  }
  get right() {
    return this.left + this.width;
  }
  set right(t) {
    this._x = t - this.width + this._locOffset.x;
  }
  get paddedRight() {
    return this.right + this._padding.right;
  }
  set paddedRight(t) {
    this._x = t - this._padding.right - this.width + this._locOffset.x;
  }
  get centerX() {
    return this.left + this.width / 2;
  }
  set centerX(t) {
    this._x = t - this.width / 2 + this._locOffset.x;
  }
  get top() {
    return this._y - this._locOffset.y;
  }
  set top(t) {
    this._y = t + this._locOffset.y;
  }
  get paddedTop() {
    return this.top - this._padding.top;
  }
  set paddedTop(t) {
    this._y = t + this._padding.top + this._locOffset.y;
  }
  get bottom() {
    return this.top + this.height;
  }
  set bottom(t) {
    this._y = t - this.height + this._locOffset.y;
  }
  get paddedBottom() {
    return this.bottom + this._padding.bottom;
  }
  set paddedBottom(t) {
    this._y = t - this._padding.bottom - this.height + this._locOffset.y;
  }
  get centerY() {
    return this.top + this.height / 2;
  }
  set centerY(t) {
    this._y = t - this.height / 2 + this._locOffset.y;
  }
  get bbox() {
    return new DOMRect(this.left, this.top, this.width, this.height);
  }
  /**
   * Bounding box inclusive of stroke width
   */
  get outerBbox() {
    return this.bbox;
  }
  computeSize() {
    return [this.width, this.height];
  }
  setSize(t, r, n = !0) {
    const i = this._width, s = this._height;
    this._width = t, this._height = r, (i !== this._width || s !== this._height) && this._boundingSizeDidChange(i, s, n);
  }
  resize(t, r) {
    this.setSize(t, r);
  }
  get isBubbleSizeChange() {
    return this._isBubbleSizeChange;
  }
  set isBubbleSizeChange(t) {
    this._isBubbleSizeChange = t;
  }
  _boundingSizeDidChange(t, r, n = !0) {
  }
  _bubbleSizeChange() {
    this._parent._childDidResize(this);
  }
  updateSize(t = !0) {
    this.setSize(...this.computeSize(), t);
  }
  _childDidResize(t) {
  }
  snapXTo(t, r) {
    r === "start" ? this.left = t.left : r === "end" ? this.right = t.right : this.centerX = t.centerX;
  }
  snapYTo(t, r) {
    r === "start" ? this.top = t.top : r === "end" ? this.bottom = t.bottom : this.centerY = t.centerY;
  }
  get styleInfo() {
    return { ...this._styleInfo };
  }
  set styleInfo(t) {
    this._styleInfo = { ...t };
  }
  get classInfo() {
    return { ...this._classInfo };
  }
  set classInfo(t) {
    this._classInfo = { ...t };
  }
  get prev() {
    return this._prev;
  }
  get next() {
    return this._next;
  }
  get siblings() {
    return this._parent.children.filter((t) => t !== this);
  }
  get withSiblings() {
    return this._parent.children;
  }
  get cousins() {
    return this._parent.siblings.map((t) => t.children[this.index]);
  }
  get withCousins() {
    return this._parent.withSiblings.map((t) => t.children[this.index]);
  }
  get nextCousin() {
    return this._parent.next ? this.cousins[this._parent.index] : null;
  }
  get prevCousin() {
    return this._parent.prev ? this.cousins[this._parent.index - 1] : null;
  }
  get currFocus() {
    return this._currFocus;
  }
  set currFocus(t) {
    this._currFocus = t;
  }
  /*get eventActionManager() {
      return this._eventActionManager;
    }
  
    get hotkeyActionManager() {
      return this._hotkeyActionManager;
    }
  
    protected get _eventActions(): Actions<this> {
      return {};
    }
  
    protected get _hotkeyActions(): Actions<this> {
      return {};
    }
  
    get keymap(): KeyRegistrations {
      return {};
    }
  
    protected _setActions() {
      const eventActions = this._eventActions;
      if (Object.keys(eventActions).length) {
        this._eventActionManager = new EventActionManager(this, eventActions);
      }
      this._hotkeyActionManager = new HotkeyActionManager(this, this._hotkeyActions);
    }
  
    updateKeymap() {
      const keyMap = this.keymap;
      if (Object.keys(keyMap).length) {
        this._keymapManager = new KeymapManager(this);
      }
    }
  
    hotkeyInfo(key: string): HotkeyInfo | undefined {
      const action = this._keymapManager?.actionForKey(key);
      if (action) {
        return todo().canvas.hotkeyInfo(key, action, this);
      }
      if (this._parent) {
        return this._parent.hotkeyInfo(key);
      }
      return undefined;
    }*/
  intersects(t) {
    const r = this.centerX - t.centerX, n = t.paddedWidth / 2 + this.paddedWidth / 2;
    if (Math.abs(r) >= n)
      return null;
    const i = this.centerY - t.centerY, s = t.paddedHeight / 2 + this.paddedHeight / 2;
    return Math.abs(i) >= s ? null : new _bt(r, i, n, s);
  }
  async focus(t = !1, r = 0) {
    this._parent && (this._parent.currFocus && this._parent.currFocus !== this && !r && await this._parent.currFocus.blur(!1), this._parent.currFocus = this, await this._parent.focus(t, r + 1), this._currFocus ? r || await this.focusLeaf.onFocus(t) : await this.onFocus(t));
  }
  async onFocus(t = !1) {
  }
  async blur(t = !0) {
    this._parent.currFocus = null, await this.onBlur(), t && await this._parent.onFocus();
  }
  async onBlur() {
  }
  get focusLeaf() {
    return this._currFocus ? this._currFocus.focusLeaf : this;
  }
  _didAddChildToList(t) {
  }
  append(t) {
    this._children.push(t), this._didAddChildToList(t), t.parent = this;
  }
  prepend(t) {
    this._children.unshift(t), this._didAddChildToList(t), t.parent = this;
  }
  insert(t, r) {
    this._children.splice(r, 0, t), this._didAddChildToList(t), t.parent = this;
  }
  remove() {
    this.parent = null;
  }
  reverseChildren() {
    this._children.reverse(), this._children.forEach((t, r) => {
      const n = t._prev;
      t._prev = t._next, t._next = n;
    });
  }
  sortChildren(t) {
    this._children.sort(t), this._children.forEach((r, n) => {
      n === 0 ? r._prev = null : (n === this._children.length - 1 && (r._next = null), r._prev = this._children[n - 1], r._prev._next = r);
    });
  }
  clearChildren() {
    [...this._children].forEach((t) => {
      t.remove();
    });
  }
  replaceChild(t, r) {
    const n = t.index;
    t.remove(), this.insert(r, n);
  }
  settingDidChange(t, r, n) {
    this._children.forEach((i) => i.settingDidChange(t, r, n));
  }
  get isObserveStore() {
    return this._isObserveStore;
  }
  observeStore() {
    this._isObserveStore = !0, this._parent && this._parent.observeStore();
  }
  async storeDidChange(t, r) {
    this._isObserveStore && this._children.forEach((n) => {
      n.isObserveStore && n.storeDidChange(t, r);
    });
  }
  get isObserveNotices() {
    return this._isObserveNotices;
  }
  observeNotices() {
    this._isObserveNotices = !0, this._parent && this._parent.observeNotices();
  }
  noticePosted(t, r) {
    this._isObserveNotices && this._children.forEach((n) => {
      n.isObserveNotices && n.noticePosted(t, r);
    });
  }
  focusRingShape() {
    return null;
  }
  focusRingBbox() {
    return null;
  }
}
function Zs(e) {
  return class extends e {
    constructor() {
      super(...arguments), this.isContainer = !0;
    }
    render() {
      if (this.hidden)
        return Ie``;
      const r = this.x + this.padding.left, n = this.y + this.padding.top;
      return gbt`
        <g
          ${this.ref}
          id=${this.id || Lt}
          class=${Object.keys(this.classInfo).length ? Rr(this.classInfo) : Lt}
          style=${Object.keys(this.styleInfo).length ? ln(this.styleInfo) : Lt}
          role=${this.role || Lt}
          aria-roledescription=${this.roleDescription || Lt}
          transform=${r || n ? ee`translate(${r},${n})` : Lt}
        >
          ${this.content()}
        </g>
      `;
    }
  };
}
class Cbt extends Er {
  _createId() {
    return "chart-landing";
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    super.parent = t;
  }
  get children() {
    return this._children;
  }
  get datapointViews() {
    return this._children.flatMap((t) => t.children);
  }
  get focusLeaf() {
    return super.focusLeaf;
  }
  getSeriesView(t) {
    return this._children.find((r) => r.series.key === t);
  }
  chartSummary() {
    return "At top level.";
  }
}
let WF = class B4 extends Er {
  constructor(t, r) {
    super(t.paraview), this.chart = t, this.seriesKey = r, this._isStyleEnabled = !1, this._series = this.chart.paraview.store.model.atKey(r);
  }
  get series() {
    return this._series;
  }
  get seriesProps() {
    return this.chart.paraview.store.seriesProperties.properties(this.seriesKey);
  }
  get siblings() {
    return super.siblings.filter((t) => t instanceof B4);
  }
  get withSiblings() {
    return super.withSiblings.filter((t) => t instanceof B4);
  }
  get prev() {
    return super.prev;
  }
  get next() {
    return super.next;
  }
  get currFocus() {
    return this._currFocus;
  }
  set currFocus(t) {
    super.currFocus = t;
  }
  get prevFocus() {
    return this._prevFocus;
  }
  get color() {
    return this.seriesProps.color;
  }
  get styleInfo() {
    const t = super.styleInfo;
    return this._isStyleEnabled && this._updateStyleInfo(t), t;
  }
  set styleInfo(t) {
    super.styleInfo = t;
  }
  _updateStyleInfo(t) {
    let r = this.chart.paraview.store.colors.colorValueAt(this.color);
    t.fill = r, t.stroke = r, t.strokeWidth = this.paraview.store.settings.chart.strokeWidth;
  }
  async onFocus(t = !1) {
  }
  select(t) {
  }
};
class Wb extends Er {
  constructor(t, r) {
    super(t), this._role = "", this._ref = null, this._isPattern = !1, this._x = r.x ?? this._x, this._y = r.y ?? this._y, this._scale = r.scale ?? 1, r.strokeWidth && (this._styleInfo.strokeWidth = r.strokeWidth), r.stroke && (this._styleInfo.stroke = r.stroke), r.fill && (this._styleInfo.fill = r.fill), r.opacity !== void 0 && (this._styleInfo.opacity = r.opacity), this._isClip = !!r.isClip;
  }
  get _options() {
    return {
      x: this._x,
      y: this._y,
      fill: this._styleInfo.fill,
      stroke: this._styleInfo.stroke,
      opacity: this._styleInfo.opacity,
      strokeWidth: this._styleInfo.strokeWidth,
      scale: this._scale,
      isClip: this._isClip
    };
  }
  get role() {
    return this._role;
  }
  set role(t) {
    this._role = t;
  }
  get stroke() {
    if (this._styleInfo.stroke)
      return this._styleInfo.stroke;
    let t = this._parent;
    for (; t; ) {
      if (t.styleInfo.stroke)
        return t.styleInfo.stroke;
      t = t.parent;
    }
    return this.paraview.store.settings.chart.stroke;
  }
  set stroke(t) {
    this._styleInfo.stroke = t;
  }
  get strokeWidth() {
    if (this._styleInfo.strokeWidth !== void 0)
      return this._styleInfo.strokeWidth;
    let t = this._parent;
    for (; t; ) {
      if (t.styleInfo.strokeWidth !== void 0)
        return t.styleInfo.strokeWidth;
      t = t.parent;
    }
    return this.paraview.store.settings.chart.strokeWidth;
  }
  set strokeWidth(t) {
    this._styleInfo.strokeWidth = t;
  }
  get effectiveStrokeWidth() {
    return this.stroke === "none" ? 0 : this.strokeWidth;
  }
  get fill() {
    return this._styleInfo.fill;
  }
  set fill(t) {
    this._styleInfo.fill = t;
  }
  get outerBbox() {
    return new DOMRect(
      this.left - this.effectiveStrokeWidth / 2,
      this.top - this.effectiveStrokeWidth / 2,
      this.width + this.effectiveStrokeWidth,
      this.height + this.effectiveStrokeWidth
    );
  }
  get scale() {
    return this._scale;
  }
  set scale(t) {
    this._scale = t;
  }
  get isClip() {
    return this._isClip;
  }
  set isClip(t) {
    this._isClip = t;
  }
  get ref() {
    return this._ref;
  }
  set ref(t) {
    this._ref = t;
  }
}
class qr extends Wb {
  constructor(t, r) {
    super(t, r), this.options = r, this._width = r.width, this._height = r.height, r.isPattern && (this._isPattern = r.isPattern);
  }
  get _options() {
    let t = super._options;
    return t.width = this._width, t.height = this._height, t.isPattern = this._isPattern, t;
  }
  clone() {
    return new qr(this.paraview, this._options);
  }
  render() {
    if (this._options.isPattern) {
      let t = this.parent.parent.index;
      return this._styleInfo.fill = `url(#Pattern${t})`, Ie`
      <defs>${this.paraview.store.colors.patternValueAt(t)}</defs>
      <rect
        x=${ee`${this._x}`}
        y=${ee`${this._y}`}
        width=${ee`${this.width}`}
        height=${ee`${this.height}`}
        fill="white"
        stroke-width=2
      ></rect>
      <rect
        ${this._ref ? ge(this._ref) : void 0}
        id=${this._id || Lt}
        style=${Object.keys(this._styleInfo).length ? ln(this._styleInfo) : Lt}
        class=${Object.keys(this._classInfo).length ? Rr(this._classInfo) : Lt}
        role=${this._role || Lt}
        x=${ee`${this._x}`}
        y=${ee`${this._y}`}
        width=${ee`${this.width}`}
        height=${ee`${this.height}`}
        @pointerenter=${this.options.pointerEnter ?? Lt}
        @pointerleave=${this.options.pointerLeave ?? Lt}
      ></rect>
    `;
    } else
      return Ie`
      <rect
        ${this._ref ? ge(this._ref) : void 0}
        id=${this._id || Lt}
        style=${Object.keys(this._styleInfo).length ? ln(this._styleInfo) : Lt}
        class=${Object.keys(this._classInfo).length ? Rr(this._classInfo) : Lt}
        role=${this._role || Lt}
        x=${ee`${this._x}`}
        y=${ee`${this._y}`}
        width=${ee`${this.width}`}
        height=${ee`${this.height}`}
        clip-path=${this._options.isClip ? "url(#clip-path)" : Lt}
        @pointerenter=${this.options.pointerEnter ?? Lt}
        @pointerleave=${this.options.pointerLeave ?? Lt}
      ></rect>
    `;
  }
}
class md extends WF {
  constructor(t) {
    super(t.chart, t.series.key), this._shapes = [], this._symbol = null, this._baseSymbolScale = 1, this._animStartState = {}, this._animEndState = {};
  }
  _addedToParent() {
    super._addedToParent();
  }
  _removedFromParent() {
    super._removedFromParent(), this._parent.chart.unregisterDatapoint(this);
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    super.parent = t;
  }
  get cousins() {
    return super.cousins;
  }
  get withCousins() {
    return super.withCousins;
  }
  get nextSeriesLanding() {
    return this._parent.next;
  }
  get prevSeriesLanding() {
    return this._parent.prev;
  }
  get datapoint() {
    return this.series.datapoints[this.index];
  }
  /**
   * Identifier of the form: `${seriesKey}-${index}`
   * NB: *NOT* the same as the `id` property (the DOM ID)
   */
  get datapointId() {
    return `${this.seriesKey}-${this.index}`;
  }
  get selectedMarker() {
    return new qr(this.paraview, {
      width: this._width / 2,
      height: this._width / 2,
      x: this._x - this._width / 4,
      y: this._y - this._width / 4,
      fill: "none",
      stroke: "black",
      strokeWidth: 2,
      isClip: this.shouldClip
    });
  }
  get shapes() {
    return [...this._shapes];
  }
  get symbol() {
    return this._symbol;
  }
  set baseSymbolScale(t) {
    this._baseSymbolScale = t;
  }
  get classInfo() {
    return {
      datapoint: !0,
      visited: this.paraview.store.isVisited(this.seriesKey, this.index),
      selected: this.paraview.store.isSelected(this.seriesKey, this.index),
      highlighted: this.chart.chartInfo.isHighlighted(this.seriesKey, this.index)
    };
  }
  get color() {
    return this._isStyleEnabled ? this.index : this._parent.color;
  }
  /**
   * May be overridden to apply shape-specific style info
   * (e.g., if only a particular shape should be highlighted on visitation)
   * @param shapeIndex - Index of the shape in `_shapes`.
   * @returns Style info
   */
  _shapeStyleInfo(t) {
    return this.styleInfo;
  }
  get ref() {
    return this.chart.paraview.ref(this._id);
  }
  get el() {
    return this.ref.value;
  }
  get x() {
    return super.x;
  }
  set x(t) {
    this._shapes.forEach((r) => {
      r.x += t - this._x;
    }), this._symbol && (this._symbol.x += t - this._x), super.x = t;
  }
  get y() {
    return super.y;
  }
  set y(t) {
    this._shapes.forEach((r) => {
      r.y += t - this._y;
    }), this._symbol && (this._symbol.y += t - this._y), super.y = t;
  }
  get shouldClip() {
    const t = this.outerBbox;
    return this.paraview.store.settings.animation.isAnimationEnabled && this.paraview.store.settings.animation.lineSnake ? !0 : t.right < this.chart.x || t.bottom < this.chart.y || t.left > this.chart.right || t.top > this.chart.bottom;
  }
  _createId(...t) {
    const r = this._parent.modelIndex * this._series.length + this.index + 1;
    return this.paraview.store.jimerator.jim.selectors[`datapoint${r}`].dom.slice(1);
  }
  get id() {
    return super.id;
  }
  set id(t) {
    super.id = t, this._parent.chart.registerDatapoint(this);
  }
  /** Compute and set `x` and `y` */
  computeLocation() {
  }
  /** Do any other layout (which may depend on the location being set) */
  completeLayout() {
    if (this._createShapes(), this._createSymbol(), this._children.length === 1) {
      const t = this._children[0];
      t.id = this._id, t.role = "datapoint";
    } else
      this._children.forEach((t, r) => {
        const n = t instanceof Wb ? `${r}` : "sym";
        t.id = `${this._id}-${n}`;
      });
    this.layoutSymbol();
  }
  /**
   *
   * @param t - Value between 0 and 1
   */
  beginAnimStep(t) {
  }
  /**
   *
   * @param t - Value between 0 and 1
   */
  endAnimStep(t) {
    this.completeLayout();
  }
  /**
   * Subclasses should override this;
   * If there will be shapes, add them to `this._shapes` first,
   * THEN call `super._createShapes()`.
   * Otherwise, override with an empty method.
   */
  _createShapes() {
    this._shapes.forEach((t) => {
      this.append(t);
    });
  }
  _createSymbol() {
    var n;
    let r = this.seriesProps.symbol;
    (n = this._symbol) == null || n.remove(), this._symbol = ya.fromType(this.paraview, r), this.append(this._symbol);
  }
  layoutSymbol() {
    this._symbol && (this._symbol.x = this._x, this._symbol.y = this._y);
  }
  get symbolScale() {
    return this.paraview.store.isVisited(this.seriesKey, this.index) ? this.paraview.store.settings.chart.symbolHighlightScale : this.chart.chartInfo.isHighlighted(this.seriesKey, this.index) ? 1 : this._baseSymbolScale;
  }
  get _symbolColor() {
    return this.paraview.store.isVisited(this.seriesKey, this.index) ? -1 : this.color;
  }
  _contentUpdateShapes() {
    this._shapes.forEach((t, r) => {
      t.styleInfo = this._shapeStyleInfo(r);
    });
  }
  _contentUpdateSymbol() {
    this._symbol && (this._symbol.scale = this.symbolScale, this._symbol.color = this._symbolColor, this._symbol.hidden = !this.paraview.store.settings.chart.isDrawSymbols);
  }
  content() {
    if (this._contentUpdateShapes(), this._contentUpdateSymbol(), this._children.length === 1) {
      const t = this._children[0];
      return t.classInfo = this.classInfo, super.content();
    } else
      return Ie`
        <g
          id=${this._id}
          class=${Rr(this.classInfo)}
          role="datapoint"
        >
          ${super.content()}
        </g>`;
  }
  equals(t) {
    return this.datapoint.seriesKey === t.datapoint.seriesKey && this.datapoint.datapointIndex === t.datapoint.datapointIndex;
  }
  addPopup(t) {
  }
  removePopup(t) {
  }
}
class QA extends Zs(WF) {
  constructor(t, r, n) {
    super(t, r), this._isStyleEnabled = n ?? !0;
  }
  _createId() {
    return `series-${Cr(this.seriesKey)}`;
  }
  _seriesRef(t) {
    return this.chart.paraview.ref(`series.${t}`);
  }
  get ref() {
    return ge(this._seriesRef(this._series.key));
  }
  get class() {
    return "series";
  }
  get classInfo() {
    return {
      series: !0,
      lowlight: this.paraview.store.isSeriesLowlighted(this._series.key),
      hidden: this.paraview.store.hiddenSeriesList.includes(this._series.key)
    };
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    super.parent = t;
  }
  // @ts-ignore
  get children() {
    return this._children;
  }
  get modelIndex() {
    return this.paraview.store.model.seriesKeys.indexOf(this.seriesKey);
  }
  _updateStyleInfo(t) {
    super._updateStyleInfo(t), this.chart.updateSeriesStyle(t);
  }
  nextSeriesLanding() {
    return this._next;
  }
  prevSeriesLanding() {
    return this._prev;
  }
}
const Mc = 100;
function Ibt() {
  const e = Math.sqrt(Mc / Math.PI), t = e * 2;
  return {
    path: ee`m0,${-e} a${e},${e} 0 1,1 0,${t} a${e},${e} 0 1,1 0,${-t}`,
    baseWidth: t,
    baseHeight: t
  };
}
function Pbt() {
  const e = Math.sqrt(Mc), t = e / 2;
  return {
    path: `m${-t},${-t} h${e} v${e} h${-e} z`,
    baseWidth: e,
    baseHeight: e
  };
}
function Rbt() {
  const e = Math.sqrt(0.75), t = Math.sqrt(2 * Mc / e), r = t * e;
  return {
    path: ee`m${-t / 2},${r / 2.5} h${t} l${-t / 2},${-r} z`,
    baseWidth: t,
    baseHeight: r
  };
}
function Tbt() {
  const e = Math.sqrt(0.75), t = Math.sqrt(2 * Mc / e), r = t * e;
  return {
    path: ee`m${-t / 2},-${r / 2.5} h${t} l${-t / 2},${r} z`,
    baseWidth: t,
    baseHeight: r
  };
}
function Obt() {
  const e = Math.sqrt(Mc), t = Math.sqrt(2 * e ** 2) / 2;
  return {
    path: ee`
      m0,-${t}
      l${t},${t}
      l-${t},${t}
      l-${t},-${t} z`,
    baseWidth: t * 2,
    baseHeight: t * 2
  };
}
function Lbt() {
  const e = Mc / 5, t = Math.sqrt(e);
  return {
    path: ee`
      m${-t * 1.5},${t / 2}
      h${t}
      v${t}
      h${t}
      v${-t}
      h${t}
      v${-t}
      h${-t}
      v${-t}
      h${-t}
      v${t}
      h${-t} z`,
    baseWidth: t * 3,
    baseHeight: t * 3
  };
}
function Mbt() {
  const e = Mc / 5, t = Math.sqrt(e), r = Math.sqrt(2 * t ** 2) / 2;
  return {
    path: ee`
      m-${r},0
      l-${r},-${r}
      l${r},-${r}
      l${r},${r}
      l${r},-${r}
      l${r},${r}
      l-${r},${r}
      l${r},${r}
      l-${r},${r}
      l-${r},-${r}
      l-${r},${r}
      l-${r},-${r} z`,
    baseWidth: r * 3,
    baseHeight: r * 3
  };
}
function Nbt() {
  const e = Mc / 2, t = Math.sqrt(e / 1.72), n = (100 - e) / 5 * 2 / t, i = Math.sqrt((t / 2) ** 2 + n ** 2), s = 2 * 180 * Math.atan(t / 2 / n) / Math.PI, o = s + 72, a = o - s / 2 - 90, l = Math.cos(a * Math.PI / 180) * i, c = Math.sin(a * Math.PI / 180) * i, u = 180 - (90 - a) - s, p = 90 - u, y = o - p, g = Math.sin(u * Math.PI / 180) * i, b = Math.cos(u * Math.PI / 180) * i, f = Math.cos(y * Math.PI / 180) * i, E = Math.sin(y * Math.PI / 180) * i, A = Math.sin(o / 2 * Math.PI / 180) * i, x = Math.cos(o / 2 * Math.PI / 180) * i, m = 0.6682 * t;
  return {
    path: ee`
      m-${t / 2},-${m}
      l${t / 2},-${n}
      l${t / 2},${n}
      l${l},${c}
      l-${g},${b}
      l${f},${E}
      l-${A},-${x}
      l-${A},${x}
      l${f},-${E}
      l-${g},-${b} z`,
    baseWidth: l * 2 + t,
    baseHeight: n + c + +b + E
  };
}
const Yw = {
  circle: Ibt(),
  square: Pbt(),
  triangle_up: Rbt(),
  triangle_down: Tbt(),
  diamond: Obt(),
  plus: Lbt(),
  x: Mbt(),
  star: Nbt()
};
class ya extends Er {
  constructor(t, r, n, i) {
    super(t), this._role = "", this._options = {
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? this.paraview.store.settings.chart.symbolStrokeWidth,
      scale: (i == null ? void 0 : i.scale) ?? 1,
      color: i == null ? void 0 : i.color,
      opacity: i == null ? void 0 : i.opacity,
      dashed: (i == null ? void 0 : i.dashed) ?? !1,
      lighten: (i == null ? void 0 : i.lighten) ?? !1,
      isClip: (i == null ? void 0 : i.isClip) ?? !1,
      pointerEnter: i == null ? void 0 : i.pointerEnter,
      pointerLeave: i == null ? void 0 : i.pointerLeave
    }, this.type = `${r}.${n}`, this._locOffset.x = this.width / 2, this._locOffset.y = this.height / 2, this._updateStyleInfo(), this._classInfo = {
      symbol: !0,
      [n]: !0
    };
  }
  static fromType(t, r, n) {
    let i, s;
    return r === "default" ? (i = "circle", s = "outline", n ?? (n = {}), n.dashed = !0) : [i, s] = r.split("."), new ya(t, i, s, n);
  }
  get type() {
    return this._type;
  }
  set type(t) {
    this._type = t;
    const [r, n] = t.split(".");
    this._defsKey = `sym-${r}-${n}`, this.paraview.defs[this._defsKey] || this.paraview.addDef(this._defsKey, Ie`
        <path
          id=${this._defsKey}
          d=${Yw[this.shape].path}
        />
      `), this._updateStyleInfo();
  }
  get width() {
    return Yw[this.shape].baseWidth * this._options.scale;
  }
  get height() {
    return Yw[this.shape].baseHeight * this._options.scale;
  }
  get outerBbox() {
    return new DOMRect(
      this._x - this.width / 2 - this._options.scale * this._options.strokeWidth / 2,
      this._y - this.height / 2 - this._options.scale * this._options.strokeWidth / 2,
      this.width + this._options.scale * this._options.strokeWidth,
      this.height + this._options.scale * this._options.strokeWidth
    );
  }
  get shape() {
    return this._type.split(".")[0];
  }
  set shape(t) {
    this.type = t + "." + this._type.split(".")[1];
  }
  get fill() {
    return this._type.split(".")[1];
  }
  set fill(t) {
    this.type = this._type.split(".")[0] + "." + t, this._updateStyleInfo();
  }
  get color() {
    return this._options.color;
  }
  set color(t) {
    this._options.color = t, this._updateStyleInfo();
  }
  get opacity() {
    return this._options.opacity;
  }
  set opacity(t) {
    this._options.opacity = t, this._updateStyleInfo();
  }
  get scale() {
    return this._options.scale;
  }
  set scale(t) {
    this._options.scale = t;
  }
  get role() {
    return this._role;
  }
  set role(t) {
    this._role = t;
  }
  clone() {
    const t = ya.fromType(this.paraview, this._type, this._options);
    return t.x = this._x, t.y = this._y, t;
  }
  _updateStyleInfo() {
    if (this._styleInfo = {
      strokeWidth: this._options.strokeWidth
    }, this._options.dashed && (this._styleInfo.strokeDasharray = "1px 2px"), this._options.color !== void 0) {
      if (this.fill === "solid")
        if (this._options.lighten) {
          const t = this.paraview.store.colors.colorValueAt(
            this._options.color
          ).match(/\d+/g).map(Number);
          t[1] -= Math.min(10, t[1]), t[2] += Math.min(25, 100 - t[2]), this._styleInfo.fill = `hsl(${t[0]}, ${t[1]}%, ${t[2]}%)`;
        } else
          this._styleInfo.fill = this.paraview.store.colors.colorValueAt(
            this._options.color
          );
      else this.fill === "outline" ? this._styleInfo.fill = "white" : this._styleInfo.fill = "none";
      this._options.opacity !== void 0 && (this._styleInfo.opacity = this._options.opacity), this._styleInfo.stroke = this.paraview.store.colors.colorValueAt(
        this._options.color
      );
    }
  }
  content() {
    let t = ee`translate(${this._x},${this._y})`;
    return this._options.scale !== 1 && (t += ee` scale(${this._options.scale})`), this.paraview.store.type, this.parent instanceof md && (this._y < 0 || this._y > this.parent.chart.parent.logicalHeight) && (this.hidden = !0), this.hidden ? Ie`` : Ie`
      <use
        href="#${this._defsKey}"
        id=${this._id || Lt}
        role=${this._role || Lt}
        style=${Object.keys(this._styleInfo).length ? ln(this._styleInfo) : Lt}
        class=${Object.keys(this._classInfo).length ? Rr(this._classInfo) : Lt}
        transform=${t}
        @pointerenter=${this._options.pointerEnter ?? Lt}
        @pointerleave=${this._options.pointerLeave ?? Lt}
        clip-path=${/*this._options.isClip ? 'url(#clip-path)' :*/
    Lt}
      />
    `;
  }
}
class qF {
  constructor() {
    this.shapes = [
      "circle",
      "square",
      "triangle_up",
      "diamond",
      "plus",
      "star",
      "triangle_down",
      "x"
    ], this.fills = [
      "outline",
      "solid"
    ], this.types = this.fills.flatMap((t) => this.shapes.map((r) => `${r}.${t}`));
  }
  symbolAt(t) {
    return this.types[t] ?? "default";
  }
}
class oI {
  constructor(t) {
    this.store = t, this.seriesList = t.model.series.map((r, n) => new Dbt(r.key, t.colors.wrapColorIndex(n), t.symbols.symbolAt(n)));
  }
  properties(t) {
    const r = this.seriesList.find((n) => n.key === t);
    if (!r)
      throw new Error(`no properties for series key '${t}'`);
    return r;
  }
}
class Dbt {
  constructor(t, r, n) {
    this.key = t, this.color = r, this.symbol = n;
  }
}
const Bbt = {
  label: "Add an annotation",
  hotkeys: [
    "a"
  ]
}, jbt = {
  label: "Toggle screen reader announcements",
  hotkeys: [
    "b"
  ]
}, Fbt = {
  label: "Jump to chord landing",
  hotkeys: [
    "c"
  ]
}, $bt = {
  label: "Show the help dialog",
  hotkeys: [
    "h"
  ]
}, zbt = {
  label: "Toggle dark mode",
  hotkeys: [
    "k"
  ]
}, Vbt = {
  label: "Toggle low-vision mode",
  hotkeys: [
    "l"
  ]
}, Ubt = {
  label: "Toggle narrative highlight mode",
  hotkeys: [
    "n"
  ]
}, Hbt = {
  label: "Query data",
  hotkeys: [
    "q"
  ]
}, Gbt = {
  label: "Repeat last message",
  hotkeys: [
    "r"
  ]
}, Qbt = {
  label: "Toggle sonification mode",
  hotkeys: [
    "s"
  ]
}, Wbt = {
  label: "Toggle trend navigation mode",
  hotkeys: [
    "t"
  ]
}, qbt = {
  label: "Clear the datapoint selection",
  hotkeys: [
    "u"
  ]
}, Ybt = {
  label: "Toggle self-voicing mode",
  hotkeys: [
    "v"
  ]
}, Kbt = {
  label: "Move the cursor",
  parameters: {
    direction: "string"
  },
  hotkeys: [
    {
      keyID: "arrowright",
      args: {
        direction: "right"
      }
    },
    {
      keyID: "arrowleft",
      args: {
        direction: "left"
      }
    },
    {
      keyID: "arrowup",
      args: {
        direction: "up"
      }
    },
    {
      keyID: "arrowdown",
      args: {
        direction: "down"
      }
    },
    {
      keyID: "Shift+arrowup",
      args: {
        direction: "out"
      }
    },
    {
      keyID: "Shift+arrowdown",
      args: {
        direction: "in"
      }
    }
  ]
}, Zbt = {
  label: "Play datapoints to the right",
  hotkeys: [
    "Shift+end"
  ]
}, Jbt = {
  label: "Play datapoints to the left",
  hotkeys: [
    "Shift+home"
  ]
}, Xbt = {
  label: "Stop playing",
  hotkeys: [
    "Ctrl+control"
  ]
}, tvt = {
  label: "Go to first point in series",
  hotkeys: [
    "home",
    ";"
  ]
}, evt = {
  label: "Go to last point in series",
  hotkeys: [
    "end",
    "'"
  ]
}, rvt = {
  label: "Play or pause audio",
  hotkeys: [
    " "
  ]
}, nvt = {
  label: "Reset the chart",
  hotkeys: [
    "Shift+ "
  ]
}, ivt = {
  label: "Select a datapoint",
  hotkeys: [
    "enter"
  ]
}, svt = {
  label: "Extend the datapoint selection",
  hotkeys: [
    "Shift+enter"
  ]
}, ovt = {
  label: "Go to the series minimum",
  hotkeys: [
    "["
  ]
}, avt = {
  label: "Go to the series maximum",
  hotkeys: [
    "]"
  ]
}, lvt = {
  label: "Go to the chart minimum",
  hotkeys: [
    "Shift+{"
  ]
}, cvt = {
  label: "Go to the chart maximum",
  hotkeys: [
    "Shift+}"
  ]
}, uvt = {
  label: "Announce version info",
  hotkeys: [
    "Ctrl+Shift+v"
  ]
}, hvt = {
  label: "Stop speaking (self-voicing mode)",
  hotkeys: [
    "Ctrl",
    "escape"
  ]
}, pvt = {
  addAnnotation: Bbt,
  toggleAnnouncementMode: jbt,
  jumpToChordLanding: Fbt,
  openHelp: $bt,
  toggleDarkMode: zbt,
  toggleLowVisionMode: Vbt,
  toggleNarrativeHighlightMode: Ubt,
  queryData: Hbt,
  repeatLastAnnouncement: Gbt,
  toggleSonificationMode: Qbt,
  toggleTrendNavigationMode: Wbt,
  clearSelection: qbt,
  toggleVoicingMode: Ybt,
  move: Kbt,
  playRight: Zbt,
  playLeft: Jbt,
  stopPlay: Xbt,
  goFirst: tvt,
  goLast: evt,
  playPauseMedia: rvt,
  reset: nvt,
  select: ivt,
  extendSelection: svt,
  goMinimum: ovt,
  goMaximum: avt,
  goTotalMinimum: lvt,
  goTotalMaximum: cvt,
  announceVersionInfo: uvt,
  shutUp: hvt
}, YF = pvt;
class dvt extends Event {
  constructor(t, r, n) {
    super("hotkeypress", { bubbles: !0, cancelable: !0, composed: !0 }), this.key = t, this.action = r, this.args = n;
  }
}
class fvt extends EventTarget {
  constructor(t) {
    super(), this._keyDetails = {}, this.registerHotkeys(t);
  }
  /**
   * Handle the keydown event
   * @param event - keydown event
   */
  // handleKeyEvents(event: CustomEvent) {
  //   if (event.detail in this._keymap) {
  //     this.view.actionManager!.call(this._keymap[keyPress].action);
  //   } else if (keyPress.toUpperCase() in this._keymap) {
  //     this.view.actionManager!.call(this._keymap[keyPress.toUpperCase()].action);
  //   }
  // }
  /**
   * Register a hotkey.
   * @param keyInfo - the key ID string or key with args object
   * @param action - the action to perform if the key is pressed
   */
  registerHotkey(t, r) {
    const n = typeof t == "string" ? t : t.keyID;
    try {
      this._keyDetails[n] = {
        key: n,
        //title: this.todo.controller.translator.translate(titleId),
        //description,
        action: r
        //keyDescription
      }, typeof t != "string" && (this._keyDetails[n].args = t.args), n.length === 1 && n.toLocaleUpperCase() !== n && (this._keyDetails[`Shift+${n}`] = {
        key: n,
        //title: this.todo.controller.translator.translate(titleId),
        //description,
        action: r
        //keyDescription
      });
    } catch (i) {
      i instanceof Error && console.warn(i.message);
    }
  }
  /**
   * Register multiple hotkeys.
   * Effectively a shortcut to calling `.registerHotkey()` multiple times
   * @param keyRegistrations - hotkey registration info
   */
  registerHotkeys(t) {
    for (const [r, n] of Object.entries(t))
      for (const i of n.hotkeys)
        this.registerHotkey(i, r);
  }
  onKeydown(t) {
    const r = this._keyDetails[t];
    return r ? (this.dispatchEvent(new dvt(t, r.action, r.args)), !0) : !1;
  }
  /**
   * Build a help dialog
   * @param lang Language of the dialog - used in attribute, and for i18n
   * @param translationCallback - get language-specific verbiage
   */
  /*generateHelpDialog(
      lang: string,
      translationCallback: (
        code: string,
        //evaluators?: translateEvaluators
      ) => string
    ) {
      const dialog = document.createElement("dialog");
      dialog.setAttribute("lang", lang);
  
      const closeButton = document.createElement("button");
      closeButton.textContent = 'X';
      closeButton.ariaLabel = translationCallback("close");
      closeButton.style.position = 'absolute';
      closeButton.style.top = '10px';
      closeButton.style.right = '10px';
      closeButton.addEventListener("click", () => {
        dialog.close();
      });
      dialog.appendChild(closeButton);
  
      const heading = translationCallback("kbmg-title");
      const h1 = document.createElement("h1");
      h1.textContent = heading;
      dialog.setAttribute("aria-live", heading);
      dialog.appendChild(h1);
  
      const table = document.createElement("table");
      const tbody = document.createElement("tbody");
      Object.entries(this._keyMap).forEach(([keystroke, details]) => {
        const tr = document.createElement("tr");
        const th = document.createElement("th");
        th.scope = 'row';
        th.textContent = details.title;
        tr.appendChild(th);
  
        const td1 = document.createElement("td");
        td1.textContent = details.keyDescription ?? keystroke;
        tr.appendChild(td1);
  
        const td2 = document.createElement("td");
        td2.textContent = details.description;
        tr.appendChild(td2);
  
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
  
      dialog.appendChild(table);
      return dialog;
    }*/
  /**
   * Launch help dialog
   * @param lang Language of the dialog - used in attribute, and for i18n
   * @param translationCallback - get language-specific verbiage
   */
  /*launchHelpDialog(
    lang: string,
    translationCallback: (
      code: string,
      evaluators?: translateEvaluators
    ) => string
  ) {
    if (this._dialog === null) {
      this._dialog = this.generateHelpDialog(lang, translationCallback);
      document.body.appendChild(this._dialog);
    }
    this._dialog.showModal();
    this._dialog.focus();
  }*/
}
var gvt = Object.defineProperty, Ar = (e, t, r, n) => {
  for (var i = void 0, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(t, r, i) || i);
  return i && gvt(t, r, i), i;
};
Frt();
function Zr(e) {
  const [t, r] = e.split("-");
  return {
    seriesKey: t,
    index: parseInt(r)
  };
}
class xr extends Rm {
  constructor(t, r, n, i, s) {
    super(), this.paraChart = t, this.symbols = new qF(), this.dataState = "initial", this.darkMode = !1, this.announcement = { text: "", html: "", highlights: [], startFrom: 0 }, this.annotations = [], this.popups = [], this.sparkBrailleInfo = null, this.seriesAnalyses = {}, this.frontSeries = "", this._lowlightSeries = [], this._hiddenSeriesList = [], this.data = null, this.focused = "chart", this.selected = null, this.queryLevel = "default", this._visitedDatapoints = /* @__PURE__ */ new Set(), this._prevVisitedDatapoints = /* @__PURE__ */ new Set(), this._everVisitedDatapoints = /* @__PURE__ */ new Set(), this._highlightedSelector = "", this._selectedDatapoints = /* @__PURE__ */ new Set(), this._prevSelectedDatapoints = /* @__PURE__ */ new Set(), this._rangeHighlights = [], this._modelLineBreaks = [], this._userLineBreaks = [], this._modelTrendLines = [], this._userTrendLines = [], this._settingControls = new GF(this), this._settingObservers = {}, this._manifest = null, this._jimerator = null, this._model = null, this._facets = null, this._type = "line", this._title = "", this._seriesProperties = null, this._keymapManager = new fvt(YF), this.annotID = 0, this.idList = {};
    const o = dr.hydrateInput(r);
    dr.suppleteSettings(o, n ?? vbt), this.settings = o, this.subscribe((a, l) => this._propertyChanged(a, l)), this._colors = new QF(this), this._seriesAnalyzerConstructor = i, this._pairAnalyzerConstructor = s, this._getUrlAnnotations();
  }
  get settingControls() {
    return this._settingControls;
  }
  get type() {
    return this._type;
  }
  get model() {
    return this._model;
  }
  get title() {
    return this._title;
  }
  get jimerator() {
    return this._jimerator;
  }
  get seriesProperties() {
    return this._seriesProperties;
  }
  get colors() {
    return this._colors;
  }
  get keymapManager() {
    return this._keymapManager;
  }
  get rangeHighlights() {
    return this._rangeHighlights;
  }
  get modelLineBreaks() {
    return this._modelLineBreaks;
  }
  get userLineBreaks() {
    return this._userLineBreaks;
  }
  get modelTrendLines() {
    return this._modelTrendLines;
  }
  get userTrendLines() {
    return this._userTrendLines;
  }
  get hiddenSeriesList() {
    return this._hiddenSeriesList;
  }
  setManifest(t, r) {
    this._manifest = t;
    const n = this._manifest.datasets[0];
    if (sI[n.type] && Object.entries(sI[n.type]).forEach(([i, s]) => this.updateSettings((o) => {
      dr.set(i, s, o);
    })), n.settings && (Object.entries(n.settings).forEach(([i, s]) => this.updateSettings((o) => {
      dr.set(i, s, o);
    })), this.settings.color.colorMap && this._colors.setColorMap(...this.settings.color.colorMap.split(",").map((i) => i.trim()))), this._jimerator = new Ect(this._manifest, r), this._jimerator.render(), this._type = n.type, this._title = n.title, this._facets = V0(n), n.data.source === "inline")
      A7(n.type) ? this._model = Ktt(t) : this._model = Jtt(
        t,
        this._seriesAnalyzerConstructor,
        this._pairAnalyzerConstructor
      ), this._seriesProperties = new oI(this), this.data = FM(t);
    else if (r)
      A7(n.type) ? this._model = Ztt(r, t) : this._model = Xtt(
        r,
        t,
        this._seriesAnalyzerConstructor,
        this._pairAnalyzerConstructor
      ), this._seriesProperties = new oI(this), this.data = r;
    else
      throw new Error("store lacks external or inline chart data");
    this._model instanceof cc && this._model.seriesKeys.forEach(async (i) => {
      this.seriesAnalyses = {
        [i]: await this._model.getSeriesAnalysis(i),
        ...this.seriesAnalyses
      };
    });
  }
  _propertyChanged(t, r) {
  }
  updateSettings(t, r = !1) {
    var a;
    const [n, i, s] = zrt(this.settings, t);
    if (this.settings = n, r)
      return;
    const o = {};
    for (const l of i) {
      if (l.op !== "replace") {
        console.error(`unexpected patch op '${l.op}' (${l.path})`);
        continue;
      }
      o[l.path.join(".")] = { newValue: l.value };
    }
    for (const l of s) {
      if (l.op !== "replace") {
        console.error(`unexpected patch op '${l.op}' (${l.path})`);
        continue;
      }
      o[l.path.join(".")].oldValue = l.value;
    }
    for (const [l, c] of Object.entries(o))
      (a = this._settingObservers[l]) == null || a.forEach(
        (h) => h(c.oldValue, c.newValue)
      ), this.paraChart.settingDidChange(l, c.oldValue, c.newValue);
  }
  observeSetting(t, r) {
    if (this._settingObservers[t] || (this._settingObservers[t] = []), this._settingObservers[t].includes(r))
      throw new Error(`observer already registered for setting '${t}'`);
    this._settingObservers[t].push(r);
  }
  observeSettings(t, r) {
    for (let n of t)
      this.observeSetting(n, r);
  }
  unobserveSetting(t, r) {
    if (!this._settingObservers[t])
      throw new Error(`no observers for setting '${t}'`);
    const n = this._settingObservers[t].indexOf(r);
    if (n === -1)
      throw new Error(`observer not registered for setting '${t}'`);
    this._settingObservers[t].splice(n, 1), this._settingObservers[t].length === 0 && delete this._settingObservers[t];
  }
  lowlightSeries(t) {
    this._lowlightSeries.includes(t) || (this._lowlightSeries = [...this._lowlightSeries, t]);
  }
  clearSeriesLowlight(t) {
    this._lowlightSeries.includes(t) && (this._lowlightSeries = this._lowlightSeries.filter((r) => r !== t));
  }
  isSeriesLowlighted(t) {
    return this._lowlightSeries.includes(t);
  }
  lowlightOtherSeries(...t) {
    this._lowlightSeries = this._model.seriesKeys.filter((r) => !t.includes(r));
  }
  clearAllSeriesLowlights() {
    this._lowlightSeries = [];
  }
  announce(t, r = !1, n = 0) {
    let i = "", s = "";
    const o = `\r
`;
    let a = [];
    typeof t == "string" ? (i = t, s = t) : Array.isArray(t) ? (i = this._joinStrArray(t, o), s = i) : (i = t.text, s = t.html, a = t.highlights ?? []), this.settings.ui.isAnnouncementEnabled && (this.announcement = { text: i, html: s, highlights: a, clear: r, startFrom: n }, console.log("ANNOUNCE:", this.announcement.text));
  }
  _joinStrArray(t, r) {
    if (t = t.filter((n) => /\S/.test(n)), t.length) {
      const n = t.length - 1;
      return t.reduce((i, s, o) => {
        const a = o === n ? "." : "", l = i ? ` ${r}` : "";
        return `${i.match(/[.,?:;]$/) ? i : `${i}.`} ${l}${s}${a}`;
      });
    }
    return "";
  }
  hide(t) {
    this._hiddenSeriesList.includes(t) || (this._hiddenSeriesList = [...this._hiddenSeriesList, t]);
  }
  get visitedDatapoints() {
    return this._visitedDatapoints;
  }
  get prevVisitedDatapoints() {
    return this._prevVisitedDatapoints;
  }
  get everVisitedDatapoints() {
    return this._everVisitedDatapoints;
  }
  visit(t) {
    this._prevVisitedDatapoints = this._visitedDatapoints, this._visitedDatapoints = /* @__PURE__ */ new Set(), t.forEach((r) => {
      this._visitedDatapoints.add(`${r.seriesKey}-${r.datapointIndex}`);
    });
    for (const r of t)
      this._everVisitedDatapoints.add(`${r.seriesKey}-${r.datapointIndex}`);
    this.settings.controlPanel.isMDRAnnotationsVisible && (this.removeMDRAnnotations(this._prevVisitedDatapoints), this.showMDRAnnotations()), this.paraChart.paraView.requestUpdate();
  }
  _datapointSetHas(t, r, n) {
    return n.has(`${t}-${r}`);
  }
  isVisited(t, r) {
    return this._datapointSetHas(t, r, this._visitedDatapoints);
  }
  isVisitedSeries(t) {
    return this._visitedDatapoints.values().some((r) => r.startsWith(t));
  }
  wasVisited(t, r) {
    return this._datapointSetHas(t, r, this._prevVisitedDatapoints);
  }
  wasVisitedSeries(t) {
    return this._prevVisitedDatapoints.values().some((r) => r.startsWith(t));
  }
  everVisited(t, r) {
    return this._datapointSetHas(t, r, this._everVisitedDatapoints);
  }
  everVisitedSeries(t) {
    return this._everVisitedDatapoints.values().some((r) => r.startsWith(t));
  }
  clearVisited() {
    this._prevVisitedDatapoints = this._visitedDatapoints, this._visitedDatapoints = /* @__PURE__ */ new Set();
  }
  get highlightedSelector() {
    return this._highlightedSelector;
  }
  highlight(t) {
    this._highlightedSelector = t;
  }
  clearHighlight() {
    this.popups.splice(0, this.popups.length), this._highlightedSelector = "";
  }
  get selectedDatapoints() {
    return this._selectedDatapoints;
  }
  get prevSelectedDatapoints() {
    return this._prevSelectedDatapoints;
  }
  select() {
    let t = /* @__PURE__ */ new Set();
    if (this._visitedDatapoints.size === 1) {
      const r = [...this._visitedDatapoints.values()][0], { seriesKey: n, index: i } = Zr(r);
      (!this.isSelected(n, i) || this._selectedDatapoints.size > 1) && t.add(r);
    } else
      for (const r of this._visitedDatapoints) {
        const { seriesKey: n, index: i } = Zr(r);
        this.isSelected(n, i) || t.add(r);
      }
    this._prevSelectedDatapoints = this._selectedDatapoints, this._selectedDatapoints = t;
  }
  extendSelection() {
    const t = new Set(this._selectedDatapoints);
    for (const r of this._visitedDatapoints) {
      const { seriesKey: n, index: i } = Zr(r);
      this.isSelected(n, i) ? t.delete(r) : t.add(r);
    }
    this._prevSelectedDatapoints = this._selectedDatapoints, this._selectedDatapoints = t;
  }
  isSelected(t, r) {
    return this._datapointSetHas(t, r, this._selectedDatapoints);
  }
  isSelectedSeries(t) {
    return this._selectedDatapoints.values().some((r) => r.startsWith(t));
  }
  wasSelected(t, r) {
    return this._datapointSetHas(t, r, this._prevSelectedDatapoints);
  }
  wasSelectedSeries(t) {
    return this._prevSelectedDatapoints.values().some((r) => r.startsWith(t));
  }
  clearSelected() {
    this._prevSelectedDatapoints = this._selectedDatapoints, this._selectedDatapoints = /* @__PURE__ */ new Set();
  }
  getFormatType(t) {
    return t === "domId" ? "domId" : dr.get(pbt[t], this.settings);
  }
  addAnnotation() {
    const t = [];
    this._visitedDatapoints.forEach((r) => {
      const { seriesKey: n, index: i } = Zr(r), s = ff(
        this._model.atKeyAndIndex(n, i),
        "raw"
      ), o = prompt("Annotation:");
      o && (t.push({
        type: "datapoint",
        seriesKey: n,
        index: i,
        annotation: `${n}, ${s}: ${o}`,
        text: o,
        id: `${n}-${s}-${this.annotID}`
      }), this.annotID += 1);
    }), this.annotations = [...this.annotations, ...t];
  }
  annotatePoint(t, r, n) {
    if (this.annotations.find((s) => s.seriesKey === t && s.index === r && s.text === n))
      return;
    const i = ff(
      this._model.atKeyAndIndex(t, r),
      "raw"
    );
    this.annotations = [...this.annotations, {
      type: "datapoint",
      seriesKey: t,
      index: r,
      annotation: `${t}, ${i}: ${n}`,
      text: n,
      id: `${t}-${i}-${this.annotID}`
    }], this.annotID++;
  }
  async showMDRAnnotations() {
    if (this.type === "line")
      if (this.settings.controlPanel.isMDRAnnotationsVisible) {
        let t, r;
        if (this.visitedDatapoints.size > 0 ? (r = Zr(this.visitedDatapoints.keys().toArray()[0]).seriesKey, t = this.model ? await this.model.getSeriesAnalysis(r) : void 0) : (r = this.model.series[0][0].seriesKey, t = this.model ? await this.model.getSeriesAnalysis(r) : void 0), !t) {
          console.log("This chart does not support AI trend annotations"), this.updateSettings((o) => {
            o.controlPanel.isMDRAnnotationsVisible = !this.settings.controlPanel.isMDRAnnotationsVisible;
          });
          return;
        }
        const n = this.model.series[0].length - 1;
        let i = t == null ? void 0 : t.messageSeqs.map((o) => t.sequences[o]);
        for (let o of i)
          this.highlightRange(o.start / n, (o.end - 1) / n);
        this.addModelLineBreaks(t.sequences, r), this.addModelTrendLines(t.sequences, r);
        let s = `Detected trend: ${t == null ? void 0 : t.message}, consisting of ${t == null ? void 0 : t.messageSeqs.length} datapoint sequences from`;
        for (let o of i)
          s += ` ${this.model.allPoints[o.start].facetValueNumericized("x")} to ${this.model.allPoints[o.end - 1].facetValueNumericized("x")} (${o.message}),`;
        if (this.annotations.some((o) => o.id == "trend-analysis-annotation")) {
          const o = this.annotations.findIndex((a) => a.id == "trend-analysis-annotation");
          this.annotations.splice(o, 1);
        }
        this.annotations.push({
          type: "trend",
          annotation: s,
          id: "trend-analysis-annotation"
        });
      } else
        this.removeMDRAnnotations();
    else
      console.log("Trend annotations not currently supported for this chart type"), this.updateSettings((t) => {
        t.controlPanel.isMDRAnnotationsVisible = !this.settings.controlPanel.isMDRAnnotationsVisible;
      });
  }
  async removeMDRAnnotations(t) {
    let r = null, n = null;
    t || (t = this.visitedDatapoints), this.type !== "line" || (t.size > 0 ? (n = Zr(this.visitedDatapoints.keys().toArray()[0]).seriesKey, r = this.model ? await this.model.getSeriesAnalysis(n) : null) : (n = this.model.series[0][0].seriesKey, r = this.model ? await this.model.getSeriesAnalysis(n) : null));
    const i = this.model.series[0].length - 1;
    let s = r == null ? void 0 : r.messageSeqs.map((o) => r.sequences[o]);
    for (let o of s)
      this.unhighlightRange(o.start / i, (o.end - 1) / i);
    if (n !== null && (this.removeModelLineBreaks(r.sequences, n), this.removeModelTrendLines(r.sequences, n)), this.annotations.some((o) => o.id == "trend-analysis-annotation")) {
      const o = this.annotations.findIndex((a) => a.id == "trend-analysis-annotation");
      this.annotations.splice(o, 1);
    }
  }
  _getUrlAnnotations() {
    const t = (s) => s.replace(/(\r\n|\n|\r)/gm, "").replace(/\s+/g, " ").trim();
    let n = window.location.search;
    if (n) {
      var i = new URLSearchParams(n);
      let s = i.get("text");
      i.get("note"), s && (s = t(s));
    }
  }
  highlightRange(t, r) {
    if (this._rangeHighlights.find((n) => n.startPortion === t && n.endPortion === r))
      throw new Error("range already highlighted");
    this._rangeHighlights = [...this._rangeHighlights, { startPortion: t, endPortion: r }];
  }
  unhighlightRange(t, r) {
    const n = this._rangeHighlights.findIndex((i) => i.startPortion === t && i.endPortion === r);
    if (n === -1)
      throw new Error("range not highlighted");
    this._rangeHighlights = this._rangeHighlights.toSpliced(n, 1);
  }
  getModelCsv() {
    const t = this._model.getFacet(this.model.independentFacetKeys[0]).label;
    return IL.unparse(this.model.series[0].datapoints.map((r, n) => ({
      [t]: ff(r, "raw"),
      ...Object.fromEntries(this.model.series.map((i) => [i.key, z5(i[n], "value")]))
    })));
  }
  addModelLineBreaks(t, r) {
    const i = this.model.series.filter((s) => s[0].seriesKey == r)[0].length - 1;
    for (let s of t)
      this.addLineBreak(s.start / i, s.start, r, !0);
    this.addLineBreak((t[t.length - 1].end - 1) / i, t[t.length - 1].end - 1, r, !0);
  }
  removeModelLineBreaks(t, r) {
    const i = this.model.series.filter((o) => o[0].seriesKey == r)[0].length - 1;
    for (let o of t) {
      const a = this._modelLineBreaks.findIndex((l) => l.startPortion === o.start / i);
      a === -1 || (this._modelLineBreaks = this._modelLineBreaks.toSpliced(a, 1));
    }
    const s = this._modelLineBreaks.findIndex((o) => o.startPortion === (t[t.length - 1].end - 1) / i);
    s === -1 || (this._modelLineBreaks = this._modelLineBreaks.toSpliced(s, 1));
  }
  addLineBreak(t, r, n, i) {
    i ? this._modelLineBreaks.find((s) => s.startPortion === t) || (this._modelLineBreaks = [...this._modelLineBreaks, { startPortion: t, seriesKey: n, index: r }]) : this._userLineBreaks.find((s) => s.startPortion === t && s.seriesKey === n) || this._userLineBreaks.push({ startPortion: t, seriesKey: n, index: r });
  }
  addUserLineBreaks() {
    for (const t of this.selectedDatapoints) {
      const { seriesKey: r, index: n } = Zr(t), i = this.model.series.filter((o) => o[0].seriesKey === r)[0], s = i.length - 1;
      this.addLineBreak(n / s, n, r, !1), this.annotations.push({
        type: "lineBreak",
        seriesKey: r,
        index: n,
        annotation: `${i.key}, ${i.rawData[n].x}: Added line break`,
        id: `line-break-${n}`
      }), this.paraChart.postNotice("addLineBreak", { seriesKey: r, index: n });
    }
    if (this.userLineBreaks.length) {
      this.clearUserTrendLines();
      for (let t of new Set(this.userLineBreaks.map((r) => r.seriesKey))) {
        let r = this.userLineBreaks.filter((s) => s.seriesKey === t).sort((s, o) => s.index - o.index);
        this.addTrendLine(0, r[0].startPortion, 0, r[0].index + 1, t, !1);
        for (let s = 0; s < r.length - 1; s++)
          this.addTrendLine(r[s].startPortion, r[s + 1].startPortion, r[s].index, r[s + 1].index + 1, t, !1);
        const i = this.model.series.filter((s) => s[0].seriesKey == t)[0].length - 1;
        this.addTrendLine(r[r.length - 1].startPortion, 1, r[r.length - 1].index, i + 1, t, !1);
      }
    }
  }
  addModelTrendLines(t, r) {
    const i = this.model.series.filter((s) => s[0].seriesKey == r)[0].length - 1;
    for (let s of t)
      this.addTrendLine(s.start / i, (s.end - 1) / i, s.start, s.end, r, !0);
  }
  addTrendLine(t, r, n, i, s, o) {
    o ? this._modelTrendLines.find((a) => a.startPortion === t && a.endPortion === r) || (this._modelTrendLines = [...this._modelTrendLines, { startPortion: t, endPortion: r, startIndex: n, endIndex: i, seriesKey: s }]) : this._userTrendLines.find((a) => a.startPortion === t && a.endPortion === r && a.seriesKey === s) || (this._userTrendLines = [...this._userTrendLines, { startPortion: t, endPortion: r, startIndex: n, endIndex: i, seriesKey: s }]);
  }
  removeModelTrendLines(t, r) {
    const i = this.model.series.filter((s) => s[0].seriesKey == r)[0].length - 1;
    for (let s of t) {
      const o = this._modelTrendLines.findIndex((a) => a.startPortion === s.start / i && a.endPortion === (s.end - 1) / i);
      o === -1 || (this._modelTrendLines = this._modelTrendLines.toSpliced(o, 1));
    }
  }
  clearUserLineBreaks() {
    this._userLineBreaks = [], this.annotations = this.annotations.filter((t) => !/line-break/.test(t.id)), this.paraChart.postNotice("clearLineBreaks", null);
  }
  clearUserTrendLines() {
    this._userTrendLines = [];
  }
}
Ar([
  vr()
], xr.prototype, "dataState");
Ar([
  vr()
], xr.prototype, "settings");
Ar([
  vr()
], xr.prototype, "darkMode");
Ar([
  vr()
], xr.prototype, "announcement");
Ar([
  vr()
], xr.prototype, "annotations");
Ar([
  vr()
], xr.prototype, "popups");
Ar([
  vr()
], xr.prototype, "sparkBrailleInfo");
Ar([
  vr()
], xr.prototype, "seriesAnalyses");
Ar([
  vr()
], xr.prototype, "frontSeries");
Ar([
  vr()
], xr.prototype, "_lowlightSeries");
Ar([
  vr()
], xr.prototype, "_hiddenSeriesList");
Ar([
  vr()
], xr.prototype, "data");
Ar([
  vr()
], xr.prototype, "focused");
Ar([
  vr()
], xr.prototype, "selected");
Ar([
  vr()
], xr.prototype, "queryLevel");
Ar([
  vr()
], xr.prototype, "_highlightedSelector");
Ar([
  vr()
], xr.prototype, "_selectedDatapoints");
Ar([
  vr()
], xr.prototype, "_prevSelectedDatapoints");
Ar([
  vr()
], xr.prototype, "_rangeHighlights");
Ar([
  vr()
], xr.prototype, "_modelLineBreaks");
Ar([
  vr()
], xr.prototype, "_userLineBreaks");
Ar([
  vr()
], xr.prototype, "_modelTrendLines");
Ar([
  vr()
], xr.prototype, "_userTrendLines");
var mvt = Object.defineProperty, yvt = Object.getOwnPropertyDescriptor, WA = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? yvt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && mvt(t, r, i), i;
};
const uS = class uS extends zi {
  constructor() {
    super(...arguments), this.hidden = !1;
  }
  set value(t) {
    this._value = t;
  }
  get value() {
    return this._value;
  }
  _updateSetting(t, r) {
    this._store.updateSettings((n) => dr.set(t, r, n));
  }
  _validateInput(t, r) {
    if (this.info.validator) {
      const n = this.info.validator(t);
      if (n.err)
        return r.dispatchEvent(
          new CustomEvent(
            "invalidvalue",
            { bubbles: !0, composed: !0, detail: n.err }
          )
        ), !1;
    }
    return !0;
  }
  render() {
    return Ht`
      <div
        class="setting"
      >
        ${this.content()}
      </div>
    `;
  }
};
uS.styles = [
  //styles,
  Te`
    `
];
let Ts = uS;
WA([
  Lr()
], Ts.prototype, "label", 2);
WA([
  Lr()
], Ts.prototype, "value", 1);
WA([
  Qt({ type: Boolean })
], Ts.prototype, "hidden", 2);
var bvt = Object.getOwnPropertyDescriptor, vvt = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? bvt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let aI = class extends Ts {
  content() {
    const e = this.info.options;
    return Ht`
      <label>
        ${this.label}
        <input 
          type=${(e == null ? void 0 : e.inputType) ?? "text"}
          .value=${this._value} 
          min=${(e == null ? void 0 : e.inputType) === "number" ? e.min : Lt}
          max=${(e == null ? void 0 : e.inputType) === "number" ? e.max : Lt}
          size=${(e == null ? void 0 : e.size) ?? "8"}
          @change=${(t) => {
      const r = t.target, n = (e == null ? void 0 : e.inputType) === "number" ? parseFloat(r.value) : r.value;
      this._validateInput(n, r) ? (this._value = n, this._updateSetting(this.info.key, n)) : r.value = this._value.toString();
    }}
        />
      </label>
    `;
  }
};
aI = vvt([
  Oe("para-textfield-setting-control")
], aI);
var wvt = Object.getOwnPropertyDescriptor, xvt = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? wvt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let lI = class extends Ts {
  connectedCallback() {
    super.connectedCallback(), this.values = this.info.options.values ?? this.info.options.options;
  }
  content() {
    return Ht`
      <fizz-dropdown 
        label=${this.label} 
        .options=${this.info.options.options}
        selected=${this.values.indexOf(this._value)}
        @select=${(e) => {
      const t = e.target.selectedIndex;
      this._updateSetting(this.info.key, this.values[t]);
    }}
      ></fizz-dropdown>
    `;
  }
};
lI = xvt([
  Oe("para-dropdown-setting-control")
], lI);
var Evt = Object.getOwnPropertyDescriptor, Avt = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Evt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let cI = class extends Ts {
  content() {
    return Ht`
      <label>
        <input 
          type="checkbox"
          .checked=${!!this._value}
          @change=${(e) => {
      this._updateSetting(
        this.info.key,
        e.target.checked
      );
    }}
        >
          ${this.label} 
      </label>
    `;
  }
};
cI = Avt([
  Oe("para-checkbox-setting-control")
], cI);
var Svt = Object.getOwnPropertyDescriptor, _vt = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Svt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let uI = class extends Ts {
  content() {
    const e = this.info.options;
    return Ht`
      <fizz-radiogroup
        .buttons=${e.buttons}
        selected=${this._value}
        layout=${e.layout ?? Lt}
        ?wrap=${e.wrap}
        @select=${(t) => this._updateSetting(
      this.info.key,
      t.detail
    )}
      >
        <span slot="legend">${this.label}</span>
      </fizz-radiogroup>
    `;
  }
};
uI = _vt([
  Oe("para-radio-setting-control")
], uI);
var kvt = Object.getOwnPropertyDescriptor, Cvt = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? kvt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let hI = class extends Ts {
  content() {
    const e = this.info.options, t = we(), r = e != null && e.width ? {
      "--width": e.width
    } : {};
    return Ht`
      <fizz-slider
        ${ge(t)}
        style=${ln(r)}
        label=${this.label}
        key=${Cr(this.info.key)}
        value=${this._value}
        min=${(e == null ? void 0 : e.min) ?? Lt}
        max=${(e == null ? void 0 : e.max) ?? Lt}
        step=${(e == null ? void 0 : e.step) ?? Lt}
        lowbound=${(e == null ? void 0 : e.lowBound) ?? Lt}
        highbound=${(e == null ? void 0 : e.highBound) ?? Lt}
        ?percent=${e == null ? void 0 : e.percent}
        ?showvalue=${e == null ? void 0 : e.showValue}
        ?compact=${e == null ? void 0 : e.compact}
        @update=${(n) => this._updateSetting(
      this.info.key,
      n.detail
    )}
      ></fizz-slider>
    `;
  }
};
hI = Cvt([
  Oe("para-slider-setting-control")
], hI);
var Ivt = Object.getOwnPropertyDescriptor, Pvt = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Ivt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let pI = class extends Ts {
  content() {
    return Ht`
      <label>
        <button
          type="button"
          @click=${(e) => {
      this._value = !this._value, this._updateSetting(this.info.key, this._value);
    }}
        >
          ${this.label}
        </button> 
      </label>
    `;
  }
};
pI = Pvt([
  Oe("para-button-setting-control")
], pI);
class Rvt extends mL {
  constructor(t) {
    super(), this._store = t;
  }
  logName() {
    return "ParaViewController";
  }
  handleKeyEvent(t) {
    if (this._store.settings.chart.isStatic)
      return;
    let r = t.key === "Control" ? "Ctrl" : t.key.toLocaleLowerCase(), n = [
      t.altKey ? "Alt" : "",
      t.ctrlKey ? "Ctrl" : "",
      t.shiftKey ? "Shift" : "",
      t.metaKey ? "Meta" : ""
    ].filter((s) => s);
    n.includes(r) && (r = "");
    const i = (r ? [...n, r] : n).join("+");
    this._store.keymapManager.onKeydown(i) && (t.stopPropagation(), t.preventDefault());
  }
}
class Tvt {
  constructor(t) {
    this._paraView = t, this._touchArray = [], this._currentTarget = null, this._selectedElement = null, this._selectedElements = [], this._highlightBoxes = /* @__PURE__ */ new WeakMap(), this._coords = null, this._dataRoot = null, this._dataRect = null;
  }
  get coords() {
    return this._coords;
  }
  /**
   * Records pointer event info.
   * @param event - The event on the element.
   */
  _registerPointerEvent(t) {
    return {
      id: t.pointerId,
      target: t.target,
      x: t.clientX,
      y: t.clientY,
      offsetX: t.offsetX,
      offsetY: t.offsetY
    };
  }
  /**
   * Starts pointer events.
   * @param event - The event on the element.
   */
  handleStart(t) {
    const r = this._registerPointerEvent(t);
    this._touchArray.push(r);
  }
  /**
   * Ends pointer events.
   * @param event - The event on the element.
   */
  handleEnd(t) {
    this.handleCancel(t);
  }
  /**
   * Cancels pointer events.
   * @param event - The event on the element.
   */
  handleCancel(t) {
    const r = t.pointerId, n = this._touchArray.findIndex((i) => i.id === r);
    n >= 0 && this._touchArray.splice(n, 1);
  }
  /**
   * Reads element labels and default settings, and triggers speech.
   * @param event - The event on the element.
   */
  handleMove(t) {
    const r = t.target;
    if (r.releasePointerCapture(t.pointerId), this._coords = this._localCoords(t), r === this._paraView.root || r === this._dataRoot)
      this._currentTarget = null;
    else if (r !== this._currentTarget) {
      if (r !== this._currentTarget) {
        this._currentTarget = r, this._selectedElements.includes(r);
        const n = t.pointerId, i = this._touchArray.findIndex((s) => s.id === n);
        if (i >= 0) {
          this._touchArray[i];
          const s = this._registerPointerEvent(t);
          this._touchArray[i] = s;
        }
      }
    }
  }
  /**
   * .
   * @param event - The event on the element.
   */
  _updateTouchArray(t) {
    const r = t.pointerId, n = this._touchArray.findIndex((i) => i.id === r);
    if (n >= 0) {
      this._touchArray[n];
      const i = this._registerPointerEvent(t);
      this._touchArray[n] = i, this._coords = this._localCoords(t);
    }
  }
  /**
   * Reads element labels and default settings, and triggers speech.
   * @param event - The event on the element.
   */
  handleClick(t) {
    const r = t.target;
    t.detail < 2 && (r === this._paraView.frame || r === this._dataRect ? console.log("clicked backdrop!") : this._selectElement(r, t.shiftKey));
  }
  /**
   * Double click handler.
   * @param event - The event on the element.
   */
  handleDoubleClick(t) {
    const r = t.target;
    t.preventDefault(), r === this._paraView.root || this._dataRoot;
  }
  /**
   * Set selected element and add a highlight box.
   * @param target - The element to be selected; deselects if absent or `null`.
   */
  async _selectElement(t, r) {
    if (!t)
      this._clearSelectedElements();
    else {
      r || this._clearSelectedElements();
      const n = t.closest('[role="datapoint"]');
      if (n) {
        const i = n.id.endsWith("-sym") || n.id.endsWith("-rlb") || n.id.endsWith("-blb") || n.id.endsWith("-ilb") ? n.id.slice(0, -4) : n.id, s = this._paraView.documentView.chartLayers.dataLayer.datapointViewForId(i), o = this._paraView.documentView.chartInfo;
        o.navMap.goTo(o.navDatapointType, {
          seriesKey: s.seriesKey,
          index: s.index
        }), this._paraView.documentView.chartInfo.selectCurrent(!!r), this._selectedElement = t, this._selectedElements.push(t);
      } else
        console.log("not a datapoint!");
    }
  }
  // /**
  //  * Set selected element and add a highlight box.
  //  * @param {Element} target The element to be selected; deselects if absent or `null`.
  //  * @private
  //  * @memberOf module:@fizz/touchUI
  //  */
  // _createSelectBox(target: SVGGraphicsElement) {
  //   // console.log('_selectElement');
  //   if (target) {
  //     // highlight box
  //     const bbox = target.getBBox();
  //     let x = bbox.x;
  //     let y = bbox.y;
  //     // find any transforms on the element
  //     // TODO: fix this hack
  //     const transforms = (target.parentNode! as SVGGraphicsElement).getAttribute('transform');
  //     if (transforms) {
  //       // highlightBox.setAttribute('transform', transforms );
  //       // x += transforms.e;
  //       // y += transforms.f;
  //       let translate = transforms.split('translate(')[1].split(')')[0].split(',');
  //       x += parseFloat(translate[0]);
  //       y += parseFloat(translate[1]);
  //       // const transformMatrix = target.transform.baseVal.consolidate().matrix;
  //       // console.log('target.transform.baseVal.consolidate()', target.transform.baseVal.consolidate());
  //     }
  //     const highlightBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  //     highlightBox.classList.add('_highlight_box');
  //     highlightBox.setAttribute('x', (x - 2.5).toString());
  //     highlightBox.setAttribute('y', (y - 2.5).toString());
  //     highlightBox.setAttribute('width', (bbox.width + 5).toString());
  //     highlightBox.setAttribute('height', (bbox.height + 5).toString());
  //     // this.canvasContainer.firstElementChild.append(highlightBox);
  //     this._highlightBoxes.set(target, highlightBox);
  //   }
  // }
  /**
   * Remove selected element and remove its highlight box.
   * @param target - The element to be selected; deselects if absent or `null`.
   */
  _deselectElement(t) {
  }
  /**
   * Deselect all elements.
   */
  _clearSelectedElements() {
    this._selectedElement = null;
  }
  /**
  * Adjust the coordinates for transforms
  * @param event - The mouse event with the coordinates
  * @returns A coordinate point object with the proper transforms, as a 2-precision float
  */
  _localCoords(t) {
    var n, i;
    let r = {
      x: 0,
      y: 0
    };
    if (t.isTrusted) {
      let s = this._paraView.root.createSVGPoint();
      s.x = t.clientX, s.y = t.clientY, s = s.matrixTransform((i = (n = this._paraView.frame) == null ? void 0 : n.getScreenCTM()) == null ? void 0 : i.inverse()), r = {
        x: +s.x.toFixed(2),
        y: +s.y.toFixed(2)
      };
    }
    return r;
  }
}
const dI = {
  up: "down",
  down: "up",
  left: "right",
  right: "left",
  in: "out",
  out: "in"
};
function Ovt(e, t) {
  for (const r in e)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function Lvt(e, t) {
  if (!Object.keys(e).length)
    return !0;
  for (const r in e)
    if (e[r] === t[r])
      return !0;
  return !1;
}
class qA {
  constructor(t, r) {
    this._store = t, this._chart = r, this._layers = /* @__PURE__ */ new Map(), this._runTimer = null, this._currentLayer = "root";
    const n = new xy(this, this._currentLayer);
    this._layers.set(this._currentLayer, n);
  }
  get currentLayer() {
    return this._currentLayer;
  }
  set currentLayer(t) {
    this._currentLayer = t;
  }
  get cursor() {
    return this.layer(this._currentLayer).cursor;
  }
  get root() {
    return this._layers.get("root");
  }
  get chartInfo() {
    return this._chart;
  }
  clone() {
    const t = new qA(this._store, this._chart);
    return t._layers = new Map(this._layers.entries().map(([r, n]) => [r, n.clone(t)])), t._currentLayer = this._currentLayer, t;
  }
  layer(t) {
    return this._layers.get(t);
  }
  registerLayer(t) {
    this._layers.has(t.id) || this._layers.set(t.id, t);
  }
  async visitDatapoints() {
    this._store.visit(this.cursor.datapoints), this._runTimer ? clearTimeout(this._runTimer) : await this._chart.navRunDidStart(this.cursor), this._runTimer = setTimeout(() => {
      this._runTimer = null, this._chart.navRunDidEnd(this.cursor);
    }, this._store.settings.ui.navRunTimeoutMs);
  }
  node(t, r) {
    for (const n of this._layers.values()) {
      const i = n.get(t, r);
      if (i)
        return i;
    }
  }
  goTo(t, r) {
    const n = this.node(t, r);
    if (n)
      n.layer.cursor = n, this._currentLayer = n.layer.id, this.visitDatapoints();
    else
      throw new Error("nav node not found");
  }
  datapointsForSelector(t, r) {
    const n = this._layers.get(t);
    if (!n)
      throw new Error(`no such layer '${t}'`);
    const i = r.split(/-/), s = i[0];
    let o;
    if (s === "datapoint")
      o = n.get("datapoint", {
        seriesKey: i[1],
        index: parseInt(i[2])
      });
    else if (s === "sequence")
      o = n.get("sequence", {
        seriesKey: i[1],
        start: parseInt(i[2]),
        end: parseInt(i[3])
      });
    else if (s === "series")
      o = n.get("series", { seriesKey: i[1] });
    else
      return [];
    return o ? o.datapoints : [];
  }
}
const $y = class $y {
  constructor(t, r) {
    this._map = t, this._id = r, this._nodes = /* @__PURE__ */ new Map(), this._nodesById = /* @__PURE__ */ new Map(), t.registerLayer(this);
  }
  get map() {
    return this._map;
  }
  get id() {
    return this._id;
  }
  get cursor() {
    return this._nodesById.get(this._cursor);
  }
  set cursor(t) {
    this._cursor = t.id;
  }
  clone(t) {
    const r = new $y(t, this._id);
    return r._nodesById = new Map(this._nodesById.entries().map(([n, i]) => [n, i.clone(r)])), r._nodes = new Map(this._nodes.entries().map(([n, i]) => [n, [...i]])), r._cursor = this._cursor, r;
  }
  registerNode(t) {
    if (t.index !== -1)
      return;
    this._nodesById.set(t.id, t);
    let r = this._nodes.get(t.type);
    r || (r = [], this._nodes.set(t.type, r)), r.push(t.id), t.index = r.length - 1, this._cursor || (this._cursor = t.id);
  }
  /** Get a node from its ID. */
  node(t) {
    return this._nodesById.get(t);
  }
  /** Get a node from its options or index. */
  get(t, r = 0) {
    const n = this._nodes.get(t);
    if (n)
      return this._nodesById.get(typeof r == "number" ? n[r] : n.find((i) => Ovt(r, this._nodesById.get(i).options)));
  }
  /** Get all nodes matching partial options. */
  query(t, r = {}) {
    const n = this._nodes.get(t);
    return n ? n.filter((i) => Lvt(r, this._nodesById.get(i).options)).map((i) => this._nodesById.get(i)) : [];
  }
  goToNode(t) {
    this._cursor = t.id, this.map.visitDatapoints();
  }
  goTo(t, r) {
    const n = this.get(t, r);
    if (n)
      this.goToNode(n);
    else
      throw new Error(`nav node not found (type='${t}')`);
  }
};
$y.nextId = 0;
let xy = $y;
const zh = class zh {
  constructor(t, r, n, i) {
    this._layer = t, this._type = r, this._options = n, this._store = i, this._links = /* @__PURE__ */ new Map(), this._index = -1, this._id = `:${zh.nextId++}`, t.registerNode(this);
  }
  // get datapoints(): readonly DatapointCursor[] {
  //   return this._datapoints;
  // }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get options() {
    return this._options;
  }
  get layer() {
    return this._layer;
  }
  get index() {
    return this._index;
  }
  set index(t) {
    this._index = t;
  }
  get datapoints() {
    const t = [];
    if (this.isNodeType("datapoint") || this.isNodeType("scatterpoint"))
      t.push(this._store.model.atKeyAndIndex(this._options.seriesKey, this._options.index));
    else if (this.isNodeType("series")) {
      const r = this._store.model.atKey(this._options.seriesKey).length;
      for (let n = 0; n < r; n++)
        t.push(this._store.model.atKeyAndIndex(this._options.seriesKey, n));
    } else if (this.isNodeType("chord"))
      t.push(...this._layer.map.chartInfo.seriesInNavOrder().map((r) => r.datapoints[this._options.index]));
    else if (this.isNodeType("sequence"))
      for (let r = this._options.start; r < this._options.end; r++)
        t.push(this._store.model.atKeyAndIndex(this._options.seriesKey, r));
    else this.isNodeType("cluster") && t.push(...this._store.model.atKey(this._options.seriesKey).datapoints.filter((r) => this._options.datapoints.includes(r.datapointIndex)));
    return t;
  }
  clone(t) {
    const r = new zh(t, this._type, this._options, this._store);
    return r._links = new Map(this._links), r._index = this._index, r._id = this._id, r;
  }
  getLink(t) {
    return this._links.get(t);
  }
  setLink(t, r) {
    this._links.set(t, r.id);
  }
  removeLink(t) {
    this._links.delete(t);
  }
  connect(t, r, n = !0) {
    this.setLink(t, r), r instanceof zh && n && r.setLink(dI[t], this);
  }
  disconnect(t, r = !0) {
    const n = this._links.get(t);
    n && (this.removeLink(t), n[0] === ":" && r && this._layer.node(n).removeLink(dI[t]));
  }
  peekNode(t, r) {
    let n = this._id;
    for (; n && r--; ) {
      const i = this._layer.node(n).getLink(t);
      n = i && i[0] !== ":" ? void 0 : i;
    }
    return n ? this._layer.node(n) : void 0;
  }
  allNodes(t, r) {
    let n = 1, i;
    const s = [];
    for (; i = this.peekNode(t, n++), i && (!r || r === i.type); ) {
      if (s.includes(i))
        break;
      s.push(i);
    }
    return s;
  }
  async move(t) {
    const r = this._links.get(t);
    r && (r[0] === ":" ? this.layer.cursor = this._layer.node(r) : this._layer.map.currentLayer = r, this._layer.map.visitDatapoints());
  }
  go() {
    this.layer.goToNode(this);
  }
  isNodeType(t) {
    return this.type === t;
  }
  isDatapointNode() {
    return this.type === "datapoint";
  }
};
zh.nextId = 0;
let oa = zh;
var mn = /* @__PURE__ */ ((e) => (e.Annotation = "annotation", e.Bumper = "bumper", e.Threshold = "threshold", e.Intersection = "intersection", e.High = "high", e.Low = "low", e.Series = "series", e))(mn || {});
const ef = 130.8128, rf = 195.9977, Kw = ef * 2, q1 = rf * 2, fI = q1 * 2;
class Mvt {
  /**
   * Create a new OscillatorAudioEngine.
   * @param context - the audio context
   */
  constructor(t) {
    this._audioContext = t, this._masterCompressor = t.createDynamicsCompressor(), this._masterCompressor.connect(this._audioContext.destination), this._masterCompressor.threshold.value = -50, this._masterCompressor.knee.value = 40, this._masterCompressor.ratio.value = 12, this._masterCompressor.attack.value = 0, this._masterCompressor.release.value = 0.25, this._masterGain = this._audioContext.createGain(), this._masterGain.gain.value = 0.5, this._masterCompressor.connect(this._masterGain), this._masterGain.connect(this._audioContext.destination);
  }
  get masterGain() {
    return this._masterGain.gain.value;
  }
  /**
   *The overall loudness of the audio engine.
   */
  set masterGain(t) {
    this._masterGain.gain.value = t;
  }
  /**
   * Play a sound to represent a data point.
   * @param frequency - the fundimental frequency
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds, defaults to 0.2
   */
  playDataPoint(t, r, n = 0.2) {
    this._playNote(
      t,
      r,
      n,
      this._masterCompressor
    );
  }
  /**
   * Play an audio notification.
   * @param notificationType - the type of audio notification
   * @param [panning] - where to play the sound (-1 <= 0 <= 1, 0 == center). Default: 0
   * @param [duration] - the duration of the notification in seconds. Default: 0.15
   */
  playNotification(t, r = 0, n = 0.15) {
    switch (t) {
      case mn.Annotation:
        this._playAnnotation(r, n);
        break;
      case mn.Bumper:
        this._playBumper(r, n);
        break;
      case mn.Intersection:
        this._playIntersection(r, n);
        break;
      case mn.High:
        this._playHigh(r, n);
        break;
      case mn.Low:
        this._playLow(r, n);
        break;
      case mn.Series:
        this._playSeriesChange(r, n);
        break;
      case mn.Threshold:
        this._playThreshold(r, n);
        break;
    }
  }
  /**
   * Play a data point, sending the audio to the given destination node.
   * @param frequency - the fundimental frequency
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   * @param destinationNode - the node to receive the audio
   */
  _playNote(t, r, n, i) {
    const s = this._audioContext.currentTime, o = this._audioContext.createOscillator();
    o.frequency.value = t, o.start();
    const {
      carrier: a,
      amp: l,
      modulator: c,
      filter: h,
      adsr: u
    } = Nvt(
      this._audioContext,
      t * 0.5,
      t * 3,
      t * 2
    );
    a.type = "triangle", u.gain.setValueCurveAtTime([0.2, 0.1], s, n * 0.75), h.frequency.value = t, h.type = "lowpass";
    const p = this._audioContext.createGain();
    p.gain.setValueCurveAtTime(
      [0.5, 1, 0.5, 0.5, 0.5, 0.1, 1e-4],
      s,
      n
    );
    const y = this._audioContext.createStereoPanner();
    y.pan.value = r, o.connect(p), u.connect(p), p.connect(y), y.connect(i), setTimeout(
      () => {
        y.disconnect(), p.disconnect(), u.disconnect(), o.stop(), o.disconnect(), c.stop(), c.disconnect(), a.stop(), a.disconnect(), l.disconnect(), h.disconnect();
      },
      n * 1e3 * 2
    );
  }
  /**
   * Play a sound that means that an annotation is present.
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playAnnotation(t, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = t;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(ef, 0, r / 4, i), this._playNote(Kw, 0, r / 4, i), setTimeout(
      () => {
        this._playNote(rf, 0, r / 4, i), this._playNote(q1, 0, r / 4, i), this._playNote(fI, 0, r / 4, i);
      },
      r * 1e3 * 0.25
    ), setTimeout(
      () => {
        this._playNote(ef, 0, r / 4, i), this._playNote(Kw, 0, r / 4, i);
      },
      r * 1e3 * 0.5
    ), setTimeout(
      () => {
        this._playNote(rf, 0, r / 4, i), this._playNote(q1, 0, r / 4, i), this._playNote(fI, 0, r / 4, i);
      },
      r * 1e3 * 0.75
    ), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
   * Play a sound that means that an annotation is present.
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playBumper(t, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = t;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(ef, 0, r / 4, i), this._playNote(Kw, 0, r / 4, i), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
   * Play a sound that means that an annotation is present.
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playSeriesChange(t, r) {
  }
  /**
   * Play a sound to indicate this is the series or chart low
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playLow(t, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = t;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(rf, 0, r / 4, i), setTimeout(
      () => {
        this._playNote(ef, 0, r / 4, i);
      },
      r * 1e3 * 0.5
    ), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
   * Play a sound to indicate this is the series or chart high
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playHigh(t, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = t;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(rf, 0, r / 4, i), setTimeout(
      () => {
        this._playNote(q1, 0, r / 4, i);
      },
      r * 1e3 * 0.5
    ), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
  * Play a sound to indicate that this section contains an intersection
  * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
  * @param duration - the duration of the note in seconds
  */
  _playIntersection(t, r) {
  }
  /**
  * Play a sound to indicate that this section intersects a threshold line or point
  * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
  * @param duration - the duration of the note in seconds
  */
  _playThreshold(t, r) {
  }
}
function Nvt(e, t, r, n) {
  const i = e.createOscillator(), s = e.createGain(), o = e.createOscillator(), a = e.createBiquadFilter(), l = e.createGain();
  return i.frequency.value = t, o.frequency.value = r, s.gain.value = n, o.connect(s), s.connect(i.frequency), i.connect(a), a.connect(l), i.start(), o.start(), { carrier: i, amp: s, modulator: o, filter: a, adsr: l };
}
const Dvt = [
  16.3516,
  17.32391,
  18.35405,
  19.44544,
  20.60172,
  21.82676,
  23.12465,
  24.49971,
  25.95654,
  27.5,
  29.13524,
  30.86771,
  // octave 0
  32.7032,
  34.64783,
  36.7081,
  38.89087,
  41.20344,
  43.65353,
  46.2493,
  48.99943,
  51.91309,
  55,
  58.27047,
  61.73541,
  // octave 1
  65.40639,
  69.29566,
  73.41619,
  77.78175,
  82.40689,
  87.30706,
  92.49861,
  97.99886,
  103.8262,
  110,
  116.5409,
  123.4708,
  // octave 2
  130.8128,
  138.5913,
  146.8324,
  155.5635,
  164.8138,
  174.6141,
  184.9972,
  195.9977,
  207.6523,
  220,
  233.0819,
  246.9417,
  // octave 3
  261.6256,
  277.1826,
  293.6648,
  311.127,
  329.6276,
  349.2282,
  369.9944,
  391.9954,
  415.3047,
  440,
  466.1638,
  493.8833,
  // octave 4
  523.2511,
  554.3653,
  587.3295,
  622.254,
  659.2551,
  698.4565,
  739.9888,
  783.9909,
  830.6094,
  880,
  932.3275,
  987.7666,
  // octave 5
  1046.502,
  1108.731,
  1174.659,
  1244.508,
  1318.51,
  1396.913,
  1479.978,
  1567.982,
  1661.219,
  1760,
  1864.655,
  1975.533,
  // octave 6
  2093.005,
  2217.461,
  2349.318,
  2489.016,
  2637.02,
  2793.826,
  2959.955,
  3135.963,
  3322.438,
  3520,
  3729.31,
  3951.066,
  // octave 7
  4186.009,
  4434.922,
  4698.636,
  4978.032,
  5274.041,
  5587.652,
  5919.911,
  6271.927,
  6644.875,
  7040,
  7458.62,
  7902.133
  // octave 8
], gI = 0.25, Bvt = (e, t, r) => isNaN(e) || e < t || e > r, mI = (e) => isNaN(e) ? 0 : (e * 2 - 1) * 0.98, jvt = ({
  point: e,
  min: t,
  max: r,
  bins: n,
  scale: i
}) => Fvt({ point: e, min: t, max: r, bins: n }), Fvt = ({
  point: e,
  min: t,
  max: r,
  bins: n
}) => {
  const i = (e - t) / (r - t);
  return Math.floor(n * i);
};
class $vt {
  //private _playListContinuous: NodeJS.Timeout[] = [];
  constructor(t, r) {
    this._chartInfo = t, this._store = r, this.context = null, this._audioEngine = null;
  }
  /**
   * Confirm the audio engine was initialized
   */
  _checkAudioEngine() {
    this.context || (this.context = new AudioContext()), !this._audioEngine && this.context && (this._audioEngine = this._providedAudioEngine ?? new Mvt(this.context));
  }
  /**
   * Get the available hertzes
   * @returns number[]
   */
  _getHertzRange() {
    return Dvt.slice(
      this._store.settings.sonification.hertzLower,
      this._store.settings.sonification.hertzUpper
    );
  }
  /**
   * Play a given data point
   * @param datapoint - the data point to play
   */
  playDatapoints(t, {
    cont: r = !1,
    invert: n = !1,
    durationVariable: i = !1
  } = {}) {
    if (this._checkAudioEngine(), !this._audioEngine)
      return;
    const s = this._getHertzRange(), o = this._store.model.getFacet("x").datatype === "string";
    t.forEach((a, l) => {
      const c = a.facetValueNumericized(a.indepKey ?? "x");
      let h = a.facetValueNumericized(a.depKey ?? "y");
      const u = o ? l : c - this._chartInfo.axisInfo.xLabelInfo.min, p = o ? t.length - 1 : this._chartInfo.axisInfo.xLabelInfo.range, y = (
        /*this._xAxis.type === 'log10'
          ? calcPan(
            (Math.log10(current.x) -
              Math.log10(this._xAxis.minimum)) /
            (Math.log10(this._xAxis.maximum) -
              Math.log10(this._xAxis.minimum))
          )
          :*/
        mI(
          u / p
        )
      );
      let g, b;
      if (this._chartInfo.axisInfo)
        g = this._chartInfo.axisInfo.yLabelInfo.min, b = this._chartInfo.axisInfo.yLabelInfo.max;
      else {
        const E = this._store.model.getFacetInterval("y");
        g = E.start, b = E.end;
      }
      const f = h;
      if (n && (h = b - (h - g)), !Bvt(h, g, b))
        if (r) {
          let E = Math.min(...s);
          const A = (h - g) / (b - g), x = E * 1.05946 ** (A * s.length);
          let m = mI((c - this._chartInfo.axisInfo.xLabelInfo.min) / this._chartInfo.axisInfo.xLabelInfo.range);
          this._audioEngine.playDataPoint(x, m, gI);
        } else {
          const E = jvt({
            point: h,
            min: g,
            max: b,
            bins: s.length - 1,
            scale: "linear"
          }), A = i ? 0.1 + (f - g) / (b - g) : gI;
          this._audioEngine.playDataPoint(s[E], y, A);
        }
    });
  }
  /**
   * Play an audio notification
   * @param earcon - the type of notification to play
   */
  playNotification(t) {
    if (this._store.settings.sonification.isNotificationEnabled) {
      if (this._checkAudioEngine(), !this._audioEngine)
        return;
      let r = mn.Annotation, n = 0.5;
      switch (t) {
        case "annotation":
          r = mn.Annotation;
          break;
        case "bumper":
          r = mn.Bumper, n = 0.25;
          break;
        case "high":
          r = mn.High;
          break;
        case "low":
          r = mn.Low;
          break;
        case "series":
          r = mn.Series, n = 0.3;
          break;
        case "intersection":
          r = mn.Intersection;
          break;
        case "threshold":
          r = mn.Threshold;
          break;
      }
      this._audioEngine.playNotification(r, 0, n);
    }
  }
}
class KF extends mL {
  constructor(t, r) {
    super(), this._type = t, this._store = r, this._navMap = null, this._axisInfo = null, this._chordPrevSeriesKey = "", this._soniInterval = null, this._soniRiffInterval = null, this._init(), this._addSettingControls();
  }
  _addSettingControls() {
    this._store.settingControls.add({
      type: "textfield",
      key: "chart.size.width",
      label: "Width",
      options: {
        inputType: "number",
        min: 1,
        max: 1e3
      },
      parentView: "controlPanel.tabs.chart.general.width"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "chart.size.height",
      label: "Height",
      options: {
        inputType: "number",
        min: 1,
        max: 1e3
      },
      parentView: "controlPanel.tabs.chart.general.height"
    });
  }
  _init() {
    this._createNavMap(), this._sonifier = new $vt(this, this._store), this._storeChangeUnsub = this._store.subscribe(async (t, r) => {
      t === "data" && this._createSummarizer();
    }), this._createSummarizer();
  }
  _createSummarizer() {
    this._summarizer = this._type === "pie" || this._type === "donut" ? new Qb(this._store.model) : new Gb(this._store.model);
  }
  get summarizer() {
    return this._summarizer;
  }
  get managedSettingKeys() {
    return [`type.${this._type}`];
  }
  get settings() {
    return dr.getGroupLink(this.managedSettingKeys[0], this._store.settings);
  }
  get navMap() {
    return this._navMap;
  }
  /** Overridden by ScatterChartInfo */
  get navDatapointType() {
    return "datapoint";
  }
  get axisInfo() {
    return this._axisInfo;
  }
  settingDidChange(t, r, n) {
  }
  async storeDidChange(t, r) {
  }
  noticePosted(t, r) {
  }
  _createNavMap() {
    this._navMap = new qA(this._store, this);
    const t = this._navMap.layer("root"), r = new oa(t, "top", {}, this._store);
    t.registerNode(r), t.cursor = r;
  }
  didAddHighlight(t) {
  }
  didRemoveHighlight(t) {
  }
  legend() {
    return [];
  }
  popuplegend() {
    return this.seriesInNavOrder().map((r) => r.key).map((r, n) => ({
      label: "",
      color: this._store.seriesProperties.properties(r).color,
      symbol: this._store.seriesProperties.properties(r).symbol
    }));
  }
  navToDatapoint(t, r) {
    this._navMap.goTo(this.navDatapointType, { seriesKey: t, index: r });
  }
  async move(t) {
    await this._navMap.cursor.move(t), this._store.paraChart.postNotice("move", { dir: t, options: this._navMap.cursor.options });
  }
  /**
   * Navigate to the series minimum/maximum datapoint
   * @param isMin - If true, go the the minimum. Otherwise, go to the maximum
   */
  goSeriesMinMax(t) {
    const r = this._navMap.cursor;
    if (r.isNodeType("top") || r.isNodeType("chord"))
      this.goChartMinMax(t);
    else if (r.isNodeType(this.navDatapointType) || r.isNodeType("series") || r.isNodeType("sequence") || r.isNodeType("cluster")) {
      let n = null;
      const i = r.options.seriesKey;
      r.isNodeType(this.navDatapointType) && (n = this._store.model.atKeyAndIndex(r.options.seriesKey, r.options.index));
      const s = this._store.model.dependentFacetKeys[0], o = this._store.model.atKey(i).getFacetStats(s);
      let a = t ? o.min.datapoints : o.max.datapoints;
      if (n && a.length > 1) {
        const l = a.findIndex((c) => c === n);
        l !== -1 && l !== a.length + 1 && (a = a.toSpliced(0, l));
      }
      this._navMap.goTo(this.navDatapointType, {
        seriesKey: a[0].seriesKey,
        index: a[0].datapointIndex
      }), this._store.paraChart.postNotice("goSeriesMinMax", { isMin: t, options: this._navMap.cursor.options });
    }
  }
  /**
   * Navigate to (one of) the chart minimum/maximum datapoint(s)
   * @param isMin - If true, go the the minimum. Otherwise, go to the maximum
   */
  goChartMinMax(t) {
    const r = this._store.model.getFacetStats("y"), n = t ? r.min.value : r.max.value, i = this._store.model.allPoints.find((s) => s.facetValueAsNumber("y") === n);
    this._navMap.goTo(this.navDatapointType, {
      seriesKey: i == null ? void 0 : i.seriesKey,
      index: i == null ? void 0 : i.datapointIndex
    }), this._store.paraChart.postNotice("goChartMinMax", { isMin: t, options: this._navMap.cursor.options });
  }
  _composePointSelectionAnnouncement(t) {
    const r = (c) => {
      const { seriesKey: h, index: u } = Zr(c), p = this._store.model.atKeyAndIndex(h, u);
      return `${h} (${jr(p.facetBox("x"), this._store.getFormatType("statusBar"))}, ${jr(p.facetBox("y"), this._store.getFormatType("statusBar"))})`;
    }, n = this._store.selectedDatapoints.size, i = this._store.prevSelectedDatapoints.size, s = this._store.selectedDatapoints.difference(
      this._store.prevSelectedDatapoints
    ), o = this._store.prevSelectedDatapoints.difference(
      this._store.selectedDatapoints
    ), l = `${n} point${n === 1 ? "" : "s"} selected.`;
    return i === 0 ? `Selected ${r(s.values().toArray()[0])}` : i === 1 && !n ? `Deselected ${r(o.values().toArray()[0])}. No points selected.` : !t && s.size && i ? `Selected ${r(s.values().toArray()[0])}. 1 point selected.` : !t && n && i ? `Deselected ${r(o.values().toArray()[0])}. 1 point selected.` : t && o.size ? `Deselected ${r(o.values().toArray()[0])}. ${l}` : t && s.size ? `Selected ${r(s.values().toArray()[0])}. ${l}` : "ERROR";
  }
  _composeSeriesSelectionAnnouncement() {
    const t = this._store.selectedDatapoints.size, r = this._store.prevSelectedDatapoints.size, n = this._store.selectedDatapoints.values().filter((a) => {
      const l = Zr(a);
      return !this._store.wasSelected(l.seriesKey, l.index);
    }).toArray();
    let i = t === 1 ? "" : "s";
    const s = `${t} point${i} selected.`;
    i = n.length === 1 ? "" : "s";
    const o = `Selected ${n.length} point${i}.`;
    return r === 0 ? o : `${o} ${s}`;
  }
  selectCurrent(t = !1) {
    t ? this._store.extendSelection() : this._store.select();
    const r = this._navMap.cursor.isNodeType("datapoint") ? this._composePointSelectionAnnouncement(t) : this._navMap.cursor.isNodeType("series") ? this._composeSeriesSelectionAnnouncement() : "";
    r && this._store.announce(r), this._store.paraChart.postNotice("select", { isExtend: t, options: this._navMap.cursor.options });
  }
  clearDatapointSelection(t = !1) {
    this._store.clearSelected(), t || this._store.announce("No items selected."), this._store.paraChart.postNotice("clearSelection", null);
  }
  // NOTE: This should be overriden in subclasses
  queryData() {
    const t = this._navMap.cursor.type;
    this._store.announce(
      `[ParaChart/Internal] Error: DataLayer.queryData should be overriden. Query Type: ${t}`
    );
  }
  navFirst() {
    var r;
    const t = this._navMap.cursor.type;
    if ([this.navDatapointType, "chord", "series"].includes(t)) {
      const n = {
        datapoint: "left",
        chord: "left",
        series: "up"
      };
      (r = this._navMap.cursor.allNodes(n[t], t).at(-1)) == null || r.go(), this._store.paraChart.postNotice("goFirst", { options: this._navMap.cursor.options });
    }
  }
  navLast() {
    var r;
    const t = this._navMap.cursor.type;
    if ([this.navDatapointType, "chord", "series"].includes(t)) {
      const n = {
        datapoint: "right",
        chord: "right",
        series: "down"
      };
      (r = this._navMap.cursor.allNodes(n[t], t).at(-1)) == null || r.go(), this._store.paraChart.postNotice("goLast", { options: this._navMap.cursor.options });
    }
  }
  navToChordLanding() {
    if (["line", "bar", "column"].includes(this._store.type) && this._store.model.series.length > 1)
      if (this._navMap.cursor.isNodeType(this.navDatapointType)) {
        const t = this._navMap.cursor.options.seriesKey;
        this._navMap.cursor.layer.goTo("chord", this._navMap.cursor.options.index), this._chordPrevSeriesKey = t, this._store.paraChart.postNotice("enterChordMode", { options: this._navMap.cursor.options });
      } else this._navMap.cursor.isNodeType("chord") && (this._navMap.cursor.layer.goTo(
        this.navDatapointType,
        {
          seriesKey: this._chordPrevSeriesKey,
          index: this._navMap.cursor.options.index
        }
      ), this._store.paraChart.postNotice("exitChordMode", { options: this._navMap.cursor.options }));
    else
      console.log("Chord mode not supported for this chart type");
  }
  async navRunDidStart(t) {
    (t.isNodeType("series") || t.isNodeType(this.navDatapointType)) && (this._store.frontSeries = t.options.seriesKey);
  }
  async navRunDidEnd(t) {
    if (t.isNodeType("top"))
      this._store.announce(await this._summarizer.getChartSummary());
    else if (t.isNodeType("series"))
      this._store.announce(
        await this._summarizer.getSeriesSummary(t.options.seriesKey)
      ), this._playCurrentRiff(), this._store.sparkBrailleInfo = this._sparkBrailleInfo();
    else if (t.isNodeType(this.navDatapointType)) {
      const r = this._store.everVisitedSeries(t.options.seriesKey), n = this._store.model.atKeyAndIndex(t.options.seriesKey, t.options.index), i = [this._summarizer.getDatapointSummary(n, "statusBar")];
      if (!this._store.wasVisitedSeries(t.options.seriesKey) && (i[0] = `${t.options.seriesKey}: ${i[0]}`, !r)) {
        const o = await this._summarizer.getSeriesSummary(t.options.seriesKey);
        i.push(o.text);
      }
      this._store.announce(i), this._store.settings.sonification.isSoniEnabled && this.playDatapoints([n]), this._store.sparkBrailleInfo = this._sparkBrailleInfo();
    } else if (t.isNodeType("chord")) {
      if (this._store.settings.sonification.isSoniEnabled)
        if (this._store.settings.sonification.isArpeggiateChords)
          this._playCurrentRiff(this._chordRiffOrder());
        else {
          const r = t.datapoints.map((n) => this._store.model.atKeyAndIndex(n.seriesKey, n.datapointIndex));
          this.playDatapoints(r);
        }
    } else t.isNodeType("sequence") && (this._store.announce(
      await this._summarizer.getSequenceSummary({
        seriesKey: t.options.seriesKey,
        start: t.options.start,
        end: t.options.end
      })
    ), this._playCurrentRiff());
  }
  /** Can be overridden by subclasses. */
  seriesInNavOrder() {
    return this._store.model.series;
  }
  /** Nav map layer from which to interpret selectors */
  get selectorLayer() {
    return "root";
  }
  datapointsForSelector(t) {
    return this._navMap.datapointsForSelector(this.selectorLayer, t);
  }
  isHighlighted(t, r) {
    if (this._store.highlightedSelector) {
      const n = this.datapointsForSelector(this._store.highlightedSelector);
      for (const i of n)
        if (i.seriesKey === t && i.datapointIndex === r)
          return !0;
    }
    return !1;
  }
  get shouldDrawFocusRing() {
    return this._navMap.cursor.type !== "top";
  }
  /** Play a riff for the current nav node */
  _playCurrentRiff(t) {
    this._store.settings.sonification.isSoniEnabled && this._store.settings.sonification.isRiffEnabled && this.playRiff(this._navMap.cursor.datapoints, t);
  }
  _chordRiffOrder() {
    return "normal";
  }
  /**
   * Clear outstanding play intervals/timeouts
   */
  clearPlay() {
    clearInterval(this._soniInterval), clearInterval(this._soniRiffInterval);
  }
  getXAxisInterval() {
    let t = [];
    if (this._store.model.getFacet("x").datatype === "number" || this._store.model.getFacet("x").datatype === "date")
      t = this._store.model.allFacetValues("x").map((r) => r.asNumber());
    else
      throw new Error("axis must be of type number or date to take interval");
    return { start: Math.min(...t), end: Math.max(...t) };
  }
  getYAxisInterval() {
    if (!this.axisInfo)
      throw new Error("chart is missing `axisInfo` object");
    return {
      start: this.axisInfo.yLabelInfo.min,
      end: this.axisInfo.yLabelInfo.max
    };
  }
  getAxisInterval(t) {
    return t === "x" ? this.getXAxisInterval() : this.getYAxisInterval();
  }
}
const zvt = [1e3, 250, 100, 50, 25], ZF = [450, 300, 150, 100, 75];
class YA extends KF {
  constructor(t, r) {
    super(t, r), this._soniSequenceIndex = 0, this._soniNoteIndex = 0, this._soniSpeedRateIndex = 1;
  }
  _createNavMap() {
    super._createNavMap(), this._createPrimaryNavNodes(), this._store.model.seriesKeys.length > 1 && (this._createVerticalNavLinks(), this._createChordNavNodes());
  }
  get _datapointNavNodeType() {
    return "datapoint";
  }
  _datapointNavNodeOptions(t) {
    return {
      seriesKey: t.seriesKey,
      index: t.datapointIndex
    };
  }
  _createPrimaryNavNodes() {
    let t = this._navMap.root.get("top");
    this._store.model.dependentFacetKeys[0], this.seriesInNavOrder().forEach((n, i) => {
      const s = new oa(this._navMap.root, "series", {
        seriesKey: n.key
      }, this._store);
      s.connect("left", t), t = s, n.datapoints.forEach((o, a) => {
        const l = new oa(
          this._navMap.root,
          this._datapointNavNodeType,
          this._datapointNavNodeOptions(o),
          this._store
        );
        l.connect("left", t), t = l;
      });
    });
  }
  _createVerticalNavLinks() {
    this._store.model.series.slice(0, -1).forEach((t, r) => {
      const n = this._navMap.root.get("series", r), i = this._navMap.root.get("series", r + 1);
      n.connect("down", i);
      for (let s = 1; s <= t.datapoints.length; s++)
        n.peekNode("right", s).connect(
          "down",
          i.peekNode("right", s)
        );
    });
  }
  _createChordNavNodes() {
    this._navMap.root.query(this._datapointNavNodeType, {
      seriesKey: this.seriesInNavOrder()[0].key
    }).forEach((t) => {
      new oa(
        this._navMap.root,
        "chord",
        { index: t.options.index },
        this._store
      );
    }), this._navMap.root.query("chord").slice(0, -1).forEach((t, r) => {
      t.connect("right", this._navMap.root.get("chord", r + 1));
    });
  }
  playRiff(t, r) {
    r === "sorted" ? t.sort((n, i) => n.facetValueAsNumber("y") - i.facetValueAsNumber("y")) : r === "reversed" && t.reverse(), t.length && (this._soniRiffInterval && clearInterval(this._soniRiffInterval), this._soniSequenceIndex++, this._soniRiffInterval = setInterval(() => {
      const n = t.shift();
      n ? (this._sonifier.playDatapoints([n]), this._soniNoteIndex++) : clearInterval(this._soniRiffInterval);
    }, ZF.at(this._store.settings.sonification.riffSpeedIndex)));
  }
  playDatapoints(t) {
    this._sonifier.playDatapoints(t);
  }
  playDir(t) {
    if (this._navMap.cursor.type !== this._datapointNavNodeType)
      return;
    this.clearPlay();
    let r = this._navMap.cursor;
    this._soniInterval = setInterval(() => {
      const n = r.peekNode(t, 1);
      n && n.type === this._datapointNavNodeType ? (this.playDatapoints([n.datapoints[0]]), r = n) : this.clearPlay();
    }, zvt.at(this._soniSpeedRateIndex));
  }
  _sparkBrailleInfo() {
    return {
      data: this._navMap.cursor.isNodeType(this._datapointNavNodeType) || this._navMap.cursor.isNodeType("series") || this._navMap.cursor.isNodeType("sequence") ? this._store.model.atKey(this._navMap.cursor.options.seriesKey).datapoints.map((t) => t.facetValueAsNumber("y")).join(" ") : "0",
      isBar: this._type === "bar" || this._type === "column"
    };
  }
}
/*!
 *  decimal.js v10.5.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var j4 = 9e15, Nc = 1e9, F4 = "0123456789abcdef", Ey = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", Ay = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", $4 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -9e15,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: j4,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, JF, Ko, xe = !0, qb = "[DecimalError] ", Wl = qb + "Invalid argument: ", XF = qb + "Precision limit exceeded", t$ = qb + "crypto unavailable", e$ = "[object Decimal]", Rn = Math.floor, zr = Math.pow, Vvt = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, Uvt = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, Hvt = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, r$ = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Is = 1e7, ve = 7, Gvt = 9007199254740991, Qvt = Ey.length - 1, z4 = Ay.length - 1, Dt = { toStringTag: e$ };
Dt.absoluteValue = Dt.abs = function() {
  var e = new this.constructor(this);
  return e.s < 0 && (e.s = 1), ue(e);
};
Dt.ceil = function() {
  return ue(new this.constructor(this), this.e + 1, 2);
};
Dt.clampedTo = Dt.clamp = function(e, t) {
  var r, n = this, i = n.constructor;
  if (e = new i(e), t = new i(t), !e.s || !t.s) return new i(NaN);
  if (e.gt(t)) throw Error(Wl + t);
  return r = n.cmp(e), r < 0 ? e : n.cmp(t) > 0 ? t : new i(n);
};
Dt.comparedTo = Dt.cmp = function(e) {
  var t, r, n, i, s = this, o = s.d, a = (e = new s.constructor(e)).d, l = s.s, c = e.s;
  if (!o || !a)
    return !l || !c ? NaN : l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? l : a[0] ? -c : 0;
  if (l !== c) return l;
  if (s.e !== e.e) return s.e > e.e ^ l < 0 ? 1 : -1;
  for (n = o.length, i = a.length, t = 0, r = n < i ? n : i; t < r; ++t)
    if (o[t] !== a[t]) return o[t] > a[t] ^ l < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
};
Dt.cosine = Dt.cos = function() {
  var e, t, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + ve, n.rounding = 1, r = Wvt(n, a$(n, r)), n.precision = e, n.rounding = t, ue(Ko == 2 || Ko == 3 ? r.neg() : r, e, t, !0)) : new n(1) : new n(NaN);
};
Dt.cubeRoot = Dt.cbrt = function() {
  var e, t, r, n, i, s, o, a, l, c, h = this, u = h.constructor;
  if (!h.isFinite() || h.isZero()) return new u(h);
  for (xe = !1, s = h.s * zr(h.s * h, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = sn(h.d), e = h.e, (s = (e - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = zr(r, 1 / 3), e = Rn((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + e : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new u(r), n.s = h.s) : n = new u(s.toString()), o = (e = u.precision) + 3; ; )
    if (a = n, l = a.times(a).times(a), c = l.plus(h), n = rr(c.plus(h).times(a), c.plus(l), o + 2, 1), sn(a.d).slice(0, o) === (r = sn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (ue(a, e + 1, 0), a.times(a).times(a).eq(h))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (ue(n, e + 1, 1), t = !n.times(n).times(n).eq(h));
        break;
      }
  return xe = !0, ue(n, e, u.rounding, t);
};
Dt.decimalPlaces = Dt.dp = function() {
  var e, t = this.d, r = NaN;
  if (t) {
    if (e = t.length - 1, r = (e - Rn(this.e / ve)) * ve, e = t[e], e) for (; e % 10 == 0; e /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
Dt.dividedBy = Dt.div = function(e) {
  return rr(this, new this.constructor(e));
};
Dt.dividedToIntegerBy = Dt.divToInt = function(e) {
  var t = this, r = t.constructor;
  return ue(rr(t, new r(e), 0, 1, 1), r.precision, r.rounding);
};
Dt.equals = Dt.eq = function(e) {
  return this.cmp(e) === 0;
};
Dt.floor = function() {
  return ue(new this.constructor(this), this.e + 1, 3);
};
Dt.greaterThan = Dt.gt = function(e) {
  return this.cmp(e) > 0;
};
Dt.greaterThanOrEqualTo = Dt.gte = function(e) {
  var t = this.cmp(e);
  return t == 1 || t === 0;
};
Dt.hyperbolicCosine = Dt.cosh = function() {
  var e, t, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (e = Math.ceil(i / 3), t = (1 / Kb(4, e)).toString()) : (e = 16, t = "2.3283064365386962890625e-10"), s = yp(o, 1, s.times(t), new o(1), !0);
  for (var l, c = e, h = new o(8); c--; )
    l = s.times(s), s = a.minus(l.times(h.minus(l.times(h))));
  return ue(s, o.precision = r, o.rounding = n, !0);
};
Dt.hyperbolicSine = Dt.sinh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero()) return new s(i);
  if (t = s.precision, r = s.rounding, s.precision = t + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = yp(s, 2, i, i, !0);
  else {
    e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / Kb(5, e)), i = yp(s, 2, i, i, !0);
    for (var o, a = new s(5), l = new s(16), c = new s(20); e--; )
      o = i.times(i), i = i.times(a.plus(o.times(l.times(o).plus(c))));
  }
  return s.precision = t, s.rounding = r, ue(i, t, r, !0);
};
Dt.hyperbolicTangent = Dt.tanh = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, rr(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s);
};
Dt.inverseCosine = Dt.acos = function() {
  var e = this, t = e.constructor, r = e.abs().cmp(1), n = t.precision, i = t.rounding;
  return r !== -1 ? r === 0 ? e.isNeg() ? ho(t, n, i) : new t(0) : new t(NaN) : e.isZero() ? ho(t, n + 4, i).times(0.5) : (t.precision = n + 6, t.rounding = 1, e = new t(1).minus(e).div(e.plus(1)).sqrt().atan(), t.precision = n, t.rounding = i, e.times(2));
};
Dt.inverseHyperbolicCosine = Dt.acosh = function() {
  var e, t, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, xe = !1, r = r.times(r).minus(1).sqrt().plus(r), xe = !0, n.precision = e, n.rounding = t, r.ln()) : new n(r);
};
Dt.inverseHyperbolicSine = Dt.asinh = function() {
  var e, t, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, xe = !1, r = r.times(r).plus(1).sqrt().plus(r), xe = !0, n.precision = e, n.rounding = t, r.ln());
};
Dt.inverseHyperbolicTangent = Dt.atanh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = s.precision, t = s.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? ue(new s(i), e, t, !0) : (s.precision = r = n - i.e, i = rr(i.plus(1), new s(1).minus(i), r + e, 1), s.precision = e + 4, s.rounding = 1, i = i.ln(), s.precision = e, s.rounding = t, i.times(0.5))) : new s(NaN);
};
Dt.inverseSine = Dt.asin = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (t = i.abs().cmp(1), r = s.precision, n = s.rounding, t !== -1 ? t === 0 ? (e = ho(s, r + 4, n).times(0.5), e.s = i.s, e) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
Dt.inverseTangent = Dt.atan = function() {
  var e, t, r, n, i, s, o, a, l, c = this, h = c.constructor, u = h.precision, p = h.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new h(c);
    if (c.abs().eq(1) && u + 4 <= z4)
      return o = ho(h, u + 4, p).times(0.25), o.s = c.s, o;
  } else {
    if (!c.s) return new h(NaN);
    if (u + 4 <= z4)
      return o = ho(h, u + 4, p).times(0.5), o.s = c.s, o;
  }
  for (h.precision = a = u + 10, h.rounding = 1, r = Math.min(28, a / ve + 2 | 0), e = r; e; --e) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (xe = !1, t = Math.ceil(a / ve), n = 1, l = c.times(c), o = new h(c), i = c; e !== -1; )
    if (i = i.times(l), s = o.minus(i.div(n += 2)), i = i.times(l), o = s.plus(i.div(n += 2)), o.d[t] !== void 0) for (e = t; o.d[e] === s.d[e] && e--; ) ;
  return r && (o = o.times(2 << r - 1)), xe = !0, ue(o, h.precision = u, h.rounding = p, !0);
};
Dt.isFinite = function() {
  return !!this.d;
};
Dt.isInteger = Dt.isInt = function() {
  return !!this.d && Rn(this.e / ve) > this.d.length - 2;
};
Dt.isNaN = function() {
  return !this.s;
};
Dt.isNegative = Dt.isNeg = function() {
  return this.s < 0;
};
Dt.isPositive = Dt.isPos = function() {
  return this.s > 0;
};
Dt.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
Dt.lessThan = Dt.lt = function(e) {
  return this.cmp(e) < 0;
};
Dt.lessThanOrEqualTo = Dt.lte = function(e) {
  return this.cmp(e) < 1;
};
Dt.logarithm = Dt.log = function(e) {
  var t, r, n, i, s, o, a, l, c = this, h = c.constructor, u = h.precision, p = h.rounding, y = 5;
  if (e == null)
    e = new h(10), t = !0;
  else {
    if (e = new h(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1)) return new h(NaN);
    t = e.eq(10);
  }
  if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1))
    return new h(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (t)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      s = i !== 1;
    }
  if (xe = !1, a = u + y, o = gl(c, a), n = t ? Sy(h, a + 10) : gl(e, a), l = rr(o, n, a, 1), d0(l.d, i = u, p))
    do
      if (a += 10, o = gl(c, a), n = t ? Sy(h, a + 10) : gl(e, a), l = rr(o, n, a, 1), !s) {
        +sn(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = ue(l, u + 1, 0));
        break;
      }
    while (d0(l.d, i += 10, p));
  return xe = !0, ue(l, u, p);
};
Dt.minus = Dt.sub = function(e) {
  var t, r, n, i, s, o, a, l, c, h, u, p, y = this, g = y.constructor;
  if (e = new g(e), !y.d || !e.d)
    return !y.s || !e.s ? e = new g(NaN) : y.d ? e.s = -e.s : e = new g(e.d || y.s !== e.s ? y : NaN), e;
  if (y.s != e.s)
    return e.s = -e.s, y.plus(e);
  if (c = y.d, p = e.d, a = g.precision, l = g.rounding, !c[0] || !p[0]) {
    if (p[0]) e.s = -e.s;
    else if (c[0]) e = new g(y);
    else return new g(l === 3 ? -0 : 0);
    return xe ? ue(e, a, l) : e;
  }
  if (r = Rn(e.e / ve), h = Rn(y.e / ve), c = c.slice(), s = h - r, s) {
    for (u = s < 0, u ? (t = c, s = -s, o = p.length) : (t = p, r = h, o = c.length), n = Math.max(Math.ceil(a / ve), o) + 2, s > n && (s = n, t.length = 1), t.reverse(), n = s; n--; ) t.push(0);
    t.reverse();
  } else {
    for (n = c.length, o = p.length, u = n < o, u && (o = n), n = 0; n < o; n++)
      if (c[n] != p[n]) {
        u = c[n] < p[n];
        break;
      }
    s = 0;
  }
  for (u && (t = c, c = p, p = t, e.s = -e.s), o = c.length, n = p.length - o; n > 0; --n) c[o++] = 0;
  for (n = p.length; n > s; ) {
    if (c[--n] < p[n]) {
      for (i = n; i && c[--i] === 0; ) c[i] = Is - 1;
      --c[i], c[n] += Is;
    }
    c[n] -= p[n];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --r;
  return c[0] ? (e.d = c, e.e = Yb(c, r), xe ? ue(e, a, l) : e) : new g(l === 3 ? -0 : 0);
};
Dt.modulo = Dt.mod = function(e) {
  var t, r = this, n = r.constructor;
  return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? ue(new n(r), n.precision, n.rounding) : (xe = !1, n.modulo == 9 ? (t = rr(r, e.abs(), 0, 3, 1), t.s *= e.s) : t = rr(r, e, 0, n.modulo, 1), t = t.times(e), xe = !0, r.minus(t));
};
Dt.naturalExponential = Dt.exp = function() {
  return V4(this);
};
Dt.naturalLogarithm = Dt.ln = function() {
  return gl(this);
};
Dt.negated = Dt.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s, ue(e);
};
Dt.plus = Dt.add = function(e) {
  var t, r, n, i, s, o, a, l, c, h, u = this, p = u.constructor;
  if (e = new p(e), !u.d || !e.d)
    return !u.s || !e.s ? e = new p(NaN) : u.d || (e = new p(e.d || u.s === e.s ? u : NaN)), e;
  if (u.s != e.s)
    return e.s = -e.s, u.minus(e);
  if (c = u.d, h = e.d, a = p.precision, l = p.rounding, !c[0] || !h[0])
    return h[0] || (e = new p(u)), xe ? ue(e, a, l) : e;
  if (s = Rn(u.e / ve), n = Rn(e.e / ve), c = c.slice(), i = s - n, i) {
    for (i < 0 ? (r = c, i = -i, o = h.length) : (r = h, n = s, o = c.length), s = Math.ceil(a / ve), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = c.length, i = h.length, o - i < 0 && (i = o, r = h, h = c, c = r), t = 0; i; )
    t = (c[--i] = c[i] + h[i] + t) / Is | 0, c[i] %= Is;
  for (t && (c.unshift(t), ++n), o = c.length; c[--o] == 0; ) c.pop();
  return e.d = c, e.e = Yb(c, n), xe ? ue(e, a, l) : e;
};
Dt.precision = Dt.sd = function(e) {
  var t, r = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(Wl + e);
  return r.d ? (t = n$(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
};
Dt.round = function() {
  var e = this, t = e.constructor;
  return ue(new t(e), e.e + 1, t.rounding);
};
Dt.sine = Dt.sin = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + ve, n.rounding = 1, r = Yvt(n, a$(n, r)), n.precision = e, n.rounding = t, ue(Ko > 2 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
Dt.squareRoot = Dt.sqrt = function() {
  var e, t, r, n, i, s, o = this, a = o.d, l = o.e, c = o.s, h = o.constructor;
  if (c !== 1 || !a || !a[0])
    return new h(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (xe = !1, c = Math.sqrt(+o), c == 0 || c == 1 / 0 ? (t = sn(a), (t.length + l) % 2 == 0 && (t += "0"), c = Math.sqrt(t), l = Rn((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? t = "5e" + l : (t = c.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + l), n = new h(t)) : n = new h(c.toString()), r = (l = h.precision) + 3; ; )
    if (s = n, n = s.plus(rr(o, s, r + 2, 1)).times(0.5), sn(s.d).slice(0, r) === (t = sn(n.d)).slice(0, r))
      if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
        if (!i && (ue(s, l + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+t || !+t.slice(1) && t.charAt(0) == "5") && (ue(n, l + 1, 1), e = !n.times(n).eq(o));
        break;
      }
  return xe = !0, ue(n, l, h.rounding, e);
};
Dt.tangent = Dt.tan = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = rr(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, ue(Ko == 2 || Ko == 4 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
Dt.times = Dt.mul = function(e) {
  var t, r, n, i, s, o, a, l, c, h = this, u = h.constructor, p = h.d, y = (e = new u(e)).d;
  if (e.s *= h.s, !p || !p[0] || !y || !y[0])
    return new u(!e.s || p && !p[0] && !y || y && !y[0] && !p ? NaN : !p || !y ? e.s / 0 : e.s * 0);
  for (r = Rn(h.e / ve) + Rn(e.e / ve), l = p.length, c = y.length, l < c && (s = p, p = y, y = s, o = l, l = c, c = o), s = [], o = l + c, n = o; n--; ) s.push(0);
  for (n = c; --n >= 0; ) {
    for (t = 0, i = l + n; i > n; )
      a = s[i] + y[n] * p[i - n - 1] + t, s[i--] = a % Is | 0, t = a / Is | 0;
    s[i] = (s[i] + t) % Is | 0;
  }
  for (; !s[--o]; ) s.pop();
  return t ? ++r : s.shift(), e.d = s, e.e = Yb(s, r), xe ? ue(e, u.precision, u.rounding) : e;
};
Dt.toBinary = function(e, t) {
  return KA(this, 2, e, t);
};
Dt.toDecimalPlaces = Dt.toDP = function(e, t) {
  var r = this, n = r.constructor;
  return r = new n(r), e === void 0 ? r : (ti(e, 0, Nc), t === void 0 ? t = n.rounding : ti(t, 0, 8), ue(r, e + r.e + 1, t));
};
Dt.toExponential = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = Po(n, !0) : (ti(e, 0, Nc), t === void 0 ? t = i.rounding : ti(t, 0, 8), n = ue(new i(n), e + 1, t), r = Po(n, !0, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Dt.toFixed = function(e, t) {
  var r, n, i = this, s = i.constructor;
  return e === void 0 ? r = Po(i) : (ti(e, 0, Nc), t === void 0 ? t = s.rounding : ti(t, 0, 8), n = ue(new s(i), e + i.e + 1, t), r = Po(n, !1, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
Dt.toFraction = function(e) {
  var t, r, n, i, s, o, a, l, c, h, u, p, y = this, g = y.d, b = y.constructor;
  if (!g) return new b(y);
  if (c = r = new b(1), n = l = new b(0), t = new b(n), s = t.e = n$(g) - y.e - 1, o = s % ve, t.d[0] = zr(10, o < 0 ? ve + o : o), e == null)
    e = s > 0 ? t : c;
  else {
    if (a = new b(e), !a.isInt() || a.lt(c)) throw Error(Wl + a);
    e = a.gt(t) ? s > 0 ? t : c : a;
  }
  for (xe = !1, a = new b(sn(g)), h = b.precision, b.precision = s = g.length * ve * 2; u = rr(a, t, 0, 1, 1), i = r.plus(u.times(n)), i.cmp(e) != 1; )
    r = n, n = i, i = c, c = l.plus(u.times(i)), l = i, i = t, t = a.minus(u.times(i)), a = i;
  return i = rr(e.minus(r), n, 0, 1, 1), l = l.plus(i.times(c)), r = r.plus(i.times(n)), l.s = c.s = y.s, p = rr(c, n, s, 1).minus(y).abs().cmp(rr(l, r, s, 1).minus(y).abs()) < 1 ? [c, n] : [l, r], b.precision = h, xe = !0, p;
};
Dt.toHexadecimal = Dt.toHex = function(e, t) {
  return KA(this, 16, e, t);
};
Dt.toNearest = function(e, t) {
  var r = this, n = r.constructor;
  if (r = new n(r), e == null) {
    if (!r.d) return r;
    e = new n(1), t = n.rounding;
  } else {
    if (e = new n(e), t === void 0 ? t = n.rounding : ti(t, 0, 8), !r.d) return e.s ? r : e;
    if (!e.d)
      return e.s && (e.s = r.s), e;
  }
  return e.d[0] ? (xe = !1, r = rr(r, e, 0, t, 1).times(e), xe = !0, ue(r)) : (e.s = r.s, r = e), r;
};
Dt.toNumber = function() {
  return +this;
};
Dt.toOctal = function(e, t) {
  return KA(this, 8, e, t);
};
Dt.toPower = Dt.pow = function(e) {
  var t, r, n, i, s, o, a = this, l = a.constructor, c = +(e = new l(e));
  if (!a.d || !e.d || !a.d[0] || !e.d[0]) return new l(zr(+a, c));
  if (a = new l(a), a.eq(1)) return a;
  if (n = l.precision, s = l.rounding, e.eq(1)) return ue(a, n, s);
  if (t = Rn(e.e / ve), t >= e.d.length - 1 && (r = c < 0 ? -c : c) <= Gvt)
    return i = i$(l, a, r, n), e.s < 0 ? new l(1).div(i) : ue(i, n, s);
  if (o = a.s, o < 0) {
    if (t < e.d.length - 1) return new l(NaN);
    if (e.d[t] & 1 || (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = zr(+a, c), t = r == 0 || !isFinite(r) ? Rn(c * (Math.log("0." + sn(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, t > l.maxE + 1 || t < l.minE - 1 ? new l(t > 0 ? o / 0 : 0) : (xe = !1, l.rounding = a.s = 1, r = Math.min(12, (t + "").length), i = V4(e.times(gl(a, n + r)), n), i.d && (i = ue(i, n + 5, 1), d0(i.d, n, s) && (t = n + 10, i = ue(V4(e.times(gl(a, t + r)), t), t + 5, 1), +sn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = ue(i, n + 1, 0)))), i.s = o, xe = !0, l.rounding = s, ue(i, n, s));
};
Dt.toPrecision = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = Po(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (ti(e, 1, Nc), t === void 0 ? t = i.rounding : ti(t, 0, 8), n = ue(new i(n), e, t), r = Po(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Dt.toSignificantDigits = Dt.toSD = function(e, t) {
  var r = this, n = r.constructor;
  return e === void 0 ? (e = n.precision, t = n.rounding) : (ti(e, 1, Nc), t === void 0 ? t = n.rounding : ti(t, 0, 8)), ue(new n(r), e, t);
};
Dt.toString = function() {
  var e = this, t = e.constructor, r = Po(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() && !e.isZero() ? "-" + r : r;
};
Dt.truncated = Dt.trunc = function() {
  return ue(new this.constructor(this), this.e + 1, 1);
};
Dt.valueOf = Dt.toJSON = function() {
  var e = this, t = e.constructor, r = Po(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() ? "-" + r : r;
};
function sn(e) {
  var t, r, n, i = e.length - 1, s = "", o = e[0];
  if (i > 0) {
    for (s += o, t = 1; t < i; t++)
      n = e[t] + "", r = ve - n.length, r && (s += il(r)), s += n;
    o = e[t], n = o + "", r = ve - n.length, r && (s += il(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function ti(e, t, r) {
  if (e !== ~~e || e < t || e > r)
    throw Error(Wl + e);
}
function d0(e, t, r, n) {
  var i, s, o, a;
  for (s = e[0]; s >= 10; s /= 10) --t;
  return --t < 0 ? (t += ve, i = 0) : (i = Math.ceil((t + 1) / ve), t %= ve), s = zr(10, ve - t), a = e[i] % s | 0, n == null ? t < 3 ? (t == 0 ? a = a / 100 | 0 : t == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 100 | 0) == zr(10, t - 2) - 1 || (a == s / 2 || a == 0) && (e[i + 1] / s / 100 | 0) == 0 : t < 4 ? (t == 0 ? a = a / 1e3 | 0 : t == 1 ? a = a / 100 | 0 : t == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 1e3 | 0) == zr(10, t - 3) - 1, o;
}
function Y1(e, t, r) {
  for (var n, i = [0], s, o = 0, a = e.length; o < a; ) {
    for (s = i.length; s--; ) i[s] *= t;
    for (i[0] += F4.indexOf(e.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function Wvt(e, t) {
  var r, n, i;
  if (t.isZero()) return t;
  n = t.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Kb(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), e.precision += r, t = yp(e, 1, t.times(i), new e(1));
  for (var s = r; s--; ) {
    var o = t.times(t);
    t = o.times(o).minus(o).times(8).plus(1);
  }
  return e.precision -= r, t;
}
var rr = /* @__PURE__ */ function() {
  function e(n, i, s) {
    var o, a = 0, l = n.length;
    for (n = n.slice(); l--; )
      o = n[l] * i + a, n[l] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function t(n, i, s, o) {
    var a, l;
    if (s != o)
      l = s > o ? 1 : -1;
    else
      for (a = l = 0; a < s; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, o, a, l) {
    var c, h, u, p, y, g, b, f, E, A, x, m, w, _, S, R, O, $, z, F, Y = n.constructor, rt = n.s == i.s ? 1 : -1, at = n.d, pt = i.d;
    if (!at || !at[0] || !pt || !pt[0])
      return new Y(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (at ? pt && at[0] == pt[0] : !pt) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          at && at[0] == 0 || !pt ? rt * 0 : rt / 0
        )
      );
    for (l ? (y = 1, h = n.e - i.e) : (l = Is, y = ve, h = Rn(n.e / y) - Rn(i.e / y)), z = pt.length, O = at.length, E = new Y(rt), A = E.d = [], u = 0; pt[u] == (at[u] || 0); u++) ;
    if (pt[u] > (at[u] || 0) && h--, s == null ? (_ = s = Y.precision, o = Y.rounding) : a ? _ = s + (n.e - i.e) + 1 : _ = s, _ < 0)
      A.push(1), g = !0;
    else {
      if (_ = _ / y + 2 | 0, u = 0, z == 1) {
        for (p = 0, pt = pt[0], _++; (u < O || p) && _--; u++)
          S = p * l + (at[u] || 0), A[u] = S / pt | 0, p = S % pt | 0;
        g = p || u < O;
      } else {
        for (p = l / (pt[0] + 1) | 0, p > 1 && (pt = e(pt, p, l), at = e(at, p, l), z = pt.length, O = at.length), R = z, x = at.slice(0, z), m = x.length; m < z; ) x[m++] = 0;
        F = pt.slice(), F.unshift(0), $ = pt[0], pt[1] >= l / 2 && ++$;
        do
          p = 0, c = t(pt, x, z, m), c < 0 ? (w = x[0], z != m && (w = w * l + (x[1] || 0)), p = w / $ | 0, p > 1 ? (p >= l && (p = l - 1), b = e(pt, p, l), f = b.length, m = x.length, c = t(b, x, f, m), c == 1 && (p--, r(b, z < f ? F : pt, f, l))) : (p == 0 && (c = p = 1), b = pt.slice()), f = b.length, f < m && b.unshift(0), r(x, b, m, l), c == -1 && (m = x.length, c = t(pt, x, z, m), c < 1 && (p++, r(x, z < m ? F : pt, m, l))), m = x.length) : c === 0 && (p++, x = [0]), A[u++] = p, c && x[0] ? x[m++] = at[R] || 0 : (x = [at[R]], m = 1);
        while ((R++ < O || x[0] !== void 0) && _--);
        g = x[0] !== void 0;
      }
      A[0] || A.shift();
    }
    if (y == 1)
      E.e = h, JF = g;
    else {
      for (u = 1, p = A[0]; p >= 10; p /= 10) u++;
      E.e = u + h * y - 1, ue(E, a ? s + E.e + 1 : s, o, g);
    }
    return E;
  };
}();
function ue(e, t, r, n) {
  var i, s, o, a, l, c, h, u, p, y = e.constructor;
  t: if (t != null) {
    if (u = e.d, !u) return e;
    for (i = 1, a = u[0]; a >= 10; a /= 10) i++;
    if (s = t - i, s < 0)
      s += ve, o = t, h = u[p = 0], l = h / zr(10, i - o - 1) % 10 | 0;
    else if (p = Math.ceil((s + 1) / ve), a = u.length, p >= a)
      if (n) {
        for (; a++ <= p; ) u.push(0);
        h = l = 0, i = 1, s %= ve, o = s - ve + 1;
      } else
        break t;
    else {
      for (h = a = u[p], i = 1; a >= 10; a /= 10) i++;
      s %= ve, o = s - ve + i, l = o < 0 ? 0 : h / zr(10, i - o - 1) % 10 | 0;
    }
    if (n = n || t < 0 || u[p + 1] !== void 0 || (o < 0 ? h : h % zr(10, i - o - 1)), c = r < 4 ? (l || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? h / zr(10, i - o) : 0 : u[p - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !u[0])
      return u.length = 0, c ? (t -= e.e + 1, u[0] = zr(10, (ve - t % ve) % ve), e.e = -t || 0) : u[0] = e.e = 0, e;
    if (s == 0 ? (u.length = p, a = 1, p--) : (u.length = p + 1, a = zr(10, ve - s), u[p] = o > 0 ? (h / zr(10, i - o) % zr(10, o) | 0) * a : 0), c)
      for (; ; )
        if (p == 0) {
          for (s = 1, o = u[0]; o >= 10; o /= 10) s++;
          for (o = u[0] += a, a = 1; o >= 10; o /= 10) a++;
          s != a && (e.e++, u[0] == Is && (u[0] = 1));
          break;
        } else {
          if (u[p] += a, u[p] != Is) break;
          u[p--] = 0, a = 1;
        }
    for (s = u.length; u[--s] === 0; ) u.pop();
  }
  return xe && (e.e > y.maxE ? (e.d = null, e.e = NaN) : e.e < y.minE && (e.e = 0, e.d = [0])), e;
}
function Po(e, t, r) {
  if (!e.isFinite()) return o$(e);
  var n, i = e.e, s = sn(e.d), o = s.length;
  return t ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + il(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (s = "0." + il(-i - 1) + s, r && (n = r - o) > 0 && (s += il(n))) : i >= o ? (s += il(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + il(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += il(n))), s;
}
function Yb(e, t) {
  var r = e[0];
  for (t *= ve; r >= 10; r /= 10) t++;
  return t;
}
function Sy(e, t, r) {
  if (t > Qvt)
    throw xe = !0, r && (e.precision = r), Error(XF);
  return ue(new e(Ey), t, 1, !0);
}
function ho(e, t, r) {
  if (t > z4) throw Error(XF);
  return ue(new e(Ay), t, r, !0);
}
function n$(e) {
  var t = e.length - 1, r = t * ve + 1;
  if (t = e[t], t) {
    for (; t % 10 == 0; t /= 10) r--;
    for (t = e[0]; t >= 10; t /= 10) r++;
  }
  return r;
}
function il(e) {
  for (var t = ""; e--; ) t += "0";
  return t;
}
function i$(e, t, r, n) {
  var i, s = new e(1), o = Math.ceil(n / ve + 4);
  for (xe = !1; ; ) {
    if (r % 2 && (s = s.times(t), bI(s.d, o) && (i = !0)), r = Rn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    t = t.times(t), bI(t.d, o);
  }
  return xe = !0, s;
}
function yI(e) {
  return e.d[e.d.length - 1] & 1;
}
function s$(e, t, r) {
  for (var n, i, s = new e(t[0]), o = 0; ++o < t.length; ) {
    if (i = new e(t[o]), !i.s) {
      s = i;
      break;
    }
    n = s.cmp(i), (n === r || n === 0 && s.s === r) && (s = i);
  }
  return s;
}
function V4(e, t) {
  var r, n, i, s, o, a, l, c = 0, h = 0, u = 0, p = e.constructor, y = p.rounding, g = p.precision;
  if (!e.d || !e.d[0] || e.e > 17)
    return new p(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
  for (t == null ? (xe = !1, l = g) : l = t, a = new p(0.03125); e.e > -2; )
    e = e.times(a), u += 5;
  for (n = Math.log(zr(2, u)) / Math.LN10 * 2 + 5 | 0, l += n, r = s = o = new p(1), p.precision = l; ; ) {
    if (s = ue(s.times(e), l, 1), r = r.times(++h), a = o.plus(rr(s, r, l, 1)), sn(a.d).slice(0, l) === sn(o.d).slice(0, l)) {
      for (i = u; i--; ) o = ue(o.times(o), l, 1);
      if (t == null)
        if (c < 3 && d0(o.d, l - n, y, c))
          p.precision = l += 10, r = s = a = new p(1), h = 0, c++;
        else
          return ue(o, p.precision = g, y, xe = !0);
      else
        return p.precision = g, o;
    }
    o = a;
  }
}
function gl(e, t) {
  var r, n, i, s, o, a, l, c, h, u, p, y = 1, g = 10, b = e, f = b.d, E = b.constructor, A = E.rounding, x = E.precision;
  if (b.s < 0 || !f || !f[0] || !b.e && f[0] == 1 && f.length == 1)
    return new E(f && !f[0] ? -1 / 0 : b.s != 1 ? NaN : f ? 0 : b);
  if (t == null ? (xe = !1, h = x) : h = t, E.precision = h += g, r = sn(f), n = r.charAt(0), Math.abs(s = b.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      b = b.times(e), r = sn(b.d), n = r.charAt(0), y++;
    s = b.e, n > 1 ? (b = new E("0." + r), s++) : b = new E(n + "." + r.slice(1));
  } else
    return c = Sy(E, h + 2, x).times(s + ""), b = gl(new E(n + "." + r.slice(1)), h - g).plus(c), E.precision = x, t == null ? ue(b, x, A, xe = !0) : b;
  for (u = b, l = o = b = rr(b.minus(1), b.plus(1), h, 1), p = ue(b.times(b), h, 1), i = 3; ; ) {
    if (o = ue(o.times(p), h, 1), c = l.plus(rr(o, new E(i), h, 1)), sn(c.d).slice(0, h) === sn(l.d).slice(0, h))
      if (l = l.times(2), s !== 0 && (l = l.plus(Sy(E, h + 2, x).times(s + ""))), l = rr(l, new E(y), h, 1), t == null)
        if (d0(l.d, h - g, A, a))
          E.precision = h += g, c = o = b = rr(u.minus(1), u.plus(1), h, 1), p = ue(b.times(b), h, 1), i = a = 1;
        else
          return ue(l, E.precision = x, A, xe = !0);
      else
        return E.precision = x, l;
    l = c, i += 2;
  }
}
function o$(e) {
  return String(e.s * e.s / 0);
}
function K1(e, t) {
  var r, n, i;
  for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0; t.charCodeAt(n) === 48; n++) ;
  for (i = t.length; t.charCodeAt(i - 1) === 48; --i) ;
  if (t = t.slice(n, i), t) {
    if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % ve, r < 0 && (n += ve), n < i) {
      for (n && e.d.push(+t.slice(0, n)), i -= ve; n < i; ) e.d.push(+t.slice(n, n += ve));
      t = t.slice(n), n = ve - t.length;
    } else
      n -= i;
    for (; n--; ) t += "0";
    e.d.push(+t), xe && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
  } else
    e.e = 0, e.d = [0];
  return e;
}
function qvt(e, t) {
  var r, n, i, s, o, a, l, c, h;
  if (t.indexOf("_") > -1) {
    if (t = t.replace(/(\d)_(?=\d)/g, "$1"), r$.test(t)) return K1(e, t);
  } else if (t === "Infinity" || t === "NaN")
    return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
  if (Uvt.test(t))
    r = 16, t = t.toLowerCase();
  else if (Vvt.test(t))
    r = 2;
  else if (Hvt.test(t))
    r = 8;
  else
    throw Error(Wl + t);
  for (s = t.search(/p/i), s > 0 ? (l = +t.slice(s + 1), t = t.substring(2, s)) : t = t.slice(2), s = t.indexOf("."), o = s >= 0, n = e.constructor, o && (t = t.replace(".", ""), a = t.length, s = a - s, i = i$(n, new n(r), s, s * 2)), c = Y1(t, r, Is), h = c.length - 1, s = h; c[s] === 0; --s) c.pop();
  return s < 0 ? new n(e.s * 0) : (e.e = Yb(c, h), e.d = c, xe = !1, o && (e = rr(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? zr(2, l) : bs.pow(2, l))), xe = !0, e);
}
function Yvt(e, t) {
  var r, n = t.d.length;
  if (n < 3)
    return t.isZero() ? t : yp(e, 2, t, t);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(1 / Kb(5, r)), t = yp(e, 2, t, t);
  for (var i, s = new e(5), o = new e(16), a = new e(20); r--; )
    i = t.times(t), t = t.times(s.plus(i.times(o.times(i).minus(a))));
  return t;
}
function yp(e, t, r, n, i) {
  var s, o, a, l, c = e.precision, h = Math.ceil(c / ve);
  for (xe = !1, l = r.times(r), a = new e(n); ; ) {
    if (o = rr(a.times(l), new e(t++ * t++), c, 1), a = i ? n.plus(o) : n.minus(o), n = rr(o.times(l), new e(t++ * t++), c, 1), o = a.plus(n), o.d[h] !== void 0) {
      for (s = h; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = n, n = o, o = s;
  }
  return xe = !0, o.d.length = h + 1, o;
}
function Kb(e, t) {
  for (var r = e; --t; ) r *= e;
  return r;
}
function a$(e, t) {
  var r, n = t.s < 0, i = ho(e, e.precision, 1), s = i.times(0.5);
  if (t = t.abs(), t.lte(s))
    return Ko = n ? 4 : 1, t;
  if (r = t.divToInt(i), r.isZero())
    Ko = n ? 3 : 2;
  else {
    if (t = t.minus(r.times(i)), t.lte(s))
      return Ko = yI(r) ? n ? 2 : 3 : n ? 4 : 1, t;
    Ko = yI(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return t.minus(i).abs();
}
function KA(e, t, r, n) {
  var i, s, o, a, l, c, h, u, p, y = e.constructor, g = r !== void 0;
  if (g ? (ti(r, 1, Nc), n === void 0 ? n = y.rounding : ti(n, 0, 8)) : (r = y.precision, n = y.rounding), !e.isFinite())
    h = o$(e);
  else {
    for (h = Po(e), o = h.indexOf("."), g ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, o >= 0 && (h = h.replace(".", ""), p = new y(1), p.e = h.length - o, p.d = Y1(Po(p), 10, i), p.e = p.d.length), u = Y1(h, 10, i), s = l = u.length; u[--l] == 0; ) u.pop();
    if (!u[0])
      h = g ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (e = new y(e), e.d = u, e.e = s, e = rr(e, p, r, n, 0, i), u = e.d, s = e.e, c = JF), o = u[r], a = i / 2, c = c || u[r + 1] !== void 0, c = n < 4 ? (o !== void 0 || c) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || c || n === 6 && u[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), u.length = r, c)
        for (; ++u[--r] > i - 1; )
          u[r] = 0, r || (++s, u.unshift(1));
      for (l = u.length; !u[l - 1]; --l) ;
      for (o = 0, h = ""; o < l; o++) h += F4.charAt(u[o]);
      if (g) {
        if (l > 1)
          if (t == 16 || t == 8) {
            for (o = t == 16 ? 4 : 3, --l; l % o; l++) h += "0";
            for (u = Y1(h, i, t), l = u.length; !u[l - 1]; --l) ;
            for (o = 1, h = "1."; o < l; o++) h += F4.charAt(u[o]);
          } else
            h = h.charAt(0) + "." + h.slice(1);
        h = h + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) h = "0" + h;
        h = "0." + h;
      } else if (++s > l) for (s -= l; s--; ) h += "0";
      else s < l && (h = h.slice(0, s) + "." + h.slice(s));
    }
    h = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + h;
  }
  return e.s < 0 ? "-" + h : h;
}
function bI(e, t) {
  if (e.length > t)
    return e.length = t, !0;
}
function Kvt(e) {
  return new this(e).abs();
}
function Zvt(e) {
  return new this(e).acos();
}
function Jvt(e) {
  return new this(e).acosh();
}
function Xvt(e, t) {
  return new this(e).plus(t);
}
function twt(e) {
  return new this(e).asin();
}
function ewt(e) {
  return new this(e).asinh();
}
function rwt(e) {
  return new this(e).atan();
}
function nwt(e) {
  return new this(e).atanh();
}
function iwt(e, t) {
  e = new this(e), t = new this(t);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !e.s || !t.s ? r = new this(NaN) : !e.d && !t.d ? (r = ho(this, s, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t.d || e.isZero() ? (r = t.s < 0 ? ho(this, n, i) : new this(0), r.s = e.s) : !e.d || t.isZero() ? (r = ho(this, s, 1).times(0.5), r.s = e.s) : t.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(rr(e, t, s, 1)), t = ho(this, s, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(rr(e, t, s, 1)), r;
}
function swt(e) {
  return new this(e).cbrt();
}
function owt(e) {
  return ue(e = new this(e), e.e + 1, 2);
}
function awt(e, t, r) {
  return new this(e).clamp(t, r);
}
function lwt(e) {
  if (!e || typeof e != "object") throw Error(qb + "Object expected");
  var t, r, n, i = e.defaults === !0, s = [
    "precision",
    1,
    Nc,
    "rounding",
    0,
    8,
    "toExpNeg",
    -9e15,
    0,
    "toExpPos",
    0,
    j4,
    "maxE",
    0,
    j4,
    "minE",
    -9e15,
    0,
    "modulo",
    0,
    9
  ];
  for (t = 0; t < s.length; t += 3)
    if (r = s[t], i && (this[r] = $4[r]), (n = e[r]) !== void 0)
      if (Rn(n) === n && n >= s[t + 1] && n <= s[t + 2]) this[r] = n;
      else throw Error(Wl + r + ": " + n);
  if (r = "crypto", i && (this[r] = $4[r]), (n = e[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(t$);
      else
        this[r] = !1;
    else
      throw Error(Wl + r + ": " + n);
  return this;
}
function cwt(e) {
  return new this(e).cos();
}
function uwt(e) {
  return new this(e).cosh();
}
function l$(e) {
  var t, r, n;
  function i(s) {
    var o, a, l, c = this;
    if (!(c instanceof i)) return new i(s);
    if (c.constructor = i, vI(s)) {
      c.s = s.s, xe ? !s.d || s.e > i.maxE ? (c.e = NaN, c.d = null) : s.e < i.minE ? (c.e = 0, c.d = [0]) : (c.e = s.e, c.d = s.d.slice()) : (c.e = s.e, c.d = s.d ? s.d.slice() : s.d);
      return;
    }
    if (l = typeof s, l === "number") {
      if (s === 0) {
        c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        xe ? o > i.maxE ? (c.e = NaN, c.d = null) : o < i.minE ? (c.e = 0, c.d = [0]) : (c.e = o, c.d = [s]) : (c.e = o, c.d = [s]);
        return;
      }
      if (s * 0 !== 0) {
        s || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return K1(c, s.toString());
    }
    if (l === "string")
      return (a = s.charCodeAt(0)) === 45 ? (s = s.slice(1), c.s = -1) : (a === 43 && (s = s.slice(1)), c.s = 1), r$.test(s) ? K1(c, s) : qvt(c, s);
    if (l === "bigint")
      return s < 0 ? (s = -s, c.s = -1) : c.s = 1, K1(c, s.toString());
    throw Error(Wl + s);
  }
  if (i.prototype = Dt, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = lwt, i.clone = l$, i.isDecimal = vI, i.abs = Kvt, i.acos = Zvt, i.acosh = Jvt, i.add = Xvt, i.asin = twt, i.asinh = ewt, i.atan = rwt, i.atanh = nwt, i.atan2 = iwt, i.cbrt = swt, i.ceil = owt, i.clamp = awt, i.cos = cwt, i.cosh = uwt, i.div = hwt, i.exp = pwt, i.floor = dwt, i.hypot = fwt, i.ln = gwt, i.log = mwt, i.log10 = bwt, i.log2 = ywt, i.max = vwt, i.min = wwt, i.mod = xwt, i.mul = Ewt, i.pow = Awt, i.random = Swt, i.round = _wt, i.sign = kwt, i.sin = Cwt, i.sinh = Iwt, i.sqrt = Pwt, i.sub = Rwt, i.sum = Twt, i.tan = Owt, i.tanh = Lwt, i.trunc = Mwt, e === void 0 && (e = {}), e && e.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0; t < n.length; ) e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
  return i.config(e), i;
}
function hwt(e, t) {
  return new this(e).div(t);
}
function pwt(e) {
  return new this(e).exp();
}
function dwt(e) {
  return ue(e = new this(e), e.e + 1, 3);
}
function fwt() {
  var e, t, r = new this(0);
  for (xe = !1, e = 0; e < arguments.length; )
    if (t = new this(arguments[e++]), t.d)
      r.d && (r = r.plus(t.times(t)));
    else {
      if (t.s)
        return xe = !0, new this(1 / 0);
      r = t;
    }
  return xe = !0, r.sqrt();
}
function vI(e) {
  return e instanceof bs || e && e.toStringTag === e$ || !1;
}
function gwt(e) {
  return new this(e).ln();
}
function mwt(e, t) {
  return new this(e).log(t);
}
function ywt(e) {
  return new this(e).log(2);
}
function bwt(e) {
  return new this(e).log(10);
}
function vwt() {
  return s$(this, arguments, -1);
}
function wwt() {
  return s$(this, arguments, 1);
}
function xwt(e, t) {
  return new this(e).mod(t);
}
function Ewt(e, t) {
  return new this(e).mul(t);
}
function Awt(e, t) {
  return new this(e).pow(t);
}
function Swt(e) {
  var t, r, n, i, s = 0, o = new this(1), a = [];
  if (e === void 0 ? e = this.precision : ti(e, 1, Nc), n = Math.ceil(e / ve), this.crypto)
    if (crypto.getRandomValues)
      for (t = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = t[s], i >= 429e7 ? t[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (t = crypto.randomBytes(n *= 4); s < n; )
        i = t[s] + (t[s + 1] << 8) + (t[s + 2] << 16) + ((t[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(t, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(t$);
  else for (; s < n; ) a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], e %= ve, n && e && (i = zr(10, ve - e), a[s] = (n / i | 0) * i); a[s] === 0; s--) a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= ve) a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
    n < ve && (r -= ve - n);
  }
  return o.e = r, o.d = a, o;
}
function _wt(e) {
  return ue(e = new this(e), e.e + 1, this.rounding);
}
function kwt(e) {
  return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
}
function Cwt(e) {
  return new this(e).sin();
}
function Iwt(e) {
  return new this(e).sinh();
}
function Pwt(e) {
  return new this(e).sqrt();
}
function Rwt(e, t) {
  return new this(e).sub(t);
}
function Twt() {
  var e = 0, t = arguments, r = new this(t[e]);
  for (xe = !1; r.s && ++e < t.length; ) r = r.plus(t[e]);
  return xe = !0, ue(r, this.precision, this.rounding);
}
function Owt(e) {
  return new this(e).tan();
}
function Lwt(e) {
  return new this(e).tanh();
}
function Mwt(e) {
  return ue(e = new this(e), e.e + 1, 1);
}
Dt[Symbol.for("nodejs.util.inspect.custom")] = Dt.toString;
Dt[Symbol.toStringTag] = "Decimal";
var bs = Dt.constructor = l$($4);
Ey = new bs(Ey);
Ay = new bs(Ay);
function _y(e, t, r, n = !0) {
  const i = new bs(e), s = new bs(t), o = s.sub(i), a = o.div(10);
  let l, c, h;
  l = new bs(10).pow(a.log(10).ceil()), l.div(o).gte(0.8) ? l = l.div(10) : l.div(o).gte(0.5) ? l = l.div(4) : l.div(o).gte(0.2) && (l = l.div(2)), c = i.div(l).floor().mul(l), h = s.div(l).ceil().mul(l);
  const u = new Intl.NumberFormat(void 0, { maximumFractionDigits: 5, useGrouping: n }), p = new Array(h.sub(c).div(l).toNumber() + 1).fill(0).map((y, g) => u.format(+c.add(l.mul(g))) + (r ? "%" : ""));
  return {
    min: c.toNumber(),
    max: h.toNumber(),
    range: h.sub(c).toNumber(),
    labelTiers: [p]
  };
}
function Nwt(e, t, r, n, i = !0) {
  if (r < 0)
    throw new Error("tick interval must be > 0");
  const s = e - e % r, o = t + (r - t % r), a = new Intl.NumberFormat(void 0, { maximumFractionDigits: 5, useGrouping: i });
  return {
    min: s,
    max: o,
    range: o - s,
    labelTiers: [new Array((o - s) / r + 1).fill(0).map((l, c) => a.format(s + r * c) + "")]
  };
}
class Zb {
  constructor(t, r) {
    this._store = t, this._options = r, r.xTiers ? this._xLabelInfo = { labelTiers: r.xTiers } : this._computeXLabelInfo(), r.yTiers ? this._yLabelInfo = { labelTiers: r.yTiers } : this._computeYLabelInfo();
  }
  get xLabelInfo() {
    return this._xLabelInfo;
  }
  get yLabelInfo() {
    return this._yLabelInfo;
  }
  get options() {
    return this._options;
  }
  get horizFacet() {
    return this._store.model.getAxisFacet(
      this._options.isXVertical ? "vert" : "horiz"
    );
  }
  get vertFacet() {
    return this._store.model.getAxisFacet(
      this._options.isXVertical ? "horiz" : "vert"
    );
  }
  getFacetForOrientation(t) {
    return t === "horiz" ? this.horizFacet : this.vertFacet;
  }
  updateYRange() {
    this._computeYLabelInfo();
  }
  _computeXLabels(t, r) {
    return _y(
      this._store.settings.axis.x.minValue === "unset" ? t : this._store.settings.axis.x.minValue,
      this._store.settings.axis.x.maxValue === "unset" ? r : this._store.settings.axis.x.maxValue,
      !1
    );
  }
  _computeYLabels(t, r) {
    return this._store.settings.axis.y.interval !== "unset" ? Nwt(t, r, this._store.settings.axis.y.interval) : _y(t, r, !1);
  }
  _computeXLabelInfo() {
    if (this._options.xValues)
      this._xLabelInfo = this._computeXLabels(
        Math.min(...this._options.xValues),
        Math.max(...this._options.xValues)
      );
    else {
      const t = this._store.model.series[0].datapoints.map(
        (r) => jr(r.facetBox("x"), this._store.getFormatType("horizTick"))
      );
      this._xLabelInfo = {
        labelTiers: [t]
      };
    }
  }
  _computeYLabelInfo() {
    const t = this._store.settings.axis.y.minValue === "unset" ? this._options.yMin ?? Math.min(...this._options.yValues) : this._store.settings.axis.y.minValue, r = this._store.settings.axis.y.maxValue === "unset" ? this._options.yMax ?? Math.max(...this._options.yValues) : this._store.settings.axis.y.maxValue;
    this._yLabelInfo = this._computeYLabels(t, r);
  }
}
class c$ extends YA {
  constructor(t, r) {
    super(t, r);
  }
  _init() {
    super._init(), this._axisInfo = new Zb(this._store, {
      yValues: this._store.model.allFacetValues("y").map((t) => t.value)
    });
  }
  seriesInNavOrder() {
    const t = this._store.model.dependentFacetKeys[0];
    return this._store.model.series.toSorted((r, n) => n.datapoints[0].facetValueNumericized(t) - r.datapoints[0].facetValueNumericized(t));
  }
}
function ZA(e, t) {
  const r = [], n = t.some((s) => s.equals(e));
  if (t.length >= (n ? 2 : 1)) {
    const s = n ? Ai.other : void 0;
    r.push(Dn(Ai.comparisonSelectedDatapoints, { other: s }));
    const o = t.toSorted((a, l) => a.datapoint.facetValueNumericized("y") > l.datapoint.facetValueNumericized("y") ? -1 : 1);
    for (const a of o)
      if (!a.equals(e)) {
        const l = a.datapoint.facetValueNumericized("y"), c = e.datapoint.facetValueNumericized("y"), h = p$(c, l), u = h$[h.relationship].msg, p = h.diff !== 0 ? Dn("${diff:number} ", { diff: h.diff }) : void 0;
        r.push(Iut(Dn(
          "${diff:string?}${comparatorMsg:string} ${seriesName:string} ${datapointXY:string}",
          { diff: p, comparatorMsg: u, seriesName: a.seriesKey, datapointXY: qf(a.datapoint, "raw") }
        )));
      }
  }
  return r;
}
function JA(e, t, r) {
  const n = [], i = e.series.filter((u) => u.key === r)[0];
  let s = [], o = [];
  for (let u of i.rawData)
    s.push(Number(u.y));
  for (let u of e.series)
    for (let p of u.rawData)
      o.push(Number(p.y));
  const a = Math.min(...s), l = Math.min(...o), c = Math.max(...s), h = Math.max(...o);
  return t == l ? n.push(Ai.seriesChartMin) : t == a && n.push(Ai.seriesMin), t == h ? n.push(Ai.seriesChartMax) : t == c && n.push(Ai.seriesMax), console.log(n), n;
}
function u$(e, t) {
  const r = [];
  let n, i;
  return (n = wI(e, t, "prev")) && r.push(n), (i = wI(e, t, "next")) && r.push(i), Put(r, !0);
}
function wI(e, t, r) {
  const n = t[r];
  if (!n)
    return null;
  const i = `${n.series[n.index].facetBox("x").raw}, ${n.series[n.index].facetBox("y").raw}`, s = e.series.filter((y) => y.key == t.seriesKey)[0], o = e.series.filter((y) => y.key == n.seriesKey)[0], a = s[t.index].facetBox("y").raw, l = o[n.index].facetBox("y").raw, c = p$(a, l);
  console.log(c);
  const h = h$[c.relationship][r], u = r === "prev" ? c.percentagePrev : c.percentageNext;
  if (c.diff === 0)
    return Dn("${comparator:string} ${otherLabel:string}", { comparator: h, otherLabel: i });
  const p = r === "prev" ? "from" : "in";
  return Dn(
    "${comparator:string} ${diff:number} (${percent:number#.1}%) ${preposition:string} ${otherLabel:string}",
    { comparator: h, diff: c.diff, percent: u, preposition: p, otherLabel: i }
  );
}
const Ai = {
  comparisonSelectedDatapoints: "Comparison to${other:string?} selected datapoints",
  other: " other",
  seriesMin: "Series low",
  seriesChartMin: "Series low and chart low",
  seriesMax: "Series high",
  seriesChartMax: "Series high and chart high",
  seriesKeyLength: "${seriesKey:string}. ${datapointCount:number} datapoints",
  datapointKeyLength: "${seriesKey:string} ${datapointXY:string}. Datapoint ${datapointIndex:number} of ${datapointCount:number}.",
  percentageOfSeries: "${datapointXY:string}% of total amount in series: ${seriesKey:string}. Datapoint ${datapointIndex:number} of ${datapointCount:number}.",
  percentageOfChart: "${datapointXY:string}% of total amount in chart: ${chartKey:string}. Datapoint ${datapointIndex:number} of ${datapointCount:number}."
}, h$ = {
  equal: {
    msg: "equal to",
    prev: "stayed the same from",
    next: "will stay the same in"
  },
  greater: {
    msg: "more than",
    prev: "grew by",
    next: "will decrease by"
  },
  less: {
    msg: "less than",
    prev: "decreased by",
    next: "will grow by"
  }
};
function p$(e, t) {
  console.log(t);
  const r = {
    diff: 0
  };
  if (e === t)
    r.relationship = "equal";
  else {
    r.relationship = e > t ? "greater" : "less";
    const n = new bs(Math.min(e, t)), i = new bs(Math.max(e, t));
    r.diff = i.sub(n).toNumber();
    const s = new bs(e), o = new bs(t);
    s && (r.percentageNext = o.sub(s).dividedBy(s).times(100).toNumber()), o && (r.percentagePrev = s.sub(o).dividedBy(o).times(100).toNumber());
  }
  return r;
}
class Dwt extends c$ {
  constructor(t, r) {
    super(t, r), this._prevHighlightNavcode = "";
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "textfield",
      key: "type.line.lineWidth",
      label: "Line width",
      options: {
        inputType: "number",
        min: 1,
        max: this._store.settings.type.line.lineWidthMax
      },
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "chart.isDrawSymbols",
      label: "Show symbols",
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "chart.showPopups",
      label: "Show popups",
      parentView: "controlPanel.tabs.chart.popups"
    });
  }
  get settings() {
    return super.settings;
  }
  settingDidChange(t, r, n) {
    ["type.line.isTrendNavigationModeEnabled"].includes(t) && ([this._navMap, this._altNavMap] = [this._altNavMap, this._navMap], this._navMap.root.goTo("top", {})), super.settingDidChange(t, r, n);
  }
  async storeDidChange(t, r) {
    await super.storeDidChange(t, r), t === "seriesAnalyses" && this._createSequenceNavNodes();
  }
  _canCreateSequenceNavNodes() {
    return !!this._navMap && Object.keys(this._store.seriesAnalyses).length === this._store.model.seriesKeys.length && !!this._store.seriesAnalyses[this._store.model.seriesKeys[0]];
  }
  _createNavMap() {
    super._createNavMap(), this._createSequenceNavNodes();
  }
  _createSequenceNavNodes() {
    if (!this._canCreateSequenceNavNodes()) return;
    const t = [];
    this._altNavMap = this._navMap.clone(), this._altNavMap.root.query("series").forEach((r) => {
      t.length && r.connect("left", t.at(-1).at(-1));
      const n = this._store.seriesAnalyses[r.options.seriesKey], i = r.allNodes("right", "datapoint"), s = [];
      n.sequences.forEach((o) => {
        const a = new oa(r.layer, "sequence", {
          seriesKey: r.options.seriesKey,
          start: o.start,
          end: o.end
        }, this._store);
        s.push(a);
      }), t.push(s), s.slice(0, -1).forEach((o, a) => {
        o.connect("right", s[a + 1]);
      }), r.connect("right", s[0]), i[0].disconnect("left", !1), i.at(-1).disconnect("right"), s.forEach((o) => {
        o.connect(
          "in",
          i[o.options.start],
          !i[o.options.start].getLink("out")
        );
        for (let a = o.options.start + 1; a < o.options.end; a++)
          i[a].connect("out", o, !1);
        o.peekNode("right", 1) && i[o.options.end - 1].connect("in", o.peekNode("right", 1), !1);
      });
    }), t.slice(0, -1).forEach((r, n) => {
      r.forEach((i) => {
        const s = t[n + 1].find((o) => o.options.start <= i.options.start && o.options.end > i.options.start);
        i.connect("down", s, !1);
      });
    }), t.slice(1).forEach((r, n) => {
      r.forEach((i, s) => {
        const o = t[n].find((a) => a.options.start <= i.options.start && a.options.end > i.options.start);
        i.connect("up", o, !1);
      });
    });
  }
  noticePosted(t, r) {
    if (super.noticePosted(t, r), this._store.settings.ui.isNarrativeHighlightEnabled)
      if (t === "utteranceBoundary") {
        const n = r;
        this._prevHighlightNavcode = this._doHighlight(n, this._prevHighlightNavcode);
      } else t === "utteranceEnd" && (this._store.paraChart.captionBox.highlightManualOverride || (this._store.clearHighlight(), this._store.clearAllSeriesLowlights()), this._prevHighlightNavcode && (this.didRemoveHighlight(this._prevHighlightNavcode), this._prevHighlightNavcode = ""));
  }
  _doHighlight(t, r) {
    if (t.navcode) {
      if (t.navcode.startsWith("series")) {
        const n = t.navcode.split(/-/);
        this._store.lowlightOtherSeries(...n.slice(1));
      } else
        this._store.clearHighlight(), this._store.highlight(t.navcode), r && this.didRemoveHighlight(r), this.didAddHighlight(t.navcode);
      r = t.navcode;
    } else
      this._store.clearHighlight(), this._store.clearAllSeriesLowlights(), r && (this.didRemoveHighlight(r), r = "");
    return r;
  }
  legend() {
    const t = [...this._store.model.seriesKeys];
    return this._store.settings.legend.itemOrder === "alphabetical" && t.sort(), t.map((r) => ({
      label: r,
      color: this._store.seriesProperties.properties(r).color
    }));
  }
  // TODO: localize this text output
  // focused view: e.options!.focus
  // all visited datapoint views: e.options!.visited
  queryData() {
    const t = [], r = this._navMap.cursor;
    if (r.isNodeType("top"))
      t.push(`Displaying Chart: ${this._store.title}`);
    else if (r.isNodeType("series")) {
      const n = r.options.seriesKey, i = this._store.model.atKey(n).length;
      t.push(Dn(
        Ai.seriesKeyLength,
        { seriesKey: n, datapointCount: i }
      ));
    } else if (r.isNodeType("datapoint")) {
      const n = this._store.selectedDatapoints, i = r.options.seriesKey, s = r.options.index, o = this._store.model.atKey(i).datapoints[s], a = this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(i, s);
      if (t.push(Dn(
        Ai.datapointKeyLength,
        {
          seriesKey: i,
          datapointXY: qf(o, "raw"),
          datapointIndex: r.options.index + 1,
          datapointCount: this._store.model.atKey(i).length
        }
      )), n.size > 0) {
        const c = n.values().map((u) => {
          const p = Zr(u);
          return this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(p.seriesKey, p.index);
        }).toArray(), h = ZA(
          a,
          c
        );
        t.push(...h);
      } else {
        const c = u$(this._store.model, a);
        t.push(c);
      }
      const l = JA(
        this._store.model,
        o.facetValueAsNumber("y"),
        i
      );
      t.push(...l);
    }
    this._store.announce(t);
  }
}
class Bwt {
  constructor(t, r) {
    this.chartInfo = t, this.key = r, this.stacks = {}, this.id = `barcluster-${Cr(this.key)}`, this.labelId = `tick-x-${this.id}`;
  }
  get index() {
    return Object.keys(this.chartInfo.clusteredData).indexOf(this.key);
  }
}
class xI {
  constructor(t, r) {
    this.cluster = t, this.key = r, this.bars = {}, this._label = null, this.id = `barstack-${Cr(this.cluster.key)}-${Cr(this.key)}`, this.labelId = `tick-x-${this.id}`;
  }
  get index() {
    return Object.keys(this.cluster.stacks).indexOf(this.key);
  }
  get label() {
    return this._label;
  }
  set label(t) {
    this._label = t;
  }
}
class EI extends YA {
  constructor(t, r) {
    super(t, r);
  }
  _init() {
    super._init(), this._clusteredData = this._clusterData();
    const t = Object.values(this._clusteredData).flatMap((n) => Object.values(n.stacks).map(
      (i) => Object.values(i.bars).map((s) => s.value.value).reduce((s, o) => s + o, 0)
      //        + Object.values(s.bars).length*this.settings.stackInsideGap
    ));
    this._axisInfo = new Zb(this._store, {
      // xTiers: [this.paraview.store.model!.allFacetValues('x')!.map(x =>
      //   formatBox(x, 'barCluster', this.paraview.store))],
      xTiers: [Object.keys(this._clusteredData)],
      yValues: t,
      yMin: Math.min(0, Math.min(...t)),
      isXInterval: !0,
      // manifest can override this
      isXVertical: this._store.type === "bar"
    });
    const r = this._store.model.numSeries;
    this.settings.stacking === "standard" ? this._stacksPerCluster = 1 : this.settings.stacking === "none" && (this._stacksPerCluster = Math.ceil(r / 1));
  }
  get settings() {
    return super.settings;
  }
  get clusteredData() {
    return this._clusteredData;
  }
  get stacksPerCluster() {
    return this._stacksPerCluster;
  }
  _clusterData() {
    const t = this._store.settings.type[this._type], r = {}, n = this._store.model.series[0].datapoints.map((o) => o.facetBox("x")), i = [];
    for (const [o, a] of Nn(n)) {
      const l = jr(o, this._store.getFormatType("barCluster"));
      let c = r[l];
      c || (c = new Bwt(this, l), r[l] = c, i.push(c));
    }
    const s = [...this._store.model.series];
    this._store.type === "column" && t.stacking === "standard" && s.reverse();
    for (const [o, a] of Nn(s))
      for (const [l, c] of Nn(o.datapoints.map((h) => h.facetBox("y")))) {
        let h, u;
        t.stacking === "standard" ? (u = "stack", h = i[c].stacks[u], h || (h = new xI(i[c], u), i[c].stacks[u] = h)) : t.stacking === "none" && (u = o.key, h = i[c].stacks[u], h || (h = new xI(i[c], u), i[c].stacks[u] = h)), h.bars[o.key] = {
          series: o.key,
          value: o.datapoints[c].facetBox("y")
        };
      }
    return r;
  }
  legend() {
    return this._store.settings.legend.itemOrder === "series" ? this._store.model.series.map((t) => ({
      label: t.key,
      color: this._store.seriesProperties.properties(t.key).color
    })) : this._store.model.seriesKeys.toSorted().map((t) => ({
      label: t,
      color: this._store.seriesProperties.properties(t).color
    }));
  }
  // TODO: localize this text output
  // focused view: e.options!.focus
  // all visited datapoint views: e.options!.visited
  queryData() {
    const t = [], r = this._navMap.cursor;
    if (r.isNodeType("top"))
      t.push(`Displaying Chart: ${this._store.title}`);
    else if (r.isNodeType("series")) {
      const n = r.options.seriesKey, i = this._store.model.atKey(n).length;
      t.push(Dn(
        Ai.seriesKeyLength,
        { seriesKey: n, datapointCount: i }
      ));
    } else if (r.isNodeType("datapoint")) {
      const n = this._store.selectedDatapoints, i = r.options.seriesKey, s = r.options.index, o = this._store.model.atKey(i).datapoints[s], a = this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(i, s);
      if (t.push(Dn(
        Ai.datapointKeyLength,
        {
          seriesKey: i,
          datapointXY: qf(o, "raw"),
          datapointIndex: r.options.index + 1,
          datapointCount: this._store.model.atKey(i).length
        }
      )), n.size > 0) {
        const c = n.values().map((u) => {
          const p = Zr(u);
          return this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(p.seriesKey, p.index);
        }).toArray(), h = ZA(
          a,
          c
        );
        t.push(...h);
      } else {
        const c = u$(this._store.model, a);
        t.push(c);
      }
      const l = JA(
        this._store.model,
        o.facetValueAsNumber("y"),
        i
      );
      t.push(...l);
    }
    this._store.announce(t);
  }
}
class AI extends KF {
  constructor(t, r) {
    super(t, r);
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "slider",
      key: `type.${this._type}.orientationAngleOffset`,
      label: "Orientation",
      options: {
        min: 0,
        max: 360,
        step: 1,
        compact: !0,
        width: "8rem"
      },
      parentView: "controlPanel.tabs.chart.chart"
    });
    const t = ["", "category", "percentage:(value)"];
    this._store.settingControls.add({
      type: "dropdown",
      key: `type.${this._type}.insideLabels.contents`,
      label: "Inside labels:",
      options: { options: t },
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: `type.${this._type}.outsideLabels.contents`,
      label: "Outside labels:",
      options: { options: t },
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "textfield",
      key: `type.${this._type}.explode`,
      label: "Explode",
      options: {
        inputType: "text"
      },
      parentView: "controlPanel.tabs.chart.chart"
    });
  }
  _createNavMap() {
    super._createNavMap();
    const t = new xy(this._navMap, "slices");
    hbt.forEach((n) => {
      this._navMap.node("top", {}).connect(n, t);
    });
    const r = this._store.model.series[0].datapoints.map((n, i) => {
      const s = new oa(t, "datapoint", {
        seriesKey: n.seriesKey,
        index: n.datapointIndex
      }, this._store);
      return s.connect("out", this._navMap.root), s.connect("up", this._navMap.root), s;
    });
    r.slice(0, -1).forEach((n, i) => {
      n.connect("right", t.get("datapoint", i + 1));
    }), r.at(-1).connect("right", r[0]);
  }
  legend() {
    const t = this._store.model.series[0].datapoints.map((n) => jr(n.facetBox("x"), this._store.getFormatType("pieSliceLabel"))), r = this._store.model.series[0].datapoints.map((n) => jr(n.facetBox("y"), this._store.getFormatType("pieSliceValue")));
    return t.map((n, i) => ({
      label: `${n}: ${r[i]}`,
      color: i,
      datapointIndex: i
    }));
  }
  playDatapoints(t) {
    this._sonifier.playDatapoints(t, { invert: !0, durationVariable: !0 });
  }
  playDir(t) {
  }
  playRiff(t, r) {
  }
  _sparkBrailleInfo() {
    return {
      data: this._navMap.cursor.isNodeType("datapoint") || this._navMap.cursor.isNodeType("series") ? JSON.stringify(this._store.model.atKey(
        this._navMap.cursor.options.seriesKey
      ).datapoints.map((t) => ({
        // XXX shouldn't assume x is string (or that we have an 'x' facet, for that matter)
        label: t.facetValue("x"),
        value: t.facetValueAsNumber("y")
      }))) : "0",
      isProportional: !0
    };
  }
  // TODO: localize this text output
  // focused view: e.options!.focus
  // all visited datapoint views: e.options!.visited
  queryData() {
    const t = [], r = this._navMap.cursor;
    if (r.isNodeType("top"))
      t.push(`Displaying Chart: ${this._store.title}`);
    else if (r.isNodeType("series")) {
      const n = r.options.seriesKey, i = this._store.model.atKey(n).length;
      t.push(Dn(
        Ai.seriesKeyLength,
        { seriesKey: n, datapointCount: i }
      ));
    } else if (r.isNodeType("datapoint")) {
      const n = this._store.selectedDatapoints, i = r.options.seriesKey, s = r.options.index, o = this._store.model.atKey(i).datapoints[s], a = this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(i, s);
      if (n.size) {
        const c = n.values().map((u) => {
          const p = Zr(u);
          return this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(p.seriesKey, p.index);
        }).toArray(), h = ZA(
          a,
          c
        );
        t.push(...h);
      } else
        t.push(Dn(
          Ai.percentageOfChart,
          {
            chartKey: i,
            datapointXY: qf(o, "raw"),
            datapointIndex: r.options.index + 1,
            datapointCount: this._store.model.atKey(i).length
          }
        )), this._store.model.multi && t.push(Dn(
          Ai.percentageOfSeries,
          {
            seriesKey: i,
            datapointXY: qf(o, "raw"),
            datapointIndex: r.options.index + 1,
            datapointCount: this._store.model.atKey(i).length
          }
        ));
      const l = JA(
        this._store.model,
        o.facetValueAsNumber("y"),
        i
      );
      t.push(...l);
    }
    this._store.announce(t);
  }
}
var jwt = Object.defineProperty, Fwt = (e, t, r) => t in e ? jwt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Ui = (e, t, r) => Fwt(e, typeof t != "symbol" ? t + "" : t, r);
function $wt(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var SI = { exports: {} }, Zw, _I;
function d$() {
  if (_I) return Zw;
  _I = 1, Zw = t;
  var e = +(Math.pow(2, 27) + 1);
  function t(r, n, i) {
    var s = r * n, o = e * r, a = o - r, l = o - a, c = r - l, h = e * n, u = h - n, p = h - u, y = n - p, g = s - l * p, b = g - c * p, f = b - l * y, E = c * y - f;
    return i ? (i[0] = E, i[1] = s, i) : [E, s];
  }
  return Zw;
}
var Jw, kI;
function zwt() {
  if (kI) return Jw;
  kI = 1, Jw = t;
  function e(r, n) {
    var i = r + n, s = i - r, o = i - s, a = n - s, l = r - o, c = l + a;
    return c ? [c, i] : [i];
  }
  function t(r, n) {
    var i = r.length | 0, s = n.length | 0;
    if (i === 1 && s === 1)
      return e(r[0], n[0]);
    var o = i + s, a = new Array(o), l = 0, c = 0, h = 0, u = Math.abs, p = r[c], y = u(p), g = n[h], b = u(g), f, E;
    y < b ? (E = p, c += 1, c < i && (p = r[c], y = u(p))) : (E = g, h += 1, h < s && (g = n[h], b = u(g))), c < i && y < b || h >= s ? (f = p, c += 1, c < i && (p = r[c], y = u(p))) : (f = g, h += 1, h < s && (g = n[h], b = u(g)));
    for (var A = f + E, x = A - f, m = E - x, w = m, _ = A, S, R, O, $, z; c < i && h < s; )
      y < b ? (f = p, c += 1, c < i && (p = r[c], y = u(p))) : (f = g, h += 1, h < s && (g = n[h], b = u(g))), E = w, A = f + E, x = A - f, m = E - x, m && (a[l++] = m), S = _ + A, R = S - _, O = S - R, $ = A - R, z = _ - O, w = z + $, _ = S;
    for (; c < i; )
      f = p, E = w, A = f + E, x = A - f, m = E - x, m && (a[l++] = m), S = _ + A, R = S - _, O = S - R, $ = A - R, z = _ - O, w = z + $, _ = S, c += 1, c < i && (p = r[c]);
    for (; h < s; )
      f = g, E = w, A = f + E, x = A - f, m = E - x, m && (a[l++] = m), S = _ + A, R = S - _, O = S - R, $ = A - R, z = _ - O, w = z + $, _ = S, h += 1, h < s && (g = n[h]);
    return w && (a[l++] = w), _ && (a[l++] = _), l || (a[l++] = 0), a.length = l, a;
  }
  return Jw;
}
var Xw, CI;
function Vwt() {
  if (CI) return Xw;
  CI = 1, Xw = e;
  function e(t, r, n) {
    var i = t + r, s = i - t, o = i - s, a = r - s, l = t - o;
    return n ? (n[0] = l + a, n[1] = i, n) : [l + a, i];
  }
  return Xw;
}
var t3, II;
function Uwt() {
  if (II) return t3;
  II = 1;
  var e = d$(), t = Vwt();
  t3 = r;
  function r(n, i) {
    var s = n.length;
    if (s === 1) {
      var o = e(n[0], i);
      return o[0] ? o : [o[1]];
    }
    var a = new Array(2 * s), l = [0.1, 0.1], c = [0.1, 0.1], h = 0;
    e(n[0], i, l), l[0] && (a[h++] = l[0]);
    for (var u = 1; u < s; ++u) {
      e(n[u], i, c);
      var p = l[1];
      t(p, c[0], l), l[0] && (a[h++] = l[0]);
      var y = c[1], g = l[1], b = y + g, f = b - y, E = g - f;
      l[1] = b, E && (a[h++] = E);
    }
    return l[1] && (a[h++] = l[1]), h === 0 && (a[h++] = 0), a.length = h, a;
  }
  return t3;
}
var e3, PI;
function Hwt() {
  if (PI) return e3;
  PI = 1, e3 = t;
  function e(r, n) {
    var i = r + n, s = i - r, o = i - s, a = n - s, l = r - o, c = l + a;
    return c ? [c, i] : [i];
  }
  function t(r, n) {
    var i = r.length | 0, s = n.length | 0;
    if (i === 1 && s === 1)
      return e(r[0], -n[0]);
    var o = i + s, a = new Array(o), l = 0, c = 0, h = 0, u = Math.abs, p = r[c], y = u(p), g = -n[h], b = u(g), f, E;
    y < b ? (E = p, c += 1, c < i && (p = r[c], y = u(p))) : (E = g, h += 1, h < s && (g = -n[h], b = u(g))), c < i && y < b || h >= s ? (f = p, c += 1, c < i && (p = r[c], y = u(p))) : (f = g, h += 1, h < s && (g = -n[h], b = u(g)));
    for (var A = f + E, x = A - f, m = E - x, w = m, _ = A, S, R, O, $, z; c < i && h < s; )
      y < b ? (f = p, c += 1, c < i && (p = r[c], y = u(p))) : (f = g, h += 1, h < s && (g = -n[h], b = u(g))), E = w, A = f + E, x = A - f, m = E - x, m && (a[l++] = m), S = _ + A, R = S - _, O = S - R, $ = A - R, z = _ - O, w = z + $, _ = S;
    for (; c < i; )
      f = p, E = w, A = f + E, x = A - f, m = E - x, m && (a[l++] = m), S = _ + A, R = S - _, O = S - R, $ = A - R, z = _ - O, w = z + $, _ = S, c += 1, c < i && (p = r[c]);
    for (; h < s; )
      f = g, E = w, A = f + E, x = A - f, m = E - x, m && (a[l++] = m), S = _ + A, R = S - _, O = S - R, $ = A - R, z = _ - O, w = z + $, _ = S, h += 1, h < s && (g = -n[h]);
    return w && (a[l++] = w), _ && (a[l++] = _), l || (a[l++] = 0), a.length = l, a;
  }
  return e3;
}
var RI;
function Gwt() {
  return RI || (RI = 1, function(e) {
    var t = d$(), r = zwt(), n = Uwt(), i = Hwt(), s = 5, o = 11102230246251565e-32, a = (3 + 16 * o) * o, l = (7 + 56 * o) * o;
    function c(x, m, w, _) {
      return function(S, R, O) {
        var $ = x(x(m(R[1], O[0]), m(-O[1], R[0])), x(m(S[1], R[0]), m(-R[1], S[0]))), z = x(m(S[1], O[0]), m(-O[1], S[0])), F = _($, z);
        return F[F.length - 1];
      };
    }
    function h(x, m, w, _) {
      return function(S, R, O, $) {
        var z = x(x(w(x(m(O[1], $[0]), m(-$[1], O[0])), R[2]), x(w(x(m(R[1], $[0]), m(-$[1], R[0])), -O[2]), w(x(m(R[1], O[0]), m(-O[1], R[0])), $[2]))), x(w(x(m(R[1], $[0]), m(-$[1], R[0])), S[2]), x(w(x(m(S[1], $[0]), m(-$[1], S[0])), -R[2]), w(x(m(S[1], R[0]), m(-R[1], S[0])), $[2])))), F = x(x(w(x(m(O[1], $[0]), m(-$[1], O[0])), S[2]), x(w(x(m(S[1], $[0]), m(-$[1], S[0])), -O[2]), w(x(m(S[1], O[0]), m(-O[1], S[0])), $[2]))), x(w(x(m(R[1], O[0]), m(-O[1], R[0])), S[2]), x(w(x(m(S[1], O[0]), m(-O[1], S[0])), -R[2]), w(x(m(S[1], R[0]), m(-R[1], S[0])), O[2])))), Y = _(z, F);
        return Y[Y.length - 1];
      };
    }
    function u(x, m, w, _) {
      return function(S, R, O, $, z) {
        var F = x(x(x(w(x(w(x(m($[1], z[0]), m(-z[1], $[0])), O[2]), x(w(x(m(O[1], z[0]), m(-z[1], O[0])), -$[2]), w(x(m(O[1], $[0]), m(-$[1], O[0])), z[2]))), R[3]), x(w(x(w(x(m($[1], z[0]), m(-z[1], $[0])), R[2]), x(w(x(m(R[1], z[0]), m(-z[1], R[0])), -$[2]), w(x(m(R[1], $[0]), m(-$[1], R[0])), z[2]))), -O[3]), w(x(w(x(m(O[1], z[0]), m(-z[1], O[0])), R[2]), x(w(x(m(R[1], z[0]), m(-z[1], R[0])), -O[2]), w(x(m(R[1], O[0]), m(-O[1], R[0])), z[2]))), $[3]))), x(w(x(w(x(m(O[1], $[0]), m(-$[1], O[0])), R[2]), x(w(x(m(R[1], $[0]), m(-$[1], R[0])), -O[2]), w(x(m(R[1], O[0]), m(-O[1], R[0])), $[2]))), -z[3]), x(w(x(w(x(m($[1], z[0]), m(-z[1], $[0])), R[2]), x(w(x(m(R[1], z[0]), m(-z[1], R[0])), -$[2]), w(x(m(R[1], $[0]), m(-$[1], R[0])), z[2]))), S[3]), w(x(w(x(m($[1], z[0]), m(-z[1], $[0])), S[2]), x(w(x(m(S[1], z[0]), m(-z[1], S[0])), -$[2]), w(x(m(S[1], $[0]), m(-$[1], S[0])), z[2]))), -R[3])))), x(x(w(x(w(x(m(R[1], z[0]), m(-z[1], R[0])), S[2]), x(w(x(m(S[1], z[0]), m(-z[1], S[0])), -R[2]), w(x(m(S[1], R[0]), m(-R[1], S[0])), z[2]))), $[3]), x(w(x(w(x(m(R[1], $[0]), m(-$[1], R[0])), S[2]), x(w(x(m(S[1], $[0]), m(-$[1], S[0])), -R[2]), w(x(m(S[1], R[0]), m(-R[1], S[0])), $[2]))), -z[3]), w(x(w(x(m(O[1], $[0]), m(-$[1], O[0])), R[2]), x(w(x(m(R[1], $[0]), m(-$[1], R[0])), -O[2]), w(x(m(R[1], O[0]), m(-O[1], R[0])), $[2]))), S[3]))), x(w(x(w(x(m(O[1], $[0]), m(-$[1], O[0])), S[2]), x(w(x(m(S[1], $[0]), m(-$[1], S[0])), -O[2]), w(x(m(S[1], O[0]), m(-O[1], S[0])), $[2]))), -R[3]), x(w(x(w(x(m(R[1], $[0]), m(-$[1], R[0])), S[2]), x(w(x(m(S[1], $[0]), m(-$[1], S[0])), -R[2]), w(x(m(S[1], R[0]), m(-R[1], S[0])), $[2]))), O[3]), w(x(w(x(m(R[1], O[0]), m(-O[1], R[0])), S[2]), x(w(x(m(S[1], O[0]), m(-O[1], S[0])), -R[2]), w(x(m(S[1], R[0]), m(-R[1], S[0])), O[2]))), -$[3]))))), Y = x(x(x(w(x(w(x(m($[1], z[0]), m(-z[1], $[0])), O[2]), x(w(x(m(O[1], z[0]), m(-z[1], O[0])), -$[2]), w(x(m(O[1], $[0]), m(-$[1], O[0])), z[2]))), S[3]), w(x(w(x(m($[1], z[0]), m(-z[1], $[0])), S[2]), x(w(x(m(S[1], z[0]), m(-z[1], S[0])), -$[2]), w(x(m(S[1], $[0]), m(-$[1], S[0])), z[2]))), -O[3])), x(w(x(w(x(m(O[1], z[0]), m(-z[1], O[0])), S[2]), x(w(x(m(S[1], z[0]), m(-z[1], S[0])), -O[2]), w(x(m(S[1], O[0]), m(-O[1], S[0])), z[2]))), $[3]), w(x(w(x(m(O[1], $[0]), m(-$[1], O[0])), S[2]), x(w(x(m(S[1], $[0]), m(-$[1], S[0])), -O[2]), w(x(m(S[1], O[0]), m(-O[1], S[0])), $[2]))), -z[3]))), x(x(w(x(w(x(m(O[1], z[0]), m(-z[1], O[0])), R[2]), x(w(x(m(R[1], z[0]), m(-z[1], R[0])), -O[2]), w(x(m(R[1], O[0]), m(-O[1], R[0])), z[2]))), S[3]), w(x(w(x(m(O[1], z[0]), m(-z[1], O[0])), S[2]), x(w(x(m(S[1], z[0]), m(-z[1], S[0])), -O[2]), w(x(m(S[1], O[0]), m(-O[1], S[0])), z[2]))), -R[3])), x(w(x(w(x(m(R[1], z[0]), m(-z[1], R[0])), S[2]), x(w(x(m(S[1], z[0]), m(-z[1], S[0])), -R[2]), w(x(m(S[1], R[0]), m(-R[1], S[0])), z[2]))), O[3]), w(x(w(x(m(R[1], O[0]), m(-O[1], R[0])), S[2]), x(w(x(m(S[1], O[0]), m(-O[1], S[0])), -R[2]), w(x(m(S[1], R[0]), m(-R[1], S[0])), O[2]))), -z[3])))), rt = _(F, Y);
        return rt[rt.length - 1];
      };
    }
    function p(x) {
      var m = x === 3 ? c : x === 4 ? h : u;
      return m(r, t, n, i);
    }
    var y = p(3), g = p(4), b = [
      function() {
        return 0;
      },
      function() {
        return 0;
      },
      function(x, m) {
        return m[0] - x[0];
      },
      function(x, m, w) {
        var _ = (x[1] - w[1]) * (m[0] - w[0]), S = (x[0] - w[0]) * (m[1] - w[1]), R = _ - S, O;
        if (_ > 0) {
          if (S <= 0)
            return R;
          O = _ + S;
        } else if (_ < 0) {
          if (S >= 0)
            return R;
          O = -(_ + S);
        } else
          return R;
        var $ = a * O;
        return R >= $ || R <= -$ ? R : y(x, m, w);
      },
      function(x, m, w, _) {
        var S = x[0] - _[0], R = m[0] - _[0], O = w[0] - _[0], $ = x[1] - _[1], z = m[1] - _[1], F = w[1] - _[1], Y = x[2] - _[2], rt = m[2] - _[2], at = w[2] - _[2], pt = R * F, vt = O * z, _t = O * $, Ct = S * F, It = S * z, jt = R * $, lt = Y * (pt - vt) + rt * (_t - Ct) + at * (It - jt), L = (Math.abs(pt) + Math.abs(vt)) * Math.abs(Y) + (Math.abs(_t) + Math.abs(Ct)) * Math.abs(rt) + (Math.abs(It) + Math.abs(jt)) * Math.abs(at), D = l * L;
        return lt > D || -lt > D ? lt : g(x, m, w, _);
      }
    ];
    function f(x) {
      var m = b[x.length];
      return m || (m = b[x.length] = p(x.length)), m.apply(void 0, x);
    }
    function E(x, m, w, _, S, R, O) {
      return function($, z, F, Y, rt) {
        switch (arguments.length) {
          case 0:
          case 1:
            return 0;
          case 2:
            return _($, z);
          case 3:
            return S($, z, F);
          case 4:
            return R($, z, F, Y);
          case 5:
            return O($, z, F, Y, rt);
        }
        for (var at = new Array(arguments.length), pt = 0; pt < arguments.length; ++pt)
          at[pt] = arguments[pt];
        return x(at);
      };
    }
    function A() {
      for (; b.length <= s; )
        b.push(p(b.length));
      e.exports = E.apply(void 0, [f].concat(b));
      for (var x = 0; x <= s; ++x)
        e.exports[x] = b[x];
    }
    A();
  }(SI)), SI.exports;
}
var Qwt = Gwt();
const p1 = /* @__PURE__ */ $wt(Qwt);
function U4(e, t, r) {
  for (var n = t[0], i = t[1], s = e.length, o = 1, a = s, l = 0, c = s - 1; l < a; c = l++) {
    var h = e[l], u = e[c], p = h[1], y = u[1];
    if (y < p) {
      if (y < i && i < p) {
        var g = p1(h, u, t);
        if (Math.abs(g) < r)
          return 0;
        o ^= 0 < g | 0;
      } else if (i === p) {
        var b = e[(l + 1) % s], f = b[1];
        if (p < f) {
          var g = p1(h, u, t);
          if (g === 0)
            return 0;
          o ^= 0 < g | 0;
        }
      }
    } else if (p < y) {
      if (p < i && i < y) {
        var g = p1(h, u, t);
        if (g === 0)
          return 0;
        o ^= g < 0 | 0;
      } else if (i === p) {
        var b = e[(l + 1) % s], f = b[1];
        if (f < p) {
          var g = p1(h, u, t);
          if (g === 0)
            return 0;
          o ^= g < 0 | 0;
        }
      }
    } else if (i === p) {
      var E = Math.min(h[0], u[0]), A = Math.max(h[0], u[0]);
      if (l === 0) {
        for (; c > 0; ) {
          var x = (c + s - 1) % s, m = e[x];
          if (m[1] !== i)
            break;
          var w = m[0];
          E = Math.min(E, w), A = Math.max(A, w), c = x;
        }
        if (c === 0)
          return E <= n && n <= A ? 0 : 1;
        a = c + 1;
      }
      for (var _ = e[(c + s - 1) % s][1]; l + 1 < a; ) {
        var m = e[l + 1];
        if (m[1] !== i)
          break;
        var w = m[0];
        E = Math.min(E, w), A = Math.max(A, w), l += 1;
      }
      if (E <= n && n <= A)
        return 0;
      var S = e[(l + 1) % s][1];
      n < E && _ < i != S < i && (o ^= 1);
    }
  }
  return 2 * o - 1;
}
function H4(e) {
  let t = e.slice();
  return t.sort(qwt), Wwt(t);
}
function Wwt(e) {
  if (e.length <= 1)
    return e.slice();
  let t = [];
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1], o = t[t.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
        t.pop();
      else
        break;
    }
    t.push(i);
  }
  t.pop();
  let r = [];
  for (let n = e.length - 1; n >= 0; n--) {
    const i = e[n];
    for (; r.length >= 2; ) {
      const s = r[r.length - 1], o = r[r.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
        r.pop();
      else
        break;
    }
    r.push(i);
  }
  return r.pop(), t.length == 1 && r.length == 1 && t[0].x == r[0].x && t[0].y == r[0].y ? t : t.concat(r);
}
function qwt(e, t) {
  return e.x < t.x ? -1 : e.x > t.x ? 1 : e.y < t.y ? -1 : e.y > t.y ? 1 : 0;
}
class Ywt {
  constructor(t, r, n, i, s) {
    Ui(this, "dataset"), Ui(this, "epsilon"), Ui(this, "minPts"), Ui(this, "distance"), Ui(this, "forceIn"), Ui(this, "clusters"), Ui(this, "clusterCentroids"), Ui(this, "noise"), Ui(this, "noiseAssigned"), Ui(this, "_visited"), Ui(this, "_assigned"), Ui(this, "_datasetLength"), this.dataset = t, this.epsilon = r, this.minPts = n, s || (s = this._euclideanDistance), this.distance = s, this.forceIn = i, this.clusters = [], this.clusterCentroids = [], this.noise = [], this.noiseAssigned = [], this._visited = [], this._assigned = [], this._datasetLength = t.length, this.run(t, r, n, i, s);
  }
  /******************************************************************************/
  // public functions
  /**
   * Start clustering
   *
   * @param {Array} dataset
   * @param {number} epsilon
   * @param {number} minPts
   * @param {function} distanceFunction
   * @param {boolean} distanceFunction
   * @returns {undefined}
   * @access public
   */
  run(t, r, n, i, s) {
    this._init(t, r, n, i, s);
    for (var o = 0; o < this._datasetLength; o++)
      if (this._visited[o] !== 1) {
        this._visited[o] = 1;
        var a = this._regionQuery(o);
        if (a.length < this.minPts)
          this.noise.push(o);
        else {
          var l = this.clusters.length;
          this.clusters.push([]), this._addToCluster(o, l), this._expandCluster(l, a);
        }
      }
    if (this.dataset.length > 1e3) {
      for (var c = this.minPts * 2, l = 0; l < this.clusters.length; l++) {
        var h = this.clusters[l];
        if (h.length < c) {
          for (var o = 0; o < h.length; o++)
            this.noise.push(h[o]);
          this.clusters[l] = [];
        }
      }
      this.clusters = this.clusters.filter((g) => g.length > 0);
    }
    for (var u = 0; u < this.clusters.length; u++)
      this.clusterCentroids.push(this._centroid(this.clusters[u]));
    let p = [];
    for (let g = 0; g < this._datasetLength; g++)
      p.push(0);
    for (let g in this.clusters)
      for (let b of this.clusters[g])
        p[b] = Number(g);
    let y = [];
    for (let g of this.noise) {
      let b = this._nearestAssignedNeighbor(this.clusters.flat(), g);
      y.push([g, Number(p[b])]);
    }
    if (this.forceIn) {
      this.noiseAssigned = [];
      for (let g = 0; g < y.length; g++) {
        let b = y[g];
        this.noiseAssigned.push([b[0], b[1]]), this._addToCluster(b[0], b[1]), p[b[0]] = b[1];
      }
      this.noise = [];
    } else {
      this.noiseAssigned = [];
      for (let g = 0; g < y.length; g++) {
        let b = y[g];
        this.noiseAssigned.push([b[0], b[1]]), p[b[0]] = b[1];
      }
    }
    return this.clusters;
  }
  /******************************************************************************/
  // protected functions
  /**
   * Set object properties
   *
   * @param {Array} dataset
   * @param {number} epsilon
   * @param {number} minPts
   * @param {function} distance
   * @param {boolean} forceIn
   * @returns {undefined}
   * @access protected
   */
  _init(t, r, n, i, s) {
    if (t) {
      if (!(t instanceof Array))
        throw Error("Dataset must be of type array, " + typeof t + " given");
      this.dataset = t, this.clusters = [], this.noise = [], this._datasetLength = t.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength);
    }
    r && (this.epsilon = r), n && (this.minPts = n), s && (this.distance = s), i && (this.forceIn = i);
  }
  /**
   * Expand cluster to closest points of given neighborhood
   *
   * @param {number} clusterId
   * @param {Array} neighbors
   * @returns {undefined}
   * @access protected
   */
  _expandCluster(t, r) {
    for (var n = 0; n < r.length; n++) {
      var i = r[n];
      if (this._visited[i] !== 1) {
        this._visited[i] = 1;
        var s = this._regionQuery(i);
        s.length >= this.minPts && (r = this._mergeArrays(r, s));
      }
      this._assigned[i] !== 1 && (this._addToCluster(i, t), this.noise.indexOf(i) > -1 && this.noise.splice(this.noise.indexOf(i), 1));
    }
  }
  /**
   * Add new point to cluster
   *
   * @param {number} pointId
   * @param {number} clusterId
   */
  _addToCluster(t, r) {
    this.clusters[r].push(t), this._assigned[t] = 1;
  }
  /**
   * Find all neighbors around given point
   *
   * @param {number} pointId,
   * @param {number} epsilon
   * @returns {Array}
   * @access protected
   */
  _regionQuery(t) {
    let r = [];
    for (var n = 0; n < this._datasetLength; n++) {
      var i = this.distance(this.dataset[t], this.dataset[n]);
      i < this.epsilon && r.push(n);
    }
    return r;
  }
  /******************************************************************************/
  // helpers
  /**
   * @param {Array} a
   * @param {Array} b
   * @returns {Array}
   * @access protected
   */
  _mergeArrays(t, r) {
    for (var n = r.length, i = 0; i < n; i++) {
      var s = r[i];
      t.indexOf(s) < 0 && t.push(s);
    }
    return t;
  }
  /**
   * Calculate euclidean distance in multidimensional space
   *
   * @param {Array} p
   * @param {Array} q
   * @returns {number}
   * @access protected
   */
  _euclideanDistance(t, r) {
    for (var n = 0, i = Math.min(t.length, r.length); i--; )
      n += (t[i] - r[i]) * (t[i] - r[i]);
    return Math.sqrt(n);
  }
  /**
   * Calculate centroid of a group of points
   *
   * @param {Array} c
   * @returns {Array}
   * @access protected
   */
  _centroid(t) {
    let r = 0, n = 0;
    const i = t.length;
    for (let s of t)
      r += this.dataset[s][0], n += this.dataset[s][1];
    return [r / i, n / i];
  }
  /**
  * Given a list of clustered points and an outlier, returns the closest clustered point.
  *
  * @param {Array} datasetIds
  * @param {number} pointId
  * @returns {number}
  * @access protected
  */
  _nearestAssignedNeighbor(t, r) {
    var n = [0, 0];
    for (var i of t) {
      n[1] == 0 && (n = [i, this._euclideanDistance(this.dataset[r], this.dataset[i])]);
      let s = this._euclideanDistance(this.dataset[r], this.dataset[i]);
      n[1] > s && (n = [i, s]);
    }
    return n[0];
  }
}
/*!
Copyright (C) 2010-2013 Raymond Hill: https://github.com/gorhill/Javascript-Voronoi
MIT License: See https://github.com/gorhill/Javascript-Voronoi/LICENSE.md
*/
function ae() {
  this.vertices = null, this.edges = null, this.cells = null, this.toRecycle = null, this.beachsectionJunkyard = [], this.circleEventJunkyard = [], this.vertexJunkyard = [], this.edgeJunkyard = [], this.cellJunkyard = [];
}
ae.prototype.reset = function() {
  if (this.beachline || (this.beachline = new this.RBTree()), this.beachline.root)
    for (var e = this.beachline.getFirst(this.beachline.root); e; )
      this.beachsectionJunkyard.push(e), e = e.rbNext;
  this.beachline.root = null, this.circleEvents || (this.circleEvents = new this.RBTree()), this.circleEvents.root = this.firstCircleEvent = null, this.vertices = [], this.edges = [], this.cells = [];
};
ae.prototype.sqrt = Math.sqrt;
ae.prototype.abs = Math.abs;
ae.prototype. = ae. = 1e-9;
ae.prototype.inv = ae.inv = 1 / ae.;
ae.prototype.equalWithEpsilon = function(e, t) {
  return this.abs(e - t) < 1e-9;
};
ae.prototype.greaterThanWithEpsilon = function(e, t) {
  return e - t > 1e-9;
};
ae.prototype.greaterThanOrEqualWithEpsilon = function(e, t) {
  return t - e < 1e-9;
};
ae.prototype.lessThanWithEpsilon = function(e, t) {
  return t - e > 1e-9;
};
ae.prototype.lessThanOrEqualWithEpsilon = function(e, t) {
  return e - t < 1e-9;
};
ae.prototype.RBTree = function() {
  this.root = null;
};
ae.prototype.RBTree.prototype.rbInsertSuccessor = function(e, t) {
  var r;
  if (e) {
    if (t.rbPrevious = e, t.rbNext = e.rbNext, e.rbNext && (e.rbNext.rbPrevious = t), e.rbNext = t, e.rbRight) {
      for (e = e.rbRight; e.rbLeft; )
        e = e.rbLeft;
      e.rbLeft = t;
    } else
      e.rbRight = t;
    r = e;
  } else this.root ? (e = this.getFirst(this.root), t.rbPrevious = null, t.rbNext = e, e.rbPrevious = t, e.rbLeft = t, r = e) : (t.rbPrevious = t.rbNext = null, this.root = t, r = null);
  t.rbLeft = t.rbRight = null, t.rbParent = r, t.rbRed = !0;
  var n, i;
  for (e = t; r && r.rbRed; )
    n = r.rbParent, r === n.rbLeft ? (i = n.rbRight, i && i.rbRed ? (r.rbRed = i.rbRed = !1, n.rbRed = !0, e = n) : (e === r.rbRight && (this.rbRotateLeft(r), e = r, r = e.rbParent), r.rbRed = !1, n.rbRed = !0, this.rbRotateRight(n))) : (i = n.rbLeft, i && i.rbRed ? (r.rbRed = i.rbRed = !1, n.rbRed = !0, e = n) : (e === r.rbLeft && (this.rbRotateRight(r), e = r, r = e.rbParent), r.rbRed = !1, n.rbRed = !0, this.rbRotateLeft(n))), r = e.rbParent;
  this.root.rbRed = !1;
};
ae.prototype.RBTree.prototype.rbRemoveNode = function(e) {
  e.rbNext && (e.rbNext.rbPrevious = e.rbPrevious), e.rbPrevious && (e.rbPrevious.rbNext = e.rbNext), e.rbNext = e.rbPrevious = null;
  var t = e.rbParent, r = e.rbLeft, n = e.rbRight, i;
  r ? n ? i = this.getFirst(n) : i = r : i = n, t ? t.rbLeft === e ? t.rbLeft = i : t.rbRight = i : this.root = i;
  var s;
  if (r && n ? (s = i.rbRed, i.rbRed = e.rbRed, i.rbLeft = r, r.rbParent = i, i !== n ? (t = i.rbParent, i.rbParent = e.rbParent, e = i.rbRight, t.rbLeft = e, i.rbRight = n, n.rbParent = i) : (i.rbParent = t, t = i, e = i.rbRight)) : (s = e.rbRed, e = i), e && (e.rbParent = t), !s) {
    if (e && e.rbRed) {
      e.rbRed = !1;
      return;
    }
    var o;
    do {
      if (e === this.root)
        break;
      if (e === t.rbLeft) {
        if (o = t.rbRight, o.rbRed && (o.rbRed = !1, t.rbRed = !0, this.rbRotateLeft(t), o = t.rbRight), o.rbLeft && o.rbLeft.rbRed || o.rbRight && o.rbRight.rbRed) {
          (!o.rbRight || !o.rbRight.rbRed) && (o.rbLeft.rbRed = !1, o.rbRed = !0, this.rbRotateRight(o), o = t.rbRight), o.rbRed = t.rbRed, t.rbRed = o.rbRight.rbRed = !1, this.rbRotateLeft(t), e = this.root;
          break;
        }
      } else if (o = t.rbLeft, o.rbRed && (o.rbRed = !1, t.rbRed = !0, this.rbRotateRight(t), o = t.rbLeft), o.rbLeft && o.rbLeft.rbRed || o.rbRight && o.rbRight.rbRed) {
        (!o.rbLeft || !o.rbLeft.rbRed) && (o.rbRight.rbRed = !1, o.rbRed = !0, this.rbRotateLeft(o), o = t.rbLeft), o.rbRed = t.rbRed, t.rbRed = o.rbLeft.rbRed = !1, this.rbRotateRight(t), e = this.root;
        break;
      }
      o.rbRed = !0, e = t, t = t.rbParent;
    } while (!e.rbRed);
    e && (e.rbRed = !1);
  }
};
ae.prototype.RBTree.prototype.rbRotateLeft = function(e) {
  var t = e, r = e.rbRight, n = t.rbParent;
  n ? n.rbLeft === t ? n.rbLeft = r : n.rbRight = r : this.root = r, r.rbParent = n, t.rbParent = r, t.rbRight = r.rbLeft, t.rbRight && (t.rbRight.rbParent = t), r.rbLeft = t;
};
ae.prototype.RBTree.prototype.rbRotateRight = function(e) {
  var t = e, r = e.rbLeft, n = t.rbParent;
  n ? n.rbLeft === t ? n.rbLeft = r : n.rbRight = r : this.root = r, r.rbParent = n, t.rbParent = r, t.rbLeft = r.rbRight, t.rbLeft && (t.rbLeft.rbParent = t), r.rbRight = t;
};
ae.prototype.RBTree.prototype.getFirst = function(e) {
  for (; e.rbLeft; )
    e = e.rbLeft;
  return e;
};
ae.prototype.RBTree.prototype.getLast = function(e) {
  for (; e.rbRight; )
    e = e.rbRight;
  return e;
};
ae.prototype.Diagram = function(e) {
  this.site = e;
};
ae.prototype.Cell = function(e) {
  this.site = e, this.halfedges = [], this.closeMe = !1;
};
ae.prototype.Cell.prototype.init = function(e) {
  return this.site = e, this.halfedges = [], this.closeMe = !1, this;
};
ae.prototype.createCell = function(e) {
  var t = this.cellJunkyard.pop();
  return t ? t.init(e) : new this.Cell(e);
};
ae.prototype.Cell.prototype.prepareHalfedges = function() {
  for (var e = this.halfedges, t = e.length, r; t--; )
    r = e[t].edge, (!r.vb || !r.va) && e.splice(t, 1);
  return e.sort(function(n, i) {
    return i.angle - n.angle;
  }), e.length;
};
ae.prototype.Cell.prototype.getNeighborIds = function() {
  for (var e = [], t = this.halfedges.length, r; t--; )
    r = this.halfedges[t].edge, r.lSite !== null && r.lSite.voronoiId != this.site.voronoiId ? e.push(r.lSite.voronoiId) : r.rSite !== null && r.rSite.voronoiId != this.site.voronoiId && e.push(r.rSite.voronoiId);
  return e;
};
ae.prototype.Cell.prototype.getBbox = function() {
  for (var e = this.halfedges, t = e.length, r = 1 / 0, n = 1 / 0, i = -1 / 0, s = -1 / 0, o, a, l; t--; )
    o = e[t].getStartpoint(), a = o.x, l = o.y, a < r && (r = a), l < n && (n = l), a > i && (i = a), l > s && (s = l);
  return {
    x: r,
    y: n,
    width: i - r,
    height: s - n
  };
};
ae.prototype.Cell.prototype.pointIntersection = function(e, t) {
  for (var r = this.halfedges, n = r.length, i, s, o, a; n--; ) {
    if (i = r[n], s = i.getStartpoint(), o = i.getEndpoint(), a = (t - s.y) * (o.x - s.x) - (e - s.x) * (o.y - s.y), !a)
      return 0;
    if (a > 0)
      return -1;
  }
  return 1;
};
ae.prototype.Vertex = function(e, t) {
  this.x = e, this.y = t;
};
ae.prototype.Edge = function(e, t) {
  this.lSite = e, this.rSite = t, this.va = this.vb = null;
};
ae.prototype.Halfedge = function(e, t, r) {
  if (this.site = t, this.edge = e, r)
    this.angle = Math.atan2(r.y - t.y, r.x - t.x);
  else {
    var n = e.va, i = e.vb;
    this.angle = e.lSite === t ? Math.atan2(i.x - n.x, n.y - i.y) : Math.atan2(n.x - i.x, i.y - n.y);
  }
};
ae.prototype.createHalfedge = function(e, t, r) {
  return new this.Halfedge(e, t, r);
};
ae.prototype.Halfedge.prototype.getStartpoint = function() {
  return this.edge.lSite === this.site ? this.edge.va : this.edge.vb;
};
ae.prototype.Halfedge.prototype.getEndpoint = function() {
  return this.edge.lSite === this.site ? this.edge.vb : this.edge.va;
};
ae.prototype.createVertex = function(e, t) {
  var r = this.vertexJunkyard.pop();
  return r ? (r.x = e, r.y = t) : r = new this.Vertex(e, t), this.vertices.push(r), r;
};
ae.prototype.createEdge = function(e, t, r, n) {
  var i = this.edgeJunkyard.pop();
  return i ? (i.lSite = e, i.rSite = t, i.va = i.vb = null) : i = new this.Edge(e, t), this.edges.push(i), r && this.setEdgeStartpoint(i, e, t, r), n && this.setEdgeEndpoint(i, e, t, n), this.cells[e.voronoiId].halfedges.push(this.createHalfedge(i, e, t)), this.cells[t.voronoiId].halfedges.push(this.createHalfedge(i, t, e)), i;
};
ae.prototype.createBorderEdge = function(e, t, r) {
  var n = this.edgeJunkyard.pop();
  return n ? (n.lSite = e, n.rSite = null) : n = new this.Edge(e, null), n.va = t, n.vb = r, this.edges.push(n), n;
};
ae.prototype.setEdgeStartpoint = function(e, t, r, n) {
  !e.va && !e.vb ? (e.va = n, e.lSite = t, e.rSite = r) : e.lSite === r ? e.vb = n : e.va = n;
};
ae.prototype.setEdgeEndpoint = function(e, t, r, n) {
  this.setEdgeStartpoint(e, r, t, n);
};
ae.prototype.Beachsection = function() {
};
ae.prototype.createBeachsection = function(e) {
  var t = this.beachsectionJunkyard.pop();
  return t || (t = new this.Beachsection()), t.site = e, t;
};
ae.prototype.leftBreakPoint = function(e, t) {
  var r = e.site, n = r.x, i = r.y, s = i - t;
  if (!s)
    return n;
  var o = e.rbPrevious;
  if (!o)
    return -1 / 0;
  r = o.site;
  var a = r.x, l = r.y, c = l - t;
  if (!c)
    return a;
  var h = a - n, u = 1 / s - 1 / c, p = h / c;
  return u ? (-p + this.sqrt(p * p - 2 * u * (h * h / (-2 * c) - l + c / 2 + i - s / 2))) / u + n : (n + a) / 2;
};
ae.prototype.rightBreakPoint = function(e, t) {
  var r = e.rbNext;
  if (r)
    return this.leftBreakPoint(r, t);
  var n = e.site;
  return n.y === t ? n.x : 1 / 0;
};
ae.prototype.detachBeachsection = function(e) {
  this.detachCircleEvent(e), this.beachline.rbRemoveNode(e), this.beachsectionJunkyard.push(e);
};
ae.prototype.removeBeachsection = function(e) {
  var t = e.circleEvent, r = t.x, n = t.ycenter, i = this.createVertex(r, n), s = e.rbPrevious, o = e.rbNext, a = [e], l = Math.abs;
  this.detachBeachsection(e);
  for (var c = s; c.circleEvent && l(r - c.circleEvent.x) < 1e-9 && l(n - c.circleEvent.ycenter) < 1e-9; )
    s = c.rbPrevious, a.unshift(c), this.detachBeachsection(c), c = s;
  a.unshift(c), this.detachCircleEvent(c);
  for (var h = o; h.circleEvent && l(r - h.circleEvent.x) < 1e-9 && l(n - h.circleEvent.ycenter) < 1e-9; )
    o = h.rbNext, a.push(h), this.detachBeachsection(h), h = o;
  a.push(h), this.detachCircleEvent(h);
  var u = a.length, p;
  for (p = 1; p < u; p++)
    h = a[p], c = a[p - 1], this.setEdgeStartpoint(h.edge, c.site, h.site, i);
  c = a[0], h = a[u - 1], h.edge = this.createEdge(c.site, h.site, void 0, i), this.attachCircleEvent(c), this.attachCircleEvent(h);
};
ae.prototype.addBeachsection = function(e) {
  for (var t = e.x, r = e.y, n, i, s, o, a = this.beachline.root; a; )
    if (s = this.leftBreakPoint(a, r) - t, s > 1e-9)
      a = a.rbLeft;
    else if (o = t - this.rightBreakPoint(a, r), o > 1e-9) {
      if (!a.rbRight) {
        n = a;
        break;
      }
      a = a.rbRight;
    } else {
      s > -1e-9 ? (n = a.rbPrevious, i = a) : o > -1e-9 ? (n = a, i = a.rbNext) : n = i = a;
      break;
    }
  var l = this.createBeachsection(e);
  if (this.beachline.rbInsertSuccessor(n, l), !(!n && !i)) {
    if (n === i) {
      this.detachCircleEvent(n), i = this.createBeachsection(n.site), this.beachline.rbInsertSuccessor(l, i), l.edge = i.edge = this.createEdge(n.site, l.site), this.attachCircleEvent(n), this.attachCircleEvent(i);
      return;
    }
    if (n && !i) {
      l.edge = this.createEdge(n.site, l.site);
      return;
    }
    if (n !== i) {
      this.detachCircleEvent(n), this.detachCircleEvent(i);
      var c = n.site, h = c.x, u = c.y, p = e.x - h, y = e.y - u, g = i.site, b = g.x - h, f = g.y - u, E = 2 * (p * f - y * b), A = p * p + y * y, x = b * b + f * f, m = this.createVertex((f * A - y * x) / E + h, (p * x - b * A) / E + u);
      this.setEdgeStartpoint(i.edge, c, g, m), l.edge = this.createEdge(c, e, void 0, m), i.edge = this.createEdge(e, g, void 0, m), this.attachCircleEvent(n), this.attachCircleEvent(i);
      return;
    }
  }
};
ae.prototype.CircleEvent = function() {
  this.arc = null, this.rbLeft = null, this.rbNext = null, this.rbParent = null, this.rbPrevious = null, this.rbRed = !1, this.rbRight = null, this.site = null, this.x = this.y = this.ycenter = 0;
};
ae.prototype.attachCircleEvent = function(e) {
  var t = e.rbPrevious, r = e.rbNext;
  if (!(!t || !r)) {
    var n = t.site, i = e.site, s = r.site;
    if (n !== s) {
      var o = i.x, a = i.y, l = n.x - o, c = n.y - a, h = s.x - o, u = s.y - a, p = 2 * (l * u - c * h);
      if (!(p >= -2e-12)) {
        var y = l * l + c * c, g = h * h + u * u, b = (u * y - c * g) / p, f = (l * g - h * y) / p, E = f + a, A = this.circleEventJunkyard.pop();
        A || (A = new this.CircleEvent()), A.arc = e, A.site = i, A.x = b + o, A.y = E + this.sqrt(b * b + f * f), A.ycenter = E, e.circleEvent = A;
        for (var x = null, m = this.circleEvents.root; m; )
          if (A.y < m.y || A.y === m.y && A.x <= m.x)
            if (m.rbLeft)
              m = m.rbLeft;
            else {
              x = m.rbPrevious;
              break;
            }
          else if (m.rbRight)
            m = m.rbRight;
          else {
            x = m;
            break;
          }
        this.circleEvents.rbInsertSuccessor(x, A), x || (this.firstCircleEvent = A);
      }
    }
  }
};
ae.prototype.detachCircleEvent = function(e) {
  var t = e.circleEvent;
  t && (t.rbPrevious || (this.firstCircleEvent = t.rbNext), this.circleEvents.rbRemoveNode(t), this.circleEventJunkyard.push(t), e.circleEvent = null);
};
ae.prototype.connectEdge = function(e, t) {
  var r = e.vb;
  if (r)
    return !0;
  var n = e.va, i = t.xl, s = t.xr, o = t.yt, a = t.yb, l = e.lSite, c = e.rSite, h = l.x, u = l.y, p = c.x, y = c.y, g = (h + p) / 2, b = (u + y) / 2, f, E;
  if (this.cells[l.voronoiId].closeMe = !0, this.cells[c.voronoiId].closeMe = !0, y !== u && (f = (h - p) / (y - u), E = b - f * g), f === void 0) {
    if (g < i || g >= s)
      return !1;
    if (h > p) {
      if (!n || n.y < o)
        n = this.createVertex(g, o);
      else if (n.y >= a)
        return !1;
      r = this.createVertex(g, a);
    } else {
      if (!n || n.y > a)
        n = this.createVertex(g, a);
      else if (n.y < o)
        return !1;
      r = this.createVertex(g, o);
    }
  } else if (f < -1 || f > 1)
    if (h > p) {
      if (!n || n.y < o)
        n = this.createVertex((o - E) / f, o);
      else if (n.y >= a)
        return !1;
      r = this.createVertex((a - E) / f, a);
    } else {
      if (!n || n.y > a)
        n = this.createVertex((a - E) / f, a);
      else if (n.y < o)
        return !1;
      r = this.createVertex((o - E) / f, o);
    }
  else if (u < y) {
    if (!n || n.x < i)
      n = this.createVertex(i, f * i + E);
    else if (n.x >= s)
      return !1;
    r = this.createVertex(s, f * s + E);
  } else {
    if (!n || n.x > s)
      n = this.createVertex(s, f * s + E);
    else if (n.x < i)
      return !1;
    r = this.createVertex(i, f * i + E);
  }
  return e.va = n, e.vb = r, !0;
};
ae.prototype.clipEdge = function(e, t) {
  var r = e.va.x, n = e.va.y, i = e.vb.x, s = e.vb.y, o = 0, a = 1, l = i - r, c = s - n, h = r - t.xl;
  if (l === 0 && h < 0)
    return !1;
  var u = -h / l;
  if (l < 0) {
    if (u < o)
      return !1;
    u < a && (a = u);
  } else if (l > 0) {
    if (u > a)
      return !1;
    u > o && (o = u);
  }
  if (h = t.xr - r, l === 0 && h < 0)
    return !1;
  if (u = h / l, l < 0) {
    if (u > a)
      return !1;
    u > o && (o = u);
  } else if (l > 0) {
    if (u < o)
      return !1;
    u < a && (a = u);
  }
  if (h = n - t.yt, c === 0 && h < 0)
    return !1;
  if (u = -h / c, c < 0) {
    if (u < o)
      return !1;
    u < a && (a = u);
  } else if (c > 0) {
    if (u > a)
      return !1;
    u > o && (o = u);
  }
  if (h = t.yb - n, c === 0 && h < 0)
    return !1;
  if (u = h / c, c < 0) {
    if (u > a)
      return !1;
    u > o && (o = u);
  } else if (c > 0) {
    if (u < o)
      return !1;
    u < a && (a = u);
  }
  return o > 0 && (e.va = this.createVertex(r + o * l, n + o * c)), a < 1 && (e.vb = this.createVertex(r + a * l, n + a * c)), (o > 0 || a < 1) && (this.cells[e.lSite.voronoiId].closeMe = !0, this.cells[e.rSite.voronoiId].closeMe = !0), !0;
};
ae.prototype.clipEdges = function(e) {
  for (var t = this.edges, r = t.length, n, i = Math.abs; r--; )
    n = t[r], (!this.connectEdge(n, e) || !this.clipEdge(n, e) || i(n.va.x - n.vb.x) < 1e-9 && i(n.va.y - n.vb.y) < 1e-9) && (n.va = n.vb = null, t.splice(r, 1));
};
ae.prototype.closeCells = function(e) {
  for (var t = e.xl, r = e.xr, n = e.yt, i = e.yb, s = this.cells, o = s.length, a, l, c, h, u, p, y, g, b, f = Math.abs; o--; )
    if (a = s[o], !!a.prepareHalfedges() && a.closeMe) {
      for (c = a.halfedges, h = c.length, l = 0; l < h; ) {
        if (p = c[l].getEndpoint(), g = c[(l + 1) % h].getStartpoint(), f(p.x - g.x) >= 1e-9 || f(p.y - g.y) >= 1e-9)
          switch (!0) {
            case (this.equalWithEpsilon(p.x, t) && this.lessThanWithEpsilon(p.y, i)):
              if (b = this.equalWithEpsilon(g.x, t), y = this.createVertex(t, b ? g.y : i), u = this.createBorderEdge(a.site, p, y), l++, c.splice(l, 0, this.createHalfedge(u, a.site, null)), h++, b)
                break;
              p = y;
            case (this.equalWithEpsilon(p.y, i) && this.lessThanWithEpsilon(p.x, r)):
              if (b = this.equalWithEpsilon(g.y, i), y = this.createVertex(b ? g.x : r, i), u = this.createBorderEdge(a.site, p, y), l++, c.splice(l, 0, this.createHalfedge(u, a.site, null)), h++, b)
                break;
              p = y;
            case (this.equalWithEpsilon(p.x, r) && this.greaterThanWithEpsilon(p.y, n)):
              if (b = this.equalWithEpsilon(g.x, r), y = this.createVertex(r, b ? g.y : n), u = this.createBorderEdge(a.site, p, y), l++, c.splice(l, 0, this.createHalfedge(u, a.site, null)), h++, b)
                break;
              p = y;
            case (this.equalWithEpsilon(p.y, n) && this.greaterThanWithEpsilon(p.x, t)):
              if (b = this.equalWithEpsilon(g.y, n), y = this.createVertex(b ? g.x : t, n), u = this.createBorderEdge(a.site, p, y), l++, c.splice(l, 0, this.createHalfedge(u, a.site, null)), h++, b || (p = y, b = this.equalWithEpsilon(g.x, t), y = this.createVertex(t, b ? g.y : i), u = this.createBorderEdge(a.site, p, y), l++, c.splice(l, 0, this.createHalfedge(u, a.site, null)), h++, b) || (p = y, b = this.equalWithEpsilon(g.y, i), y = this.createVertex(b ? g.x : r, i), u = this.createBorderEdge(a.site, p, y), l++, c.splice(l, 0, this.createHalfedge(u, a.site, null)), h++, b) || (p = y, b = this.equalWithEpsilon(g.x, r), y = this.createVertex(r, b ? g.y : n), u = this.createBorderEdge(a.site, p, y), l++, c.splice(l, 0, this.createHalfedge(u, a.site, null)), h++, b))
                break;
            default:
              throw "Voronoi.closeCells() > this makes no sense!";
          }
        l++;
      }
      a.closeMe = !1;
    }
};
ae.prototype.quantizeSites = function(e) {
  for (var t = this., r = e.length, n; r--; )
    n = e[r], n.x = Math.floor(n.x / t) * t, n.y = Math.floor(n.y / t) * t;
};
ae.prototype.recycle = function(e) {
  if (e)
    if (e instanceof this.Diagram)
      this.toRecycle = e;
    else
      throw "Voronoi.recycleDiagram() > Need a Diagram object.";
};
ae.prototype.compute = function(e, t) {
  var r = /* @__PURE__ */ new Date();
  this.reset(), this.toRecycle && (this.vertexJunkyard = this.vertexJunkyard.concat(this.toRecycle.vertices), this.edgeJunkyard = this.edgeJunkyard.concat(this.toRecycle.edges), this.cellJunkyard = this.cellJunkyard.concat(this.toRecycle.cells), this.toRecycle = null);
  var n = e.slice(0);
  n.sort(function(p, y) {
    var g = y.y - p.y;
    return g || y.x - p.x;
  });
  for (var i = n.pop(), s = 0, o, a, l = this.cells, c; ; )
    if (c = this.firstCircleEvent, i && (!c || i.y < c.y || i.y === c.y && i.x < c.x))
      (i.x !== o || i.y !== a) && (l[s] = this.createCell(i), i.voronoiId = s++, this.addBeachsection(i), a = i.y, o = i.x), i = n.pop();
    else if (c)
      this.removeBeachsection(c.arc);
    else
      break;
  this.clipEdges(t), this.closeCells(t);
  var h = /* @__PURE__ */ new Date(), u = new this.Diagram();
  return u.cells = this.cells, u.edges = this.edges, u.vertices = this.vertices, u.execTime = h.getTime() - r.getTime(), this.reset(), u;
};
typeof module < "u" && (module.exports = ae);
/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function Kwt(e, t) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(h) {
      return l([c, h]);
    };
  }
  function l(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
      switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
        case 0:
        case 1:
          s = c;
          break;
        case 4:
          return r.label++, { value: c[1], done: !1 };
        case 5:
          r.label++, i = c[1], c = [0];
          continue;
        case 7:
          c = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            r = 0;
            continue;
          }
          if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
            r.label = c[1];
            break;
          }
          if (c[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = c;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(c);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      c = t.call(e, r);
    } catch (h) {
      c = [6, h], i = 0;
    } finally {
      n = s = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
var ql = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, r) {
      this.next = null, this.key = t, this.data = r, this.left = null, this.right = null;
    }
    return e;
  }()
);
function Zwt(e, t) {
  return e > t ? 1 : e < t ? -1 : 0;
}
function ul(e, t, r) {
  for (var n = new ql(null, null), i = n, s = n; ; ) {
    var o = r(e, t.key);
    if (o < 0) {
      if (t.left === null)
        break;
      if (r(e, t.left.key) < 0) {
        var a = t.left;
        if (t.left = a.right, a.right = t, t = a, t.left === null)
          break;
      }
      s.left = t, s = t, t = t.left;
    } else if (o > 0) {
      if (t.right === null)
        break;
      if (r(e, t.right.key) > 0) {
        var a = t.right;
        if (t.right = a.left, a.left = t, t = a, t.right === null)
          break;
      }
      i.right = t, i = t, t = t.right;
    } else
      break;
  }
  return i.right = t.left, s.left = t.right, t.left = n.right, t.right = n.left, t;
}
function r3(e, t, r, n) {
  var i = new ql(e, t);
  if (r === null)
    return i.left = i.right = null, i;
  r = ul(e, r, n);
  var s = n(e, r.key);
  return s < 0 ? (i.left = r.left, i.right = r, r.left = null) : s >= 0 && (i.right = r.right, i.left = r, r.right = null), i;
}
function TI(e, t, r) {
  var n = null, i = null;
  if (t) {
    t = ul(e, t, r);
    var s = r(t.key, e);
    s === 0 ? (n = t.left, i = t.right) : s < 0 ? (i = t.right, t.right = null, n = t) : (n = t.left, t.left = null, i = t);
  }
  return { left: n, right: i };
}
function Jwt(e, t, r) {
  return t === null ? e : (e === null || (t = ul(e.key, t, r), t.left = e), t);
}
function G4(e, t, r, n, i) {
  if (e) {
    n("" + t + (r ? " " : " ") + i(e) + `
`);
    var s = t + (r ? "    " : "   ");
    e.left && G4(e.left, s, !1, n, i), e.right && G4(e.right, s, !0, n, i);
  }
}
var XA = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = Zwt), this._root = null, this._size = 0, this._comparator = t;
    }
    return e.prototype.insert = function(t, r) {
      return this._size++, this._root = r3(t, r, this._root, this._comparator);
    }, e.prototype.add = function(t, r) {
      var n = new ql(t, r);
      this._root === null && (n.left = n.right = null, this._size++, this._root = n);
      var i = this._comparator, s = ul(t, this._root, i), o = i(t, s.key);
      return o === 0 ? this._root = s : (o < 0 ? (n.left = s.left, n.right = s, s.left = null) : o > 0 && (n.right = s.right, n.left = s, s.right = null), this._size++, this._root = n), this._root;
    }, e.prototype.remove = function(t) {
      this._root = this._remove(t, this._root, this._comparator);
    }, e.prototype._remove = function(t, r, n) {
      var i;
      if (r === null)
        return null;
      r = ul(t, r, n);
      var s = n(t, r.key);
      return s === 0 ? (r.left === null ? i = r.right : (i = ul(t, r.left, n), i.right = r.right), this._size--, i) : r;
    }, e.prototype.pop = function() {
      var t = this._root;
      if (t) {
        for (; t.left; )
          t = t.left;
        return this._root = ul(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), { key: t.key, data: t.data };
      }
      return null;
    }, e.prototype.findStatic = function(t) {
      for (var r = this._root, n = this._comparator; r; ) {
        var i = n(t, r.key);
        if (i === 0)
          return r;
        i < 0 ? r = r.left : r = r.right;
      }
      return null;
    }, e.prototype.find = function(t) {
      return this._root && (this._root = ul(t, this._root, this._comparator), this._comparator(t, this._root.key) !== 0) ? null : this._root;
    }, e.prototype.contains = function(t) {
      for (var r = this._root, n = this._comparator; r; ) {
        var i = n(t, r.key);
        if (i === 0)
          return !0;
        i < 0 ? r = r.left : r = r.right;
      }
      return !1;
    }, e.prototype.forEach = function(t, r) {
      for (var n = this._root, i = [], s = !1; !s; )
        n !== null ? (i.push(n), n = n.left) : i.length !== 0 ? (n = i.pop(), t.call(r, n), n = n.right) : s = !0;
      return this;
    }, e.prototype.range = function(t, r, n, i) {
      for (var s = [], o = this._comparator, a = this._root, l; s.length !== 0 || a; )
        if (a)
          s.push(a), a = a.left;
        else {
          if (a = s.pop(), l = o(a.key, r), l > 0)
            break;
          if (o(a.key, t) >= 0 && n.call(i, a))
            return this;
          a = a.right;
        }
      return this;
    }, e.prototype.keys = function() {
      var t = [];
      return this.forEach(function(r) {
        var n = r.key;
        return t.push(n);
      }), t;
    }, e.prototype.values = function() {
      var t = [];
      return this.forEach(function(r) {
        var n = r.data;
        return t.push(n);
      }), t;
    }, e.prototype.min = function() {
      return this._root ? this.minNode(this._root).key : null;
    }, e.prototype.max = function() {
      return this._root ? this.maxNode(this._root).key : null;
    }, e.prototype.minNode = function(t) {
      if (t === void 0 && (t = this._root), t)
        for (; t.left; )
          t = t.left;
      return t;
    }, e.prototype.maxNode = function(t) {
      if (t === void 0 && (t = this._root), t)
        for (; t.right; )
          t = t.right;
      return t;
    }, e.prototype.at = function(t) {
      for (var r = this._root, n = !1, i = 0, s = []; !n; )
        if (r)
          s.push(r), r = r.left;
        else if (s.length > 0) {
          if (r = s.pop(), i === t)
            return r;
          i++, r = r.right;
        } else
          n = !0;
      return null;
    }, e.prototype.next = function(t) {
      var r = this._root, n = null;
      if (t.right) {
        for (n = t.right; n.left; )
          n = n.left;
        return n;
      }
      for (var i = this._comparator; r; ) {
        var s = i(t.key, r.key);
        if (s === 0)
          break;
        s < 0 ? (n = r, r = r.left) : r = r.right;
      }
      return n;
    }, e.prototype.prev = function(t) {
      var r = this._root, n = null;
      if (t.left !== null) {
        for (n = t.left; n.right; )
          n = n.right;
        return n;
      }
      for (var i = this._comparator; r; ) {
        var s = i(t.key, r.key);
        if (s === 0)
          break;
        s < 0 ? r = r.left : (n = r, r = r.right);
      }
      return n;
    }, e.prototype.clear = function() {
      return this._root = null, this._size = 0, this;
    }, e.prototype.toList = function() {
      return t3t(this._root);
    }, e.prototype.load = function(t, r, n) {
      r === void 0 && (r = []), n === void 0 && (n = !1);
      var i = t.length, s = this._comparator;
      if (n && q4(t, r, 0, i - 1, s), this._root === null)
        this._root = Q4(t, r, 0, i), this._size = i;
      else {
        var o = e3t(this.toList(), Xwt(t, r), s);
        i = this._size + i, this._root = W4({ head: o }, 0, i);
      }
      return this;
    }, e.prototype.isEmpty = function() {
      return this._root === null;
    }, Object.defineProperty(e.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.toString = function(t) {
      t === void 0 && (t = function(n) {
        return String(n.key);
      });
      var r = [];
      return G4(this._root, "", !0, function(n) {
        return r.push(n);
      }, t), r.join("");
    }, e.prototype.update = function(t, r, n) {
      var i = this._comparator, s = TI(t, this._root, i), o = s.left, a = s.right;
      i(t, r) < 0 ? a = r3(r, n, a, i) : o = r3(r, n, o, i), this._root = Jwt(o, a, i);
    }, e.prototype.split = function(t) {
      return TI(t, this._root, this._comparator);
    }, e.prototype[Symbol.iterator] = function() {
      var t, r, n;
      return Kwt(this, function(i) {
        switch (i.label) {
          case 0:
            t = this._root, r = [], n = !1, i.label = 1;
          case 1:
            return n ? [3, 6] : t === null ? [3, 2] : (r.push(t), t = t.left, [3, 5]);
          case 2:
            return r.length === 0 ? [3, 4] : (t = r.pop(), [4, t]);
          case 3:
            return i.sent(), t = t.right, [3, 5];
          case 4:
            n = !0, i.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    }, e;
  }()
);
function Q4(e, t, r, n) {
  var i = n - r;
  if (i > 0) {
    var s = r + Math.floor(i / 2), o = e[s], a = t[s], l = new ql(o, a);
    return l.left = Q4(e, t, r, s), l.right = Q4(e, t, s + 1, n), l;
  }
  return null;
}
function Xwt(e, t) {
  for (var r = new ql(null, null), n = r, i = 0; i < e.length; i++)
    n = n.next = new ql(e[i], t[i]);
  return n.next = null, r.next;
}
function t3t(e) {
  for (var t = e, r = [], n = !1, i = new ql(null, null), s = i; !n; )
    t ? (r.push(t), t = t.left) : r.length > 0 ? (t = s = s.next = r.pop(), t = t.right) : n = !0;
  return s.next = null, i.next;
}
function W4(e, t, r) {
  var n = r - t;
  if (n > 0) {
    var i = t + Math.floor(n / 2), s = W4(e, t, i), o = e.head;
    return o.left = s, e.head = e.head.next, o.right = W4(e, i + 1, r), o;
  }
  return null;
}
function e3t(e, t, r) {
  for (var n = new ql(null, null), i = n, s = e, o = t; s !== null && o !== null; )
    r(s.key, o.key) < 0 ? (i.next = s, s = s.next) : (i.next = o, o = o.next), i = i.next;
  return s !== null ? i.next = s : o !== null && (i.next = o), n.next;
}
function q4(e, t, r, n, i) {
  if (!(r >= n)) {
    for (var s = e[r + n >> 1], o = r - 1, a = n + 1; ; ) {
      do
        o++;
      while (i(e[o], s) < 0);
      do
        a--;
      while (i(e[a], s) > 0);
      if (o >= a)
        break;
      var l = e[o];
      e[o] = e[a], e[a] = l, l = t[o], t[o] = t[a], t[a] = l;
    }
    q4(e, t, r, a, i), q4(e, t, a + 1, n, i);
  }
}
const aa = 11102230246251565e-32, dn = 134217729, r3t = (3 + 8 * aa) * aa;
function n3(e, t, r, n, i) {
  let s, o, a, l, c = t[0], h = n[0], u = 0, p = 0;
  h > c == h > -c ? (s = c, c = t[++u]) : (s = h, h = n[++p]);
  let y = 0;
  if (u < e && p < r)
    for (h > c == h > -c ? (o = c + s, a = s - (o - c), c = t[++u]) : (o = h + s, a = s - (o - h), h = n[++p]), s = o, a !== 0 && (i[y++] = a); u < e && p < r; )
      h > c == h > -c ? (o = s + c, l = o - s, a = s - (o - l) + (c - l), c = t[++u]) : (o = s + h, l = o - s, a = s - (o - l) + (h - l), h = n[++p]), s = o, a !== 0 && (i[y++] = a);
  for (; u < e; )
    o = s + c, l = o - s, a = s - (o - l) + (c - l), c = t[++u], s = o, a !== 0 && (i[y++] = a);
  for (; p < r; )
    o = s + h, l = o - s, a = s - (o - l) + (h - l), h = n[++p], s = o, a !== 0 && (i[y++] = a);
  return (s !== 0 || y === 0) && (i[y++] = s), y;
}
function n3t(e, t) {
  let r = t[0];
  for (let n = 1; n < e; n++) r += t[n];
  return r;
}
function Dg(e) {
  return new Float64Array(e);
}
const i3t = (3 + 16 * aa) * aa, s3t = (2 + 12 * aa) * aa, o3t = (9 + 64 * aa) * aa * aa, Rh = Dg(4), OI = Dg(8), LI = Dg(12), MI = Dg(16), Ln = Dg(4);
function a3t(e, t, r, n, i, s, o) {
  let a, l, c, h, u, p, y, g, b, f, E, A, x, m, w, _, S, R;
  const O = e - i, $ = r - i, z = t - s, F = n - s;
  m = O * F, p = dn * O, y = p - (p - O), g = O - y, p = dn * F, b = p - (p - F), f = F - b, w = g * f - (m - y * b - g * b - y * f), _ = z * $, p = dn * z, y = p - (p - z), g = z - y, p = dn * $, b = p - (p - $), f = $ - b, S = g * f - (_ - y * b - g * b - y * f), E = w - S, u = w - E, Rh[0] = w - (E + u) + (u - S), A = m + E, u = A - m, x = m - (A - u) + (E - u), E = x - _, u = x - E, Rh[1] = x - (E + u) + (u - _), R = A + E, u = R - A, Rh[2] = A - (R - u) + (E - u), Rh[3] = R;
  let Y = n3t(4, Rh), rt = s3t * o;
  if (Y >= rt || -Y >= rt || (u = e - O, a = e - (O + u) + (u - i), u = r - $, c = r - ($ + u) + (u - i), u = t - z, l = t - (z + u) + (u - s), u = n - F, h = n - (F + u) + (u - s), a === 0 && l === 0 && c === 0 && h === 0) || (rt = o3t * o + r3t * Math.abs(Y), Y += O * h + F * a - (z * c + $ * l), Y >= rt || -Y >= rt)) return Y;
  m = a * F, p = dn * a, y = p - (p - a), g = a - y, p = dn * F, b = p - (p - F), f = F - b, w = g * f - (m - y * b - g * b - y * f), _ = l * $, p = dn * l, y = p - (p - l), g = l - y, p = dn * $, b = p - (p - $), f = $ - b, S = g * f - (_ - y * b - g * b - y * f), E = w - S, u = w - E, Ln[0] = w - (E + u) + (u - S), A = m + E, u = A - m, x = m - (A - u) + (E - u), E = x - _, u = x - E, Ln[1] = x - (E + u) + (u - _), R = A + E, u = R - A, Ln[2] = A - (R - u) + (E - u), Ln[3] = R;
  const at = n3(4, Rh, 4, Ln, OI);
  m = O * h, p = dn * O, y = p - (p - O), g = O - y, p = dn * h, b = p - (p - h), f = h - b, w = g * f - (m - y * b - g * b - y * f), _ = z * c, p = dn * z, y = p - (p - z), g = z - y, p = dn * c, b = p - (p - c), f = c - b, S = g * f - (_ - y * b - g * b - y * f), E = w - S, u = w - E, Ln[0] = w - (E + u) + (u - S), A = m + E, u = A - m, x = m - (A - u) + (E - u), E = x - _, u = x - E, Ln[1] = x - (E + u) + (u - _), R = A + E, u = R - A, Ln[2] = A - (R - u) + (E - u), Ln[3] = R;
  const pt = n3(at, OI, 4, Ln, LI);
  m = a * h, p = dn * a, y = p - (p - a), g = a - y, p = dn * h, b = p - (p - h), f = h - b, w = g * f - (m - y * b - g * b - y * f), _ = l * c, p = dn * l, y = p - (p - l), g = l - y, p = dn * c, b = p - (p - c), f = c - b, S = g * f - (_ - y * b - g * b - y * f), E = w - S, u = w - E, Ln[0] = w - (E + u) + (u - S), A = m + E, u = A - m, x = m - (A - u) + (E - u), E = x - _, u = x - E, Ln[1] = x - (E + u) + (u - _), R = A + E, u = R - A, Ln[2] = A - (R - u) + (E - u), Ln[3] = R;
  const vt = n3(pt, LI, 4, Ln, MI);
  return MI[vt - 1];
}
function l3t(e, t, r, n, i, s) {
  const o = (t - s) * (r - i), a = (e - i) * (n - s), l = o - a, c = Math.abs(o + a);
  return Math.abs(l) >= i3t * c ? l : -a3t(e, t, r, n, i, s, c);
}
const Gd = (e, t) => e.ll.x <= t.x && t.x <= e.ur.x && e.ll.y <= t.y && t.y <= e.ur.y, Y4 = (e, t) => {
  if (t.ur.x < e.ll.x || e.ur.x < t.ll.x || t.ur.y < e.ll.y || e.ur.y < t.ll.y) return null;
  const r = e.ll.x < t.ll.x ? t.ll.x : e.ll.x, n = e.ur.x < t.ur.x ? e.ur.x : t.ur.x, i = e.ll.y < t.ll.y ? t.ll.y : e.ll.y, s = e.ur.y < t.ur.y ? e.ur.y : t.ur.y;
  return {
    ll: {
      x: r,
      y: i
    },
    ur: {
      x: n,
      y: s
    }
  };
};
let ml = Number.EPSILON;
ml === void 0 && (ml = Math.pow(2, -52));
const c3t = ml * ml, NI = (e, t) => {
  if (-ml < e && e < ml && -ml < t && t < ml)
    return 0;
  const r = e - t;
  return r * r < c3t * e * t ? 0 : e < t ? -1 : 1;
};
class u3t {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new DI(), this.yRounder = new DI();
  }
  round(t, r) {
    return {
      x: this.xRounder.round(t),
      y: this.yRounder.round(r)
    };
  }
}
let DI = class {
  constructor() {
    this.tree = new XA(), this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(t) {
    const r = this.tree.add(t), n = this.tree.prev(r);
    if (n !== null && NI(r.key, n.key) === 0)
      return this.tree.remove(t), n.key;
    const i = this.tree.next(r);
    return i !== null && NI(r.key, i.key) === 0 ? (this.tree.remove(t), i.key) : t;
  }
};
const f0 = new u3t(), Z1 = (e, t) => e.x * t.y - e.y * t.x, f$ = (e, t) => e.x * t.x + e.y * t.y, BI = (e, t, r) => {
  const n = l3t(e.x, e.y, t.x, t.y, r.x, r.y);
  return n > 0 ? -1 : n < 0 ? 1 : 0;
}, ky = (e) => Math.sqrt(f$(e, e)), h3t = (e, t, r) => {
  const n = {
    x: t.x - e.x,
    y: t.y - e.y
  }, i = {
    x: r.x - e.x,
    y: r.y - e.y
  };
  return Z1(i, n) / ky(i) / ky(n);
}, p3t = (e, t, r) => {
  const n = {
    x: t.x - e.x,
    y: t.y - e.y
  }, i = {
    x: r.x - e.x,
    y: r.y - e.y
  };
  return f$(i, n) / ky(i) / ky(n);
}, jI = (e, t, r) => t.y === 0 ? null : {
  x: e.x + t.x / t.y * (r - e.y),
  y: r
}, FI = (e, t, r) => t.x === 0 ? null : {
  x: r,
  y: e.y + t.y / t.x * (r - e.x)
}, d3t = (e, t, r, n) => {
  if (t.x === 0) return FI(r, n, e.x);
  if (n.x === 0) return FI(e, t, r.x);
  if (t.y === 0) return jI(r, n, e.y);
  if (n.y === 0) return jI(e, t, r.y);
  const i = Z1(t, n);
  if (i == 0) return null;
  const s = {
    x: r.x - e.x,
    y: r.y - e.y
  }, o = Z1(s, t) / i, a = Z1(s, n) / i, l = e.x + a * t.x, c = r.x + o * n.x, h = e.y + a * t.y, u = r.y + o * n.y, p = (l + c) / 2, y = (h + u) / 2;
  return {
    x: p,
    y
  };
};
let io = class g$ {
  // for ordering sweep events in the sweep event queue
  static compare(t, r) {
    const n = g$.comparePoints(t.point, r.point);
    return n !== 0 ? n : (t.point !== r.point && t.link(r), t.isLeft !== r.isLeft ? t.isLeft ? 1 : -1 : Cy.compare(t.segment, r.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(t, r) {
    return t.x < r.x ? -1 : t.x > r.x ? 1 : t.y < r.y ? -1 : t.y > r.y ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(t, r) {
    t.events === void 0 ? t.events = [this] : t.events.push(this), this.point = t, this.isLeft = r;
  }
  link(t) {
    if (t.point === this.point)
      throw new Error("Tried to link already linked events");
    const r = t.point.events;
    for (let n = 0, i = r.length; n < i; n++) {
      const s = r[n];
      this.point.events.push(s), s.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const t = this.point.events.length;
    for (let r = 0; r < t; r++) {
      const n = this.point.events[r];
      if (n.segment.consumedBy === void 0)
        for (let i = r + 1; i < t; i++) {
          const s = this.point.events[i];
          s.consumedBy === void 0 && n.otherSE.point.events === s.otherSE.point.events && n.segment.consume(s.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const t = [];
    for (let r = 0, n = this.point.events.length; r < n; r++) {
      const i = this.point.events[r];
      i !== this && !i.segment.ringOut && i.segment.isInResult() && t.push(i);
    }
    return t;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(t) {
    const r = /* @__PURE__ */ new Map(), n = (i) => {
      const s = i.otherSE;
      r.set(i, {
        sine: h3t(this.point, t.point, s.point),
        cosine: p3t(this.point, t.point, s.point)
      });
    };
    return (i, s) => {
      r.has(i) || n(i), r.has(s) || n(s);
      const {
        sine: o,
        cosine: a
      } = r.get(i), {
        sine: l,
        cosine: c
      } = r.get(s);
      return o >= 0 && l >= 0 ? a < c ? 1 : a > c ? -1 : 0 : o < 0 && l < 0 ? a < c ? -1 : a > c ? 1 : 0 : l < o ? -1 : l > o ? 1 : 0;
    };
  }
}, f3t = 0, Cy = class J1 {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(t, r) {
    const n = t.leftSE.point.x, i = r.leftSE.point.x, s = t.rightSE.point.x, o = r.rightSE.point.x;
    if (o < n) return 1;
    if (s < i) return -1;
    const a = t.leftSE.point.y, l = r.leftSE.point.y, c = t.rightSE.point.y, h = r.rightSE.point.y;
    if (n < i) {
      if (l < a && l < c) return 1;
      if (l > a && l > c) return -1;
      const u = t.comparePoint(r.leftSE.point);
      if (u < 0) return 1;
      if (u > 0) return -1;
      const p = r.comparePoint(t.rightSE.point);
      return p !== 0 ? p : -1;
    }
    if (n > i) {
      if (a < l && a < h) return -1;
      if (a > l && a > h) return 1;
      const u = r.comparePoint(t.leftSE.point);
      if (u !== 0) return u;
      const p = t.comparePoint(r.rightSE.point);
      return p < 0 ? 1 : p > 0 ? -1 : 1;
    }
    if (a < l) return -1;
    if (a > l) return 1;
    if (s < o) {
      const u = r.comparePoint(t.rightSE.point);
      if (u !== 0) return u;
    }
    if (s > o) {
      const u = t.comparePoint(r.rightSE.point);
      if (u < 0) return 1;
      if (u > 0) return -1;
    }
    if (s !== o) {
      const u = c - a, p = s - n, y = h - l, g = o - i;
      if (u > p && y < g) return 1;
      if (u < p && y > g) return -1;
    }
    return s > o ? 1 : s < o || c < h ? -1 : c > h ? 1 : t.id < r.id ? -1 : t.id > r.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(t, r, n, i) {
    this.id = ++f3t, this.leftSE = t, t.segment = this, t.otherSE = r, this.rightSE = r, r.segment = this, r.otherSE = t, this.rings = n, this.windings = i;
  }
  static fromRing(t, r, n) {
    let i, s, o;
    const a = io.comparePoints(t, r);
    if (a < 0)
      i = t, s = r, o = 1;
    else if (a > 0)
      i = r, s = t, o = -1;
    else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);
    const l = new io(i, !0), c = new io(s, !1);
    return new J1(l, c, [n], [o]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(t) {
    this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const t = this.leftSE.point.y, r = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: t < r ? t : r
      },
      ur: {
        x: this.rightSE.point.x,
        y: t > r ? t : r
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(t) {
    return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(t) {
    if (this.isAnEndpoint(t)) return 0;
    const r = this.leftSE.point, n = this.rightSE.point, i = this.vector();
    if (r.x === n.x)
      return t.x === r.x ? 0 : t.x < r.x ? 1 : -1;
    const s = (t.y - r.y) / i.y, o = r.x + s * i.x;
    if (t.x === o) return 0;
    const a = (t.x - r.x) / i.x, l = r.y + a * i.y;
    return t.y === l ? 0 : t.y < l ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(t) {
    const r = this.bbox(), n = t.bbox(), i = Y4(r, n);
    if (i === null) return null;
    const s = this.leftSE.point, o = this.rightSE.point, a = t.leftSE.point, l = t.rightSE.point, c = Gd(r, a) && this.comparePoint(a) === 0, h = Gd(n, s) && t.comparePoint(s) === 0, u = Gd(r, l) && this.comparePoint(l) === 0, p = Gd(n, o) && t.comparePoint(o) === 0;
    if (h && c)
      return p && !u ? o : !p && u ? l : null;
    if (h)
      return u && s.x === l.x && s.y === l.y ? null : s;
    if (c)
      return p && o.x === a.x && o.y === a.y ? null : a;
    if (p && u) return null;
    if (p) return o;
    if (u) return l;
    const y = d3t(s, this.vector(), a, t.vector());
    return y === null || !Gd(i, y) ? null : f0.round(y.x, y.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(t) {
    const r = [], n = t.events !== void 0, i = new io(t, !0), s = new io(t, !1), o = this.rightSE;
    this.replaceRightSE(s), r.push(s), r.push(i);
    const a = new J1(i, o, this.rings.slice(), this.windings.slice());
    return io.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), io.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), n && (i.checkForConsuming(), s.checkForConsuming()), r;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const t = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let r = 0, n = this.windings.length; r < n; r++)
      this.windings[r] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(t) {
    let r = this, n = t;
    for (; r.consumedBy; ) r = r.consumedBy;
    for (; n.consumedBy; ) n = n.consumedBy;
    const i = J1.compare(r, n);
    if (i !== 0) {
      if (i > 0) {
        const s = r;
        r = n, n = s;
      }
      if (r.prev === n) {
        const s = r;
        r = n, n = s;
      }
      for (let s = 0, o = n.rings.length; s < o; s++) {
        const a = n.rings[s], l = n.windings[s], c = r.rings.indexOf(a);
        c === -1 ? (r.rings.push(a), r.windings.push(l)) : r.windings[c] += l;
      }
      n.rings = null, n.windings = null, n.consumedBy = r, n.leftSE.consumedBy = r.leftSE, n.rightSE.consumedBy = r.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev) this._beforeState = {
      rings: [],
      windings: [],
      multiPolys: []
    };
    else {
      const t = this.prev.consumedBy || this.prev;
      this._beforeState = t.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const t = this.beforeState();
    this._afterState = {
      rings: t.rings.slice(0),
      windings: t.windings.slice(0),
      multiPolys: []
    };
    const r = this._afterState.rings, n = this._afterState.windings, i = this._afterState.multiPolys;
    for (let a = 0, l = this.rings.length; a < l; a++) {
      const c = this.rings[a], h = this.windings[a], u = r.indexOf(c);
      u === -1 ? (r.push(c), n.push(h)) : n[u] += h;
    }
    const s = [], o = [];
    for (let a = 0, l = r.length; a < l; a++) {
      if (n[a] === 0) continue;
      const c = r[a], h = c.poly;
      if (o.indexOf(h) === -1)
        if (c.isExterior) s.push(h);
        else {
          o.indexOf(h) === -1 && o.push(h);
          const u = s.indexOf(c.poly);
          u !== -1 && s.splice(u, 1);
        }
    }
    for (let a = 0, l = s.length; a < l; a++) {
      const c = s[a].multiPoly;
      i.indexOf(c) === -1 && i.push(c);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const t = this.beforeState().multiPolys, r = this.afterState().multiPolys;
    switch (vs.type) {
      case "union": {
        const n = t.length === 0, i = r.length === 0;
        this._isInResult = n !== i;
        break;
      }
      case "intersection": {
        let n, i;
        t.length < r.length ? (n = t.length, i = r.length) : (n = r.length, i = t.length), this._isInResult = i === vs.numMultiPolys && n < i;
        break;
      }
      case "xor": {
        const n = Math.abs(t.length - r.length);
        this._isInResult = n % 2 === 1;
        break;
      }
      case "difference": {
        const n = (i) => i.length === 1 && i[0].isSubject;
        this._isInResult = n(t) !== n(r);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${vs.type}`);
    }
    return this._isInResult;
  }
}, $I = class {
  constructor(t, r, n) {
    if (!Array.isArray(t) || t.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = r, this.isExterior = n, this.segments = [], typeof t[0][0] != "number" || typeof t[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const i = f0.round(t[0][0], t[0][1]);
    this.bbox = {
      ll: {
        x: i.x,
        y: i.y
      },
      ur: {
        x: i.x,
        y: i.y
      }
    };
    let s = i;
    for (let o = 1, a = t.length; o < a; o++) {
      if (typeof t[o][0] != "number" || typeof t[o][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      let l = f0.round(t[o][0], t[o][1]);
      l.x === s.x && l.y === s.y || (this.segments.push(Cy.fromRing(s, l, this)), l.x < this.bbox.ll.x && (this.bbox.ll.x = l.x), l.y < this.bbox.ll.y && (this.bbox.ll.y = l.y), l.x > this.bbox.ur.x && (this.bbox.ur.x = l.x), l.y > this.bbox.ur.y && (this.bbox.ur.y = l.y), s = l);
    }
    (i.x !== s.x || i.y !== s.y) && this.segments.push(Cy.fromRing(s, i, this));
  }
  getSweepEvents() {
    const t = [];
    for (let r = 0, n = this.segments.length; r < n; r++) {
      const i = this.segments[r];
      t.push(i.leftSE), t.push(i.rightSE);
    }
    return t;
  }
};
class g3t {
  constructor(t, r) {
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new $I(t[0], this, !0), this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    }, this.interiorRings = [];
    for (let n = 1, i = t.length; n < i; n++) {
      const s = new $I(t[n], this, !1);
      s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.interiorRings.push(s);
    }
    this.multiPoly = r;
  }
  getSweepEvents() {
    const t = this.exteriorRing.getSweepEvents();
    for (let r = 0, n = this.interiorRings.length; r < n; r++) {
      const i = this.interiorRings[r].getSweepEvents();
      for (let s = 0, o = i.length; s < o; s++)
        t.push(i[s]);
    }
    return t;
  }
}
let zI = class {
  constructor(t, r) {
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof t[0][0][0] == "number" && (t = [t]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let n = 0, i = t.length; n < i; n++) {
      const s = new g3t(t[n], this);
      s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.polys.push(s);
    }
    this.isSubject = r;
  }
  getSweepEvents() {
    const t = [];
    for (let r = 0, n = this.polys.length; r < n; r++) {
      const i = this.polys[r].getSweepEvents();
      for (let s = 0, o = i.length; s < o; s++)
        t.push(i[s]);
    }
    return t;
  }
}, m3t = class K4 {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(t) {
    const r = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      if (!s.isInResult() || s.ringOut) continue;
      let o = null, a = s.leftSE, l = s.rightSE;
      const c = [a], h = a.point, u = [];
      for (; o = a, a = l, c.push(a), a.point !== h; )
        for (; ; ) {
          const p = a.getAvailableLinkedEvents();
          if (p.length === 0) {
            const b = c[0].point, f = c[c.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${b.x}, ${b.y}]. Last matching segment found ends at [${f.x}, ${f.y}].`);
          }
          if (p.length === 1) {
            l = p[0].otherSE;
            break;
          }
          let y = null;
          for (let b = 0, f = u.length; b < f; b++)
            if (u[b].point === a.point) {
              y = b;
              break;
            }
          if (y !== null) {
            const b = u.splice(y)[0], f = c.splice(b.index);
            f.unshift(f[0].otherSE), r.push(new K4(f.reverse()));
            continue;
          }
          u.push({
            index: c.length,
            point: a.point
          });
          const g = a.getLeftmostComparator(o);
          l = p.sort(g)[0].otherSE;
          break;
        }
      r.push(new K4(c));
    }
    return r;
  }
  constructor(t) {
    this.events = t;
    for (let r = 0, n = t.length; r < n; r++)
      t[r].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let t = this.events[0].point;
    const r = [t];
    for (let c = 1, h = this.events.length - 1; c < h; c++) {
      const u = this.events[c].point, p = this.events[c + 1].point;
      BI(u, t, p) !== 0 && (r.push(u), t = u);
    }
    if (r.length === 1) return null;
    const n = r[0], i = r[1];
    BI(n, t, i) === 0 && r.shift(), r.push(r[0]);
    const s = this.isExteriorRing() ? 1 : -1, o = this.isExteriorRing() ? 0 : r.length - 1, a = this.isExteriorRing() ? r.length : -1, l = [];
    for (let c = o; c != a; c += s) l.push([r[c].x, r[c].y]);
    return l;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const t = this.enclosingRing();
      this._isExteriorRing = t ? !t.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let t = this.events[0];
    for (let i = 1, s = this.events.length; i < s; i++) {
      const o = this.events[i];
      io.compare(t, o) > 0 && (t = o);
    }
    let r = t.segment.prevInResult(), n = r ? r.prevInResult() : null;
    for (; ; ) {
      if (!r) return null;
      if (!n) return r.ringOut;
      if (n.ringOut !== r.ringOut)
        return n.ringOut.enclosingRing() !== r.ringOut ? r.ringOut : r.ringOut.enclosingRing();
      r = n.prevInResult(), n = r ? r.prevInResult() : null;
    }
  }
}, VI = class {
  constructor(t) {
    this.exteriorRing = t, t.poly = this, this.interiorRings = [];
  }
  addInterior(t) {
    this.interiorRings.push(t), t.poly = this;
  }
  getGeom() {
    const t = [this.exteriorRing.getGeom()];
    if (t[0] === null) return null;
    for (let r = 0, n = this.interiorRings.length; r < n; r++) {
      const i = this.interiorRings[r].getGeom();
      i !== null && t.push(i);
    }
    return t;
  }
};
class y3t {
  constructor(t) {
    this.rings = t, this.polys = this._composePolys(t);
  }
  getGeom() {
    const t = [];
    for (let r = 0, n = this.polys.length; r < n; r++) {
      const i = this.polys[r].getGeom();
      i !== null && t.push(i);
    }
    return t;
  }
  _composePolys(t) {
    const r = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      if (!s.poly)
        if (s.isExteriorRing()) r.push(new VI(s));
        else {
          const o = s.enclosingRing();
          o.poly || r.push(new VI(o)), o.poly.addInterior(s);
        }
    }
    return r;
  }
}
class b3t {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Cy.compare;
    this.queue = t, this.tree = new XA(r), this.segments = [];
  }
  process(t) {
    const r = t.segment, n = [];
    if (t.consumedBy)
      return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(r), n;
    const i = t.isLeft ? this.tree.add(r) : this.tree.find(r);
    if (!i) throw new Error(`Unable to find segment #${r.id} [${r.leftSE.point.x}, ${r.leftSE.point.y}] -> [${r.rightSE.point.x}, ${r.rightSE.point.y}] in SweepLine tree.`);
    let s = i, o = i, a, l;
    for (; a === void 0; )
      s = this.tree.prev(s), s === null ? a = null : s.key.consumedBy === void 0 && (a = s.key);
    for (; l === void 0; )
      o = this.tree.next(o), o === null ? l = null : o.key.consumedBy === void 0 && (l = o.key);
    if (t.isLeft) {
      let c = null;
      if (a) {
        const u = a.getIntersection(r);
        if (u !== null && (r.isAnEndpoint(u) || (c = u), !a.isAnEndpoint(u))) {
          const p = this._splitSafely(a, u);
          for (let y = 0, g = p.length; y < g; y++)
            n.push(p[y]);
        }
      }
      let h = null;
      if (l) {
        const u = l.getIntersection(r);
        if (u !== null && (r.isAnEndpoint(u) || (h = u), !l.isAnEndpoint(u))) {
          const p = this._splitSafely(l, u);
          for (let y = 0, g = p.length; y < g; y++)
            n.push(p[y]);
        }
      }
      if (c !== null || h !== null) {
        let u = null;
        c === null ? u = h : h === null ? u = c : u = io.comparePoints(c, h) <= 0 ? c : h, this.queue.remove(r.rightSE), n.push(r.rightSE);
        const p = r.split(u);
        for (let y = 0, g = p.length; y < g; y++)
          n.push(p[y]);
      }
      n.length > 0 ? (this.tree.remove(r), n.push(t)) : (this.segments.push(r), r.prev = a);
    } else {
      if (a && l) {
        const c = a.getIntersection(l);
        if (c !== null) {
          if (!a.isAnEndpoint(c)) {
            const h = this._splitSafely(a, c);
            for (let u = 0, p = h.length; u < p; u++)
              n.push(h[u]);
          }
          if (!l.isAnEndpoint(c)) {
            const h = this._splitSafely(l, c);
            for (let u = 0, p = h.length; u < p; u++)
              n.push(h[u]);
          }
        }
      }
      this.tree.remove(r);
    }
    return n;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(t, r) {
    this.tree.remove(t);
    const n = t.rightSE;
    this.queue.remove(n);
    const i = t.split(r);
    return i.push(n), t.consumedBy === void 0 && this.tree.add(t), i;
  }
}
const UI = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, v3t = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
class w3t {
  run(t, r, n) {
    vs.type = t, f0.reset();
    const i = [new zI(r, !0)];
    for (let h = 0, u = n.length; h < u; h++)
      i.push(new zI(n[h], !1));
    if (vs.numMultiPolys = i.length, vs.type === "difference") {
      const h = i[0];
      let u = 1;
      for (; u < i.length; )
        Y4(i[u].bbox, h.bbox) !== null ? u++ : i.splice(u, 1);
    }
    if (vs.type === "intersection")
      for (let h = 0, u = i.length; h < u; h++) {
        const p = i[h];
        for (let y = h + 1, g = i.length; y < g; y++)
          if (Y4(p.bbox, i[y].bbox) === null) return [];
      }
    const s = new XA(io.compare);
    for (let h = 0, u = i.length; h < u; h++) {
      const p = i[h].getSweepEvents();
      for (let y = 0, g = p.length; y < g; y++)
        if (s.insert(p[y]), s.size > UI)
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
    }
    const o = new b3t(s);
    let a = s.size, l = s.pop();
    for (; l; ) {
      const h = l.key;
      if (s.size === a) {
        const p = h.segment;
        throw new Error(`Unable to pop() ${h.isLeft ? "left" : "right"} SweepEvent [${h.point.x}, ${h.point.y}] from segment #${p.id} [${p.leftSE.point.x}, ${p.leftSE.point.y}] -> [${p.rightSE.point.x}, ${p.rightSE.point.y}] from queue.`);
      }
      if (s.size > UI)
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      if (o.segments.length > v3t)
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      const u = o.process(h);
      for (let p = 0, y = u.length; p < y; p++) {
        const g = u[p];
        g.consumedBy === void 0 && s.insert(g);
      }
      a = s.size, l = s.pop();
    }
    f0.reset();
    const c = m3t.factory(o.segments);
    return new y3t(c).getGeom();
  }
}
const vs = new w3t(), x3t = function(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  return vs.run("union", e, r);
}, E3t = function(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  return vs.run("intersection", e, r);
}, A3t = function(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  return vs.run("xor", e, r);
}, S3t = function(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  return vs.run("difference", e, r);
};
var _3t = {
  union: x3t,
  intersection: E3t,
  xor: A3t,
  difference: S3t
};
function HI(e, t, r) {
  const n = e.length;
  if (n == 0)
    throw new Error("Error: Given data has zero length");
  const i = [];
  let s = [], o = [];
  if (r != null) {
    if (n != r.length)
      throw new Error("Error: Given labels do not match length of data");
    o = [...new Set(r.flat())];
    for (let Y = 0; Y < o.length; Y++)
      s.push({ label: o[Y], factor: Y });
    for (let Y = 0; Y < r.length; Y++)
      i.push(o.indexOf(r[Y]));
  }
  const a = 4, l = [];
  for (let Y = 0; Y < n; Y++)
    l.push([Number(e[Y].x), Number(e[Y].y)]);
  const c = [], h = [];
  for (let Y = 0; Y < n; Y++)
    h.push(P3t(l, Y, a));
  for (let Y = 0; Y < n; Y++) {
    let rt = 0;
    for (let at = 0; at < n; at++)
      rt += h[at][Y];
    c.push(rt / n);
  }
  const u = new Ywt(l, 2 * c[a], a, t);
  let p = u.clusters, y = u.clusterCentroids, g = u.noiseAssigned;
  if (r != null) {
    p = [];
    for (let Y = 0; Y < o.length; Y++)
      p.push([]);
    for (let Y = 0; Y < l.length; Y++) {
      let rt = i[Y];
      p[rt].push(Y);
    }
    y = [];
    for (let Y = 0; Y < p.length; Y++) {
      let rt = [];
      for (let at of p[Y])
        rt.push(l[at]);
      y.push(j3t(rt));
    }
    g = [];
  }
  const b = [], f = N3t(y), E = D3t(f), A = [], x = [];
  for (let Y = 0; Y < n; Y++)
    A.push(l[Y][0]), x.push(l[Y][1]);
  const m = Math.max(...x), w = Math.max(...A), _ = Math.min(...x), S = Math.min(...A);
  let R = 0;
  for (let Y of p) {
    const rt = {
      area: 0,
      centroid: [],
      dataPoints: [],
      dataPointIDs: [],
      outlierIDs: [],
      density: 0,
      densityRank: 0,
      hasSignificantHole: !1,
      holes: [],
      hull: [],
      hullIDs: [],
      hullSimplified: [],
      id: 0,
      perimeter: 0,
      region: 0,
      regionDesc: "",
      relations: [{
        angle: 0,
        cardDirection: "",
        distance: 0,
        id: 0,
        isNeighbor: !1
      }],
      shape: { description: "" },
      xMin: 0,
      xMax: 0,
      yMin: 0,
      yMax: 0
    }, at = [];
    for (let X of Y)
      at.push(l[X]);
    r && (rt.label = o[R]), rt.dataPoints = at, rt.dataPointIDs = Y;
    let pt = at[0][0], vt = at[0][0], _t = at[0][1], Ct = at[0][1];
    for (let X of at)
      X[0] < pt && (pt = X[0]), X[0] > vt && (vt = X[0]), X[1] < _t && (_t = X[1]), X[1] > Ct && (Ct = X[1]);
    rt.xMin = pt, rt.xMax = vt, rt.yMin = _t, rt.yMax = Ct, rt.centroid = y[R], rt.id = R, rt.region = f[R], rt.regionDesc = E[R];
    const It = H4(vf(at));
    rt.hull = It;
    for (let X of It) {
      const ot = l.findIndex((mt) => mt[0] == X.x && mt[1] == X.y);
      rt.hullIDs.push(ot);
    }
    const jt = GI(It);
    rt.hullSimplified = jt;
    const lt = X1(It);
    rt.area = lt;
    const L = tS(It);
    rt.perimeter = L;
    const D = F(rt);
    rt.shape = D;
    const tt = Y.length / lt;
    rt.density = tt, rt.relations = [];
    const et = L3t(y, R), st = I3t(y, R);
    for (let X = 0; X < p.length; X++) {
      const ot = co(y[R], y[et[X]]), mt = B3t(y[R], y[et[X]]);
      rt.relations.push({
        id: et[X],
        distance: st[X],
        angle: ot,
        cardDirection: mt
      });
    }
    rt.holes = C3t(rt), rt.holes[0][2] > 0.2 ? rt.hasSignificantHole = !0 : rt.hasSignificantHole = !1, b.push(rt), R++;
  }
  for (let Y of g)
    b[Y[1]].outlierIDs.push(Y[0]);
  const O = JSON.parse(JSON.stringify(b)).sort((Y, rt) => Y.density - rt.density), $ = [];
  for (let Y of O)
    $.push(Y.id);
  for (let Y of b)
    Y.densityRank = $.indexOf(Y.id);
  R = 0;
  const z = 1.2;
  for (let Y of y) {
    let rt = 0;
    for (let at of y) {
      let pt = [];
      if (R == rt)
        b[R].relations[0].isNeighbor = !0, rt++;
      else {
        R < rt && (pt = [...y.slice(0, R), ...y.slice(R + 1)], pt.splice(rt - 1, 1)), R > rt && (pt = [...y.slice(0, rt), ...y.slice(rt + 1)], pt.splice(R - 1, 1));
        const vt = ar(Y, at), _t = [];
        for (let It of pt)
          ar(Y, It) < ar(Y, at) && _t.push(ar(Y, It) + ar(It, at));
        let Ct = {
          angle: 0,
          cardDirection: "",
          distance: 0,
          id: 0,
          isNeighbor: !1
        };
        for (let It of b[R].relations)
          It.id == rt && (Ct = It);
        Math.min(..._t) < z * vt ? b[R].relations[b[R].relations.indexOf(Ct)].isNeighbor = !1 : b[R].relations[b[R].relations.indexOf(Ct)].isNeighbor = !0, rt++;
      }
    }
    R++;
  }
  for (let Y in b) {
    let rt = b[Y];
    for (let at in b) {
      let pt = 0;
      for (let vt in b[Y].relations)
        b[Y].relations[vt].id == Number(at) && (pt = Number(vt));
      if (Y == at)
        b[Y].relations[pt].overlap = 1;
      else {
        let vt = b[at], _t = _3t.intersection([gs(rt.hull)], [gs(vt.hull)]);
        if (_t.length > 0) {
          let Ct = X1(vf(_t[0][0])) / rt.area;
          b[Y].relations[pt].overlap = Ct, b[Y].relations[pt].sharedPts = [];
          for (let It of rt.dataPoints) {
            let jt = 10 ** (Math.log10(Math.max(rt.xMax - rt.xMin, rt.yMax - rt.yMin)) - 4);
            U4(gs(vt.hull), It, jt) < 1 && b[Y].relations[pt].sharedPts.push(It);
          }
          b[Y].relations[pt].percentPtsShared = b[Y].relations[pt].sharedPts.length / b[Y].dataPoints.length;
        } else
          b[Y].relations[pt].overlap = 0;
      }
    }
  }
  function F(Y) {
    const rt = Y.dataPoints, at = H4(vf(rt)), pt = M3t(at);
    if (pt > 0.92)
      return {
        description: "roughly circular",
        radius: Math.sqrt(X1(at) / Math.PI)
      };
    if (pt > 0.7) {
      const vt = gs(GI(at)), _t = vt.length;
      switch (!0) {
        case _t == 3:
          return {
            description: "triangular",
            averageSideLength: (ar(vt[0], vt[1]) + ar(vt[1], vt[2]) + ar(vt[2], vt[0])) / 3
          };
        case _t == 4:
          const Ct = co(vt[0], vt[1]), It = co(vt[1], vt[2]), jt = co(vt[2], vt[3]), lt = co(vt[3], vt[0]), L = It - Ct, D = jt - It, tt = lt - jt, et = Ct - lt;
          if (Math.abs((L + 720) % 360 - 270) < 15 && Math.abs((D + 720) % 360 - 270) < 15 && Math.abs((tt + 720) % 360 - 270) < 15 && Math.abs((et + 720) % 360 - 270) < 15) {
            const J = ar(vt[0], vt[1]), St = ar(vt[1], vt[2]), Rt = ar(vt[2], vt[3]), zt = ar(vt[3], vt[0]), Tt = (J + St + Rt + zt) / 4;
            return Tt * 0.91 < J && J < Tt * 1.1 && Tt * 0.91 < St && St < Tt * 1.1 && Tt * 0.91 < Rt && Rt < Tt * 1.1 && Tt * 0.91 < zt && zt < Tt * 1.1 ? (Ct % 90 + It % 90 + jt % 90 + lt % 90) / 4 > 25 && (Ct % 90 + It % 90 + jt % 90 + lt % 90) / 4 < 65 ? {
              description: "diamond",
              averageSideLength: Tt
            } : {
              description: "square",
              averageSideLength: Tt
            } : { description: "rectangular" };
          } else return Math.abs((L + 720) % 360 - (tt + 720) % 360) < 20 && Math.abs((D + 720) % 360 - (et + 720) % 360) < 20 ? { description: "parallelogram" } : { description: "irregular quadrilateral" };
        case _t == 5:
          return { description: "pentagon" };
        case _t > 5:
          const st = [], X = [];
          for (let J = 0; J < at.length; J++)
            st.push(at[J].x), X.push(at[J].y);
          const ot = QI(st, X)[1], mt = (Math.max(...st) - Math.min(...st)) / (w - S), U = (Math.max(...X) - Math.min(...X)) / (m - _);
          if (mt / U > 2 || U / mt > 2)
            return mt > U ? {
              description: "elliptical: horizontal",
              slope: ot
            } : {
              description: "elliptical: vertical",
              slope: ot
            };
          switch (!0) {
            case ot >= 0.3:
              return {
                description: "elliptical: positively correlated",
                slope: ot
              };
            case ot <= -0.3:
              return {
                description: "elliptical: negatively correlated",
                slope: ot
              };
            case (ot < 0.3 && ot > -0.3 && (Math.max(...st) - Math.min(...st)) / (w - S) > (Math.max(...X) - Math.min(...X)) / (m - _)):
              return {
                description: "elliptical: horizontal",
                slope: ot
              };
            case (ot < 0.3 && ot > -0.3 && (Math.max(...st) - Math.min(...st)) / (w - S) <= (Math.max(...X) - Math.min(...X)) / (m - _)):
              return {
                description: "elliptical: vertical",
                slope: ot
              };
          }
      }
    } else {
      const vt = [], _t = [];
      for (let It = 0; It < at.length; It++)
        vt.push(at[It].x), _t.push(at[It].y);
      const Ct = QI(vt, _t)[1];
      switch (!0) {
        case Ct > 0.3:
          return {
            description: "roughly linear: positively correlated",
            slope: Ct
          };
        case Ct < -0.3:
          return {
            description: "roughly linear: negatively correlated",
            slope: Ct
          };
        case (Ct < 0.3 && Ct > -0.3 && (Math.max(...vt) - Math.min(...vt)) / (w - S) > (Math.max(..._t) - Math.min(..._t)) / (m - _)):
          return {
            description: "roughly linear: horizontal",
            slope: Ct
          };
        case (Ct < 0.3 && Ct > -0.3 && (Math.max(...vt) - Math.min(...vt)) / (w - S) < (Math.max(..._t) - Math.min(..._t)) / (m - _)):
          return {
            description: "roughly linear: vertical",
            slope: Ct
          };
      }
    }
    throw new Error("Something has gone wrong in judgeShape()");
  }
  return b;
}
function GI(e) {
  const t = gs(e), r = 15;
  let n = t.length;
  for (let o = 0; o < n; o++) {
    const a = co(t[o % n], t[(o + 1) % n]), l = co(t[(o + 1) % n], t[(o + 2) % n]) - a;
    (Math.abs(l) < r || Math.abs(l + 360) < r || Math.abs(l - 360) < r) && (t.splice((o + 1) % n, 1), o--, n--);
  }
  const i = 20, s = tS(e);
  for (let o = 0; o < n; o++)
    if (ar(t[(o + 1) % n], t[(o + 2) % n]) < s / i) {
      const a = co(t[o % n], t[(o + 1) % n]), l = co(t[(o + 2) % n], t[(o + 3) % n]) - a;
      if (!(160 < (l + 720) % 360 && (l + 720) % 360 < 200)) {
        const c = m$(t[o % n], t[(o + 1) % n], t[(o + 2) % n], t[(o + 3) % n]);
        t[(o + 1) % n] = c, t.splice((o + 2) % n, 1), o--, n--;
      }
    }
  return vf(t);
}
function m$(e, t, r, n) {
  if (Array.isArray(e) || (e = [e.x, e.y]), Array.isArray(t) || (t = [t.x, t.y]), Array.isArray(r) || (r = [r.x, r.y]), Array.isArray(n) || (n = [n.x, n.y]), t[0] - e[0] == 0) {
    if (n[0] - r[0] == 0)
      throw new Error("Error: attempting to compare parallel lines in completeAngle");
    return [e[0], (n[1] - r[1]) / (n[0] - r[0]) * e[0] + r[1] - (n[1] - r[1]) / (n[0] - r[0]) * r[0]];
  }
  if (n[0] - r[0] == 0)
    return [r[0], (t[1] - e[1]) / (t[0] - e[0]) * r[0] + e[1] - (t[1] - e[1]) / (t[0] - e[0]) * e[0]];
  const i = (t[1] - e[1]) / (t[0] - e[0]), s = (n[1] - r[1]) / (n[0] - r[0]);
  if (i - s == 0)
    throw new Error("Error: attempting to compare parallel lines in completeAngle");
  const o = (e[1] - r[1] - i * e[0] + s * r[0]) / (s - i);
  return [o, i * o + e[1] - i * e[0]];
}
function k3t(e, t, r, n) {
  if (Array.isArray(e) || (e = [e.x, e.y]), Array.isArray(t) || (t = [t.x, t.y]), Array.isArray(r) || (r = [r.x, r.y]), Array.isArray(n) || (n = [n.x, n.y]), t[0] - e[0] == 0)
    return n[0] - r[0] == 0;
  const i = (t[1] - e[1]) / (t[0] - e[0]), s = (n[1] - r[1]) / (n[0] - r[0]);
  return i - s == 0;
}
function QI(e, t) {
  const r = e.length;
  let n = 0, i = 0, s = 0, o = 0;
  for (let l = 0; l < r; l++) {
    const c = e[l], h = t[l];
    n += c, i += h, s += c * h, o += c * c;
  }
  const a = (r * s - n * i) / (r * o - n * n);
  return [i / r - a * (n / r), a];
}
function C3t(e) {
  const t = vf(e.dataPoints), r = new ae(), n = { xl: e.xMin, xr: e.xMax, yt: e.yMin, yb: e.yMax }, i = r.compute(t, n), s = H4(t), o = [], a = [];
  for (let b of i.edges) {
    const f = [b.va.x, b.va.y], E = [b.vb.x, b.vb.y], A = s.length;
    for (let x = 0; x < A; x++)
      if (!k3t(f, E, s[x % A], s[(x + 1) % A])) {
        let m = m$(f, E, s[x % A], s[(x + 1) % A]);
        (m[0] > f[0] && m[0] < E[0] || m[0] < f[0] && m[0] > E[0]) && (m[1] > f[1] && m[1] < E[1] || m[1] < f[1] && m[1] > E[1]) && o.push(m);
      }
  }
  const l = 10 ** (Math.log10(Math.max(e.xMax - e.xMin, e.yMax - e.yMin)) - 4);
  for (let b of gs(i.vertices))
    U4(gs(s), b, l) < 1 && a.push(b);
  for (let b of o)
    U4(gs(s), b, l) < 1 && a.push(b);
  let c = [];
  for (let b in a) {
    let f = a[b], E = [Number(b), ar(f, gs(t)[0])];
    for (let A of gs(t))
      E[1] > ar(f, A) && (E = [Number(b), ar(f, A)]);
    c.push(E);
  }
  let h = c.sort((b, f) => f[1] - b[1]);
  for (let b in h) {
    const f = h[b];
    let E = Number(b) + 1;
    for (; E < h.length; )
      ar(a[f[0]], a[h[E][0]]) < f[1] && (h.splice(E, 1), E--), E++;
  }
  const u = gs(e.hull);
  let p = ar(u[0], e.centroid), y = 0;
  for (let b of u) {
    const f = ar(b, e.centroid);
    p < f && (p = f), y += f / u.length;
  }
  const g = [];
  for (let b = 0; b < h.length; b++) {
    const f = [a[h[b][0]], h[b][1], 0], E = ar(f[0], e.centroid), A = f[1] / y * (1 - E / p);
    f[2] = A, g.push(f);
  }
  return g.sort((b, f) => f[2] - b[2]);
}
function ar(e, t) {
  let r = 0, n = Math.min(e.length, t.length);
  for (; n--; )
    r += (e[n] - t[n]) * (e[n] - t[n]);
  return Math.sqrt(r);
}
function I3t(e, t) {
  const r = [];
  for (let n = 0; n < e.length; n++) {
    const i = ar(e[t], e[n]);
    r.push(i);
  }
  return r.sort((n, i) => n - i), r;
}
function P3t(e, t, r) {
  const n = [];
  for (let i = 0; i < e.length; i++) {
    const s = ar(e[t], e[i]);
    n.push(s);
  }
  return O3t(n, 2 * r);
}
function R3t(e, t, r, n) {
  let i;
  for (typeof r > "u" && (r = 0), typeof n > "u" && (n = e.length); r < n; )
    i = Math.floor((r + n) / 2), t < e[i] ? n = i : r = i + 1;
  return r;
}
function T3t(e, t) {
  e.splice(R3t(e, t), 0, t);
}
function O3t(e, t) {
  let r = [];
  for (let n = 0, i = e.length; n < i; ++n) {
    const s = e[n];
    (r.length < t || s < r[r.length - 1]) && (T3t(r, s), r.length > t && r.splice(t, 1));
  }
  return r;
}
function L3t(e, t) {
  let r = [];
  for (let i = 0; i < e.length; i++) {
    const s = [i, ar(e[t], e[i])];
    r.push(s);
  }
  r = r.sort((i, s) => i[1] - s[1]);
  const n = [];
  for (let i = 0; i < e.length; i++)
    n.push(r[i][0]);
  return n;
}
function X1(e) {
  if (e.length == 0)
    return 0;
  let t = 0;
  const r = e.length;
  for (let n = 0; n < r - 1; n++)
    t += e[n].x * e[n + 1].y - e[n].y * e[n + 1].x;
  return t += e[r - 1].x * e[0].y - e[r - 1].y * e[0].x, Math.abs(t / 2);
}
function tS(e) {
  let t = 0;
  const r = e.length;
  if (r < 2)
    return 0;
  if (r == 2)
    return ar([e[0].x, e[0].y], [e[1].x, e[1].y]);
  for (let n = 0; n < r - 1; n++) {
    let i = [e[n].x, e[n].y], s = [e[n + 1].x, e[n + 1].y];
    t += ar(i, s);
  }
  return t += ar([e[r - 1].x, e[r - 1].y], [e[0].x, e[0].y]), t;
}
function M3t(e) {
  return 2 * Math.sqrt(X1(e) * Math.PI) / tS(e);
}
function N3t(e) {
  const t = [], r = e.length;
  let n = e[0][0], i = e[0][1], s = e[0][0], o = e[0][1];
  for (let u = 0; u < r; u++)
    n < e[u][0] && (n = e[u][0]), s > e[u][0] && (s = e[u][0]), i < e[u][1] && (i = e[u][1]), o > e[u][1] && (o = e[u][1]);
  const a = (n - s) / 3 + s, l = (n - s) * 2 / 3 + s, c = (i - o) / 3 + o, h = (i - o) * 2 / 3 + o;
  for (let u of e) {
    const p = [u[0] < a, u[0] < l, u[1] < c, u[1] < h];
    switch (!0) {
      case JSON.stringify(p) == JSON.stringify([!0, !0, !0, !0]):
        t.push(0);
        break;
      case JSON.stringify(p) == JSON.stringify([!1, !0, !0, !0]):
        t.push(1);
        break;
      case JSON.stringify(p) == JSON.stringify([!1, !1, !0, !0]):
        t.push(2);
        break;
      case JSON.stringify(p) == JSON.stringify([!0, !0, !1, !0]):
        t.push(3);
        break;
      case JSON.stringify(p) == JSON.stringify([!1, !0, !1, !0]):
        t.push(4);
        break;
      case JSON.stringify(p) == JSON.stringify([!1, !1, !1, !0]):
        t.push(5);
        break;
      case JSON.stringify(p) == JSON.stringify([!0, !0, !1, !1]):
        t.push(6);
        break;
      case JSON.stringify(p) == JSON.stringify([!1, !0, !1, !1]):
        t.push(7);
        break;
      case JSON.stringify(p) == JSON.stringify([!1, !1, !1, !1]):
        t.push(8);
    }
  }
  return t;
}
function D3t(e) {
  const t = [], r = e.length;
  for (let n = 0; n < r; n++) {
    const i = e[n];
    switch (!0) {
      case i == 0:
        t.push("bottom left");
        break;
      case i == 1:
        t.push("bottom center");
        break;
      case i == 2:
        t.push("bottom right");
        break;
      case i == 3:
        t.push("left");
        break;
      case i == 4:
        t.push("center");
        break;
      case i == 5:
        t.push("right");
        break;
      case i == 6:
        t.push("top left");
        break;
      case i == 7:
        t.push("top center");
        break;
      case i == 8:
        t.push("top right");
    }
  }
  return t;
}
function co(e, t) {
  const r = t.map((i, s) => i - e[s]);
  let n = 0;
  if (r[0] == 0 && r[1] > 0)
    return 90;
  if (r[0] == 0 && r[1] < 0)
    return 270;
  if (r[1] == 0 && r[0] >= 0)
    return 0;
  if (r[1] == 0 && r[0] < 0)
    return 180;
  switch (!0) {
    case (r[0] > 0 && r[1] > 0):
      n = Math.atan(r[1] / r[0]);
      break;
    case (r[0] < 0 && r[1] > 0):
      n = Math.atan(r[0] / r[1]), n = Math.abs(n) + Math.PI / 2;
      break;
    case (r[0] < 0 && r[1] < 0):
      n = Math.atan(r[1] / r[0]), n = Math.abs(n) + Math.PI;
      break;
    case (r[0] > 0 && r[1] < 0):
      n = Math.atan(r[0] / r[1]), n = Math.abs(n) + 3 * Math.PI / 2;
      break;
  }
  return n = n * 180 / Math.PI, n;
}
function B3t(e, t) {
  const r = co(e, t);
  switch (!0) {
    case (345 < r || r <= 15):
      return "east";
    case (15 < r && r <= 75):
      return "north-east";
    case (75 < r && r <= 105):
      return "north";
    case (105 < r && r <= 165):
      return "north-west";
    case (165 < r && r <= 195):
      return "west";
    case (195 < r && r <= 255):
      return "south-west";
    case (255 < r && r <= 285):
      return "south";
    case (285 < r && r <= 345):
      return "south-east";
  }
  throw new Error("Error: undefined angle in judgeAngle()");
}
function gs(e) {
  if (e.length == 0)
    return [];
  const t = [];
  for (let r = 0; r < e.length; r++)
    t.push([e[r].x, e[r].y]);
  return t;
}
function vf(e) {
  if (e.length == 0)
    return [];
  const t = [];
  for (let r = 0; r < e.length; r++)
    t.push({ x: e[r][0], y: e[r][1] });
  return t;
}
function j3t(e) {
  var t = [0, 0], r = 0, n = 0, i = e.length;
  for (r = 0; r < i; r++)
    for (n = 0; n < e[r].length; n++)
      t[n] !== void 0 || t.push(0), t[n] += e[r][n] / i;
  return t;
}
class F3t extends c$ {
  constructor(t, r) {
    super(t, r), this._currentCluster = -1;
  }
  _init() {
    this._generateClustering(), super._init(), this._axisInfo = new Zb(this._store, {
      xValues: this._store.model.allFacetValues("x").map((t) => t.value),
      yValues: this._store.model.allFacetValues("y").map((t) => t.value)
    });
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "checkbox",
      key: "type.scatter.isDrawTrendLine",
      label: "Trend line",
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "type.scatter.isShowOutliers",
      label: "Show outliers",
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "chart.showPopups",
      label: "Show popups",
      parentView: "controlPanel.tabs.chart.popups"
    });
  }
  get clustering() {
    return this._clustering;
  }
  get currentCluster() {
    return this._currentCluster;
  }
  get _datapointNavNodeType() {
    return "scatterpoint";
  }
  _datapointNavNodeOptions(t) {
    const r = super._datapointNavNodeOptions(t);
    return r.cluster = this._findCluster(t.datapointIndex), r;
  }
  _createNavMap() {
    super._createNavMap(), this._clustering && this._createClusterNavNodes();
  }
  _generateClustering() {
    const t = [], r = this._store.model.series;
    for (const i of r)
      for (let s = 0; s < i.length; s++)
        t.push({ x: Number(i.rawData[s].x), y: Number(i.rawData[s].y) });
    const n = [];
    if (r.length > 1)
      for (const i of r)
        for (let s = 0; s < i.length; s++)
          n.push(i[s].seriesKey);
    this._store.model.numSeries > 1 ? this._clustering = HI(t, !0, n) : this._clustering = HI(t, !1);
  }
  get navDatapointType() {
    return "scatterpoint";
  }
  seriesInNavOrder() {
    return this._store.model.series;
  }
  _createClusterNavNodes() {
    const t = [];
    this._navMap.root.query("series").forEach((n) => {
      t.length && n.connect("left", t.at(-1).at(-1));
      let i = this.clustering;
      this._store.model.numSeries > 1 && (i = i.slice(n.index, n.index + 1));
      const s = n.allNodes("right", "scatterpoint"), o = [];
      i.forEach((a) => {
        const l = new oa(n.layer, "cluster", {
          seriesKey: n.options.seriesKey,
          start: 0,
          //cluster.dataPointIDs[0],
          end: a.dataPointIDs.length - 1,
          //cluster.dataPointIDs[cluster.dataPointIDs.length - 1],
          datapoints: this._store.model.numSeries > 1 ? a.dataPointIDs.map((c) => c - a.dataPointIDs[0]) : [...a.dataPointIDs, ...a.outlierIDs],
          clustering: a
        }, this._store);
        o.push(l);
      }), t.push(o), o.sort((a, l) => a.options.clustering.centroid[0] - l.options.clustering.centroid[0]), o.slice(0, -1).forEach((a, l) => {
        a.connect("right", o[l + 1]);
      }), n.connect("right", o[0]), s[0].disconnect("left", !1), s.at(-1).disconnect("right"), o.forEach((a) => {
        a.connect(
          "in",
          s[0],
          !s[0].getLink("out")
        );
        for (const l of s)
          l.connect("out", a, !1);
        a.peekNode("right", 1) && s.at(-1).connect("in", a.peekNode("right", 1), !1);
      });
    });
    const r = this.navMap.node("top", {});
    t.forEach((n, i) => {
      n.forEach((s, o) => {
        s.connect("out", r, !1);
      });
    }), r.connect("right", t[0][0], !0), t.slice(0, -1).forEach((n, i) => {
      n[n.length - 1].connect("right", t[i + 1][0], !0);
    });
  }
  _findCluster(t) {
    return this._clustering.findIndex((r) => r.dataPointIDs.includes(t));
  }
  async navRunDidEnd(t) {
    this._clustering && (t.isNodeType("cluster") ? this._currentCluster = t.options.clustering.id : t.isNodeType("scatterpoint") ? this._currentCluster = t.options.cluster : t.isNodeType("top") && (this._currentCluster = -1), this._store.paraChart.paraView.requestUpdate(), super.navRunDidEnd(t));
  }
}
class $3t extends YA {
  constructor(t, r) {
    super(t, r);
  }
  _init() {
    this._resolution = this._store.settings.type.heatmap.resolution ?? 20, this._generateHeatmap();
    const t = this._grid.flat();
    this._maxCount = Math.max(...t), this._axisInfo = new Zb(this._store, {
      xValues: this._store.model.allFacetValues("x").map((r) => r.value),
      yValues: this._store.model.allFacetValues("y").map((r) => r.value)
    }), super._init();
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "textfield",
      key: "type.heatmap.resolution",
      label: "Resolution",
      options: {
        inputType: "number",
        min: 5,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.chart"
    });
  }
  get grid() {
    return this._grid;
  }
  get maxCount() {
    return this._maxCount;
  }
  _createPrimaryNavNodes() {
    super._createPrimaryNavNodes(), this._navMap.root.query("series").forEach((t) => {
      t.allNodes("right").slice(0, -this._resolution).forEach((r, n) => {
        r.connect("down", r.layer.get("datapoint", n + this._resolution));
      });
    });
  }
  _createNavLinksBetweenSeries() {
  }
  _createChordNavNodes() {
  }
  _datapointSummary(t) {
    const r = this._grid[t % this._resolution][Math.floor(t / this._resolution)], n = this._axisInfo.xLabelInfo, i = this._axisInfo.yLabelInfo, s = n.range / this._resolution, o = i.range / this._resolution, a = (i.max - o * Math.floor(t / this._resolution)).toFixed(2), l = (i.max - o * (Math.floor(t / this._resolution) + 1)).toFixed(2), c = (n.min + s * (t % this._resolution)).toFixed(2), h = (n.min + s * (t % this._resolution + 1)).toFixed(2);
    return `This block contains ${r} datapoints. It spans x values from ${c} to ${h}, and y values from ${l} to ${a}`;
  }
  async navRunDidEnd(t) {
    t.isNodeType("datapoint") && this._store.announce(this._datapointSummary(t.options.index));
  }
  _generateHeatmap() {
    const t = this._store.model.series;
    this._data = [];
    for (let u of t)
      for (let p = 0; p < u.length; p++)
        this._data.push([u[p].facetValueNumericized("x"), u[p].facetValueNumericized("y")]);
    const r = [], n = [];
    for (const u of this._data)
      n.push(u[0]), r.push(u[1]);
    const i = _y(
      Math.min(...this._store.model.allFacetValues("x").map((u) => u.value)),
      Math.max(...this._store.model.allFacetValues("x").map((u) => u.value)),
      !1
    ), s = _y(
      Math.min(...this._store.model.allFacetValues("y").map((u) => u.value)),
      Math.max(...this._store.model.allFacetValues("y").map((u) => u.value)),
      !1
    );
    let o = s.max, a = i.max, l = s.min, c = i.min;
    a += (a - c) / 10, c -= (a - c) / 10;
    const h = [];
    for (let u = 0; u < this.resolution; u++) {
      h.push([]);
      for (let p = 0; p < this.resolution; p++)
        h[u].push(0);
    }
    for (const u of this._data) {
      const p = Math.floor((u[0] - c) * this.resolution / (a - c)), y = Math.floor((u[1] - l) * this.resolution / (o - l));
      h[p][this.resolution - y - 1]++;
    }
    return this._grid = h, h;
  }
  get resolution() {
    return this._resolution;
  }
  goSeriesMinMax(t) {
  }
  goChartMinMax(t) {
  }
}
const z3t = {
  bar: EI,
  column: EI,
  line: Dwt,
  pie: AI,
  donut: AI,
  scatter: F3t,
  heatmap: $3t
  // histogram: Histogram,
  // gauge: BarChart, //GaugeChart,
  // stepline: LineChart, //StepLineChart,
  // lollipop: BarChart, //LollipopChart
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class Z4 extends C2 {
  constructor(t) {
    if (super(t), this.it = Lt, t.type !== _2.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t) {
    if (t === Lt || t == null) return this._t = void 0, this.it = t;
    if (t === la) return t;
    if (typeof t != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t === this.it) return this._t;
    this.it = t;
    const r = [t];
    return r.raw = r, this._t = { _$litType$: this.constructor.resultType, strings: r, values: [] };
  }
}
Z4.directiveName = "unsafeHTML", Z4.resultType = 1;
const y$ = k2(Z4);
class ei extends Er {
  constructor(t, r) {
    super(t), this.options = r, this._elRef = we(), this._textLines = [], this._canWidthFlex = !0, this._canHeightFlex = !0, r.classList ? (r.classList.includes("label") || r.classList.push("label"), this._classInfo = Object.fromEntries(r.classList.map((n) => [n, !0]))) : this._classInfo = {
      label: !0
    }, this._angle = this.options.angle ?? 0, this._textAnchor = this.options.textAnchor ?? (r.wrapWidth ? "start" : "middle"), this._justify = this.options.justify ?? "start", this._lineSpacing = this.options.lineSpacing ?? 0, this._text = this.options.text, this.updateSize(), this.options.loc && (this._loc = this.options.loc), this.options.x && (this._x = this.options.x), this.options.y && (this._y = this.options.y), this.options.left && (this.left = this.options.left), this.options.right && (this.right = this.options.right), this.options.top && (this.top = this.options.top), this.options.bottom && (this.bottom = this.options.bottom), this.options.centerX && (this.centerX = this.options.centerX), this.options.centerY && (this.centerY = this.options.centerY), this.options.topLeft && (this.topLeft = this.options.topLeft), this.options.topRight && (this.topRight = this.options.topRight), this.options.bottomRight && (this.bottomRight = this.options.bottomRight), this.options.bottomLeft && (this.bottomLeft = this.options.bottomLeft);
  }
  _createId() {
    return this.options.id || Ebt(this._text, this.paraview.store);
  }
  get el() {
    return this._elRef.value;
  }
  get text() {
    return this._text;
  }
  set text(t) {
    this._text = t, this.updateSize(), this.paraview.requestUpdate();
  }
  get angle() {
    return this._angle;
  }
  set angle(t) {
    this._angle = t, this.updateSize();
  }
  get textAnchor() {
    return this._textAnchor;
  }
  set textAnchor(t) {
    this._textAnchor = t, this.updateSize();
  }
  // get bbox() {
  //   return this._elRef.value!.getBBox();
  // }
  get topLeft() {
    return this._loc.add(this._textCornerOffsets.topLeft);
  }
  set topLeft(t) {
    this._loc = t.subtract(this._textCornerOffsets.topLeft);
  }
  get topRight() {
    return this._loc.add(this._textCornerOffsets.topRight);
  }
  set topRight(t) {
    this._loc = t.subtract(this._textCornerOffsets.topRight);
  }
  get bottomRight() {
    return this._loc.add(this._textCornerOffsets.bottomRight);
  }
  set bottomRight(t) {
    this._loc = t.subtract(this._textCornerOffsets.bottomRight);
  }
  get bottomLeft() {
    return this._loc.add(this._textCornerOffsets.bottomLeft);
  }
  set bottomLeft(t) {
    this._loc = t.subtract(this._textCornerOffsets.bottomLeft);
  }
  get textCorners() {
    return {
      topLeft: this.topLeft,
      topRight: this.topRight,
      bottomRight: this.bottomRight,
      bottomLeft: this.bottomLeft
    };
  }
  resize(t, r) {
  }
  computeSize() {
    var b;
    const t = document.createElementNS(Fh, "text");
    this.options.classList && t.classList.add(...this.options.classList), t.setAttribute("text-anchor", this._textAnchor), t.style.visibility = "hidden", this._text ? t.textContent = this._text : t.innerHTML = "&nbsp;", this._angle && t.setAttribute("transform", `rotate(${this._angle})`), this.paraview.root.append(t);
    const r = ((b = this.paraview.root) == null ? void 0 : b.getBoundingClientRect()) ?? new DOMRect(0, 0, 0, 0), n = t.getBoundingClientRect();
    let i = n.width, s = n.height;
    this._locOffset.x = -(n.x - r.x), this._locOffset.y = -(n.y - r.y);
    let o = 0, a = 0, l = 0, c = 0;
    const h = this.options.wrapWidth !== void 0 && i > this.options.wrapWidth;
    if (h || this._text.includes(`
`)) {
      t.textContent = "";
      const f = [document.createElementNS(Fh, "tspan")], E = this._text.split(h ? /(\s+)/ : /(\n+)/);
      for (f.at(-1).textContent = E.shift(), t.append(f.at(-1)); E.length; ) {
        const x = E.shift();
        if (x.includes(`
`)) {
          f.push(document.createElementNS(Fh, "tspan"));
          const _ = f.at(-1);
          t.append(_), _.textContent = x, _.setAttribute("x", "0");
          const S = f.at(-2).getBoundingClientRect();
          _.setAttribute("dy", `${S.height + this._lineSpacing}px`);
          continue;
        }
        if (!x.match(/\w/))
          continue;
        const m = f.at(-1), w = m.textContent;
        if (h) {
          m.textContent += " " + x;
          const _ = this.paraview.store.settings.ui.isFullscreenEnabled ? m.getBBox() : m.getBoundingClientRect();
          _.width >= this.options.wrapWidth && (m.textContent = w, f.push(document.createElementNS(Fh, "tspan")), t.append(f.at(-1)), f.at(-1).textContent = x, f.at(-1).setAttribute("x", "0"), f.at(-1).setAttribute("dy", `${_.height + this._lineSpacing}px`));
        } else {
          m.textContent = x;
          const _ = m.getBoundingClientRect();
          f.length > 1 && (f.at(-1).setAttribute("x", "0"), f.at(-1).setAttribute("dy", `${_.height + this._lineSpacing}px`));
        }
      }
      const A = this.paraview.store.settings.ui.isFullscreenEnabled ? t.getBBox() : t.getBoundingClientRect();
      i = A.width, s = A.height, this._locOffset.x = -(A.x - r.x), this._locOffset.y = -(A.y - r.y), this._textLines = f.map((x) => ({ text: x.textContent, offset: 0 })), this._justify !== "start" && f.forEach((x, m) => {
        const w = x.getBoundingClientRect();
        let _ = i - w.width;
        this._justify === "center" && (_ = _ / 2), this._textLines[m].offset = _;
      }), f.forEach((x) => {
        const m = x.getNumberOfChars();
        for (let w = 0; w < m; w++) {
          const _ = x.getExtentOfChar(w);
          o = Math.min(o, _.y), a = Math.max(a, _.y + _.height), l = Math.min(l, _.x), c = Math.max(c, _.x + _.width);
        }
      }), this._lineHeight = f[0].getExtentOfChar(0).height, f.forEach((x) => x.remove());
    } else {
      this._textLines = [];
      const f = t.getNumberOfChars();
      o = t.getExtentOfChar(0).y, a = t.getExtentOfChar(0).y + t.getExtentOfChar(0).height, l = t.getExtentOfChar(0).x, c = t.getExtentOfChar(f - 1).x + t.getExtentOfChar(f - 1).width, this._lineHeight = t.getExtentOfChar(0).height;
    }
    const u = new qt(l, o).rotate(-this._angle * Math.PI / 180), p = new qt(c, o).rotate(-this._angle * Math.PI / 180), y = new qt(c, a).rotate(-this._angle * Math.PI / 180), g = new qt(l, a).rotate(-this._angle * Math.PI / 180);
    return this._textCornerOffsets = {
      topLeft: u,
      topRight: p,
      bottomRight: y,
      bottomLeft: g
    }, t.remove(), [i, s];
  }
  _makeTransform() {
    let t;
    return this._angle && (t = ee`
        translate(${this._x},${this._y})
        rotate(${this._angle})
        translate(${-this._x},${-this._y})`), t;
  }
  settingDidChange(t, r, n) {
    this.updateSize(), super.settingDidChange(t, r, n);
  }
  render() {
    return Ie`
      ${this.options.hasBackground ? Ie`
          <path
            class="label-bg"
            d="
              M${this.topLeft.x},${this.topLeft.y}
              L${this.topRight.x},${this.topRight.y}
              L${this.bottomRight.x},${this.bottomRight.y}
              L${this.bottomLeft.x},${this.bottomLeft.y}
              Z"
            width=${this._width}
            height=${this._height}
          ></path>
        ` : ""}
      <text
        ${ge(this._elRef)}
        class=${Object.keys(this._classInfo).length ? Rr(this._classInfo) : Lt}
        role=${this.options.role ?? Lt}
        x=${ee`${this._x}`}
        y=${ee`${this._y}`}
        text-anchor=${this._textAnchor !== "start" ? this._textAnchor : Lt}
        transform=${this._makeTransform() ?? Lt}
        id=${this.id}
        style=${Object.keys(this._styleInfo).length ? ln(this._styleInfo) : Lt}
        @pointerenter=${this.options.pointerEnter ?? Lt}
        @pointerleave=${this.options.pointerLeave ?? Lt}
        @click=${this.options.click ?? Lt}
      >
        ${this._textLines.length ? this._textLines.map((t, r) => Ie`
              <tspan
                x=${ee`${this._x + t.offset}`}
                dy=${r === 0 ? "0" : this._lineHeight + this._lineSpacing}
              >
                ${t.text}
              </tspan>
            `) : this._text ? this._text : y$("&nbsp;")}
      </text>
    `;
  }
}
class yd extends Zs(Er) {
  constructor(t, r, n) {
    super(t), this._width = r, this._height = n;
  }
  _createId(t) {
    return `${t}-layer`;
  }
  _addedToParent() {
    this.setSize(this._parent.logicalWidth, this._parent.logicalHeight, !1);
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    super.parent = t;
  }
}
class mo extends Wb {
  constructor(t, r) {
    super(t, r), this._points = r.points.map((n) => n.clone());
  }
  get _options() {
    let t = super._options;
    return t.points = this._points.map((r) => r.clone()), t;
  }
  clone() {
    return new mo(this.paraview, this._options);
  }
  get points() {
    return this._points.map((t) => t.clone());
  }
  set points(t) {
    this._points = t.map((r) => r.clone());
  }
  get xs() {
    return this._points.map((t) => t.x);
  }
  get ys() {
    return this._points.map((t) => t.y);
  }
  get width() {
    return Math.max(...this.xs) - Math.min(...this.xs);
  }
  get height() {
    return Math.max(...this.ys) - Math.min(...this.ys);
  }
  get left() {
    return this._x + Math.min(...this.xs);
  }
  set left(t) {
    this._x += t - this.left;
  }
  get right() {
    return this._x + Math.max(...this.xs);
  }
  set right(t) {
    this._x += t - this.right;
  }
  get top() {
    return this._y + Math.min(...this.ys);
  }
  set top(t) {
    this._y += t - this.top;
  }
  get bottom() {
    return this._y + Math.max(...this.ys);
  }
  set bottom(t) {
    this._y += t - this.bottom;
  }
  get _pathD() {
    const t = this._points.map((n) => n.add(this._loc));
    let r = ee`M${t[0].x},${t[0].y}`;
    return t.slice(1).forEach((n) => {
      r += ee`L${n.x},${n.y}`;
    }), r;
  }
  render() {
    return Ie`
      <path
        ${this._ref ? ge(this._ref) : void 0}
        id=${this._id || Lt}
        style=${Object.keys(this._styleInfo).length ? ln(this._styleInfo) : Lt}
        class=${Object.keys(this._classInfo).length ? Rr(this._classInfo) : Lt}
        role=${this._role || Lt}
        d=${this._pathD}
        clip-path=${this._options.isClip ? "url(#clip-path)" : Lt}
      ></path>
    `;
  }
}
function d1(e) {
  return e * Math.PI / 180;
}
function V3t(e) {
  return e * 180 / Math.PI;
}
function WI(e) {
  return e %= 360, e < 0 ? 360 + e : e;
}
function f1(e, t, r) {
  return e * (1 - r) + t * r;
}
class Iy extends Wb {
  constructor(t, r) {
    super(t, r), this.options = r, this._annularThickness = null, this._arcSweep = 1, this._r = r.r, this._centralAngle = r.centralAngle, this._orientationAngle = r.orientationAngle, this._orientationAngleCounterclockwise = !!r.orientationAngleCounterclockwise, r.annularThickness && (this._annularThickness = r.annularThickness), this._arcCenterIsOrientationAnchor = !!r.arcCenterIsOrientationAnchor, this._orientationAngleOffset = r.orientationAngleOffset ?? 90, r.isPattern && (this._isPattern = r.isPattern), this.computeLayout();
  }
  get _options() {
    let t = super._options;
    return t.r = this._r, t.centralAngle = this._centralAngle, t.orientationAngle = this._orientationAngle, t.orientationAngleCounterclockwise = this._orientationAngleCounterclockwise, this._annularThickness && (t.annularThickness = this._annularThickness), t.arcCenterIsOrientationAnchor = this._arcCenterIsOrientationAnchor, t.orientationAngleOffset = this._orientationAngleOffset, this._isPattern && (t.isPattern = this._isPattern), t;
  }
  clone() {
    return new Iy(this.paraview, this._options);
  }
  get x() {
    return super.x;
  }
  set x(t) {
    super.x = t, this.computeLayout();
  }
  get y() {
    return super.y;
  }
  set y(t) {
    super.y = t, this.computeLayout();
  }
  get loc() {
    return this._loc;
  }
  set loc(t) {
    this._loc = t, this.computeLayout();
  }
  get startX() {
    return this._startX;
  }
  get startY() {
    return this._startY;
  }
  get endX() {
    return this._endX;
  }
  get endY() {
    return this._endY;
  }
  _orientationAngleToPolar(t) {
    return WI((this._orientationAngleCounterclockwise ? t : 360 - t) + this._orientationAngleOffset);
  }
  _polarAngleToOrientation(t) {
    const r = t - this._orientationAngleOffset;
    return WI(this._orientationAngleCounterclockwise ? r : 360 - r);
  }
  /**
   * Convert polar angle to Cartesian vector.
   * @returns Vector with origin at circle center, positive y UP
   */
  _angleToVector(t) {
    return new qt(
      this._r * Math.cos(d1(t)),
      this._r * Math.sin(d1(t))
    );
  }
  /**
   * Convert Cartesian vector to polar angle.
   */
  _vectorToAngle(t) {
    t = t.normalize();
    const r = Math.abs(V3t(Math.asin(t.y)));
    return t.x >= 0 && t.y >= 0 ? r : t.x < 0 && t.y >= 0 ? 180 - r : t.x < 0 && t.y < 0 ? 180 + r : 360 - r;
  }
  get arcCenterAngle() {
    return this._orientationAngleToPolar(this._arcCenterIsOrientationAnchor ? this._orientationAngle : this._orientationAngle + this._centralAngle / 2);
  }
  get arcCenter() {
    return this._angleToVector(this.arcCenterAngle).multiply(new qt(1, -1)).add(this._loc);
  }
  get arcLeftAngle() {
    return this._orientationAngleToPolar(this._arcCenterIsOrientationAnchor ? this._orientationAngle + this._centralAngle / 2 : this._orientationAngle);
  }
  get arcLeft() {
    return this._angleToVector(this.arcLeftAngle).multiply(new qt(1, -1)).add(this._loc);
  }
  get arcRightAngle() {
    return this._orientationAngleToPolar(this._arcCenterIsOrientationAnchor ? this._orientationAngle + this._centralAngle / 2 : this._orientationAngle + this._centralAngle);
  }
  get arcRight() {
    return this._angleToVector(this.arcRightAngle).multiply(new qt(1, -1)).add(this._loc);
  }
  get r() {
    return this._r;
  }
  set r(t) {
    this._r = t, this.computeLayout();
  }
  get centralAngle() {
    return this._centralAngle;
  }
  set centralAngle(t) {
    this._centralAngle = t, this.computeLayout();
  }
  get orientationAngle() {
    return this._orientationAngle;
  }
  set orientationAngle(t) {
    this._orientationAngle = t, this.computeLayout();
  }
  get annularThickness() {
    return this._annularThickness;
  }
  set annularThickness(t) {
    this._annularThickness = t, this.computeLayout();
  }
  get orientationVector() {
    return this.arcCenter.subtract(this._loc).normalize();
  }
  containsPoint(t) {
    const r = t.subtract(this._loc);
    r.y = -r.y;
    const n = this._polarAngleToOrientation(this._vectorToAngle(r)), i = this._polarAngleToOrientation(this.arcLeftAngle), s = this._polarAngleToOrientation(this.arcRightAngle), o = n >= i && n <= (s === 0 ? 360 : s);
    return this._annularThickness === null || this._annularThickness === 1 ? o && r.length() <= this._r : o && r.length() >= this._r - this._annularThickness * this._r;
  }
  computeLayout() {
    const t = d1(this.arcLeftAngle), r = d1(this.arcRightAngle);
    this._startX = this._x + this._r * Math.cos(t), this._startY = this._y - this._r * Math.sin(t), this._endX = this._x + this._r * Math.cos(r), this._endY = this._y - this._r * Math.sin(r), this._arcLarge = this._centralAngle >= 180 ? 1 : 0;
  }
  get _pathD() {
    let t = this._x, r = this.y, n = 0;
    return this._annularThickness !== null && this._annularThickness < 1 && (n = this._r * (1 - this._annularThickness), t = f1(this._x, this._startX, 1 - this._annularThickness), r = f1(this._y, this._startY, 1 - this._annularThickness)), ee`
      M${t},${r}
      L${this._startX},${this._startY}
      A${this._r},${this._r}
        0 ${this._arcLarge} ${this._arcSweep}
        ${this._endX},${this._endY}
      ${this._annularThickness !== null && this._annularThickness < 1 ? ee`
          L${f1(this._endX, this._x, this._annularThickness)},
          ${f1(this._endY, this._y, this._annularThickness)}
          A${n},${n}
            0 ${this._arcLarge} ${1 - this._arcSweep}
            ${t},${r}
        ` : ""}
      Z`;
  }
  render() {
    if (this._options.isPattern) {
      let t = this.parent.index, r = this.parent;
      return this._styleInfo.fill = `url(#Pattern${t})`, this.paraview.store.isVisited(r.seriesKey, t) && (this._styleInfo.stroke = this.paraview.store.colors.colorValue("visit"), this._styleInfo.strokeWidth = 6), Ie`
          <defs>${this.paraview.store.colors.patternValueAt(t)}</defs>
          <path
            d=${this._pathD}
            transform=${this._scale !== 1 ? `translate(${this._x},${this._y})
                    scale(${this._scale})
                    translate(${-this._x},${-this._y})` : Lt}
            fill="white"
            stroke="black"
            stroke-width=4
            clip-path=${this._options.isClip ? "url(#clip-path)" : Lt}
          ></path>
          <path
            ${this._ref ? ge(this._ref) : void 0}
            id=${this._id || Lt}
            style=${Object.keys(this._styleInfo).length ? ln(this._styleInfo) : Lt}
            class=${Object.keys(this._classInfo).length ? Rr(this._classInfo) : Lt}
            role=${this._role || Lt}
            d=${this._pathD}
            transform=${this._scale !== 1 ? `translate(${this._x},${this._y})
                    scale(${this._scale})
                    translate(${-this._x},${-this._y})` : Lt}
            clip-path=${this._options.isClip ? "url(#clip-path)" : Lt}
            @pointerenter=${this.options.pointerEnter ?? Lt}
            @pointerleave=${this.options.pointerLeave ?? Lt}
          ></path>
        `;
    } else
      return Ie`
      <path
        ${this._ref ? ge(this._ref) : void 0}
        id=${this._id || Lt}
        style=${Object.keys(this._styleInfo).length ? ln(this._styleInfo) : Lt}
        class=${Object.keys(this._classInfo).length ? Rr(this._classInfo) : Lt}
        role=${this._role || Lt}
        d=${this._pathD}
        transform=${this._scale !== 1 ? `translate(${this._x},${this._y})
             scale(${this._scale})
             translate(${-this._x},${-this._y})` : Lt}
        clip-path=${this._options.isClip ? "url(#clip-path)" : Lt}
        @pointerenter=${this.options.pointerEnter ?? Lt}
        @pointerleave=${this.options.pointerLeave ?? Lt}
      ></path>
    `;
  }
}
class b$ {
  constructor(t, r, n, i, s) {
    this._pts = [];
    const o = new qt(t, r), a = new qt(n, i);
    for (let l = 0; l < s; l++) {
      const c = l / s, h = c * c, u = h * c;
      this._pts.push(
        o.multiplyScalar(3 * (u - 2 * h + c)).add(
          a.multiplyScalar(3 * (h - u)).add(
            new qt(u, u)
          )
        )
      );
    }
    this._pts.push(new qt(1, 1));
  }
  // copy() {
  //   cdef Bezier c = Bezier.__new__(Bezier)
  //   c.pts = [v.copy() for v in self.pts]
  //   return c
  // }
  eval(t) {
    for (let r = 0; r < this._pts.length - 1; r++)
      if (t <= this._pts[r + 1].x) {
        const n = this._pts[r], i = this._pts[r + 1];
        return n.lerp(i, (t - n.x) / (i.x - n.x)).y;
      }
  }
}
class U3t extends Er {
  constructor(t, r) {
    super(t), r && (this._id = r);
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(t) {
    this._children.forEach((r) => {
      r.x += t - this._x;
    }), super.x = t;
  }
  set y(t) {
    this._children.forEach((r) => {
      r.y += t - this._y;
    }), super.y = t;
  }
  // setSize(width: number, height: number, isBubble = true) {
  //   super.setSize(width, height, isBubble);
  //   this.layoutViews();
  // }
  // constrainSize(maxWidth: number, maxHeight: number, isBubble = false) {
  //   console.log('CONSTRAIN', this.id || this.constructor.name, maxWidth, maxHeight, isBubble);
  //   this.setSize(Math.min(this._width, maxWidth), Math.min(this._height, maxHeight), isBubble);
  //   this._children.forEach(kid => {
  //     kid.constrainSize(this._width, this._height, false);
  //   });
  //   this._adjustToSizeConstraint();
  // }
  // protected _adjustToSizeConstraint() {
  //   this.layoutViews();
  // }
  _didAddChildToList(t) {
    t.isBubbleSizeChange = !0;
  }
  _childDidResize(t) {
    this.updateSize();
  }
  _didAddChild(t) {
  }
  _didRemoveChild(t) {
    this.updateSize();
  }
}
function qI(e) {
  return Math.round(e * 100) / 100;
}
class Fu extends U3t {
  constructor(t, r, n) {
    super(t, n), this._rows = [], this._territories = /* @__PURE__ */ new Map(), this._hRules = [], this._vRules = [], this._canWidthFlex = !!r.canWidthFlex, this._canHeightFlex = !!r.canHeightFlex, this._width = r.width ?? this._width, this._height = r.height ?? this._height, this._isAutoWidth = !!r.isAutoWidth, this._isAutoHeight = !!r.isAutoHeight, this._numCols = r.numCols, this._rowGaps = r.rowGaps !== void 0 ? this._expandRowGaps(r.rowGaps) : [0], this._colGaps = r.colGaps !== void 0 ? this._expandColGaps(r.colGaps) : new Array(this._numCols - 1).fill(0), this._rowAligns = r.rowAligns !== void 0 ? this._expandRowAligns(r.rowAligns) : ["center"], this._colAligns = r.colAligns !== void 0 ? this._expandColAligns(r.colAligns) : new Array(this._numCols).fill("center"), this._rows.push(new Array(this._numCols).fill(null)), this._resetRules();
  }
  get padding() {
    return super.padding;
  }
  set padding(t) {
    super.padding = t, this.layoutViews();
  }
  get numRows() {
    return this._rows.length;
  }
  get numCols() {
    return this._numCols;
  }
  get rowGaps() {
    return Array.from(this._rowGaps);
  }
  get colGaps() {
    return Array.from(this._colGaps);
  }
  get rowAligns() {
    return Array.from(this._rowAligns);
  }
  get colAligns() {
    return Array.from(this._colAligns);
  }
  set numCols(t) {
    this._numCols = t, this._arrangeChildren(), this.layoutViews();
  }
  set rowGaps(t) {
    this._rowGaps = this._expandRowGaps(t), this.setSize(...this.computeSize()), this.layoutViews();
  }
  setRowGap(t, r) {
    if (t >= this._rowGaps.length)
      throw new Error(`row gap index '${t}' out of bounds`);
    const n = this._rowGaps[t];
    this._rowGaps[t] = r;
    const i = t + 1, s = this._hRules.slice(i + 1).map((o) => o - (r - n));
    this._hRules.splice(i + 1, s.length, ...s), this._hRules[i] -= r, this._territories.keys().forEach((o) => {
      this._adjustViewToRules(o);
    }), this.layoutViews();
  }
  _expandRowGaps(t) {
    return typeof t == "object" ? Array.from(t) : [t];
  }
  set colGaps(t) {
    this._colGaps = this._expandColGaps(t), this.setSize(...this.computeSize()), this.layoutViews();
  }
  setColGap(t, r) {
    if (t < 0 || t >= this._colGaps.length)
      throw new Error(`col gap index '${t}' out of bounds`);
    const n = this._colGaps[t];
    this._colGaps[t] = r;
    const i = t + 1, s = this._vRules.slice(i + 1).map((o) => o - (r - n));
    this._vRules.splice(i + 1, s.length, ...s), this._vRules[i] -= r, this._territories.keys().forEach((o) => {
      this._adjustViewToRules(o);
    }), this.layoutViews();
  }
  _expandColGaps(t) {
    return typeof t == "object" ? Array.from(t) : new Array(this._numCols - 1).fill(t);
  }
  set rowAligns(t) {
    this._rowAligns = this._expandRowAligns(t), this.layoutViews();
  }
  _expandRowAligns(t) {
    return typeof t == "object" ? Array.from(t) : [t];
  }
  set colAligns(t) {
    this._colAligns = this._expandColAligns(t), this.layoutViews();
  }
  /** Contents of each cell in the given column. */
  col(t) {
    return this._rows.map((r) => r[t]);
  }
  _expandColAligns(t) {
    return typeof t == "object" ? Array.from(t) : new Array(this._numCols).fill(t);
  }
  // getAvailableSpace(territory: GridTerritory): {width: number, height: number} {
  //   // all cells must be empty
  //   for (let i = territory.x; i < territory.x + territory.width; i++) {
  //     for (let j = territory.y; j < territory.y + territory.height; j++) {
  //       if (this._rows[j][i]) {
  //         throw new Error(`grid row=${j} col=${i} already occupied`);
  //       }
  //     }
  //   }
  // }
  addColumnLeft() {
    this._numCols++, this._colGaps.unshift(0), this._colAligns.unshift("center"), this._rows.forEach((t) => t.unshift(null)), this._territories.values().forEach((t) => {
      t.x++;
    }), this._vRules.unshift(0);
  }
  addColumnRight() {
    this._numCols++, this._colGaps.push(0), this._colAligns.push("center"), this._rows.forEach((t) => t.push(null)), this._vRules.push(this._vRules.at(-1));
  }
  splitColumnRight(t, r = 0, n = "center") {
    const i = this.col(t).filter((s) => {
      if (s) {
        const o = this._territories.get(s);
        return o.x + o.width === t + 1;
      }
      return !1;
    });
    this._territories.values().forEach((s) => {
      s.x > t && s.x++;
    }), this._numCols++, this._colGaps.splice(t, 0, r), this._colAligns.splice(t + 1, 0, n), this._rows.forEach((s) => {
      s.splice(t + 1, 0, null);
    }), this._vRules.splice(t + 1, 0, i.length ? Math.max(...i.map((s) => s.paddedRight)) : this._vRules[t + 1]);
  }
  addRowTop() {
    this._rowGaps.unshift(0), this._rowAligns.unshift("center"), this._rows.unshift(new Array(this._numCols).fill(null)), this._territories.values().forEach((t) => {
      t.y++;
    }), this._hRules.unshift(0);
  }
  addRowBottom() {
    this._rowGaps.push(0), this._rowAligns.push("center"), this._rows.push(new Array(this._numCols).fill(null)), this._hRules.push(this._hRules.at(-1));
  }
  splitRowTop(t, r = "center") {
    const n = this._rows[t].filter((i) => i ? this._territories.get(i).y === t : !1);
    this._territories.values().forEach((i) => {
      i.y >= t && i.y++;
    }), this._rowGaps.splice(t - 1, 0, 0), this._rowAligns.splice(t, 0, r), this._rows.splice(t, 0, this._rows[0].map((i) => null)), this._hRules.splice(t + 1, 0, n.length ? Math.min(...n.map((i) => i.paddedTop)) : this._hRules[t]);
  }
  insertRow(t, r = 0, n = "center") {
    if (this._rowGaps.splice(t, 0, r), this._rowAligns.splice(t, 0, n), this._rows.splice(t, 0, new Array(this._numCols).fill(null)), this._territories.values().forEach((i) => {
      i.y >= t && i.y++;
    }), this._hRules.splice(t, 0, this._hRules[t] ?? this._hRules.at(-1)), r)
      for (let i = t + 2; i < this._hRules.length; i++)
        this._hRules[i] -= r;
  }
  _resetRules() {
    this._hRules = [0, this._isAutoHeight ? 0 : this._height - this._rowGaps.reduce((t, r) => t + r, 0)], this._vRules = new Array(this._numCols).fill(0), this._vRules.push(this._isAutoWidth ? 0 : this._width - this._colGaps.reduce((t, r) => t + r, 0));
  }
  _defaultMargin(t, r) {
    return {
      left: this._colGaps[this._leftGapIndex(t)] ?? 0,
      right: this._colGaps[this._rightGapIndex(t)] ?? 0,
      top: this._rowGaps[this._topGapIndex(r)] ?? 0,
      bottom: this._rowGaps[this._bottomGapIndex(r)] ?? 0
    };
  }
  _createTerritory(t) {
    const r = t.x ?? 0, n = t.y ?? 0;
    return {
      x: r,
      y: n,
      width: t.width ?? 1,
      height: t.height ?? 1,
      rowAlign: t.rowAlign,
      colAlign: t.colAlign
      // margin: input.margin !== undefined
      //   ? this._expandPadding(input.margin, this._defaultMargin(x, y))
      //   : this._defaultMargin(x, y)
    };
  }
  _claimTerritory(t, r) {
    if (this._territories.has(t))
      throw new Error("view already present in grid");
    r && this._territories.set(t, this._createTerritory(r));
  }
  _territoryView(t) {
    return this._territories.keys().find((r) => this._territories.get(r) === t);
  }
  _territoryPhysWidth(t, r = !0) {
    return this._vRuleDist(t.x, t.x + t.width, r);
  }
  _territoryPhysHeight(t, r = !0) {
    return this._hRuleDist(t.y, t.y + t.height, r);
  }
  /** Physical distance between two hRules, possibly inclusive of gaps */
  _hRuleDist(t, r, n = !0) {
    return this._hRules[r] - this._hRules[t] + (n ? this._rowGaps.slice(t, r).reduce((i, s) => i + s, 0) : 0);
  }
  /** Physical distance between two vRules, possibly inclusive of gaps */
  _vRuleDist(t, r, n = !0) {
    return this._vRules[r] - this._vRules[t] + (n ? this._colGaps.slice(t, r).reduce((i, s) => i + s, 0) : 0);
  }
  /**
   * View's unused horizontal space in its territory
   */
  _viewAvailWidth(t) {
    return this._territoryPhysWidth(this._territories.get(t), !1) - t.paddedWidth;
  }
  /**
   * View's unused vertical space in its territory
   */
  _viewAvailHeight(t) {
    return this._territoryPhysHeight(this._territories.get(t), !1) - t.paddedHeight;
  }
  _territoryBbox(t) {
    let r = this.left;
    const n = this._vRules.slice(1).map((p, y) => p - this._vRules[y]), i = this._colGaps;
    for (let p = 0; p < t.x; p++)
      r += n[p] + i[p];
    const s = n.slice(t.x, t.x + t.width).reduce((p, y) => p + y, 0) + i.slice(t.x, t.x + t.width - 1).reduce((p, y) => p + y, 0), o = r + s;
    let a = this.top;
    const l = this._hRules.slice(1).map((p, y) => p - this._hRules[y]), c = this._rowGaps;
    for (let p = 0; p < t.y; p++)
      a += l[p] + c[p];
    const h = l.slice(t.y, t.y + t.height).reduce((p, y) => p + y, 0) + c.slice(t.y, t.y + t.height - 1).reduce((p, y) => p + y, 0), u = a + h;
    return new DOMRect(r, a, o - r, u - a);
  }
  append(t, r) {
    this._claimTerritory(t, r), super.append(t);
  }
  prepend(t, r) {
    this._claimTerritory(t, r), super.prepend(t);
  }
  _didAddChild(t) {
    this._arrangeChild(t), this._adjustRules(t), (this._isAutoWidth || this._isAutoHeight) && this.updateSize(), this.layoutViews(), super._didAddChild(t);
  }
  _didRemoveChild(t) {
    this._rows = this._rows.map((r) => r.map((n) => n === t ? null : n)), this._territories.delete(t), this._contractRules(), super._didRemoveChild(t);
  }
  _firstEmptyCell() {
    for (let t = 0; t < this._rows.length; t++) {
      const r = this._rows[t];
      for (let n = 0; n < r.length; n++)
        if (!r[n])
          return [t, n];
    }
    return [this._rows.length, 0];
  }
  _arrangeChild(t) {
    const r = this._territories.get(t);
    let n = [], i = [];
    if (r)
      r.x < 0 && (r.x = this._numCols + r.x), r.y < 0 && (r.y = this._rows.length + r.y), n = Vo(r.height, (s) => r.y + s), i = Vo(r.width, (s) => r.x + s);
    else {
      const [s, o] = this._firstEmptyCell();
      n = [s], i = [o], this._territories.set(t, {
        x: o,
        y: s,
        width: 1,
        height: 1
        // margin: this._defaultMargin(col, row)
      });
    }
    n.filter((s) => s > this._rows.length - 1).forEach((s) => {
      this._rows.push(Vo(this._numCols, (o) => null)), this._rowGaps.push(0), this._hRules.push(this._hRules.at(-1));
    }), n.forEach(
      (s) => i.forEach((o) => {
        if (this._rows[s][o])
          throw new Error("grid children cannot overlap");
        this._rows[s][o] = t;
      })
    );
  }
  colWidth(t) {
    if (t > this._rows[0].length - 1)
      throw new Error(`col index '${t}' out of bounds`);
    return this._vRuleDist(t, t + 1, !1);
  }
  rowHeight(t) {
    if (t > this._rows.length - 1)
      throw new Error(`row index '${t}' out of bounds`);
    return this._hRuleDist(t, t + 1, !1);
  }
  /** Whether a row can expand vertically. */
  _rowCanGrow(t) {
    return this.rowHeight(t) ? this._rows[t].every((n) => !n || n.canWidthFlex) : !1;
  }
  /**
   * How much a row can shrink vertically;
   * max value is the current row height
   */
  _rowShrinkability(t) {
    const r = this.rowHeight(t);
    if (!r)
      return 0;
    const n = this._rows[t].filter(
      (s) => {
        if (s) {
          const o = this._territories.get(s);
          return o.y === t || o.y + o.height === t + 1;
        }
      }
    );
    if (!n.length)
      return r;
    const i = n.map((s) => s.canHeightFlex ? r : Math.min(r, this._viewAvailHeight(s)));
    return qI(Math.min(...i));
  }
  /** Whether a column can expand horizontally. */
  _columnCanGrow(t) {
    return this.colWidth(t) ? this.col(t).every((n) => !n || n.canWidthFlex) : !1;
  }
  /**
   * How much a column can shrink horizontally;
   * max value is the current column width
   */
  _columnShrinkability(t) {
    const r = this.colWidth(t);
    if (!r)
      return 0;
    const n = this._rows.map((i) => i[t]).filter(
      (i) => {
        if (i) {
          const s = this._territories.get(i);
          return s.x === t || s.x + s.width === t + 1;
        }
      }
    );
    return n.length === 0 ? r : qI(Math.min(...n.map((i) => i.canWidthFlex ? r : Math.min(r, this._viewAvailWidth(i)))));
  }
  // protected _hRuleUpFlexibility(hRule: number): number {
  //   // views that end on hRule
  //   const prevRowViews = this._rows[hRule - 1]
  //     .filter(view => {
  //       if (view) {
  //         const t = this._territories.get(view)!;
  //         return t.y + t.height === hRule;
  //       }
  //     }
  //   ) as View[];
  //   if (prevRowViews.length) {
  //     const canShrink = prevRowViews.filter(view => view.isHeightCanShrink);
  //     const cantShrink = prevRowViews.filter(view => !view.isHeightCanShrink);
  //     if (canShrink.length === 0) {
  //       if (hRule > 1) {
  //         return this._hRuleUpFlexibility(hRule - 1);
  //       } else {
  //         return 0;
  //       }
  //     } else if (cantShrink.length === 0) {
  //       const rowFlex = Math.max(...canShrink.map(view => view.paddedHeight));
  //       if (hRule > 1) {
  //         return rowFlex + this._hRuleUpFlexibility(hRule - 1);
  //       } else {
  //         return rowFlex;
  //       }
  //     } else {
  //       const rowCanFlex = Math.max(...canShrink.map(view => view.paddedHeight));
  //       const rowCantFlex = Math.max(...cantShrink.map(view => view.paddedHeight));
  //       const rowFlex = Math.max(0, rowCanFlex - rowCantFlex);
  //       if (hRule > 1) {
  //         return rowFlex + this._hRuleUpFlexibility(hRule - 1);
  //       } else {
  //         return rowFlex;
  //       }
  //     }
  //   } else if (hRule > 1) {
  //     return this._hRuleUpFlexibility(hRule - 1);
  //   } else {
  //     return 0;
  //   }
  // }
  // canChildResize(kid: View, newWidth: number, newHeight: number): boolean {
  //   const territory = this._territories.get(kid)!;
  //   const hRuleStart = territory.y;
  //   const hRuleEnd = hRuleStart + territory.height;
  //   const vRuleStart = territory.x;
  //   const vRuleEnd = vRuleStart + territory.width;
  //   let rowShrinkage = new Map<number, number>();
  //   let columnShrinkage = new Map<number, number>();
  //   let kidWidthShrink = 0;
  //   let kidHeightShrink = 0;
  //   if (!this._canWidthFlex) {
  //     const territoryPhysWidth = this._territoryPhysWidth(territory);
  //     console.log('TPW', territoryPhysWidth, this._hRules, this._vRules);
  //     const widthDiff = kid.paddedWidth - territoryPhysWidth;
  //     console.log('WIDTH DIFF', widthDiff);
  //     if (widthDiff > 0) {
  //       let otherCols = this._rows[0].map((_, i) => i).filter(i =>
  //         i < territory.x || i >= territory.x + territory.width);
  //       let availShrink = otherCols.map(i => this._columnShrinkability(i));
  //       otherCols = otherCols.filter((_rowIdx, i) => availShrink[i]);
  //       availShrink = availShrink.filter(avail => avail).map(avail => avail);
  //       console.log('AVAIL COL SHRINK', otherCols, availShrink);
  //       // NB: otherCols may be empty
  //       const availShrinkSum = availShrink.reduce((a, b) => a + b, 0);
  //       if (availShrinkSum < widthDiff) {
  //         // we can shrink as much as possible, but kid must be able to shrink
  //         // XXX any view resizing should be queued and performed after all new sizes
  //         // are determined, in case a view needs to resize in both width and height
  //         if (availShrinkSum) {
  //           columnShrinkage = this._apportionShrinkage(
  //             availShrinkSum, availShrinkSum,
  //             availShrink, otherCols);
  //         }
  //         kidWidthShrink = widthDiff - availShrinkSum;
  //         console.log('KIDWIDTHSHRINK', kidWidthShrink, columnShrinkage);
  //       } else {
  //         // apportion space among shrinkable columns
  //         columnShrinkage = this._apportionShrinkage(
  //           widthDiff, availShrinkSum,
  //           availShrink, otherCols);
  //         console.log('COL SHRINK', columnShrinkage);
  //       }
  //     }
  //   } else {
  //     // All territories spanning the previous column that end on vRuleEnd
  //     const prevColTerritories = this._rows
  //       .map(row => row[vRuleEnd - 1])
  //       .filter(view => view)
  //       .map(view => this._territories.get(view!)!)
  //       .filter(t => t.x + t.width === vRuleEnd);
  //     const territoryDiffs = prevColTerritories.map(t => {
  //       const vRuleStart = t.x;
  //       const vRuleEnd = vRuleStart + t.width;
  //       const vDiff = this._vRules[vRuleEnd] - this._vRules[vRuleStart];
  //       const tView = this._rows[t.y][t.x];
  //       return tView!.paddedWidth - vDiff;
  //     });
  //     const vShift = Math.max(...territoryDiffs);
  //     if (vShift) {
  //       this._vRules[vRuleEnd] += vShift;
  //       this._vRules.slice(vRuleEnd + 1).forEach((vRule, i) => {
  //         this._vRules[vRuleEnd + 1 + i] += vShift;
  //       });
  //     }
  //   }
  //   if (!this._canHeightFlex) {
  //     const territoryPhysHeight = this._territoryPhysHeight(territory);
  //     console.log('TPH', territoryPhysHeight, kid.paddedHeight);
  //     const heightDiff = kid.paddedHeight - territoryPhysHeight;
  //     console.log('HEIGHT DIFF', heightDiff);
  //     if (heightDiff > 0) {
  //       let otherRows = this._rows.map((_, i) => i).filter(i =>
  //         i < territory.y || i >= territory.y + territory.height);
  //       console.log('OTHER ROWS', otherRows);
  //       let availShrink = otherRows.map(i => this._rowShrinkability(i));
  //       console.log('AVAIL SHRINK', availShrink);
  //       otherRows = otherRows.filter((_rowIdx, i) => availShrink[i]);
  //       availShrink = availShrink.filter(avail => avail).map(avail => avail);
  //       const availShrinkSum = availShrink.reduce((a, b) => a + b, 0);
  //       if (availShrinkSum < heightDiff) {
  //         if (availShrinkSum) {
  //           rowShrinkage = this._apportionShrinkage(
  //             availShrinkSum, availShrinkSum,
  //             availShrink, otherRows);
  //         }
  //         kidHeightShrink = heightDiff - availShrinkSum;
  //       } else {
  //         rowShrinkage = this._apportionShrinkage(
  //           heightDiff, availShrinkSum,
  //           availShrink, otherRows);
  //         console.log('ROW SHRINK', rowShrinkage);
  //       }
  //     }
  //   } else {
  //     // views in bottom-most row of territory that end on hRuleEnd
  //     const prevRowTerritories = this._rows[hRuleEnd - 1]
  //       .filter(view => view)
  //       .map(view => this._territories.get(view!)!)
  //       .filter(t => t.y + t.height === hRuleEnd);
  //     const rowTerritoryDiffs = prevRowTerritories.map(t => {
  //       const hRuleStart = t.y;
  //       const hRuleEnd = hRuleStart + t.height;
  //       const hDiff = this._hRules[hRuleEnd] - this._hRules[hRuleStart];
  //       const tView = this._rows[t.y][t.x];
  //       // XXX not all views here will necessarily start at hRuleStart!
  //       return tView!.paddedHeight - hDiff;
  //     });
  //     const hShift = Math.max(...rowTerritoryDiffs);
  //     if (hShift) {
  //       this._hRules[hRuleEnd] += hShift;
  //       this._hRules.slice(hRuleEnd + 1).forEach((hRule, i) => {
  //         this._hRules[hRuleEnd + 1 + i] += hShift;
  //       });
  //     }
  //   }
  //   const toResize = new Map<View, {width: number, height: number}>();
  //   if (rowShrinkage.size) {
  //     console.log('ROWS WILL SHRINK');
  //     rowShrinkage.entries().forEach(([idx, shrink]) => {
  //       this._rows[idx].forEach(view => {
  //         if (view) {
  //           toResize.set(view, {width: view.width, height: view.height - shrink});
  //         }
  //       });
  //     });
  //     console.log('TO RESIZE', toResize);
  //     const rowsAbove = new Map(rowShrinkage.entries().filter(([idx, shrink]) =>
  //       idx < territory.y));
  //     const rowsBelow = new Map(rowShrinkage.entries().filter(([idx, shrink]) =>
  //       idx >= territory.y + territory.height));
  //     console.log('ROWS ABOVE', rowsAbove, rowsBelow);
  //     console.log('HRULES BEFORE', [...this._hRules]);
  //     // Move hrules above territory up
  //     rowsAbove.forEach((shrink, idx) => {
  //       this._hRules.splice(idx + 1, rowsAbove.size,
  //         ...this._hRules.slice(idx + 1, idx + 1 + rowsAbove.size).map(hr => hr - shrink));
  //     });
  //     // Move hrules below territory down
  //     rowsBelow.forEach((shrink, idx) => {
  //       this._hRules.splice(idx, rowsBelow.size,
  //         ...this._hRules.slice(idx).map(hr => hr + shrink));
  //     });
  //     console.log('HRULES', this._hRules);
  //   }
  //   if (columnShrinkage.size) {
  //     console.log('COLS WILL SHRINK');
  //     columnShrinkage.entries().forEach(([idx, shrink]) => {
  //       this._rows.map(row => row[idx]).forEach(view => {
  //         if (view) {
  //           toResize.set(view, {width: view.width - shrink, height: view.height});
  //         }
  //       });
  //     });
  //     console.log('TO RESIZE', toResize);
  //     const colsLeft = columnShrinkage.entries().filter(([idx, shrink]) =>
  //       idx < territory.x).toArray();
  //     const colsRight = columnShrinkage.entries().filter(([idx, shrink]) =>
  //       idx >= territory.x + territory.width).toArray().toReversed();
  //     console.log('VRULES BEFORE', [...this._vRules]);
  //     // Move vrules at territory left
  //     colsLeft.forEach(([idx, shrink]) => {
  //       this._vRules.splice(idx + 1, territory.x - (idx + 1),
  //         ...this._vRules.slice(idx + 1, territory.x).map(vr => vr - shrink));
  //     });
  //     // Move vrules at territory right
  //     colsRight.forEach(([idx, shrink]) => {
  //       const start = territory.x + territory.width;
  //       this._vRules.splice(start, idx + 1 - start,
  //         ...this._vRules.slice(start, idx + 1).map(vr => vr + shrink)
  //       );
  //     });
  //     console.log('VRULES', this._vRules);
  //   }
  //   toResize.forEach((newSize, view) => {
  //     // Set the size without notifying the parent of the size change
  //     console.log('RESIZING VIEWS', [...this._hRules]);
  //     // view.constrainSize(newSize.width, newSize.height);
  //     view.setSize(newSize.width, newSize.height, false);
  //     console.log('RESIZING VIEWS COMPLETE', [...this._hRules]);
  //   });
  //   if (kidWidthShrink || kidHeightShrink) {
  //     console.log('KID CONSTRAIN', kid.width - kidWidthShrink, kid.height - kidHeightShrink);
  //     // kid.constrainSize(kid.width - kidWidthShrink, kid.height - kidHeightShrink);
  //     kid.setSize(kid.width - kidWidthShrink, kid.height - kidHeightShrink, false);
  //   }
  //   // XXX Don't forget to resize any other views in the kid's territory's row(s)/col(s),
  //   // if necessary
  // }
  _adjustRules(t) {
    const r = this._territories.get(t), i = r.y + r.height, o = r.x + r.width;
    let a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = 0, h = 0;
    if (this._isAutoWidth) {
      const p = t.paddedWidth - this._territoryPhysWidth(r);
      p > 0 && (this._vRules[o] += p, this._vRules.slice(o + 1).forEach((y, g) => {
        this._vRules[o + 1 + g] += p;
      }));
    } else {
      const p = this._territoryPhysWidth(r, !1), y = t.paddedWidth - p;
      if (y > 0) {
        let g = this._rows[0].map((E, A) => A).filter((E) => E < r.x || E >= r.x + r.width), b = g.map((E) => this._columnShrinkability(E));
        g = g.filter((E, A) => b[A]), b = b.filter((E) => E).map((E) => E);
        const f = b.reduce((E, A) => E + A, 0);
        f < y ? (f && (l = this._apportionShrinkage(
          f,
          f,
          b,
          g
        )), c = y - f) : l = this._apportionShrinkage(
          y,
          f,
          b,
          g
        );
      }
    }
    if (this._isAutoHeight) {
      const y = this._rows[i - 1].filter((b) => b).map((b) => this._territories.get(b)).filter((b) => b.y + b.height === i).map((b) => {
        const f = b.y, E = f + b.height, A = this._hRules[E] - this._hRules[f];
        return this._rows[b.y][b.x].paddedHeight - A;
      }), g = Math.max(...y);
      g && (this._hRules[i] += g, this._hRules.slice(i + 1).forEach((b, f) => {
        this._hRules[i + 1 + f] += g;
      }));
    } else {
      const p = this._territoryPhysHeight(r, !1), y = t.paddedHeight - p;
      if (y > 0) {
        let g = this._rows.map((E, A) => A).filter((E) => E < r.y || E >= r.y + r.height), b = g.map((E) => this._rowShrinkability(E));
        g = g.filter((E, A) => b[A]), b = b.filter((E) => E);
        const f = b.reduce((E, A) => E + A, 0);
        f < y ? (f && (a = this._apportionShrinkage(
          f,
          f,
          b,
          g
        )), h = y - f) : a = this._apportionShrinkage(
          y,
          f,
          b,
          g
        );
      }
    }
    const u = /* @__PURE__ */ new Map();
    if (a.size) {
      a.entries().forEach(([g, b]) => {
        this._rows[g].forEach((f) => {
          f && u.set(f, { width: f.width, height: f.height - b });
        });
      });
      const p = new Map(a.entries().filter(([g, b]) => g < r.y)), y = new Map(a.entries().filter(([g, b]) => g >= r.y + r.height));
      p.forEach((g, b) => {
        this._hRules.splice(
          b + 1,
          p.size,
          ...this._hRules.slice(b + 1, b + 1 + p.size).map((f) => f - g)
        );
      }), y.entries().forEach(([g, b]) => {
        this._hRules[g] += b;
      });
    }
    if (l.size) {
      l.entries().forEach(([g, b]) => {
        this._rows.map((f) => f[g]).forEach((f) => {
          f && u.set(f, { width: f.width - b, height: f.height });
        });
      });
      const p = l.entries().filter(([g, b]) => g < r.x).toArray(), y = l.entries().filter(([g, b]) => g >= r.x + r.width).toArray().toReversed();
      p.forEach(([g, b]) => {
        const f = this._vRules.slice(g + 1, r.x + 1).map((E) => E - b);
        this._vRules.splice(g + 1, f.length, ...f);
      }), y.forEach(([g, b]) => {
        const f = r.x + r.width;
        this._vRules.splice(
          f,
          g + 1 - f,
          ...this._vRules.slice(f, g + 1).map((E) => E + b)
        );
      });
    }
    u.forEach((p, y) => {
      y.resize(p.width, p.height);
    }), (c || h) && t.resize(t.width - c, t.height - h);
  }
  _adjustViewToRules(t) {
    const r = this._territories.get(t);
    let n = 0, i = 0;
    const s = this._territoryPhysWidth(r, !1), o = t.paddedWidth - s;
    o > 0 && (n = o);
    const a = this._territoryPhysHeight(r, !1), l = t.paddedHeight - a;
    l > 0 && (i = l), (n || i) && t.resize(t.width - n, t.height - i);
  }
  /**
   * Apportion shrinkage of rows or columns
   * @param toApportion - Total amount of shrinkage to apportion
   * @param availShrinkSum - Total shrinkage available in rows/columns
   * @param availShrink - Amount of shrinkage available in each row/column
   * @param indices - Row/column indices
   * @returns Map of row/column index to amount of shrinkage
   */
  _apportionShrinkage(t, r, n, i) {
    const s = /* @__PURE__ */ new Map(), o = t / r;
    return i.forEach((a, l) => {
      s.set(a, n[l] * o);
    }), s;
  }
  // protected _apportionColumnShrinkage(
  //   toApportion: number, availShrinkSum: number,
  //   availShrink: number[], cols: number[]
  // ): Map<number, number> {
  //   const shrinkage = new Map<number, number>();
  //   const apportionPct = toApportion/availShrinkSum;
  //   cols.forEach((colIdx, i) => {
  //     shrinkage.set(colIdx, availShrink[i]*apportionPct);
  //   });
  //   return shrinkage;
  // }
  _contractRules() {
    this._rows.forEach((r, n) => {
      if (r.every((i) => i === null)) {
        const i = this._hRules[n + 1] - this._hRules[n];
        this._hRules.splice(
          n + 1,
          this._hRules.length - (n + 1),
          ...this._hRules.slice(n + 1).map((s) => s - i)
        );
      }
    });
    const t = [];
    this._rows.forEach((r, n) => {
      r.forEach((i, s) => {
        t[s] || (t[s] = []), t[s][n] = i;
      });
    }), t.forEach((r, n) => {
      if (r.every((i) => i === null)) {
        const i = this._vRules[n + 1] - this._vRules[n];
        this._vRules.splice(
          n + 1,
          this._vRules.length - (n + 1),
          ...this._vRules.slice(n + 1).map((s) => s - i)
        );
      }
    });
  }
  // protected _computeColGap(index: number) {
  //   if (index < 0 || index > this._colGaps.length - 1) {
  //     return 0;
  //   }
  //   const leftViewMargins = this._rows
  //     .flatMap(row => row.filter((v, i) => v && (i === index)) as View[])
  //     .map(v => this._territories.get(v)!.margin.right);
  //   const rightViewMargins = this._rows
  //     .flatMap(row => row.filter((v, i) => v && (i === index + 1)) as View[])
  //     .map(v => this._territories.get(v)!.margin.left);
  //   const margins = leftViewMargins.concat(rightViewMargins);
  //   return margins.length ? Math.max(...margins) : 0;
  // }
  // protected _computeRowGap(index: number) {
  //   if (index < 0 || index > this._rowGaps.length - 1) {
  //     return 0;
  //   }
  //   const topViewMargins = ((this._rows[index]
  //     ?.filter(v => v) ?? []) as View[])
  //     .map(v => {
  //       return this._territories.get(v)!.margin.bottom;
  //     });
  //   const bottomViewMargins = ((this._rows[index + 1]
  //     ?.filter(v => v) ?? []) as View[])
  //     .map(v => this._territories.get(v)!.margin.top);
  //   const margins = topViewMargins.concat(bottomViewMargins);
  //   return margins.length ? Math.max(...margins) : 0;
  // }
  _leftGapIndex(t) {
    return t - 1;
  }
  _rightGapIndex(t) {
    return t;
  }
  _topGapIndex(t) {
    return t - 1;
  }
  _bottomGapIndex(t) {
    return t;
  }
  // protected _adjustGaps(kid: View) {
  //   const territory = this._territories.get(kid)!;
  //   const leftIndex = this._leftGapIndex(territory.x);
  //   if (leftIndex >= 0) {
  //     this._colGaps[leftIndex] = this._computeColGap(leftIndex);
  //   }
  //   const rightIndex = this._rightGapIndex(territory.x);
  //   if (rightIndex < this._colGaps.length) {
  //     this._colGaps[rightIndex] = this._computeColGap(rightIndex);
  //   }
  //   const topIndex = this._topGapIndex(territory.y);
  //   if (topIndex >= 0) {
  //     this._rowGaps[topIndex] = this._computeRowGap(topIndex);
  //   }
  //   const bottomIndex = this._bottomGapIndex(territory.y);
  //   if (bottomIndex < this._rowGaps.length) {
  //     this._rowGaps[bottomIndex] = this._computeRowGap(bottomIndex);
  //   }
  // }
  // protected _updateGaps() {
  //   for (const index of this._colGaps) {
  //     this._colGaps[index] = this._computeColGap(index);
  //   }
  //   for (const index of this._rowGaps) {
  //     this._rowGaps[index] = this._computeRowGap(index);
  //   }
  // }
  _arrangeChildren() {
    this._rows = [], this._territories.clear(), this._resetRules(), this._children.forEach((t) => {
      this._arrangeChild(t), this._adjustRules(t);
    }), this.setSize(...this.computeSize());
  }
  _childDidResize(t) {
    this._adjustRules(t), super._childDidResize(t);
  }
  computeSize() {
    const t = this._colGaps.reduce((n, i) => n + i, 0), r = this._rowGaps.reduce((n, i) => n + i, 0);
    return [
      this._vRules.at(-1) + t,
      this._hRules.at(-1) + r
    ];
  }
  _adjustToSizeConstraint() {
  }
  resize(t, r) {
    const n = /* @__PURE__ */ new Map();
    if (this._width !== t) {
      const i = Vo(this.numCols, (s) => s);
      if (this._width > t) {
        const s = i.map((a) => this._columnShrinkability(a)), o = this._apportionShrinkage(
          this._width - t,
          s.reduce((a, l) => a + l, 0),
          s,
          i
        );
        i.forEach((a) => {
          this._vRules[a + 1] -= o.get(a), i.slice(a + 1).forEach((l) => {
            this._vRules[l + 1] -= o.get(a);
          });
        }), o.entries().forEach(([a, l]) => {
          this._rows.map((c) => c[a]).forEach((c) => {
            c && l && c.canWidthFlex && n.set(c, { width: c.width - l, height: c.height });
          });
        });
      } else if (this._width < t) {
        const s = i.map((l) => this._columnCanGrow(l)), o = s.reduce((l, c) => (l ? 1 : 0) + (c ? 1 : 0), 0), a = s.map((l) => l ? (t - this._width) / o : 0);
        i.forEach((l) => {
          this._vRules[l + 1] += a[l], i.slice(l + 1).forEach((c) => {
            this._vRules[c + 1] += a[l];
          });
        }), a.forEach((l, c) => {
          this._rows.map((h) => h[c]).forEach((h) => {
            h && l && n.set(h, { width: h.width + l, height: h.height });
          });
        });
      }
      this._width = t;
    }
    if (this._height > r) {
      const i = Vo(this.numRows, (a) => a), s = i.map((a) => this._rowShrinkability(a)), o = this._apportionShrinkage(
        this._height - r,
        s.reduce((a, l) => a + l, 0),
        s,
        i
      );
      i.forEach((a) => {
        this._hRules[a + 1] -= o.get(a), i.slice(a + 1).forEach((l) => {
          this._hRules[l + 1] -= o.get(a);
        });
      }), o.entries().forEach(([a, l]) => {
        this._rows[a].forEach((c) => {
          c && l && c.canHeightFlex && n.set(c, { width: c.width, height: c.height - l });
        });
      }), this._height = r;
    } else if (this._height < r) {
      const i = Vo(this.numRows, (l) => l), s = i.map((l) => this._rowCanGrow(l)), o = s.reduce((l, c) => (l ? 1 : 0) + (c ? 1 : 0), 0), a = s.map((l) => l ? (r - this._height) / o : 0);
      i.forEach((l) => {
        this._hRules[l + 1] += a[l], i.slice(l + 1).forEach((c) => {
          this._hRules[c + 1] += a[l];
        });
      }), a.forEach((l, c) => {
        this._rows[c].forEach((h) => {
          h && l && n.set(h, { width: h.width, height: h.height + l });
        });
      }), this._height = r;
    }
    n.forEach((i, s) => {
      s instanceof ei || s.resize(i.width, i.height);
    }), this.layoutViews();
  }
  layoutViews() {
    this._children.forEach((t, r) => {
      this._snapChildX(t), this._snapChildY(t);
    });
  }
  _snapChildX(t) {
    const r = this._territories.get(t);
    let n = this.left;
    const i = this._vRules.slice(1).map((l, c) => l - this._vRules[c]), s = this._colGaps;
    for (let l = 0; l < r.x; l++)
      n += i[l] + s[l];
    const o = r.colAlign ?? this._colAligns[r.x], a = i.slice(r.x, r.x + r.width).reduce((l, c) => l + c, 0) + s.slice(r.x, r.x + r.width - 1).reduce((l, c) => l + c, 0);
    o === "start" ? t.left = n : o === "end" ? t.right = n + a : t.centerX = n + a / 2;
  }
  _snapChildY(t) {
    const r = this._territories.get(t);
    let n = this.top;
    const i = this._hRules.slice(1).map((l, c) => l - this._hRules[c]), s = this._rowGaps;
    for (let l = 0; l < r.y; l++)
      n += i[l] + s[l];
    const o = r.rowAlign ?? this._rowAligns[r.y], a = i.slice(r.y, r.y + r.height).reduce((l, c) => l + c, 0) + s.slice(r.y, r.y + r.height - 1).reduce((l, c) => l + c, 0);
    o === "start" ? t.paddedTop = n : o === "end" ? t.paddedBottom = n + a : t.centerY = n + a / 2;
  }
  content(...t) {
    const r = this._territories.values().map((n) => {
      const i = this._territoryBbox(n), s = new qr(this.paraview, {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      });
      return s.classInfo = { "debug-grid-territory": !0 }, s;
    });
    return Ie`
      ${super.content()}
      ${this.paraview.store.settings.dev.isShowGridTerritories ? r.map((n) => n.render()) : ""}
    `;
  }
}
var H3t = Object.defineProperty, G3t = Object.getOwnPropertyDescriptor, v$ = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? G3t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && H3t(t, r, i), i;
};
const Ga = 10, YI = 15, Q3t = 6;
class Il extends Er {
  constructor(t, r, n) {
    super(t), this.popupLabelOptions = r, this.popupShapeOptions = n, this.leftPadding = this.paraview.store.settings.popup.leftPadding, this.rightPadding = this.paraview.store.settings.popup.rightPadding, this.downPadding = this.paraview.store.settings.popup.downPadding, this.upPadding = this.paraview.store.settings.popup.upPadding, this.horizShift = 0, this.arrowPosition = "bottom", this._wrapWidth = this.paraview.store.settings.popup.maxWidth, this.applyDefaults(), this._label = new ei(this.paraview, this.popupLabelOptions), this.paraview.store.settings.popup.backgroundColor === "dark" && (this._label.styleInfo = {
      stroke: "none",
      fill: this.popupLabelOptions.type == "chord" ? "black" : this.paraview.store.colors.contrastValueAt(this.popupLabelOptions.color)
    }), this.paraview.store.settings.ui.isLowVisionModeEnabled && (this._label.styleInfo = {
      stroke: "none",
      fill: "black"
    }), this._grid = this.generateGrid(), this.shiftGrid(), this.append(this._grid), this._box = this.generateBox(n), this.append(this._box);
    const i = parseFloat(this.paraview.documentView.chartLayers.width.toFixed(5));
    if (this.popupLabelOptions.type === "sequence") {
      const s = this.popupLabelOptions.points;
      s.map((o) => o.shapes.map((a) => a.intersects(this.box))).flat().some(Boolean) && (i - s[s.length - 1].x > this.grid.width ? (this.arrowPosition = "left", this.grid.x = s[s.length - 1].x + this.leftPadding + Ga) : s[0].x > this.grid.width && (this.arrowPosition = "right", this.grid.x = s[0].x - this.grid.width - this.leftPadding - Ga), this._children.pop(), this._box = this.generateBox(n), this.append(this._box));
    }
    this._children.unshift(this._box), this._children.pop(), r.id && (this.id = r.id);
  }
  get grid() {
    return this._grid;
  }
  get label() {
    return this._label;
  }
  get box() {
    return this._box;
  }
  get margin() {
    return this.popupLabelOptions.margin ?? this.paraview.store.settings.popup.margin;
  }
  get wrapWidth() {
    return this._wrapWidth;
  }
  set wrapWidth(t) {
    this._wrapWidth = t;
  }
  get text() {
    return this.popupLabelOptions.text;
  }
  applyDefaults() {
    this.popupLabelOptions.color || (this.popupLabelOptions.color = 0), this.popupLabelOptions.wrapWidth || (this.popupLabelOptions.wrapWidth = this.wrapWidth), this.popupLabelOptions.y && (this.popupLabelOptions.y -= this.margin), this.popupShapeOptions.fill || (this.popupShapeOptions.fill = this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(this.popupLabelOptions.color), 6) : this.paraview.store.colors.colorValueAt(this.popupLabelOptions.color)), this.popupShapeOptions.stroke || (this.popupShapeOptions.stroke = this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(this.popupLabelOptions.color) : "black"), this.paraview.store.settings.ui.isLowVisionModeEnabled || (this.popupShapeOptions.fill = `${this.popupShapeOptions.fill.slice(0, -1)}, ${this.paraview.store.settings.popup.opacity})`), this.popupShapeOptions.shape || (this.popupShapeOptions.shape = this.paraview.store.settings.popup.shape);
  }
  shiftGrid() {
    var r, n;
    const t = parseFloat(this.paraview.documentView.chartLayers.width.toFixed(5));
    this.grid.right + this.rightPadding > t && (this.popupLabelOptions.type === "chord" ? (this.arrowPosition = "right", this.grid.x += -(this.grid.width + 2 * Ga + this.rightPadding + this.leftPadding)) : (this.horizShift = this.grid.right + this.rightPadding - t, this.grid.x -= this.horizShift)), this.grid.left - this.leftPadding < 0 && (this.horizShift = -(this.leftPadding - this.grid.left), this.grid.x -= this.horizShift), this.grid.y - this.grid.bottom < 0 && this.popupLabelOptions.type !== "chord" && (this.grid.y += this.grid.y - this.grid.bottom), this.grid.top - this.upPadding < 0 && (this.popupLabelOptions.type !== "chord" ? (this.arrowPosition = "up", this.grid.y += 2 * this.margin + this.grid.height) : this.grid.height > ((r = this.paraview.documentView) == null ? void 0 : r.chartLayers.dataLayer.height) && this.wrapWidth + 50 < ((n = this.paraview.documentView) == null ? void 0 : n.chartLayers.dataLayer.width) && (this.wrapWidth += 50, this.generateGrid(), this.shiftGrid()));
  }
  generateGrid() {
    if (this.popupLabelOptions.type === "chord") {
      let t = [];
      this.leftPadding += 10, this.arrowPosition = "left";
      let r = [];
      for (let n = 0; n < this.popupLabelOptions.items.length - 1; n++)
        r.push(Q3t);
      this._grid = new Fu(this.paraview, {
        numCols: 2,
        colGaps: [15],
        rowGaps: r,
        colAligns: ["center", "start"],
        isAutoWidth: !0,
        isAutoHeight: !0
      }, "popup-grid"), this.popupLabelOptions.items.forEach((n, i) => {
        t.push(ya.fromType(
          this.paraview,
          this.paraview.store.settings.chart.isDrawSymbols ? n.symbol ?? "square.solid" : "square.solid",
          {
            color: n.color
          }
        ));
        const o = this.popupLabelOptions.text.split(/\r?\n|\r/);
        t.push(new ei(this.paraview, {
          text: o[i],
          x: 0,
          y: 0,
          wrapWidth: this.wrapWidth,
          textAnchor: "start"
        }));
      }), t.forEach((n) => this._grid.append(n)), this._grid.y = this.paraview.documentView.chartLayers.height / 2 - this._grid.height / 2, this._grid.x = this.popupLabelOptions.x + Ga + this.leftPadding + this.horizShift;
    } else {
      let t = [];
      this._grid = new Fu(this.paraview, {
        numCols: 1,
        colAligns: ["start"],
        isAutoWidth: !0,
        isAutoHeight: !0
      }, "popup-grid"), t.push(this._label), t.forEach((r) => this._grid.append(r)), this._grid.y = this.popupLabelOptions.y, this._grid.x = this.popupLabelOptions.x - this._grid.width / 2;
    }
    return this._grid;
  }
  generateBox(t) {
    const r = t.shape ?? "box", n = this._grid, i = n.bottom, s = n.x, o = n.width, a = n.height, l = this.leftPadding, c = this.rightPadding, h = this.upPadding, u = this.downPadding, p = this.horizShift;
    return r === "boxWithArrow" ? this.arrowPosition == "bottom" ? new Qd(this.paraview, {
      points: [
        new qt(s - l, i - a - h),
        new qt(s - l, i + u),
        new qt(Math.max(s + o / 2 - Math.min(o / 2, YI) + p, s - l), i + u),
        //This is manually correcting for what I'm pretty sure are floating-point errors
        new qt(Math.abs(s + o / 2 + p - (s + o + c)) < 0.5 ? s + o + c : Math.abs(s + o / 2 + p - (s - l)) < 0.5 ? s - l : s + o / 2 + p, i + u + Ga),
        new qt(Math.min(s + o / 2 + Math.min(o / 2, YI) + p, s + o + c), i + u),
        new qt(s + o + c, i + u),
        new qt(s + o + c, i - a - h),
        new qt(s - l, i - a - h)
      ],
      fill: t.fill,
      stroke: t.stroke,
      shape: "boxWithArrow",
      arrowPosition: "down"
    }) : this.arrowPosition == "right" ? new Qd(this.paraview, {
      points: [
        new qt(s - l, i - a - h),
        new qt(s - l, i + u),
        new qt(s + o + c, i + u),
        new qt(s + o + c, i - a / 2 + Math.min(a / 4, 15)),
        new qt(s + o + c + Ga, i - a / 2),
        new qt(s + o + c, i - a / 2 - Math.min(a / 4, 15)),
        new qt(s + o + c, i - a - h),
        new qt(s - l, i - a - h)
      ],
      fill: t.fill,
      stroke: t.stroke,
      shape: "boxWithArrow",
      arrowPosition: "right"
    }) : this.arrowPosition == "left" ? new Qd(this.paraview, {
      points: [
        new qt(s - l, i - a - h),
        new qt(s - l, i - a / 2 - Math.min(a / 4, 15)),
        new qt(s - l - Ga, i - a / 2),
        new qt(s - l, i - a / 2 + Math.min(a / 4, 15)),
        new qt(s - l, i + u),
        new qt(s + o + c, i + u),
        new qt(s + o + c, i - a - h),
        new qt(s - l, i - a - h)
      ],
      fill: t.fill,
      stroke: t.stroke,
      shape: "boxWithArrow",
      arrowPosition: "left"
    }) : new Qd(this.paraview, {
      points: [
        new qt(s - l, i - a - h),
        new qt(s - l, i + u),
        new qt(s + o + c, i + u),
        new qt(s + o + c, i - a - h),
        new qt(Math.min(s + o / 2 + Math.min(o / 4, 15) + p, s + o + c), i - a - h),
        //This is manually correcting for what I'm pretty sure are floating-point errors
        new qt(Math.abs(s + o / 2 + p - (s + o + c)) < 0.5 ? s + o + c : Math.abs(s + o / 2 + p - (s - l)) < 0.5 ? s - l : s + o / 2 + p, i - a - h - Ga),
        new qt(Math.max(s + o / 2 + -Math.min(o / 4, 15) + p, s - l), i - a - h),
        new qt(s - l, i - a - h)
      ],
      fill: t.fill,
      stroke: t.stroke,
      shape: "boxWithArrow",
      arrowPosition: "up"
    }) : new Qd(this.paraview, {
      points: [
        new qt(s - l, i - a - h),
        new qt(s - l, i + u),
        new qt(s + o + c, i + u),
        new qt(s + o + c, i - a - h),
        new qt(s - l, i - a - h)
      ],
      fill: t.fill,
      stroke: t.stroke,
      shape: "box"
    });
  }
}
let Py = class extends ka(zi) {
  constructor() {
    super(...arguments), this._dialogRef = we(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "dropdown",
      key: "popup.shape",
      label: "Shape",
      options: { options: ["box", "boxWithArrow"] },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: "popup.activation",
      label: "Activate popups on",
      options: { options: ["onHover", "onFocus", "onSelect"] },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "slider",
      key: "popup.opacity",
      label: "Opacity",
      options: {
        min: 0,
        max: 1,
        //highBound: this._store.settings.sonification.hertzUpper - 1,
        step: 0.1
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.maxWidth",
      label: "Max width",
      options: {
        inputType: "number",
        min: 0,
        max: 300
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.leftPadding",
      label: "Left padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.rightPadding",
      label: "Right padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.upPadding",
      label: "Up padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.downPadding",
      label: "Down padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.margin",
      label: "Vertical margin",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.borderRadius",
      label: "Border radius",
      options: {
        inputType: "number",
        min: 0,
        max: 20
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: "popup.backgroundColor",
      label: "Color mode",
      options: {
        options: ["dark", "light"]
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    });
  }
  render() {
    return Ht`
      <fizz-dialog
        ${ge(this._dialogRef)}
        title="Popup Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        <div id="controls">
          <div id="popup-settings"
            class="popup-views"
          >
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.dialog.popups")}
          </div>
        </div>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show();
  }
};
Py.styles = Te`
    #controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  `;
v$([
  Qt()
], Py.prototype, "btnText", 2);
Py = v$([
  Oe("para-popup-settings-dialog")
], Py);
class Qd extends mo {
  constructor(t, r) {
    super(t, r), this.options = r, this.curvePoints = {
      boxWithArrow: [1, 1, 0, 0, 0, 1, 1, 1],
      boxWithDownArrow: [1, 1, 0, 0, 0, 1, 1, 1],
      boxWithUpArrow: [1, 1, 1, 1, 0, 0, 0, 1],
      boxWithRightArrow: [1, 1, 1, 0, 0, 0, 1, 1],
      boxWithLeftArrow: [1, 0, 0, 0, 1, 1, 1, 1],
      box: [1, 1, 1, 1, 1]
    }, this._points = r.points.map((n) => n.clone()), this.shape = this.options.shape;
  }
  get _pathD() {
    const t = this.paraview.store.settings.popup.borderRadius;
    let r;
    this.shape == "boxWithArrow" && this.options.arrowPosition === "up" ? r = this.curvePoints.boxWithUpArrow : this.shape == "boxWithArrow" && this.options.arrowPosition === "down" ? r = this.curvePoints.boxWithDownArrow : this.shape == "boxWithArrow" && this.options.arrowPosition === "right" ? r = this.curvePoints.boxWithRightArrow : this.shape == "boxWithArrow" && this.options.arrowPosition === "left" ? r = this.curvePoints.boxWithLeftArrow : r = this.curvePoints[this.shape];
    const n = this._points.map((o) => o.add(this._loc));
    let i = ee``, s = n.length;
    if (!r[0] || Math.abs(n[0].x - n[s - 2].x) < t / 2 && Math.abs(n[0].y - n[s - 2].y) < t / 2)
      i += ee`M${n[0].x},${n[0].y}`;
    else {
      let o = n[0], a = n[1 % s];
      const l = Math.sign(o.x - a.x), c = Math.sign(o.y - a.y);
      i += ee`M${o.x - l * t},${o.y - c * t}`;
    }
    for (let o = 1; o < s; o++) {
      let a = n[o % s], l = n[(o - 1 + s) % s], c = n[(o + 1 + (o === s - 1 ? 1 : 0)) % s];
      if (!r[o % s] || Math.abs(a.x - l.x) < t / 2 && Math.abs(a.y - l.y) < t / 2 || Math.abs(a.x - c.x) < t / 2 && Math.abs(a.y - c.y) < t / 2 && o !== s - 1)
        i += ee`L${a.x},${a.y}`;
      else {
        const h = Math.sign(a.x - l.x), u = Math.sign(a.y - l.y), p = Math.sign(c.x - a.x), y = Math.sign(c.y - a.y);
        i += ee`L${a.x - h * t},${a.y - u * t}`, i += ee`A ${t}, ${t}, 0, 0, 0, ${a.x + p * t}, ${a.y + y * t}`;
      }
    }
    return i;
  }
}
class KI extends yd {
  constructor(t, r, n, i) {
    super(t, r, n), this.type = i, this._groups = /* @__PURE__ */ new Map();
  }
  _createId() {
    return super._createId(`${this.type}-annotation`);
  }
  group(t) {
    return this._groups.get(t);
  }
  addGroup(t, r = !1) {
    if (this._groups.has(t)) {
      if (r)
        return;
      throw new Error(`group '${t}' already exists`);
    }
    this._groups.set(t, new W3t(this.paraview, t)), this.append(this._groups.get(t));
  }
  removeGroup(t, r = !1) {
    if (this._groups.has(t))
      this._groups.delete(t);
    else {
      if (r)
        return;
      throw new Error(`group '${t}' does not exist`);
    }
  }
  renderChildren() {
    var t;
    if (this.type === "foreground") {
      if (this.paraview.store.modelTrendLines) {
        this.addGroup("trend-lines", !0), this.group("trend-lines").clearChildren();
        for (const r of this.paraview.store.modelTrendLines) {
          const n = this.paraview.store.model.series.filter((y) => y[0].seriesKey == r.seriesKey)[0], i = this.parent.docView.chartInfo.getYAxisInterval(), s = i.start ?? Number(this.paraview.store.settings.axis.y.minValue), o = i.end ?? Number(this.paraview.store.settings.axis.y.maxValue), a = this.height - (n.datapoints[r.startIndex].facetValueNumericized("y") - s) / (o - s) * this.height, l = this.height - (n.datapoints[r.endIndex - 1].facetValueNumericized("y") - s) / (o - s) * this.height, c = this.width * r.startPortion, h = this.width * r.endPortion, u = this.paraview.store.colors.colorValue("visit"), p = new mo(this.paraview, {
            x: this._x,
            y: this._y,
            points: [new qt(c, a), new qt(h, l)],
            fill: u,
            stroke: u
          });
          p.classInfo = { "trend-line": !0 }, this.group("trend-lines").append(p);
        }
      } else
        this._groups.has("trend-lines") && this.removeGroup("trend-lines", !0);
      if (this.paraview.store.userTrendLines) {
        this.addGroup("user-trend-lines", !0), this.group("user-trend-lines").clearChildren();
        let r = structuredClone(this.paraview.store.userTrendLines);
        if (this.paraview.store.visitedDatapoints.size > 0) {
          const n = Zr(this.paraview.store.visitedDatapoints.values().toArray()[0]);
          r = r.filter((i) => i.seriesKey == n.seriesKey);
        }
        for (const n of r) {
          const i = this.paraview.store.model.series.filter((g) => g[0].seriesKey == n.seriesKey)[0], s = this.parent.docView.chartInfo.getYAxisInterval(), o = s.start ?? Number(this.paraview.store.settings.axis.y.minValue), a = s.end ?? Number(this.paraview.store.settings.axis.y.maxValue), l = this.height - (i.datapoints[n.startIndex].facetValueNumericized("y") - o) / (a - o) * this.height, c = this.height - (i.datapoints[n.endIndex - 1].facetValueNumericized("y") - o) / (a - o) * this.height, h = this.width * n.startPortion, u = this.width * n.endPortion, p = this.paraview.store.colors.colorValue("highlight"), y = new mo(this.paraview, {
            x: this._x,
            y: this._y,
            points: [new qt(h, l), new qt(u, c)],
            fill: p,
            stroke: p
          });
          y.classInfo = { "user-trend-line": !0 }, this.group("user-trend-lines").append(y);
        }
      } else
        this._groups.has("user-trend-lines") && this.removeGroup("user-trend-lines", !0);
      if (this.paraview.store.annotations) {
        this.addGroup("annotation-popups", !0), this.group("annotation-popups").clearChildren();
        let r = structuredClone(this.paraview.store.annotations.filter((n) => n.type == "datapoint" && n.isSelected == !0));
        for (const n of r) {
          const i = this.paraview.store.model.series.filter((a) => a[0].seriesKey == n.seriesKey)[0].key, s = (t = this.paraview.documentView) == null ? void 0 : t.chartLayers.dataLayer.datapointViews.filter((a) => a.seriesKey == i && a.index == n.index)[0];
          if (!s)
            break;
          let o = new Il(
            this.paraview,
            {
              text: n.text,
              x: s.x,
              y: s.y,
              textAnchor: "middle",
              classList: ["annotationlabel"],
              id: this.id,
              color: s.color,
              points: [s]
            },
            {
              fill: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(s.color), 6) : this.paraview.store.colors.colorValueAt(s.color),
              stroke: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(s.color) : "black"
            }
          );
          o.classInfo = { popup: !0 }, this.group("annotation-popups").append(o);
        }
      } else
        this._groups.has("annotation-popups") && this.removeGroup("annotation-popups", !0);
    }
    if (this.type === "background") {
      if (this.paraview.store.rangeHighlights) {
        this.addGroup("range-highlights", !0), this.group("range-highlights").clearChildren();
        for (const r of this.paraview.store.rangeHighlights) {
          const n = this.width * r.startPortion, i = this.width * r.endPortion, s = new qr(this.paraview, {
            x: n,
            y: 0,
            width: i - n,
            height: this.height
          });
          s.classInfo = { "range-highlight": !0 }, this.group("range-highlights").append(s);
        }
      } else
        this._groups.has("range-highlights") && this.removeGroup("range-highlights", !0);
      if (this.paraview.store.modelLineBreaks) {
        this.addGroup("linebreaker-markers", !0), this.group("linebreaker-markers").clearChildren();
        for (const r of this.paraview.store.modelLineBreaks) {
          const n = this.width * r.startPortion, i = new qr(this.paraview, {
            x: n - 1.5,
            y: 0,
            width: 3,
            height: this.height
          });
          i.classInfo = { "linebreaker-marker": !0 }, this.group("linebreaker-markers").append(i);
        }
      } else
        this._groups.has("linebreaker-markers") && this.removeGroup("linebreaker-markers", !0);
      if (this.paraview.store.userLineBreaks) {
        this.addGroup("user-linebreaker-markers", !0), this.group("user-linebreaker-markers").clearChildren();
        let r = structuredClone(this.paraview.store.userLineBreaks);
        if (this.paraview.store.visitedDatapoints.size > 0) {
          const n = Zr(this.paraview.store.visitedDatapoints.values().toArray()[0]);
          r = r.filter((i) => i.seriesKey == n.seriesKey);
        }
        for (const n of r) {
          const i = this.paraview.store.model.series.findIndex((l) => l.key == n.seriesKey), s = this.paraview.store.colors.colorValueAt(i), o = this.width * n.startPortion, a = new qr(this.paraview, {
            x: o - 1.5,
            y: 0,
            width: 3,
            height: this.height,
            fill: s
          });
          a.classInfo = { "user-linebreaker-marker": !0 }, this.group("user-linebreaker-markers").append(a);
        }
      } else
        this._groups.has("user-linebreaks") && this.removeGroup("userlinebreaks", !0);
    }
    return super.renderChildren();
  }
}
let W3t = class extends Zs(Er) {
  constructor(t, r) {
    super(t), this._name = r;
  }
  get name() {
    return this._name;
  }
};
class w$ extends yd {
  constructor(t, r, n, i, s) {
    super(t, r, n), this.dataLayerIndex = i, this._chartInfo = s, this._datapointDomIds = /* @__PURE__ */ new Map(), this._currentAnimationFrame = null, this._animateRevealComplete = !1;
  }
  _createId() {
    return super._createId("data");
  }
  _addedToParent() {
    super._addedToParent(), this._chartLandingView = new Cbt(this.paraview), this.append(this._chartLandingView);
  }
  get managedSettingKeys() {
    return [`type.${this._parent.docView.type}`];
  }
  get settings() {
    return dr.getGroupLink(this.managedSettingKeys[0], this.paraview.store.settings);
  }
  get chartInfo() {
    return this._chartInfo;
  }
  resize(t, r) {
    super.resize(t, r), this._layoutDatapoints();
  }
  // get sonifier() {
  //   return this._sonifier;
  // }
  get chartLandingView() {
    return this._chartLandingView;
  }
  get datapointViews() {
    return this._chartLandingView.datapointViews;
  }
  get visitedDatapointViews() {
    return this.datapointViews.filter(
      (t) => this.paraview.store.isVisited(t.seriesKey, t.index)
    );
  }
  get selectedDatapointViews() {
    return this.datapointViews.filter(
      (t) => this.paraview.store.isSelected(t.seriesKey, t.index)
    );
  }
  registerDatapoint(t) {
    const r = `${t.seriesKey}-${t.index}`;
    this._datapointDomIds.set(r, t.id);
  }
  unregisterDatapoint(t) {
    this._datapointDomIds.delete(`${t.seriesKey}-${t.index}`);
  }
  get datapointDomIds() {
    return this._datapointDomIds;
  }
  get dataset() {
    return this.paraview.ref(`dataset${this.index}`).value;
  }
  get role() {
    return "dataset";
  }
  get ref() {
    return ge(this.paraview.ref(`dataset${this.index}`));
  }
  get animateRevealComplete() {
    return this._animateRevealComplete;
  }
  init() {
    this._layoutDatapoints(), this.paraview.store.settings.animation.isAnimationEnabled && this._animateReveal();
  }
  settingDidChange(t, r, n) {
    ["ui.isLowVisionModeEnabled"].includes(t) && (r || this.paraview.store.updateSettings((i) => {
      i.popup.activation = "onSelect";
    })), ["popup.activation"].includes(t) && (r === "onSelect" || r === "onFocus") && (this.paraview.store.popups.splice(0, this.paraview.store.popups.length), this.paraview.store.userLineBreaks.splice(0, this.paraview.store.userLineBreaks.length)), ["chart.showPopups"].includes(t) && this.paraview.store.popups.splice(0, this.paraview.store.popups.length), super.settingDidChange(t, r, n);
  }
  /**
   * Stroke width for visited datapoints. Can be overridden.
   */
  get visitedStrokeWidth() {
    const t = this.paraview.store.settings.chart.strokeHighlightScale;
    return this.paraview.store.settings.chart.strokeWidth * t;
  }
  /**
   * Mutate `styleInfo` with any custom series styles.
   * @param styleInfo
   */
  updateSeriesStyle(t) {
  }
  _beginDatapointLayout() {
    this._createDatapoints();
    for (const t of this.datapointViews)
      t.computeLocation();
  }
  _completeDatapointLayout() {
    for (const t of this.datapointViews)
      t.completeLayout();
  }
  _layoutDatapoints() {
    this._chartLandingView.clearChildren(), this._beginDatapointLayout(), this.paraview.store.settings.animation.isAnimationEnabled && this.paraview.store.settings.animation.symbolPopIn && this.datapointViews.map((t) => t.baseSymbolScale = 0), this._completeDatapointLayout();
  }
  // protected _layoutComponents() {
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.computeLocation();
  //   }
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.completeLayout();
  //   }
  //   //this._layoutSymbols();
  // }
  _animateReveal() {
    let t = -1;
    const r = new b$(0.2, 0.9, 0.5, 1, 10), n = (o) => {
      t === -1 && (t = o);
      const a = o - t, l = Math.max(1, this.paraview.store.settings.animation.animateRevealTimeMs), c = Math.min(a / l, 1), h = r.eval(c);
      this._animStep(h), this.paraview.paraChart.postNotice("animRevealStep", h), this.paraview.requestUpdate(), a < l ? this._currentAnimationFrame = requestAnimationFrame(n) : this._animEnd();
    };
    this._currentAnimationFrame = requestAnimationFrame(n);
    const i = Date.now(), s = () => {
      let o = setTimeout(() => {
        this.paraview.requestUpdate(), s();
      }, 50);
      Date.now() - i > this.paraview.store.settings.animation.popInAnimateRevealTimeMs + this.paraview.store.settings.animation.animateRevealTimeMs && clearTimeout(o);
    };
    s();
  }
  _animStep(t) {
    this.paraview.store.settings.animation.lineSnake && (this.paraview.clipWidth = t * this.paraview.documentView.chartLayers.width);
    for (const r of this.datapointViews)
      r.beginAnimStep(t);
    for (const r of this.datapointViews)
      r.endAnimStep(t);
  }
  _animEnd() {
    this.paraview.paraChart.postNotice("animRevealEnd", null), this._currentAnimationFrame = null, this._animateRevealComplete = !0;
  }
  stopAnimation() {
    this._currentAnimationFrame !== null && (cancelAnimationFrame(this._currentAnimationFrame), this._animStep(1), this.paraview.paraChart.postNotice("animRevealStep", 1), this.paraview.requestUpdate(), this._animEnd());
  }
  _newDatapointView(t, ...r) {
    return new md(t);
  }
  _newSeriesView(t, r, ...n) {
    return new QA(this, t, r);
  }
  datapointView(t, r) {
    return this.datapointViews.find((n) => n.seriesKey === t && n.index === r);
  }
  datapointViewForId(t) {
    return this.datapointViews.find((r) => r.id === t);
  }
  // protected _layoutSymbols() {
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.layoutSymbol();
  //   }
  // }
  focusRingBbox() {
    const r = this._parent.docView.chartInfo.navMap.cursor;
    return ["series", "chord", "datapoint", "sequence"].includes(r.type) ? D4(...r.datapoints.map((n) => this.datapointView(n.seriesKey, n.datapointIndex).outerBbox)) : null;
  }
  handlePan(t, r, n, i) {
  }
  handleZoom(t, r) {
  }
}
class Jb extends w$ {
  constructor(t, r, n, i, s) {
    super(t, r, n, i, s);
  }
  get datapointViews() {
    return super.datapointViews;
  }
  get visitedDatapointViews() {
    return super.visitedDatapointViews;
  }
  get selectedDatapointViews() {
    return super.selectedDatapointViews;
  }
  /*
  protected get _eventActions(): Actions<this> {
    return {
      ...super._eventActions,
      // User attempted to move past series endpoint in chord mode
      series_endpoint_reached: function() {
        todo().controller.announce('On final point.');
      },
      // User attempted to move past endpoint of final series
      final_series_endpoint_reached: function() {
        todo().controller.appendAnnouncement('Press the up arrow to go to the previous series, or the left arrow to go to the previous point in this series');
        todo().controller.announce('On final point of final series.');
      },
      // User attempted to move up from first series
      first_series_reached: function() {
        todo().controller.appendAnnouncement('Press the down arrow to go to the next series, or the left or right arrow to explore this series');
        todo().controller.announce('On first series.');
      },
      // User attempted to move down from final series
      final_series_reached: function() {
        todo().controller.appendAnnouncement('Press the up arrow to go to the previous series, or the left or right arrow to explore this series');
        todo().controller.announce('On final series.');
      },
      // User attempted to move up or down while on the root nav point
      no_series: function() {
        todo().controller.announce('No series selected.');
      },
      chord_mode_no_up_down: function() {
        todo().controller.announce('Cannot switch series in chord mode.');
      },
    };
  }*/
  /*compareDatapoints(datapoint1: XYDatapointView, datapoint2: XYDatapointView) :
      {
        comparator: string,
        diff: number
      }
    {
      // TODO: localize this text output
      // TODO: move this to some statistical / NLP module
      const value1 = datapoint1.datapoint.y;
      const value2 = datapoint2.datapoint.y;
      const result = value1.compare(value2);
      let comparator = '';
      if (result.relationship === 'equal') {
        comparator = 'equal to';
      } else {
        comparator = (result.relationship === 'greater') ? 'greater than' : 'less than';
      }
      return {
        comparator,
        diff: result.diff!
      };
    }
  
    capitalize(string: string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }*/
}
class Xb extends QA {
  get children() {
    return super.children;
  }
  get siblings() {
    return super.siblings;
  }
}
class x$ extends md {
  constructor(t) {
    super(t);
  }
  _addedToParent() {
    super._addedToParent();
  }
  // override to get more specific return type
  get datapoint() {
    return super.datapoint;
  }
  // get styleInfo() {
  //   const styles = super.styleInfo;
  //   styles['--datapoint-centroid'] = this.centroid;
  //   return styles;
  // }
  /*protected get _eventActions(): Actions<this> {
    return {
      datapoint_focused: function(focusInfo: FocusInfo) {
        todo().controller.announce(this.summary(focusInfo));
      },
      datapoint_selected: function(selectionInfo: XYSelectionInfo) {
        todo().controller.announce(this.chart.composeDatapointSelectionAnnouncement(selectionInfo));
      },
    };
  }*/
  //abstract computeLayout(): void;
  /*summary(focusInfo: FocusInfo) {
    if (focusInfo.visited.length > 1) {
      return `${this.datapoint.formatX('statusBar')}, all points`;
    } else {
      // Don't include the series name unless the previously-visited point
      // was in a different series
      const datapoint = this.datapoint.format('statusBar');
      /*if (!focusInfo.isSeriesChange) {
        return datapoint;
      } else if (todo().seriesSummaries[focusInfo.visited[0].series.name!]) {
        return `${todo().controller.todo.seriesSummaries[focusInfo.visited[0].series.name!]} ${datapoint}`;
      } else {
        return `${focusInfo.visited[0].series.name!}: ${datapoint}`;
      }*/
  //  }
  //}
  async onFocus(t = !1) {
    await super.onFocus(t);
  }
}
class E$ extends Jb {
  settingDidChange(t, r, n) {
    ["axis.y.maxValue", "axis.y.minValue"].includes(t) && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(t, r, n);
  }
  async storeDidChange(t, r) {
    await super.storeDidChange(t, r), t === "frontSeries" && this._raiseSeries(r);
  }
  get datapointViews() {
    return super.datapointViews;
  }
  _newSeriesView(t) {
    return new q3t(this, t);
  }
  _newDatapointView(t) {
    return new eS(t);
  }
  _createDatapoints() {
    const t = [];
    for (const [r, n] of Nn(this.paraview.store.model.series[0].datapoints))
      t.push(jr(r.facetBox("x"), this.paraview.store.getFormatType(`${this.parent.docView.type}Point`))), Cr(t.at(-1));
    for (const [r, n] of Nn(this.paraview.store.model.series)) {
      const i = this._newSeriesView(r.key);
      this._chartLandingView.append(i);
      for (const [s, o] of Nn(r)) {
        const a = this._newDatapointView(i);
        i.append(a);
      }
    }
    this._chartLandingView.sortChildren((r, n) => n.children[0].datapoint.facetValueNumericized(n.children[0].datapoint.depKey) - r.children[0].datapoint.facetValueNumericized(r.children[0].datapoint.depKey));
  }
  // protected _layoutDatapoints() {
  //   ChartPoint.computeSize(this);
  //   for (const datapointView of this.datapointViews) {
  //      datapointView.computeLayout();
  //   }
  // }
  seriesRef(t) {
    return this.paraview.ref(`series.${t}`);
  }
  _raiseSeries(t) {
    console.log("RAISING", t);
    const r = this.seriesRef(t).value;
    this.dataset.append(r);
  }
  getDatapointGroupBbox(t) {
    const n = this.paraview.store.model.allFacetValues("x").map(
      (s) => jr(s, this.paraview.store.getFormatType("horizTick"))
    ).findIndex((s) => s === t);
    if (n === -1)
      throw new Error(`no such datapoint with label '${t}'`);
    return this.paraview.ref("dataset").value.children[n].getBBox();
  }
  getTickX(t) {
    return this.datapointViews[t].x;
  }
}
class q3t extends Xb {
}
class eS extends x$ {
  // static computeSize(chart: PointChart) {
  //   const axisDivisions = chart.paraview.store.model!.allFacetValues('x')!.length - 1;
  //   this.width = chart.parent.contentWidth/axisDivisions;
  // }
  constructor(t) {
    super(t), this._currentAnimationFrame = null, this._isAnimating = !1, this._hasAnimated = !1;
  }
  get width() {
    const t = this.paraview.store.model.series[0].length - 1;
    return this.chart.width / t;
  }
  get height() {
    return 0;
  }
  get _selectedMarkerX() {
    return this._x - this.width / 2;
  }
  get _selectedMarkerY() {
    return this._y - this.height / 2;
  }
  get hasAnimated() {
    return this._hasAnimated;
  }
  computeX() {
    return this.width * this.index;
  }
  computeY() {
    const t = this.chart.parent.docView.chartInfo.axisInfo.yLabelInfo, r = this.chart.height / t.range;
    return this.chart.height - (this.datapoint.facetValueNumericized("y") - t.min) * r;
  }
  computeLocation() {
    this._x = this.computeX(), this.paraview.store.settings.animation.isAnimationEnabled && this.paraview.store.settings.animation.expandPoints ? (this.paraview.store.settings.animation.animationOrigin === "initialValue" ? this._animStartState.y = this._parent.children[0].computeY() : this.paraview.store.settings.animation.animationOrigin === "baseline" ? this._animStartState.y = this.chart.height : this.paraview.store.settings.animation.animationOrigin === "top" ? this._animStartState.y = 0 : this._animStartState.y = this.paraview.store.settings.animation.animationOriginValue, this._animEndState.y = this.computeY(), this._y = this._animStartState.y) : (this._y = this.computeY(), this._animStartState.y = this._y, this._animEndState.y = this._y);
  }
  beginAnimStep(t) {
    this.paraview.store.settings.animation.symbolPopIn && t + 0.01 >= this.x / this.chart.width && !this._isAnimating && !this._hasAnimated && this.popInAnimation(t), this._y = this._animStartState.y * (1 - t) + this._animEndState.y * t, super.beginAnimStep(t);
  }
  _animEnd() {
    this._currentAnimationFrame = null, this._isAnimating = !1, this._hasAnimated = !0;
  }
  popInAnimation(t) {
    this._isAnimating = !0;
    let r = -1;
    this._baseSymbolScale = 0;
    const n = new b$(0.2, 6, 1, 1, 10), i = (s) => {
      r === -1 && (r = s);
      const o = s - r, a = Math.max(1, this.paraview.store.settings.animation.popInAnimateRevealTimeMs), l = Math.min(o / a, 1), c = n.eval(l);
      this._baseSymbolScale = c * 0.25 + 0.75, this._contentUpdateSymbol(), o < a ? this._currentAnimationFrame = requestAnimationFrame(i) : this._animEnd();
    };
    this._currentAnimationFrame = requestAnimationFrame(i);
  }
}
class Y3t extends Er {
  constructor(t) {
    super(t.paraview), this.chart = t, this.x1 = 0, this.x2 = 0, this.y1 = 0, this.y2 = 0, this._generateEndpoints();
  }
  _generateEndpoints() {
    const t = [];
    for (const n of this.chart.datapointViews)
      t.push([n.x, n.y]);
    const r = h6(t);
    this.y1 = r.b, this.x2 = this.chart.parent.width, this.y2 = this.x2 * r.m + r.b, this.y2 < 0 && (this.x2 = -1 * r.b / r.m, this.y2 = 0), this.y2 > this.chart.parent.height && (this.x2 = (this.chart.parent.height - r.b) / r.m, this.y2 = this.chart.parent.height);
  }
  render() {
    return Ie`
    <line x1=${this.x1} x2=${this.x2} y1=${this.y1} y2=${this.y2} style="stroke:red;stroke-width:3"/>
    `;
  }
}
const K3t = 8, ZI = 0.125;
function Z3t(e) {
  let t = 1, r = [], n = !0;
  for (; !r.length; )
    for (let s = 0; s < e.length; s++) {
      let o;
      if (e[s].match(/\s/) && !n ? o = e[s].split(/\s+/).map((a) => a.slice(0, t)).join("") : o = e[s].slice(0, t), r.includes(o)) {
        r = [], t++, n = !1;
        break;
      }
      r[s] = o;
    }
  const i = {};
  return e.forEach((s, o) => i[s] = r[o]), i;
}
class g1 extends Jb {
  constructor() {
    super(...arguments), this._totalLabels = [];
  }
  _addedToParent() {
    super._addedToParent(), this.paraview.store.settings.type.bar.isAbbrevSeries && (this._abbrevs = Z3t(this.paraview.store.model.seriesKeys)), this.paraview.store.settingControls.add({
      type: "checkbox",
      key: "chart.showPopups",
      label: "Show popups",
      parentView: "controlPanel.tabs.chart.popups"
    });
  }
  settingDidChange(t, r, n) {
    ["color.colorPalette", "color.colorVisionMode", "chart.showPopups"].includes(t) && (n === "pattern" || n !== "pattern" && r === "pattern" || this.paraview.store.settings.color.colorPalette === "pattern") && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(t, r, n);
  }
  get abbrevs() {
    return this._abbrevs;
  }
  get numStacks() {
    return this._numStacks;
  }
  get stackWidth() {
    return this._stackWidth;
  }
  get clusterWidth() {
    return this._clusterWidth;
  }
  get availSpace() {
    return this._availSpace;
  }
  _newDatapointView(t, r) {
    return new J3t(t, r);
  }
  _beginDatapointLayout() {
    const t = Object.values(this._chartInfo.clusteredData).length;
    this._numStacks = t * this._chartInfo.stacksPerCluster;
    let r = (this._width - t * this._chartInfo.settings.clusterGap) / this._numStacks, n = 0;
    r >= K3t ? (this._stackWidth = (1 - ZI) * r, n = ZI * r) : this._stackWidth = r, this._availSpace = n * this._numStacks, super._beginDatapointLayout();
  }
  _createDatapoints() {
    const t = this._parent.docView.chartInfo, r = {};
    Object.entries(t.clusteredData).forEach(([n, i], s) => {
      for (const [o, a] of Object.entries(i.stacks))
        for (const [l, c] of Object.entries(a.bars))
          r[l] || (r[l] = new Xb(this, l), this._chartLandingView.append(r[l])), r[l].append(this._newDatapointView(r[l], a));
    }), this.paraview.store.type === "column" && this._chartLandingView.reverseChildren();
  }
  _completeDatapointLayout() {
    if (super._completeDatapointLayout(), this._chartInfo.settings.stacking === "standard" && this._chartInfo.settings.isDrawTotalLabels) {
      this._totalLabels.forEach((i) => {
        i.remove();
      }), this._totalLabels = [];
      const t = this._chartLandingView.children;
      let r = 0;
      this.parent.orientation === "east" && (r = -90);
      let n = 0;
      for (const [i, s] of Object.entries(this._chartInfo.clusteredData))
        for (const [o, a] of Object.entries(s.stacks)) {
          const l = Object.values(a.bars).at(-1), h = t.find((p) => p.seriesKey === l.series).children[n++], u = Object.values(a.bars).map((p) => t.find((g) => g.seriesKey === p.series).children[n - 1].datapoint).reduce((p, y) => p + y.facetValueAsNumber("y"), 0);
          this._totalLabels.push(new ei(this.paraview, {
            // XXX hack
            text: u.toFixed(2),
            id: this._id + "-slb",
            classList: [`${this.paraview.store.type}-total-label`],
            role: "datapoint",
            // textAnchor,
            angle: r
          })), this.append(this._totalLabels.at(-1)), this._totalLabels.at(-1).centerX = h.centerX, this._totalLabels.at(-1).bottom = h.top;
        }
    }
  }
  noticePosted(t, r) {
    ["animRevealStep", "animRevealEnd"].includes(t) && this._completeDatapointLayout();
  }
  // protected _resizeToFitLabels() {
  //   const labels = Object.values(this.bars).flatMap(cluster =>
  //     Object.values(cluster.stacks)).map(stack => stack.label!);
  //   const minX = Math.min(...labels.map(label => label.left));
  //   if (minX < 0) {
  //     this._parent.logicalWidth += -minX;
  //     console.log('NEW WIDTH', this._width);
  //     this.datapointViews.forEach(dp => {
  //       dp.x += -minX;
  //     });
  //   }
  //   const maxX = Math.max(...labels.map(label => label.right));
  //   if (maxX > this._width) {
  //     const diff = maxX - this._width;
  //     this._parent.logicalWidth += diff;
  //     console.log('NEW WIDTH', this._width);
  //   }
  //   const minY = Math.min(...labels.map(label => label.top));
  //   if (minY < 0) {
  //     this._parent.logicalHeight += -minY;
  //     console.log('NEW HEIGHT', this._height);
  //     this.datapointViews.forEach(dp => {
  //       dp.y += -minY;
  //     });
  //     labels.forEach(label => {
  //       label.y += -minY;
  //     });
  //   }
  //   const maxY = Math.max(...labels.map(label => label.bottom));
  //   if (maxY > this._height) {
  //     const diff = maxY - this._height;
  //     this._parent.logicalHeight += diff;
  //     console.log('NEW HEIGHT', this._height);
  //   }
  //   //this._checkLabelSpacing();
  // }
  // protected _checkLabelSpacing() {
  //   const labels = Object.values(this.bars).flatMap(cluster =>
  //     Object.values(cluster.stacks)).map(stack => stack.label!);
  //   const gaps = labels.slice(1).map((label, i) => label.left - labels[i].right);
  //   const minGap = Math.min(...gaps);
  //   if (Math.round(minGap) < 0) {
  //     const diffBefore = labels.at(-1)!.x - labels[0].x;
  //     labels.slice(1).forEach((label, i) => {
  //       // NB: Even if the anchor is set to middle, the labels may be rotated, so
  //       // the anchor will no longer be in the middle of the bbox
  //       label.x = labels[i].right + 0 + label.anchorXOffset;
  //     });
  //     const diffAfter = labels.at(-1)!.x - labels[0].x;
  //     this._parent.logicalWidth += diffAfter - diffBefore;
  //   }
  // }
}
class J3t extends x$ {
  constructor(t, r) {
    super(t), this._stack = r, this._recordLabel = null, this._dataLabel = null, this._isStyleEnabled = this.paraview.store.settings.type.bar.colorByDatapoint;
  }
  get classInfo() {
    return { bar: !0, ...super.classInfo };
  }
  get x() {
    return super.x;
  }
  set x(t) {
    this._dataLabel && (this._dataLabel.x += t - this._x), super.x = t;
  }
  get y() {
    return super.y;
  }
  set y(t) {
    this._dataLabel && (this._dataLabel.y += t - this._y), super.y = t;
  }
  get recordLabel() {
    return this._recordLabel;
  }
  set recordLabel(t) {
    this._recordLabel = t;
  }
  get dataLabel() {
    return this._dataLabel;
  }
  set dataLabel(t) {
    this._dataLabel = t;
  }
  get _selectedMarkerX() {
    return this._x;
  }
  get _selectedMarkerY() {
    return this._y;
  }
  // get styleInfo(): StyleInfo {
  //   const style = super.styleInfo;
  //   if (!this.paraview.store.isVisited(this.seriesKey, this.index)) {
  //     style.strokeWidth = 0;
  //   }
  //   return style;
  // }
  computeLocation() {
    const t = this.chart.chartInfo, r = this.chart.stackWidth;
    if (this._width = this.chart.stackWidth, this.paraview.store.settings.animation.isAnimationEnabled)
      this._height = 0, this._y = 0;
    else {
      const s = Object.keys(this._stack.bars).indexOf(this.series.key), o = this.chart.parent.logicalHeight / t.axisInfo.yLabelInfo.range, a = Object.values(this._stack.bars).slice(0, s).map((c) => c.value.value * o).reduce((c, h) => c + h, 0), l = this.chart.parent.logicalHeight - t.axisInfo.yLabelInfo.max * this.chart.parent.logicalHeight / t.axisInfo.yLabelInfo.range;
      this._height = Math.abs(this.datapoint.data.y.value * o), this.datapoint.data.y.value < 0 ? this._y = this.chart.height - a - l : this._y = this.chart.height - this.height - a - l;
    }
    const n = this.chart.availSpace / this.chart.numStacks, i = t.settings.clusterGap;
    this._x = i / 2 + n / 2 + r * (t.stacksPerCluster * this._stack.cluster.index + this._stack.index) + i * this._stack.cluster.index + n * (t.stacksPerCluster * this._stack.cluster.index + this._stack.index);
  }
  beginAnimStep(t) {
    const r = this.chart.chartInfo, n = Object.keys(this._stack.bars).indexOf(this.series.key), i = this.chart.parent.logicalHeight / r.axisInfo.yLabelInfo.range, s = Object.values(this._stack.bars).slice(0, n).map((a) => a.value.value * i).reduce((a, l) => a + l, 0), o = this.chart.parent.logicalHeight - r.axisInfo.yLabelInfo.max * this.chart.parent.logicalHeight / r.axisInfo.yLabelInfo.range;
    this._height = Math.abs(this.datapoint.data.y.value * i * t), this.datapoint.data.y.value < 0 ? this._y = this.chart.height - s * t - o : this._y = this.chart.height - this.height - s * t - o, super.beginAnimStep(t);
  }
  completeLayout() {
    super.completeLayout();
    const t = this.chart.chartInfo;
    let r = "middle", n = 0;
    this.chart.parent.orientation === "east" && (r = "start", n = -90), t.settings.isDrawRecordLabels && (this._recordLabel = new ei(this.paraview, {
      // @ts-ignore
      text: jr(this.datapoint.data.x, this.paraview.store.getFormatType("pieSliceValue")),
      id: this._id + "-rlb",
      classList: [`${this.paraview.store.type}-label`],
      role: "datapoint",
      textAnchor: r,
      angle: n
    }), this.append(this._recordLabel), this._recordLabel.styleInfo = {
      stroke: "none",
      fill: this.paraview.store.colors.contrastValueAt(this._isStyleEnabled ? this.index : this.parent.index)
    }, this._recordLabel.centerX = this.centerX, this._recordLabel.y = this.chart.height - this._recordLabel.height - t.settings.stackLabelGap), t.settings.isDrawDataLabels && (this._dataLabel = new ei(this.paraview, {
      // @ts-ignore
      text: jr(this.datapoint.data.y, this.paraview.store.getFormatType("pieSliceValue")),
      id: this._id + "-blb",
      classList: [`${this.paraview.store.type}-label`],
      role: "datapoint",
      textAnchor: r,
      angle: n
    }), this.append(this._dataLabel), this._dataLabel.styleInfo = {
      stroke: "none",
      fill: this.paraview.store.colors.contrastValueAt(this._isStyleEnabled ? this.index : this.parent.index)
    }, this._dataLabel.centerX = this.centerX, t.settings.dataLabelPosition === "center" ? this._dataLabel.centerY = this.centerY : t.settings.dataLabelPosition === "end" ? this._dataLabel.top = this.top : t.settings.dataLabelPosition === "base" ? this._dataLabel.bottom = this.bottom : this._dataLabel.bottom = this.top);
  }
  _createSymbol() {
  }
  // protected get _d() {
  //   return fixed`
  //     M${this._x},${this._y + this.chart.settings.barGap}
  //     v${this._height - this.chart.settings.barGap*2}
  //     h${BarStack.width}
  //     v${-(this._height - this.chart.settings.barGap*2)}
  //     Z`;
  // }
  _createShapes() {
    const t = this.paraview.store.colors.palette.isPattern;
    this._shapes.forEach((r) => {
      r.remove();
    }), this._shapes = [], this._shapes.push(new qr(this.paraview, {
      x: this._x,
      y: this._y,
      width: this._width,
      height: this._height,
      isPattern: !!t,
      pointerEnter: (r) => {
        this.paraview.store.settings.chart.showPopups && this.addPopup();
      },
      pointerLeave: (r) => {
        this.paraview.store.settings.chart.showPopups && this.removePopup(this.id);
      }
    })), super._createShapes();
  }
  get selectedMarker() {
    return new qr(this.paraview, {
      width: this._width + 4,
      height: this._height + 4,
      x: this._x - 2,
      y: this._y - 2,
      fill: "none",
      stroke: "black",
      strokeWidth: 2,
      isClip: this.shouldClip
    });
  }
  addPopup(t) {
    let r = `${this.seriesKey} ${this.index + 1}/${this.series.datapoints.length}: ${this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar")}`, n = new Il(
      this.paraview,
      {
        text: t ?? r,
        x: this.x + this.width / 2,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {}
    );
    this.paraview.store.popups.push(n);
  }
  removePopup(t) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === t), 1), this.paraview.requestUpdate();
  }
}
class i3 extends E$ {
  get datapointViews() {
    return super.datapointViews;
  }
  get settings() {
    return super.settings;
  }
  settingDidChange(t, r, n) {
    ["chart.hasDirectLabels"].includes(t) && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(t, r, n);
  }
  updateSeriesStyle(t) {
    super.updateSeriesStyle(t), t.strokeWidth = this.effectiveLineWidth;
  }
  get effectiveLineWidth() {
    return this.paraview.store.settings.ui.isLowVisionModeEnabled ? this.paraview.store.settings.type.line.lowVisionLineWidth : this.paraview.store.settings.type.line.lineWidth;
  }
  get effectiveVisitedScale() {
    return this.paraview.store.settings.ui.isLowVisionModeEnabled ? 1 : this.paraview.store.settings.type.line.lineHighlightScale;
  }
  get visitedStrokeWidth() {
    return this.effectiveLineWidth * this.effectiveVisitedScale;
  }
  _newDatapointView(t) {
    return new X3t(t);
  }
}
class X3t extends eS {
  // get height() {
  //   // apparently this can get called before the shape is created
  //   return bboxOfBboxes(...this._shapes.map(shape => shape.bbox)).height ?? 0;
  // }
  // get left() {
  //   return this._shape!.left;
  // }
  // get right() {
  //   return this._shape!.right;
  // }
  // get top() {
  //   return this._shape!.top;
  // }
  // get bottom() {
  //   return this._shape!.bottom;
  // }
  get outerBbox() {
    const t = this._shapes.map((r) => r.outerBbox);
    return this._symbol ? D4(...t, this._symbol.outerBbox) : D4(...t);
  }
  completeLayout() {
    this.index && this._computePrev(), this.index < this.chart.paraview.store.model.series[0].length - 1 && this._computeNext(), this._computeCentroid(), super.completeLayout();
  }
  _createSymbol() {
    var n;
    let r = this.seriesProps.symbol;
    (n = this._symbol) == null || n.remove(), this._symbol = ya.fromType(this.paraview, r), this.append(this._symbol);
  }
  _computePrev() {
    this._prevMidX = -this.width / 2, this._prevMidY = (this._prev.y - this.y) / 2;
  }
  _computeNext() {
    this._nextMidX = this.width / 2, this._nextMidY = (this._next.y - this.y) / 2;
  }
  _computeCentroid() {
    var s, o;
    const t = ((s = this._symbol) == null ? void 0 : s.width) ?? 0, r = ((o = this._symbol) == null ? void 0 : o.height) ?? 0;
    let n = "50%";
    this._prevMidX ? this._nextMidX || (n = `calc(100% - ${t / 2}px)`) : n = `${t / 2}px`;
    let i = "50%";
    if (!this._prevMidY && this._nextMidY)
      i = this._y > this._nextMidY ? `calc(100% - ${r / 2}px)` : `${r / 2}px`;
    else if (!this._nextMidY && this._prevMidY)
      i = this._y > this._prevMidY ? `calc(100% - ${r / 2}px)` : `${r / 2}px`;
    else if (this._nextMidY && this._prevMidY) {
      const a = this._y - r / 2, l = this._y + r / 2;
      l > this._nextMidY && l > this._prevMidY ? i = `calc(100% - ${r / 2}px)` : a < this._nextMidY && a < this._prevMidY ? i = `${r / 2}px` : i = `${this._y - Math.min(this._prevMidY, this._nextMidY)}px`;
    }
    this.centroid = `${n} ${i}`;
  }
  get _points() {
    return this._prevMidY !== void 0 && this._nextMidY !== void 0 ? [
      new qt(this._prevMidX, this._prevMidY),
      new qt(),
      new qt(this._nextMidX, this._nextMidY)
    ] : this._prevMidY === void 0 && this._nextMidY !== void 0 ? [
      new qt(),
      new qt(this._nextMidX, this._nextMidY)
    ] : this._prevMidY !== void 0 && this._nextMidY === void 0 ? [
      new qt(this._prevMidX, this._prevMidY),
      new qt()
    ] : [
      new qt()
    ];
  }
  get classInfo() {
    return {
      "data-line": !0,
      ...super.classInfo
    };
  }
  _shapeStyleInfo(t) {
    if (this.paraview.documentView.chartInfo.navMap.cursor.isNodeType("sequence")) {
      const r = this.paraview.documentView.chartInfo.navMap.cursor;
      if (this.index === r.options.start && this.index && !t || this.index === r.options.end - 1 && t)
        return {
          fill: this._parent.styleInfo.fill,
          stroke: this._parent.styleInfo.stroke,
          strokeWidth: this._parent.styleInfo.strokeWidth
        };
    }
    return super._shapeStyleInfo(t);
  }
  _createShapes() {
    this._shapes.forEach((s) => {
      s.remove();
    }), this._shapes = [];
    const t = this._points;
    let r = this.withCousins.map((s, o) => [s, o]).toSorted((s, o) => s[0].y - o[0].y), n = 0, i = 0;
    if (r.length === 1)
      n = 0, i = this.chart.height;
    else if (r[0][1] === this.parent.index)
      n = 0, i = (r[1][0].y - this.y) / 2 + this.y;
    else if (r[r.length - 1][1] === this.parent.index)
      n = (this.y - r[r.length - 2][0].y) / 2 + r[r.length - 2][0].y, i = this.chart.height - ((this.y - r[r.length - 2][0].y) / 2 + r[r.length - 2][0].y);
    else {
      let s = r.findIndex((o) => o[1] === this.parent.index);
      n = (this.y - r[s - 1][0].y) / 2 + r[s - 1][0].y, i = (r[s + 1][0].y - this.y) / 2 + this.y - ((this.y - r[s - 1][0].y) / 2 + r[s - 1][0].y);
    }
    if (t.length === 3) {
      const s = [t.slice(0, -1), t.slice(1)];
      this._shapes.push(
        new mo(this.paraview, {
          x: this._x,
          y: this._y,
          points: s[0],
          isClip: !0
        }),
        new mo(this.paraview, {
          x: this._x,
          y: this._y,
          points: s[1],
          isClip: !0
        })
      );
      let o = new qr(this.paraview, {
        x: this._x + s[0][0].x,
        y: n,
        width: s[1][1].x - s[0][0].x,
        height: i,
        stroke: "white",
        fill: "white",
        pointerEnter: (a) => {
          this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.addPopup();
        },
        pointerLeave: (a) => {
          this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.removePopup(this.id);
        }
      });
      this._shapes[0].classInfo = { "leg-left": !0 }, this._shapes[1].classInfo = { "leg-right": !0 }, o.classInfo = { invis: !0 }, this.append(o);
    } else if (t.length === 2) {
      this._shapes.push(
        new mo(this.paraview, {
          x: this._x,
          y: this._y,
          points: t,
          isClip: !0
        })
      );
      let s = new qr(this.paraview, {
        x: t[0].x == 0 ? this._x : this._x + t[0].x,
        y: n,
        width: t[0].x == 0 ? t[1].x : this.x,
        height: i,
        stroke: "white",
        fill: "white",
        pointerEnter: (o) => {
          this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.addPopup();
        },
        pointerLeave: (o) => {
          this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.removePopup(this.id);
        }
      });
      this._shapes[0].classInfo = this._prevMidY !== void 0 ? { "leg-left": !0 } : { "leg-right": !0 }, s.classInfo = { invis: !0 }, this.append(s);
    }
    this._shapes.forEach((s) => {
      s.isClip = this.shouldClip;
    }), super._createShapes();
  }
  addPopup(t) {
    let r = `${this.seriesKey} ${this.index + 1}/${this.series.datapoints.length}: ${this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar")}`, n = new Il(
      this.paraview,
      {
        text: t ?? r,
        x: this.x,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {}
    );
    this.paraview.store.popups.push(n);
  }
  removePopup(t) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === t), 1);
  }
}
class t4t extends w$ {
  constructor(t, r, n, i, s) {
    super(t, r, n, i, s), this._arcType = "circle", this._startAngleOffset = -0.25, this._arc = 1, this._radiusDivisor = 2.3, this._centerLabel = null;
  }
  _addedToParent() {
    super._addedToParent(), this._resetRadius(), this._arcType === "semicircle" && (this._arc = 0.5, this._startAngleOffset = -0.25), this.paraview.store.settingControls.add({
      type: "checkbox",
      key: "chart.showPopups",
      label: "Show popups",
      parentView: "controlPanel.tabs.chart.popups"
    });
  }
  // get radius() {
  //   return this._radius;
  // }
  get settings() {
    return super.settings;
  }
  get cx() {
    return this._cx;
  }
  get cy() {
    return this._cy;
  }
  get arcType() {
    return this._arcType;
  }
  get startAngleOffset() {
    return this._startAngleOffset;
  }
  get radius() {
    return this._radius;
  }
  get datapointViews() {
    return super.datapointViews;
  }
  _completeDatapointLayout() {
    super._completeDatapointLayout(), this._createLabels();
  }
  _animStep(t) {
    super._animStep(t), this._createLabels();
  }
  init() {
    super.init(), this._resizeToFitLabels(), this.settings.centerLabel === "title" && (this.paraview.store.updateSettings((t) => {
      t.chart.title.isDrawTitle = !1;
    }), this._centerLabel = new ei(this.paraview, {
      text: this.paraview.store.title,
      centerX: this._cx,
      centerY: this._cy,
      textAnchor: "middle",
      wrapWidth: 2 * (this.radius - this.settings.annularThickness * this.radius) - this.settings.centerLabelPadding * 2,
      id: "chart-title",
      classList: ["chart-title"]
    }), this.append(this._centerLabel));
  }
  settingDidChange(t, r, n) {
    ["color.colorPalette", "color.colorVisionMode"].includes(t) && (n === "pattern" || n !== "pattern" && r === "pattern" || this.paraview.store.settings.color.colorPalette === "pattern") && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), ["explode", "orientationAngleOffset", "insideLabels.contents", "outsideLabels.contents"].map((s) => `type.${this.paraview.store.type}.${s}`).includes(t) && (this._resetRadius(), this._chartLandingView.clearChildren(), this._layoutDatapoints(), this._resizeToFitLabels(), this.paraview.requestUpdate()), super.settingDidChange(t, r, n);
  }
  _resetRadius() {
    this._radius = Math.min(this._height, this._width) / 2, this._cx = this._width / 2, this._cy = this._height / 2;
  }
  _resizeToFitLabels() {
    for (; ; ) {
      const t = this.datapointViews.map((a) => a.outsideLabel).filter((a) => a);
      if (!t.length) return;
      let r = 1;
      const n = Math.min(...t.map((a) => a.paddedLeft));
      if (n < 0) {
        const a = this.datapointViews.find((u) => {
          var p;
          return ((p = u.outsideLabel) == null ? void 0 : p.paddedLeft) === n;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.x), h = Math.max((c + n) / c, 0.5);
        h < r && (r = h);
      }
      const i = Math.max(...t.map((a) => a.paddedRight));
      if (i > this._width) {
        const a = this.datapointViews.find((u) => {
          var p;
          return ((p = u.outsideLabel) == null ? void 0 : p.paddedRight) === i;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.x), h = Math.max((c - (i - this._width)) / c, 0.5);
        h < r && (r = h);
      }
      const s = Math.min(...t.map((a) => a.paddedTop));
      if (s < 0) {
        const a = this.datapointViews.find((u) => {
          var p;
          return ((p = u.outsideLabel) == null ? void 0 : p.paddedTop) === s;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.y), h = Math.max((c + s) / c, 0.5);
        h < r && (r = h);
      }
      const o = Math.max(...t.map((a) => a.paddedBottom));
      if (o > this._height) {
        const a = this.datapointViews.find((u) => {
          var p;
          return ((p = u.outsideLabel) == null ? void 0 : p.paddedBottom) === o;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.y), h = Math.max((c - (o - this._height)) / c, 0.5);
        h < r && (r = h);
      }
      if (Math.round(r * 100) < 100)
        this._radius *= r, this._chartLandingView.clearChildren(), this._layoutDatapoints();
      else
        break;
    }
  }
  _createDatapoints() {
    const t = this.paraview.store.model.series[0].datapoints.map(
      (o) => jr(o.facetBox("x"), this.paraview.store.getFormatType("pieSliceLabel"))
    ), r = this.paraview.store.model.series[0].datapoints.map((o) => o.facetValueNumericized("y")), n = r.reduce((o, a) => o + a, 0), i = new QA(this, this.paraview.store.model.seriesKeys[0], !1);
    this._chartLandingView.append(i);
    let s = 0;
    for (const [o, a] of Nn(t)) {
      const l = r.at(a), c = this._arc * l / n, h = this._createSlice(i, {
        value: l,
        category: o,
        seriesIdx: a,
        percentage: c,
        accum: s,
        numDatapoints: t.length
      });
      i.append(h), s += c;
    }
  }
  _createLabels() {
    const t = this.paraview.store.model.series[0].datapoints.map(
      (n) => jr(n.facetBox("x"), this.paraview.store.getFormatType("pieSliceLabel"))
    );
    this.paraview.store.model.series[0].datapoints.map(
      (n) => jr(n.facetBox("y"), this.paraview.store.getFormatType("pieSliceLabel"))
    );
    for (const [n, i] of Nn(t)) {
      const s = this._chartLandingView.children[0].children[i];
      this.settings.outsideLabels.contents && s.createOutsidelabel(), this.settings.insideLabels.contents && s.createInsideLabel();
    }
    this.datapointViews.map((n) => n.outsideLabel).filter((n) => n).length && this._resolveOutsideLabelCollisions();
  }
  _resolveOutsideLabelCollisions() {
    const t = this.datapointViews.filter((r) => r.outsideLabel);
    t.sort((r, n) => n.outsideLabel.y - r.outsideLabel.y), t.slice(1).forEach((r, n) => {
      if (r.outsideLabel.intersects(t[n].outsideLabel)) {
        const i = r.outsideLabel.y;
        r.outsideLabel.bottom = t[n].outsideLabel.top - this.settings.outsideLabels.vertGap;
        const s = r.outsideLabel.y - i;
        r.adjustLeader(s);
      }
    });
  }
  focusRingShape() {
    const r = this._parent.docView.chartInfo.navMap.cursor;
    return r.isNodeType("datapoint") ? this.datapointView(r.options.seriesKey, r.options.index).focusRingShape() : null;
  }
}
class e4t extends md {
  constructor(t, r) {
    super(t), this._params = r, this._outsideLabel = null, this._insideLabel = null, this._leader = null, this._focusRingShape = null, this._centralAngle = 0, this._isStyleEnabled = !0;
  }
  get percentage() {
    return this._params.percentage;
  }
  get outsideLabel() {
    return this._outsideLabel;
  }
  get insideLabel() {
    return this._insideLabel;
  }
  get shapes() {
    return this._shapes;
  }
  get role() {
    return "graphics-symbol";
  }
  get roleDescription() {
    return "datapoint";
  }
  get classInfo() {
    return {
      ...super.classInfo,
      "pastry-slice": !0
      // bad workaround for the problem that, when a visited datapoint is recreated,
      // the store data cursor now has a ref to the old instance
      // visited: this.paraview.store.isVisited(this.seriesKey, this.index),
      // selected: this.paraview.store.isSelected(this.seriesKey, this.index)
    };
  }
  get styleInfo() {
    const t = super.styleInfo;
    return delete t.strokeWidth, delete t.stroke, t;
  }
  get x() {
    return super.x;
  }
  set x(t) {
    this._outsideLabel && (this._outsideLabel.x += t - this._x), this._insideLabel && (this._insideLabel.x += t - this._x), this._leader && (this._leader.x += t - this._x), super.x = t;
  }
  get y() {
    return super.y;
  }
  set y(t) {
    this._outsideLabel && (this._outsideLabel.y += t - this._y), this._insideLabel && (this._insideLabel.y += t - this._y), this._leader && (this._leader.y += t - this._y), super.y = t;
  }
  _createSymbol() {
  }
  get isPositionRight() {
    return this.shapes[0].arcCenter.x > this.chart.cx;
  }
  get isPositionBottom() {
    return this.shapes[0].arcCenter.y > this.chart.cy;
  }
  _createShapes() {
    const t = this._shapes[0].clone(), r = this.paraview.store.settings.ui.focusRingGap, n = t.centralAngle;
    if (t.centralAngle += 2 * r * 360 / (2 * Math.PI * t.r), t.orientationAngle -= (t.centralAngle - n) / 2, t.annularThickness < 1) {
      t.r += r;
      const i = t.annularThickness * t.r;
      t.annularThickness = (i + 2 * r) / (t.r + r);
    } else
      t.scale = (t.r + r) / t.r;
    this._focusRingShape = t, super._createShapes();
  }
  _labelContents(t) {
    return t.split(/:/).map((i) => {
      let s = !1;
      i[0] === "(" && i.at(-1) === ")" && (s = !0, i = i.slice(1, -1));
      let o = "";
      if (i === "series")
        o = this.seriesKey;
      else if (i === "category")
        o = this._params.category;
      else if (i === "percentage")
        o = `${Math.round(this._params.percentage * 100)}%`;
      else if (i === "value")
        o = `${this._params.value}`;
      else
        throw new Error(`invalid radial label content field '${i}'`);
      return s ? `(${o})` : o;
    }).join(" ");
  }
  createOutsidelabel(t = "") {
    var c, h;
    const r = this.shapes[0], n = r.orientationVector.multiplyScalar(
      this.chart.settings.outsideLabels.arcGap
    );
    let i = "end", s = "topLeft", o = 0, a = 0;
    const l = r.arcCenter.add(n);
    this.isPositionRight ? (l.x += this.chart.settings.outsideLabels.horizShift, o = this.chart.settings.outsideLabels.horizPadding, i = "start") : (l.x -= this.chart.settings.outsideLabels.horizShift, a = this.chart.settings.outsideLabels.horizPadding), this.isPositionBottom ? s = i === "start" ? "topLeft" : "topRight" : s = i === "start" ? "bottomLeft" : "bottomRight", (c = this._outsideLabel) == null || c.remove(), this._outsideLabel = new ei(this.paraview, {
      text: this._labelContents(t || this.chart.settings.outsideLabels.contents),
      id: this.id + "-rlb",
      classList: ["pastry-outside-label"],
      role: "datapoint",
      [s]: l,
      textAnchor: i
    }), this._outsideLabel.padding = { left: o, right: a }, (h = this._leader) == null || h.remove(), this._leader = this._createOutsideLabelLeader(), this.append(this._leader), this.append(this._outsideLabel);
  }
  _createOutsideLabelLeader() {
    const t = new qt(
      this.isPositionRight ? this._outsideLabel.paddedLeft : this._outsideLabel.paddedRight,
      this.chart.settings.outsideLabels.leaderStyle === "direct" ? this._outsideLabel.centerY : this._outsideLabel.bottom
    ).addY(
      this.chart.settings.outsideLabels.leaderStyle === "underline" ? this.chart.settings.outsideLabels.underlineGap : 0
    ), r = this.chart.settings.outsideLabels.leaderStyle === "direct" ? this.chart.settings.outsideLabels.horizPadding : this._outsideLabel.paddedWidth, n = new mo(this.paraview, {
      points: [this.shapes[0].arcCenter, t, t.x > this._outsideLabel.centerX ? t.subtractX(r) : t.addX(r)],
      stroke: this.paraview.store.colors.colorValueAt(this.color)
    });
    return n.classInfo = { "pastry-outside-label-leader": !0 }, n;
  }
  adjustLeader(t) {
    this._leader.points = [
      this._leader.points[0],
      this._leader.points[1].addY(t),
      this._leader.points[2].addY(t)
    ];
  }
  createInsideLabel() {
    var n;
    const t = this.shapes[0];
    let r = "topLeft";
    if (this.isPositionBottom ? r = this.isPositionRight ? "topLeft" : "topRight" : r = this.isPositionRight ? "bottomLeft" : "bottomRight", (n = this._insideLabel) == null || n.remove(), this._insideLabel = new ei(this.paraview, {
      text: this._labelContents(this.chart.settings.insideLabels.contents),
      id: this.id + "-ilb",
      classList: ["pastry-inside-label"],
      role: "datapoint",
      [Abt(r)]: t.loc.add(
        t.orientationVector.multiplyScalar(
          this.chart.radius * this.chart.settings.insideLabels.position
        )
      )
    }), Object.values(this._insideLabel.textCorners).every((i) => t.containsPoint(i)))
      this._insideLabel.styleInfo = {
        fill: this.paraview.store.colors.contrastValueAt(this.color)
      }, this.append(this._insideLabel);
    else {
      if (this._outsideLabel) {
        this._outsideLabel.text += `
${this._insideLabel.text}`;
        const i = this._leader;
        this._leader = this._createOutsideLabelLeader(), this.replaceChild(i, this._leader);
      } else
        this.createOutsidelabel(
          this.chart.settings.insideLabels.contents + (this.chart.settings.outsideLabels.contents ? ":" + this.chart.settings.outsideLabels.contents : "")
        );
      this._insideLabel = null;
    }
  }
  focusRingShape() {
    return this._focusRingShape;
  }
}
class JI extends t4t {
  _createSlice(t, r) {
    return new r4t(t, r);
  }
}
class r4t extends e4t {
  constructor(t, r) {
    super(t, r), this._x = this.chart.cx, this._y = this.chart.cy;
  }
  get width() {
    return 0;
  }
  get height() {
    return 0;
  }
  computeLocation() {
    this.paraview.store.settings.animation.isAnimationEnabled ? this._centralAngle = this.chart.animateRevealComplete ? this._params.percentage * 360 : 0 : this._centralAngle = this._params.percentage * 360;
  }
  beginAnimStep(t) {
    this._centralAngle = this._params.percentage * 360 * t, super.beginAnimStep(t);
  }
  _createShapes() {
    const t = this.paraview.store.colors.palette.isPattern;
    this._shapes.forEach((i) => {
      i.remove();
    }), this._shapes = [];
    const r = new Iy(this.paraview, {
      x: this._x,
      y: this._y,
      r: this.chart.radius,
      centralAngle: this._centralAngle,
      orientationAngle: this._params.accum * 360,
      orientationAngleOffset: this.chart.settings.orientationAngleOffset,
      annularThickness: this.chart.settings.annularThickness,
      isPattern: !!t,
      pointerEnter: (i) => {
        this.paraview.store.settings.chart.showPopups && this.addPopup();
      },
      pointerLeave: (i) => {
        this.paraview.store.settings.chart.showPopups && this.removePopup(this.id);
      }
    });
    this._shapes.push(r), this.chart.settings.explode.split(":").map((i) => parseInt(i)).includes(this.index) && (r.loc = r.loc.add(r.orientationVector.multiplyScalar(this.chart.settings.explodeDistance))), super._createShapes();
  }
  // protected _computeLabelOptions() {
  //   const r = this.chart.radius.outer;
  //   const sector = (this._children[0] as Sector);
  //   const centerAngle = sector.options.orientationAngle + sector.options.centralAngle/2;
  //   let className = 'radial_label';
  //   // if (centerAngle >= 0.05 && centerAngle <= 0.45) {
  //   //   className = 'radial_label_right';
  //   // } else if (centerAngle >= 0.55 && centerAngle <= 0.95) {
  //   //   className = 'radial_label_left';
  //   // }
  //   // console.log('LABEL OPTS', r, centerAngle, this.chart.cx, this.chart.cy, this._radians);
  //   return {
  //     x: this.chart.cx + r*Math.cos(centerAngle*Math.PI/180),
  //     y: this.chart.cy + r*Math.sin(centerAngle*Math.PI/180),
  //     className
  //   };
  // }
  get selectedMarker() {
    return new Iy(this.paraview, {
      x: this._x,
      y: this._y,
      r: this.chart.radius,
      centralAngle: this._params.percentage * 360,
      orientationAngle: this._params.accum * 360,
      orientationAngleOffset: this.chart.settings.orientationAngleOffset,
      annularThickness: this.chart.settings.annularThickness,
      fill: "none",
      stroke: "black",
      strokeWidth: 2
    });
  }
  addPopup(t) {
    if (this.paraview.store.popups.some((a) => a.id == this.id))
      return;
    let r = 2 * Math.PI - (this._params.accum * 2 * Math.PI + this._params.percentage * Math.PI - this.chart.settings.orientationAngleOffset * 2 * Math.PI / 360), n = this.x + this.chart.radius * (1 - this.chart.settings.annularThickness / 2) * Math.cos(r), i = this.y - this.chart.radius * (1 - this.chart.settings.annularThickness / 2) * Math.sin(r), s = `${this.seriesKey} ${this.index + 1}/${this.series.datapoints.length}: ${this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar")}`, o = new Il(
      this.paraview,
      {
        text: t ?? s,
        x: n,
        y: i,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {
        shape: "boxWithArrow",
        fill: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(this.color), 6) : this.paraview.store.colors.colorValueAt(this.color),
        stroke: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(this.color) : "black"
      }
    );
    this.paraview.store.popups.push(o);
  }
  removePopup(t) {
    let r = this.paraview.pointerEventManager.coords, n = r.x - this.paraview.documentView.padding.left - this.paraview.documentView.chartLayers.x, i = r.y - this.paraview.documentView.padding.top - this.paraview.documentView.chartLayers.y, s = this.paraview.store.popups.find((o) => o.id === t);
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((o) => o.id === t), 1), s && (n <= s.box.right && n >= s.box.left && i >= s.box.top && i <= s.box.bottom || this.paraview.requestUpdate());
  }
}
class n4t extends E$ {
  constructor() {
    super(...arguments), this._clusterShellView = null;
  }
  get settings() {
    return super.settings;
  }
  get chartInfo() {
    return this._chartInfo;
  }
  get datapointViews() {
    return super.datapointViews;
  }
  settingDidChange(t, r, n) {
    ["type.scatter.isShowOutliers"].includes(t) && this.updateOutliers(), super.settingDidChange(t, r, n);
  }
  _newDatapointView(t) {
    return new i4t(t);
  }
  _createDatapoints() {
    for (const [r, n] of Nn(this.paraview.store.model.series)) {
      const i = this._newSeriesView(r.key);
      this._chartLandingView.append(i);
      for (const [s, o] of Nn(r)) {
        const a = this._newDatapointView(i);
        i.append(a);
      }
    }
    const t = this.datapointViews;
    for (const r of this._chartInfo.clustering) {
      for (const n of r.dataPointIDs)
        t[n].clusterID = r.id;
      for (const n of r.outlierIDs)
        t[n].clusterID = r.id, t[n].isOutlier = !0;
    }
    this.datapointViewsStatic = super.datapointViews;
  }
  _beginDatapointLayout() {
    super._beginDatapointLayout();
    for (let r of this.children)
      r instanceof XI && r.remove();
    let t = new XI(this);
    this.append(t);
  }
  updateOutliers() {
    for (let t of this.datapointViews)
      t.isOutlier && t.completeLayout();
  }
  content(...t) {
    var n;
    const r = this.parent.docView.chartInfo;
    return r.clustering && ((n = this._clusterShellView) == null || n.remove(), r.currentCluster !== -1 && (this._clusterShellView = new s4t(this, r.currentCluster), this.append(this._clusterShellView))), super.content(...t);
  }
}
class i4t extends eS {
  constructor() {
    super(...arguments), this.isOutlier = !1;
  }
  computeX() {
    const t = this.chart.chartInfo.axisInfo, r = (this.datapoint.facetValueNumericized("x") - t.xLabelInfo.min) / t.xLabelInfo.range;
    return this.chart.parent.width * r;
  }
  get width() {
    var t;
    return (t = this._symbol) != null && t.width ? 2 * 1.5 * this._symbol.width : 36;
  }
  _createShape() {
  }
  get _symbolColor() {
    return this.symbolColor === void 0 && (this.symbolColor = this.seriesProps.color), this.paraview.store.isVisited(this.seriesKey, this.index) ? -1 : this.symbolColor;
  }
  _createSymbol() {
    const t = this.seriesProps;
    let r = t.symbol, n = t.color;
    const i = new qF().types;
    this.chart.chartInfo.clustering && (this.clusterID !== void 0 ? (n = Number(this.clusterID), r = i[n % i.length]) : r = i[8], this.paraview.store.settings.type.scatter.isShowOutliers && this.isOutlier && (n = 0, r = i[8])), this._symbol = ya.fromType(this.paraview, r, {
      strokeWidth: this.paraview.store.settings.chart.symbolStrokeWidth,
      lighten: !0,
      pointerEnter: (s) => {
        this.paraview.store.settings.chart.showPopups && this.addPopup();
      },
      pointerLeave: (s) => {
        this.paraview.store.settings.chart.showPopups && this.removePopup(this.id);
      }
    }), this._symbol.role = "datapoint", this._symbol.id = `${this._id}-sym`, this.symbolColor = n, this._children = this.children.filter((s) => !(s instanceof ya)), this.append(this._symbol);
  }
  get classInfo() {
    return {
      [`cluster-${this.clusterID}`]: this.clusterID !== void 0,
      ...super.classInfo
    };
  }
  get color() {
    return this.chart.chartInfo.clustering ? this.clusterID : super.color;
  }
  addPopup() {
    let t = new Il(
      this.paraview,
      {
        text: this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar"),
        x: this.x,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {
        shape: "boxWithArrow",
        fill: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(this.color), 6) : this.paraview.store.colors.colorValueAt(this.color),
        stroke: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(this.color) : "black"
      }
    );
    this.paraview.store.popups.push(t);
  }
  removePopup(t) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === t), 1), this.paraview.requestUpdate();
  }
}
class XI extends Y3t {
  render() {
    return this.paraview.store.settings.type.scatter.isDrawTrendLine ? Ie`
    <line x1=${this.x1} x2=${this.x2} y1=${this.y1} y2=${this.y2} style="stroke:red;stroke-width:3"/>
    ` : Ie``;
  }
}
class s4t extends Er {
  constructor(t, r, n) {
    super(t.paraview), this.chart = t, this.clusterID = r, this.selectedPoints = n, this._points = [], this.generatePoints();
  }
  _createId(...t) {
    return "";
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  generatePoints() {
    if (this.selectedPoints !== void 0) {
      let t = [];
      for (let r of this.selectedPoints)
        t.push([r.x, r.y]);
      this._points = t;
    } else if (this.clusterID !== void 0) {
      const t = this.chart.datapointViewsStatic, i = this.chart.parent.docView.chartInfo.clustering[this.clusterID].hullIDs, s = [];
      for (const o of i)
        s.push([t[o].x, t[o].y]);
      this._points = s;
    } else
      this._points = [];
  }
  get points() {
    return this._points;
  }
  get pointsString() {
    let t = "";
    for (const r of this.points)
      t = t.concat(ee`${r[0]},${r[1]} `);
    return t;
  }
  get centroid() {
    const t = [0, 0];
    for (const r of this.points)
      t[0] += r[0] / this.points.length, t[1] += r[1] / this.points.length;
    return t;
  }
  get color() {
    return this.clusterID !== void 0 ? this.clusterID : 0;
  }
  render() {
    let t = new QF(this.paraview.store);
    return Ie`<g>
      <polygon points=${this.pointsString} style="stroke:black; fill:none; stroke-width:2"/>
      <circle
        cx=${ee`${this.centroid[0]}`}
        cy=${ee`${this.centroid[1]}`} r="8"
        style=stroke:black;fill:${t.colorValueAt(this.color)}
      />
    </g>`;
  }
}
class o4t extends Jb {
  constructor(t, r, n, i, s) {
    super(t, r, n, i, s), this._settings = this.paraview.store.settings.type.heatmap;
  }
  settingDidChange(t, r, n) {
    t === "type.heatmap.resolution" && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(t, r, n);
  }
  get settings() {
    return this._settings;
  }
  get chartInfo() {
    return this._chartInfo;
  }
  _newDatapointView(t) {
    return new tP(this, t);
  }
  _createDatapoints() {
    console.log("CREATING DATAPOINTS");
    const t = [];
    for (const [r, n] of Nn(this.paraview.store.model.allFacetValues("x")))
      t.push(jr(r, this.paraview.store.getFormatType(`${this.parent.docView.type}Point`))), Cr(t.at(-1));
    for (const [r, n] of Nn(this.paraview.store.model.series)) {
      const i = new Xb(this, r.key);
      this._chartLandingView.append(i);
      for (let s = 0; s < this._chartInfo.resolution ** 2; s++) {
        const o = new tP(this, i);
        i.append(o);
      }
    }
    this._chartLandingView.sortChildren((r, n) => n.children[0].datapoint.facetValueNumericized(n.children[0].datapoint.depKey) - r.children[0].datapoint.facetValueNumericized(r.children[0].datapoint.depKey));
  }
  // protected _layoutDatapoints() {
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.completeLayout();
  //   }
  // }
  seriesRef(t) {
    return this.paraview.ref(`series.${t}`);
  }
  _raiseSeries(t) {
    const r = this.seriesRef(t).value;
    this.dataset.append(r);
  }
  getTickX(t) {
    return this.datapointViews[t].x;
  }
}
class tP extends md {
  constructor(t, r) {
    super(r), this._count = 0;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get count() {
    return this._count;
  }
  get fillColor() {
    let t = "hsl(0, 0%, 0%)";
    return this._count > 0 && (t = `hsl(0, 0%, ${85 * this._count / this.chart.chartInfo.maxCount + 15}%)`), t;
  }
  get _selectedMarkerX() {
    return this._x;
  }
  get _selectedMarkerY() {
    return this._y;
  }
  get selectedMarker() {
    return new qr(this.paraview, {
      width: this._width + 4,
      height: this._height + 4,
      x: this._x - 2,
      y: this._y - 2,
      fill: "none",
      stroke: "red",
      strokeWidth: 5
    });
  }
  _createId(...t) {
    return [
      "datapoint",
      Cr(this.series.key),
      //facets,
      `${this.index}`
    ].join("-");
  }
  completeLayout() {
    const t = this.chart.chartInfo;
    this._height = this.chart.parent.height / t.resolution, this._width = this.chart.parent.width / t.resolution, this._x = this.index % t.resolution * this._width, this._y = Math.floor(this.index / t.resolution) * this._height;
    const r = this.index;
    this._count = t.grid[r % t.resolution][Math.floor(r / t.resolution)], this.id = [
      "datapoint",
      Cr(this.seriesKey),
      ee`${this._x}`,
      ee`${this._y}`
    ].join("-"), super.completeLayout();
  }
  _createSymbol() {
  }
  _contentUpdateShapes() {
  }
  layoutSymbol() {
  }
  _createShapes() {
    const t = new a4t(this.paraview, {
      x: this._x,
      y: this._y,
      width: this._width,
      height: this._height,
      fill: this.fillColor,
      stroke: this.fillColor
    });
    this._shapes.push(t), super._createShapes();
  }
}
class a4t extends qr {
  get count() {
    return this.parent.count;
  }
  get chart() {
    return this.parent.chart;
  }
  get fillColor() {
    return this.parent.fillColor;
  }
  get parentIndex() {
    return this.parent.index;
  }
  render() {
    return this._styleInfo.stroke = this.paraview.store.visitedDatapoints.values().some((t) => t === this.parent.datapointId) ? "hsl(0, 100.00%, 50.00%)" : this.options.stroke ?? this._options.stroke, Ie`
        <rect
          ${this._ref ? ge(this._ref) : void 0}
          id=${this._id || Lt}
          style=${Object.keys(this._styleInfo).length ? ln(this._styleInfo) : Lt}
          class=${Object.keys(this._classInfo).length ? Rr(this._classInfo) : Lt}
          role=${this._role || Lt}
          x=${ee`${this._x}`}
          y=${ee`${this._y}`}
          width=${ee`${this.width}`}
          height=${ee`${this.height}`}
          fill= '${this.fillColor}'

          clip-path=${this._options.isClip ? "url(#clip-path)" : Lt}
        ></rect>
      `;
  }
}
class l4t extends Jb {
  settingDidChange(t, r, n) {
    ["type.histogram.groupingAxis", "type.histogram.displayAxis", "type.histogram.relativeAxes", "axis.y.maxValue", "axis.y.minValue"].includes(t) ? (this.paraview.createDocumentView(), this.paraview.requestUpdate()) : t === "type.histogram.bins" && (this.paraview.createDocumentView(), this.paraview.requestUpdate(), this.paraview.store.updateSettings((i) => {
      i.axis.y.maxValue = "unset";
    }), this.paraview.store.updateSettings((i) => {
      i.axis.y.minValue = "unset";
    })), super.settingDidChange(t, r, n);
  }
  get chartInfo() {
    return this._chartInfo;
  }
  get datapointViews() {
    return super.datapointViews;
  }
  get settings() {
    return this._settings;
  }
  _newDatapointView(t) {
    return new eP(this, t);
  }
  _createDatapoints() {
    const t = [];
    for (const [n, i] of Nn(this.paraview.store.model.series[0].datapoints))
      t.push(jr(n.facetBox("x"), this.paraview.store.getFormatType(`${this.parent.docView.type}Point`))), Cr(t.at(-1));
    const r = new Xb(this, this.paraview.store.model.series[0].key);
    this._chartLandingView.append(r);
    for (let n = 0; n < this.chartInfo.bins; n++) {
      const i = new eP(this, r);
      r.append(i);
    }
    this._chartLandingView.sortChildren((n, i) => i.children[0].datapoint.facetValueNumericized(i.children[0].datapoint.depKey) - n.children[0].datapoint.facetValueNumericized(n.children[0].datapoint.depKey));
  }
  _layoutDatapoints() {
    for (const t of this.datapointViews)
      t.completeLayout();
  }
  seriesRef(t) {
    return this.paraview.ref(`series.${t}`);
  }
  _raiseSeries(t) {
    const r = this.seriesRef(t).value;
    this.dataset.append(r);
  }
  getTickX(t) {
    return this.datapointViews[t].x;
  }
}
class eP extends md {
  constructor(t, r) {
    super(r), this._count = 0;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get count() {
    return this._count;
  }
  get _selectedMarkerX() {
    return this._x;
  }
  get _selectedMarkerY() {
    return this._y;
  }
  get selectedMarker() {
    return new qr(this.paraview, {
      width: this._width,
      height: this._height,
      x: this._x,
      y: this._y - this._height,
      fill: "none",
      stroke: "black",
      strokeWidth: 4
    });
  }
  // protected get visitedTransform() {
  //   return 'scaleX(1.15)';
  // }
  computeLocation() {
  }
  layoutSymbol() {
  }
  /*
     completeLayout() {
    //super.completeLayout();
  }
    */
  completeLayout() {
    const t = this.chart.chartInfo;
    if (this.chart.settings.displayAxis == "x" || this.chart.settings.displayAxis == null) {
      const r = this.index;
      this._y = this.chart.parent.height, this._width = this.chart.parent.width / t.bins, this._x = this.index % t.bins * this._width, this._height = (t.grid[r] - t.axisInfo.yLabelInfo.min) / t.axisInfo.yLabelInfo.max * this._y, this.chart.settings.relativeAxes == "Percentage" && (this._height = this._height / t.grid.reduce((n, i) => n + i)), this._count = t.grid[r], this._id = [
        "datapoint-tile",
        Cr(this.seriesKey),
        `${this._x}`,
        `${this._y}`
      ].join("-");
    } else {
      const r = this.index - length;
      this._x = 0, this._height = this.chart.parent.height / t.bins, this._y = (t.grid.length - r - 1) % t.bins * this._height + this._height, this._width = (t.grid[r] - t.axisInfo.xLabelInfo.min) / t.axisInfo.xLabelInfo.max * this.chart.parent.width, this.chart.settings.relativeAxes == "Percentage" && (this._width = this._width / t.grid.reduce((n, i) => n + i)), this._count = t.grid[r], this._id = [
        "datapoint-tile",
        Cr(this.seriesKey),
        `${this._x}`,
        `${this._y}`
      ].join("-");
    }
  }
  summary() {
    const t = this.paraview.store.model.series.flat()[0].length, r = this.chart.chartInfo.axisInfo.xLabelInfo, n = r.range / this.chart.chartInfo.bins, i = (r.min + n * (this.index % this.chart.chartInfo.bins)).toFixed(2), s = (r.min + n * (this.index % this.chart.chartInfo.bins + 1)).toFixed(2);
    return `This bin contains ${this.count} datapoints, which is ${(100 * this.count / t).toFixed(2)}% of the overall data.
        It spans x values from ${i} to ${s}}`;
  }
  //Note: I'm overriding this for now because at the time of writing JIM doesn't support visualizations with a
  //different number of visible datapoints (treating bins as datapoints in this case) than exist in the dataset
  _createId(...t) {
    return `datapoint-${this.index}`;
  }
  get _d() {
    return ee`
          M${this._x},${this._y}
          v${-1 * this._height}
          h${this._width}
          v${this._height}
          Z`;
  }
  render() {
    let t = "hsl(0, 0%, 0%)", r = this.paraview.store.colors.colorValueAt(0);
    return this.paraview.store.visitedDatapoints.values().some((n) => Zr(n).index === this.index) ? this.chart.settings.displayAxis == "x" || this.chart.settings.displayAxis == null ? Ie`
                    <g>
                        <path
                            d='${this._d}'
                            role="datapoint"
                            stroke-width= '2'
                            fill= '${"hsl(0, 100.00%, 50.00%)"}'
                            stroke= '${t}'
                            id= '${this.id}'
                        ></path>
                        <line x1=${this._x} y1=${this._y} x2=${this._x + this._width} y2=${this._y} stroke="hsl(0, 100.00%, 50.00%)" stroke-width= 2 />
                    </g>
                ` : Ie`
                    <g>
                        <path
                            d='${this._d}'
                            role="datapoint"
                            stroke-width= '2'
                            fill= '${"hsl(0, 100.00%, 50.00%)"}'
                            stroke= '${t}'
                            id= '${this.id}'
                        ></path>
                        <line x1=${this._x} y1=${this._y} x2=${this._x} y2=${this._y - this._height} stroke="hsl(0, 100.00%, 50.00%)" stroke-width= 2 />
                    </g>
                ` : Ie`
                    <path
                        d='${this._d}'
                        role="datapoint"
                        stroke-width= '2'
                        fill= '${r}'
                        stroke= '${t}'
                        id= '${this.id}'
                    ></path>
            `;
  }
}
class rP extends yd {
  constructor(t, r, n, i) {
    super(t, r, n), this.type = i;
  }
  _createId() {
    return super._createId(`${this.type}-highlights`);
  }
  content() {
    var o;
    const t = this.paraview.store.highlightedSelector;
    let r = null, n = [], i = null, s = [];
    return t && (s = this.paraview.documentView.chartInfo.datapointsForSelector(t).map((l) => this._parent.dataLayer.datapointView(l.seriesKey, l.datapointIndex)), t.startsWith("datapoint") ? (n.push(s[0].symbol.clone()), this.paraview.store.settings.chart.showPopups && this.type == "foreground" && s[0].addPopup()) : t.startsWith("sequence") && (n.push(s[0].symbol.clone()), n.push(s.at(-1).symbol.clone()), i = new mo(this.paraview, {
      x: 0,
      y: 0,
      points: [n[0].loc, n[1].loc],
      stroke: this.paraview.store.colors.colorValueAt(n[0].color),
      opacity: 0.5,
      strokeWidth: 20
    }), this.type === "background" && (r = new qr(this.paraview, {
      x: n[0].x,
      y: 0,
      width: n[1].x - n[0].x,
      height: this._height,
      fill: this.paraview.store.colors.colorValueAt(n[0].color),
      opacity: 0.25
    })), this.paraview.store.settings.chart.showPopups && this.type == "foreground" && this.paraview.store.popups.push(...this.parent.popupLayer.addSequencePopups(s))), n.forEach((l) => {
      l.scale *= 3, l.opacity = 0.5, l.fill = "empty";
    }), (o = this.paraview.documentView) == null || o.chartLayers.popupLayer.addPopups()), Ie`
      ${this.paraview.store.visitedDatapoints.values().map((a) => {
      const { seriesKey: l, index: c } = Zr(a);
      return Ie`
            <use
              id="visited-mark-${l}-${c}"
              class="visited-mark"
              href="#${this._parent.dataLayer.datapointDomIds.get(a)}"
            />
          `;
    })}
      ${this.type === "background" && r ? r.render() : ""}
      ${/*overlaySym
            ?
                svg`
                  <use
                    id="highlighted-mark-${datapointViews[0].seriesKey}-${datapointViews[0].index}"
                    class="highlighted-mark"
                    href="#${datapointViews[0].id}-sym"
                  />
                `
    
            : ''*/
    this.type === "foreground" && i ? i.render() : ""}
      ${this.type === "foreground" && n.length ? n.map((a) => a.render()) : ""}
    `;
  }
}
class c4t extends yd {
  _createId() {
    return super._createId("selection");
  }
  get class() {
    return "selected-datapoint-marker";
  }
  content() {
    const t = this._parent.dataLayer;
    return Ie`
      ${this.paraview.store.selectedDatapoints.values().map((r) => t.datapointViewForId(t.datapointDomIds.get(r)).selectedMarker.render())}
    `;
  }
}
const Th = 4, nP = 2;
class u4t extends Zs(Er) {
  constructor(t, r) {
    super(t);
    const n = t.store.settings.ui.focusRingGap;
    let i = r.focusRingShape();
    if (i) {
      i.remove(), i.stroke = "white", i.strokeWidth = Th, i.fill = "none", this.append(i);
      const s = i.clone();
      s.stroke = "black", s.strokeWidth = nP, s.fill = "none", this.append(s);
    } else {
      const s = r.focusRingBbox() ?? r.outerBbox, o = s.left - Th / 2 - n, a = s.top - Th / 2 - n, l = s.width + Th + n * 2, c = s.height + Th + n * 2;
      this.append(new qr(t, {
        x: o,
        y: a,
        width: l,
        height: c,
        stroke: "white",
        strokeWidth: Th,
        fill: "none"
      })), this.append(new qr(t, {
        x: o,
        y: a,
        width: l,
        height: c,
        stroke: "black",
        strokeWidth: nP,
        fill: "none"
      }));
    }
  }
}
class h4t extends yd {
  _createId() {
    return super._createId("focus");
  }
  content() {
    const t = this._parent.dataLayer.focusLeaf, r = this._parent.docView.chartInfo.shouldDrawFocusRing && (this.paraview.store.settings.ui.isLowVisionModeEnabled || this.paraview.store.settings.ui.isFocusRingEnabled) ? new u4t(this.paraview, t) : null;
    return Ie`
      ${r == null ? void 0 : r.render()}
    `;
  }
}
const iP = {
  /** A single rising sequence */
  Rise: "Rising",
  /** A single falling sequence */
  Fall: "Falling",
  /** A single stable sequence */
  Stable: "Stable",
  /** A single sequence that shows a large, rapid increase in value */
  BigJump: "Big Jump",
  /** A single sequence that shows a large, rapid decrease in value */
  BigFall: "Big Fall",
  /** A falling sequence followed by a rising sequence */
  ReversalToRise: "Reversal to Rising",
  /** A rising sequence followed by a falling sequence */
  ReversalToFall: "Reversal to Falling",
  /** A stable sequence followed by a rising sequence */
  EmergingRise: "Emerging Rising",
  /** A stable sequence followed by a falling sequence */
  EmergingFall: "Emerging Falling",
  /** A rising sequence followed by a stable sequence */
  RiseToStable: "Rising to Stable",
  /** A falling sequence followed by a stable sequence */
  FallToStable: "Falling to Stable",
  /** A rising sequence followed by a falling sequence and another rising sequence */
  Rebound: "Rebounding",
  /** A falling sequence followed by a rising sequence and another falling sequence */
  TemporaryJump: "Temporary Jump",
  /** A falling sequence followed by a short rising sequence at the end of the chart */
  PossibleReversalToRise: "Possible Reversal to Rising",
  /** A rising sequence followed by a short falling sequence at the end of the chart */
  PossibleReversalToFall: "Possible Reversal to Falling",
  /** A stable sequence followed by a short rising sequence at the end of the chart */
  PossibleEmergingRise: "Possible Emerging Rising",
  /** A stable sequence followed by a short falling sequence at the end of the chart */
  PossibleEmergingFall: "Possible Emerging Falling",
  /** A rising sequence followed by a short stable sequence at the end of the chart */
  PossibleRiseToStable: "Possible Rising to Stable",
  /** A falling sequence followed by a short stable sequence at the end of the chart */
  PossibleFallToStable: "Possible Falling to Stable",
  /** A rising sequence followed by a falling sequence and another short rising sequence at the end of the chart */
  PossibleRebound: "Possible Rebounding",
  /** A falling sequence followed by a rising sequence and another short falling sequence at the end of the chart */
  PossibleTemporaryJump: "Possible Temporary Jump"
};
class p4t extends yd {
  constructor(t, r, n, i) {
    super(t, r, n), this.type = i, this._groups = /* @__PURE__ */ new Map();
  }
  _createId() {
    return super._createId(`${this.type}-annotation`);
  }
  group(t) {
    return this._groups.get(t);
  }
  addGroup(t, r = !1) {
    if (this._groups.has(t)) {
      if (r)
        return;
      throw new Error(`group '${t}' already exists`);
    }
    this._groups.set(t, new d4t(this.paraview, t)), this.append(this._groups.get(t));
  }
  removeGroup(t, r = !1) {
    if (this._groups.has(t))
      this._groups.delete(t);
    else {
      if (r)
        return;
      throw new Error(`group '${t}' does not exist`);
    }
  }
  addPopups() {
    if (this.addGroup("datapoint-popups", !0), this.group("datapoint-popups").clearChildren(), this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onFocus") {
      this.paraview.store.userLineBreaks.splice(0, this.paraview.store.userLineBreaks.length), this.paraview.store.popups.splice(0, this.paraview.store.popups.length);
      const t = this.paraview.documentView.chartLayers.dataLayer.chartInfo.navMap.cursor, n = t.datapoints.map((s) => this._parent.dataLayer.datapointView(s.seriesKey, s.datapointIndex));
      let i = [];
      if (t.type === "chord")
        i.push(...this.addChordPopups(n));
      else if (t.type === "sequence")
        i.push(...this.addSequencePopups(n));
      else if (t.type === "series")
        i.push(...this.addSeriesPopups(n));
      else
        for (let s of this.paraview.store.visitedDatapoints) {
          const { seriesKey: o, index: a } = Zr(s);
          this.paraview.documentView.chartLayers.dataLayer.datapointView(o, a).addPopup();
        }
      for (let s of i)
        this.paraview.store.popups.push(s);
    } else if (this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onSelect") {
      this.paraview.store.popups.splice(0, this.paraview.store.popups.length);
      for (let t of this.paraview.store.selectedDatapoints) {
        const { seriesKey: r, index: n } = Zr(t);
        this.paraview.documentView.chartLayers.dataLayer.datapointView(r, n).addPopup();
      }
    }
    for (const t of this.paraview.store.popups)
      t.classInfo = { popup: !0 }, this.type === "foreground" ? this.group("datapoint-popups").append(t) : this._groups.has("datapoint-popups") && this.removeGroup("datapoint-popups", !0);
  }
  addChordPopups(t) {
    var o, a, l;
    let r = "";
    for (let c of t)
      r = r.concat(`${c.seriesKey}: ${this.paraview.documentView.chartLayers.dataLayer.chartInfo.summarizer.getDatapointSummary(c.datapoint, "statusBar")}
`);
    const n = t[0], i = (o = this.paraview.documentView) == null ? void 0 : o.chartLayers.dataLayer.chartInfo.popuplegend();
    this.paraview.store.addLineBreak(
      ((a = this.paraview.documentView) == null ? void 0 : a.chartLayers.dataLayer.chartInfo.navMap.cursor.index) / (this.paraview.store.model.series[0].datapoints.length - 1),
      n.index,
      n.seriesKey,
      !1
    ), (l = this.paraview.documentView) == null || l.chartLayers.backgroundAnnotationLayer.render();
    const s = new Il(
      this.paraview,
      {
        text: r,
        x: n.x,
        y: n.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: n.color,
        //margin: 60,
        type: "chord",
        items: i,
        points: t
      },
      {
        fill: "hsl(0, 0%, 100%)",
        stroke: "hsl(0, 0%, 0%)"
      }
    );
    return s.classInfo = { popup: !0 }, [s];
  }
  addSequencePopups(t) {
    const r = t[0];
    let i = (t[t.length - 1].x + r.x) / 2, s = 0;
    if (t.length % 2 == 0) {
      const y = t[t.length / 2 - 1], g = t[t.length / 2];
      s = (y.y + g.y) / 2;
    } else
      s = t[(t.length - 1) / 2].y;
    const o = this.paraview.store.seriesAnalyses[r.seriesKey], a = o.sequences.findIndex((y) => y.start === t[0].index && y.end - 1 === t[t.length - 1].index), l = this.paraview.store.model.series[0].datapoints.map(
      (y) => jr(y.facetBox("x"), this.paraview.store.getFormatType("horizTick"))
    ), c = this.paraview.store.model.series.find((y) => y.key === t[0].seriesKey).datapoints;
    let h = "";
    if (o.sequences[a].message == null) {
      let y = o.sequences[a];
      t[t.length - 1].y - t[0].y > 0 && Math.abs(y.slopeInfo.slope) > 0.2 ? h = h.concat("Falling trend") : t[t.length - 1].y - t[0].y <= 0 && Math.abs(y.slopeInfo.slope) > 0.2 ? h = h.concat("Rising trend") : h = h.concat("Stable trend");
    } else
      h = h.concat(`${iP[o.sequences[a].message]} trend`);
    const u = parseFloat((c[o.sequences[a].end - 1].facetValueAsNumber("y") - c[o.sequences[a].start].facetValueAsNumber("y")).toFixed(4));
    h = h.concat(`
${u > 0 ? "+" : ""}${u}`), h = h.concat(`
${l[o.sequences[a].start]}-${l[o.sequences[a].end - 1]}`), h = h.concat(`
${o.sequences[a].end - o.sequences[a].start} records`);
    const p = new Il(
      this.paraview,
      {
        text: h,
        x: i,
        y: s,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: r.color,
        margin: 60,
        type: "sequence",
        points: t
      },
      {}
    );
    return p.classInfo = { popup: !0 }, [p];
  }
  addSeriesPopups(t) {
    const r = t[0];
    let i = (t[t.length - 1].x + r.x) / 2, s = 0;
    if (t.length % 2 == 0) {
      const p = t[t.length / 2 - 1], y = t[t.length / 2];
      s = (p.y + y.y) / 2;
    } else
      s = t[(t.length - 1) / 2].y;
    const o = this.paraview.store.seriesAnalyses[r.seriesKey], a = this.paraview.store.model.series[0].datapoints.map(
      (p) => jr(p.facetBox("x"), this.paraview.store.getFormatType("horizTick"))
    ), l = this.paraview.store.model.series.find((p) => p.key === t[0].seriesKey).datapoints;
    let c = "";
    c = c.concat(`${t[0].seriesKey}`), (o == null ? void 0 : o.message) == null ? c = c.concat(`
No trend detected`) : c = c.concat(`
${iP[o == null ? void 0 : o.message]} trend`);
    let h = parseFloat((l[l.length - 1].facetValueAsNumber("y") - l[0].facetValueAsNumber("y")).toFixed(4));
    c = c.concat(`
${h > 0 ? "+" : ""}${h}`), c = c.concat(`
${a[0]}-${a[l.length - 1]}`), c = c.concat(`
${l.length} records`);
    const u = new Il(
      this.paraview,
      {
        text: c,
        x: i,
        y: s,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: r.color,
        margin: 60,
        points: t
      },
      {}
    );
    return u.classInfo = { popup: !0 }, [u];
  }
  renderChildren() {
    return super.renderChildren();
  }
}
class d4t extends Zs(Er) {
  constructor(t, r) {
    super(t), this._name = r;
  }
  get name() {
    return this._name;
  }
}
const f4t = {
  bar: g1,
  column: g1,
  line: i3,
  scatter: n4t,
  histogram: l4t,
  heatmap: o4t,
  pie: JI,
  donut: JI,
  gauge: g1,
  //GaugeChart,
  stepline: i3,
  //StepLineChart,
  lollipop: g1,
  //LollipopChart
  graph: i3
};
class g4t extends Er {
  constructor(t, r, n) {
    super(t.paraview), this.docView = t, this._orientation = this.paraview.store.settings.chart.orientation, this.width = r, this.height = n, this._canWidthFlex = !0, this._canHeightFlex = !0, this.createLayers();
  }
  _createId() {
    return "layers";
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    super.parent = t;
  }
  createLayers() {
    this._backgroundHighlightsLayer = new rP(this.paraview, this._width, this._height, "background"), this.append(this._backgroundHighlightsLayer), this._backgroundAnnotationLayer = new KI(this.paraview, this._width, this._height, "background"), this.append(this._backgroundAnnotationLayer), this.createDataLayers(), this._foregroundHighlightsLayer = new rP(this.paraview, this._width, this._height, "foreground"), this.append(this._foregroundHighlightsLayer), this._foregroundAnnotationLayer = new KI(this.paraview, this._width, this._height, "foreground"), this.append(this._foregroundAnnotationLayer), this._selectionLayer = new c4t(this.paraview, this._width, this._height), this.append(this._selectionLayer), this._focusLayer = new h4t(this.paraview, this._width, this._height), this.append(this._focusLayer), this._popupLayer = new p4t(this.paraview, this._width, this._height, "foreground"), this.append(this._popupLayer);
  }
  /** Physical width of the chart; i.e., width onscreen after any rotation. */
  get width() {
    return super.width;
  }
  set width(t) {
    this._orientation === "north" || this._orientation === "south" ? this._logicalWidth = t : this._logicalHeight = t, super.width = t, this._resizeLayers();
  }
  /** Physical height of the chart; i.e., height onscreen after any rotation. */
  get height() {
    return super.height;
  }
  set height(t) {
    this._orientation === "north" || this._orientation === "south" ? this._logicalHeight = t : this._logicalWidth = t, super.height = t, this._resizeLayers();
  }
  get logicalWidth() {
    return this._logicalWidth;
  }
  set logicalWidth(t) {
    this._orientation === "north" || this._orientation === "south" ? this.width = t : this.height = t, this._logicalWidth = t, this._resizeLayers();
  }
  get logicalHeight() {
    return this._logicalHeight;
  }
  set logicalHeight(t) {
    this._orientation === "north" || this._orientation === "south" ? this.height = t : this.width = t, this._logicalHeight = t, this._resizeLayers();
  }
  get orientation() {
    return this._orientation;
  }
  get backgroundHighlightsLayer() {
    return this._backgroundHighlightsLayer;
  }
  get backgroundAnnotationLayer() {
    return this._backgroundAnnotationLayer;
  }
  get dataLayer() {
    return this._dataLayers[0];
  }
  get foregroundHighlightsLayer() {
    return this._foregroundHighlightsLayer;
  }
  get foregroundAnnotationLayer() {
    return this._foregroundAnnotationLayer;
  }
  get selectionLayer() {
    return this._selectionLayer;
  }
  get popupLayer() {
    return this._popupLayer;
  }
  _resizeLayers() {
    this._children.forEach((t) => {
      t.resize(this._logicalWidth, this._logicalHeight);
    });
  }
  resize(t, r) {
    super.resize(t, r), this._orientation === "north" || this._orientation === "south" ? (this._logicalWidth = t, this._logicalHeight = r) : (this._logicalHeight = t, this._logicalWidth = r), this._resizeLayers();
  }
  createDataLayers() {
    const t = f4t[this.paraview.store.type];
    let r;
    if (t)
      r = new t(this.paraview, this._width, this._height, 0, this.docView.chartInfo), this.append(r);
    else
      throw new Error(`no class found for chart type '${this.paraview.store.type}'`);
    this._dataLayers = [r];
  }
  updateLoc() {
  }
  render() {
    this.popupLayer.addPopups();
    let t = ee`translate(${this._x + this._padding.left},${this._y + this._padding.top})`;
    return this._orientation === "east" ? t += ee`
        translate(${this._logicalHeight},${0})
        rotate(90)
      ` : this._orientation === "west" ? t += ee`
        translate(0,${this._logicalHeight})
        rotate(-90)
      ` : this._orientation === "south" && (t += ee`
        translate(0,${this._logicalHeight})
        scale(1,-1)
      `), Ie`
      <g
        id="chart-layers"
        transform=${t}
      >
        <rect
          id="data-backdrop"
          width=${ee`${this._logicalWidth}`}
          height=${ee`${this._logicalHeight}`}
        />
        ${this._backgroundHighlightsLayer.render()}
        ${this._backgroundAnnotationLayer.render()}
        ${this._dataLayers.map((r) => r.render())}
        ${this._foregroundHighlightsLayer.render()}
        ${this._selectionLayer.render()}
        ${this._foregroundAnnotationLayer.render()}
        ${this._focusLayer.render()}
        ${this.popupLayer.render()}
      </g>
    `;
  }
}
class A$ extends Er {
  constructor(t, r) {
    super(t.paraview), this.axis = t, this.length = r, this._classInfo = { "axis-line": !0 };
  }
  get length() {
    return 0;
  }
  set length(t) {
  }
  _createId(...t) {
    return `${this.axis.orientation}-axis-line`;
  }
  render() {
    const t = ee`translate(${this._x},${this._y})`;
    return Ie`
      <path
        transform=${this._x !== 0 || this._y !== 0 ? t : Lt}
        id=${this._id}
        class=${Rr(this._classInfo)}
        d=${this.getLineD()}
      ></path>
    `;
  }
}
class m4t extends A$ {
  constructor(t, r) {
    super(t, r), this._height = 0, this._canWidthFlex = !0;
  }
  get length() {
    return this.width;
  }
  set length(t) {
    this.width = t, super.length = t;
  }
  getLineD() {
    if (this.axis.orientationSettings.line.isDrawOverhang) {
      const t = this.paraview.store.settings.axis.vert.ticks.length, r = this.paraview.store.settings.axis.vert.position === "west" ? -t : 0;
      return ee`M${r},0 h${this.width + t}`;
    } else
      return ee`M0,0 h${this.width}`;
  }
}
class y4t extends A$ {
  constructor(t, r) {
    super(t, r), this._width = 0, this._canHeightFlex = !0;
  }
  get length() {
    return this.height;
  }
  set length(t) {
    this.height = t, super.length = t;
  }
  getLineD() {
    if (this.axis.orientationSettings.line.isDrawOverhang) {
      const t = this.paraview.store.settings.axis.horiz.ticks.length, r = this.paraview.store.settings.axis.horiz.position === "north" ? -t : 0;
      return ee`M0,${r} v${this.height + t}`;
    } else
      return ee`M0,0 v${this.height}`;
  }
}
class S$ extends Zs(Er) {
  constructor(t, r, n, i, s, o) {
    super(o), this.axis = t, this.tickLabels = r, this.tierIndex = n, this._tickStep = s, this._updateSizeFromLength(i), this.createTickLabels();
  }
  resize(t, r) {
    super.resize(t, r), this.createTickLabels();
  }
  get class() {
    return "tick-label-tier";
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    super.parent = t;
  }
  get tickInterval() {
    return this._labelDistance;
  }
  _createId(...t) {
    return `tick-label-tier-${this.axis.orientation}-${this.tierIndex}`;
  }
  _maxLabelWidth() {
    return this._children.length ? Math.max(...this._children.map((t) => t.paddedWidth ?? 0)) : 0;
  }
  _maxLabelHeight() {
    return this._children.length ? Math.max(...this._children.map((t) => t.paddedHeight ?? 0)) : 0;
  }
  createTickLabels(t = !0) {
    const r = this.axis.isInterval ? this.tickLabels.length : this.tickLabels.length - 1;
    this._labelDistance = this._length / (r / this._tickStep), this.clearChildren();
    for (const [n, i] of this.tickLabels.entries()) {
      if (n % this._tickStep)
        continue;
      const s = new ei(this.paraview, {
        id: `tick-label-${this.axis.orientation}-${n}`,
        classList: [
          "tick-label",
          `tick-label-${this.axis.orientation}`,
          this.axis.orientationSettings.position
        ],
        role: "axislabel",
        text: i,
        textAnchor: this._labelTextAnchor,
        wrapWidth: this._labelWrapWidth,
        x: 0,
        y: 0
      });
      this.append(s);
    }
  }
  updateTickLabelIds() {
  }
}
class b4t extends S$ {
  constructor(t, r, n, i, s, o) {
    super(t, r, n, i, s, o), this.axis = t, this.tickLabels = r, this._canWidthFlex = !0, this.padding = { top: this.axis.orientationSettings.ticks.labels.offsetGap };
  }
  _updateSizeFromLength(t) {
    this._width = t;
  }
  get _length() {
    return this._width;
  }
  get _labelTextAnchor() {
    return this.axis.orientationSettings.ticks.labels.angle ? "end" : "middle";
  }
  get _labelWrapWidth() {
    return this._labelDistance;
  }
  computeSize() {
    return [this._width, this._maxLabelHeight()];
  }
  _tickLabelX(t) {
    let r = this._labelDistance * t;
    return this.axis.isInterval && (r += this._labelDistance / this._tickStep / 2), this.axis.orientationSettings.labelOrder === "westToEast" ? r : this._width - r;
  }
  _tickLabelY(t) {
    return this.paraview.store.model.getAxisFacet(this.axis.orientation) ?? this.paraview.store.model.getFacet(this.axis.orientation === "horiz" ? "x" : "y"), this.axis.orientationSettings.position === "north" ? this.height : 0;
  }
  createTickLabels(t = !0) {
    super.createTickLabels(), this._children.forEach((r, n) => {
      this.paraview.store.settings.axis.horiz.ticks.labels.angle && (r.angle = this.axis.orientationSettings.ticks.labels.angle), r.angle === 0 ? (r.top = this._tickLabelY(n), r.centerX = this._tickLabelX(n)) : r.angle > 0 ? r.topLeft = new qt(this._tickLabelX(n), this._tickLabelY(n)) : r.topRight = new qt(this._tickLabelX(n), this._tickLabelY(n));
    }), this.updateSize(), t && (this._tickStep = this._optimizeLabelSpacing(), this.createTickLabels(!1));
  }
  _optimizeLabelSpacing() {
    const t = this._children.map((i) => i.bbox);
    let r = [...t];
    this._children.map((i) => i.locOffset.x);
    let n = this._tickStep;
    for (this._width; ; ) {
      const i = r.slice(1).map((o, a) => o.left - r[a].right), s = Math.min(...i);
      if (Math.round(s) < this.axis.orientationSettings.ticks.labels.gap) {
        if (n++, r = t.filter((a, l) => l % n === 0), !(Math.floor(this.tickLabels.length / n) + this.tickLabels.length % n))
          throw new Error("tick labels will always overlap");
        continue;
      }
      break;
    }
    return n;
  }
}
class v4t extends S$ {
  constructor(t, r, n, i, s, o) {
    super(t, r, n, i, s, o), this.axis = t, this.tickLabels = r, this._canHeightFlex = !0, this.padding = { right: this.axis.orientationSettings.ticks.labels.offsetGap };
  }
  _updateSizeFromLength(t) {
    this._height = t;
  }
  get _length() {
    return this._height;
  }
  get _labelTextAnchor() {
    return "end";
  }
  get _labelWrapWidth() {
  }
  computeSize() {
    return [this._maxLabelWidth(), this._height];
  }
  _tickLabelX(t) {
    return this.axis.orientationSettings.position === "west" ? this.width : 0;
  }
  _tickLabelY(t) {
    const r = this._labelDistance * t;
    return this.axis.orientationSettings.labelOrder === "northToSouth" ? r + this._labelDistance / 2 + this._children[t].height / 3 : this.height - r + this._children[t].height / 3;
  }
  createTickLabels() {
    super.createTickLabels(), this.updateSize(!1), this._children.forEach((t, r) => {
      t.x = this._tickLabelX(r), t.y = this._tickLabelY(r);
    });
  }
}
class _$ extends Er {
  constructor(t, r = !0, n, i, s = !1) {
    super(t), this._major = r, this._orientation = i, this.darken = s, this.length = n;
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    super.parent = t;
  }
  get length() {
    return 0;
  }
  set length(t) {
  }
  _addedToParent() {
    this.updateSize();
  }
  content() {
    const t = this._shouldNegateLength ? -this.length : this.length, r = ee`M${this._x},${this._y}`, n = this._orientation + ee`${t}`;
    return Ie`
      <path
        id=${this.darken ? "grid-zero" : ""}
        class=${Rr(this.classInfo)}
        d=${r + " " + n}
      ></path>
    `;
  }
}
class k$ extends _$ {
  /**
   * @param _pointsTo - The tick starts on the axis and points in this direction.
   * @param major
   */
  constructor(t, r, n = !0, i, s = !1) {
    super(r, n, i, "v", s), this._pointsTo = t;
  }
  get length() {
    return this.height;
  }
  set length(t) {
    this.height = t, super.length = t;
  }
  computeSize() {
    return [
      0,
      // computeSize() initially gets called before the parent is set
      this.height
    ];
  }
}
class C$ extends _$ {
  /**
   * @param _pointsTo - The tick starts on the axis and points in this direction.
   * @param major
   */
  constructor(t, r, n = !0, i, s = !1) {
    super(r, n, i, "h", s), this._pointsTo = t;
  }
  get length() {
    return this.width;
  }
  set length(t) {
    this.width = t, super.length = t;
  }
  computeSize() {
    return [
      // computeSize() initially gets called before the parent is set
      this.width,
      0
    ];
  }
}
class w4t extends k$ {
  get classInfo() {
    return {
      tick: !0,
      "tick-horiz": !0
    };
  }
  get length() {
    return this._major ? super.length : super.length / 2;
  }
  set length(t) {
    super.length = t;
  }
  get _shouldNegateLength() {
    return this._pointsTo === "north";
  }
}
class x4t extends C$ {
  get classInfo() {
    return {
      tick: !0,
      "tick-vert": !0
    };
  }
  get length() {
    return this._major ? super.length : super.length / 2;
  }
  set length(t) {
    super.length = t;
  }
  get _shouldNegateLength() {
    return this._pointsTo === "west";
  }
}
class E4t extends k$ {
  get classInfo() {
    return {
      grid: !0,
      "grid-horiz": !0
    };
  }
  get _shouldNegateLength() {
    return this._pointsTo === "south";
  }
}
class A4t extends C$ {
  get classInfo() {
    return {
      grid: !0,
      "grid-vert": !0
    };
  }
  get _shouldNegateLength() {
    return this._pointsTo === "east";
  }
}
class I$ extends Zs(Er) {
  constructor(t, r, n, i) {
    super(t), this._axisSettings = r, this._majorModulus = n, this._options = i, this._indices = [], this._updateSizeFromLength(this._options.length), this._count = this._options.tickCount, this._options.isInterval, this._computeInterval();
  }
  resize(t, r) {
    super.resize(t, r), this._computeInterval(), this.clearChildren(), this._createTicks();
  }
  // protected _computeCount() {
  //   // XXX CIRCULAR DEPENDENCY between this and computeInterval()
  //   const intervalCount = this._length / this._interval;
  //   this._count = Math.round(intervalCount);
  //   if (this._options.isInterval) {
  //     this._count++;
  //   }
  // }
  _computeInterval() {
    const t = this._options.isInterval ? this._count : this._count - 1;
    this._interval = this._length / (t / this._options.tickStep);
  }
  _addedToParent() {
    this._createTicks();
  }
  /**
   * Overridden by subclasses to set the appropriate size dimension from `length`.
   */
  _updateSizeFromLength(t) {
    this.updateSize();
  }
  _createId(...t) {
    return `${this._options.orientation}-axis-tick-strip`;
  }
  get parent() {
    return this._parent;
  }
  get class() {
    return "tick-strip";
  }
  set parent(t) {
    super.parent = t;
  }
}
class S4t extends I$ {
  constructor(t, r, n, i) {
    super(t, r, n, i), this._ruleXs = [], this._ruleY = 0, this._canWidthFlex = !0;
  }
  computeSize() {
    return [
      this._options.length,
      // NB! The grid lines DON'T COUNT toward the height!
      this._axisSettings.ticks.isDrawTicks || this._options.isDrawOverhang ? this._axisSettings.ticks.length : 0
    ];
  }
  get _length() {
    return this._width;
  }
  _updateSizeFromLength(t) {
    this._width = t, super._updateSizeFromLength(t);
  }
  // resize(width: number, height: number, interval: number) {
  //   this.width = width;
  //   this._gridLineLength = height;
  //   super.resize(width, height, interval);
  // }
  _createTicks() {
    const t = this._options.orthoAxisPosition === "east";
    let r = this._axisSettings.ticks.length;
    this._ruleY = 0, this._axisSettings.position === "north" && (this._ruleY = this._axisSettings.ticks.isDrawTicks || this._options.isDrawOverhang ? r + this._axisSettings.ticks.padding : 0), this._indices = Vo(this._count + (this._options.isInterval ? 1 : 0), (n) => n).filter((n) => n % this._options.tickStep === 0), this.paraview.store.settings.grid.isDrawVertAxisOppositeLine || (this._indices = t ? this._indices.slice(0, -1) : this._indices.slice(1)), this._indices = this._indices.slice(1), this._ruleXs = this._indices.map((n) => t ? this.width - n * this._interval : n * this._interval), this._indices.forEach((n, i) => {
      this.append(new w4t(
        this._axisSettings.position,
        this.paraview,
        n % this._majorModulus === 0,
        r
      )), this._children.at(-1).x = this._ruleXs[i], this._children.at(-1).y = this._ruleY;
    });
  }
  addRules(t) {
    this._indices.forEach((r, n) => {
      this.append(new E4t(
        this._axisSettings.position,
        this.paraview,
        void 0,
        t,
        n === this._options.zeroIndex
      )), this._children.at(-1).x = this._ruleXs[n], this._children.at(-1).y = this._ruleY, this._children.at(-1).hidden = !this.paraview.store.settings.grid.isDrawVertLines;
    });
  }
}
class _4t extends I$ {
  constructor(t, r, n, i) {
    super(t, r, n, i), this._ruleX = 0, this._ruleYs = [], this._canHeightFlex = !0;
  }
  computeSize() {
    return [
      // NB! The grid lines DON'T COUNT toward the width!
      this._axisSettings.ticks.isDrawTicks || this._options.isDrawOverhang ? this._axisSettings.ticks.length : 0,
      this._options.length
    ];
  }
  get _length() {
    return this._height;
  }
  _updateSizeFromLength(t) {
    this._height = t, super._updateSizeFromLength(t);
  }
  // protected _adjustToSizeConstraint() {
  //   this._gridLineLength = width;
  //   this.height = height;
  //   super.resize(width, height, interval);
  // }
  _createTicks() {
    const t = this._options.orthoAxisPosition === "north", r = this._axisSettings.ticks.length;
    this._ruleX = r, this._indices = Vo(this._count, (n) => n), this.paraview.store.settings.grid.isDrawHorizAxisOppositeLine || (this._indices = t ? this._indices.slice(1) : this._indices.slice(0, -1)), this._axisSettings.position === "east" && (this._ruleX = 0), this._ruleYs = this._indices.map((n) => t ? this.height - n * this._interval : n * this._interval), this._indices.forEach((n) => {
      this.append(new x4t(
        this._axisSettings.position,
        this.paraview,
        n % this._majorModulus === 0,
        r
      )), this._children.at(-1).x = this._ruleX, this._children.at(-1).y = this._ruleYs[n];
    });
  }
  addRules(t) {
    this._indices.forEach((r) => {
      this.append(new A4t(
        this._axisSettings.position,
        // XXX don't use `plotWidth` here
        this.paraview,
        void 0,
        t,
        this._indices.length - r - 1 === this._options.zeroIndex
      )), this._children.at(-1).x = this._ruleX, this._children.at(-1).y = this._ruleYs[r], this._children.at(-1).hidden = !this.paraview.store.settings.grid.isDrawHorizLines;
    });
  }
}
class dEt extends Error {
  constructor(t) {
    super(), this.preferredWidth = t;
  }
}
class fEt extends Error {
  constructor(t) {
    super(), this.preferredTickStep = t;
  }
}
class P$ extends Zs(Er) {
  constructor(t, r) {
    super(t.paraview), this.docView = t, this.orientation = r, this._tickLabelTiers = [], this._tickStrip = null, this._store = this.paraview.store, this.chartLayers = t.chartLayers, this._facet = t.chartInfo.axisInfo.getFacetForOrientation(this.orientation), this.datatype = this._facet.datatype, this.settings = dr.getGroupLink(
      this.managedSettingKeys[0],
      this._store.settings
    ), this.orientationSettings = dr.getGroupLink(
      `axis.${r}`,
      this._store.settings
    ), this._tickStep = this.orientationSettings.ticks.step, this._labelInfo = this.coord === "x" ? t.chartInfo.axisInfo.xLabelInfo : t.chartInfo.axisInfo.yLabelInfo, this._isInterval = this.coord === "x" ? !!t.chartInfo.axisInfo.options.isXInterval : !!t.chartInfo.axisInfo.options.isYInterval, this._titleText = this.orientationSettings.title.text ?? "";
  }
  get coord() {
    return this._store.model.facetKeys.find((t) => this._store.model.getFacet(t) === this._facet);
  }
  _createId() {
    return `${this.orientation}-axis`;
  }
  isHoriz() {
    return this.orientation === "horiz";
  }
  isVert() {
    return this.orientation === "vert";
  }
  get asHoriz() {
    if (this.isHoriz())
      return this;
    throw new Error("axis is not horizontal");
  }
  get asVert() {
    if (this.isVert())
      return this;
    throw new Error("axis is not vertical");
  }
  get managedSettingKeys() {
    return [`axis.${this.coord}`];
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    super.parent = t;
  }
  get tickStep() {
    return this._tickStep;
  }
  get isInterval() {
    return this._isInterval;
  }
  get tickLabelTiers() {
    return this._tickLabelTiers;
  }
  get role() {
    return "graphics-object";
  }
  get roleDescription() {
    return `${this.coord}-axis`;
  }
  get extraAttrs() {
    return [
      {
        attr: Zc`data-axistype`,
        value: this.datatype
      }
    ];
  }
  get viewGroup() {
    return this._layout;
  }
  get titleText() {
    return this._titleText;
  }
  // get range() {
  //   return this.chartLayers.getAxisInterval(this.coord);
  // }
  get orthoAxis() {
    return this._orthoAxis;
  }
  set orthoAxis(t) {
    this._orthoAxis = t;
  }
  resize(t, r) {
    this._layout.resize(t, r), super.resize(t, r);
  }
  _childDidResize(t) {
    this.updateSize();
  }
  // settingDidChange(path: string, _oldValue?: Setting, _newValue?: Setting): void {
  //   if (['axis.y.maxValue', 'axis.y.minValue'].includes(path)) {
  //     this._layout.clearChildren();
  //     this.createComponents();
  //     this.layoutComponents();
  //   }
  // }
  createComponents() {
    this.orientationSettings.title.isDrawTitle && this._titleText && (this._createAxisTitle(), this._appendTitle()), this.orientationSettings.ticks.labels.isDrawTickLabels && (this._tickLabelTiers = this._createTickLabelTiers(), this._appendTickLabelTiers()), this.orientationSettings.ticks.isDrawTicks && (this._tickStrip = this._createTickStrip(), this._appendTickStrip()), this.orientationSettings.line.isDrawAxisLine && (this._createAxisLine(), this._appendAxisLine());
  }
  layoutComponents() {
  }
  _createAxisTitle() {
    this._axisTitle = new ei(this.paraview, {
      id: `axis-title-${this.orientation}`,
      text: this.titleText,
      classList: [`axis-title-${this.orientation}`],
      role: "heading",
      angle: this._getAxisTitleAngle()
    }), this._axisTitle.padding = this._getAxisTitlePadding();
  }
  updateTickLabelIds() {
    for (const t of this._tickLabelTiers)
      t.updateTickLabelIds();
  }
  setAxisLabelText(t) {
    this._titleText = t ?? this.orientationSettings.title.text ?? "", this._axisTitle && (this._axisTitle.text = this._titleText);
  }
  _getAxisTitleAngle() {
    return 0;
  }
  addGridRules(t) {
    var r;
    (r = this._tickStrip) == null || r.addRules(t);
  }
}
class k4t extends P$ {
  constructor(t) {
    super(t, "horiz"), this._canWidthFlex = !0, this._layout = new Fu(this.paraview, {
      numCols: 1,
      rowAligns: "end",
      colAligns: "center",
      canWidthFlex: !0,
      width: this.docView.width,
      isAutoHeight: !0
    }, "horiz-axis-layout"), this._layout.isBubbleSizeChange = !0, this.append(this._layout);
  }
  get length() {
    return this._width;
  }
  computeSize() {
    return [
      this._layout.width,
      this._layout.height
    ];
  }
  _appendTitle() {
    this._layout.append(this._axisTitle);
  }
  _createTickLabelTiers() {
    return this._labelInfo.labelTiers.map((t, r) => new b4t(
      this,
      t,
      r,
      this.docView.width,
      this._tickStep,
      this.paraview
    ));
  }
  _appendTickLabelTiers() {
    this._tickLabelTiers.forEach((t, r) => {
      this._layout.splitRowTop(0, "end"), this._layout.append(t);
    });
  }
  _createTickStrip() {
    return new S4t(this.paraview, this.orientationSettings, 1, {
      orientation: this.orientation,
      length: this.docView.width,
      plotWidth: this.docView.width,
      plotHeight: this._layout.height,
      tickCount: this._labelInfo.labelTiers[0].length,
      isInterval: this._isInterval,
      isDrawOverhang: this.paraview.store.settings.axis.vert.line.isDrawOverhang,
      tickStep: this._tickStep,
      orthoAxisPosition: this.paraview.store.settings.axis.vert.position,
      zeroIndex: this._labelInfo.labelTiers[0].findIndex((t) => t === "0") - 1
    });
  }
  _appendTickStrip() {
    this._layout.splitRowTop(0, "end"), this._layout.append(this._tickStrip);
  }
  _createAxisLine() {
    this._axisLine = new m4t(this, this.docView.width);
  }
  _appendAxisLine() {
    this._layout.splitRowTop(0, "end"), this._layout.append(this._axisLine);
  }
  _getAxisTitlePadding() {
    return this.orientationSettings.position === "south" ? { top: this.orientationSettings.title.gap } : { bottom: this.orientationSettings.title.gap };
  }
  layoutComponents() {
    this.orientationSettings.position === "south" && (this._layout.reverseChildren(), this._layout.layoutViews()), super.layoutComponents();
  }
}
class C4t extends P$ {
  constructor(t) {
    super(t, "vert"), this._canHeightFlex = !0, this._layout = new Fu(this.paraview, {
      numCols: 1,
      // new cols will get added as needed
      rowAligns: "center",
      colAligns: "start",
      canHeightFlex: !0,
      height: this.docView.height,
      isAutoWidth: !0
    }, "vert-axis-layout"), this._layout.isBubbleSizeChange = !0, this.append(this._layout);
  }
  get length() {
    return this._height;
  }
  _addedToParent() {
    super._addedToParent();
    const t = this._labelInfo.min, r = this._labelInfo.max;
    this.paraview.store.settingControls.add({
      type: "textfield",
      key: "axis.y.minValue",
      label: "Min y-value",
      options: { inputType: "number" },
      value: this.settings.minValue === "unset" ? t : this.settings.minValue,
      validator: (n) => {
        const i = this.paraview.store.settings.axis.y.maxValue === "unset" ? Math.max(...this.docView.chartInfo.axisInfo.options.yValues) : this.paraview.store.settings.axis.y.maxValue;
        return n >= i ? { err: `Min y-value (${n}) must be less than (${i})` } : {};
      },
      parentView: "controlPanel.tabs.chart.general.minY"
    }), this.paraview.store.settingControls.add({
      type: "textfield",
      key: "axis.y.maxValue",
      label: "Max y-value",
      options: { inputType: "number" },
      value: this.settings.maxValue === "unset" ? r : this.settings.maxValue,
      validator: (n) => {
        const i = this.paraview.store.settings.axis.y.minValue == "unset" ? Math.min(...this.docView.chartInfo.axisInfo.options.yValues) : this.paraview.store.settings.axis.y.minValue;
        return n <= i ? { err: `Max y-value (${n}) must be greater than (${i})` } : {};
      },
      parentView: "controlPanel.tabs.chart.general.maxY"
    });
  }
  computeSize() {
    return [
      this._layout.width,
      this._layout.height
    ];
  }
  _appendTitle() {
    this._layout.append(this._axisTitle);
  }
  _createTickLabelTiers() {
    return this._labelInfo.labelTiers.map((t, r) => new v4t(
      this,
      t,
      r,
      this.docView.height,
      this._tickStep,
      this.paraview
    ));
  }
  _appendTickLabelTiers() {
    this._tickLabelTiers.forEach((t, r) => {
      this._layout.splitColumnRight(r, 0, "start"), this._layout.append(t, {
        x: r + 1
      });
    });
  }
  _createTickStrip() {
    return new _4t(this.paraview, this.orientationSettings, 1, {
      orientation: this.orientation,
      length: this.docView.height,
      plotWidth: this.docView.width,
      plotHeight: this.docView.height,
      tickCount: this._labelInfo.labelTiers[0].length,
      isInterval: this._isInterval,
      isDrawOverhang: this.paraview.store.settings.axis.horiz.line.isDrawOverhang,
      tickStep: this._tickStep,
      orthoAxisPosition: this.paraview.store.settings.axis.horiz.position,
      // XXX could be '0.0' or have a unit, etc.
      zeroIndex: this._labelInfo.labelTiers[0].findIndex((t) => t === "0")
    });
  }
  _appendTickStrip() {
    this._layout.splitColumnRight(this._tickLabelTiers.length, 0, "start"), this._layout.append(this._tickStrip, {
      x: this._layout.numCols - 1
    });
  }
  _createAxisLine() {
    this._axisLine = new y4t(this, this.docView.height);
  }
  _appendAxisLine() {
    this._layout.splitColumnRight(this._tickLabelTiers.length + 1, 0, "start"), this._layout.append(this._axisLine, {
      x: this._layout.numCols - 1
    });
  }
  _getAxisTitlePadding() {
    return this.orientationSettings.position === "west" ? { right: this.orientationSettings.title.gap } : { left: this.orientationSettings.title.gap };
  }
  tickLabelTotalWidth() {
    return this._tickLabelTiers.map((t) => t.width).reduce((t, r) => t + r, 0);
  }
  layoutComponents() {
    this.orientationSettings.position === "west" || this._layout.reverseChildren(), super.layoutComponents();
  }
  _getAxisTitleAngle() {
    return this.orientationSettings.position === "east" ? 90 : -90;
  }
}
const sP = (...e) => {
  const t = [];
  for (let r = 0; r < Math.max(...e.map((n) => n.length)); r++)
    e.forEach((n) => {
      n[r] !== void 0 && t.push(n[r]);
    });
  return t;
};
class m1 extends Zs(Er) {
  constructor(t, r, n = { orientation: "vert" }) {
    super(t), this._items = r, this._options = n, this._markers = [];
  }
  get settings() {
    return dr.getGroupLink("legend", this.paraview.store.settings);
  }
  get classInfo() {
    return { legend: !0 };
  }
  _addedToParent() {
    const t = [], r = this.settings.boxStyle.outline !== "none" || this.settings.boxStyle.fill !== "none";
    this._items.forEach((s) => {
      this._markers.push(new qr(this.paraview, { width: 12, height: 6 })), t.push(this._markers.at(-1)), t.push(ya.fromType(
        this.paraview,
        this.paraview.store.settings.chart.isDrawSymbols ? s.symbol ?? "square.solid" : "square.solid",
        {
          color: s.color,
          pointerEnter: (o) => {
            this.paraview.store.lowlightOtherSeries(s.label);
          },
          pointerLeave: (o) => {
            this.paraview.store.clearAllSeriesLowlights();
          }
        }
      )), t.push(new ei(this.paraview, {
        text: s.label,
        x: 0,
        y: 0,
        textAnchor: "start",
        classList: ["legend-label"],
        pointerEnter: (o) => {
          this.paraview.store.lowlightOtherSeries(s.label);
        },
        pointerLeave: (o) => {
          this.paraview.store.clearAllSeriesLowlights();
        }
      }));
    });
    const n = this.paraview.store.settings.legend.symbolLabelGap, i = this.paraview.store.settings.legend.pairGap;
    if (this._options.orientation === "vert")
      this._grid = new Fu(this.paraview, {
        numCols: 3,
        colGaps: n,
        colAligns: ["center", "center", "start"],
        isAutoWidth: !0,
        isAutoHeight: !0
      }, "legend-grid"), this._grid.padding = r ? this.paraview.store.settings.legend.padding : 0, t.forEach((s) => this._grid.append(s));
    else {
      let s = t.length / 3;
      for (; ; ) {
        const o = sP(
          new Array(s).fill(0),
          new Array(s).fill(n),
          new Array(s - 1).fill(i)
        );
        if (this._grid = new Fu(this.paraview, {
          numCols: s * 3,
          colGaps: o
        }, "legend-grid"), this._grid.padding = r ? this.paraview.store.settings.legend.padding : 0, t.forEach((a) => this._grid.append(a)), this._options.wrapWidth === void 0 || this._grid.paddedWidth <= this._options.wrapWidth || s === 1)
          break;
        s--, t.forEach((a) => a.remove());
      }
      this._grid.colAligns = sP(
        new Array(s).fill("center"),
        new Array(s).fill("start")
      );
    }
    this.append(this._grid), r && this.prepend(new qr(this.paraview, {
      width: this._grid.width,
      height: this._grid.height,
      fill: this.settings.boxStyle.fill,
      stroke: this.settings.boxStyle.outline,
      strokeWidth: this.settings.boxStyle.outlineWidth
    })), this.updateSize();
  }
  computeSize() {
    var t, r;
    return [((t = this._grid) == null ? void 0 : t.paddedWidth) ?? 0, ((r = this._grid) == null ? void 0 : r.paddedHeight) ?? 0];
  }
  content() {
    return this._items.forEach((t, r) => {
      const n = this._markers[r].styleInfo;
      (t.datapointIndex !== void 0 ? this.paraview.store.isVisited(
        this.paraview.store.model.seriesKeys[0],
        t.datapointIndex
      ) : this.paraview.store.isVisitedSeries(t.label)) ? n.fill = this.paraview.store.colors.colorValueAt(-1) : n.fill = "none", this._markers[r].styleInfo = n;
    }), super.content();
  }
}
class I4t extends Zs(Er) {
  constructor(t) {
    super(t.paraview), this._chart = t, this._id = "direct-label-strip", this._createLabels();
  }
  _createLabels() {
    var s;
    const t = this.paraview.store.settings.chart.isDrawSymbols ? this._chart.settings.seriesLabelPadding * 2 : this._chart.settings.seriesLabelPadding, r = this._chart.datapointViews.filter(
      (o) => o.index === this.paraview.store.model.series[0].length - 1
    );
    r.sort((o, a) => o.y - a.y), (s = this.seriesLabels) == null || s.forEach((o) => {
      o.remove();
    }), this.seriesLabels = [], r.forEach((o, a) => {
      this.seriesLabels.push(new ei(this.paraview, {
        text: o.series.label,
        left: t,
        y: o.y,
        classList: ["direct-label"],
        pointerEnter: (l) => {
          this.paraview.store.lowlightOtherSeries(o.seriesKey);
        },
        pointerLeave: (l) => {
          this.paraview.store.clearAllSeriesLowlights();
        }
      })), this.append(this.seriesLabels.at(-1));
    }), this.seriesLabels.forEach((o) => {
      o.y += o.locOffset.y / 2;
    });
    const n = this.seriesLabels[0];
    n.y < 0 && (n.y = 0), this.seriesLabels.at(-1).bottom - this.height, this.resolveSeriesLabelCollisions(r);
  }
  _addedToParent() {
    this.observeNotices();
  }
  noticePosted(t, r) {
    ["animRevealStep", "animRevealEnd"].includes(t) && this._createLabels();
  }
  computeSize() {
    return [
      Math.max(...this.seriesLabels.map((t) => t.right)),
      this._chart.height
    ];
  }
  // XXX I don't think this method will get the job done in all cases
  resolveSeriesLabelCollisions(t) {
    var n, i;
    const r = [];
    for (let s = 1; s < this.seriesLabels.length; s++)
      this.seriesLabels[s].top < this.seriesLabels[s - 1].bottom && (((n = r.at(-1)) == null ? void 0 : n.label) !== this.seriesLabels[s - 1] && r.push({ label: this.seriesLabels[s - 1], endpoint: t[s - 1] }), r.push({ label: this.seriesLabels[s], endpoint: t[s] }));
    if ((i = this.leaders) == null || i.forEach((s) => {
      s.remove();
    }), this.leaders = [], r.length) {
      const s = this.paraview.store.settings.chart.isDrawSymbols ? -this._chart.settings.seriesLabelPadding : 0;
      r.reverse().slice(1).forEach((a, l) => {
        a.label.bottom = r[l].label.top;
      });
      const o = this.seriesLabels.filter((a) => !r.map((l) => l.label).includes(a)).toReversed();
      if (o.length) {
        const l = r.at(-1).label.bottom - o[0].y;
        l < 0 && (o.forEach((c) => c.y -= l), o.at(-1).y < 0 && console.warn("unable to resolve series label collision"));
      }
      r.forEach((a) => {
        a.label.x += this._chart.settings.leaderLineLength + s, this.leaders.push(new P4t(a.endpoint, a.label, this._chart)), this.prepend(this.leaders.at(-1));
      });
    }
  }
}
class P4t extends Er {
  constructor(t, r, n) {
    super(n.paraview), this._endpoint = t, this._chart = n, this._endX = this._chart.paraview.store.settings.type.line.leaderLineLength, this._endY = r.y - r.locOffset.y / 2, this._lineD = ee`
      M${0},${t.y}
      L${this._endX},${this._endY}`;
  }
  get styleInfo() {
    const t = {};
    let r = this._chart.paraview.store.colors.colorValueAt(this._endpoint.seriesProps.color);
    return t.fill = r, t.stroke = r, t;
  }
  get classInfo() {
    return {
      "label-leader": !0,
      lowlight: this.paraview.store.isSeriesLowlighted(this._endpoint.seriesKey)
    };
  }
  content() {
    return Ie`
      <g
        class=${Rr(this.classInfo)}
        style=${ln(this.styleInfo)}
      >
        <path
          d=${this._lineD}
          />
        <circle
          cx=${this._endX}
          cy=${this._endY}
          r="1.8"
        />
      </g>
    `;
  }
}
class R4t extends Zs(Er) {
  constructor(t) {
    super(t), this._directLabelStrip = null, this._legends = {}, this._store = t.store, this.observeNotices(), this.type = this._store.type, this._chartInfo = new z3t[this.type](this.type, this._store, this), this.setTitleText(this._store.title);
    const r = this._parsePadding(this._store.settings.chart.padding), n = Math.max(8 + 1.1 * 16, r.left);
    this.padding = {
      left: n,
      right: r.right,
      top: r.top,
      bottom: r.bottom
    }, this._createGrid();
  }
  _createGrid() {
    var t;
    (t = this._grid) == null || t.remove(), this._grid = new Fu(this.paraview, {
      width: this._store.settings.chart.size.width - this._padding.left - this._padding.right,
      height: this._store.settings.chart.size.height - this._padding.top - this._padding.bottom,
      canWidthFlex: !1,
      canHeightFlex: !1,
      numCols: 4,
      // (this._store.settings.legend.isDrawLegend &&
      // ['east', 'west'].includes(this._store.settings.legend.position))
      // ? 4 : 3,
      rowAligns: "start",
      colAligns: "start"
      // rowGaps: this._store.settings.chart.title.isDrawTitle && this._store.title
      //   ? [this._store.settings.chart.title.margin]
      //   : undefined
    }, "doc-grid"), this.append(this._grid), this.updateSize(), this._populateGrid(), this._grid.layoutViews(), this.setSize(this._grid.paddedWidth, this._grid.paddedHeight, !1);
  }
  /**
   * Parse `padding` like CSS padding (1-4 numbers, same order as CSS)
   */
  _parsePadding(t) {
    const r = t.trim().split(" ");
    if (r.length === 0)
      throw new Error("must supply between 1 and 4 values for chart padding");
    return r.length === 1 ? this._expandPadding(parseFloat(r[0])) : r.length === 2 ? this._expandPadding({
      vert: parseFloat(r[0]),
      horiz: parseFloat(r[1])
    }) : r.length === 3 ? this._expandPadding({
      top: parseFloat(r[0]),
      horiz: parseFloat(r[1]),
      bottom: parseFloat(r[2])
    }) : this._expandPadding({
      top: parseFloat(r[0]),
      right: parseFloat(r[1]),
      bottom: parseFloat(r[2]),
      left: parseFloat(r[3])
    });
  }
  _populateGrid() {
    var o, a;
    this._store.settings.chart.title.isDrawTitle && this._store.title && this.createTitle();
    const t = this._store.settings.axis.horiz.position;
    if (this._chartInfo.axisInfo) {
      if (this._store.settings.axis.horiz.isDrawAxis) {
        this._horizAxis = new k4t(this);
        const l = this._chartInfo.axisInfo.horizFacet;
        this._horizAxis.setAxisLabelText(l.label), this._horizAxis.createComponents(), this._horizAxis.layoutComponents(), this._grid.append(this._horizAxis, {
          x: 1,
          y: (t === "north" ? 0 : 1) + (this._titleLabel ? 1 : 0),
          width: 1,
          rowAlign: "end"
        });
      }
      if (this._store.settings.axis.vert.isDrawAxis) {
        this._vertAxis = new C4t(this);
        const l = this._chartInfo.axisInfo.vertFacet;
        this._vertAxis.setAxisLabelText(l.label), this._vertAxis.createComponents(), this._vertAxis.layoutComponents(), this._grid.append(this._vertAxis, {
          x: 0,
          y: this._titleLabel ? 1 : 0,
          // XXX title might be at bottom
          height: 1,
          rowAlign: t === "north" ? "end" : "start"
        });
      }
      this._titleText = this._store.title ?? this._store.settings.chart.title.text;
    }
    const r = (this._chartInfo.axisInfo && t === "north" ? 1 : 0) + (this._titleLabel ? 1 : 0), n = this._horizAxis ? this._grid.colWidth(1) : this._grid.width, i = this._vertAxis ? this._grid.rowHeight(r) : this._grid.height;
    if (this._chartLayers = new g4t(this, n, i), this._chartLayers.dataLayer.init(), this._grid.append(this._chartLayers, {
      x: 1,
      y: r
    }), this._chartLayers.dataLayer.observeStore(), this._chartLayers.dataLayer.observeNotices(), this._store.settings.chart.hasDirectLabels && this.type === "line" && /*this._chartLayers.dataLayer.settings.isAlwaysShowSeriesLabel || */
    this._store.model.multi) {
      const l = this._store.settings.axis.horiz.position, c = (this._chartInfo.axisInfo && l === "north" ? 1 : 0) + (this._titleLabel ? 1 : 0);
      this._directLabelStrip = new I4t(this._chartLayers.dataLayer), this._grid.append(this._directLabelStrip, {
        x: 2,
        y: c,
        height: 1
      });
    }
    this._shouldAddLegend && this.addLegend(this._store.settings.legend.position), this._chartInfo.axisInfo && ((o = this._horizAxis) == null || o.addGridRules(this._chartLayers.height), (a = this._vertAxis) == null || a.addGridRules(this._chartLayers.width));
  }
  get _shouldAddLegend() {
    return this._store.settings.legend.isDrawLegend && (this._store.settings.legend.isAlwaysDrawLegend || this._directLabelStrip && this._store.settings.chart.hasLegendWithDirectLabels || !this._directLabelStrip && this._store.model.multi);
  }
  settingDidChange(t, r, n) {
    this._chartInfo.settingDidChange(t, r, n), ["chart.size.width", "chart.size.height", "chart.fontScale"].includes(t) && this._createGrid(), super.settingDidChange(t, r, n);
  }
  async storeDidChange(t, r) {
    return await super.storeDidChange(t, r), this._chartInfo.storeDidChange(t, r);
  }
  // noticePosted(key: string, value: any): void {
  //   console.log('NOTICE', key);
  //   if (key === 'animRevealEnd') {
  //     const shouldAddDirectLabelStrip = this._store.settings.chart.hasDirectLabels
  //       && this.type === 'line'
  //       && /*this._chartLayers.dataLayer.settings.isAlwaysShowSeriesLabel || */
  //         this._store.model!.multi;
  //     if (shouldAddDirectLabelStrip) {
  //       const horizAxisPos = this._store.settings.axis.horiz.position;
  //       const plotRow = (this._chartInfo.axisInfo && horizAxisPos === 'north'
  //         ? 1
  //         : 0) + (this._titleLabel ? 1 : 0);
  //       console.log('PLOT ROW', plotRow);
  //       // this._directLabelStrip = new DirectLabelStrip(this._chartLayers.dataLayer as LinePlotView);
  //       // this._grid.append(this._directLabelStrip, {
  //       //   x: 2,
  //       //   y: plotRow,
  //       //   height: 1
  //       // });
  //     }
  //   }
  // }
  get chartInfo() {
    return this._chartInfo;
  }
  _createId() {
    return "doc-view";
  }
  get role() {
    return "graphics-document";
  }
  get roleDescription() {
    return `${this.type} chart`;
  }
  get chartLayers() {
    return this._chartLayers;
  }
  get titleText() {
    return this._titleText;
  }
  setTitleText(t) {
    this._titleText = t ?? this._store.settings.chart.title.text ?? "[TITLE]", this._titleLabel && (this._titleLabel.text = this._titleText);
  }
  get horizAxis() {
    return this._horizAxis;
  }
  get vertAxis() {
    return this._vertAxis;
  }
  get xAxis() {
    return this.getAxisForCoord("x");
  }
  get yAxis() {
    return this.getAxisForCoord("y");
  }
  getAxisForCoord(t) {
    var r, n;
    if (((r = this._horizAxis) == null ? void 0 : r.coord) === t)
      return this._horizAxis;
    if (((n = this._vertAxis) == null ? void 0 : n.coord) === t)
      return this._vertAxis;
    console.log("no axis!", this._horizAxis, this._vertAxis, t);
  }
  /*protected get _hotkeyActions() {
      return hotkeyActions.global;
    }
  
    get keymap() {
      return keymaps.global;
    }*/
  createTitle() {
    const t = this._store.settings.chart.title.align ?? "center";
    this._titleLabel = new ei(this.paraview, {
      id: "chart-title",
      role: "heading",
      classList: ["chart-title"],
      text: this._titleText,
      wrapWidth: this._grid.width,
      justify: t
    }), this._titleLabel.canHeightFlex = !1;
    let r = 0;
    this._store.settings.chart.title.margin, this._store.settings.chart.title.position, this._store.settings.chart.title.position === "top" ? this._grid.insertRow(0, this._store.settings.chart.title.margin) : (this._grid.insertRow(this._grid.numRows, this._store.settings.chart.title.margin), r = this._grid.numRows), this._grid.append(this._titleLabel, {
      x: 0,
      y: r,
      colAlign: t,
      width: 4
      // margin: {
      //   top: titlePos === 'top' ? 0 : titleMargin,
      //   bottom: titlePos === 'bottom' ? 0 : titleMargin
      // }
    });
  }
  computeSize() {
    return [this._grid.width, this._grid.height];
  }
  _childDidResize(t) {
    this.updateSize(!1);
  }
  _boundingSizeDidChange() {
    this.paraview.computeViewBox();
  }
  /*updateAllKeymaps() {
    const update = (v: View) => {
      v.updateKeymap();
      v.children.forEach(update);
    };
    update(this);
  }*/
  addLegend(t) {
    const r = this._chartInfo.legend(), n = this._store.settings.legend.margin;
    t === "east" ? (this._legends.east = new m1(this.paraview, r), this._grid.append(this._legends.east, {
      x: 3,
      y: 1,
      height: 1
      //margin: {left: margin}
    }), this._grid.setColGap(this._directLabelStrip ? 2 : 1, n)) : t === "west" ? (this._legends.west = new m1(this.paraview, r), this._grid.addColumnLeft(), this._grid.append(this._legends.west, {
      x: 0,
      y: 0,
      height: 2
      //margin: {right: margin}
    })) : t === "south" ? (this._legends.south = new m1(this.paraview, r, {
      orientation: "horiz",
      wrapWidth: this._chartLayers.paddedWidth
    }), this._grid.insertRow(this._grid.numRows), this._grid.append(this._legends.south, {
      x: 1,
      y: -1,
      width: 1,
      colAlign: "center"
      //margin: {top: margin}
    })) : t === "north" && (this._legends.north = new m1(this.paraview, r, {
      orientation: "horiz",
      wrapWidth: this._chartLayers.paddedWidth
    }), this._grid.insertRow(this._store.settings.chart.title.isDrawTitle && this._store.title ? 1 : 0), this._grid.append(this._legends.north, {
      x: 1,
      y: 0,
      width: 1,
      colAlign: "center"
      //margin: {bottom: margin}
    }));
  }
}
var T4t = Object.defineProperty, O4t = Object.getOwnPropertyDescriptor, Js = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? O4t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && T4t(t, r, i), i;
};
let ji = class extends ka(zi) {
  constructor() {
    super(), this.type = "bar", this.contrastLevel = 1, this.disableFocus = !1, this._rootRef = we(), this._defsRef = we(), this._frameRef = we(), this._dataspaceRef = we(), this.loadingMessageRectRef = we(), this.loadingMessageTextRef = we(), this.loadingMessageStyles = {
      display: "none"
    }, this._chartRefs = /* @__PURE__ */ new Map(), this._fileSavePlaceholderRef = we(), this._pointerEventManager = null, this._defs = {}, this._jim = "", this._lowVisionModeSaved = /* @__PURE__ */ new Map(), this._hotkeyListener = (e) => {
      const t = this.paraChart.api.actions[e.action];
      t ? t(e.args) : console.warn(`no handler for action '${e.action}'`);
    }, this._jimReadyPromise = new Promise((e, t) => {
      this._jimReadyResolver = e, this._jimReadyRejector = t;
    });
  }
  get viewBox() {
    return this._viewBox;
  }
  get root() {
    return this._rootRef.value;
  }
  get frame() {
    return this._frameRef.value;
  }
  get dataspace() {
    return this._dataspaceRef.value;
  }
  get documentView() {
    return this._documentView;
  }
  get prevFocusLeaf() {
    return this._prevFocusLeaf;
  }
  set prevFocusLeaf(e) {
    this._prevFocusLeaf = e;
  }
  get fileSavePlaceholder() {
    return this._fileSavePlaceholderRef.value;
  }
  get defs() {
    return this._defs;
  }
  async jimReady() {
    await this._jimReadyPromise, this._jimReadyPromise = new Promise((e, t) => {
      this._jimReadyResolver = e, this._jimReadyRejector = t;
    });
  }
  get pointerEventManager() {
    return this._pointerEventManager;
  }
  connectedCallback() {
    super.connectedCallback(), this._controller ?? (this._controller = new Rvt(this._store)), this._storeChangeUnsub = this._store.subscribe(async (e, t) => {
      var r;
      e === "data" && await this.dataUpdated(), await ((r = this._documentView) == null ? void 0 : r.storeDidChange(e, t));
    }), this.computeViewBox(), this._store.keymapManager.addEventListener("hotkeypress", this._hotkeyListener), this._store.settings.chart.isStatic || (this._pointerEventManager = new Tvt(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._storeChangeUnsub(), this._store.keymapManager.removeEventListener("hotkeyPress", this._hotkeyListener);
  }
  // Anything that needs to be done when data is updated, do here
  async dataUpdated() {
    this.createDocumentView(), this.paraChart.headless && await this.addJIMSeriesSummaries(), this._jim = this._store.jimerator ? JSON.stringify(this._store.jimerator.jim, void 0, 2) : "", this._jimReadyResolver();
  }
  willUpdate(e) {
    e.has("width") && this.computeViewBox(), e.has("chartTitle") && this.documentView && this.documentView.setTitleText(this.chartTitle), e.has("xAxisLabel") && this.documentView && this.documentView.xAxis.setAxisLabelText(this.xAxisLabel), e.has("yAxisLabel") && this.documentView && this.documentView.yAxis.setAxisLabelText(this.yAxisLabel);
  }
  firstUpdated(e) {
    this.log("ready"), this.dispatchEvent(new CustomEvent("paraviewready", { bubbles: !0, composed: !0, cancelable: !0 }));
  }
  settingDidChange(e, t, r) {
    var n;
    if ((n = this._documentView) == null || n.settingDidChange(e, t, r), e === "ui.isFullscreenEnabled") {
      if (r && !document.fullscreenElement)
        try {
          this.root.requestFullscreen();
        } catch {
          console.error("failed to enter fullscreen"), this._store.updateSettings((i) => {
            i.ui.isFullscreenEnabled = !1;
          }, !0);
        }
      else if (!r && document.fullscreenElement)
        try {
          document.exitFullscreen();
        } catch {
          console.error("failed to exit fullscreen"), this._store.updateSettings((i) => {
            i.ui.isFullscreenEnabled = !0;
          }, !0);
        }
    } else if (e === "ui.isLowVisionModeEnabled")
      r ? this._store.colors.selectPaletteWithKey("low-vision") : this._store.colors.prevSelectedColor.length > 0 && this._store.colors.selectPaletteWithKey(this._store.colors.prevSelectedColor), this._store.updateSettings((i) => {
        this._store.announce(`Low vision mode ${r ? "enabled" : "disabled"}`), i.color.isDarkModeEnabled = !!r, i.ui.isFullscreenEnabled = !!r, r ? (this._lowVisionModeSaved.set("animation.isAnimationEnabled", i.animation.isAnimationEnabled), this._lowVisionModeSaved.set("chart.fontScale", i.chart.fontScale), this._lowVisionModeSaved.set("grid.isDrawVertLines", i.grid.isDrawVertLines), this._documentView.chartLayers.dataLayer.stopAnimation(), i.animation.isAnimationEnabled = !1, i.chart.fontScale = 2, i.grid.isDrawVertLines = !0) : (i.animation.isAnimationEnabled = this._lowVisionModeSaved.get("animation.isAnimationEnabled"), i.chart.fontScale = this._lowVisionModeSaved.get("chart.fontScale"), i.grid.isDrawVertLines = this._lowVisionModeSaved.get("grid.isDrawVertLines"), this._lowVisionModeSaved.clear());
      });
    else if (e === "ui.isVoicingEnabled")
      if (this._store.settings.ui.isVoicingEnabled)
        if (this._store.settings.ui.isNarrativeHighlightEnabled)
          (async () => this._store.announce(await this._documentView.chartInfo.summarizer.getChartSummary()))();
        else {
          const i = ["Self-voicing enabled."], s = this.paraChart.ariaLiveRegion.lastAnnouncement;
          s && i.push(s), this._store.announce(i);
        }
      else
        this.paraChart.ariaLiveRegion.voicing.shutUp(), this.paraChart.ariaLiveRegion.voicing.speak("Self-voicing disabled.", []);
    else if (e === "ui.isNarrativeHighlightEnabled")
      if (this._store.settings.ui.isNarrativeHighlightEnabled)
        if (this._store.settings.ui.isVoicingEnabled) {
          this.startNarrativeHighlightMode();
          const i = this.paraChart.ariaLiveRegion.lastAnnouncement, s = ["Narrative Highlights Mode enabled."];
          i && s.push(i), this._store.announce(s), (async () => this._store.announce(await this._documentView.chartInfo.summarizer.getChartSummary()))();
        } else {
          this._store.updateSettings((o) => {
            o.ui.isVoicingEnabled = !0;
          }), this.startNarrativeHighlightMode();
          const i = this.paraChart.ariaLiveRegion.lastAnnouncement, s = ["Narrative Highlights Mode enabled."];
          i && s.push(i), this._store.announce(s), (async () => this._store.announce(await this._documentView.chartInfo.summarizer.getChartSummary()))();
        }
      else
        this.endNarrativeHighlightMode(), this._store.updateSettings((i) => {
          i.ui.isVoicingEnabled = !1;
        }), this._store.announce(["Narrative Highlight Mode disabled."]);
    else e === "ui.isNarrativeHighlightPaused" && this.paraChart.ariaLiveRegion.voicing.togglePaused();
  }
  _onFullscreenChange() {
    document.fullscreenElement ? this._store.settings.ui.isFullscreenEnabled || this._store.updateSettings((e) => {
      e.ui.isFullscreenEnabled = !0;
    }, !0) : this._store.settings.ui.isLowVisionModeEnabled ? this._store.updateSettings((e) => {
      e.ui.isLowVisionModeEnabled = !1;
    }) : this._store.settings.ui.isFullscreenEnabled && this._store.updateSettings((e) => {
      e.ui.isFullscreenEnabled = !1;
    }, !0);
  }
  /*protected updated(changedProperties: PropertyValues) {
    this.log('canvas updated');
    if (changedProperties.has('dataState')) {
      if (this.dataState === 'pending') {
        const bbox = this._rootRef.value!.getBoundingClientRect();
        const textLength = bbox.width / 3;
        const fontSize = 20;
        const rectHPadding = 5;
        const rectVPadding = 3;
        const rectWidth = textLength + rectHPadding * 2;
        const rectHeight = fontSize + rectVPadding * 2;
        this.loadingMessageRectRef.value!.setAttribute('x', `${bbox.width / 2 - rectWidth / 2}`);
        this.loadingMessageRectRef.value!.setAttribute('y', `${bbox.height / 2}`);
        this.loadingMessageRectRef.value!.setAttribute('width', `${rectWidth}`);
        this.loadingMessageRectRef.value!.setAttribute('height', `${rectHeight}`);
        this.loadingMessageTextRef.value!.setAttribute('x', `${bbox.width / 2 - textLength / 2}`);
        this.loadingMessageTextRef.value!.setAttribute('y', `${bbox.height / 2 + fontSize}`);
        this.loadingMessageTextRef.value!.setAttribute('textLength', `${textLength}`);
        this.loadingMessageStyles = {
          'font-size': `${fontSize}px`,
          color: 'black'
        };
      } else if (this.dataState === 'complete') {
        this.loadingMessageStyles = {
          display: 'none'
        };
        //this.todo.signalManager.signal('canvasDataLoadComplete');
        // this.isReady = true;
      }
    }
  }*/
  ref(e) {
    return this._chartRefs.has(e) || this._chartRefs.set(e, we()), this._chartRefs.get(e);
  }
  unref(e) {
    if (e.endsWith("*")) {
      const t = e.slice(0, -1);
      for (const r of this._chartRefs.keys())
        r.startsWith(t) && this._chartRefs.delete(r);
    } else if (this._chartRefs.has(e))
      this._chartRefs.delete(e);
    else
      throw new Error(`no ref for key '${e}'`);
  }
  startNarrativeHighlightMode() {
    this._store.updateSettings((e) => {
      e.ui.isVoicingEnabled = !0;
    }), this._store.updateSettings((e) => {
      e.chart.showPopups = !0;
    });
  }
  endNarrativeHighlightMode() {
    this._store.updateSettings((e) => {
      e.ui.isVoicingEnabled = !1, e.chart.showPopups = !1;
    });
  }
  createDocumentView() {
    this.log("creating document view", this.type), this._documentView = new R4t(this), this.computeViewBox(), this.paraChart.styleManager.update();
  }
  computeViewBox() {
    this._viewBox = {
      x: 0,
      y: 0,
      width: this._store.settings.chart.size.width,
      height: this._store.settings.chart.size.height
    }, this.log("view box:", this._viewBox.width, "x", this._viewBox.height);
  }
  updateViewbox(e, t, r, n) {
    this.viewBox.x = e ?? this.viewBox.x, this.viewBox.y = t ?? this.viewBox.y, this.viewBox.width = r ?? this.viewBox.width, this.viewBox.height = n ?? this.viewBox.height;
  }
  // updateDefs(el: SVGLinearGradientElement) {
  //   this._defsRef.value!.appendChild(el);
  // }
  async addJIMSeriesSummaries() {
    var r;
    const e = this._documentView.chartInfo.summarizer, t = ((r = this._store.model) == null ? void 0 : r.seriesKeys) || [];
    for (const n of t) {
      const i = await e.getSeriesSummary(n), s = typeof i == "string" ? i : i.text;
      this._store.jimerator.addSeriesSummary(n, s);
    }
  }
  serialize() {
    var s, o;
    const e = this.root.cloneNode(!0);
    e.id = "para" + (((o = (s = window.crypto).randomUUID) == null ? void 0 : o.call(s)) ?? "");
    const t = this.paraChart.extractStyles(e.id) + `
` + this.extractStyles(e.id), r = document.createElementNS(Fh, "style");
    r.textContent = t, e.prepend(r);
    const n = [], i = (a) => {
      for (const l of a)
        l instanceof Comment ? n.push(l) : l.childNodes.length && i(l.childNodes);
    };
    return i(e.childNodes), n.forEach((a) => a.remove()), e.removeAttribute("width"), e.removeAttribute("height"), e.removeAttribute("role"), new XMLSerializer().serializeToString(e).split(`
`).filter((a) => !a.match(/^\s*$/)).join(`
`);
  }
  downloadSVG() {
    const e = this.serialize(), t = new Blob([e], {
      type: "image/svg+xml;charset=utf-8"
    }), r = URL.createObjectURL(t);
    this.downloadContent(r, "svg"), URL.revokeObjectURL(r);
  }
  downloadPNG() {
    const e = this.serialize(), t = new Blob([e], {
      type: "image/svg+xml;charset=utf-8"
    }), r = URL.createObjectURL(t), n = new Image();
    n.addEventListener("load", () => {
      const i = this._rootRef.value.getBBox(), s = document.createElement("canvas");
      s.width = i.width, s.height = i.height, s.getContext("2d").drawImage(n, 0, 0, i.width, i.height), URL.revokeObjectURL(r), s.toBlob((a) => {
        if (a) {
          const l = URL.createObjectURL(a);
          this.downloadContent(l, "png"), URL.revokeObjectURL(l);
        } else
          throw new Error("failed to create image download blob");
      });
    }), n.src = r;
  }
  downloadContent(e, t) {
    const r = document.createElement("a");
    this.fileSavePlaceholder.appendChild(r);
    const n = this._documentView.titleText || "parachart";
    r.download = `${n.replace(/\W/g, "_")}.${t}`, r.href = e, r.click(), r.remove();
  }
  addDef(e, t) {
    if (this._defs[e])
      throw new Error("view already in defs");
    console.log("ADDING DEF", e), this._defs = { ...this._defs, [e]: t }, this.requestUpdate();
  }
  _rootStyle() {
    const e = {
      fontFamily: this._store.settings.chart.fontFamily,
      fontWeight: this._store.settings.chart.fontWeight
    };
    if (document.fullscreenElement === this.root) {
      const r = Math.round(this._viewBox.width), n = Math.round(this._viewBox.height), i = Math.min(r, n) / Math.max(r, n) * 100;
      r > n ? (e.width = "100vw", e.height = `${i}vh`) : (e.width = `${i}vw`, e.height = "100vh");
    }
    const t = this.store.settings.color.contrastLevel * 50;
    return this._store.settings.color.isDarkModeEnabled ? (e["--axis-line-color"] = `hsl(0, 0%, ${50 + t}%)`, e["--label-color"] = `hsl(0, 0%, ${50 + t}%)`, e["--background-color"] = `hsl(0, 0%, ${(100 - t) / 5 - 10}%)`) : (e["--axis-line-color"] = `hsl(0, 0%, ${50 - t}%)`, e["--label-color"] = `hsl(0, 0%, ${50 - t}%)`), e;
  }
  _rootClasses() {
    return {
      darkmode: this._store.settings.color.isDarkModeEnabled
    };
  }
  navToDatapoint(e, t) {
    this._documentView.chartInfo.navToDatapoint(e, t);
  }
  render() {
    var e, t;
    return this.log("render"), Ht`
      <svg
        role="application"
        tabindex=${this.disableFocus ? -1 : 0}
        aria-label=${this._documentView ? `${this._documentView.titleText}, accessible chart` : "loading..."}
        ${ge(this._rootRef)}
        xmlns=${Fh}
        data-charttype=${this.paraChart.type ?? this.type}
        width=${ee`${this._viewBox.width}px`}
        height=${ee`${this._viewBox.height}px`}
        class=${Rr(this._rootClasses())}
        viewBox=${ee`${this._viewBox.x} ${this._viewBox.y} ${this._viewBox.width} ${this._viewBox.height}`}
        style=${ln(this._rootStyle())}
        @fullscreenchange=${() => this._onFullscreenChange()}
        @focus=${() => {
      this._store.settings.chart.isStatic;
    }}
        @keydown=${(r) => this._controller.handleKeyEvent(r)}
        @pointerdown=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleStart(r);
    }}
        @pointerup=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleEnd(r);
    }}
        @pointercancel=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleCancel(r);
    }}
        @pointermove=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleMove(r);
    }}
        @pointerleave=${(r) => Sbt(this, r) ? void 0 : this.requestUpdate()}
        @click=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleClick(r);
    }}
        @dblclick=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleDoubleClick(r);
    }}
      >
        <defs
          ${ge(this._defsRef)}
        >
          ${Object.entries(this._defs).map(([r, n]) => n)}
          ${(e = this._documentView) != null && e.horizAxis ? Ie`
            <clipPath id="clip-path">
              <rect
                x=${0}
                y=${0}
                width=${this.clipWidth ?? this._documentView.chartLayers.width}
                height=${this._documentView.chartLayers.height}>
              </rect>
            </clipPath>
          ` : ""}
        </defs>
        <metadata data-type="text/jim+json">
          ${this._jim}
        </metadata>
        <rect
          ${ge(this._frameRef)}
          id="frame"
          class=${Lt}
          pointer-events="all"
          x="0"
          y="0"
          width="100%"
          height="100%"
        >
        </rect>
        ${((t = this._documentView) == null ? void 0 : t.render()) ?? ""}
      </svg>
      <div
        ${ge(this._fileSavePlaceholderRef)}
        hidden
      ></div>
    `;
  }
};
ji.styles = [
  //styles,
  Te`
      #frame {
        fill: var(--background-color);
        stroke: none;
      }
      #frame.pending {
        fill: lightgray;
      }
      .darkmode {
        --axis-line-color: ghostwhite;
        --label-color: ghostwhite;
        --background-color: black;
      }
      #loading-message {
        fill: black;
      }
      #loading-message text {
        fill: white;
      }
      .grid-horiz {
        stroke: var(--axis-line-color);
        opacity: 0.2;
      }
      .grid-vert {
        stroke: var(--axis-line-color);
        opacity: 0.2;
      }
      #grid-zero {
        opacity: 0.6;
        stroke-width: 2;
      }
      .tick {
        stroke: var(--label-color);
      }
      .chart-title {
        font-size: calc(var(--chart-title-font-size)*var(--chart-font-scale));
      }
      .axis-title-horiz {
        font-size: calc(var(--horiz-axis-title-font-size)*var(--chart-font-scale));
      }
      .axis-title-vert {
        font-size: calc(var(--vert-axis-title-font-size)*var(--chart-font-scale));
      }
      .direct-label {
        font-size: calc(var(--direct-label-font-size)*var(--chart-font-scale));
      }
      .legend-label {
        font-size: calc(var(--legend-label-font-size)*var(--chart-font-scale));
      }
      .label {
        fill: var(--label-color);
        stroke: none;
      }
      .label-bg {
        fill: lightgray;
      }
      .tick-label-horiz {
        font-size: calc(var(--horiz-axis-tick-label-font-size)*var(--chart-font-scale));
      }
      .tick-label-vert {
        font-size: calc(var(--vert-axis-tick-label-font-size)*var(--chart-font-scale));
      }
      .bar-label {
        font-size: calc(var(--bar-label-font-size)*var(--chart-font-scale));
        fill: white;
      }
      .bar-total-label {
        font-size: calc(var(--bar-label-font-size)*var(--chart-font-scale));
      }
      .column-label {
        font-size: calc(var(--column-label-font-size)*var(--chart-font-scale));
        fill: white;
      }
      .column-total-label {
        font-size: calc(var(--column-label-font-size)*var(--chart-font-scale));
                background-color: red;
      }
      .pastry-inside-label {
      }
      .pastry-outside-label-leader {
        fill: none;
        stroke-width: 2;
      }
      .pastry-slice {
        stroke: white;
        stroke-width: 2;
      }
      .label-leader {
        stroke-width: 2;
      }
      #vert-axis-line {
        fill: none;
        stroke: var(--axis-line-color);
        stroke-width: 2px;
        stroke-linecap: round;
      }
      #horiz-axis-line {
        fill: none;
        stroke: var(--axis-line-color);
        opacity: 1;
        stroke-width: 2px;
        stroke-linecap: round;
      }
      rect#data-backdrop {
        stroke: none;
        fill: none; /*lightgoldenrodyellow;*/
        /*opacity: 0.5;*/
        pointer-events: all;
      }
      .symbol {
        /*stroke-width: 2;*/
        stroke-linejoin: round;
      }
      .symbol.outline {
        fill: white;
      }
      use.visited-mark {
       pointer-events: none;
      }
      .bar {
        stroke-width: 0;
      }
      .data-line {
        fill: none;
        /*stroke-width: 3px;*/
        stroke-linecap: round;
      }
      .range-highlight {
        fill: silver;
        opacity: 0.5;
      }
      .linebreaker-marker {
        fill: hsl(0, 17.30%, 37.50%);
      }
      .user-linebreaker-marker {
        fill: hsl(0, 87%, 48%);
      }
      .trend-line{
        display: inline;
        stroke-width: 8px;
        stroke-linecap: butt;
        stroke-dasharray: 12 12;
        stroke-opacity: 0.8;
      }
      .user-trend-line{
        display: inline;
        stroke-width: 8px;
        stroke-linecap: butt;
        stroke-dasharray: 12 12;
        stroke-opacity: 0.8;
      }
      .datapoint.visited:not(.highlighted) {
        stroke: var(--visited-color);
        fill: var(--visited-color);
        stroke-width: var(--visited-stroke-width);
      }
      .datapoint.highlighted {
/*        stroke: var(--highlighted-color);
        fill: var(--highlighted-color);
        stroke-width: var(--visited-stroke-width); */
      }
      .lowlight {
        opacity: 0.20;
      }
      .hidden {
        display: none;
      }
      .invis {
        opacity: 0;
      }
      .control-column {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-start;
        gap: 0.5em;
      }
      .debug-grid-territory {
        fill: lightblue;
        stroke: blue;
        stroke-width: 2;
        opacity: 0.5;
      }
    `
];
Js([
  Qt()
], ji.prototype, "type", 2);
Js([
  Qt()
], ji.prototype, "chartTitle", 2);
Js([
  Qt()
], ji.prototype, "xAxisLabel", 2);
Js([
  Qt()
], ji.prototype, "yAxisLabel", 2);
Js([
  Qt()
], ji.prototype, "contrastLevel", 2);
Js([
  Qt({ type: Boolean })
], ji.prototype, "disableFocus", 2);
Js([
  Qt()
], ji.prototype, "clipWidth", 2);
Js([
  Lr()
], ji.prototype, "loadingMessageStyles", 2);
Js([
  Lr()
], ji.prototype, "_defs", 2);
Js([
  Lr()
], ji.prototype, "_jim", 2);
ji = Js([
  Oe("para-view")
], ji);
class R$ extends ka(zi) {
  connectedCallback() {
    super.connectedCallback(), this._controlsState = new c5(this, this._store.settingControls);
  }
}
const hS = class hS extends R$ {
  get controlPanel() {
    return this._controlPanel;
  }
  set controlPanel(t) {
    this._controlPanel = t, this.store = t.store;
  }
};
hS.styles = [
  Te`
      .tab-content {
        display: flex;
        flex-direction: row;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
        padding: 0.2rem;
      }

      .tab-content.stacked {
        flex-direction: column;
        gap: 0.1rem;
        align-items: flex-start;
        justify-content: space-between;
        padding: 0.5rem 0.2rem;
      }
    `
];
let pn = hS;
var L4t = Object.getOwnPropertyDescriptor, M4t = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? L4t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let J4 = class extends pn {
  render() {
    return Ht`   
      <div class="tab-content">
        <div
          class="setting-views"
        >
          <slot name="settings">
            <span id="settings"> </span>
          </slot>
        </div>
      </div>
    `;
  }
};
J4.styles = [
  //styles,
  Te`
    `
];
J4 = M4t([
  Oe("para-analysis-panel")
], J4);
var N4t = Object.getOwnPropertyDescriptor, D4t = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? N4t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let X4 = class extends pn {
  constructor() {
    super();
  }
  showAnnotations() {
    return Ht`
      <ol class="annotations">
        ${this._store.annotations.map((e) => Ht`
            <li
              data-series="${e.seriesKey}"
              data-index="${e.index}"
              @click=${(t) => {
      e.isSelected = !e.isSelected, this._selectAnnotation(t);
    }}
              @dblclick=${(t) => {
      this._store.annotations = this._store.annotations.filter((r) => r.id != e.id);
    }}
            >${e.annotation}</li>
          `)}
      </ol>
    `;
  }
  _selectAnnotation(e) {
    const t = e == null ? void 0 : e.target;
    if (t && (this._highlightAnnotation(t), t.dataset.series && t.dataset.index)) {
      const r = t.dataset.series, n = parseInt(t.dataset.index);
      this._navToAnnotation(r, n);
    }
  }
  _highlightAnnotation(e) {
    var t;
    for (const r of (t = e.parentElement) == null ? void 0 : t.children)
      r.classList.remove("selected");
    e.classList.add("selected"), e.scrollIntoView(!1);
  }
  _navToAnnotation(e, t) {
    this._controlPanel.paraChart.paraView.navToDatapoint(e, t);
  }
  render() {
    return Ht`
      <div id="annotation-tab" class="tab-content">
        <section id="annotations">
          ${this.showAnnotations()}
        </section>
        <div>
          <button
            @click=${() => {
      this._store.addAnnotation();
    }}
          >
            Add Annotation
          </button>
        </div>
        <div> 
          <button
            @click=${() => {
      this._store.addUserLineBreaks();
    }}
          >
            Add Line breaks
          </button>
        </div>
         <div>
          <button
            @click=${() => {
      this._store.clearUserLineBreaks(), this._store.clearUserTrendLines();
    }}
          >
            Remove added line breaks
          </button>
        </div>
         <div>
          <button
            @click=${() => {
      this._store.updateSettings((e) => {
        e.controlPanel.isMDRAnnotationsVisible = !this._store.settings.controlPanel.isMDRAnnotationsVisible;
      }), this._store.showMDRAnnotations();
    }}
          >
            Show Trend Annotations
          </button>
        </div>
      </div>
    `;
  }
};
X4.styles = [
  ...pn.styles,
  Te`
      :host {
        --zebraStripe: hsl(0, 0%, 85%);
      }

      ol.annotations {
        padding-inline-start: 1.5rem;
        max-height: 6rem;
        overflow-y: scroll;
      }

      ol.annotations li {
        cursor: pointer;
        padding: 4px;
      }

      ol.annotations li:nth-child(even) {
        background-color: var(--zebraStripe);
      }

      ol.annotations li.selected {
        font-weight: bold;
        background-color: var(--theme-color-light);
      }
    `
];
X4 = D4t([
  Oe("para-annotation-panel")
], X4);
var B4t = Object.defineProperty, j4t = Object.getOwnPropertyDescriptor, T$ = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? j4t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && B4t(t, r, i), i;
};
let Ry = class extends R$ {
  constructor() {
    super(...arguments), this._dialogRef = we(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isNotificationEnabled",
      label: "Notification sounds",
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "slider",
      key: "sonification.hertzLower",
      label: "Lower hertz",
      options: {
        min: 0,
        max: N4.length - 1,
        highBound: this._store.settings.sonification.hertzUpper - 1,
        step: 1
      },
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "slider",
      key: "sonification.hertzUpper",
      label: "Upper hertz",
      options: {
        min: 0,
        max: N4.length - 1,
        lowBound: this._store.settings.sonification.hertzLower + 1,
        step: 1
      },
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isRiffEnabled",
      label: "Series riff enabled",
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isArpeggiateChords",
      label: "Chords are arpeggiated",
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "slider",
      key: "sonification.riffSpeedIndex",
      label: "Riff speed",
      options: {
        min: 0,
        max: ZF.length - 1,
        step: 1
      },
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    });
  }
  render() {
    return Ht`
      <fizz-dialog
        ${ge(this._dialogRef)}
        title="Sonification Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        ${this._store.settingControls.getContent("controlPanel.tabs.audio.sonification.dialog")}
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show();
  }
};
Ry.styles = Te`
  `;
T$([
  Qt()
], Ry.prototype, "btnText", 2);
Ry = T$([
  Oe("para-soni-settings-dialog")
], Ry);
var F4t = Object.defineProperty, $4t = Object.getOwnPropertyDescriptor, O$ = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? $4t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && F4t(t, r, i), i;
};
let Ty = class extends ka(zi) {
  constructor() {
    super(...arguments), this._dialogRef = we(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "radio",
      key: "controlPanel.tabLabelStyle",
      label: "Tab label style",
      options: {
        buttons: {
          icon: {
            label: "Icon only"
          },
          iconLabel: {
            label: "Icon and label"
          },
          label: {
            label: "Label only"
          }
        },
        layout: "horiz"
      },
      parentView: "controlPanel.tabs.controls.dialog.tabLabels"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.isCaptionVisible",
      label: "Caption visible",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.isExplorationBarVisible",
      label: "Exploration bar visible",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.caption.isCaptionExternalWhenControlPanelClosed",
      label: "Caption external when control panel closed",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.caption.isExplorationBarBeside",
      label: "Exploration bar is beside caption",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    });
  }
  render() {
    return Ht`
      <fizz-dialog
        ${ge(this._dialogRef)}
        title="Advanced Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        <div id="controls">
          <div id="advanced"
            class="advanced-views"
          >
            ${this._store.settingControls.getContent("controlPanel.tabs.controls.dialog.settings")}
          </div>
          <div>
            ${this._store.settingControls.getContent("controlPanel.tabs.controls.dialog.tabLabels")}
          </div>
        </div>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
Ty.styles = Te`
    #controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  `;
O$([
  Qt()
], Ty.prototype, "btnText", 2);
Ty = O$([
  Oe("para-advanced-control-settings-dialog")
], Ty);
var z4t = Object.defineProperty, V4t = Object.getOwnPropertyDescriptor, L$ = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? V4t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && z4t(t, r, i), i;
};
let Oy = class extends ka(zi) {
  constructor() {
    super(...arguments), this._dialogRef = we(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.expandPoints",
      label: "Expand points vertically?",
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "animation.animateRevealTimeMs",
      label: "Animation rate",
      options: {
        inputType: "number",
        min: 0,
        max: 1e4
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "radio",
      key: "animation.animationType",
      label: "Animation type",
      options: {
        buttons: {
          uniform: {
            label: "Uniform"
          },
          progressive: {
            label: "Progressive"
          }
        },
        layout: "horiz"
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "radio",
      key: "animation.animationOrigin",
      label: "Animation origin",
      options: {
        buttons: {
          baseline: {
            label: "Bottom"
          },
          top: {
            label: "Top"
          },
          initialValue: {
            label: "Initial Value"
          },
          custom: {
            label: "Custom"
          }
        },
        layout: "horiz"
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "animation.animationOriginValue",
      label: "Animation origin value",
      options: {
        inputType: "number",
        min: 0,
        max: 1e4
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.lineSnake",
      label: "Snake lines from left?",
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.symbolPopIn",
      label: "Pop in symbols?",
      parentView: "controlPanel.tabs.controls.dialog.animation"
    });
  }
  render() {
    return Ht`
      <fizz-dialog
        ${ge(this._dialogRef)}
        title="Animation Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        <div id="animation-controls">
          ${this._store.settingControls.getContent("controlPanel.tabs.controls.dialog.animation")}
        </div>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
Oy.styles = Te`
    #animation-controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  `;
L$([
  Qt()
], Oy.prototype, "btnText", 2);
Oy = L$([
  Oe("para-animation-dialog")
], Oy);
var U4t = Object.getOwnPropertyDescriptor, H4t = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? U4t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let t6 = class extends pn {
  constructor() {
    super(...arguments), this._soniDialogRef = we();
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "checkbox",
      key: "ui.isVoicingEnabled",
      label: "Self-voicing mode",
      parentView: "controlPanel.tabs.audio.voicing"
    }), this._store.settingControls.add({
      type: "slider",
      key: "ui.speechRate",
      label: "Speech rate",
      options: {
        min: 0.5,
        max: 2,
        step: 0.1,
        percent: !0
      },
      parentView: "controlPanel.tabs.audio.voicing"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "ui.isAnnouncementEnabled",
      label: "Announce to screen reader",
      parentView: "controlPanel.tabs.audio.voicing"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isSoniEnabled",
      label: "Sonification mode",
      parentView: "controlPanel.tabs.audio.sonification"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "ui.isNarrativeHighlightEnabled",
      label: "Narrative Highlights mode",
      parentView: "controlPanel.tabs.audio.narrative"
    }), this._store.settingControls.add({
      type: "button",
      key: "ui.isNarrativeHighlightPaused",
      label: "Play/Pause Narrative Highlights",
      parentView: "controlPanel.tabs.audio.narrative"
    });
  }
  render() {
    return Ht`   
      <div class="tab-content">
        <section id="voicing">
          ${this._store.settingControls.getContent("controlPanel.tabs.audio.voicing")}
        </section>
        <section id="narrative">
          ${this._store.settingControls.getContent("controlPanel.tabs.audio.narrative")}
        </section>
        <section id="sonification">
          ${this._store.settingControls.getContent("controlPanel.tabs.audio.sonification")}
          <button
            @click=${() => {
      var e;
      return (e = this._soniDialogRef.value) == null ? void 0 : e.show();
    }}
          >
            Sonification Controls
          </button>
        </section>
      </div>
      <para-soni-settings-dialog
        ${ge(this._soniDialogRef)}
        id="sonification-settings-dialog"
        .store=${this._store}
      ></para-soni-settings-dialog>
    `;
  }
};
t6.styles = [
  ...pn.styles,
  Te`
      #voicing, 
      #sonification,
      #narrative,
      .control-column {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-start;
        align-items: center;
        gap: 0.5em;
      }
    `
];
t6 = H4t([
  Oe("para-audio-panel")
], t6);
var G4t = Object.getOwnPropertyDescriptor, Q4t = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? G4t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let e6 = class extends pn {
  constructor() {
    super(...arguments), this._popupDialogRef = we();
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "slider",
      key: "chart.fontScale",
      label: "Font scale",
      options: {
        min: 0.5,
        max: 3,
        step: 0.1,
        showValue: !0
      },
      parentView: "controlPanel.tabs.chart.fonts"
    });
  }
  render() {
    const e = this._store.settingControls.getContent("controlPanel.tabs.chart.chart"), t = this._store.settingControls.getContent("controlPanel.tabs.chart.popups"), r = this._store.settingControls.getContent("controlPanel.tabs.chart.fonts");
    return Ht`
      <section id="panel">
        <div id="columns">
          <div id="width">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.width")}
          </div>
          <div id="height">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.height")}
          </div>
          <div id="min-y">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.minY")}
          </div>
          <div id="max-y">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.maxY")}
          </div>
          ${e.map((n) => Ht`
            <div>
              ${n}
            </div>
          `)}
          ${t.map((n) => Ht`
            <div>
              ${n}
            </div>
          `)}

          <section id="popups">
            <button
              @click=${() => {
      var n;
      (n = this._popupDialogRef.value) == null || n.show();
    }}
            >
              Popup settings
            </button>
            <para-popup-settings-dialog
              ${ge(this._popupDialogRef)}
              id="popup-settings-dialog"
              .store=${this._store}
            >
            </para-popup-settings-dialog>
          </section>
        </div>
        <div>
          ${r}
        </div>
      </section>
    `;
  }
};
e6.styles = [
  ...pn.styles,
  Te`
      #columns {
        display: grid;
        grid-template-columns: repeat(4, 9rem);
        padding: 0.25rem;
        column-gap: 0.5rem;
        row-gap: 0.5rem;
        align-items: center;
      }
      #width {
        grid-row: 1;
        grid-column: 1;
      }
      #height {
        grid-row: 2;
        grid-column: 1;
      }
      #min-y {
        grid-row: 1;
        grid-column: 2;
      }
      #max-y {
        grid-row: 2;
        grid-column: 2;
      }
      #panel {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: center;
      }
    `
];
e6 = Q4t([
  Oe("para-chart-panel")
], e6);
const W4t = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eNormal%20Color%20Vision%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(240,%20100%25,%2043%25);%20}%20.medium%20{%20fill:%20hsl(106,%2058%25,%2041%25);%20}%20.long%20{%20fill:%20hsl(5,%2083%25,%2053%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e", q4t = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eDeutan%20(Green-Red)%20Color%20Vision%20Deficiency%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(240,%20100%25,%2043%25);%20}%20.medium%20{%20fill:%20none;%20stroke:%20hsl(106,%2058%25,%2041%25);%20stroke-width:%2010px;%20}%20.long%20{%20fill:%20hsl(5,%2083%25,%2053%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M48,71.373C30.563,71.373%2014.622,62.651%205.199,48C14.622,33.349%2030.563,24.627%2048,24.627C65.436,24.627%2081.378,33.349%2090.801,48C81.378,62.651%2065.436,71.373%2048,71.373Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e", Y4t = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eProtan%20(Red-Green)%20Color%20Vision%20Deficiency%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(240,%20100%25,%2043%25);%20}%20.medium%20{%20fill:%20hsl(106,%2058%25,%2041%25);%20}%20.long%20{%20fill:%20none;%20stroke:%20hsl(5,%2083%25,%2053%25);%20stroke-width:%2010px;%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M48,71.373C30.563,71.373%2014.622,62.651%205.199,48C14.622,33.349%2030.563,24.627%2048,24.627C65.436,24.627%2081.378,33.349%2090.801,48C81.378,62.651%2065.436,71.373%2048,71.373Z'/%3e%3c/svg%3e", K4t = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eTriatan%20(Blue-Yellow)%20Color%20Vision%20Deficiency%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20none;%20stroke:%20hsl(240,%20100%25,%2043%25);%20stroke-width:%2010px;%20}%20.medium%20{%20fill:%20hsl(106,%2058%25,%2041%25);%20}%20.long%20{%20fill:%20hsl(5,%2083%25,%2053%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M48,71.373C30.563,71.373%2014.622,62.651%205.199,48C14.622,33.349%2030.563,24.627%2048,24.627C65.436,24.627%2081.378,33.349%2090.801,48C81.378,62.651%2065.436,71.373%2048,71.373Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e", Z4t = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eNormal%20Color%20Vision%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(0,%200%25,%2047%25);%20}%20.medium%20{%20fill:%20hsl(0,%200%25,%2035%25);%20}%20.long%20{%20fill:%20hsl(0,%200%25,%2020%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e";
var J4t = Object.getOwnPropertyDescriptor, X4t = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? J4t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let r6 = class extends pn {
  connectedCallback() {
    super.connectedCallback();
    const e = this._store.colors.palettes.filter((t) => !t.cvd).map((t) => t.key);
    this._store.settingControls.add({
      type: "checkbox",
      key: "color.isDarkModeEnabled",
      label: "Dark mode",
      parentView: "controlPanel.tabs.color.colorContrast"
    }), this._store.settingControls.add({
      type: "slider",
      key: "color.contrastLevel",
      label: "Contrast",
      options: {
        min: 0,
        max: 1,
        step: 0.1,
        percent: !0,
        compact: !0
      },
      parentView: "controlPanel.tabs.color.colorContrast"
    }), this._store.settingControls.add({
      type: "radio",
      key: "color.colorVisionMode",
      label: "Chart colors for CVD (color blindness)",
      options: {
        buttons: {
          normal: {
            label: "Normal",
            title: "Trichromat color vision",
            icon: W4t
          },
          deutan: {
            label: "Deutan",
            title: "Green-red color blindness",
            icon: q4t
          },
          protan: {
            label: "Protan",
            title: "Red-green color blindness",
            icon: Y4t
          },
          tritan: {
            label: "Tritan",
            title: "Blue-yellow color blindness",
            icon: K4t
          },
          grayscale: {
            label: "Gray",
            title: "Grayscale printing or achromotopsia",
            icon: Z4t
          }
        }
      },
      parentView: "controlPanel.tabs.color.colorVision"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: "color.colorPalette",
      label: "Color palette:",
      options: { options: e },
      parentView: "controlPanel.tabs.color.colorPalette"
    }), this._state = new c5(this, this._store.settingControls);
  }
  render() {
    return Ht`
      <div class="tab-content">
        <div class="control-column">
          ${this._store.settingControls.getContent("controlPanel.tabs.color.colorContrast")}

          ${this.controlPanel.settings.isColorPaletteControlVisible ? this._store.settingControls.getContent("controlPanel.tabs.color.colorPalette") : Lt}
        </div>
        ${this.controlPanel.settings.isCVDControlVisible ? Ht`
            <div>
              ${this._store.settingControls.getContent("controlPanel.tabs.color.colorVision")}
            </div>
          ` : Lt}
      </div>
    `;
  }
};
r6.styles = [
  ...pn.styles,
  Te`
      #setting-colorcontrastlevel {
        --width: 6rem;
      }
    `
];
r6 = X4t([
  Oe("para-colors-panel")
], r6);
var t6t = Object.getOwnPropertyDescriptor, e6t = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? t6t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let n6 = class extends pn {
  constructor() {
    super(...arguments), this._advancedControlDialogRef = we(), this._animationDialogRef = we();
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "button",
      key: "ui.isFullscreenEnabled",
      label: "Fullscreen",
      parentView: "controlPanel.tabs.controls.fullscreen"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.isAnimationEnabled",
      label: "Animation enabled",
      parentView: "controlPanel.tabs.controls.animation"
    });
  }
  _getHelp() {
    return Ht`
      <p>ParaCharts is an accessible data visualization app with multimodal features for different disabilities. You can explore it using the mouse, touchscreen, or keyboard.</p>
      <ul>
        <li>Navigate using the arrow keys:
          <ul>
            <li><b>Right or left arrow keys</b>: move to the next or previous data point in this series</li>
            <li><b>Up or down arrow keys</b>: move to the previous or next data series</li>
          </ul>
        </li>
        <li><b>Enter key</b>: select current data point</li>
        <li><b>Shift + Enter key</b>: add current data point to selection</li>
        <li><b>Q key</b>: get more information about this data point or series, and compare selected data points</li>
        <li><b>S key</b>: toggle sonification on or off</li>
        <li><b>V key</b>: toggle self-voicing on or off</li>
        <li><b>L key</b>: low vision mode</li>
        <li><b>C key</b>: chord mode</li>
        <li>High/low jump keys:
          <ul>
            <li><b>] (right bracket) key</b>: jump to the highest data point in this series</li>
            <li><b>Shift + ] (right bracket) key</b>: jump to the highest data point in the chart</li>
            <li><b>[ (left bracket) key</b>: jump to the lowest data point in this series</li>
            <li><b>Shift + [ (left bracket) key</b>: jump to the lowest data point in the chart</li>
          </ul>
        </li>
        <li><b>Escape key</b> or <b>Control key</b>: stop speaking</li>
        <li><b>H key</b>: open this Help dialog</li>
      </ul>

      <p>Explore the collapsible Control Panel to find many more accessibility features, including options for color blindness, dark mode with fine-grained contrast, self-voicing, SparkBraille tactile support, and more.</p>

      <p>For more details, visit the <a href="https://fizzstudio.github.io/paracharts" target="_blank">ParaCharts Documentation</a>.</p>
    `;
  }
  showHelpDialog() {
    this.controlPanel.dialog.show("Help", this._getHelp());
  }
  _getKeyTable() {
    return Ht`
      <table>
        <tbody>
          ${Object.entries(YF).map(([e, t]) => Ht`
              <tr>
                <th scope="row">${t.label}</th>
                <td>${t.hotkeys}</td>
                <td><button disable>edit</button></td>
              </tr>
            `)}
        </tbody>
      </table>
    `;
  }
  render() {
    return Ht`
      <div id="controls-tab" class="tab-content">
        <div>
          <button
            @click=${() => this.controlPanel.dialog.show("Key Bindings", this._getKeyTable())}
          >
            Keyboard Controls
          </button>
          <button
            @click=${() => this.store.updateSettings((e) => {
      e.ui.isFullscreenEnabled = !0;
    })}
          >
            Fullscreen
          </button>
        </div>

        <div>
          ${this._store.settingControls.getContent("controlPanel.tabs.controls")}
        </div>

        <section id="animation">
          ${this._store.settingControls.getContent("controlPanel.tabs.controls.animation")}
          <button
            @click=${() => {
      var e;
      (e = this._animationDialogRef.value) == null || e.show();
    }}
          >
            Animation settings
          </button>
          <para-animation-dialog
            ${ge(this._animationDialogRef)}
            id="animation-settings-dialog"
            .store=${this._store}
          >
          </para-animation-dialog>
        </section>

        <section id="advanced">
          <button
            @click=${() => this.showHelpDialog()}
          >
            Help
          </button>
          <button
            @click=${() => {
      var e;
      return (e = this._advancedControlDialogRef.value) == null ? void 0 : e.show();
    }}
          >
          Advanced Controls
          </button>
        </section>
      </div>
      <div id="file-save-placeholder" style="display: none;">
      </div>
      <para-advanced-control-settings-dialog
        ${ge(this._advancedControlDialogRef)}
        id="advanced-control-settings-dialog"
        .store=${this._store}
      ></para-advanced-control-settings-dialog>
    `;
  }
};
n6.styles = [
  ...pn.styles,
  Te`
    `
];
n6 = e6t([
  Oe("para-controls-panel")
], n6);
var r6t = Object.getOwnPropertyDescriptor, n6t = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? r6t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = o(i) || i);
  return i;
};
let i6 = class extends zi {
  render() {
    return console.log("MODEL", this.model), Ht`
      <div class="wrapper">
        <table>
          <thead>
            <tr>
              <th>
                ${this.model.getFacet(this.model.independentFacetKeys[0]).label} // TODO: Assumes exactly 1 indep facet
              </th>
              ${this.model.series.map((e) => Ht`
                <th scope="col">
                  ${e.key}
                </th>
              `)}
            </tr>
          </thead>
          <tbody>
            ${this.model.series[0].datapoints.map((e, t) => Ht`
              <tr>
                <td>
                  ${ff(e, "raw")}
                </td>
                ${this.model.series.map((r) => Ht`
                  <td>
                    ${z5(r[t], "value")}
                  </td>
                `)}
              </tr>
            `)}
          </tbody>
        </table>
      </div>
    `;
  }
};
i6.styles = [
  Te`
      th, td {
        padding: 0.25rem;
      }
      thead {
        position: sticky;
        top: 0;
        background: var(--theme-color-light);
      }
      .wrapper {
        overflow: scroll;
        max-height: 15rem;
      }
    `
];
i6 = n6t([
  Oe("para-datatable")
], i6);
class i6t {
  constructor(t, r) {
    this.data = t, this.binCount = r, this.init();
  }
  get binnedData() {
    return this._binnedData;
  }
  init() {
    this.findMinMax(), this.binData();
  }
  findMinMax() {
    this.min = Math.min(...this.data), this.max = Math.max(...this.data), this.range = this.max - this.min;
  }
  binData() {
    this._binnedData = [], this._binnedData = this.data.map((t) => Math.min(
      this.binCount - 1,
      Math.floor(this.binCount * (t - this.min) / this.range)
    ));
  }
}
const oP = [[1, 2, 3, 7], [4, 5, 6, 8]];
class s6t {
  constructor(t, r = !1) {
    this.binnedData = t, this.isBar = r, this.cellArray = [], this.init();
  }
  get cells() {
    return this.cellArray;
  }
  init() {
    this.buildGlyphs();
  }
  buildGlyphs() {
    let t = [];
    for (let r = 0; r < this.binnedData.length; ++r) {
      const n = this.binnedData[r], i = r % 2;
      if (t.push(oP[i][3 - n]), this.isBar)
        for (let s = 0; s < n; s++)
          t.push(oP[i][3 - s]);
      (i || this.binnedData.length === r + 1) && (this.cellArray.push(t), t = []);
    }
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const tm = globalThis, rS = tm.ShadowRoot && (tm.ShadyCSS === void 0 || tm.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, nS = Symbol(), aP = /* @__PURE__ */ new WeakMap();
let M$ = class {
  constructor(e, t, r) {
    if (this._$cssResult$ = !0, r !== nS) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (rS && e === void 0) {
      const r = t !== void 0 && t.length === 1;
      r && (e = aP.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), r && aP.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const o6t = (e) => new M$(typeof e == "string" ? e : e + "", void 0, nS), a6t = (e, ...t) => {
  const r = e.length === 1 ? e[0] : t.reduce((n, i, s) => n + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + e[s + 1], e[0]);
  return new M$(r, e, nS);
}, l6t = (e, t) => {
  if (rS) e.adoptedStyleSheets = t.map((r) => r instanceof CSSStyleSheet ? r : r.styleSheet);
  else for (const r of t) {
    const n = document.createElement("style"), i = tm.litNonce;
    i !== void 0 && n.setAttribute("nonce", i), n.textContent = r.cssText, e.appendChild(n);
  }
}, lP = rS ? (e) => e : (e) => e instanceof CSSStyleSheet ? ((t) => {
  let r = "";
  for (const n of t.cssRules) r += n.cssText;
  return o6t(r);
})(e) : e;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: c6t, defineProperty: u6t, getOwnPropertyDescriptor: h6t, getOwnPropertyNames: p6t, getOwnPropertySymbols: d6t, getPrototypeOf: f6t } = Object, bp = globalThis, cP = bp.trustedTypes, g6t = cP ? cP.emptyScript : "", uP = bp.reactiveElementPolyfillSupport, wf = (e, t) => e, Ly = { toAttribute(e, t) {
  switch (t) {
    case Boolean:
      e = e ? g6t : null;
      break;
    case Object:
    case Array:
      e = e == null ? e : JSON.stringify(e);
  }
  return e;
}, fromAttribute(e, t) {
  let r = e;
  switch (t) {
    case Boolean:
      r = e !== null;
      break;
    case Number:
      r = e === null ? null : Number(e);
      break;
    case Object:
    case Array:
      try {
        r = JSON.parse(e);
      } catch {
        r = null;
      }
  }
  return r;
} }, iS = (e, t) => !c6t(e, t), hP = { attribute: !0, type: String, converter: Ly, reflect: !1, hasChanged: iS };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), bp.litPropertyMetadata ?? (bp.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class jh extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, r = hP) {
    if (r.state && (r.attribute = !1), this._$Ei(), this.elementProperties.set(t, r), !r.noAccessor) {
      const n = Symbol(), i = this.getPropertyDescriptor(t, n, r);
      i !== void 0 && u6t(this.prototype, t, i);
    }
  }
  static getPropertyDescriptor(t, r, n) {
    const { get: i, set: s } = h6t(this.prototype, t) ?? { get() {
      return this[r];
    }, set(o) {
      this[r] = o;
    } };
    return { get() {
      return i == null ? void 0 : i.call(this);
    }, set(o) {
      const a = i == null ? void 0 : i.call(this);
      s.call(this, o), this.requestUpdate(t, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? hP;
  }
  static _$Ei() {
    if (this.hasOwnProperty(wf("elementProperties"))) return;
    const t = f6t(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(wf("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(wf("properties"))) {
      const r = this.properties, n = [...p6t(r), ...d6t(r)];
      for (const i of n) this.createProperty(i, r[i]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const r = litPropertyMetadata.get(t);
      if (r !== void 0) for (const [n, i] of r) this.elementProperties.set(n, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [r, n] of this.elementProperties) {
      const i = this._$Eu(r, n);
      i !== void 0 && this._$Eh.set(i, r);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const r = [];
    if (Array.isArray(t)) {
      const n = new Set(t.flat(1 / 0).reverse());
      for (const i of n) r.unshift(lP(i));
    } else t !== void 0 && r.push(lP(t));
    return r;
  }
  static _$Eu(t, r) {
    const n = r.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((r) => this.enableUpdating = r), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((r) => r(this));
  }
  addController(t) {
    var r;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((r = t.hostConnected) == null || r.call(t));
  }
  removeController(t) {
    var r;
    (r = this._$EO) == null || r.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), r = this.constructor.elementProperties;
    for (const n of r.keys()) this.hasOwnProperty(n) && (t.set(n, this[n]), delete this[n]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return l6t(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((r) => {
      var n;
      return (n = r.hostConnected) == null ? void 0 : n.call(r);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((r) => {
      var n;
      return (n = r.hostDisconnected) == null ? void 0 : n.call(r);
    });
  }
  attributeChangedCallback(t, r, n) {
    this._$AK(t, n);
  }
  _$EC(t, r) {
    var n;
    const i = this.constructor.elementProperties.get(t), s = this.constructor._$Eu(t, i);
    if (s !== void 0 && i.reflect === !0) {
      const o = (((n = i.converter) == null ? void 0 : n.toAttribute) !== void 0 ? i.converter : Ly).toAttribute(r, i.type);
      this._$Em = t, o == null ? this.removeAttribute(s) : this.setAttribute(s, o), this._$Em = null;
    }
  }
  _$AK(t, r) {
    var n;
    const i = this.constructor, s = i._$Eh.get(t);
    if (s !== void 0 && this._$Em !== s) {
      const o = i.getPropertyOptions(s), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((n = o.converter) == null ? void 0 : n.fromAttribute) !== void 0 ? o.converter : Ly;
      this._$Em = s, this[s] = a.fromAttribute(r, o.type), this._$Em = null;
    }
  }
  requestUpdate(t, r, n) {
    if (t !== void 0) {
      if (n ?? (n = this.constructor.getPropertyOptions(t)), !(n.hasChanged ?? iS)(this[t], r)) return;
      this.P(t, r, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(t, r, n) {
    this._$AL.has(t) || this._$AL.set(t, r), n.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (r) {
      Promise.reject(r);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep) this[s] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [s, o] of i) o.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], o);
    }
    let r = !1;
    const n = this._$AL;
    try {
      r = this.shouldUpdate(n), r ? (this.willUpdate(n), (t = this._$EO) == null || t.forEach((i) => {
        var s;
        return (s = i.hostUpdate) == null ? void 0 : s.call(i);
      }), this.update(n)) : this._$EU();
    } catch (i) {
      throw r = !1, this._$EU(), i;
    }
    r && this._$AE(n);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var r;
    (r = this._$EO) == null || r.forEach((n) => {
      var i;
      return (i = n.hostUpdated) == null ? void 0 : i.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((r) => this._$EC(r, this[r]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}
jh.elementStyles = [], jh.shadowRootOptions = { mode: "open" }, jh[wf("elementProperties")] = /* @__PURE__ */ new Map(), jh[wf("finalized")] = /* @__PURE__ */ new Map(), uP == null || uP({ ReactiveElement: jh }), (bp.reactiveElementVersions ?? (bp.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const My = globalThis, Ny = My.trustedTypes, pP = Ny ? Ny.createPolicy("lit-html", { createHTML: (e) => e }) : void 0, N$ = "$lit$", hl = `lit$${Math.random().toFixed(9).slice(2)}$`, D$ = "?" + hl, m6t = `<${D$}>`, $u = document, g0 = () => $u.createComment(""), m0 = (e) => e === null || typeof e != "object" && typeof e != "function", sS = Array.isArray, y6t = (e) => sS(e) || typeof (e == null ? void 0 : e[Symbol.iterator]) == "function", s3 = `[ 	
\f\r]`, Wd = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, dP = /-->/g, fP = />/g, Wc = RegExp(`>|${s3}(?:([^\\s"'>=/]+)(${s3}*=${s3}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), gP = /'/g, mP = /"/g, B$ = /^(?:script|style|textarea|title)$/i, b6t = (e) => (t, ...r) => ({ _$litType$: e, strings: t, values: r }), v6t = b6t(1), vp = Symbol.for("lit-noChange"), Br = Symbol.for("lit-nothing"), yP = /* @__PURE__ */ new WeakMap(), iu = $u.createTreeWalker($u, 129);
function j$(e, t) {
  if (!sS(e) || !e.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return pP !== void 0 ? pP.createHTML(t) : t;
}
const w6t = (e, t) => {
  const r = e.length - 1, n = [];
  let i, s = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", o = Wd;
  for (let a = 0; a < r; a++) {
    const l = e[a];
    let c, h, u = -1, p = 0;
    for (; p < l.length && (o.lastIndex = p, h = o.exec(l), h !== null); ) p = o.lastIndex, o === Wd ? h[1] === "!--" ? o = dP : h[1] !== void 0 ? o = fP : h[2] !== void 0 ? (B$.test(h[2]) && (i = RegExp("</" + h[2], "g")), o = Wc) : h[3] !== void 0 && (o = Wc) : o === Wc ? h[0] === ">" ? (o = i ?? Wd, u = -1) : h[1] === void 0 ? u = -2 : (u = o.lastIndex - h[2].length, c = h[1], o = h[3] === void 0 ? Wc : h[3] === '"' ? mP : gP) : o === mP || o === gP ? o = Wc : o === dP || o === fP ? o = Wd : (o = Wc, i = void 0);
    const y = o === Wc && e[a + 1].startsWith("/>") ? " " : "";
    s += o === Wd ? l + m6t : u >= 0 ? (n.push(c), l.slice(0, u) + N$ + l.slice(u) + hl + y) : l + hl + (u === -2 ? a : y);
  }
  return [j$(e, s + (e[r] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), n];
};
class y0 {
  constructor({ strings: t, _$litType$: r }, n) {
    let i;
    this.parts = [];
    let s = 0, o = 0;
    const a = t.length - 1, l = this.parts, [c, h] = w6t(t, r);
    if (this.el = y0.createElement(c, n), iu.currentNode = this.el.content, r === 2 || r === 3) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (i = iu.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const u of i.getAttributeNames()) if (u.endsWith(N$)) {
          const p = h[o++], y = i.getAttribute(u).split(hl), g = /([.?@])?(.*)/.exec(p);
          l.push({ type: 1, index: s, name: g[2], strings: y, ctor: g[1] === "." ? E6t : g[1] === "?" ? A6t : g[1] === "@" ? S6t : tv }), i.removeAttribute(u);
        } else u.startsWith(hl) && (l.push({ type: 6, index: s }), i.removeAttribute(u));
        if (B$.test(i.tagName)) {
          const u = i.textContent.split(hl), p = u.length - 1;
          if (p > 0) {
            i.textContent = Ny ? Ny.emptyScript : "";
            for (let y = 0; y < p; y++) i.append(u[y], g0()), iu.nextNode(), l.push({ type: 2, index: ++s });
            i.append(u[p], g0());
          }
        }
      } else if (i.nodeType === 8) if (i.data === D$) l.push({ type: 2, index: s });
      else {
        let u = -1;
        for (; (u = i.data.indexOf(hl, u + 1)) !== -1; ) l.push({ type: 7, index: s }), u += hl.length - 1;
      }
      s++;
    }
  }
  static createElement(t, r) {
    const n = $u.createElement("template");
    return n.innerHTML = t, n;
  }
}
function wp(e, t, r = e, n) {
  var i, s;
  if (t === vp) return t;
  let o = n !== void 0 ? (i = r._$Co) == null ? void 0 : i[n] : r._$Cl;
  const a = m0(t) ? void 0 : t._$litDirective$;
  return (o == null ? void 0 : o.constructor) !== a && ((s = o == null ? void 0 : o._$AO) == null || s.call(o, !1), a === void 0 ? o = void 0 : (o = new a(e), o._$AT(e, r, n)), n !== void 0 ? (r._$Co ?? (r._$Co = []))[n] = o : r._$Cl = o), o !== void 0 && (t = wp(e, o._$AS(e, t.values), o, n)), t;
}
class x6t {
  constructor(t, r) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = r;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: r }, parts: n } = this._$AD, i = ((t == null ? void 0 : t.creationScope) ?? $u).importNode(r, !0);
    iu.currentNode = i;
    let s = iu.nextNode(), o = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new Bg(s, s.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, t) : l.type === 6 && (c = new _6t(s, this, t)), this._$AV.push(c), l = n[++a];
      }
      o !== (l == null ? void 0 : l.index) && (s = iu.nextNode(), o++);
    }
    return iu.currentNode = $u, i;
  }
  p(t) {
    let r = 0;
    for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(t, n, r), r += n.strings.length - 2) : n._$AI(t[r])), r++;
  }
}
class Bg {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, r, n, i) {
    this.type = 2, this._$AH = Br, this._$AN = void 0, this._$AA = t, this._$AB = r, this._$AM = n, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const r = this._$AM;
    return r !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = r.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, r = this) {
    t = wp(this, t, r), m0(t) ? t === Br || t == null || t === "" ? (this._$AH !== Br && this._$AR(), this._$AH = Br) : t !== this._$AH && t !== vp && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : y6t(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== Br && m0(this._$AH) ? this._$AA.nextSibling.data = t : this.T($u.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var r;
    const { values: n, _$litType$: i } = t, s = typeof i == "number" ? this._$AC(t) : (i.el === void 0 && (i.el = y0.createElement(j$(i.h, i.h[0]), this.options)), i);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === s) this._$AH.p(n);
    else {
      const o = new x6t(s, this), a = o.u(this.options);
      o.p(n), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let r = yP.get(t.strings);
    return r === void 0 && yP.set(t.strings, r = new y0(t)), r;
  }
  k(t) {
    sS(this._$AH) || (this._$AH = [], this._$AR());
    const r = this._$AH;
    let n, i = 0;
    for (const s of t) i === r.length ? r.push(n = new Bg(this.O(g0()), this.O(g0()), this, this.options)) : n = r[i], n._$AI(s), i++;
    i < r.length && (this._$AR(n && n._$AB.nextSibling, i), r.length = i);
  }
  _$AR(t = this._$AA.nextSibling, r) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, r); t && t !== this._$AB; ) {
      const i = t.nextSibling;
      t.remove(), t = i;
    }
  }
  setConnected(t) {
    var r;
    this._$AM === void 0 && (this._$Cv = t, (r = this._$AP) == null || r.call(this, t));
  }
}
class tv {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, r, n, i, s) {
    this.type = 1, this._$AH = Br, this._$AN = void 0, this.element = t, this.name = r, this._$AM = i, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = Br;
  }
  _$AI(t, r = this, n, i) {
    const s = this.strings;
    let o = !1;
    if (s === void 0) t = wp(this, t, r, 0), o = !m0(t) || t !== this._$AH && t !== vp, o && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = s[0], l = 0; l < s.length - 1; l++) c = wp(this, a[n + l], r, l), c === vp && (c = this._$AH[l]), o || (o = !m0(c) || c !== this._$AH[l]), c === Br ? t = Br : t !== Br && (t += (c ?? "") + s[l + 1]), this._$AH[l] = c;
    }
    o && !i && this.j(t);
  }
  j(t) {
    t === Br ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class E6t extends tv {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === Br ? void 0 : t;
  }
}
class A6t extends tv {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== Br);
  }
}
class S6t extends tv {
  constructor(t, r, n, i, s) {
    super(t, r, n, i, s), this.type = 5;
  }
  _$AI(t, r = this) {
    if ((t = wp(this, t, r, 0) ?? Br) === vp) return;
    const n = this._$AH, i = t === Br && n !== Br || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive, s = t !== Br && (n === Br || i);
    i && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var r;
    typeof this._$AH == "function" ? this._$AH.call(((r = this.options) == null ? void 0 : r.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class _6t {
  constructor(t, r, n) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = r, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    wp(this, t);
  }
}
const bP = My.litHtmlPolyfillSupport;
bP == null || bP(y0, Bg), (My.litHtmlVersions ?? (My.litHtmlVersions = [])).push("3.2.1");
const k6t = (e, t, r) => {
  const n = (r == null ? void 0 : r.renderBefore) ?? t;
  let i = n._$litPart$;
  if (i === void 0) {
    const s = (r == null ? void 0 : r.renderBefore) ?? null;
    n._$litPart$ = i = new Bg(t.insertBefore(g0(), s), s, void 0, r ?? {});
  }
  return i._$AI(e), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let xf = class extends jh {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = k6t(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return vp;
  }
};
var vP;
xf._$litElement$ = !0, xf.finalized = !0, (vP = globalThis.litElementHydrateSupport) == null || vP.call(globalThis, { LitElement: xf });
const wP = globalThis.litElementPolyfillSupport;
wP == null || wP({ LitElement: xf });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const C6t = (e) => (t, r) => {
  r !== void 0 ? r.addInitializer(() => {
    customElements.define(e, t);
  }) : customElements.define(e, t);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const I6t = { attribute: !0, type: String, converter: Ly, reflect: !1, hasChanged: iS }, P6t = (e = I6t, t, r) => {
  const { kind: n, metadata: i } = r;
  let s = globalThis.litPropertyMetadata.get(i);
  if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = /* @__PURE__ */ new Map()), s.set(r.name, e), n === "accessor") {
    const { name: o } = r;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, l, e);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, e), a;
    } };
  }
  if (n === "setter") {
    const { name: o } = r;
    return function(a) {
      const l = this[o];
      t.call(this, a), this.requestUpdate(o, l, e);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function jg(e) {
  return (t, r) => typeof r == "object" ? P6t(e, t, r) : ((n, i, s) => {
    const o = i.hasOwnProperty(s);
    return i.constructor.createProperty(s, o ? { ...n, wrapped: !0 } : n), o ? Object.getOwnPropertyDescriptor(i, s) : void 0;
  })(e, t, r);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function R6t(e) {
  return jg({ ...e, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const T6t = (e, t, r) => (r.configurable = !0, r.enumerable = !0, Reflect.decorate && typeof t != "object" && Object.defineProperty(e, t, r), r);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function O6t(e) {
  return (t, r) => {
    const { slot: n } = {}, i = "slot" + (n ? `[name=${n}]` : ":not([name])");
    return T6t(t, r, { get() {
      var s;
      const o = (s = this.renderRoot) == null ? void 0 : s.querySelector(i);
      return (o == null ? void 0 : o.assignedNodes(e)) ?? [];
    } });
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const L6t = (e) => e.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const M6t = { CHILD: 2 }, N6t = (e) => (...t) => ({ _$litDirective$: e, values: t });
class D6t {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, r, n) {
    this._$Ct = t, this._$AM = r, this._$Ci = n;
  }
  _$AS(t, r) {
    return this.update(t, r);
  }
  update(t, r) {
    return this.render(...r);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ef = (e, t) => {
  var r;
  const n = e._$AN;
  if (n === void 0) return !1;
  for (const i of n) (r = i._$AO) == null || r.call(i, t, !1), Ef(i, t);
  return !0;
}, Dy = (e) => {
  let t, r;
  do {
    if ((t = e._$AM) === void 0) break;
    r = t._$AN, r.delete(e), e = t;
  } while ((r == null ? void 0 : r.size) === 0);
}, F$ = (e) => {
  for (let t; t = e._$AM; e = t) {
    let r = t._$AN;
    if (r === void 0) t._$AN = r = /* @__PURE__ */ new Set();
    else if (r.has(e)) break;
    r.add(e), F6t(t);
  }
};
function B6t(e) {
  this._$AN !== void 0 ? (Dy(this), this._$AM = e, F$(this)) : this._$AM = e;
}
function j6t(e, t = !1, r = 0) {
  const n = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0) if (t) if (Array.isArray(n)) for (let s = r; s < n.length; s++) Ef(n[s], !1), Dy(n[s]);
  else n != null && (Ef(n, !1), Dy(n));
  else Ef(this, e);
}
const F6t = (e) => {
  e.type == M6t.CHILD && (e._$AP ?? (e._$AP = j6t), e._$AQ ?? (e._$AQ = B6t));
};
class $6t extends D6t {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, r, n) {
    super._$AT(t, r, n), F$(this), this.isConnected = t._$AU;
  }
  _$AO(t, r = !0) {
    var n, i;
    t !== this.isConnected && (this.isConnected = t, t ? (n = this.reconnected) == null || n.call(this) : (i = this.disconnected) == null || i.call(this)), r && (Ef(this, t), Dy(this));
  }
  setValue(t) {
    if (L6t(this._$Ct)) this._$Ct._$AI(t, this);
    else {
      const r = [...this._$Ct._$AH];
      r[this._$Ci] = t, this._$Ct._$AI(r, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const xP = () => new z6t();
class z6t {
}
const o3 = /* @__PURE__ */ new WeakMap(), EP = N6t(class extends $6t {
  render(e) {
    return Br;
  }
  update(e, [t]) {
    var r;
    const n = t !== this.Y;
    return n && this.Y !== void 0 && this.rt(void 0), (n || this.lt !== this.ct) && (this.Y = t, this.ht = (r = e.options) == null ? void 0 : r.host, this.rt(this.ct = e.element)), Br;
  }
  rt(e) {
    if (this.isConnected || (e = void 0), typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let r = o3.get(t);
      r === void 0 && (r = /* @__PURE__ */ new WeakMap(), o3.set(t, r)), r.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), r.set(this.Y, e), e !== void 0 && this.Y.call(this.ht, e);
    } else this.Y.value = e;
  }
  get lt() {
    var e, t;
    return typeof this.Y == "function" ? (e = o3.get(this.ht ?? globalThis)) == null ? void 0 : e.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
class V6t {
  constructor(t, r) {
    this.labeledDataString = t, this.binCount = r, this._letters = [], this._proportions = [], this._returnString = "", this.labeledData = [], this.init();
  }
  get returnString() {
    return this._returnString;
  }
  init() {
    this.labeledData = JSON.parse(this.labeledDataString), this.labeledData.sort((t, r) => r.value - t.value), this.findTotal();
    for (let t of this.labeledData)
      this.findCandidateLetter(t.label);
    this.assignProportions(), this.composeString();
  }
  findTotal() {
    let t = 0;
    for (let r of this.labeledData)
      t += r.value;
    this.total = t;
  }
  findCandidateLetter(t) {
    const r = [];
    if (this._letters)
      for (let l of this._letters)
        r.push(l.candidate);
    let n = 0, i = t[0].toUpperCase();
    const s = t.replace(/\s+/g, ""), o = [...t.matchAll(/\s(\w)/g)], a = String(o.map((l) => l[1]).join(""));
    for (; r.includes(s[n].toUpperCase()); ) {
      if (o.length > 0 && !r.includes(a[0].toUpperCase())) {
        i = a[0].toUpperCase();
        break;
      }
      if (n += 1, i = s[n].toUpperCase(), n > s.length) {
        i = "?";
        break;
      }
    }
    this._letters.push({ label: t, candidate: i });
  }
  assignProportions() {
    let t = this.binCount;
    for (let r = this.labeledData.length - 1; r > -1; r--) {
      let n = this.labeledData[r];
      const i = n.value / this.total;
      let s = Math.max(1, Math.round(i * this.binCount));
      this.labeledData[0] == n && (s = t);
      const o = this._letters.filter((a) => a.label == n.label)[0].candidate;
      this._proportions.push({ label: o, value: s }), t -= s;
    }
    this._proportions.sort((r, n) => n.value - r.value);
  }
  composeString() {
    for (let t of this._proportions)
      this._returnString = this._returnString.concat(t.label.repeat(t.value));
  }
}
var U6t = Object.defineProperty, H6t = Object.getOwnPropertyDescriptor, uh = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? H6t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && U6t(t, r, i), i;
};
const G6t = 10240;
function Q6t(e) {
  return e.reduce((t, r) => {
    if (typeof r > "u" || r === null)
      throw new Error("Invalid dot specification");
    let n = G6t;
    for (const i of r) {
      if (i < 1 || i > 8)
        throw new Error(`Dot out of range: ${i}`);
      n |= 1 << i - 1;
    }
    return t + String.fromCharCode(n);
  }, "");
}
let ba = class extends xf {
  constructor() {
    super(), this.bar = !1, this.isProp = !1, this.regionRef = xP(), this.preRef = xP(), this.onSelectionChange = () => {
      var e, t;
      const r = document.getSelection();
      if (((t = (e = r == null ? void 0 : r.anchorNode) == null ? void 0 : e.parentNode) == null ? void 0 : t.parentNode) !== this.regionRef.value)
        return;
      const n = r == null ? void 0 : r.anchorOffset;
      this.dispatchEvent(
        new CustomEvent(
          "select",
          {
            bubbles: !0,
            composed: !0,
            detail: n
          }
        )
      );
    };
  }
  /** Binned data, in case you want to see it. */
  get binnedData() {
    return this._binnedData;
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("selectionchange", this.onSelectionChange), this.data && !this.cells && this.renderBraille(this.data);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  willUpdate(e) {
    e.has("data") && this.renderBraille(this.data);
  }
  toBraille(e) {
    return e.split("").map((t) => W6t[t]).join("");
  }
  render() {
    let e;
    if (this.isProp) {
      const t = this.labeledData, r = new V6t(t, 20);
      e = this.toBraille(r.returnString);
    } else
      e = this.cells ? Q6t(this.cells) : "";
    return v6t`
      <div
        ${EP(this.regionRef)}
        role="textbox"
        contenteditable="true"
      >
        <pre 
          ${EP(this.preRef)}
          contenteditable="false"
        >${e}</pre>
        <div class="data" style="display: none">
          <slot 
          ></slot>
        </div>
      </div>
    `;
  }
  firstUpdated(e) {
    if (this.cells)
      return;
    const t = this.slotNodes.find((r) => {
      var n;
      return (n = r.textContent) == null ? void 0 : n.trim();
    });
    t && this.renderBraille(t.textContent);
  }
  renderBraille(e) {
    const t = e.split(/ /).map(parseFloat), r = new i6t(t, 4);
    this._binnedData = r.binnedData;
    const n = new s6t(this._binnedData, this.bar);
    this.cells = n.cells;
  }
};
ba.styles = a6t`
    div {
      font-size: var(--font-size, 2rem);
      padding: var(--padding, unset);
      margin: var(--margin, unset);
    }
    pre {
      margin: 0;
    }
  `;
uh([
  jg()
], ba.prototype, "data", 2);
uh([
  jg({ type: Boolean })
], ba.prototype, "bar", 2);
uh([
  jg()
], ba.prototype, "labeledData", 2);
uh([
  jg({ type: Boolean })
], ba.prototype, "isProp", 2);
uh([
  R6t()
], ba.prototype, "cells", 2);
uh([
  O6t()
], ba.prototype, "slotNodes", 2);
ba = uh([
  C6t("fizz-sparkbraille")
], ba);
const W6t = {
  " ": "",
  a: "",
  b: "",
  c: "",
  d: "",
  e: "",
  f: "",
  g: "",
  h: "",
  i: "",
  j: "",
  k: "",
  l: "",
  m: "",
  n: "",
  o: "",
  p: "",
  q: "",
  r: "",
  s: "",
  t: "",
  u: "",
  v: "",
  w: "",
  x: "",
  y: "",
  z: "",
  1: "",
  2: "",
  3: "",
  4: "",
  5: "",
  6: "",
  7: "",
  8: "",
  9: "",
  0: "",
  ",": "",
  ".": "",
  ";": "",
  ":": "",
  "!": "",
  "?": "",
  '"': "",
  "'": "",
  "-": "",
  "(": "",
  ")": "",
  A: "",
  B: "",
  C: "",
  D: "",
  E: "",
  F: "",
  G: "",
  H: "",
  I: "",
  J: "",
  K: "",
  L: "",
  M: "",
  N: "",
  O: "",
  P: "",
  Q: "",
  R: "",
  S: "",
  T: "",
  U: "",
  V: "",
  W: "",
  X: "",
  Y: "",
  Z: ""
};
var q6t = Object.defineProperty, Y6t = Object.getOwnPropertyDescriptor, $$ = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Y6t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && q6t(t, r, i), i;
};
let By = class extends pn {
  constructor() {
    super(...arguments), this.isSparkBrailleVisible = !1, this._sparkBrailleRef = we(), this._sparkBrailleWrapperRef = we();
  }
  _saveChart() {
    const e = this.controlPanel.paraChart.paraView.serialize(), t = new Blob([e], { type: "image/svg+xml;charset=utf-8" }), r = URL.createObjectURL(t);
    this._controlPanel.paraChart.paraView.downloadContent(r, "svg"), URL.revokeObjectURL(r);
  }
  _saveData() {
    const e = this._store.getModelCsv(), t = new Blob([e], { type: "text/csv;charset=utf-8" }), r = URL.createObjectURL(t);
    this._controlPanel.paraChart.paraView.downloadContent(r, "csv"), URL.revokeObjectURL(r);
  }
  render() {
    var t, r, n, i, s, o;
    const e = this.controlPanel.parentElement.firstElementChild;
    return Ht`
      <div
        id="data-page"
        class="tab-content"
      >
        <div>
          <p>Source: <span id="source-name">unknown</span></p>
        </div>
        <div id="data-buttons">
          ${this.controlPanel.settings.isSparkBrailleControlVisible ? Ht`
              <button
                @click=${() => {
      this.isSparkBrailleVisible = !this.isSparkBrailleVisible, e.store.updateSettings((a) => {
        a.controlPanel.isSparkBrailleVisible = this.isSparkBrailleVisible;
      }), this._sparkBrailleRef.value.focus();
    }}
              >
                SparkBraille
              </button>
            ` : Lt}
          <button
            @click=${() => {
      this.controlPanel.dialog.show(
        "JSON Image Metadata",
        Ht`
                  <pre>
                    <code>
                      ${JSON.stringify(this._store.jimerator.jim, void 0, 2)}
                    </code>
                  </pre>`
      );
    }}
          >
            JIM
          </button>
          <button
            @click=${() => this._saveData()}
          >
            Save data
          </button>
          <button
            @click=${() => {
      this.controlPanel.dialog.show("Data table", Ht`
                <para-datatable
                  .model=${this._store.model}
                >
                </para-datatable>
              `);
    }}
          >
            Data table
          </button>
          <button
            @click=${() => this.controlPanel.dialog.show("Source links")}
          >
            Source Links
          </button>
          <button
            @click=${() => {
      this._saveChart();
    }}
          >
            Save chart
          </button>
        </div>
      </div>
      <div
        ${ge(this._sparkBrailleWrapperRef)}
        id="sparkbraille"
        class=${this.isSparkBrailleVisible ? Lt : "hidden"}
        ?hidden=${!this.isSparkBrailleVisible}
    >
        <!--
          What should happen when a braille cell is selected?
        -->
        <fizz-sparkbraille
          ${ge(this._sparkBrailleRef)}
          ?bar=${(t = this._store.sparkBrailleInfo) == null ? void 0 : t.isBar}
          ?isProp=${(r = this._store.sparkBrailleInfo) == null ? void 0 : r.isProportional}
          data=${(n = this._store.sparkBrailleInfo) != null && n.isProportional ? "" : ((i = this._store.sparkBrailleInfo) == null ? void 0 : i.data) ?? ""}
          labeledData=${(s = this._store.sparkBrailleInfo) != null && s.isProportional ? ((o = this._store.sparkBrailleInfo) == null ? void 0 : o.data) ?? "" : ""}
          @select=${(a) => {
      a.detail * 2;
    }}
        >
        </fizz-sparkbraille>
      </div>
    `;
  }
};
By.styles = [
  ...pn.styles,
  Te`
      #data-page {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        align-content: center;
        flex-grow: 1;
      }
      #data-page p {
        white-space: nowrap;
      }
      #data-buttons {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        align-content: center;
        flex-wrap: wrap;
        width: 30rem;
      }

      #data-buttons button {
        width: 8rem;
        max-width: 8rem;
      }
      #sparkbraille {
        background-color: var(--theme-color-light);
        padding: 0.2rem;
      }
    `
];
$$([
  Qt({ type: Boolean })
], By.prototype, "isSparkBrailleVisible", 2);
By = $$([
  Oe("para-data-panel")
], By);
var K6t = Object.defineProperty, Z6t = Object.getOwnPropertyDescriptor, oS = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Z6t(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && K6t(t, r, i), i;
};
let b0 = class extends pn {
  constructor() {
    super(...arguments), this.caption = "", this.visibleStatus = "", this._captionBoxWrapperRef = we();
  }
  // get ariaLiveRegion() {
  //   return this._ariaLiveRegionRef.value!;
  // }
  positionCaptionBox() {
    this._controlPanel.settings.isControlPanelDefaultOpen || !this._controlPanel.settings.caption.isCaptionExternalWhenControlPanelClosed ? this.internalizeCaptionBox() : this._controlPanel.externalizeCaptionBox();
  }
  // get speechRate() {
  //   return this._controller.voice.rate;
  // }
  // set speechRate(rate: number) {
  //   this._controller.voice.rate = rate;
  // }
  clearStatusBar() {
    this._controlPanel.paraChart.clearAriaLive();
  }
  // clearAriaLive() {
  //   this._ariaLiveRegionRef.value!.clear();
  // }
  // protected _showAriaLiveHistory() {
  //   this._ariaLiveRegionRef.value!.showHistoryDialog();
  // }
  internalizeCaptionBox() {
    this.renderRoot.querySelector("#wrapper").append(this.controlPanel.paraChart.captionBox);
  }
  render() {
    return Ht`
      <div id="wrapper"></div>
    `;
  }
};
b0.styles = [
  ...pn.styles,
  Te`
      #description {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      #desc-footer {
        background-color: var(--theme-color-light);
        padding: 0.2rem;
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-direction: row;
        justify-content: space-between;
      }
    `
];
oS([
  Qt()
], b0.prototype, "caption", 2);
oS([
  Qt()
], b0.prototype, "visibleStatus", 2);
b0 = oS([
  Oe("para-description-panel")
], b0);
const J6t = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%205px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20%3c/style%3e%3cpath%20d='M95,23.6%20A14.1,14.1,0,0,0,80.8,9.4%20H19.1%20A14.1,14.1,0,0,0,5,23.6%20V52.1%20A14.1,14.1,0,0,0,19.1,66.2%20H45.7%20L69.0,89.9%20a1.9,1.9,0,0,0,3.4%20-1.5%20L70.4,66.2%20H80.8%20A14.1,14.1,0,0,0,95,52.1%20ZM91.0,52.1%20a10.1,10.1,0,0,1-10.1,10.1%20H68.2%20a1.9,1.9,0,0,0-1.9,2.1%20L67.9,83.1%20l-19.9%20-20.2%20a1.9,1.9,0,0,0-1.4%20-.59567h-27.4%20a10.1,10.1,0,0,1-10.1%20-10.1%20V23.6%20a10.1,10.1,0,0,1,10.1%20-10.1%20H80.8%20a10.1,10.1,0,0,1,10.1,10.1%20Z%20M20,25%20H75%20M20,37.5%20H75%20M20,50%20H75'%20/%3e%3c/svg%3e", X6t = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%207px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20%3c/style%3e%3cpath%20d='M50%204.6875c-21.875%200-39.062%209.2188-39.062%2020.938v48.594c0%2011.875%2017.188%2021.094%2039.062%2021.094s39.062-9.2188%2039.062-20.938v-48.75c0-11.719-17.188-20.938-39.062-20.938zm35.938%2069.688c0%209.6875-16.406%2017.812-35.938%2017.812s-35.938-8.125-35.938-17.812v-15.938c5.9375%207.5%2019.531%2012.656%2035.938%2012.656s30-5.1562%2035.938-12.656zm0-24.375c0%209.6875-16.406%2017.812-35.938%2017.812s-35.938-8.125-35.938-17.812v-15.938c5.9375%207.5%2019.531%2012.656%2035.938%2012.656s30-5.1562%2035.938-12.656zm-35.938-6.4062c-19.531%200-35.938-8.125-35.938-17.812s16.406-17.969%2035.938-17.969%2035.938%208.125%2035.938%2017.812-16.406%2017.969-35.938%2017.969z'%20/%3e%3c/svg%3e", txt = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cpath%20d='m44.375%2088.531c1.7109%201.5938%203.5977%202.9883%205.625%204.1562-7.1992%204.1562-15.762%205.2734-23.789%203.0977-8.0234-2.1719-14.852-7.4531-18.973-14.676-4.1211-7.2227-5.1914-15.789-2.9805-23.801%202.2148-8.0156%207.5312-14.82%2014.773-18.902%200.25391%202.1992%200.76953%204.3594%201.5312%206.4375%202.5391%207.0938%207.5391%2013.039%2014.094%2016.75-0.1875%201.3359-0.28125%202.6836-0.28125%204.0312-0.007812%208.6953%203.6172%2017%2010%2022.906zm36.594-50.125c-0.25391%202.1992-0.76953%204.3594-1.5312%206.4375-2.5391%207.0938-7.5391%2013.039-14.094%2016.75%200.1875%201.3359%200.28125%202.6836%200.28125%204.0312%200.007812%208.6953-3.6172%2017-10%2022.906-1.7109%201.5938-3.5977%202.9883-5.625%204.1562%207.1992%204.1562%2015.762%205.2734%2023.789%203.0977%208.0234-2.1719%2014.852-7.4531%2018.973-14.676%204.1211-7.2227%205.1914-15.789%202.9805-23.801-2.2148-8.0156-7.5312-14.82-14.773-18.902zm-7.1875%203.625c-2.6172-0.92969-5.3789-1.4062-8.1562-1.4062-3.4414-0.003906-6.8477%200.71094-10%202.0938%203.6914%203.4258%206.5%207.6914%208.1875%2012.438%204.7266-3.1055%208.2461-7.7383%209.9688-13.125zm-14.438%2022.156c-6.082%201.918-12.605%201.918-18.688%200-0.03125%200.46875-0.03125%200.96875-0.03125%201.4375-0.007812%207.5781%203.4453%2014.75%209.375%2019.469%205.9297-4.7188%209.3828-11.891%209.375-19.469%200-0.46875%200-0.96875-0.03125-1.4375zm-9.3438-4.8125c2.7773%200%205.5391-0.47656%208.1562-1.4062-1.4844-4.6602-4.3242-8.7734-8.1562-11.812-3.832%203.0391-6.6719%207.1523-8.1562%2011.812%202.6172%200.92969%205.3789%201.4062%208.1562%201.4062zm-15.625-18.75c-2.7773%200-5.5391%200.47656-8.1562%201.4062%201.7227%205.3867%205.2422%2010.02%209.9688%2013.125%201.6875-4.7461%204.4961-9.0117%208.1875-12.438-3.1523-1.3828-6.5586-2.0977-10-2.0938zm0-6.25c5.4844-0.003906%2010.875%201.4414%2015.625%204.1875%204.75-2.7461%2010.141-4.1914%2015.625-4.1875%203.1719-0.003906%206.3203%200.48047%209.3438%201.4375%202.0859%200.65234%204.0977%201.5195%206%202.5938%200.1875-1.3359%200.28125-2.6836%200.28125-4.0312%200-11.164-5.957-21.48-15.625-27.062s-21.582-5.582-31.25%200-15.625%2015.898-15.625%2027.062c0%201.3477%200.09375%202.6953%200.28125%204.0312%201.9023-1.0742%203.9141-1.9414%206-2.5938%203.0234-0.95703%206.1719-1.4414%209.3438-1.4375z'%20/%3e%3c/svg%3e", ext = "data:image/svg+xml,%3csvg%20viewBox='0%200%20100%20100'%20xmlns='http://www.w3.org/2000/svg'%3e%3cstyle%3e%20path%20{%20stroke:%20black;%20stroke-width:%208;%20stroke-linecap:round;%20fill:%20none;%20}%20path%23speaker%20{%20stroke:%20none;%20fill:%20black;%20}%20%3c/style%3e%3cpath%20id='speaker'%20d='M%2052.9,11.7%20C%2050,10.2%2046.5,10.5%2043.8,12.5%20L%2020.9,29.5%20C%2020.7,29.7%2020.3,29.8%2020,29.8%20H%2011.1%20C%206.3,29.8%202.4,33.7%202.4,38.5%20V%2061.5%20C%202.4,66.3%206.3,70.2%2011.1,70.2%20H%2020%20C%2020.3,70.2%2020.6,70.3%2020.9,70.5%20L%2043.8,87.5%20C%2045.3,88.6%2047.1,89.2%2049,89.2%2050.3,89.2%2051.7,88.9%2052.9,88.3%2055.8,86.8%2057.7,83.8%2057.7,80.5%20V%2019.5%20C%2057.6,16.2%2055.8,13.2%2052.9,11.7%20Z'%20/%3e%3cpath%20d='M70.5,31%20C78.5,40%2078.5,60%2070.5,69'%20/%3e%3cpath%20d='M81.5,17%20C97.5,34%2097.5,66%2081.5,83'%20/%3e%3c/svg%3e", rxt = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%208px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20circle%20{%20fill:%20white;%20stroke:%20black;%20stroke-width:%206px;%20}%20%3c/style%3e%3cg%3e%3cpath%20d='M15,25%20H85'%20/%3e%3ccircle%20cx='28'%20cy='25'%20r='7'%20/%3e%3c/g%3e%3cg%3e%3cpath%20d='M15,50%20H85'%20/%3e%3ccircle%20cx='68'%20cy='50'%20r='7'%20/%3e%3c/g%3e%3cg%3e%3cpath%20d='M15,75%20H85'%20/%3e%3ccircle%20cx='50'%20cy='75'%20r='7'%20/%3e%3c/g%3e%3c/svg%3e", nxt = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path.new%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%208px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20%3c/style%3e%3cpath%20class='new'%20d='M10,10%20V90%20H90%20M22,60%20L35,75%20L50,58%20L58,68%20L90,28'%20/%3e%3c/svg%3e", AP = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='10%2010%2080%2080'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%207px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20circle%20{%20fill:%20white;%20stroke:%20black;%20stroke-width:%206px;%20}%20%3c/style%3e%3cpath%20d='M57.5%20,70%20m23.3%202.6%20-20.5%20-35.0%20v-20.3%20h4.5%20c1.3%200%202.5-1.1%202.5-2.5%200-1.3%20-1.1%20-2.5%20-2.5%20-2.5%20h-30.1%20c-1.3%200-2.5%201.1%20-2.5%202.5%200%201.3%201.1%202.5%202.5%202.5%20h4.7%20v20.3%20l-19.9%2035.1%20c-1.6%202.9%20-1.6%206.5%200.0%209.4%201.7%202.9%204.7%204.7%208.2%204.7%20h44.8%20c3.4%200%206.5%20-1.7%208.2%20-4.7%201.7%20-2.9%201.6%20-6.5%20-0.0%20-9.5%20z%20M33,50%20H67'%20/%3e%3ccircle%20cx='40'%20cy='63'%20r='4'%20/%3e%3ccircle%20cx='57'%20cy='72'%20r='4'%20/%3e%3c/svg%3e", ixt = "data:image/svg+xml,%3csvg%20id='fizz_logo'%20x='0'%20y='0'%20width='100%25'%20height='100%25'%20viewBox='0%200%20208%20208'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eFizz%20Logo%3c/title%3e%3cstyle%3e%20text%20{%20font-family:%20'Trebuchet%20MS',%20Helvetica,%20sans-serif;%20font-size:%20180px;%20}%20%3c/style%3e%3cg%20fill='hsl(258,%2030%25,%2040%25)'%3e%3ccircle%20id='circle-0-0'%20cx='50'%20cy='50'%20r='30'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-0-1'%20cx='120'%20cy='46.5'%20r='23'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-0-2'%20cx='176'%20cy='43'%20r='16'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-1-0'%20cx='46.5'%20cy='120'%20r='23'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-1-1'%20cx='112'%20cy='112'%20r='16'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-2-0'%20cx='43'%20cy='176'%20r='16'%20fill='%23944bbb'/%3e%3c/g%3e%3c/svg%3e", z$ = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMS4yNXJlbSIgaGVpZ2h0PSIxLjI1cmVtIiB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGNpcmNsZSBzdHlsZT0ic3Ryb2tlOmdob3N0d2hpdGU7IHN0cm9rZS13aWR0aDoxLjhweDsgZmlsbDpub25lOyIgY3g9IjEwIiBjeT0iMTAiIHI9IjkiLz48dGV4dCB4PSIxMCIgeT0iMTYiIHN0eWxlPSJmaWxsOmdob3N0d2hpdGU7IGZvbnQ6Ym9sZCAxOHB4ICdUaW1lcyBOZXcgUm9tYW4nLFRpbWVzLHNlcmlmOyB0ZXh0LWFuY2hvcjptaWRkbGU7Ij5pPC90ZXh0Pgo8L3N2Zz4K";
var sxt = Object.defineProperty, oxt = Object.getOwnPropertyDescriptor, aS = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? oxt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && sxt(t, r, i), i;
};
let v0 = class extends ka(zi) {
  constructor() {
    super(...arguments), this.dataState = "initial", this._tabsRef = we(), this._descriptionPanelRef = we(), this._dataPanelRef = we(), this._colorsPanelRef = we(), this._chartPanelRef = we(), this._annotationPanelRef = we(), this._controlsPanelRef = we(), this._dialogRef = we(), this._msgDialogRef = we();
  }
  get settings() {
    return dr.getGroupLink(
      this.managedSettingKeys[0],
      this._store.settings
    );
  }
  get managedSettingKeys() {
    return ["controlPanel"];
  }
  get descriptionPanel() {
    return this._descriptionPanelRef.value;
  }
  get chartPanel() {
    return this._chartPanelRef.value;
  }
  get annotationPanel() {
    return this._annotationPanelRef.value;
  }
  // get statusBar() {
  //   return this._descriptionPanelRef.value!.statusBar;
  // }
  get dialog() {
    return this._dialogRef.value;
  }
  connectedCallback() {
    super.connectedCallback(), this._storeChangeUnsub = this._store.subscribe((e, t) => {
      e === "data" && this.dataUpdated();
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._storeChangeUnsub();
  }
  // Anything that needs to be done when data is updated, do here
  dataUpdated() {
    this.dataState = "complete";
  }
  settingDidChange(e, t) {
    var s;
    const r = e.match(/controlPanel\.(\w+)/)[1], n = /is(\w+)TabVisible/, i = (s = r.match(n)) == null ? void 0 : s[1];
    if (i)
      t ? this._tabsRef.value.show(i) : this._tabsRef.value.hide(i);
    else if (r === "isControlPanelDefaultOpen" || r === "tabLabelStyle")
      this.requestUpdate();
    else if (r === "isCaptionVisible" || r === "isExplorationBarVisible")
      this._descriptionPanelRef.value.requestUpdate();
    else if (r === "isSparkBrailleVisible")
      this._dataPanelRef.value.isSparkBrailleVisible = t;
    else if (r === "isSparkBrailleControlVisible")
      this._dataPanelRef.value.requestUpdate();
    else if (r === "isColorPaletteControlVisible" || r === "isCVDControlVisible")
      this._colorsPanelRef.value.requestUpdate();
    else
      return !1;
    return !0;
  }
  updated(e) {
    e.has("dataState") && this.dataState === "complete" && this.descriptionPanel.requestUpdate();
  }
  externalizeCaptionBox() {
    this.after(this.paraChart.captionBox);
  }
  onFocus() {
    this._descriptionPanelRef.value.clearStatusBar();
  }
  showHelpDialog() {
    return this._controlsPanelRef.value.showHelpDialog();
  }
  render() {
    let e = this.paraChart.isControlPanelOpen ? "expanded" : "collapsed";
    const t = {
      icon: "icons",
      iconLabel: "icons-labels",
      label: "labels"
    };
    return Ht`
      <div id="wrapper">
        <fizz-tabs
          ${ge(this._tabsRef)}
          ?open=${this.settings.isControlPanelDefaultOpen}
          class=${e}
          tablabelmode=${t[this.settings.tabLabelStyle]}
		  openbuttonarialabel="ParaCharts control panel"
          @open=${() => {
      this.paraChart.isControlPanelOpen = !0, this.settings.caption.isCaptionExternalWhenControlPanelClosed && this._descriptionPanelRef.value.internalizeCaptionBox();
    }}
          @close=${() => {
      this.paraChart.isControlPanelOpen = !1, this.settings.caption.isCaptionExternalWhenControlPanelClosed && this.externalizeCaptionBox();
    }}
          @invalidvalue=${(r) => this._msgDialogRef.value.show(r.detail)}
          @ready=${() => {
    }}
        >
          <fizz-tab-panel
            tablabel="Description"
            icon=${J6t}
          >
            <para-description-panel
              ${ge(this._descriptionPanelRef)}
              .controlPanel=${this}
            ></para-description-panel>
          </fizz-tab-panel>
          <fizz-tab-panel
            tablabel="Data"
            icon=${X6t}
            ?hidden=${!this.settings.isDataTabVisible}
          >
            <para-data-panel
              ${ge(this._dataPanelRef)}
              .controlPanel=${this}
              .sparkBrailleData=${this.sparkBrailleData}
              .isSparkBrailleVisible=${this.settings.isSparkBrailleVisible}
            ></para-data-panel>
          </fizz-tab-panel>
          <fizz-tab-panel
            tablabel="Colors"
            icon=${txt}
            ?hidden=${!this.settings.isColorsTabVisible}
          >
            <para-colors-panel
              ${ge(this._colorsPanelRef)}
              .controlPanel=${this}
            ></para-colors-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Audio"
            icon=${ext}
            ?hidden=${!this.settings.isAudioTabVisible}
          >
            <para-audio-panel
              .controlPanel=${this}
            ></para-audio-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Controls"
            icon=${rxt}
            ?hidden=${!this.settings.isControlsTabVisible}
          >
            <para-controls-panel
              ${ge(this._controlsPanelRef)}
              .controlPanel=${this}
            ></para-controls-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Chart"
            icon=${nxt}
            ?hidden=${!this.settings.isChartTabVisible}
          >
            <para-chart-panel
              ${ge(this._chartPanelRef)}
              .controlPanel=${this}
            ></para-chart-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Annotations"
            icon=${AP}
            ?hidden=${!this.settings.isAnnotationsTabVisible}
          >
            <para-annotation-panel
              ${ge(this._annotationPanelRef)}
              .controlPanel=${this}
            ></para-annotation-panel>
          </fizz-tab-panel>

          <!--<fizz-tab-panel
            tablabel="Analysis"
            icon=${AP}
            ?hidden=${!this.settings.isAnalysisTabVisible}
          >
            <para-analysis-panel
              .controlPanel=${this}
            ></para-analysis-panel>
          </fizz-tab-panel>-->
        </fizz-tabs>
      </div>
      ${this.renderDialog()}
    `;
  }
  renderDialog() {
    return Ht`
      <para-dialog
        ${ge(this._dialogRef)}
        id="generic-dialog"
      ></para-dialog>
      <fizz-msg-dialog
        ${ge(this._msgDialogRef)}
      ></fizz-msg-dialog>
    `;
  }
  renderTabDebug() {
    return Ht`
      <fizz-tab-panel tablabel="Debug">
        <div class="tab-content">
          <div
            class="setting-views"
          >
          </div>
        </div>
      </fizz-tab-panel>
    `;
  }
  getJsonStr(e, t, r) {
    return t ? `
        <pre><code>${JSON.stringify(e, null, r)}
        </code></pre>
      ` : JSON.stringify(e, null, r);
  }
};
v0.styles = [
  //styles,
  Te`
      * {
        font-family: "Trebuchet MS", Helvetica, sans-serif;
        font-size: var(--control-panel-font-size, 1rem);
      }
      #wrapper {
        position: relative;
      }
      fizz-tabs {
        --background: #eee;
        --toggle-button-icon: var(--control-panel-icon, url(${du(ixt)}));
        /*--control-panel-icon: url(${du(z$)});*/
        --summary-marker-font-weight: bold;
        --control-panel-icon-size: 1.1rem;
        --contents-margin: 2px 0 0 0;
        width: 1;
        min-width: 40rem;
        max-width: 50%;
      }
      fizz-tabs.collapsed {
        /*width: rem;*/
        /*min-width: unset;*/
        position: absolute;
        bottom: 10px;
        /*--background: none;
        --control-panel-background: none;
        --control-panel-icon-color: var(--theme-color);
        --control-panel-icon-size: 1.5rem;
        --theme-contrast-color: var(--theme-color);
        --border: none;*/
        border: 2px solid transparent;
      }

      fizz-tabs.expanded {
        border: 2px solid var(--theme-color);
        border-radius: 4px;
        --background: none;
        --control-panel-icon-color: ghostwhite;
        --summary-padding: 0 0.35rem;
        --summary-margin: -2px 0;
      }

      fizz-tabs.collapsed.darkmode  {
        --control-panel-icon-color: ghostwhite;
      }
    `
];
aS([
  Qt()
], v0.prototype, "sparkBrailleData", 2);
aS([
  Lr()
], v0.prototype, "dataState", 2);
v0 = aS([
  Oe("para-control-panel")
], v0);
var axt = Object.defineProperty, lxt = Object.getOwnPropertyDescriptor, lS = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? lxt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && axt(t, r, i), i;
};
let w0 = class extends ka(zi) {
  constructor() {
    super(...arguments), this._lastSpans = /* @__PURE__ */ new Set(), this._prevSpanIdx = 0, this._highlightManualOverride = !1, this._caption = { text: "", html: "" }, this._spans = [], this._isEBarVisible = !1;
  }
  get highlightManualOverride() {
    return this._highlightManualOverride;
  }
  connectedCallback() {
    super.connectedCallback(), this.setCaption(), this._storeChangeUnsub = this._store.subscribe(this.setCaption.bind(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._storeChangeUnsub();
  }
  updated(e) {
    if (!this._store.settings.ui.isNarrativeHighlightEnabled) return;
    const t = this.getSpans();
    this._spans = this._spans.filter((r) => t.includes(r)), t.forEach((r, n) => {
      this._spans.includes(r) || (this._spans.push(r), r.addEventListener("pointerenter", (i) => {
        if (!this._store.settings.ui.isNarrativeHighlightEnabled || this._store.paraChart.ariaLiveRegion.voicing.isSpeaking) return;
        const s = this._store.announcement.highlights[n];
        this._store.paraChart.postNotice("utteranceBoundary", s);
      }));
    });
  }
  clearStatusBar() {
    this.parachart.clearAriaLive();
  }
  async setCaption() {
    this._store.dataState === "complete" && (this._summarizer || (this.store.model.type === "pie" || this.store.model.type === "donut" ? this._summarizer = new Qb(this.store.model) : this._summarizer = new Gb(this.store.model)), this._caption = await this._summarizer.getChartSummary());
  }
  noticePosted(e, t) {
    if (this._store.settings.ui.isNarrativeHighlightEnabled) {
      if (e === "utteranceBoundary") {
        const r = t;
        for (const n of this.getSpans())
          n.dataset.phrasecode === `${r.phrasecode}` ? (n.classList.add("highlight"), this._lastSpans.add(n)) : (n.classList.remove("highlight"), this._lastSpans.delete(n));
      } else if (e === "utteranceEnd" && !this._highlightManualOverride)
        for (const r of this._lastSpans)
          r.classList.remove("highlight");
    }
  }
  highlightSpan(e = !0) {
    const t = (o) => {
      const a = document.createElement("div");
      return a.innerHTML = this._store.announcement.html, a.children[o].innerText;
    }, r = this._store.paraChart.ariaLiveRegion.voicing;
    let n = this._prevSpanIdx;
    this._highlightManualOverride || (n = r.highlightIndex, this._highlightManualOverride = !0), n = Math.min(
      this._store.announcement.highlights.length - 1,
      Math.max(0, n + (e ? 1 : -1))
    ), this._prevSpanIdx = n;
    const i = t(n), s = this._store.announcement.highlights[n];
    r.shutUp(), r.speakText(i), this._store.paraChart.postNotice("utteranceBoundary", s);
  }
  clearSpanHighlights() {
    for (const e of this.getSpans())
      e.classList.remove("highlight");
  }
  renderSummary(e, t) {
    return typeof e == "string" && (e = { text: e, html: e }), Ht`
      <article>
        ${y$(e.html)}
      </article>
    `;
  }
  getSpans() {
    return Array.from(this.renderRoot.querySelectorAll("span"));
  }
  render() {
    this._isEBarVisible = !!this.store.announcement.text && this._store.announcement.text !== this._caption.text;
    const e = !this._isEBarVisible || !this._store.settings.controlPanel.isExplorationBarVisible;
    return Ht`
      <figcaption class=${this.parachart.isControlPanelOpen ? "" : "external"}>
        <div id="caption-box">
          <div
            id="caption"
            class=${e ? "solo" : ""}
            ?hidden=${!this._store.settings.controlPanel.isCaptionVisible}
          >
            ${this.renderSummary(this._caption, "caption")}
          </div>
          <div
            id="exploration-bar"
            class=${e ? "hidden" : ""}
          >
            <div
              id="exploration-bar-text"
              aria-hidden="true"
            >
              ${this._store.announcement.text === this._caption.text ? "" : this.renderSummary(this._store.announcement, "statusbar")}
            </div>
            ${!this._store.settings.controlPanel.caption.isCaptionExternalWhenControlPanelClosed || this.parachart.isControlPanelOpen ? Ht`
                <button
                  @click=${() => this.parachart.showAriaLiveHistory()}
                >
                  History
                </button>` : ""}
          </div>
        </div>
      </figcaption>
    `;
  }
};
w0.styles = [
  Te`
      figcaption.external {
        border: var(--caption-border);
      }
      #caption-box {
        display: grid;
        grid-template-columns: var(--caption-grid-template-columns);
      }
      #caption {
        padding: 0.25rem;
      }
      #caption.solo {
        grid-column: 1 / 3
      }
      #exploration-bar {
        background-color: var(--theme-color-light);
        padding: 0.2rem;
        display: var(--exploration-bar-display);
        flex-direction: column;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
      }
      #exploration-bar-text {
        align-self: flex-start;
      }
      #caption span.highlight {
        background-color: var(--theme-color-light);
      }
      #exploration-bar span.highlight {
        background-color: white;
      }
      #exploration-bar.hidden {
        /* Using this rather than 'hidden' attr to override flex display */
        display: none;
      }
    `
];
lS([
  Qt({ attribute: !1 })
], w0.prototype, "parachart", 2);
lS([
  Lr()
], w0.prototype, "_caption", 2);
w0 = lS([
  Oe("para-caption-box")
], w0);
const cxt = "./node_modules/@fizz/chart-data/data/";
class uxt {
  constructor() {
    this._csvParseResult = null;
  }
  async load(t, r, n, i) {
    let s;
    if (t === "content")
      s = JSON.parse(r);
    else {
      let a = "";
      t === "fizz-chart-data" && (a = cxt), a += r, console.log(`loading manifest from ${a}`), s = await (await fetch(a)).json();
    }
    let o;
    if (s.datasets[0].data.source === "external") {
      s.datasets[0].data.source = "inline", o = {}, s.datasets[0].data.path !== "para:preload" && this.preloadData(s.datasets[0].data.path);
      const a = s.datasets[0].series.map((c) => c.key), l = this._csvParseResult.meta.fields.filter((c) => !a.includes(c))[0];
      this._csvParseResult.data.forEach((c, h) => {
        Object.entries(c).forEach(([u, p]) => {
          a.includes(u) && (o[u] || (o[u] = []), o[u].push({
            x: c[l],
            y: p
          }));
        });
      }), s.datasets[0].series.forEach((c) => {
        c.records = o[c.key];
      });
    }
    return console.log("manifest loaded"), n && (s.datasets[0].type = n, console.log("manifest chart type changed")), i && (s.datasets[0].description = i, console.log("manifest description changed")), { result: "success", manifest: s };
  }
  /**
   * Fetch and parse a CSV, storing the parse results.
   * @param url - CSV URL
   * @returns List of FieldInfo records
   */
  async preloadData(t) {
    const r = await (await fetch(t)).text();
    return IL.parse(r, {
      header: !0,
      complete: (n) => {
        this._csvParseResult = n;
      },
      error: (n) => {
        throw new Error(`Papa Parse error: ${n}`);
      }
    }), this._csvParseResult.meta.fields.map((n) => ({
      name: n,
      // XXX need to detect date formats
      type: isNaN(parseFloat(this._csvParseResult.data[0][n])) ? "string" : "number"
    }));
  }
}
class hxt {
  constructor() {
    this._customPrefix = "--para-", this._paraRules = {}, this._colorPalette = null, this._symbolSet = null;
  }
  get store() {
    return this._store;
  }
  set store(t) {
    this._store = t;
  }
  // Convert `paraRules` to object of key-value pairs of type SettingInput
  processProperties() {
    this._getParaRules();
    const t = {};
    return Object.keys(this._paraRules).forEach((r) => {
      const n = r.replace(/\s+/g, "").substring(1), i = this._paraRules[r];
      console.log(r, i), Object.keys(i).forEach((s) => {
        const o = i[s], a = this._isColorProp(s), l = this._isSymbolProp(s);
        if (!a && !l) {
          console.log(s, o);
          const c = this._convertPropToSettingStr(s);
          let h = o, u = parseFloat(o);
          Number.isNaN(u) ? o === "true" ? h = !0 : o === "false" ? h = !1 : this._hasDoubleQuotes(o) && (h = this._trimQuotes(o)) : h = u, t[`${n}.${c}`] = h;
        } else a ? this._processColorProps(s, o) : l && this._processSymbolProps(s, o);
      });
    }), t;
  }
  _isSameDomain(t) {
    return t.href ? t.href.indexOf(window.location.origin) === 0 : !0;
  }
  // returns boolean and narrows type to CSSStyleRule
  _isStyleRule(t) {
    return t instanceof CSSStyleRule;
  }
  _isParaProp(t) {
    return t.startsWith(this._customPrefix);
  }
  _getParaRules() {
    const t = [...document.styleSheets].filter(this._isSameDomain);
    for (const r of t) {
      const n = [...r.cssRules].filter(this._isStyleRule);
      for (const i of n) {
        const s = [...i.style].filter(this._isParaProp.bind(this)).map((o) => ({
          [o]: i.style.getPropertyValue(o)
        }));
        if (s.length) {
          const o = i.selectorText;
          this._paraRules[o] ? console.warn(`[ParaCharts] Duplicate selector '${o}'; collecting all properties`) : this._paraRules[o] = {}, s.forEach((a) => {
            Object.entries(a).forEach(([l, c]) => {
              this._convertPropToSettingStr(l);
              const h = this._paraRules[o][l];
              if (h) {
                const u = h === c ? `[ParaCharts] Duplicate value '${c}' for property '${l}' in selector '${o}'` : `[ParaCharts] Replaced value '${h}' with value '${c}' for property '${l}' in selector '${o}'`;
                console.warn(u);
              }
              this._paraRules[o][l] = c;
            });
          });
        }
      }
    }
  }
  _hasDoubleQuotes(t) {
    return t.startsWith('"') && t.endsWith('"') || t.startsWith("'") && t.endsWith("'");
  }
  _trimQuotes(t) {
    return t.replace(/['"]/g, "");
  }
  _convertPropToSettingStr(t) {
    const r = t.replace(this._customPrefix, "");
    return this._convertKebabToCamelCase(r);
  }
  _convertKebabToCamelCase(t) {
    return t.replace(/-./g, (n) => n[1].toUpperCase());
  }
  _convertCamelToKebabCase(t) {
    return t.replace(/[A-Z0-9]+(?![a-z0-9])|[A-Z]/g, (n, i) => (i ? "-" : "") + n.toLowerCase());
  }
  _isColorProp(t) {
    const r = t.match(/series-\d+-color/gi), n = t.match(/palette/gi);
    return !!(r != null && r.length || n != null && n.length);
  }
  _processColorProps(t, r) {
    if (this._colorPalette || (this._colorPalette = {
      key: "custom-0",
      title: "Custom palette",
      colors: []
    }), t === `${this._customPrefix}palette`) {
      const n = r.split(/,\s+/);
      this._colorPalette.key = this._trimQuotes(n[0]), this._colorPalette.title = this._trimQuotes(n[1]);
    } else {
      const n = parseInt(t.match(/\d+/g)[0]), i = r.split(/,\s+['"]/);
      console.log("color valueArray", i), this._colorPalette.colors[n] = {
        value: i[0],
        name: this._trimQuotes(i[1])
      };
    }
  }
  registerColors() {
    this._colorPalette && (this._store.colors.addPalette(this._colorPalette), this._store.colors.selectPaletteWithKey(this._colorPalette.key));
  }
  _isSymbolProp(t) {
    const r = t.match(/series-\d+-symbol/gi);
    return !!(r != null && r.length);
  }
  _processSymbolProps(t, r) {
    this._symbolSet || (this._symbolSet = []);
    const n = parseInt(t.match(/\d+/g)[0]), i = r.split(/,\s+['"]/), s = this._trimQuotes(i[0]), o = this._trimQuotes(i[1]);
    this._symbolSet[n] = `${s}.${o}`;
  }
  registerSymbols() {
    this._symbolSet && (this._store.symbols.types = this._symbolSet);
  }
}
class pxt {
  constructor(t) {
    this._selector = t, this._declarations = /* @__PURE__ */ new Map();
  }
  get selector() {
    return this._selector;
  }
  set(t) {
    Object.entries(t).forEach(([r, n]) => {
      this._declarations.set(r, n);
    });
  }
  toString() {
    return `${this._selector} {
${this._declarations.entries().map(([t, r]) => `  ${t}: ${typeof r == "function" ? r() : r.toString()};`).toArray().join(`
`)}
}`;
  }
}
class dxt {
  constructor(t) {
    this._stylesheet = t, this._rules = /* @__PURE__ */ new Map();
  }
  set(t, r) {
    let n = this._rules.get(t);
    n || (n = new pxt(t), this._rules.set(t, n)), n.set(r);
  }
  update() {
    this._rules.values().map((r) => {
      const n = r.selector.split(" "), i = new RegExp(["^", ...n, "\\{"].join("\\s*"));
      return Array.from(this._stylesheet.cssRules).findIndex((s) => s.cssText.match(i));
    }).filter((r) => r !== -1).toArray().sort().reverse().forEach((r) => {
      console.log("DEL", r), this._stylesheet.deleteRule(r);
    }), this._rules.values().forEach((r) => {
      console.log("INS", r), this._stylesheet.insertRule(r.toString());
    });
  }
}
class $h {
  constructor(t) {
    const r = t.store, n = () => t.documentView.chartInfo, i = () => t.documentView.chartLayers.dataLayer;
    this._commands = {
      key(s) {
        return r.keymapManager.onKeydown(s);
      },
      click(s, o, a = !1) {
        const l = i().datapointView(s, o);
        return l ? (n().navMap.goTo(n().navDatapointType, {
          seriesKey: l.seriesKey,
          index: l.index
        }), n().selectCurrent(a), !0) : !1;
      }
    };
  }
  static getInst(t) {
    return $h._inst || ($h._inst = new $h(t)), $h._inst;
  }
  get commands() {
    return this._commands;
  }
}
class fxt {
  constructor(t) {
    this._paraChart = t;
    const r = t.store, n = t.paraView;
    this._allSeries = r.model.seriesKeys.map((a) => new gxt(a, this));
    const i = () => t.paraView.documentView.chartInfo, s = this;
    this._standardActions = {
      move(a) {
        i().clearPlay(), i().move(a.direction);
      },
      goFirst() {
        i().navFirst();
      },
      goLast() {
        i().navLast();
      },
      goMinimum() {
        i().goSeriesMinMax(!0);
      },
      goMaximum() {
        i().goSeriesMinMax(!1);
      },
      goTotalMinimum() {
        i().goChartMinMax(!0);
      },
      goTotalMaximum() {
        i().goChartMinMax(!1);
      },
      select() {
        i().selectCurrent(!1);
      },
      extendSelection() {
        i().selectCurrent(!0);
      },
      clearSelection() {
        i().clearDatapointSelection();
      },
      playRight() {
        i().playDir("right");
      },
      playLeft() {
        i().playDir("left");
      },
      stopPlay() {
        i().clearPlay();
      },
      queryData() {
        i().queryData();
      },
      toggleSonificationMode() {
        r.updateSettings((a) => {
          a.sonification.isSoniEnabled = !a.sonification.isSoniEnabled;
          const l = a.sonification.isSoniEnabled ? "enable" : "disable";
          r.announce(`Sonification ${l + "d"}`), t.postNotice(l + "Sonification", null);
        });
      },
      toggleTrendNavigationMode() {
        r.updateSettings((a) => {
          a.type.line.isTrendNavigationModeEnabled = !a.type.line.isTrendNavigationModeEnabled;
          const l = a.type.line.isTrendNavigationModeEnabled ? "enable" : "disable";
          r.announce(`Trend navigation ${l + "d"}`), t.postNotice(l + "TrendNavigation", null);
        });
      },
      toggleAnnouncementMode() {
        r.settings.ui.isAnnouncementEnabled ? (r.announce("Announcements disabled"), r.updateSettings((a) => {
          a.ui.isAnnouncementEnabled = !1;
        }), t.postNotice("disableAnnouncements", null)) : (r.updateSettings((a) => {
          a.ui.isAnnouncementEnabled = !0;
        }), r.announce("Announcements enabled"), t.postNotice("enableAnnouncements", null));
      },
      toggleVoicingMode() {
        r.updateSettings((a) => {
          a.ui.isVoicingEnabled = !a.ui.isVoicingEnabled;
          const l = a.ui.isVoicingEnabled ? "enable" : "disable";
          t.postNotice(l + "Voicing", null);
        });
      },
      toggleDarkMode() {
        r.updateSettings((a) => {
          a.color.isDarkModeEnabled = !a.color.isDarkModeEnabled;
          const l = a.color.isDarkModeEnabled ? "enable" : "disable";
          t.postNotice(l + "DarkMode", null), r.announce(`Dark mode ${l + "d"}`);
        });
      },
      toggleLowVisionMode() {
        r.updateSettings((a) => {
          a.ui.isLowVisionModeEnabled ? (a.ui.isFullscreenEnabled = !1, t.postNotice("disableLowVisionMode", null)) : (a.ui.isLowVisionModeEnabled = !0, t.postNotice("enableLowVisionMode", null));
        });
      },
      openHelp() {
        t.controlPanel.showHelpDialog();
      },
      announceVersionInfo() {
        r.announce(`Version ${__APP_VERSION__}; commit ${__COMMIT_HASH__}`);
      },
      jumpToChordLanding() {
        i().navToChordLanding();
      },
      shutUp() {
        t.ariaLiveRegion.voicing.shutUp();
      },
      repeatLastAnnouncement() {
        t.ariaLiveRegion.replay();
      },
      addAnnotation() {
        r.addAnnotation();
      },
      toggleNarrativeHighlightMode() {
        n.startNarrativeHighlightMode(), s._actions = s._narrativeActions, r.updateSettings((a) => {
          a.ui.isNarrativeHighlightEnabled = !0;
          //!draft.ui.isNarrativeHighlightEnabled;
          t.postNotice("enableNarrativeHighlightMode", null);
        });
      },
      playPauseMedia() {
      },
      reset() {
        r.clearSelected(), i().navMap.root.goTo("top", {}), n.createDocumentView();
      }
    }, this._actions = this._standardActions, this._narrativeActions = Object.create(this._actions);
    const o = n.paraChart.ariaLiveRegion.voicing;
    this._narrativeActions.move = async (a) => {
      r.paraChart.captionBox.highlightSpan(a.direction === "right" || a.direction === "down");
    }, this._narrativeActions.goFirst = () => {
    }, this._narrativeActions.goLast = () => {
    }, this._narrativeActions.repeatLastAnnouncement = () => {
    }, this._narrativeActions.toggleNarrativeHighlightMode = () => {
      t.captionBox.clearSpanHighlights(), r.clearHighlight(), r.clearAllSeriesLowlights(), n.endNarrativeHighlightMode(), s._actions = this._standardActions, r.settings.ui.isNarrativeHighlightEnabled ? r.updateSettings((a) => {
        a.ui.isNarrativeHighlightEnabled = !1;
      }) : r.updateSettings((a) => {
        a.ui.isNarrativeHighlightEnabled = !0;
      });
    }, this._narrativeActions.playPauseMedia = () => {
      o.togglePaused();
    };
  }
  get paraChart() {
    return this._paraChart;
  }
  get chartInfo() {
    return this._paraChart.paraView.documentView.chartInfo;
  }
  get allSeries() {
    return this._allSeries;
  }
  get actions() {
    return this._actions;
  }
  doAction(t, r) {
    this._actions[t](r);
  }
  getSeries(t) {
    return this.getAllSeries(t)[0];
  }
  getAllSeries(...t) {
    const r = Array.from(new Set(t)), n = [];
    for (const i of r) {
      const s = this._allSeries.find((o) => o.key === i);
      if (!s) throw new Error(`no series with key '${i}'`);
      n.push(s);
    }
    return n;
  }
  // sendKey(keyId: string) {
  //   this._paraChart.command('key', [keyId]);
  // }
  serializeChart() {
    return this._paraChart.paraView.serialize();
  }
  downloadSVG() {
    this._paraChart.paraView.downloadSVG();
  }
  downloadPNG() {
    this._paraChart.paraView.downloadPNG();
  }
  setSetting(t, r) {
    this._paraChart.store.updateSettings((n) => {
      dr.set(t, r, n);
    });
  }
  clearAllSeriesLowlights() {
    this._paraChart.store.clearAllSeriesLowlights();
  }
  enableNarrativeActions() {
    this._actions = this._narrativeActions;
  }
  enableStandardActions() {
    this._actions = this._standardActions;
  }
}
class gxt {
  constructor(t, r) {
    this._key = t, this._api = r, this._datapoints = [...r.paraChart.store.model.atKey(t).datapoints], this._allPoints = this._datapoints.map((n) => new mxt(n, this));
  }
  get key() {
    return this._key;
  }
  get api() {
    return this._api;
  }
  get allPoints() {
    return this._allPoints;
  }
  getPoint(t) {
    return this.getPoints(t)[0];
  }
  getPoints(...t) {
    const r = Array.from(new Set(t)), n = [];
    for (const i of r) {
      const s = this._allPoints[i];
      if (!s) throw new Error(`invalid index '${i}'`);
      n.push(s);
    }
    return n;
  }
  lowlight() {
    this._api.paraChart.store.lowlightSeries(this._key);
  }
  clearLowlight() {
    this._api.paraChart.store.clearSeriesLowlight(this._key);
  }
  isLowlighted() {
    return this._api.paraChart.store.isSeriesLowlighted(this._key);
  }
  lowlightOthers() {
    this._api.paraChart.store.lowlightOtherSeries(this._key);
  }
  playRiff() {
    this._api.chartInfo.playRiff(this._datapoints);
  }
}
class mxt {
  constructor(t, r) {
    this._datapoint = t, this._apiSeries = r;
  }
  visit() {
    this._apiSeries.api.chartInfo.navMap.goTo(this._apiSeries.api.chartInfo.navDatapointType, {
      seriesKey: this._datapoint.seriesKey,
      index: this._datapoint.datapointIndex
    });
  }
  select(t = !1) {
    this.visit(), this._apiSeries.api.chartInfo.selectCurrent(t);
  }
  highlight() {
  }
  clearHighlight() {
  }
  play() {
    this._apiSeries.api.chartInfo.playDatapoints([this._datapoint]);
  }
  annotate(t) {
    this._apiSeries.api.paraChart.store.annotatePoint(
      this._apiSeries.key,
      this._datapoint.datapointIndex,
      t
    );
  }
}
class yxt {
  constructor(t) {
    this.parachart = t, this.chartId = this.parachart.id, this._events = /* @__PURE__ */ new Map(), this.steps = [], this.globalOffset = { format: "percent", value: 0.5 }, this.containerElement = void 0, this.rootElement = null, this.progressThreshold = 0, this.isEnabled = !1, this.isProgress = !1, this.isTriggerOnce = !1, this.exclude = [], this.currentScrollY = 0, this.comparisonScrollY = 0, this.direction = void 0, this._handleScroll = this._handleScroll.bind(this), this._resizeStep = this._resizeStep.bind(this), this._intersectStep = this._intersectStep.bind(this), this._intersectProgress = this._intersectProgress.bind(this), this.settings = this.parachart.paraView.store.settings.scrollytelling, this.settings.isScrollytellingEnabled && this.init();
  }
  init() {
    var t;
    this.stepElements = document.querySelectorAll("[data-para-step]"), this.setup({
      step: "[data-para-step]",
      offset: 0.5,
      progress: !0,
      once: !1
    }), this.on("stepEnter", (r) => {
      const n = r.element;
      this.highlightPageContent(n);
      for (const { action: i, params: s } of r.actions) {
        if (i === "highlightSeries" && s.length > 0 && this.parachart.store.lowlightOtherSeries(...s), i === "highlightDatapoint" && s.length >= 2 && this.parachart.api.getSeries(s[0]).getPoint(+s[1]).select(), i === "directLabels") {
          console.warn("directLabels", s);
          const o = s[0] === "true";
          this.parachart.api.setSetting("chart.hasDirectLabels", o);
        }
        if (i === "hasSymbols") {
          console.warn("hasSymbols", s);
          const o = s[0] === "true";
          this.parachart.api.setSetting("chart.isDrawSymbols", o);
        }
        i === "setColorPalette" && (console.warn("setColorPalette", s), this.parachart.api.setSetting("color.colorPalette", s[0])), i === "setManifest" && (console.warn("manifest", s), console.warn("this.parachart", this.parachart), this.parachart.setAttribute("manifest", s[0]));
      }
    }), this.on("stepExit", (r) => {
      if (r.element, r.direction === "down")
        console.warn("SCROLLY: exit down", r);
      else {
        console.warn("SCROLLY: exit up", r), console.warn("SCROLLY: reverse action!");
        for (const { action: n, params: i } of r.actions)
          n === "highlightDatapoint" && i.length >= 2 && this.parachart.api.getSeries(i[0]).getPoint(+i[1]).select();
      }
    }), (t = this.stepElements[0]) == null || t.classList.add("para-active");
  }
  highlightPageContent(t) {
    this.stepElements.forEach((r) => r.classList.remove("para-active")), t.classList.add("para-active");
  }
  // internal helpers
  getChartSteps(t, r = document) {
    return this.selectAll(t, r).filter((i) => {
      const s = i.dataset.paraChartid;
      return !s || s === this.chartId;
    });
  }
  selectAll(t, r = document) {
    return typeof t == "string" ? Array.from(r.querySelectorAll(t)) : t instanceof Element ? [t] : t instanceof NodeList ? Array.from(t) : Array.isArray(t) ? t : [];
  }
  getIndex(t) {
    const r = t.getAttribute("data-scrollytelling-index");
    return r ? +r : 0;
  }
  indexSteps(t) {
    t.forEach(
      (r) => r.node.setAttribute("data-scrollytelling-index", r.index.toString())
    );
  }
  getOffsetTop(t) {
    const { top: r } = t.getBoundingClientRect(), n = window.pageYOffset, i = document.body.clientTop || 0;
    return r + n - i;
  }
  parseOffset(t) {
    if (typeof t == "string" && t.indexOf("px") > 0) {
      const r = +t.replace("px", "");
      return isNaN(r) ? (this.err('offset value must be in "px" format. Fallback to 0.5.'), { format: "percent", value: 0.5 }) : { format: "pixels", value: r };
    } else if (typeof t == "number" || t != null && !isNaN(+t)) {
      const r = typeof t == "number" ? t : +t;
      return r > 1 && this.err("offset value is greater than 1. Fallback to 1."), r < 0 && this.err("offset value is lower than 0. Fallback to 0."), { format: "percent", value: Math.min(Math.max(0, r), 1) };
    }
    return { format: "percent", value: 0.5 };
  }
  getActions(t) {
    let r = [];
    const n = this.parseActions(t.dataset.paraAction);
    r.push(...n);
    const i = t.querySelectorAll("[data-para-action]");
    return Array.from(i).filter((o) => {
      const a = o.dataset.paraChartid;
      return !a || a === this.chartId;
    }).forEach((o) => {
      const a = this.parseActions(o.dataset.paraAction);
      r.push(...a);
    }), r;
  }
  parseActions(t) {
    if (!t) return [];
    const r = [];
    return t.split(")").forEach((i) => {
      if (i = i.trim(), i) {
        const s = i.split("("), o = s[0].trim(), a = s[1] ? s[1].trim() : "", l = a ? a.split(",").map((c) => c.trim()) : [];
        r.push({
          action: o,
          params: l
        });
      }
    }), r;
  }
  err(t) {
    console.error(`scrollytelling: ${t}`);
  }
  createProgressThreshold(t, r) {
    const n = Math.ceil(t / r), i = [], s = 1 / n;
    for (let o = 0; o < n + 1; o += 1) i.push(o * s);
    return i;
  }
  _resetExclusions() {
    this.exclude = [];
  }
  on(t, r) {
    return this._events.has(t) || this._events.set(t, []), this._events.get(t).push(r), this;
  }
  once(t, r) {
    const n = (i) => {
      r(i), this.off(t, n);
    };
    return this.on(t, n);
  }
  off(t, r) {
    if (!t)
      this._events.clear();
    else if (!r)
      this._events.delete(t);
    else {
      const n = this._events.get(t);
      if (n) {
        const i = n.indexOf(r);
        i > -1 && n.splice(i, 1);
      }
    }
    return this;
  }
  emit(t, r) {
    const n = this._events.get(t);
    n && n.forEach((i) => i(r));
  }
  _disconnectObserver(t) {
    Object.keys(t).forEach((r) => t[r].disconnect());
  }
  _disconnectObservers() {
    this.steps.forEach((t) => this._disconnectObserver(t.observers));
  }
  _handleEnable(t) {
    t && !this.isEnabled && this._updateObservers(), !t && this.isEnabled && this._disconnectObservers(), this.isEnabled = t;
  }
  _notifyProgress(t, r) {
    const n = this.getIndex(t), i = this.steps[n];
    r !== void 0 && (i.progress = r);
    const s = { element: t, index: n, progress: r, direction: this.direction, actions: i.actions };
    i.state === "enter" && this.emit("stepProgress", s);
  }
  _notifyStepEnter(t) {
    const r = this.getIndex(t), n = this.steps[r], i = { element: t, index: r, direction: this.direction, actions: n.actions };
    n.direction = this.direction, n.state = "enter", this.exclude[r] || this.emit("stepEnter", i), this.isTriggerOnce && (this.exclude[r] = !0);
  }
  _notifyStepExit(t) {
    const r = this.getIndex(t), n = this.steps[r];
    if (!n.state) return !1;
    const i = { element: t, index: r, direction: this.direction, actions: n.actions };
    return this.isProgress && (this.direction === "down" && n.progress < 1 ? this._notifyProgress(t, 1) : this.direction === "up" && n.progress > 0 && this._notifyProgress(t, 0)), n.direction = this.direction, n.state = "exit", this.emit("stepExit", i), !0;
  }
  _handleScroll() {
    const t = this.containerElement ? this.containerElement.scrollTop : window.pageYOffset;
    this.currentScrollY !== t && (this.currentScrollY = t, this.currentScrollY > this.comparisonScrollY ? this.direction = "down" : this.currentScrollY < this.comparisonScrollY && (this.direction = "up"), this.comparisonScrollY = this.currentScrollY);
  }
  _setupScrollListener() {
    document.removeEventListener("scroll", this._handleScroll), document.addEventListener("scroll", this._handleScroll, { passive: !0 });
  }
  _resizeStep(t) {
    if (t.length === 0) return;
    const r = t[0], n = this.getIndex(r.target), i = this.steps[n], s = r.target.offsetHeight;
    s !== i.height && (i.height = s, this._disconnectObserver(i.observers), this._updateResizeObserver(i), this._updateStepObserver(i), this.isProgress && this._updateProgressObserver(i));
  }
  _intersectStep(t) {
    if (t.length === 0) return;
    const r = t[0];
    this._handleScroll();
    const { isIntersecting: n, target: i } = r;
    n ? this._notifyStepEnter(i) : this._notifyStepExit(i);
  }
  _intersectProgress(t) {
    if (t.length === 0) return;
    const r = t[0], n = this.getIndex(r.target), i = this.steps[n], { isIntersecting: s, intersectionRatio: o, target: a } = r;
    s && i.state === "enter" && this._notifyProgress(a, o);
  }
  _updateResizeObserver(t) {
    const r = new ResizeObserver(this._resizeStep);
    r.observe(t.node), t.observers.resize = r;
  }
  _updateResizeObservers() {
    this.steps.forEach((t) => this._updateResizeObserver(t));
  }
  _updateStepObserver(t) {
    const r = window.innerHeight, n = t.offset || this.globalOffset, i = n.format === "pixels" ? 1 : r, s = n.value * i, o = t.height / 2 - s, a = t.height / 2 - (r - s), l = `${o}px 0px ${a}px 0px`, c = this.rootElement, u = { rootMargin: l, threshold: 0.5, root: c }, p = new IntersectionObserver(this._intersectStep, u);
    p.observe(t.node), t.observers.step = p;
  }
  _updateStepObservers() {
    this.steps.forEach((t) => this._updateStepObserver(t));
  }
  _updateProgressObserver(t) {
    const r = window.innerHeight, n = t.offset || this.globalOffset, i = n.format === "pixels" ? 1 : r, s = n.value * i, o = -s + t.height, a = s - r, l = `${o}px 0px ${a}px 0px`, c = this.createProgressThreshold(t.height, this.progressThreshold), h = { rootMargin: l, threshold: c }, u = new IntersectionObserver(this._intersectProgress, h);
    u.observe(t.node), t.observers.progress = u;
  }
  _updateProgressObservers() {
    this.steps.forEach((t) => this._updateProgressObserver(t));
  }
  _updateObservers() {
    this._disconnectObservers(), this._updateResizeObservers(), this._updateStepObservers(), this.isProgress && this._updateProgressObservers();
  }
  setup({
    step: t,
    parent: r,
    offset: n = 0.5,
    threshold: i = 4,
    progress: s = !1,
    once: o = !1,
    container: a = void 0,
    root: l = null
  }) {
    this._setupScrollListener();
    const c = typeof t == "string" && r && document.querySelector(r) || document;
    return this.steps = this.getChartSteps(t, c).map((h, u) => ({
      index: u,
      direction: void 0,
      height: h.offsetHeight,
      node: h,
      observers: {},
      offset: this.parseOffset(h.dataset.offset),
      actions: this.getActions(h),
      top: this.getOffsetTop(h),
      progress: 0,
      state: void 0
    })), this.steps.length ? (this.isProgress = s, this.isTriggerOnce = o, this.progressThreshold = Math.max(1, +i), this.globalOffset = this.parseOffset(n), this.containerElement = a, this.rootElement = l, this.off(), this._resetExclusions(), this.indexSteps(this.steps), this._handleEnable(!0), this) : (console.log("scrollytelling: no step elements found"), this);
  }
  enable() {
    return this._handleEnable(!0), this;
  }
  disable() {
    return this._handleEnable(!1), this;
  }
  destroy() {
    return this._handleEnable(!1), this.off(), this._resetExclusions(), document.removeEventListener("scroll", this._handleScroll), this;
  }
  resize() {
    return this._updateObservers(), this;
  }
  get offset() {
    return this.globalOffset.value;
  }
  set offset(t) {
    this.globalOffset = this.parseOffset(t), this._updateObservers();
  }
}
class bxt {
  canLoadData(t) {
    return t.length !== 0 && t[0].tagName === "TABLE";
  }
  async findManifest(t, r, n) {
    if (r && (console.log(`Loading from manifest ID: ${r}`), document.getElementById(r)))
      if (document.getElementById(r).hasAttribute("src")) {
        const s = await (await fetch(document.getElementById(r).getAttribute("src"))).json();
        return n && (s.datasets[0].description = n, console.log("manifest description changed")), { result: "success", manifest: s };
      } else {
        let i = JSON.parse(document.getElementById(r).innerHTML);
        return { result: "success", manifest: this.validateManifest(t, i, n).manifest };
      }
    if (document.getElementsByClassName("manifest").length > 0) {
      let i = JSON.parse(document.getElementsByClassName("manifest")[0].innerHTML);
      return { result: "success", manifest: this.validateManifest(t, i, n).manifest };
    } else {
      console.log("Manifest ID not found or not present, attempting manifest construction from data");
      let i = {
        datasets: [{
          type: "",
          //chartTheme: {baseQuantity: 'Y unit', baseKind: 'number'}, 
          title: "",
          facets: {},
          series: [],
          data: { source: "inline" }
        }]
      };
      return { result: "success", manifest: this.validateManifest(t, i, n).manifest };
    }
  }
  validateManifest(t, r, n) {
    document.getElementsByTagName("para-chart")[0];
    const i = t[0], s = r.datasets[0];
    s.title || (s.title = this.findManifestTitle(i)), (!s.facets || !s.facets.keys) && (s.facets = this.loadFacets(i.rows[0]));
    const o = this.loadHeaders(i.rows[0]);
    if (!s.series || s.series.length === 0) {
      s.series = [];
      for (let l = 1; l < o.length; l++) {
        const c = {
          key: o[l].label,
          /*theme: { 
            baseQuantity: '',
            baseKind: 'number',
            entity: vars[i].label 
          },*/
          records: this.loadDataFromElement(t, r, o[l].label)
        };
        s.series.push(c);
      }
    }
    for (let l = 1; l < o.length; l++)
      r.datasets[0].series[0].records.length === 0 && (s.series[l].records = this.loadDataFromElement(t, r, o[l].label));
    s.type || (s.type = this.findManifestType(t, r)), s.data || (s.data = { source: "inline" }), s.settings || (s.settings = { "sonification.isEnabled": !0 });
    const a = o.map((l) => []);
    Array.from(i.rows).slice(1).forEach((l) => {
      this.loadRow(l, o).forEach((h, u) => {
        a[u].push(h);
      });
    });
    for (let l = 0; l < 2; l++) {
      let c = s.facets[Object.keys(s.facets)[l]];
      /%/.test(a[l][0]) && (c.measure = "ratio"), /\b(year|month|day)\b/i.test(o[l].label) ? c.datatype = "date" : isNaN(Number(a[l][0].replace("%", ""))) ? c.datatype = "string" : c.datatype = "number";
    }
    return n && (r.datasets[0].description = n, console.log("manifest description changed")), { result: "success", manifest: r };
  }
  loadDataFromElement(t, r, n) {
    if (!t.length || t[0].tagName !== "TABLE")
      throw console.log(t), new Error("'table' element must be provided");
    const i = t[0];
    let s = this.loadHeaders(i.rows[0]), o;
    n && (o = s.filter((h) => h.label == n)[0]);
    let a = s.indexOf(o);
    a == -1 && (a = 1);
    const l = s.map((h) => []);
    Array.from(i.rows).slice(1).forEach((h) => {
      this.loadRow(h, s).forEach((p, y) => {
        l[y].push(p);
      });
    });
    let c = [];
    for (let h = 0; h < l[0].length; h++)
      c.push({ x: l[0][h], y: l[a][h] });
    return c;
  }
  loadHeaders(t) {
    var s;
    const r = document.getElementsByTagName("para-chart")[0];
    if (!t)
      throw new Error("table must include a header row");
    const n = [];
    let i = 0;
    for (const o of t.children) {
      if (o.tagName !== "TD" && o.tagName !== "TH")
        throw new Error("immediate children of 'tr' element must be 'td' or 'th' elements");
      const a = ((s = o.textContent) == null ? void 0 : s.trim()) ?? "";
      if (!a)
        throw new Error("var name must be provided as 'td' element text content");
      let l = o.dataset.type ?? "string";
      if (!["string", "number", "date"].includes(l))
        throw new Error("var type must be provided as 'td' element 'data-type' attribute. Must be string, number, or date");
      const c = o.dataset.independent === "true" ? "independent" : "dependent";
      let h = o.dataset.measure ?? "nominal";
      const u = r.type == "pie" || r.type == "donut", p = ["horizontal", "vertical"];
      let y;
      u ? y = o.dataset.displayType ?? { type: "marking" } : y = o.dataset.displayType ?? { type: "axis", orientation: p[i] }, n.push({
        label: a,
        datatype: l,
        variableType: c,
        measure: h,
        displayType: y
      }), i++;
    }
    return n;
  }
  loadFacets(t) {
    let r = this.loadHeaders(t);
    if (r.length < 2)
      throw new Error("Error: please provide at least two variables");
    if (r.length === 2) {
      let o = { x: r[0], y: r[1] };
      return o.x.variableType = "independent", ["Year", "year", "Years", "years"].includes(o.x.label) ? o.x.units = "year" : o.x.units || (o.x.units = "point"), o;
    }
    let n;
    for (let o of r)
      if (o.variableType == "independent") {
        n = o;
        break;
      }
    n === void 0 && (n = r[0]);
    let i = "";
    for (let o of r.toSpliced(r.indexOf(n), 1)) {
      if (i.concat(o.label, " ").length > 50) {
        i = i.concat("...");
        break;
      }
      i = i.concat(o.label, ", ");
    }
    let s = { x: r[0], y: r[1] };
    return s.x.variableType = "independent", s.y.label = i, ["Year", "year", "Years", "years"].includes(s.x.label) ? s.x.units = "year" : s.x.units || (s.x.units = "point"), s;
  }
  loadRow(t, r) {
    if (!t || t.tagName !== "TR")
      throw new Error("immediate children of 'table' element must be 'tr' elements");
    const n = r.map((i) => "");
    return Array.from(t.children).forEach((i, s) => {
      if (i.tagName !== "TD")
        throw new Error("immediate children of 'tr' element must be 'td' elements");
      const o = i.textContent;
      if (!o)
        throw new Error("var value must be provided as 'td' element text content");
      n[s] = o;
    }), n;
  }
  findManifestTitle(t) {
    for (const r of t.children)
      if (r.nodeName === "CAPTION")
        return r.innerHTML;
    return t.hasAttribute("aria-label") ? t.getAttribute("aria-label") : t.hasAttribute("title") ? t.getAttribute("title") : `'${this.loadHeaders(t.rows[0])[0].label}' vs '${this.loadHeaders(t.rows[0])[1].label}'`;
  }
  findManifestType(t, r) {
    if (document.getElementsByTagName("para-chart")[0].hasAttribute("type"))
      return document.getElementsByTagName("para-chart")[0].getAttribute("type");
    throw new Error("Error: please provide a type for the para-chart");
  }
}
var vxt = Object.defineProperty, wxt = Object.getOwnPropertyDescriptor, V$ = (e) => {
  throw TypeError(e);
}, zo = (e, t, r, n) => {
  for (var i = n > 1 ? void 0 : n ? wxt(t, r) : t, s = e.length - 1, o; s >= 0; s--)
    (o = e[s]) && (i = (n ? o(t, r, i) : o(i)) || i);
  return n && i && vxt(t, r, i), i;
}, U$ = (e, t, r) => t.has(e) || V$("Cannot " + r), y1 = (e, t, r) => (U$(e, t, "read from private field"), r ? r.call(e) : t.get(e)), b1 = (e, t, r) => t.has(e) ? V$("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), v1 = (e, t, r, n) => (U$(e, t, "write to private field"), t.set(e, r), r), em, rm, nm, im;
const pS = class pS extends ka(zi) {
  constructor(t, r) {
    super(), this.headless = !1, b1(this, em, ""), this.manifestType = "url", this.data = "", b1(this, rm, {}), b1(this, nm), b1(this, im), this.isControlPanelOpen = !1, this._paraViewRef = we(), this._controlPanelRef = we(), this._ariaLiveRegionRef = we(), this._loader = new uxt(), this._slotLoader = new bxt(), this._loaderPromise = null, this._loaderResolver = null, this._loaderRejector = null;
    const n = new hxt(), i = n.processProperties();
    this.store = new xr(
      this,
      // XXX config won't get set until connectedCallback()
      Object.assign(i, this.config),
      this._suppleteSettingsWith,
      t,
      r
    ), this.captionBox = document.createElement("para-caption-box"), this.captionBox.store = this._store, this.captionBox.parachart = this, n.store = this.store, n.registerColors(), n.registerSymbols(), this._loaderPromise = new Promise((s, o) => {
      this._loaderResolver = s, this._loaderRejector = o;
    }), this._readyPromise = new Promise((s) => {
      this.addEventListener("paraviewready", async () => {
        if (s(), await f0t(), this.manifest)
          this.data && await this._loader.preloadData(this.data), this._runLoader(this.manifest, this.manifestType).then(() => {
            this.log("ParaCharts will now commence the raising of the roof and/or the dead"), this._paraAPI = new fxt(this), this._scrollyteller = new yxt(this);
          });
        else if (this.getElementsByTagName("table")[0]) {
          this.log("loading from slot");
          const o = this.getElementsByTagName("table")[0], a = this.getElementsByClassName("manifest")[0];
          if (this._store.dataState = "pending", o) {
            const l = await this._slotLoader.findManifest(
              [o, a],
              "some-manifest",
              this.description
            );
            this.log("loaded manifest"), l.result === "success" ? (this.store.setManifest(l.manifest), this._store.dataState = "complete") : this._store.dataState = "error";
          }
        } else
          console.log("No datatable in slot"), this._store.dataState = "error";
      });
    });
  }
  get manifest() {
    return y1(this, em);
  }
  set manifest(t) {
    v1(this, em, t);
  }
  get config() {
    return y1(this, rm);
  }
  set config(t) {
    v1(this, rm, t);
  }
  get forcecharttype() {
    return y1(this, nm);
  }
  set forcecharttype(t) {
    v1(this, nm, t);
  }
  get description() {
    return y1(this, im);
  }
  set description(t) {
    v1(this, im, t);
  }
  get paraView() {
    return this._paraViewRef.value;
  }
  get controlPanel() {
    return this._controlPanelRef.value;
  }
  get ready() {
    return this._readyPromise;
  }
  get loaded() {
    return this._loaderPromise;
  }
  get loader() {
    return this._loader;
  }
  get ariaLiveRegion() {
    return this._ariaLiveRegionRef.value;
  }
  get slotted() {
    return this._slotted;
  }
  get styleManager() {
    return this._styleManager;
  }
  get api() {
    return this._paraAPI;
  }
  get scrollyteller() {
    return this._scrollyteller;
  }
  connectedCallback() {
    super.connectedCallback(), this.isControlPanelOpen = this._store.settings.controlPanel.isControlPanelDefaultOpen, this._styleManager = new dxt(this.shadowRoot.adoptedStyleSheets[0]), this._styleManager.set(":host", {
      "--axis-line-color": "hsl(0, 0%, 0%)",
      "--label-color": "hsl(0, 0%, 0%)",
      "--tick-grid-color": "hsl(270, 50%, 50%)",
      "--background-color": "white",
      "--theme-color": "var(--fizz-theme-color, purple)",
      "--theme-color-light": "var(--fizz-theme-color-light, hsl(275.4, 100%, 88%))",
      "--theme-contrast-color": "white",
      "--fizz-theme-color": "var(--paracharts-theme-color, navy)",
      "--fizz-theme-color-light": "var(--paracharts-theme-color-light, hsl(210.5, 100%, 88%))",
      "--visited-color": () => this._store.colors.colorValue("visit"),
      "--highlighted-color": () => this._store.colors.colorValue("highlight"),
      "--visited-stroke-width": () => {
        var t, r;
        return ((r = (t = this._paraViewRef.value) == null ? void 0 : t.documentView) == null ? void 0 : r.chartLayers.dataLayer.visitedStrokeWidth) ?? 0;
      },
      "--selected-color": "var(--label-color)",
      "--datapoint-centroid": "50% 50%",
      "--focus-animation": "all 0.5s ease-in-out",
      "--chart-cursor": "pointer",
      "--data-cursor": "cell",
      "--focus-shadow-color": "gray",
      "--focus-shadow": "drop-shadow(0px 0px 4px var(--focus-shadow-color))",
      "--caption-border": () => this._store.settings.controlPanel.caption.hasBorder ? "solid 2px var(--theme-color)" : "none",
      "--caption-grid-template-columns": () => this._store.settings.controlPanel.isExplorationBarVisible && this._store.settings.controlPanel.isCaptionVisible && this._store.settings.controlPanel.caption.isExplorationBarBeside ? "2fr 1fr" : "1fr",
      "--exploration-bar-display": () => this._store.settings.controlPanel.isExplorationBarVisible ? "flex" : "none",
      "--chart-font-scale": () => this._store.settings.chart.fontScale,
      "--chart-title-font-size": () => this._store.settings.chart.title.fontSize,
      "--horiz-axis-title-font-size": () => this._store.settings.axis.horiz.title.fontSize,
      "--vert-axis-title-font-size": () => this._store.settings.axis.vert.title.fontSize,
      "--horiz-axis-tick-label-font-size": () => this._store.settings.axis.horiz.ticks.labels.fontSize,
      "--vert-axis-tick-label-font-size": () => this._store.settings.axis.vert.ticks.labels.fontSize,
      "--direct-label-font-size": () => this._store.settings.chart.directLabelFontSize,
      "--legend-label-font-size": () => this._store.settings.legend.fontSize,
      "--bar-label-font-size": () => this._store.settings.type.bar.labelFontSize,
      "--column-label-font-size": () => this._store.settings.type.column.labelFontSize,
      display: "block",
      "font-family": '"Trebuchet MS", Helvetica, sans-serif',
      "font-size": "var(--chart-view-font-size, 1rem)"
    }), this._store.settings.chart.isShowVisitedDatapointsOnly && (this._styleManager.set(".datapoint:not(.visited)", {
      display: "none"
    }), this._styleManager.set(".leg-right", {
      display: "none"
    })), this._styleManager.update();
  }
  firstUpdated(t) {
    this._commander = $h.getInst(this._paraViewRef.value);
  }
  willUpdate(t) {
    t.has("manifest") && this.manifest !== "" && this._paraViewRef.value && (this.log(`manifest changed: '${this.manifestType === "content" ? "<content>" : this.manifest}`), this._loaderPromise = this._runLoader(this.manifest, this.manifestType), this.dispatchEvent(new CustomEvent("manifestchange", { bubbles: !0, composed: !0, cancelable: !0 }))), t.has("config") && Object.entries(this.config).forEach(([r, n]) => this._store.updateSettings((i) => {
      dr.set(r, n, i);
    }));
  }
  async _runLoader(t, r) {
    this.log(`loading manifest: '${r === "content" ? "<content>" : t}'`), this._store.dataState = "pending";
    const n = await this._loader.load(
      this.manifestType,
      t,
      this.forcecharttype,
      this.description
    );
    this.log("loaded manifest"), n.result === "success" ? (this._manifest = n.manifest, this._store.setManifest(n.manifest, n.data), this._store.dataState = "complete", this._controlPanelRef.value.descriptionPanel.positionCaptionBox(), this._loaderResolver()) : (console.error(n.error), this._store.dataState = "error", this._loaderRejector());
  }
  settingDidChange(t, r, n) {
    var i;
    this.log("setting did change:", t, "=", n, `(was ${r})`), this._styleManager.update(), (i = this._paraViewRef.value) == null || i.settingDidChange(t, r, n), this._styleManager.update();
  }
  postNotice(t, r) {
    this.paraView.documentView.noticePosted(t, r), this.paraView.documentView.chartInfo.noticePosted(t, r), this.captionBox.noticePosted(t, r), this.dispatchEvent(
      new CustomEvent("paranotice", { detail: { key: t, value: r }, bubbles: !0, composed: !0 })
    );
  }
  clearAriaLive() {
    this._ariaLiveRegionRef.value.clear();
  }
  showAriaLiveHistory() {
    this._ariaLiveRegionRef.value.showHistoryDialog();
  }
  command(t, r) {
    const n = this._commander.commands[t];
    if (n)
      return n(...r);
    console.warn(`no handler for command '${t}'`);
  }
  render() {
    var r;
    const t = {
      "sr-only": this.headless
    };
    return Ht`
      <figure
        class=${Rr(t)}
        aria-hidden=${this.headless ? "true" : "false"}
      >
        <para-view
          ${ge(this._paraViewRef)}
          .paraChart=${this}
          .store=${this._store}
          colormode=${((r = this._store) == null ? void 0 : r.settings.color.colorVisionMode) ?? Lt}
          ?disableFocus=${this.headless}
        ></para-view>
        ${this.headless || this._store.settings.chart.isStatic ? "" : Ht`
            <para-control-panel
              ${ge(this._controlPanelRef)}
              .paraChart=${this}
              .store=${this._store}
            ></para-control-panel>`}
        <para-aria-live-region
          ${ge(this._ariaLiveRegionRef)}
          .store=${this._store}
          .announcement=${this._store.announcement}
        ></para-aria-live-region>
        <slot
          @slotchange=${(n) => {
    }}
        ></slot>
      </figure>
    `;
  }
};
pS.styles = [
  u5,
  Te`
      :host {
        --summary-marker-size: 1.1rem;
      }
      figure {
        display: inline grid;
        margin: 0;
      }
    `
];
let Fi = pS;
em = /* @__PURE__ */ new WeakMap();
rm = /* @__PURE__ */ new WeakMap();
nm = /* @__PURE__ */ new WeakMap();
im = /* @__PURE__ */ new WeakMap();
zo([
  Qt({ type: Boolean })
], Fi.prototype, "headless", 2);
zo([
  Qt()
], Fi.prototype, "manifest", 1);
zo([
  Qt()
], Fi.prototype, "manifestType", 2);
zo([
  Qt()
], Fi.prototype, "data", 2);
zo([
  Qt({ type: Object })
], Fi.prototype, "config", 1);
zo([
  Qt()
], Fi.prototype, "forcecharttype", 1);
zo([
  Qt()
], Fi.prototype, "type", 2);
zo([
  Qt()
], Fi.prototype, "description", 1);
zo([
  Qt({ type: Boolean, attribute: !1 })
], Fi.prototype, "isControlPanelOpen", 2);
zo([
  U0({ flatten: !0 })
], Fi.prototype, "_slotted", 2);
const dS = class dS extends Fi {
  constructor() {
    console.log("AI-enhanced ParaChart created"), super(CV, Fet);
  }
};
dS.styles = [
  u5,
  Te`
      :host {
      --control-panel-icon: url(${du(z$)});
        --summary-marker-size: 1.1rem;
      }
      figure {
        display: inline-block;
        margin: 0;
      }
    `
];
let s6 = dS;
class gEt {
  constructor() {
    this._createParaChart(), this._paraChart.store.updateSettings((t) => {
      t.animation.isAnimationEnabled = !1;
    });
  }
  get ready() {
    return this._paraChart.ready;
  }
  _createParaChart() {
    this._paraChart = document.createElement("para-chart"), this._paraChart.setAttribute("headless", ""), document.body.append(this._paraChart);
  }
  loadData(t) {
    return this._paraChart.loader.preloadData(t);
  }
  loadManifest(t, r = "url") {
    return this._paraChart.manifest = t, this._paraChart.manifestType = r, new Promise((n) => {
      this._paraChart.addEventListener("manifestchange", async () => {
        await this._paraChart.loaded, n();
      }, { once: !0 });
    });
  }
  get jimReady() {
    return this._paraChart.paraView.jimReady();
  }
  get api() {
    return this._paraChart.api;
  }
}
customElements.define("para-chart", s6);
export {
  Ty as AdvancedControlSettingsDialog,
  J4 as AnalysisPanel,
  Oy as AnimationDialog,
  KI as AnnotationLayer,
  X4 as AnnotationPanel,
  Lm as AriaLive,
  jf as AriaLiveHistoryDialog,
  t6 as AudioPanel,
  P$ as Axis,
  Zb as AxisInfo,
  A$ as AxisLine,
  _$ as AxisRule,
  J3t as Bar,
  g1 as BarPlotView,
  b$ as Bezier,
  pI as ButtonSettingControl,
  Cbt as ChartLandingView,
  e6 as ChartPanel,
  dEt as ChartTooDenseError,
  fEt as ChartTooWideError,
  cI as CheckboxSettingControl,
  s4t as ClusterShellView,
  QF as Colors,
  r6 as ColorsPanel,
  pn as ControlPanelTabPanel,
  n6 as ControlsPanel,
  w$ as DataLayer,
  By as DataPanel,
  WF as DataView,
  md as DatapointView,
  b0 as DescriptionPanel,
  lI as DropdownSettingControl,
  pbt as FORMAT_CONTEXT_SETTINGS,
  h4t as FocusLayer,
  N4 as HERTZ,
  o4t as HeatMapPlotView,
  a4t as HeatmapTile,
  tP as HeatmapTileView,
  rP as HighlightsLayer,
  l4t as Histogram,
  eP as HistogramBinView,
  k4t as HorizAxis,
  m4t as HorizAxisLine,
  E4t as HorizGridLine,
  k$ as HorizRule,
  w4t as HorizTick,
  b4t as HorizTickLabelTier,
  S4t as HorizTickStrip,
  dvt as HotkeyEvent,
  fvt as KeymapManager,
  i3 as LinePlotView,
  X3t as LineSection,
  mL as Logger,
  xy as NavLayer,
  qA as NavMap,
  oa as NavNode,
  Mvt as OscillatorAudioEngine,
  s6 as ParaChartAi,
  zi as ParaComponent,
  v0 as ParaControlPanel,
  _u as ParaDialog,
  gEt as ParaHelper,
  xr as ParaStore,
  ji as ParaView,
  Rvt as ParaViewController,
  t4t as PastryPlotView,
  mo as PathShape,
  JI as PiePlotView,
  r4t as PieSlice,
  x$ as PlaneDatapointView,
  Jb as PlanePlotView,
  Xb as PlaneSeriesView,
  yd as PlotLayer,
  g4t as PlotLayerManager,
  eS as PointDatapointView,
  E$ as PointPlotView,
  q3t as PointSeriesView,
  e4t as RadialSlice,
  uI as RadioSettingControl,
  qr as RectShape,
  Fh as SVGNS,
  n4t as ScatterPlotView,
  XI as ScatterTrendLineView,
  Bf as ScreenReaderBridge,
  yxt as Scrollyteller,
  Iy as SectorShape,
  c4t as SelectionLayer,
  Dbt as SeriesProperties,
  oI as SeriesPropertyManager,
  QA as SeriesView,
  Ts as SettingControl,
  GF as SettingControlManager,
  dr as SettingsManager,
  Wb as Shape,
  hI as SliderSettingControl,
  Ry as SoniSettingsDialog,
  aI as TextfieldSettingControl,
  S$ as TickLabelTier,
  I$ as TickStrip,
  Y3t as TrendLineView,
  qt as Vec2,
  C4t as VertAxis,
  y4t as VertAxisLine,
  A4t as VertGridLine,
  C$ as VertRule,
  x4t as VertTick,
  v4t as VertTickLabelTier,
  _4t as VertTickStrip,
  D4 as bboxOfBboxes,
  Abt as bboxOppositeAnchor,
  nEt as capitalize,
  f4t as chartClasses,
  sI as chartTypeDefaults,
  _y as computeLabels,
  Zr as datapointIdToCursor,
  oEt as datapointMatchKeyAndIndex,
  vbt as defaults,
  hbt as directions,
  iEt as exhaustive,
  ee as fixed,
  Ebt as generateUniqueId,
  sEt as groupBbox,
  Sbt as isPointerInbounds,
  ka as logging,
  xbt as toFixed
};
