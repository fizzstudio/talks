var YU = Object.defineProperty;
var ZU = (t, e, r) => e in t ? YU(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var rr = (t, e, r) => ZU(t, typeof e != "symbol" ? e + "" : e, r);
window.process = {
  env: {
    NODE_ENV: "production"
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const u1 = globalThis, xE = u1.ShadowRoot && (u1.ShadyCSS === void 0 || u1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, EE = Symbol(), K9 = /* @__PURE__ */ new WeakMap();
let RO = class {
  constructor(e, r, n) {
    if (this._$cssResult$ = !0, n !== EE) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = r;
  }
  get styleSheet() {
    let e = this.o;
    const r = this.t;
    if (xE && e === void 0) {
      const n = r !== void 0 && r.length === 1;
      n && (e = K9.get(r)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), n && K9.set(r, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const Ju = (t) => new RO(typeof t == "string" ? t : t + "", void 0, EE), Nt = (t, ...e) => {
  const r = t.length === 1 ? t[0] : e.reduce((n, i, s) => n + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + t[s + 1], t[0]);
  return new RO(r, t, EE);
}, JU = (t, e) => {
  if (xE) t.adoptedStyleSheets = e.map((r) => r instanceof CSSStyleSheet ? r : r.styleSheet);
  else for (const r of e) {
    const n = document.createElement("style"), i = u1.litNonce;
    i !== void 0 && n.setAttribute("nonce", i), n.textContent = r.cssText, t.appendChild(n);
  }
}, Y9 = xE ? (t) => t : (t) => t instanceof CSSStyleSheet ? ((e) => {
  let r = "";
  for (const n of e.cssRules) r += n.cssText;
  return Ju(r);
})(t) : t;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: XU, defineProperty: eH, getOwnPropertyDescriptor: tH, getOwnPropertyNames: rH, getOwnPropertySymbols: nH, getPrototypeOf: iH } = Object, Nl = globalThis, Z9 = Nl.trustedTypes, sH = Z9 ? Z9.emptyScript : "", tw = Nl.reactiveElementPolyfillSupport, zf = (t, e) => t, X1 = { toAttribute(t, e) {
  switch (e) {
    case Boolean:
      t = t ? sH : null;
      break;
    case Object:
    case Array:
      t = t == null ? t : JSON.stringify(t);
  }
  return t;
}, fromAttribute(t, e) {
  let r = t;
  switch (e) {
    case Boolean:
      r = t !== null;
      break;
    case Number:
      r = t === null ? null : Number(t);
      break;
    case Object:
    case Array:
      try {
        r = JSON.parse(t);
      } catch {
        r = null;
      }
  }
  return r;
} }, SE = (t, e) => !XU(t, e), J9 = { attribute: !0, type: String, converter: X1, reflect: !1, useDefault: !1, hasChanged: SE };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Nl.litPropertyMetadata ?? (Nl.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let xp = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, r = J9) {
    if (r.state && (r.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(e) && ((r = Object.create(r)).wrapped = !0), this.elementProperties.set(e, r), !r.noAccessor) {
      const n = Symbol(), i = this.getPropertyDescriptor(e, n, r);
      i !== void 0 && eH(this.prototype, e, i);
    }
  }
  static getPropertyDescriptor(e, r, n) {
    const { get: i, set: s } = tH(this.prototype, e) ?? { get() {
      return this[r];
    }, set(o) {
      this[r] = o;
    } };
    return { get: i, set(o) {
      const a = i == null ? void 0 : i.call(this);
      s == null || s.call(this, o), this.requestUpdate(e, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? J9;
  }
  static _$Ei() {
    if (this.hasOwnProperty(zf("elementProperties"))) return;
    const e = iH(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(zf("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(zf("properties"))) {
      const r = this.properties, n = [...rH(r), ...nH(r)];
      for (const i of n) this.createProperty(i, r[i]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const r = litPropertyMetadata.get(e);
      if (r !== void 0) for (const [n, i] of r) this.elementProperties.set(n, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [r, n] of this.elementProperties) {
      const i = this._$Eu(r, n);
      i !== void 0 && this._$Eh.set(i, r);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const r = [];
    if (Array.isArray(e)) {
      const n = new Set(e.flat(1 / 0).reverse());
      for (const i of n) r.unshift(Y9(i));
    } else e !== void 0 && r.push(Y9(e));
    return r;
  }
  static _$Eu(e, r) {
    const n = r.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$ES = new Promise((r) => this.enableUpdating = r), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((r) => r(this));
  }
  addController(e) {
    var r;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((r = e.hostConnected) == null || r.call(e));
  }
  removeController(e) {
    var r;
    (r = this._$EO) == null || r.delete(e);
  }
  _$E_() {
    const e = /* @__PURE__ */ new Map(), r = this.constructor.elementProperties;
    for (const n of r.keys()) this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return JU(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$EO) == null || e.forEach((r) => {
      var n;
      return (n = r.hostConnected) == null ? void 0 : n.call(r);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null || e.forEach((r) => {
      var n;
      return (n = r.hostDisconnected) == null ? void 0 : n.call(r);
    });
  }
  attributeChangedCallback(e, r, n) {
    this._$AK(e, n);
  }
  _$ET(e, r) {
    var s;
    const n = this.constructor.elementProperties.get(e), i = this.constructor._$Eu(e, n);
    if (i !== void 0 && n.reflect === !0) {
      const o = (((s = n.converter) == null ? void 0 : s.toAttribute) !== void 0 ? n.converter : X1).toAttribute(r, n.type);
      this._$Em = e, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null;
    }
  }
  _$AK(e, r) {
    var s, o;
    const n = this.constructor, i = n._$Eh.get(e);
    if (i !== void 0 && this._$Em !== i) {
      const a = n.getPropertyOptions(i), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((s = a.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? a.converter : X1;
      this._$Em = i, this[i] = l.fromAttribute(r, a.type) ?? ((o = this._$Ej) == null ? void 0 : o.get(i)) ?? null, this._$Em = null;
    }
  }
  requestUpdate(e, r, n) {
    var i;
    if (e !== void 0) {
      const s = this.constructor, o = this[e];
      if (n ?? (n = s.getPropertyOptions(e)), !((n.hasChanged ?? SE)(o, r) || n.useDefault && n.reflect && o === ((i = this._$Ej) == null ? void 0 : i.get(e)) && !this.hasAttribute(s._$Eu(e, n)))) return;
      this.C(e, r, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(e, r, { useDefault: n, reflect: i, wrapped: s }, o) {
    n && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(e) && (this._$Ej.set(e, o ?? r ?? this[e]), s !== !0 || o !== void 0) || (this._$AL.has(e) || (this.hasUpdated || n || (r = void 0), this._$AL.set(e, r)), i === !0 && this._$Em !== e && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(e));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (r) {
      Promise.reject(r);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep) this[s] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [s, o] of i) {
        const { wrapped: a } = o, l = this[s];
        a !== !0 || this._$AL.has(s) || l === void 0 || this.C(s, void 0, o, l);
      }
    }
    let e = !1;
    const r = this._$AL;
    try {
      e = this.shouldUpdate(r), e ? (this.willUpdate(r), (n = this._$EO) == null || n.forEach((i) => {
        var s;
        return (s = i.hostUpdate) == null ? void 0 : s.call(i);
      }), this.update(r)) : this._$EM();
    } catch (i) {
      throw e = !1, this._$EM(), i;
    }
    e && this._$AE(r);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var r;
    (r = this._$EO) == null || r.forEach((n) => {
      var i;
      return (i = n.hostUpdated) == null ? void 0 : i.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((r) => this._$ET(r, this[r]))), this._$EM();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
};
xp.elementStyles = [], xp.shadowRootOptions = { mode: "open" }, xp[zf("elementProperties")] = /* @__PURE__ */ new Map(), xp[zf("finalized")] = /* @__PURE__ */ new Map(), tw == null || tw({ ReactiveElement: xp }), (Nl.reactiveElementVersions ?? (Nl.reactiveElementVersions = [])).push("2.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Vf = globalThis, ey = Vf.trustedTypes, X9 = ey ? ey.createPolicy("lit-html", { createHTML: (t) => t }) : void 0, OO = "$lit$", Al = `lit$${Math.random().toFixed(9).slice(2)}$`, TO = "?" + Al, oH = `<${TO}>`, Xu = document, o0 = () => Xu.createComment(""), a0 = (t) => t === null || typeof t != "object" && typeof t != "function", AE = Array.isArray, aH = (t) => AE(t) || typeof (t == null ? void 0 : t[Symbol.iterator]) == "function", rw = `[ 	
\f\r]`, ff = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, ek = /-->/g, tk = />/g, gu = RegExp(`>|${rw}(?:([^\\s"'>=/]+)(${rw}*=${rw}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), rk = /'/g, nk = /"/g, LO = /^(?:script|style|textarea|title)$/i, MO = (t) => (e, ...r) => ({ _$litType$: t, strings: e, values: r }), qe = MO(1), Tt = MO(2), Ra = Symbol.for("lit-noChange"), De = Symbol.for("lit-nothing"), ik = /* @__PURE__ */ new WeakMap(), Mu = Xu.createTreeWalker(Xu, 129);
function NO(t, e) {
  if (!AE(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return X9 !== void 0 ? X9.createHTML(e) : e;
}
const lH = (t, e) => {
  const r = t.length - 1, n = [];
  let i, s = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", o = ff;
  for (let a = 0; a < r; a++) {
    const l = t[a];
    let c, p, h = -1, d = 0;
    for (; d < l.length && (o.lastIndex = d, p = o.exec(l), p !== null); ) d = o.lastIndex, o === ff ? p[1] === "!--" ? o = ek : p[1] !== void 0 ? o = tk : p[2] !== void 0 ? (LO.test(p[2]) && (i = RegExp("</" + p[2], "g")), o = gu) : p[3] !== void 0 && (o = gu) : o === gu ? p[0] === ">" ? (o = i ?? ff, h = -1) : p[1] === void 0 ? h = -2 : (h = o.lastIndex - p[2].length, c = p[1], o = p[3] === void 0 ? gu : p[3] === '"' ? nk : rk) : o === nk || o === rk ? o = gu : o === ek || o === tk ? o = ff : (o = gu, i = void 0);
    const b = o === gu && t[a + 1].startsWith("/>") ? " " : "";
    s += o === ff ? l + oH : h >= 0 ? (n.push(c), l.slice(0, h) + OO + l.slice(h) + Al + b) : l + Al + (h === -2 ? a : b);
  }
  return [NO(t, s + (t[r] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), n];
};
let hx = class DO {
  constructor({ strings: e, _$litType$: r }, n) {
    let i;
    this.parts = [];
    let s = 0, o = 0;
    const a = e.length - 1, l = this.parts, [c, p] = lH(e, r);
    if (this.el = DO.createElement(c, n), Mu.currentNode = this.el.content, r === 2 || r === 3) {
      const h = this.el.content.firstChild;
      h.replaceWith(...h.childNodes);
    }
    for (; (i = Mu.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const h of i.getAttributeNames()) if (h.endsWith(OO)) {
          const d = p[o++], b = i.getAttribute(h).split(Al), m = /([.?@])?(.*)/.exec(d);
          l.push({ type: 1, index: s, name: m[2], strings: b, ctor: m[1] === "." ? uH : m[1] === "?" ? hH : m[1] === "@" ? pH : F2 }), i.removeAttribute(h);
        } else h.startsWith(Al) && (l.push({ type: 6, index: s }), i.removeAttribute(h));
        if (LO.test(i.tagName)) {
          const h = i.textContent.split(Al), d = h.length - 1;
          if (d > 0) {
            i.textContent = ey ? ey.emptyScript : "";
            for (let b = 0; b < d; b++) i.append(h[b], o0()), Mu.nextNode(), l.push({ type: 2, index: ++s });
            i.append(h[d], o0());
          }
        }
      } else if (i.nodeType === 8) if (i.data === TO) l.push({ type: 2, index: s });
      else {
        let h = -1;
        for (; (h = i.data.indexOf(Al, h + 1)) !== -1; ) l.push({ type: 7, index: s }), h += Al.length - 1;
      }
      s++;
    }
  }
  static createElement(e, r) {
    const n = Xu.createElement("template");
    return n.innerHTML = e, n;
  }
};
function Bp(t, e, r = t, n) {
  var o, a;
  if (e === Ra) return e;
  let i = n !== void 0 ? (o = r._$Co) == null ? void 0 : o[n] : r._$Cl;
  const s = a0(e) ? void 0 : e._$litDirective$;
  return (i == null ? void 0 : i.constructor) !== s && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), s === void 0 ? i = void 0 : (i = new s(t), i._$AT(t, r, n)), n !== void 0 ? (r._$Co ?? (r._$Co = []))[n] = i : r._$Cl = i), i !== void 0 && (e = Bp(t, i._$AS(t, e.values), i, n)), e;
}
let cH = class {
  constructor(e, r) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = r;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: r }, parts: n } = this._$AD, i = ((e == null ? void 0 : e.creationScope) ?? Xu).importNode(r, !0);
    Mu.currentNode = i;
    let s = Mu.nextNode(), o = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new kE(s, s.nextSibling, this, e) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, e) : l.type === 6 && (c = new dH(s, this, e)), this._$AV.push(c), l = n[++a];
      }
      o !== (l == null ? void 0 : l.index) && (s = Mu.nextNode(), o++);
    }
    return Mu.currentNode = Xu, i;
  }
  p(e) {
    let r = 0;
    for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(e, n, r), r += n.strings.length - 2) : n._$AI(e[r])), r++;
  }
}, kE = class $O {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, r, n, i) {
    this.type = 2, this._$AH = De, this._$AN = void 0, this._$AA = e, this._$AB = r, this._$AM = n, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const r = this._$AM;
    return r !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = r.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, r = this) {
    e = Bp(this, e, r), a0(e) ? e === De || e == null || e === "" ? (this._$AH !== De && this._$AR(), this._$AH = De) : e !== this._$AH && e !== Ra && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : aH(e) ? this.k(e) : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.O(e));
  }
  _(e) {
    this._$AH !== De && a0(this._$AH) ? this._$AA.nextSibling.data = e : this.T(Xu.createTextNode(e)), this._$AH = e;
  }
  $(e) {
    var s;
    const { values: r, _$litType$: n } = e, i = typeof n == "number" ? this._$AC(e) : (n.el === void 0 && (n.el = hx.createElement(NO(n.h, n.h[0]), this.options)), n);
    if (((s = this._$AH) == null ? void 0 : s._$AD) === i) this._$AH.p(r);
    else {
      const o = new cH(i, this), a = o.u(this.options);
      o.p(r), this.T(a), this._$AH = o;
    }
  }
  _$AC(e) {
    let r = ik.get(e.strings);
    return r === void 0 && ik.set(e.strings, r = new hx(e)), r;
  }
  k(e) {
    AE(this._$AH) || (this._$AH = [], this._$AR());
    const r = this._$AH;
    let n, i = 0;
    for (const s of e) i === r.length ? r.push(n = new $O(this.O(o0()), this.O(o0()), this, this.options)) : n = r[i], n._$AI(s), i++;
    i < r.length && (this._$AR(n && n._$AB.nextSibling, i), r.length = i);
  }
  _$AR(e = this._$AA.nextSibling, r) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, r); e && e !== this._$AB; ) {
      const i = e.nextSibling;
      e.remove(), e = i;
    }
  }
  setConnected(e) {
    var r;
    this._$AM === void 0 && (this._$Cv = e, (r = this._$AP) == null || r.call(this, e));
  }
}, F2 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, r, n, i, s) {
    this.type = 1, this._$AH = De, this._$AN = void 0, this.element = e, this.name = r, this._$AM = i, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = De;
  }
  _$AI(e, r = this, n, i) {
    const s = this.strings;
    let o = !1;
    if (s === void 0) e = Bp(this, e, r, 0), o = !a0(e) || e !== this._$AH && e !== Ra, o && (this._$AH = e);
    else {
      const a = e;
      let l, c;
      for (e = s[0], l = 0; l < s.length - 1; l++) c = Bp(this, a[n + l], r, l), c === Ra && (c = this._$AH[l]), o || (o = !a0(c) || c !== this._$AH[l]), c === De ? e = De : e !== De && (e += (c ?? "") + s[l + 1]), this._$AH[l] = c;
    }
    o && !i && this.j(e);
  }
  j(e) {
    e === De ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}, uH = class extends F2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === De ? void 0 : e;
  }
}, hH = class extends F2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== De);
  }
}, pH = class extends F2 {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this.type = 5;
  }
  _$AI(e, r = this) {
    if ((e = Bp(this, e, r, 0) ?? De) === Ra) return;
    const n = this._$AH, i = e === De && n !== De || e.capture !== n.capture || e.once !== n.once || e.passive !== n.passive, s = e !== De && (n === De || i);
    i && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var r;
    typeof this._$AH == "function" ? this._$AH.call(((r = this.options) == null ? void 0 : r.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}, dH = class {
  constructor(e, r, n) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = r, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    Bp(this, e);
  }
};
const nw = Vf.litHtmlPolyfillSupport;
nw == null || nw(hx, kE), (Vf.litHtmlVersions ?? (Vf.litHtmlVersions = [])).push("3.3.0");
const fH = (t, e, r) => {
  const n = (r == null ? void 0 : r.renderBefore) ?? e;
  let i = n._$litPart$;
  if (i === void 0) {
    const s = (r == null ? void 0 : r.renderBefore) ?? null;
    n._$litPart$ = i = new kE(e.insertBefore(o0(), s), s, void 0, r ?? {});
  }
  return i._$AI(t), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Vu = globalThis;
let $r = class extends xp {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var r;
    const e = super.createRenderRoot();
    return (r = this.renderOptions).renderBefore ?? (r.renderBefore = e.firstChild), e;
  }
  update(e) {
    const r = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = fH(r, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return Ra;
  }
};
var PO;
$r._$litElement$ = !0, $r.finalized = !0, (PO = Vu.litElementHydrateSupport) == null || PO.call(Vu, { LitElement: $r });
const iw = Vu.litElementPolyfillSupport;
iw == null || iw({ LitElement: $r });
(Vu.litElementVersions ?? (Vu.litElementVersions = [])).push("4.2.0");
class sk {
  /**
   * Constructor
   * @param {*} options 
   * @constructor
   */
  constructor(e) {
    this._options = e;
  }
  /**
   * Initializes the module and calls the different methods in order.
   * @private
   * @memberOf module:@fizz/svmjs
   */
  async _init() {
  }
  // data is NxD array of floats. labels are 1 or -1.
  train(e, r, n) {
    this.data = e, this.labels = r, n = n || {};
    const i = n.C || 1, s = n.tol || 1e-4, o = n.alphatol || 1e-7, a = n.maxiter || 1e4, l = n.numpasses || 10;
    let c = sw;
    if (this.kernelType = "linear", "kernel" in n)
      if (typeof n.kernel == "string") {
        if (n.kernel === "linear" && (this.kernelType = "linear", c = sw), n.kernel === "rbf") {
          const m = n.rbfsigma || 0.5;
          this.rbfSigma = m, this.kernelType = "rbf", c = ok(m);
        }
      } else
        this.kernelType = "custom", c = n.kernel;
    this.kernel = c, this.N = e.length;
    const p = this.N;
    if (this.D = e[0].length, this.D, this.alpha = mH(p), this.b = 0, this.usew_ = !1, n.memoize) {
      this.kernelResults = new Array(p);
      for (let m = 0; m < p; m++) {
        this.kernelResults[m] = new Array(p);
        for (let w = 0; w < p; w++)
          this.kernelResults[m][w] = c(e[m], e[w]);
      }
    }
    let h = 0, d = 0;
    for (; d < l && h < a; ) {
      let m = 0;
      for (let w = 0; w < p; w++) {
        const f = this.marginOne(e[w]) - r[w];
        if (r[w] * f < -s && this.alpha[w] < i || r[w] * f > s && this.alpha[w] > 0) {
          let E = w;
          for (; E === w; ) E = gH(0, this.N);
          const A = this.marginOne(e[E]) - r[E];
          let x = this.alpha[w], g = this.alpha[E], v = 0, k = i;
          if (r[w] === r[E] ? (v = Math.max(0, x + g - i), k = Math.min(i, x + g)) : (v = Math.max(0, g - x), k = Math.min(i, i + g - x)), Math.abs(v - k) < 1e-4) continue;
          const S = 2 * this.kernelResult(w, E) - this.kernelResult(w, w) - this.kernelResult(E, E);
          if (S >= 0) continue;
          let R = g - r[E] * (f - A) / S;
          if (R > k && (R = k), R < v && (R = v), Math.abs(g - R) < 1e-4) continue;
          this.alpha[E] = R;
          const L = x + r[w] * r[E] * (g - R);
          this.alpha[w] = L;
          const F = this.b - f - r[w] * (L - x) * this.kernelResult(w, w) - r[E] * (R - g) * this.kernelResult(w, E), z = this.b - A - r[w] * (L - x) * this.kernelResult(w, E) - r[E] * (R - g) * this.kernelResult(E, E);
          this.b = 0.5 * (F + z), L > 0 && L < i && (this.b = F), R > 0 && R < i && (this.b = z), m++;
        }
      }
      h++, m == 0 ? d++ : d = 0;
    }
    if (this.kernelType === "linear") {
      this.w = new Array(this.D);
      for (let m = 0; m < this.D; m++) {
        let w = 0;
        for (let f = 0; f < this.N; f++)
          w += this.alpha[f] * r[f] * e[f][m];
        this.w[m] = w, this.usew_ = !0;
      }
    } else {
      const m = [], w = [], f = [];
      for (let E = 0; E < this.N; E++)
        this.alpha[E] > o && (m.push(this.data[E]), w.push(this.labels[E]), f.push(this.alpha[E]));
      this.data = m, this.labels = w, this.alpha = f, this.N = this.data.length;
    }
    const b = {};
    return b.iters = h, b;
  }
  // inst is an array of length D. Returns margin of given example
  // this is the core prediction function. All others are for convenience mostly
  // and end up calling this one somehow.
  marginOne(e) {
    let r = this.b;
    if (this.usew_)
      for (let n = 0; n < this.D; n++)
        r += e[n] * this.w[n];
    else
      for (let n = 0; n < this.N; n++)
        r += this.alpha[n] * this.labels[n] * this.kernel(e, this.data[n]);
    return r;
  }
  predictOne(e) {
    return this.marginOne(e) > 0 ? 1 : -1;
  }
  // data is an NxD array. Returns array of margins.
  margins(e) {
    const r = e.length, n = new Array(r);
    for (let i = 0; i < r; i++)
      n[i] = this.marginOne(e[i]);
    return n;
  }
  kernelResult(e, r) {
    return this.kernelResults ? this.kernelResults[e][r] : this.kernel(this.data[e], this.data[r]);
  }
  // data is NxD array. Returns array of 1 or -1, predictions
  predict(e) {
    const r = this.margins(e);
    for (let n = 0; n < r.length; n++)
      r[n] = r[n] > 0 ? 1 : -1;
    return r;
  }
  // THIS FUNCTION IS NOW DEPRECATED. WORKS FINE BUT NO NEED TO USE ANYMORE. 
  // LEAVING IT HERE JUST FOR BACKWARDS COMPATIBILITY FOR A WHILE.
  // if we trained a linear svm, it is possible to calculate just the weights and the offset
  // prediction is then yhat = sign(X * w + b)
  getWeights() {
    const e = new Array(this.D);
    for (let r = 0; r < this.D; r++) {
      let n = 0;
      for (let i = 0; i < this.N; i++)
        n += this.alpha[i] * this.labels[i] * this.data[i][r];
      e[r] = n;
    }
    return { w: e, b: this.b };
  }
  toJSON() {
    if (this.kernelType === "custom")
      return console.log("Can't save this SVM because it's using custom, unsupported kernel..."), {};
    const e = {};
    return e.N = this.N, e.D = this.D, e.b = this.b, e.kernelType = this.kernelType, this.kernelType === "linear" && (e.w = this.w), this.kernelType === "rbf" && (e.rbfSigma = this.rbfSigma, e.data = this.data, e.labels = this.labels, e.alpha = this.alpha), e;
  }
  fromJSON(e) {
    this.N = e.N, this.D = e.D, this.b = e.b, this.kernelType = e.kernelType, this.kernelType === "linear" ? (this.w = e.w, this.usew_ = !0, this.kernel = sw) : this.kernelType == "rbf" ? (this.rbfSigma = e.rbfSigma, this.kernel = ok(this.rbfSigma), this.data = e.data, this.labels = e.labels, this.alpha = e.alpha) : console.log("ERROR! unrecognized kernel type." + this.kernelType);
  }
}
function ok(t) {
  return function(e, r) {
    let n = 0;
    for (let i = 0; i < e.length; i++)
      n += (e[i] - r[i]) * (e[i] - r[i]);
    return Math.exp(-n / (2 * t * t));
  };
}
function sw(t, e) {
  let r = 0;
  for (let n = 0; n < t.length; n++)
    r += t[n] * e[n];
  return r;
}
function gH(t, e) {
  return Math.floor(Math.random() * (e - t) + t);
}
function mH(t) {
  const e = new Array(t);
  for (let r = 0; r < t; r++)
    e[r] = 0;
  return e;
}
function _E(t) {
  var e, r, n = t.length;
  if (n === 1)
    e = 0, r = t[0][1];
  else {
    for (var i = 0, s = 0, o = 0, a = 0, l, c, p, h = 0; h < n; h++)
      l = t[h], c = l[0], p = l[1], i += c, s += p, o += c * c, a += c * p;
    e = (n * a - i * s) / (n * o - i * i), r = s / n - e * i / n;
  }
  return {
    m: e,
    b: r
  };
}
function yH(t) {
  return function(e) {
    return t.b + t.m * e;
  };
}
function bH(t) {
  if (t.length === 0)
    return 0;
  var e = t[0], r = 0, n;
  if (typeof e != "number")
    return Number.NaN;
  for (var i = 1; i < t.length; i++) {
    if (typeof t[i] != "number")
      return Number.NaN;
    n = e + t[i], Math.abs(e) >= Math.abs(t[i]) ? r += e - n + t[i] : r += t[i] - n + e, e = n;
  }
  return e + r;
}
function Wl(t) {
  if (t.length === 0)
    throw new Error("mean requires at least one data point");
  return bH(t) / t.length;
}
function vH(t, e) {
  var r = Wl(t), n = 0, i, s;
  for (s = 0; s < t.length; s++)
    i = t[s] - r, n += i * i;
  return n;
}
function wH(t, e) {
  if (t.length < 2)
    return 1;
  for (var r = 0, n = 0; n < t.length; n++)
    r += t[n][1];
  for (var i = r / t.length, s = 0, o = 0; o < t.length; o++)
    s += Math.pow(i - t[o][1], 2);
  for (var a = 0, l = 0; l < t.length; l++)
    a += Math.pow(t[l][1] - e(t[l][0]), 2);
  return 1 - a / s;
}
function xH(t) {
  if (t.length === 0)
    throw new Error("mode requires at least one data point");
  if (t.length === 1)
    return t[0];
  for (var e = t[0], r = Number.NaN, n = 0, i = 1, s = 1; s < t.length + 1; s++)
    t[s] !== e ? (i > n && (n = i, r = e), i = 1, e = t[s]) : i++;
  return r;
}
function EH(t) {
  return t.slice().sort(function(e, r) {
    return e - r;
  });
}
function SH(t) {
  return xH(EH(t));
}
function CE(t) {
  if (t.length === 0)
    throw new Error("min requires at least one data point");
  for (var e = t[0], r = 1; r < t.length; r++)
    t[r] < e && (e = t[r]);
  return e;
}
function IE(t) {
  if (t.length === 0)
    throw new Error("max requires at least one data point");
  for (var e = t[0], r = 1; r < t.length; r++)
    t[r] > e && (e = t[r]);
  return e;
}
function ak(t, e) {
  var r = t.length * e;
  if (t.length === 0)
    throw new Error("quantile requires at least one data point.");
  if (e < 0 || e > 1)
    throw new Error("quantiles must be between 0 and 1");
  return e === 1 ? t[t.length - 1] : e === 0 ? t[0] : r % 1 !== 0 ? t[Math.ceil(r) - 1] : t.length % 2 === 0 ? (t[r - 1] + t[r]) / 2 : t[r];
}
function h1(t, e, r, n) {
  for (r = r || 0, n = n || t.length - 1; n > r; ) {
    if (n - r > 600) {
      var i = n - r + 1, s = e - r + 1, o = Math.log(i), a = 0.5 * Math.exp(2 * o / 3), l = 0.5 * Math.sqrt(o * a * (i - a) / i);
      s - i / 2 < 0 && (l *= -1);
      var c = Math.max(r, Math.floor(e - s * a / i + l)), p = Math.min(
        n,
        Math.floor(e + (i - s) * a / i + l)
      );
      h1(t, e, c, p);
    }
    var h = t[e], d = r, b = n;
    for (gf(t, r, e), t[n] > h && gf(t, r, n); d < b; ) {
      for (gf(t, d, b), d++, b--; t[d] < h; )
        d++;
      for (; t[b] > h; )
        b--;
    }
    t[r] === h ? gf(t, r, b) : (b++, gf(t, b, n)), b <= e && (r = b + 1), e <= b && (n = b - 1);
  }
}
function gf(t, e, r) {
  var n = t[e];
  t[e] = t[r], t[r] = n;
}
function AH(t, e) {
  var r = t.slice();
  if (Array.isArray(e)) {
    kH(r, e);
    for (var n = [], i = 0; i < e.length; i++)
      n[i] = ak(r, e[i]);
    return n;
  } else {
    var s = BO(r.length, e);
    return jO(r, s, 0, r.length - 1), ak(r, e);
  }
}
function jO(t, e, r, n) {
  e % 1 === 0 ? h1(t, e, r, n) : (e = Math.floor(e), h1(t, e, r, n), h1(t, e + 1, e + 1, n));
}
function kH(t, e) {
  for (var r = [0], n = 0; n < e.length; n++)
    r.push(BO(t.length, e[n]));
  r.push(t.length - 1), r.sort(_H);
  for (var i = [0, r.length - 1]; i.length; ) {
    var s = Math.ceil(i.pop()), o = Math.floor(i.pop());
    if (!(s - o <= 1)) {
      var a = Math.floor((o + s) / 2);
      jO(
        t,
        r[a],
        Math.floor(r[o]),
        Math.ceil(r[s])
      ), i.push(o, a, a, s);
    }
  }
}
function _H(t, e) {
  return t - e;
}
function BO(t, e) {
  var r = t * e;
  return e === 1 ? t - 1 : e === 0 ? 0 : r % 1 !== 0 ? Math.ceil(r) - 1 : t % 2 === 0 ? r - 0.5 : r;
}
function CH(t) {
  return +AH(t, 0.5);
}
function IH(t, e) {
  if (t.length !== e.length)
    throw new Error("sampleCovariance requires samples with equal lengths");
  if (t.length < 2)
    throw new Error(
      "sampleCovariance requires at least two data points in each sample"
    );
  for (var r = Wl(t), n = Wl(e), i = 0, s = 0; s < t.length; s++)
    i += (t[s] - r) * (e[s] - n);
  var o = t.length - 1;
  return i / o;
}
function PH(t) {
  if (t.length < 2)
    throw new Error("sampleVariance requires at least two data points");
  var e = vH(t), r = t.length - 1;
  return e / r;
}
function lk(t) {
  var e = PH(t);
  return Math.sqrt(e);
}
function RH(t, e) {
  var r = IH(t, e), n = lk(t), i = lk(e);
  return r / n / i;
}
class OH {
  constructor(e) {
    e && (this.df = e);
  }
  LogGamma(e) {
    const r = 1 + 76.18009173 / e - 86.50532033 / (e + 1) + 24.01409822 / (e + 2) - 1.231739516 / (e + 3) + 0.00120858003 / (e + 4) - 536382e-11 / (e + 5);
    return (e - 0.5) * Math.log(e + 4.5) - (e + 4.5) + Math.log(r * 2.50662827465);
  }
  Betinc(e, r, n) {
    let i = 0, s = 1, o = 1, a = 1, l = 0, c = 0, p;
    for (; Math.abs((o - c) / o) > 1e-5; )
      c = o, p = -(r + l) * (r + n + l) * e / (r + 2 * l) / (r + 2 * l + 1), i = o + p * i, s = a + p * s, l = l + 1, p = l * (n - l) * e / (r + 2 * l - 1) / (r + 2 * l), o = i + p * o, a = s + p * a, i = i / a, s = s / a, o = o / a, a = 1;
    return o / r;
  }
  cumulativeProbability(e, r) {
    r || (r = this.df);
    let n;
    if (r <= 0)
      console.error("Degrees of freedom must be positive");
    else {
      const i = r / 2, s = i + 0.5, o = r / (r + e * e), a = Math.exp(this.LogGamma(s) - this.LogGamma(0.5) - this.LogGamma(i) + i * Math.log(o) + 0.5 * Math.log(1 - o));
      let l;
      o < (i + 1) / (s + 2) ? l = a * this.Betinc(o, i, 0.5) : l = 1 - a * this.Betinc(1 - o, 0.5, i), e < 0 ? n = l / 2 : n = 1 - l / 2;
    }
    return n = Math.round(n * 1e5) / 1e5, n;
  }
  invCumulativeProbability(e, r) {
    if (r || (r = this.df), e >= 0.5) {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(o, r) >= e); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(n + o / 100) >= e); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(i + o / 1e4) >= e); o += 1)
        s = i + o / 1e4;
      return s;
    } else {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-o, r) <= e); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-n - o / 100) <= e); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-i - o / 1e4) <= e); o += 1)
        s = i + o / 1e4;
      return -s;
    }
  }
}
class TH {
  constructor(e, r) {
    this.df1 = e, this.df2 = r, this.EPSILON = 1e-10;
  }
  L504(e, r, n, i) {
    const s = e * r / (e * r + n), o = Math.sqrt(s), a = Math.log(o), l = Math.sqrt(1 - s), c = Math.log(l);
    let h = 1 - 2 * Math.atan(o / Math.sqrt(-o * o + 1)) / Math.PI, d = 0;
    if (n != 1) {
      const b = Math.log(2 * o / Math.PI);
      if (h -= Math.exp(b + c), n != 3) {
        const m = Math.floor((n - 3) / 2);
        for (let w = 1; w <= m; w++) {
          const f = 2 * w + 1;
          d += Math.log((f - 1) / f);
          const E = d + c * f + b;
          E > -78.4 && (h -= Math.exp(E));
        }
      }
    }
    if (e != 1) {
      let b = d;
      if (n > 1 && (b += Math.log(n - 1)), b += Math.log(2 / Math.PI) + a + c * n, b > -78.4 && (h += Math.exp(b)), e != 3) {
        const m = Math.floor((e - 3) / 2);
        d = 0;
        for (let w = 1; w <= m; w++) {
          const f = w * 2 + 1;
          d += Math.log((n + f - 2) / f);
          const E = d + a * (f - 1) + b;
          E > -78.4 && (h += Math.exp(E));
        }
      }
    }
    return h;
  }
  L401(e, r, n, i) {
    const s = e * r / (e * r + n), o = Math.log(s);
    let a = 0;
    const l = Math.log(1 - s) * n / 2;
    if (l > -78.4 && (a = Math.exp(l)), e != 2) {
      const c = Math.floor(e / 2 - 1);
      let p = 0;
      for (let h = 1; h <= c; h++) {
        const d = 2 * h;
        p += Math.log(n + d - 2) - Math.log(d) + o, p + l > -78.4 && (a += Math.exp(p + l));
      }
    }
    return i == 1 && (a = 1 - a), a;
  }
  ProbF(e, r, n) {
    let i = n, s = e, o = r, a = 0;
    return Math.floor(s / 2) * 2 == s ? this.L401(s, i, o, a) : Math.floor(o / 2) * 2 != o ? this.L504(s, i, o, a) : (i = 1 / i, s = r, o = e, a = 1, this.L401(s, i, o, a));
  }
  cumulativeProbability(e) {
    if (this.df1 > 0.01 && this.df2 > 0.01 && e > this.EPSILON)
      return 1 - this.ProbF(this.df1, this.df2, e);
    console.error("df1, df2, and F must be numbers greater than 0.");
  }
}
function px(t) {
  return Math.atan(t) * 180 / Math.PI;
}
function ua(t, e) {
  const r = [];
  for (let n = 0; n < t; n++)
    r.push(e(n));
  return r;
}
const ck = [
  1.4142024783770517,
  1.7285350177358225,
  1.975558322080508,
  2.165309701618668,
  2.3223314597870495,
  2.43666896580902,
  2.539575597098922,
  2.629725259756139,
  2.6946351910160824,
  2.7571690989287108,
  2.82429436007275,
  2.86976990061697,
  2.911181488216127,
  2.9562785307147474,
  2.991043137459134,
  3.031892332910388,
  3.0390882779033968,
  3.084150339177206,
  3.1068126593538534,
  3.1377944664764175,
  3.1526730795266236,
  3.1856353298858746,
  3.1923941584623616,
  3.2232152987382205,
  3.2423279731889063,
  3.2672678614514434,
  3.28815589678312,
  3.306598538588182,
  3.3169876930034423,
  3.3426537588982366,
  3.338808432731316,
  3.3551800156910674,
  3.3677857453596176,
  3.3801704122612546,
  3.3894353098402292,
  3.4103476461664384,
  3.420758782190955,
  3.4234022273067235,
  3.4377591100482245,
  3.4495251663075597,
  3.45784133640642,
  3.4655169406594553,
  3.499664208072353,
  3.5075228374867624,
  3.4963470841468247,
  3.5194522982765517,
  3.50887461478777,
  3.517883433127914,
  3.527130862311399,
  3.5478465903324174,
  3.5524335509017972,
  3.5453727082671342,
  3.556173872494318,
  3.557087103502499,
  3.589369632641309,
  3.5859140345184524,
  3.572323092223869,
  3.6004177405174853,
  3.6100996977289306,
  3.601519301860006,
  3.606430559116003,
  3.623484959486857,
  3.6110156117453704,
  3.6398254610166214,
  3.6485762129590045,
  3.6369984456518214,
  3.6420217039991707,
  3.6515502039986543,
  3.6534596174533878,
  3.6659253039539754,
  3.678204062277477,
  3.673013776537585,
  3.6873396028854244,
  3.677549442478252,
  3.672393117945697,
  3.694338890356745,
  3.698559967922895,
  3.7088383298959364,
  3.6960214124422732,
  3.6962804693332054,
  3.7259363906151113,
  3.6945941836261005,
  3.7123614650012637,
  3.7266182166220743,
  3.726433940762783,
  3.7262288936328507,
  3.73068538678121,
  3.7464587039431216,
  3.734498500854471,
  3.7666496106093086,
  3.7577811376185797,
  3.755885408241557,
  3.7653220485067256,
  3.759612302718265,
  3.750000422234468,
  3.776893666562007,
  3.7656945047078376
], LH = [
  [
    12.92876788710003,
    18.669362102797844,
    20.708185574014465
  ],
  [
    12.893379950402329,
    17.838738753100234,
    20.009145166260716
  ],
  [
    12.567620517329296,
    17.39284624657391,
    19.327403214291675
  ],
  [
    12.44012368783225,
    17.159725181804923,
    19.031999514734718
  ],
  [
    12.258810404004157,
    16.643626920880678,
    18.520644599539708
  ],
  [
    12.490936102639248,
    17.07031258707699,
    19.26763537042604
  ],
  [
    12.230582644506537,
    16.8611702133535,
    19.04138451550924
  ],
  [
    12.285890759032673,
    16.72028694459538,
    18.998686524252154
  ],
  [
    12.265830882960202,
    16.861313711298223,
    19.01741086021432
  ],
  [
    12.221592293386445,
    16.856569952690425,
    18.679522968116675
  ],
  [
    12.207863926087379,
    16.466760433982508,
    18.327798576854196
  ],
  [
    12.23047144884862,
    16.604698640112442,
    18.778749913667404
  ],
  [
    12.310880515319493,
    16.75477031068603,
    18.61887265606582
  ],
  [
    12.09088910593483,
    16.680683526842817,
    19.10909766756724
  ],
  [
    12.28969274656454,
    16.494346369998592,
    18.555323182091747
  ],
  [
    12.351479909044647,
    17.231085800266705,
    19.12315903511468
  ],
  [
    12.232654018508402,
    17.03319706813043,
    19.36238761950663
  ],
  [
    12.24175327982118,
    17.01249507542771,
    19.29261479388184
  ],
  [
    12.240819762926595,
    16.958668959199564,
    18.703343358289676
  ],
  [
    12.325576191647679,
    16.741637280941735,
    18.706270613293825
  ],
  [
    12.29079270883332,
    16.83580567418819,
    18.885633182327588
  ],
  [
    12.105579742321321,
    16.801481191805877,
    18.74917129995002
  ],
  [
    12.241506985184987,
    16.421107838741005,
    18.51907643327747
  ],
  [
    12.22772321442409,
    16.76637698315794,
    18.59944945667253
  ],
  [
    12.146827427372807,
    16.504491710455042,
    18.624893334253915
  ],
  [
    12.099825423105056,
    16.517727777727934,
    18.389759370770282
  ],
  [
    12.241793182544008,
    16.69983166753318,
    18.199273554649118
  ],
  [
    12.133827646762477,
    16.937161124066893,
    18.865979715097055
  ],
  [
    12.014897172400497,
    16.64164656731907,
    18.52796800753582
  ],
  [
    12.03194886183511,
    16.448427247716083,
    18.360165754021324
  ],
  [
    12.060576333659972,
    16.972556324548336,
    18.909884009510286
  ],
  [
    12.130919558394593,
    16.846538605893603,
    18.974105413083418
  ],
  [
    12.167013704292577,
    16.962535224497064,
    18.952800614645692
  ],
  [
    12.307745895005242,
    16.69776947316106,
    18.73020815902911
  ],
  [
    12.03703814065202,
    16.744259233990512,
    19.40987043616083
  ],
  [
    12.23158902787162,
    16.992381220472012,
    19.23258888861058
  ],
  [
    12.30313545083327,
    16.80175925410746,
    18.88639508508212
  ],
  [
    12.216506652052612,
    16.95978747527697,
    19.07369251354378
  ],
  [
    12.289633178985905,
    17.037358965358983,
    18.978000598844293
  ],
  [
    12.114391564747471,
    16.353909897952686,
    18.35011390560238
  ],
  [
    12.208213936084457,
    16.12841887472018,
    18.239736208276152
  ],
  [
    12.326886082604242,
    16.87043068171149,
    18.900551155302647
  ],
  [
    12.24602935198574,
    16.740078446411406,
    18.57610242578182
  ],
  [
    12.154508067768113,
    16.70375179351137,
    18.84458221820561
  ],
  [
    12.053162931004179,
    16.63616478058826,
    18.764716631834734
  ],
  [
    12.242031428895839,
    16.870439498648583,
    18.946299240629287
  ],
  [
    12.172676093456305,
    16.57616403586386,
    18.901254056077153
  ],
  [
    12.234873290793098,
    16.849691971911838,
    19.020953521536004
  ],
  [
    12.307356477970162,
    17.070904468883104,
    19.124634537613513
  ],
  [
    12.258316325281726,
    16.98236293001686,
    19.362641577913156
  ],
  [
    12.236258781616636,
    16.835948685325945,
    18.872615556171525
  ],
  [
    12.218214829379882,
    16.72052856570416,
    18.576319895769533
  ],
  [
    12.266452802779268,
    17.001974682521503,
    19.397512454689892
  ],
  [
    12.142229768023105,
    16.760040761542093,
    18.73221439686166
  ],
  [
    12.362128316602698,
    16.779263655428466,
    18.690631800055144
  ],
  [
    12.23248525532616,
    16.78957578482738,
    19.290187946573045
  ],
  [
    12.194978246692179,
    16.66872414977679,
    18.38065055971982
  ],
  [
    12.364346090585878,
    16.78308783969924,
    18.787944141467552
  ],
  [
    12.213523054233821,
    16.745070120633624,
    18.779462580096293
  ],
  [
    12.120562728816676,
    16.72947148909386,
    18.540581750860838
  ],
  [
    12.147441684285011,
    16.362711939455345,
    18.5928909502196
  ],
  [
    12.349013958141011,
    17.115157968739332,
    19.074081167238724
  ],
  [
    12.169896474381117,
    16.779107284309674,
    19.095614865501265
  ],
  [
    12.212332899050487,
    17.15220159015151,
    19.18433312800504
  ],
  [
    12.427266331944576,
    17.19802901185036,
    19.08282870552354
  ],
  [
    12.208415329256482,
    16.698611123996386,
    18.437039290733527
  ],
  [
    12.150857540075965,
    16.747967767000077,
    18.522105916017864
  ],
  [
    12.185133777587764,
    16.716543085287885,
    18.75368115517968
  ],
  [
    12.202518998568662,
    16.695350960024488,
    18.766605345681214
  ],
  [
    12.293516845096802,
    16.848652152520355,
    18.73818931670063
  ],
  [
    12.264328782539446,
    16.898700733974184,
    18.91736903501125
  ],
  [
    12.283442238272498,
    16.79113139749197,
    18.762641899116595
  ],
  [
    12.288571666812464,
    16.947956362708894,
    19.26608413111616
  ],
  [
    12.199938820517241,
    16.73882101164454,
    18.649824259785902
  ],
  [
    12.281399931209005,
    16.74455321404603,
    18.993644280454557
  ],
  [
    11.978508088635845,
    16.751385791647305,
    19.067980524092103
  ],
  [
    12.352190443412464,
    17.002035355108024,
    18.910150024775536
  ],
  [
    12.11299191492474,
    16.85211409238294,
    19.21553533835868
  ],
  [
    12.252946905996852,
    16.77267825853487,
    18.758060103809566
  ],
  [
    12.253428278525488,
    17.05117162481038,
    19.437396636388712
  ],
  [
    12.365555609949542,
    17.217797222036967,
    19.557725250431925
  ],
  [
    12.446856234792692,
    17.13219895129848,
    19.189823799758685
  ],
  [
    12.378913383861864,
    16.69420382596318,
    18.614200176451167
  ],
  [
    12.209646506057828,
    17.049298470931937,
    19.21471558598783
  ],
  [
    12.07451389049845,
    16.52146599860598,
    18.646538442813565
  ],
  [
    12.242992826481506,
    17.118044327693312,
    19.109033882498373
  ],
  [
    12.031588638774476,
    16.440292876584916,
    18.365137461548116
  ],
  [
    12.256327863966023,
    16.937124809805663,
    19.055448755862216
  ],
  [
    12.152502866561859,
    16.51661734703226,
    18.292867488178068
  ],
  [
    12.240166584135661,
    17.01144955716148,
    19.269980514360167
  ],
  [
    12.288087364649998,
    16.9124768573556,
    18.78496409520197
  ],
  [
    12.261031067472498,
    17.080660923120398,
    18.993376274931116
  ],
  [
    12.149516099981419,
    16.429960356660846,
    18.693814658804264
  ],
  [
    12.189972968413274,
    16.360091390089806,
    18.372140642711813
  ],
  [
    12.247713311640034,
    16.85901876289993,
    18.747152105084417
  ],
  [
    12.235996387439796,
    16.719425800548546,
    18.73463631602104
  ]
], Uu = {
  minLen3: 0,
  minLen6: 1,
  tooManyPoints: 2
}, MH = {
  [Uu.minLen3]: "line must have at least 3 points",
  [Uu.minLen6]: "line must have at least 6 points",
  [Uu.tooManyPoints]: "line contains too many points"
};
let z2 = class extends Error {
  constructor(e) {
    super(MH[e]), this.code = e;
  }
};
function NH(t, e, r) {
  return t.map((n) => n - e).map((n) => n / r);
}
function ow(t) {
  const e = t.bestFit, r = e.rss();
  return {
    se: Math.sqrt(r / t.length),
    rss: r,
    resid: e.residuals,
    slope: e.slope,
    inter: e.intercept
  };
}
function DH(t) {
  if (t.length < 3)
    throw new z2(Uu.minLen3);
  const e = RH(t.points.map((r) => r.x), t.points.map((r) => r.y));
  return Number.isNaN(e) ? 1 : Math.abs(e);
}
function $H(t) {
  const e = t.length;
  if (e < 6)
    throw new z2(Uu.minLen6);
  const { se: r } = ow(t);
  if (r === 0)
    return { feats: [0, 0, 0] };
  const n = LH[e - 6], i = [];
  for (let a = 2; a < e - 3; a++) {
    const l = a + 1, { se: c } = ow(t.slice(0, l)), { se: p } = ow(t.slice(l));
    i.push(c ** l * p ** (e - l) / r ** e);
  }
  const s = Math.min(...i), o = -Math.log(s);
  return {
    feats: n.map((a) => o > a ? 1 : 0),
    logLambda: o,
    t: i.indexOf(s) + 2
  };
}
function FO(t) {
  const e = t.length;
  if (e < 6)
    throw new z2(Uu.minLen6);
  const r = t.bestFit.rss(), n = [0, 0];
  if (r === 0)
    return { feats: n };
  const i = [], s = t.points.map((f) => f.x), o = t.points.map((f) => f.y), a = (f) => f.reduce((E, A) => E + A), l = (f, E) => a(f.map((A, x) => A * E[x])), c = [], p = [];
  for (let f = 2; f < e - 3; f++) {
    const E = s.slice(0, f + 1), A = o.slice(0, f + 1), x = a(E), g = a(A), v = l(E, A), k = a(E.map((le) => le ** 2)), S = v - x * g / (f + 1), R = k - x ** 2 / (f + 1), L = S / R, F = Wl(A) - L * Wl(E), z = s[f], j = F + L * z, ee = s.slice(f + 1), X = o.slice(f + 1), ie = a(ee), ce = a(X), ke = l(ee, X), ye = a(ee.map((le) => le ** 2)), Ce = ce - (t.length - (f + 1)) * j, Ie = ie - (t.length - (f + 1)) * z, Te = Ce / Ie, ue = ke / ie - Te * ye / ie, O = E.map((le) => F + L * le), N = a(E.map((le, te) => (A[te] - O[te]) ** 2)), Z = ee.map((le) => ue + Te * le), re = a(ee.map((le, te) => (X[te] - Z[te]) ** 2));
    i.push(N + re), c.push({ a1: F, b1: L, a2: ue, b2: Te }), p.push(O.concat(Z));
  }
  const h = Math.min(...i);
  let d, b = (r - h) / 2 / (h / (e - 4));
  b <= 0 && (b = 1e-3), b === 1 / 0 ? d = 0 : d = 1 - new TH(2, e - 4).cumulativeProbability(b);
  const m = i.indexOf(h) + 2, w = { rssMin: h, rssl: r, F: b, p: d, split: m, params: c[m - 2], yhats: p[m - 2] };
  return d < 0.1 && (n[0] = 1), d < 0.05 && (n[1] = 1), { feats: n, debug: w };
}
function jH(t) {
  const e = t.bestFit.residuals.map(Math.sign), { r, nminus: n, nplus: i } = e.reduce(
    (a, l, c) => (c && l !== e[c - 1] && a.r++, l || (l = 1), a[l === 1 ? "nplus" : "nminus"]++, a),
    { r: 1, nminus: 0, nplus: 0 }
  ), s = 2 * i * n / (i + n) + 1, o = Math.abs(Math.sqrt(
    2 * i * n * (2 * i * n - i - n) / (Math.pow(i + n, 2) * (i + n - 1))
  ));
  return { feats: [r < s - o / 2 ? 1 : r > s + o / 2 ? -1 : 0, r, s, o, Math.abs(r - s) / s] };
}
function BH(t) {
  const e = t.length;
  if (e > ck.length + 4)
    throw new z2(Uu.tooManyPoints);
  const r = t.bestFit.residuals, n = Math.sqrt(
    r.map((d) => d ** 2 / (e - 2)).reduce((d, b) => d + b)
  );
  if (n === 0)
    return [-1, 0];
  const i = t.points.map((d) => d.x), s = Wl(i), o = i.map((d) => (d - s) ** 2), a = o.reduce((d, b) => d + b), l = o.map((d) => n * Math.sqrt(1 - 1 / e - d / a)), c = r.map((d, b) => d / l[b]).map((d) => Math.abs(d)), p = Math.max(...c), h = ck[e - 4];
  return [p, c.filter((d) => d > h).length];
}
function FH(t) {
  const e = t.bestFit.rss(), r = t.points.at(-1).x - t.points[0].x, n = Math.sqrt(e / t.length) / r, i = Math.atan(t.bestFit.slope);
  return [n, n * Math.cos(i) ** 2];
}
let zH = class {
  /**
   * Compute non-standardized feature columns from examples.
   * @param examples - Training examples
   * @returns Feature columns
   */
  computeFeatures(e) {
    function r(i, s) {
      const o = i[0].length, a = {};
      for (let l = 0; l < o; l++)
        a[`${s}${l + 1}`] = [];
      for (const l of i)
        l.forEach((c, p) => a[`${s}${p + 1}`].push(c));
      return a;
    }
    const n = {
      absCorrCoeff: e.map((i) => DH(i.data)),
      nPoints: e.map((i) => i.data.length),
      ...r(e.map((i) => FH(i.data)), "scaledS"),
      nPointsChart: e.map((i) => i.chartLength),
      chartPct: e.map((i) => (i.data.length - 1) / (i.chartLength - 1))
    };
    return e[0].data.length >= 6 && Object.assign(
      n,
      r(e.map((i) => $H(i.data).feats), "qTest"),
      r(e.map((i) => FO(i.data).feats), "fTest"),
      r(e.map((i) => jH(i.data).feats), "runsTest"),
      r(e.map((i) => BH(i.data)), "outlierTest")
    ), n;
  }
  /**
   * Standardize feature columns.
   * @param featCols - Non-standardized feature columns
   * @param featStats - Feature column statistics
   * @returns Standardized feature columns
   */
  standardizeFeatures(e, r) {
    const n = {};
    for (const [i, s] of Object.entries(e)) {
      const o = r[i];
      n[i] = o ? NH(s, o.mean, o.stdDev) : s;
    }
    return n;
  }
  /**
   * Assemble feature matrix from standardized feature columns.
   * @param stdFeatCols - Standardized feature columns.
   * @returns Feature matrix (array of example rows)
   */
  assembleMatrix(e) {
    const r = Object.values(e)[0].length, n = ua(r, (i) => []);
    for (const [i, s] of Object.entries(e))
      s.forEach((o, a) => n[a].push(o));
    return n;
  }
  /**
   * Compute feature matrix from examples.
   * @param examples - Training examples
   * @param featStats - Feature column statistics
   * @returns Feature matrix (array of example rows)
   */
  computeMatrix(e, r) {
    const n = this.computeFeatures(e), i = this.standardizeFeatures(n, r);
    return this.assembleMatrix(i);
  }
};
const zO = {
  "188b757048e": {
    breaks: "breaks_JF_CM3",
    small: {
      model: {
        N: 216,
        D: 6,
        b: 1.0301052191704447,
        kernelType: "linear",
        w: [
          -0.3670377924881308,
          0.24109852608042484,
          0.10770417080350453,
          3.7309289892912494,
          -0.24351287768173968,
          0.1773538767010703
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6613098596026764,
          stdDev: 0.32645241503938466
        },
        nPoints: {
          mean: 4.027777777777778,
          stdDev: 0.79484775003546
        },
        scaledS1: {
          mean: 0.2738191427566398,
          stdDev: 0.31274618795081666
        },
        scaledS2: {
          mean: 0.16552447256379144,
          stdDev: 0.22401114065292482
        },
        nPointsChart: {
          mean: 18.88425925925926,
          stdDev: 11.50047652834366
        },
        chartPct: {
          mean: 0.24575562721992683,
          stdDev: 0.17658868716036033
        }
      }
    },
    big: {
      model: {
        N: 818,
        D: 18,
        b: -0.5949603608497636,
        kernelType: "linear",
        w: [
          -0.4977108970919176,
          0.7541270816821308,
          0.9144109510673445,
          1.6047203771838476,
          -1.4368172642074537,
          -0.21592712823176308,
          0.07644318713996778,
          0.014636523739875784,
          0.1763324579259402,
          1.106707575171747,
          -0.47385129596321995,
          0.45987873914033983,
          0.35112878139332787,
          -0.6236067182671058,
          0.9485075089484734,
          0.19163220544936868,
          0.20546829454342905,
          -0.06915930322456987
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6452237813470705,
          stdDev: 0.3240018443609284
        },
        nPoints: {
          mean: 14.583129584352077,
          stdDev: 8.99604477133496
        },
        scaledS1: {
          mean: 0.10594325137217282,
          stdDev: 0.09177436527475356
        },
        scaledS2: {
          mean: 0.08668479622616888,
          stdDev: 0.07415105573907281
        },
        nPointsChart: {
          mean: 27.0880195599022,
          stdDev: 12.696709863610126
        },
        chartPct: {
          mean: 0.5831555684741223,
          stdDev: 0.28777669079271473
        },
        runsTest2: {
          mean: 5.10757946210269,
          stdDev: 2.511304431521282
        },
        runsTest3: {
          mean: 8.050945471288665,
          stdDev: 4.446028922152818
        },
        runsTest4: {
          mean: 1.6812783091074126,
          stdDev: 0.5646901163167827
        },
        runsTest5: {
          mean: 0.337916669549109,
          stdDev: 0.20151780352623566
        },
        outlierTest1: {
          mean: 2.100035193879811,
          stdDev: 0.5296286424653459
        },
        outlierTest2: {
          mean: 0.05867970660146699,
          stdDev: 0.2351680408679939
        }
      }
    }
  },
  "18afd2f54c7": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3380856560371651,
        kernelType: "linear",
        w: [
          -0.756517811722315,
          0.37069999610745497,
          0.21673055797213336,
          1.1244975473636247,
          0.035519868943893806,
          0.6975781903311828
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6866332461949628,
          stdDev: 0.3229548134968895
        },
        nPoints: {
          mean: 4.069767441860465,
          stdDev: 0.8050959803624481
        },
        scaledS1: {
          mean: 0.03965686197121996,
          stdDev: 0.0338017466328698
        },
        scaledS2: {
          mean: 0.038745499336644146,
          stdDev: 0.033324943757710994
        },
        nPointsChart: {
          mean: 15.078488372093023,
          stdDev: 8.898337515306299
        },
        chartPct: {
          mean: 0.2979532652417984,
          stdDev: 0.1884678355817908
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.22042056305341218,
        kernelType: "linear",
        w: [
          -0.3280468854878086,
          -0.11665058369931192,
          -0.0022542536097451466,
          2.219103384778342,
          0.0342024760983941,
          0.4293989826596215,
          0.2975608661999607,
          -0.6077251584818741,
          0.4000527465309003,
          0.4042384593088002,
          0.001186586425212074,
          0.5190085928118862,
          -0.23537053975123523,
          0.0715945226988598,
          0.033154145420287044,
          -0.06347880606856209,
          0.1850990704458409,
          -0.001228864486559927
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6223429821764429,
          stdDev: 0.3110591999188207
        },
        nPoints: {
          mean: 13.731607629427794,
          stdDev: 8.370686093707965
        },
        scaledS1: {
          mean: 0.03544093688268208,
          stdDev: 0.026611386439376005
        },
        scaledS2: {
          mean: 0.03455363316854854,
          stdDev: 0.026077505679786228
        },
        nPointsChart: {
          mean: 23.768392370572208,
          stdDev: 11.730176258926388
        },
        chartPct: {
          mean: 0.6094307363719895,
          stdDev: 0.26692294365220165
        },
        runsTest2: {
          mean: 5.151226158038147,
          stdDev: 2.6793673522936645
        },
        runsTest3: {
          mean: 7.583581141916727,
          stdDev: 4.081715945141601
        },
        runsTest4: {
          mean: 1.6148756585462214,
          stdDev: 0.5411094264297078
        },
        runsTest5: {
          mean: 0.3153327018423893,
          stdDev: 0.19626169453505887
        },
        outlierTest1: {
          mean: 2.118980108638941,
          stdDev: 0.6300714899329056
        },
        outlierTest2: {
          mean: 0.09128065395095368,
          stdDev: 0.2882041970351209
        }
      }
    }
  },
  "18b1686ceb4": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3309416402875685,
        kernelType: "linear",
        w: [
          -0.20000267112106263,
          0.42809635761540643,
          0.46656203058966117,
          1.841671684760453,
          -0.6434524674952959,
          0.49143545422517687
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6764124363859395,
          stdDev: 0.3236057116921364
        },
        nPoints: {
          mean: 4.116279069767442,
          stdDev: 0.8069465847859293
        },
        scaledS1: {
          mean: 0.1858035195675879,
          stdDev: 0.21428670248595916
        },
        scaledS2: {
          mean: 0.12950420831848175,
          stdDev: 0.15751874574784924
        },
        nPointsChart: {
          mean: 15.761627906976743,
          stdDev: 9.783137376835176
        },
        chartPct: {
          mean: 0.300526358561615,
          stdDev: 0.1927265795559554
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.33318046701370874,
        kernelType: "linear",
        w: [
          0.032315062605570585,
          0.48106580584263436,
          -1.1047252909009055,
          3.7368759283052406,
          -0.6183759573768267,
          0.6939892440180402,
          0.3861182101902436,
          -0.4528094207813589,
          0.19685209857044894,
          0.5317134144006395,
          -0.3268861531591498,
          0.5416909853776097,
          0.11204746654248579,
          -0.042886524593192116,
          0.04725504450122949,
          0.09451185559860642,
          -0.011544267888957445,
          0.17029310632188632
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6349627683741144,
          stdDev: 0.3047569778403939
        },
        nPoints: {
          mean: 13.728882833787466,
          stdDev: 8.419998905023999
        },
        scaledS1: {
          mean: 0.07039535118699393,
          stdDev: 0.06922873611482698
        },
        scaledS2: {
          mean: 0.06255041459772398,
          stdDev: 0.05952611432033109
        },
        nPointsChart: {
          mean: 23.705722070844686,
          stdDev: 11.739000887557054
        },
        chartPct: {
          mean: 0.6095266522529739,
          stdDev: 0.26470522117524425
        },
        runsTest2: {
          mean: 5.129427792915531,
          stdDev: 2.7706078547777717
        },
        runsTest3: {
          mean: 7.603857452118007,
          stdDev: 4.140301994340143
        },
        runsTest4: {
          mean: 1.6191709447588931,
          stdDev: 0.5436847808406448
        },
        runsTest5: {
          mean: 0.32151695128382807,
          stdDev: 0.19159541197646354
        },
        outlierTest1: {
          mean: 2.116230031599242,
          stdDev: 0.5977792703826863
        },
        outlierTest2: {
          mean: 0.09400544959128065,
          stdDev: 0.29203530028780983
        }
      }
    }
  }
};
function VH() {
  return Object.keys(zO).sort();
}
function UH(t) {
  return zO[t ?? VH().at(-1)];
}
var HH = Object.defineProperty, GH = (t, e, r) => e in t ? HH(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, WH = (t, e, r) => (GH(t, e + "", r), r);
const qH = 0.2;
function QH(t, e, r = qH) {
  if (t.length === 3)
    return 1;
  const n = t.points.at(-1).x - t.points[0].x, i = (t.points.at(-1).y - t.points[0].y) / n, s = Math.atan(i), o = Math.cos(s), a = t.points.map((f) => f.y), l = t.slice(1, t.length - 1);
  let c = a.indexOf(Math.min(...a)) - 1;
  (c < 0 || c === l.length) && (c = null);
  let p = a.indexOf(Math.max(...a)) - 1;
  (p < 0 || p === l.length) && (p = null);
  const h = [], d = l.points.map((f) => {
    const E = f.x - t.points[0].x, A = Math.abs(f.y - (i * E + t.points[0].y));
    return h.push(A), A * o;
  }), b = d.indexOf(Math.max(...d));
  let m = !1;
  c !== null && Math.abs(c - b) / (e - 1) <= r && (m = h[c] > d[b]);
  let w = !1;
  return p !== null && Math.abs(p - b) / (e - 1) <= r && (w = h[p] > d[b]), w ? p + 1 : m ? c + 1 : b + 1;
}
let KH = class {
  /**
   * @param model - (Optional) ID of split model to use.
   */
  constructor(e = void 0) {
    WH(this, "models");
    const r = UH(e);
    if (r)
      this.models = {
        small: {
          svm: new sk(),
          stats: r.small.stats
        },
        big: {
          svm: new sk(),
          stats: r.big.stats
        }
      };
    else
      throw new Error(`unknown model ID: '${e}'`);
    this.models.small.svm.fromJSON(r.small.model), this.models.big.svm.fromJSON(r.big.model);
  }
  /**
   * Predict whether a sequence should be split.
   * @param seq - Data points of sequence to evaluate. 
   * @param chartLength - Number of data points in the complete chart
   * of which 'seq' is a part.
   * @returns Whether the sequence should be split.
   */
  shouldSplit(e, r) {
    if (e.length < 3 || e.points.every((a) => a.y === e.points[0].y))
      return !1;
    const n = new zH(), i = e.length < 6 ? "small" : "big", [s] = n.computeMatrix(
      [{ data: e, chartLength: r }],
      this.models[i].stats
    ), [o] = this.models[i].svm.predict([s]);
    return o === 1;
  }
  /**
   * Predict trend sequences a series should be split into.
   * @param series - Data points of series to split.
   * @param yAxis - Displayed chart y-axis bounds; defaults to extreme values of data
   * @param pipCloseness - Max distance (as % of chart length) a sequence-local 
   * min/max point can be from the PIP to be a possible split point.
   * @returns List of index pairs denoting the start and end of each sequence.
   * @remarks
   * As in slices, the end index in a pair is not included in the set of indices
   * included in a sequence.
   * NB: Adjacent sequences share the point where they were split.
   * E.g., a hypothetical set of sequences might look like:
   *   [\{start: 0, end: 5\}, \{start: 4, end: 7\}, \{start: 6, end: 10\}]
   * where the first two sequences share the point at index 4, and the last
   * two share the point at index 6.
   */
  getSequences(e, r, n) {
    const i = e.length;
    e = e.project(void 0, r);
    const s = [], o = (a, l) => {
      const c = e.slice(a, l);
      if (this.shouldSplit(c, e.length)) {
        const p = QH(c, e.length, n) + a;
        o(a, p + 1), o(p, l);
      } else
        s.push({ start: a, end: l });
    };
    return o(0, i), s;
  }
};
var YH = Object.defineProperty, ZH = (t, e, r) => e in t ? YH(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, uk = (t, e, r) => (ZH(t, typeof e != "symbol" ? e + "" : e, r), r);
const JH = [
  [
    -1,
    1,
    "ReversalToRise",
    "PossibleReversalToRise"
    /* PRR */
  ],
  [
    1,
    -1,
    "ReversalToFall",
    "PossibleReversalToFall"
    /* PRF */
  ],
  [
    0,
    1,
    "EmergingRise",
    "PossibleEmergingRise"
    /* PER */
  ],
  [
    0,
    -1,
    "EmergingFall",
    "PossibleEmergingFall"
    /* PEF */
  ],
  [
    1,
    0,
    "RiseToStable",
    "PossibleRiseToStable"
    /* PRS */
  ],
  [
    -1,
    0,
    "FallToStable",
    "PossibleFallToStable"
    /* PFS */
  ]
], XH = [
  [
    1,
    -1,
    1,
    "Rebound",
    "PossibleRebound"
    /* PRB */
  ],
  [
    -1,
    1,
    -1,
    "TemporaryJump",
    "PossibleTemporaryJump"
    /* PTJ */
  ]
], eG = 6, PE = 5, tG = 0.15;
let mu = class {
  constructor(e, r = e.yBounds(), n, ...i) {
    uk(this, "params"), uk(this, "magnitude"), this.category = n, this.params = i, this.magnitude = this.computeMagnitude(e, r);
  }
  computeMagnitude(e, r) {
    const n = e.points.map((i) => i.y).slice(this.params[0], this.params.at(-1));
    return (Math.max(...n) - Math.min(...n)) / (r.end - r.start);
  }
  toString() {
    return `${this.category}(${this.params[0]}-${this.params[this.params.length - 1]})`;
  }
};
function rG(t) {
  const e = Wl(t), r = t.map((n) => n - e);
  return Math.sqrt(r.reduce((n, i) => n + i ** 2, 0));
}
function _m(t) {
  return Math.sign(t);
}
function ty(t, e = PE, r = e) {
  const n = t.length;
  if (n < 3) {
    let i = (t.points[1].y - t.points[0].y) / (t.points[1].x - t.points[0].x);
    const s = px(i);
    return Math.abs(s) < r && (i = 0), { classes: [_m(i)], slope: i, angle: s };
  } else {
    const i = t.bestFit.rss();
    if (n < eG) {
      let h = _m(t.bestFit.slope);
      return Math.abs(t.bestFit.xAngle) < r && (h = 0), { classes: [h], slope: t.bestFit.slope, angle: t.bestFit.xAngle };
    }
    const s = t.points.map((h) => h.x), o = Math.sqrt(i / (n - 2)) / rG(s), a = 1 - 0.05 / 2, l = new OH(n - 2).invCumulativeProbability(a) * o, c = [t.bestFit.slope - l, t.bestFit.slope + l], p = [];
    return Math.sign(c[0]) !== Math.sign(c[1]) ? (p.push(0), Math.abs(t.bestFit.xAngle) >= e && p.push(_m(t.bestFit.slope))) : (p.push(_m(t.bestFit.slope)), Math.abs(t.bestFit.xAngle) < e && t.bestFit.slope && p.push(0)), { classes: p, slope: t.bestFit.slope, angle: t.bestFit.xAngle, moe: l };
  }
}
function nG(t, e, r = tG, n = PE, i = n, s) {
  const o = t.project(void 0, s), a = e[e.length - 1], l = o.slice(a.start, a.end);
  if (l.length < 3)
    return null;
  const c = (m) => {
    const { classes: w } = ty(l.slice(0, m + 1), n, i), { classes: f } = ty(l.slice(m), n, i);
    if (w.length === 1 && f.length === 1 && w[0] !== f[0] || w.length === 1 && !f.includes(w[0]) || f.length === 1 && !w.includes(f[0])) {
      const E = a.start + m;
      return a.end = E + 1, e.push({ start: E, end: t.length }), !0;
    } else
      return !1;
  };
  let p = Math.round(r * t.length);
  if (p < 2)
    return null;
  if (p === 2 || l.length === 3)
    return c(l.length - 2);
  if (l.length < 6)
    return !!(c(2) || l.length === 5 && c(3));
  for (; l.length - p < l.length / 2; )
    p--;
  const h = l.slice(-(p + 3)), { feats: d, debug: b } = FO(h);
  if (d[0] && d[1]) {
    const m = a.end - (p + 3) + b.split;
    return a.end = m + 1, e.push({ start: m, end: t.length }), !0;
  }
  return !1;
}
function iG(t, e, r, n) {
  const i = [];
  let s = -1;
  function o(a) {
    const l = e[s][1], c = e[a - 1][2];
    i.push([
      ty(t.slice(l, c), r, n),
      l,
      c
    ]);
  }
  for (let a = 0; a < e.length; a++) {
    if (e[a][0].classes.length > 1) {
      s !== -1 && o(a), s = a, o(a + 1), s = -1;
      continue;
    }
    s === -1 ? s = a : e[a][0].classes[0] !== e[a - 1][0].classes[0] && (o(a), s = a);
  }
  return s !== -1 && o(e.length), i;
}
function sG(t, e, r = PE, n = r, i, s = !1) {
  const o = t.project(void 0, i);
  let a = e.map(
    ({ start: c, end: p }) => [
      ty(o.slice(c, p), r, n),
      c,
      p
    ]
  );
  s && a.length > 1 && (a = iG(o, a, r, n));
  const l = [];
  for (let c = 0; c < a.length; c++) {
    const [p, h, d] = a[c];
    for (const b of p.classes)
      l.push(new mu(
        t,
        i,
        [
          "Fall",
          "Stable",
          "Rise"
          /* RT */
        ][b + 1],
        h,
        d
      ));
    if (c < a.length - 1) {
      p.classes.includes(1) ? l.push(new mu(t, i, "BigJump", h, d)) : p.classes.includes(-1) && l.push(new mu(t, i, "BigFall", h, d));
      const [b, m, w] = a[c + 1], f = JH.filter((E) => p.classes.includes(E[0]) && b.classes.includes(E[1]));
      for (const E of f)
        l.push(new mu(t, i, E[2], h, m, w)), c + 1 === a.length - 1 && l.push(new mu(t, i, E[3], h, m, w));
      if (c < a.length - 2) {
        const [E, A, x] = a[c + 2], g = XH.filter(
          (v) => p.classes.includes(v[0]) && b.classes.includes(v[1]) && E.classes.includes(v[2])
        );
        for (const v of g)
          l.push(new mu(t, i, v[3], h, m, A, x)), c + 2 === a.length - 1 && l.push(new mu(t, i, v[4], h, m, A, x));
      }
    }
  }
  return { candidates: l, slopeInfo: a.map(([c, p, h]) => c) };
}
class oG extends Error {
}
function hk(t) {
  const e = [];
  let r = 0;
  for (let n = 0; n < t; n++)
    e[n] = Math.random(), r += e[n];
  for (let n = 0; n < t; n++)
    e[n] = e[n] / r;
  return e;
}
function RE(t, e, r) {
  if (e && e.length > 0) {
    const n = [];
    if (e.length === 1 || r === e.length - 1) {
      const i = e.length === 1 ? 0 : r, s = e[i].values.length;
      for (let o = 0; o < s; o++) {
        const a = hk(t.length);
        n.push(a);
      }
    } else {
      const i = e[r].values.length;
      for (let s = 0; s < i; s++) {
        const o = RE(t, e, r + 1);
        n.push(o);
      }
    }
    return n;
  } else
    return hk(t.length);
}
function aG(t, e, r) {
  const n = RE(t, e, 0);
  return VO(n, r, 0), n;
}
function pk(t) {
  return t.constructor === Array;
}
function lG(t) {
  return !!(pk(t) && t.length > 0 && pk(t[0]));
}
function VO(t, e, r) {
  if (lG(t)) {
    let n = r;
    for (let i = 0; i < t.length; i++)
      n = VO(t[i], e, n);
    return n;
  } else {
    for (let i = 0; i < t.length; i++)
      t[i] = e[r][i];
    return r + 1;
  }
}
function cG(t) {
  const e = [];
  for (let r = 0; r < t.length; r++)
    e.push(UO(t[r]));
  return e;
}
function UO(t) {
  const e = [];
  let r = 0;
  for (let n = 0; n < t.length; n++)
    e[n] = t[n] + 1e-3, r += e[n];
  for (let n = 0; n < t.length; n++)
    e[n] = e[n] / r;
  return e;
}
class uG {
  constructor(e, r) {
    rr(this, "name");
    rr(this, "values");
    rr(this, "_sampledLw");
    rr(this, "wasSampled", !1);
    // keeping parent names here rather than references works better
    // for using worker threads
    rr(this, "parents", []);
    rr(this, "cpt", []);
    rr(this, "value", -1);
    rr(this, "dirty", !1);
    rr(this, "isObserved", !1);
    // XXX better to use Map
    rr(this, "valueIndexMap");
    rr(this, "g");
    this.name = e, this.values = r;
  }
  initSampleLw() {
    this._sampledLw = void 0;
  }
  sampleLw() {
    if (this.wasSampled)
      return 1;
    const e = this.parents.map((i) => this.g.nodeMap[i]);
    let r = 1;
    e.forEach((i) => {
      r *= i.sampleLw();
    }), this.wasSampled = !0;
    let n = this.cpt;
    if (e.forEach((i) => {
      n = n[i.value];
    }), this.value != -1)
      r *= n[this.value];
    else {
      let i = Math.random();
      for (let s = 0; s < n.length; s++)
        if (i -= n[s], i < 0) {
          this.value = s;
          break;
        }
    }
    return r;
  }
  saveSampleLw(e) {
    if (!this._sampledLw) {
      this._sampledLw = new Array(this.values.length);
      for (let r = this.values.length - 1; r >= 0; r--)
        this._sampledLw[r] = 0;
    }
    this._sampledLw[this.value] += e;
  }
  addParent(e) {
    return this.parents.push(e), this.dirty = !0, this;
  }
  valueIndex(e) {
    if (!this.valueIndexMap) {
      this.valueIndexMap = {};
      for (let r = 0; r < this.values.length; r++) {
        const n = this.values[r];
        this.valueIndexMap[n] = r;
      }
    }
    return this.valueIndexMap[e];
  }
  observe(e) {
    const r = this.valueIndex(e);
    r >= 0 ? (this.isObserved = !0, this.value = r) : console.error("could not find value " + e + " for node " + this.name);
  }
  unobserve() {
    this.isObserved = !1, this.value = -1;
  }
  setCpt(e) {
    if (this.parents.length === 0)
      this.cpt = UO(e);
    else {
      if (!this.g)
        throw new oG("must add node to graph before calling setCpt()");
      const r = this.parents.map((n) => this.g.nodeMap[n]);
      this.cpt = aG(this.values, r, cG(e));
    }
  }
  probs() {
    if (!this._sampledLw)
      return [];
    const e = this._sampledLw.reduce((r, n) => r + n, 0);
    return this._sampledLw.map((r) => r / e);
  }
}
function hG() {
  class t {
    constructor(s, o) {
      rr(this, "name");
      rr(this, "values");
      rr(this, "_sampledLw");
      rr(this, "wasSampled", !1);
      rr(this, "parents", []);
      rr(this, "cpt", []);
      rr(this, "value", -1);
      rr(this, "dirty", !1);
      rr(this, "isObserved", !1);
      rr(this, "g");
      this.name = s, this.values = o;
    }
    initSampleLw() {
      this._sampledLw = void 0;
    }
    sampleLw() {
      if (this.wasSampled)
        return 1;
      const s = this.parents.map((l) => this.g.nodeMap[l]);
      let o = 1;
      s.forEach((l) => {
        o *= l.sampleLw();
      }), this.wasSampled = !0;
      let a = this.cpt;
      if (s.forEach((l) => {
        a = a[l.value];
      }), this.value != -1)
        o *= a[this.value];
      else {
        let l = Math.random();
        for (let c = 0; c < a.length; c++)
          if (l -= a[c], l < 0) {
            this.value = c;
            break;
          }
      }
      return o;
    }
    saveSampleLw(s) {
      if (!this._sampledLw) {
        this._sampledLw = new Array(this.values.length);
        for (let o = this.values.length - 1; o >= 0; o--)
          this._sampledLw[o] = 0;
      }
      this._sampledLw[this.value] += s;
    }
  }
  class e {
    constructor() {
      rr(this, "nodes", []);
      rr(this, "nodeMap", {});
    }
    sample(s) {
      for (let a = this.nodes.length - 1; a >= 0; a--)
        this.nodes[a].initSampleLw();
      let o = 0;
      for (let a = 0; a < s; a++) {
        for (let c = this.nodes.length - 1; c >= 0; c--) {
          const p = this.nodes[c];
          p.isObserved || (p.value = -1), p.wasSampled = !1;
        }
        const l = this.nodes.reduceRight((c, p) => c * p.sampleLw(), 1);
        o += l;
        for (let c = this.nodes.length - 1; c >= 0; c--)
          this.nodes[c].saveSampleLw(l);
      }
      return o;
    }
  }
  function r(i) {
    const s = Object.create(e.prototype, Object.getOwnPropertyDescriptors(i.graph)), o = s.nodes.map((a) => {
      const l = Object.create(t.prototype, Object.getOwnPropertyDescriptors(a));
      return l.g = s, s.nodeMap[a.name] = l, l;
    });
    return s.nodes = o, s;
  }
  function n(i) {
    const s = r(i);
    s.sample(i.samples);
    const o = {};
    for (let a = 0; a < s.nodes.length; a++)
      o[s.nodes[a].name] = s.nodes[a];
    self.postMessage(o);
  }
  self.onmessage = function(i) {
    n(i.data);
  };
}
const pG = hG.toString().trim().split(`
`).slice(1, -1).join(`
`), dG = new Blob([pG], { type: "text/javascript" }), fG = URL.createObjectURL(dG);
class gG {
  constructor() {
    rr(this, "nodes", []);
    rr(this, "saveSamples", !1);
    rr(this, "samples", []);
    rr(this, "nodeMap", {});
  }
  reinit() {
    this.nodes.forEach((e) => {
      if (e.dirty === void 0 || e.dirty) {
        const r = e.parents.map((n) => this.nodeMap[n]);
        e.cpt = RE(e.values, r, 0), e.dirty = !1;
      }
    });
  }
  sample(e) {
    this.saveSamples && (this.samples = []);
    for (let n = this.nodes.length - 1; n >= 0; n--)
      this.nodes[n].initSampleLw();
    let r = 0;
    for (let n = 0; n < e; n++) {
      for (let s = this.nodes.length - 1; s >= 0; s--) {
        const o = this.nodes[s];
        o.isObserved || (o.value = -1), o.wasSampled = !1;
      }
      const i = this.nodes.reduceRight((s, o) => s * o.sampleLw(), 1);
      r += i;
      for (let s = this.nodes.length - 1; s >= 0; s--)
        this.nodes[s].saveSampleLw(i);
      if (this.saveSamples) {
        const s = {};
        for (let o = this.nodes.length - 1; o >= 0; o--) {
          const a = this.nodes[o];
          s[a.name] = a.values[a.value];
        }
        this.samples.push(s);
      }
    }
    return r;
  }
  /*private createNodeMap() {
    this.nodeMap = {};
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      this.nodeMap[node.name] = node;
    }
  }*/
  node(e) {
    return this.nodeMap[e];
  }
  observe(e, r) {
    const n = this.node(e);
    n ? n.observe(r) : console.error("could not find node with name " + e);
  }
  unobserve(e) {
    const r = this.node(e);
    r && r.unobserve();
  }
  newNode(e, r) {
    const n = new uG(e, r);
    return this.addNodes(n), n;
  }
  addNodes(...e) {
    e.forEach((r) => {
      r.g = this, this.nodeMap[r.name] = r;
    }), this.nodes.push(...e);
  }
  samplesAsCsv(e) {
    const r = e || {}, n = r.rowDelimiter || `
`, i = r.fieldDelimiter || ",";
    let s = "", o = "";
    for (let a = 0; a < this.nodes.length; a++)
      o += this.nodes[a].name, a < this.nodes.length - 1 && (o += i);
    s += o + n;
    for (let a = 0; a < this.samples.length; a++) {
      const l = this.samples[a];
      o = "";
      for (let c = 0; c < this.nodes.length; c++) {
        const p = this.nodes[c];
        o += l[p.name], c < this.nodes.length - 1 && (o += i);
      }
      s += o, a < this.samples.length - 1 && (s += n);
    }
    return s;
  }
  toWorkerMessage(e) {
    return {
      samples: e,
      graph: this
    };
  }
  async sampleWithWorker(e) {
    return new Promise((r) => {
      const n = new Worker(fG, { type: "module" });
      n.onerror = (i) => {
        console.error(i);
      }, n.onmessage = (i) => {
        const s = i.data;
        this.updateFromWorker(s), r();
      }, n.postMessage(this.toWorkerMessage(e));
    });
  }
  updateFromWorker(e) {
    for (let r = 0; r < this.nodes.length; r++) {
      const n = this.nodes[r], i = e[n.name];
      i && (n.value = i.value, n.wasSampled = i.wasSampled, n._sampledLw = i._sampledLw);
    }
  }
}
var mG = Object.defineProperty, yG = (t, e, r) => e in t ? mG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Oi = (t, e, r) => (yG(t, typeof e != "symbol" ? e + "" : e, r), r);
function bG(t, e) {
  const r = t.length, n = t.project(void 0, e);
  if (r < 3) {
    const i = (n.points[1].y - n.points[0].y) / (n.points[1].x - n.points[0].x);
    return px(i);
  } else {
    const i = _E(t.points.map((s) => [s.x, s.y]));
    return px(i.m);
  }
}
const HO = {
  /*density: {
    values: ['low', 'med', 'high'],
    fn(series: Point[]) {
      return series.length < 10 ? this.values[0] : series.length < 30 ? this.values[1] : this.values[2];
    }
  },*/
}, GO = {
  percentage: {
    values: ["<20", ">=20", ">=40", ">=60", ">=80", "100"],
    fn(t, e) {
      const r = (t.params[t.params.length - 1] - 1 - t.params[0]) / (e.length - 1);
      return this.values[Math.floor(r * 10 / 2)];
    }
  },
  /*percentage: {
    values: ['<80', '>=80', '100'],
    fn(cand: Candidate, series: Point[]) {
      // cand.params values (indices) are taken from sequence endpoints, which now look like
      // slices, so the final param value will always be 1 greater than the final
      // index of the final sequence.
      const pct = (cand.params[cand.params.length - 1]! - 1 - cand.params[0])/(series.length - 1);
      return pct === 1 ? this.values[2] : pct >= 0.8 ? this.values[1] : this.values[0];
    }
  },*/
  touchEnd: {
    values: ["yes", "no"],
    fn(t, e) {
      return t.params.at(-1) === e.length ? this.values[0] : this.values[1];
    }
  },
  lastLength: {
    values: ["<20", ">=20"],
    fn(t, e) {
      const r = t.params.length;
      return (t.params[r - 1] - 1 - t.params[r - 2]) / (e.length - 1) >= 0.2 ? this.values[1] : this.values[0];
    }
  },
  volatility: {
    values: ["low", "med", "high"],
    fn(t, e) {
      const r = e.points.map((o) => o.y), n = IE(r) - CE(r);
      if (n === 0)
        return this.values[0];
      let i = 0;
      for (let o = 0; o < t.params.length - 1; o++) {
        const a = o < t.params.length - 2 ? e.slice(t.params[o], t.params[o + 1] + 1) : e.slice(t.params[o], t.params[o + 1]);
        a.length > 2 && (i += 2 * Math.sqrt(a.bestFit.rss() / a.length) / n);
      }
      const s = i / (t.params.length - 1);
      return s < 0.1 ? this.values[0] : s < 0.3 ? this.values[1] : this.values[2];
    }
  },
  /*containsMinMax: {
    values: ['yes', 'no'],
    fn(cand: Candidate, series: Point[]) {
      const ys = series.map(p => p[1]);
      const min = Math.min(...ys);
      const max = Math.max(...ys);
      const candYs = ys.slice(cand.params[0], cand.params.at(-1)! + 1);
      return candYs.find(y => y === min || y === max) !== undefined ? this.values[0] : this.values[1];
    }
  },*/
  /*yScale: {
    values: ['<80', '>=80'],
    cats: ['BigJump', 'BigFall'],
    fn(cand: Candidate, series: Point[], chartRanges?: ChartRanges) {
      const ys = series.map(p => p[1]);
      const candYs = ys.slice(cand.params[0], cand.params.at(-1)!);
      const candYRange = Math.max(...candYs) - Math.min(...candYs);
      const chartYRange = chartRanges ? chartRanges.y : getChartRanges(series).y;
      const yScale = candYRange/(chartYRange[1] - chartYRange[0]);
      return yScale >= 0.8 ? this.values[1] : this.values[0];
    }     
  },*/
  yScale: {
    values: ["<20", ">=20", ">=40", ">=60", ">=80", "100"],
    fn(t, e, r = e.yBounds()) {
      const n = e.points.map((o) => o.y).slice(t.params[0], t.params.at(-1)), i = Math.max(...n) - Math.min(...n);
      if (i === 0)
        return this.values[0];
      const s = i / (r.end - r.start);
      return this.values[Math.floor(s * 10 / 2)];
    }
  },
  xDuration: {
    values: ["<25", ">=25"],
    cats: ["BigJump", "BigFall"],
    fn(t, e) {
      return (t.params.at(-1) - 1 - t.params[0]) / (e.length - 1) >= 0.25 ? this.values[1] : this.values[0];
    }
  },
  bigSlope: {
    values: ["<60", ">=60"],
    cats: ["BigJump", "BigFall"],
    fn(t, e, r) {
      const n = e.slice(t.params[0], t.params.at(-1));
      return Math.abs(bG(n, r)) >= 60 ? this.values[1] : this.values[0];
    }
  }
};
function vG(t, e) {
  const r = {};
  for (const [n, i] of Object.entries(HO))
    r[n] = i.fn(t, e);
  return r;
}
function wG(t, e, r) {
  const n = {};
  for (const [i, s] of Object.entries(GO))
    (s.cats === void 0 || s.cats.includes(t.category)) && (n[i] = s.fn(t, e, r));
  return n;
}
function xG(t) {
  const e = {};
  for (const r of t) {
    const n = r.category;
    e[n] || (e[n] = []), e[n].push(r);
  }
  return e;
}
let EG = class {
  constructor(e, r, n, i) {
    Oi(this, "cands"), Oi(this, "net", new gG()), Oi(this, "root"), Oi(this, "catNodes", {}), Oi(this, "hasSugNodes", {}), Oi(this, "candNodes", {}), Oi(this, "genEvidNodes", {}), Oi(this, "candEvidNodes", {}), this.msgEx = e, this.line = r, this.yAxis = i, this.cands = xG(n), this.root = this.net.newNode("root", this.msgEx.cats), this.root.setCpt(this.msgEx.catPriors);
  }
  build() {
    this.createGeneralEvidenceNodes(), this.createCategoryNodes();
    for (const e of this.msgEx.cats) {
      const r = this.net.newNode(`${e}.hasSug`, ["true", "false"]);
      this.hasSugNodes[e] = r, r.addParent(e);
      const n = this.msgEx.catPHasSug[e];
      r.setCpt([
        [1, 0],
        // p(hasSug=T|cat=T), p(hasSug=F|cat=T)
        [n, 1 - n]
        // p(hasSug=T|cat=F), p(hasSug=F|cat=F) 
      ]);
    }
    for (const e of Object.keys(this.cands).sort()) {
      this.createCandidateNodes(e);
      const r = this.candNodes[e];
      this.candEvidNodes[e] = [];
      for (let n = 0; n < r.length; n++)
        this.createCandidateEvidenceNodes(e, n);
    }
  }
  createGeneralEvidenceNodes() {
    for (const [e, r] of Object.entries(HO))
      this.genEvidNodes[e] = this.net.newNode(e, r.values);
    for (const [e, r] of Object.entries(this.genEvidNodes))
      r.addParent(this.root.name), r.setCpt([
        ...this.root.values.map((n) => r.values.map((i) => this.msgEx.catProbs[n].general.density[i]))
        // p(density=val|root=cat)
      ]);
  }
  createCategoryNodes() {
    for (const e of this.msgEx.cats) {
      const r = this.net.newNode(e, ["true", "false"]);
      r.addParent(this.root.name), r.setCpt(this.msgEx.cats.map((n) => n === e ? [1, 0] : [0, 1])), this.catNodes[e] = r;
    }
  }
  createCandidateNodes(e) {
    const r = [];
    this.catNodes[e];
    const n = this.cands[e];
    for (let i = 0; i < n.length; i++) {
      n[i];
      const s = this.net.newNode(`${e}.cand${i}`, ["true", "false"]);
      r.push(s), s.addParent(e);
      for (let l = 0; l < i; l++)
        s.addParent(r[l].name);
      const o = [], a = 2 ** s.parents.length;
      for (let l = 0; l < a; l++)
        l === a / 2 - 1 ? o.push([
          // I'm making the assumption that, given no evidence,
          // all candidates for a particular message are equally likely
          // (given that message=T)
          1 / (n.length - i),
          (n.length - (i + 1)) / (n.length - i)
        ]) : o.push([0, 1]);
      s.setCpt(o);
    }
    this.candNodes[e] = r;
  }
  createCandidateEvidenceNodes(e, r) {
    const n = this.candNodes[e][r], i = {};
    for (const [s, o] of Object.entries(GO))
      (o.cats === void 0 || o.cats.includes(e)) && (i[s] = this.net.newNode(`${e}.cand${r}.${s}`, o.values));
    for (const [s, o] of Object.entries(i)) {
      o.addParent(n.name);
      const a = this.msgEx.catProbs[e].cand[s];
      o.setCpt([
        o.values.map((l) => a[l][0]),
        // p(evid=val|inPlan)
        o.values.map((l) => a[l][1])
        // p(evid=val|notInPlan)
      ]);
    }
    this.candEvidNodes[e].push(i);
  }
  observeEvidence() {
    var e;
    for (const n of this.msgEx.cats)
      this.hasSugNodes[n].observe(this.cands[n] ? "true" : "false"), (e = this.candEvidNodes[n]) == null || e.forEach((i, s) => {
        const o = this.cands[n][s], a = wG(o, this.line, this.yAxis);
        for (const [l, c] of Object.entries(i))
          c.observe(a[l]);
      });
    const r = vG(this.line, this.yAxis);
    for (const [n, i] of Object.entries(this.genEvidNodes))
      i.observe(r[n]);
  }
  async updateProbs(e = !0) {
    e ? await this.net.sampleWithWorker(1e4) : this.net.sample(1e4);
  }
  getSelectedCat() {
    let e = 0, r = 0;
    const n = this.root.probs();
    for (let i = 0; i < this.root.values.length; i++)
      n[i] > e && (e = n[i], r = i);
    return this.root.values[r];
  }
  getSelectedCand(e) {
    const r = this.candNodes[e];
    if (r === void 0)
      return;
    let n = 0, i = 0;
    for (let s = 0; s < r.length; s++) {
      const o = r[s].probs();
      o[0] > n && (n = o[0], i = s);
    }
    return i;
  }
  getPrediction() {
    const e = this.getSelectedCat(), r = this.getSelectedCand(e);
    if (r !== void 0)
      return { cand: this.cands[e][r], idx: r };
  }
}, SG = class {
  /**
   * @param model - Optional statistical data used by the Bayesian network (or ID thereof)
   */
  constructor(e) {
    if (Oi(this, "modelData"), Oi(this, "cats"), Oi(this, "catPriors"), Oi(this, "catPHasSug"), Oi(this, "catProbs"), typeof e == "string" || e === void 0) {
      const r = kG(e);
      if (!r)
        throw new Error(`unknown model ID '${e}'`);
      this.modelData = r;
    } else
      this.modelData = e;
    this.cats = Object.keys(this.modelData).sort(), this.catPriors = this.cats.map((r) => this.modelData[r].prior), this.catPHasSug = Object.fromEntries(this.cats.map((r) => [r, this.modelData[r].hasSug])), this.catProbs = Object.fromEntries(this.cats.map((r) => [r, this.modelData[r].probs]));
  }
  /**
   * Select the most likely (i.e., most important section) of a line.
   * @param line - Line to analyze (in its original coordinate system)
   * @param candidates - All candidate messages (as generated by 
   * chart-message-candidates#genCandidates())
   * @param yAxis - Optional displayed chart y-axis value range;
   * defaults to extreme values of data
   * @param useWorker - Do prediction in a Web Worker
   * @returns Selected candidate object and index of said candidate with
   * respect to all candidates of its type, or undefined if the model
   * failed to make a valid prediction.
   * @remarks
   * The machine learning analysis performed by this method is now
   * offloaded to a worker thread, so the result can be usefully obtained
   * asynchronously via a `.then()` callback on the returned promise.
   */
  async chooseMessage(e, r, n, i = !0) {
    if (r.length === 1)
      return { cand: r[0], idx: 0 };
    const s = new EG(this, e, r, n);
    return s.build(), s.observeEvidence(), await s.updateProbs(i), s.getPrediction();
  }
  /*buildNet(series: number[], candidates: Candidate[]) {
    const net = new BayesNet(this, series, candidates);
    net.build();
    return net;
  }*/
  /*netToTree(net: JGraph): TreeNode {
    const nodes: {[index: string]: TreeNode} = {};
    function newTreeNode(jnode: JNode) {
      const tn: TreeNode = {
        name: jnode.name,
        prob: 0
      };
      if (jnode.values[0] === 'true') {
        tn.values = jnode.values;
        tn.prob = jnode.probs();
      } else {
        tn.values = jnode.values;
        tn.prob = jnode.probs();
      }
      return tn;
    }
    for (const node of net.nodes) {
      if (node.name === 'TempJump') {
        console.log('TempJump', node, node.probs());
      }
      if (!nodes[node.name]) {
        nodes[node.name] = newTreeNode(node);
      }
      const treeNode = nodes[node.name];
      for (const p of node.parents) {
        if (!nodes[p.name]) {
          nodes[p.name] = newTreeNode(p);
        }
        if (!nodes[p.name].children) {
          nodes[p.name].children = [];
        }
        nodes[p.name].children!.push(treeNode);
      }
    }
    return nodes['root'];
  }*/
};
const WO = {
  "18b7ef6b98c": {
    trainDataName: "cm3_reconc_jf",
    model: {
      Rise: {
        prior: 0.05333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.8125,
                0
              ],
              "<20": [
                0,
                0.4180790960451977
              ],
              ">=20": [
                0.125,
                0.3220338983050847
              ],
              ">=40": [
                0,
                0.14689265536723164
              ],
              ">=60": [
                0.0625,
                0.0847457627118644
              ],
              ">=80": [
                0,
                0.02824858757062147
              ]
            },
            touchEnd: {
              yes: [
                0.9375,
                0.2514124293785311
              ],
              no: [
                0.0625,
                0.748587570621469
              ]
            },
            lastLength: {
              "<20": [
                0,
                0.4180790960451977
              ],
              ">=20": [
                1,
                0.5819209039548022
              ]
            },
            volatility: {
              low: [
                0.3125,
                0.5084745762711864
              ],
              med: [
                0.6875,
                0.423728813559322
              ],
              high: [
                0,
                0.06779661016949153
              ]
            },
            yScale: {
              100: [
                0.4375,
                0.0480225988700565
              ],
              "<20": [
                0,
                0.17231638418079095
              ],
              ">=20": [
                0.0625,
                0.2570621468926554
              ],
              ">=40": [
                0.3125,
                0.268361581920904
              ],
              ">=60": [
                0.125,
                0.12146892655367232
              ],
              ">=80": [
                0.0625,
                0.1327683615819209
              ]
            }
          }
        },
        hasSug: 0.7640845070422535
      },
      Fall: {
        prior: 0.07,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.7619047619047619,
                0.005633802816901409
              ],
              "<20": [
                0,
                0.4788732394366197
              ],
              ">=20": [
                0.09523809523809523,
                0.27323943661971833
              ],
              ">=40": [
                0.09523809523809523,
                0.14366197183098592
              ],
              ">=60": [
                0,
                0.05352112676056338
              ],
              ">=80": [
                0.047619047619047616,
                0.04507042253521127
              ]
            },
            touchEnd: {
              yes: [
                0.9523809523809523,
                0.2619718309859155
              ],
              no: [
                0.047619047619047616,
                0.7380281690140845
              ]
            },
            lastLength: {
              "<20": [
                0,
                0.4788732394366197
              ],
              ">=20": [
                1,
                0.5211267605633803
              ]
            },
            volatility: {
              low: [
                0.3333333333333333,
                0.5183098591549296
              ],
              med: [
                0.5714285714285714,
                0.38591549295774646
              ],
              high: [
                0.09523809523809523,
                0.09577464788732394
              ]
            },
            yScale: {
              100: [
                0.5714285714285714,
                0.07323943661971831
              ],
              "<20": [
                0,
                0.17746478873239438
              ],
              ">=20": [
                0.09523809523809523,
                0.29014084507042254
              ],
              ">=40": [
                0.23809523809523808,
                0.23380281690140844
              ],
              ">=60": [
                0.047619047619047616,
                0.11549295774647887
              ],
              ">=80": [
                0.047619047619047616,
                0.10985915492957747
              ]
            }
          }
        },
        hasSug: 0.8028673835125448
      },
      Stable: {
        prior: 0.03333333333333333,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.5,
                0
              ],
              "<20": [
                0,
                0.12962962962962962
              ],
              ">=20": [
                0.2,
                0.2962962962962963
              ],
              ">=40": [
                0,
                0.3194444444444444
              ],
              ">=60": [
                0.2,
                0.14351851851851852
              ],
              ">=80": [
                0.1,
                0.1111111111111111
              ]
            },
            touchEnd: {
              yes: [
                1,
                0.48148148148148145
              ],
              no: [
                0,
                0.5185185185185185
              ]
            },
            lastLength: {
              "<20": [
                0,
                0.12962962962962962
              ],
              ">=20": [
                1,
                0.8703703703703703
              ]
            },
            volatility: {
              low: [
                0.5,
                0.5972222222222222
              ],
              med: [
                0,
                0.37037037037037035
              ],
              high: [
                0.5,
                0.032407407407407406
              ]
            },
            yScale: {
              100: [
                0,
                0.004629629629629629
              ],
              "<20": [
                0.5,
                0.7870370370370371
              ],
              ">=20": [
                0.2,
                0.17592592592592593
              ],
              ">=40": [
                0.3,
                0.027777777777777776
              ],
              ">=60": [
                0,
                0.004629629629629629
              ],
              ">=80": [
                0,
                0
              ]
            }
          }
        },
        hasSug: 0.6206896551724138
      },
      BigJump: {
        prior: 0.006666666666666667,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0
              ],
              "<20": [
                1,
                0.4431818181818182
              ],
              ">=20": [
                0,
                0.32954545454545453
              ],
              ">=40": [
                0,
                0.12878787878787878
              ],
              ">=60": [
                0,
                0.06439393939393939
              ],
              ">=80": [
                0,
                0.03409090909090909
              ]
            },
            touchEnd: {
              yes: [
                0,
                0
              ],
              no: [
                1,
                1
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.4431818181818182
              ],
              ">=20": [
                0,
                0.5568181818181818
              ]
            },
            volatility: {
              low: [
                1,
                0.4659090909090909
              ],
              med: [
                0,
                0.45454545454545453
              ],
              high: [
                0,
                0.07954545454545454
              ]
            },
            yScale: {
              100: [
                0,
                0.06439393939393939
              ],
              "<20": [
                0,
                0.125
              ],
              ">=20": [
                0,
                0.26515151515151514
              ],
              ">=40": [
                0,
                0.2840909090909091
              ],
              ">=60": [
                0,
                0.14393939393939395
              ],
              ">=80": [
                1,
                0.11742424242424243
              ]
            },
            xDuration: {
              "<25": [
                1,
                0.5984848484848485
              ],
              ">=25": [
                0,
                0.4015151515151515
              ]
            },
            bigSlope: {
              "<60": [
                1,
                0.4734848484848485
              ],
              ">=60": [
                0,
                0.5265151515151515
              ]
            }
          }
        },
        hasSug: 0.6442953020134228
      },
      BigFall: {
        prior: 0.02666666666666667,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0
              ],
              "<20": [
                0.75,
                0.5568627450980392
              ],
              ">=20": [
                0.25,
                0.2549019607843137
              ],
              ">=40": [
                0,
                0.13725490196078433
              ],
              ">=60": [
                0,
                0.03529411764705882
              ],
              ">=80": [
                0,
                0.01568627450980392
              ]
            },
            touchEnd: {
              yes: [
                0,
                0
              ],
              no: [
                1,
                1
              ]
            },
            lastLength: {
              "<20": [
                0.75,
                0.5568627450980392
              ],
              ">=20": [
                0.25,
                0.44313725490196076
              ]
            },
            volatility: {
              low: [
                0.5,
                0.47058823529411764
              ],
              med: [
                0.25,
                0.41568627450980394
              ],
              high: [
                0.25,
                0.11372549019607843
              ]
            },
            yScale: {
              100: [
                0.375,
                0.0784313725490196
              ],
              "<20": [
                0,
                0.09019607843137255
              ],
              ">=20": [
                0,
                0.3137254901960784
              ],
              ">=40": [
                0,
                0.25098039215686274
              ],
              ">=60": [
                0,
                0.1411764705882353
              ],
              ">=80": [
                0.625,
                0.12549019607843137
              ]
            },
            xDuration: {
              "<25": [
                0.875,
                0.6627450980392157
              ],
              ">=25": [
                0.125,
                0.33725490196078434
              ]
            },
            bigSlope: {
              "<60": [
                0.5,
                0.5294117647058824
              ],
              ">=60": [
                0.5,
                0.47058823529411764
              ]
            }
          }
        },
        hasSug: 0.6506849315068494
      },
      ReversalToRise: {
        prior: 0.07,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.3333333333333333,
                0.03289473684210526
              ],
              "<20": [
                0.047619047619047616,
                0.125
              ],
              ">=20": [
                0.2857142857142857,
                0.375
              ],
              ">=40": [
                0.09523809523809523,
                0.2565789473684211
              ],
              ">=60": [
                0.047619047619047616,
                0.16447368421052633
              ],
              ">=80": [
                0.19047619047619047,
                0.046052631578947366
              ]
            },
            touchEnd: {
              yes: [
                0.5238095238095238,
                0.32894736842105265
              ],
              no: [
                0.47619047619047616,
                0.6710526315789473
              ]
            },
            lastLength: {
              "<20": [
                0.3333333333333333,
                0.5263157894736842
              ],
              ">=20": [
                0.6666666666666666,
                0.47368421052631576
              ]
            },
            volatility: {
              low: [
                0.3333333333333333,
                0.48026315789473684
              ],
              med: [
                0.5238095238095238,
                0.5131578947368421
              ],
              high: [
                0.14285714285714285,
                0.006578947368421052
              ]
            },
            yScale: {
              100: [
                0.2857142857142857,
                0.15789473684210525
              ],
              "<20": [
                0,
                0.006578947368421052
              ],
              ">=20": [
                0.09523809523809523,
                0.2236842105263158
              ],
              ">=40": [
                0.3333333333333333,
                0.26973684210526316
              ],
              ">=60": [
                0.09523809523809523,
                0.19736842105263158
              ],
              ">=80": [
                0.19047619047619047,
                0.14473684210526316
              ]
            }
          }
        },
        hasSug: 0.4014336917562724
      },
      ReversalToFall: {
        prior: 0.07,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.42857142857142855,
                0.047337278106508875
              ],
              "<20": [
                0.14285714285714285,
                0.11242603550295859
              ],
              ">=20": [
                0.09523809523809523,
                0.38461538461538464
              ],
              ">=40": [
                0.14285714285714285,
                0.27218934911242604
              ],
              ">=60": [
                0.09523809523809523,
                0.13609467455621302
              ],
              ">=80": [
                0.09523809523809523,
                0.047337278106508875
              ]
            },
            touchEnd: {
              yes: [
                0.6666666666666666,
                0.23076923076923078
              ],
              no: [
                0.3333333333333333,
                0.7692307692307693
              ]
            },
            lastLength: {
              "<20": [
                0.23809523809523808,
                0.6035502958579881
              ],
              ">=20": [
                0.7619047619047619,
                0.39644970414201186
              ]
            },
            volatility: {
              low: [
                0.2857142857142857,
                0.4378698224852071
              ],
              med: [
                0.6666666666666666,
                0.5325443786982249
              ],
              high: [
                0.047619047619047616,
                0.029585798816568046
              ]
            },
            yScale: {
              100: [
                0.23809523809523808,
                0.13609467455621302
              ],
              "<20": [
                0,
                0.01775147928994083
              ],
              ">=20": [
                0.14285714285714285,
                0.1952662721893491
              ],
              ">=40": [
                0.3333333333333333,
                0.3136094674556213
              ],
              ">=60": [
                0.09523809523809523,
                0.1952662721893491
              ],
              ">=80": [
                0.19047619047619047,
                0.14201183431952663
              ]
            }
          }
        },
        hasSug: 0.44802867383512546
      },
      EmergingRise: {
        prior: 0.09333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.75,
                0.027777777777777776
              ],
              "<20": [
                0,
                0.08333333333333333
              ],
              ">=20": [
                0,
                0.25
              ],
              ">=40": [
                0.10714285714285714,
                0.3611111111111111
              ],
              ">=60": [
                0.10714285714285714,
                0.25
              ],
              ">=80": [
                0.03571428571428571,
                0.027777777777777776
              ]
            },
            touchEnd: {
              yes: [
                0.9642857142857143,
                0.08333333333333333
              ],
              no: [
                0.03571428571428571,
                0.9166666666666666
              ]
            },
            lastLength: {
              "<20": [
                0.07142857142857142,
                0.5555555555555556
              ],
              ">=20": [
                0.9285714285714286,
                0.4444444444444444
              ]
            },
            volatility: {
              low: [
                0.7142857142857143,
                0.5
              ],
              med: [
                0.2857142857142857,
                0.4722222222222222
              ],
              high: [
                0,
                0.027777777777777776
              ]
            },
            yScale: {
              100: [
                0.35714285714285715,
                0.1111111111111111
              ],
              "<20": [
                0,
                0.05555555555555555
              ],
              ">=20": [
                0.10714285714285714,
                0.16666666666666666
              ],
              ">=40": [
                0.42857142857142855,
                0.25
              ],
              ">=60": [
                0.03571428571428571,
                0.19444444444444445
              ],
              ">=80": [
                0.07142857142857142,
                0.2222222222222222
              ]
            }
          }
        },
        hasSug: 0.11397058823529412
      },
      EmergingFall: {
        prior: 0.05333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.4375,
                0
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.0625,
                0.16129032258064516
              ],
              ">=40": [
                0.1875,
                0.41935483870967744
              ],
              ">=60": [
                0.0625,
                0.22580645161290322
              ],
              ">=80": [
                0.25,
                0.1935483870967742
              ]
            },
            touchEnd: {
              yes: [
                0.875,
                0.1935483870967742
              ],
              no: [
                0.125,
                0.8064516129032258
              ]
            },
            lastLength: {
              "<20": [
                0.1875,
                0.6451612903225806
              ],
              ">=20": [
                0.8125,
                0.3548387096774194
              ]
            },
            volatility: {
              low: [
                0.5,
                0.5483870967741935
              ],
              med: [
                0.5,
                0.45161290322580644
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.125,
                0.22580645161290322
              ],
              "<20": [
                0,
                0.0967741935483871
              ],
              ">=20": [
                0.3125,
                0.22580645161290322
              ],
              ">=40": [
                0.375,
                0.25806451612903225
              ],
              ">=60": [
                0.125,
                0.0967741935483871
              ],
              ">=80": [
                0.0625,
                0.0967741935483871
              ]
            }
          }
        },
        hasSug: 0.1056338028169014
      },
      RiseToStable: {
        prior: 0.07333333333333333,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.45454545454545453,
                0.05263157894736842
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.045454545454545456,
                0.3157894736842105
              ],
              ">=40": [
                0.09090909090909091,
                0.34210526315789475
              ],
              ">=60": [
                0.13636363636363635,
                0.15789473684210525
              ],
              ">=80": [
                0.2727272727272727,
                0.13157894736842105
              ]
            },
            touchEnd: {
              yes: [
                0.9090909090909091,
                0.4473684210526316
              ],
              no: [
                0.09090909090909091,
                0.5526315789473685
              ]
            },
            lastLength: {
              "<20": [
                0.045454545454545456,
                0.23684210526315788
              ],
              ">=20": [
                0.9545454545454546,
                0.7631578947368421
              ]
            },
            volatility: {
              low: [
                0.5,
                0.631578947368421
              ],
              med: [
                0.5,
                0.3684210526315789
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.22727272727272727,
                0.10526315789473684
              ],
              "<20": [
                0.045454545454545456,
                0.05263157894736842
              ],
              ">=20": [
                0.13636363636363635,
                0.34210526315789475
              ],
              ">=40": [
                0.36363636363636365,
                0.3157894736842105
              ],
              ">=60": [
                0.13636363636363635,
                0.10526315789473684
              ],
              ">=80": [
                0.09090909090909091,
                0.07894736842105263
              ]
            }
          }
        },
        hasSug: 0.12589928057553956
      },
      FallToStable: {
        prior: 0.17333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.4807692307692308,
                0.16666666666666666
              ],
              "<20": [
                0,
                0.027777777777777776
              ],
              ">=20": [
                0,
                0.19444444444444445
              ],
              ">=40": [
                0.057692307692307696,
                0.2777777777777778
              ],
              ">=60": [
                0.19230769230769232,
                0.19444444444444445
              ],
              ">=80": [
                0.2692307692307692,
                0.1388888888888889
              ]
            },
            touchEnd: {
              yes: [
                0.9807692307692307,
                0.5833333333333334
              ],
              no: [
                0.019230769230769232,
                0.4166666666666667
              ]
            },
            lastLength: {
              "<20": [
                0.019230769230769232,
                0.1111111111111111
              ],
              ">=20": [
                0.9807692307692307,
                0.8888888888888888
              ]
            },
            volatility: {
              low: [
                0.3269230769230769,
                0.6111111111111112
              ],
              med: [
                0.6730769230769231,
                0.3611111111111111
              ],
              high: [
                0,
                0.027777777777777776
              ]
            },
            yScale: {
              100: [
                0.25,
                0.19444444444444445
              ],
              "<20": [
                0,
                0.08333333333333333
              ],
              ">=20": [
                0.15384615384615385,
                0.3055555555555556
              ],
              ">=40": [
                0.4423076923076923,
                0.16666666666666666
              ],
              ">=60": [
                0.11538461538461539,
                0.1388888888888889
              ],
              ">=80": [
                0.038461538461538464,
                0.1111111111111111
              ]
            }
          }
        },
        hasSug: 0.14112903225806453
      },
      Rebound: {
        prior: 0.10333333333333333,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.22580645161290322,
                0.09090909090909091
              ],
              "<20": [
                0,
                0.015151515151515152
              ],
              ">=20": [
                0.06451612903225806,
                0.22727272727272727
              ],
              ">=40": [
                0.16129032258064516,
                0.3333333333333333
              ],
              ">=60": [
                0.3225806451612903,
                0.24242424242424243
              ],
              ">=80": [
                0.22580645161290322,
                0.09090909090909091
              ]
            },
            touchEnd: {
              yes: [
                0.6774193548387096,
                0.3333333333333333
              ],
              no: [
                0.3225806451612903,
                0.6666666666666666
              ]
            },
            lastLength: {
              "<20": [
                0.2903225806451613,
                0.6515151515151515
              ],
              ">=20": [
                0.7096774193548387,
                0.3484848484848485
              ]
            },
            volatility: {
              low: [
                0.5483870967741935,
                0.42424242424242425
              ],
              med: [
                0.45161290322580644,
                0.5606060606060606
              ],
              high: [
                0,
                0.015151515151515152
              ]
            },
            yScale: {
              100: [
                0.3548387096774194,
                0.2878787878787879
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.10606060606060606
              ],
              ">=40": [
                0.2903225806451613,
                0.25757575757575757
              ],
              ">=60": [
                0.16129032258064516,
                0.16666666666666666
              ],
              ">=80": [
                0.1935483870967742,
                0.18181818181818182
              ]
            }
          }
        },
        hasSug: 0.17472118959107807
      },
      TemporaryJump: {
        prior: 0.056666666666666664,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.35294117647058826,
                0.09230769230769231
              ],
              "<20": [
                0,
                0.046153846153846156
              ],
              ">=20": [
                0.11764705882352941,
                0.2153846153846154
              ],
              ">=40": [
                0.17647058823529413,
                0.3384615384615385
              ],
              ">=60": [
                0.058823529411764705,
                0.16923076923076924
              ],
              ">=80": [
                0.29411764705882354,
                0.13846153846153847
              ]
            },
            touchEnd: {
              yes: [
                0.8823529411764706,
                0.26153846153846155
              ],
              no: [
                0.11764705882352941,
                0.7384615384615385
              ]
            },
            lastLength: {
              "<20": [
                0.23529411764705882,
                0.6153846153846154
              ],
              ">=20": [
                0.7647058823529411,
                0.38461538461538464
              ]
            },
            volatility: {
              low: [
                0.4117647058823529,
                0.4153846153846154
              ],
              med: [
                0.5882352941176471,
                0.5538461538461539
              ],
              high: [
                0,
                0.03076923076923077
              ]
            },
            yScale: {
              100: [
                0.47058823529411764,
                0.3076923076923077
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.12307692307692308
              ],
              ">=40": [
                0.17647058823529413,
                0.2
              ],
              ">=60": [
                0.23529411764705882,
                0.12307692307692308
              ],
              ">=80": [
                0.11764705882352941,
                0.24615384615384617
              ]
            }
          }
        },
        hasSug: 0.16607773851590105
      },
      PossibleReversalToRise: {
        prior: 0.013333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.25,
                0.19298245614035087
              ],
              "<20": [
                0.25,
                0.05263157894736842
              ],
              ">=20": [
                0.25,
                0.2631578947368421
              ],
              ">=40": [
                0,
                0.2807017543859649
              ],
              ">=60": [
                0.25,
                0.10526315789473684
              ],
              ">=80": [
                0,
                0.10526315789473684
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                0.75,
                0.3684210526315789
              ],
              ">=20": [
                0.25,
                0.631578947368421
              ]
            },
            volatility: {
              low: [
                0.75,
                0.5087719298245614
              ],
              med: [
                0.25,
                0.45614035087719296
              ],
              high: [
                0,
                0.03508771929824561
              ]
            },
            yScale: {
              100: [
                0,
                0.10526315789473684
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.25,
                0.21052631578947367
              ],
              ">=40": [
                0.5,
                0.3684210526315789
              ],
              ">=60": [
                0.25,
                0.2631578947368421
              ],
              ">=80": [
                0,
                0.05263157894736842
              ]
            }
          }
        },
        hasSug: 0.19256756756756757
      },
      PossibleReversalToFall: {
        prior: 0.02,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                1,
                0.23404255319148937
              ],
              "<20": [
                0,
                0.02127659574468085
              ],
              ">=20": [
                0,
                0.2553191489361702
              ],
              ">=40": [
                0,
                0.2553191489361702
              ],
              ">=60": [
                0,
                0.1276595744680851
              ],
              ">=80": [
                0,
                0.10638297872340426
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                0.8333333333333334,
                0.23404255319148937
              ],
              ">=20": [
                0.16666666666666666,
                0.7659574468085106
              ]
            },
            volatility: {
              low: [
                0.6666666666666666,
                0.48936170212765956
              ],
              med: [
                0.3333333333333333,
                0.5106382978723404
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.16666666666666666,
                0.19148936170212766
              ],
              "<20": [
                0,
                0.02127659574468085
              ],
              ">=20": [
                0,
                0.1702127659574468
              ],
              ">=40": [
                0.6666666666666666,
                0.40425531914893614
              ],
              ">=60": [
                0.16666666666666666,
                0.14893617021276595
              ],
              ">=80": [
                0,
                0.06382978723404255
              ]
            }
          }
        },
        hasSug: 0.1598639455782313
      },
      PossibleEmergingRise: {
        prior: 0.0033333333333333335,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0.7586206896551724
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0
              ],
              ">=40": [
                0,
                0.13793103448275862
              ],
              ">=60": [
                1,
                0.06896551724137931
              ],
              ">=80": [
                0,
                0.034482758620689655
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.06896551724137931
              ],
              ">=20": [
                0,
                0.9310344827586207
              ]
            },
            volatility: {
              low: [
                1,
                0.7241379310344828
              ],
              med: [
                0,
                0.2413793103448276
              ],
              high: [
                0,
                0.034482758620689655
              ]
            },
            yScale: {
              100: [
                0,
                0.3793103448275862
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                1,
                0.10344827586206896
              ],
              ">=40": [
                0,
                0.4482758620689655
              ],
              ">=60": [
                0,
                0.034482758620689655
              ],
              ">=80": [
                0,
                0.034482758620689655
              ]
            }
          }
        },
        hasSug: 0.09698996655518395
      },
      PossibleEmergingFall: {
        prior: 0.006666666666666667,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0.3888888888888889
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.5,
                0.05555555555555555
              ],
              ">=40": [
                0,
                0.2777777777777778
              ],
              ">=60": [
                0,
                0.1111111111111111
              ],
              ">=80": [
                0.5,
                0.16666666666666666
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.2222222222222222
              ],
              ">=20": [
                0,
                0.7777777777777778
              ]
            },
            volatility: {
              low: [
                1,
                0.6666666666666666
              ],
              med: [
                0,
                0.3333333333333333
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0,
                0.1111111111111111
              ],
              "<20": [
                0.5,
                0.1111111111111111
              ],
              ">=20": [
                0.5,
                0.2777777777777778
              ],
              ">=40": [
                0,
                0.2777777777777778
              ],
              ">=60": [
                0,
                0.16666666666666666
              ],
              ">=80": [
                0,
                0.05555555555555555
              ]
            }
          }
        },
        hasSug: 0.06040268456375839
      },
      PossibleRiseToStable: {
        prior: 0.01,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.3333333333333333,
                0.3235294117647059
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.17647058823529413
              ],
              ">=40": [
                0.3333333333333333,
                0.17647058823529413
              ],
              ">=60": [
                0,
                0.20588235294117646
              ],
              ">=80": [
                0.3333333333333333,
                0.11764705882352941
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                0.3333333333333333,
                0.14705882352941177
              ],
              ">=20": [
                0.6666666666666666,
                0.8529411764705882
              ]
            },
            volatility: {
              low: [
                0.6666666666666666,
                0.5294117647058824
              ],
              med: [
                0.3333333333333333,
                0.47058823529411764
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.3333333333333333,
                0.17647058823529413
              ],
              "<20": [
                0,
                0.029411764705882353
              ],
              ">=20": [
                0.3333333333333333,
                0.20588235294117646
              ],
              ">=40": [
                0,
                0.38235294117647056
              ],
              ">=60": [
                0.3333333333333333,
                0.08823529411764706
              ],
              ">=80": [
                0,
                0.11764705882352941
              ]
            }
          }
        },
        hasSug: 0.11447811447811448
      },
      PossibleFallToStable: {
        prior: 0.0033333333333333335,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                1,
                0.4225352112676056
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.028169014084507043
              ],
              ">=40": [
                0,
                0.11267605633802817
              ],
              ">=60": [
                0,
                0.18309859154929578
              ],
              ">=80": [
                0,
                0.2535211267605634
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.04225352112676056
              ],
              ">=20": [
                0,
                0.9577464788732394
              ]
            },
            volatility: {
              low: [
                1,
                0.4084507042253521
              ],
              med: [
                0,
                0.5774647887323944
              ],
              high: [
                0,
                0.014084507042253521
              ]
            },
            yScale: {
              100: [
                1,
                0.2535211267605634
              ],
              "<20": [
                0,
                0.028169014084507043
              ],
              ">=20": [
                0,
                0.19718309859154928
              ],
              ">=40": [
                0,
                0.36619718309859156
              ],
              ">=60": [
                0,
                0.11267605633802817
              ],
              ">=80": [
                0,
                0.04225352112676056
              ]
            }
          }
        },
        hasSug: 0.23745819397993312
      },
      PossibleRebound: {
        prior: 0.043333333333333335,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.23076923076923078,
                0.3333333333333333
              ],
              "<20": [
                0.07692307692307693,
                0
              ],
              ">=20": [
                0.15384615384615385,
                0.06666666666666667
              ],
              ">=40": [
                0.38461538461538464,
                0.23333333333333334
              ],
              ">=60": [
                0.15384615384615385,
                0.16666666666666666
              ],
              ">=80": [
                0,
                0.2
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.23333333333333334
              ],
              ">=20": [
                0,
                0.7666666666666667
              ]
            },
            volatility: {
              low: [
                0.38461538461538464,
                0.5666666666666667
              ],
              med: [
                0.6153846153846154,
                0.43333333333333335
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.15384615384615385,
                0.3
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.07692307692307693,
                0.03333333333333333
              ],
              ">=40": [
                0.15384615384615385,
                0.3333333333333333
              ],
              ">=60": [
                0.46153846153846156,
                0.16666666666666666
              ],
              ">=80": [
                0.15384615384615385,
                0.16666666666666666
              ]
            }
          }
        },
        hasSug: 0.10452961672473868
      },
      PossibleTemporaryJump: {
        prior: 0.016666666666666666,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.2,
                0.4074074074074074
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.2,
                0.037037037037037035
              ],
              ">=40": [
                0,
                0.2222222222222222
              ],
              ">=60": [
                0.4,
                0.07407407407407407
              ],
              ">=80": [
                0.2,
                0.25925925925925924
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.2222222222222222
              ],
              ">=20": [
                0,
                0.7777777777777778
              ]
            },
            volatility: {
              low: [
                0.2,
                0.5185185185185185
              ],
              med: [
                0.8,
                0.48148148148148145
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.4,
                0.5185185185185185
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.037037037037037035
              ],
              ">=40": [
                0.6,
                0.14814814814814814
              ],
              ">=60": [
                0,
                0.14814814814814814
              ],
              ">=80": [
                0,
                0.14814814814814814
              ]
            }
          }
        },
        hasSug: 0.09152542372881356
      }
    }
  }
};
function AG() {
  return Object.keys(WO).sort();
}
function kG(t) {
  return WO[t ?? AG().at(-1)].model;
}
var _G = Object.defineProperty, CG = (t, e, r) => e in t ? _G(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, dk = (t, e, r) => (CG(t, typeof e != "symbol" ? e + "" : e, r), r);
function IG(t) {
  const e = t.points.map((i) => i.y), r = CE(e), n = IE(e);
  return {
    min: {
      value: r,
      labels: fk(t.points, r)
    },
    max: {
      value: n,
      labels: fk(t.points, n)
    },
    range: qO(t),
    mean: Wl(e),
    median: CH(e),
    mode: SH(e)
  };
}
function fk(t, e) {
  return t.filter((r) => r.y === e).map((r) => `${r.x}`);
}
function qO(t) {
  const e = t.points.map((r) => r.y);
  return IE(e) - CE(e);
}
function PG(t, e) {
  return (e.y - t.y) / (e.x - t.x);
}
function ry(t, e, r, n) {
  return n.range === 0 ? 1 : qO(t.slice(e, r)) / n.range;
}
function RG(t, e) {
  const r = Math.min(t.points[e].y, t.points[e + 1].y), n = t.points[e + 1].x - t.points[e].x, i = Math.max(t.points[e].y, t.points[e + 1].y) - r;
  return n * (r + 0.5 * i);
}
function ny(t, e, r, n) {
  if (e >= r)
    return 0;
  const i = t.slice(e, r), s = [];
  for (let A = 0; A < i.points.length; A++)
    s.push([i.points[A].x, i.points[A].y]);
  const o = 1 - wH(s, yH(_E(s))), a = [], l = [], c = i.yBounds().start, p = i.xBounds().start;
  for (let A = 0; A < i.points.length; A++)
    a.push((s[A][0] - p) * (i.points.length - 1) / i.xRange()), l.push((s[A][1] - c) / i.yRange());
  const h = [];
  for (let A = 1; A < s.length - 1; A++)
    h.push(((l[A + 1] - 2 * l[A] + l[A - 1]) / ((a[A] - a[A - 1]) * (a[A + 1] - a[A]))) ** 2);
  const d = h.reduce((A, x) => A + x, 0), b = i.length < 3 ? 0 : Math.atan(d / h.length) * 2 / Math.PI;
  let m = 0;
  for (let A = 0; A < s.length - 2; A++)
    (l[A + 2] - l[A + 1]) * (l[A + 1] - l[A]) < 0 && (m += 1);
  const w = m / (s.length - 2), f = Math.atan(i.length / 20) * 2 / Math.PI, E = [1 / 4, 1, 2, 3 / 4];
  return i.length < 3 ? 0 : (o * E[0] + b * E[1] + w * E[2] + f * E[3]) * i.yRange() / (4 * n.range);
}
function OG(t, e) {
  return t.slice(0, -1).points.map((r, n) => ({
    i: n,
    direction: Math.sign(PG(r, t.points[n + 1])) || 0,
    // convert any -0 to +0
    magnitude: ry(t, n, n + 2, e),
    area: RG(t, n)
  }));
}
function TG(t, e, r) {
  const n = [{ start: 0, direction: r[0].direction }];
  let i = n[0];
  for (let s = 1; s < r.length; s++) {
    const o = r[s].direction;
    o !== i.direction && (i.end = s + 1, i.magnitude = ry(t, i.start, i.end, e), i.volatility = ny(t, i.start, i.end, e), i.area = r.slice(i.start, i.end - 1).reduce((a, l) => a + l.area, 0), i = { start: s, direction: o }, n.push(i));
  }
  return i.end = r.length + 1, i.magnitude = ry(t, i.start, i.end, e), i.volatility = ny(t, i.start, i.end, e), i.area = r.slice(i.start, i.end - 1).reduce((s, o) => s + o.area, 0), n;
}
let LG = class {
  constructor() {
    dk(this, "bd"), dk(this, "mex"), this.bd = new KH(), this.mex = new SG();
  }
  /**
   * Perform all analysis of a time series.
   * @param series - Time series
   * @param opts - Options (optional)
   * @returns Results of the series analysis
   * @remarks
   * The message determination machine learning analysis performed by this 
   * method is now offloaded to a worker thread, so the result can be usefully 
   * obtained asynchronously via a `.then()` callback on the returned promise.
   */
  async analyzeSeries(e, r) {
    const n = IG(e), i = OG(e, n), s = TG(e, n, i), o = async (b, m) => {
      const w = this.bd.getSequences(b, m);
      nG(b, w);
      const { candidates: f, slopeInfo: E } = sG(
        b,
        w,
        r == null ? void 0 : r.candStableAngleCutoff,
        r != null && r.cm2Compat ? 10 : void 0,
        m
      );
      return { msg: await this.mex.chooseMessage(b, f, m, r == null ? void 0 : r.useWorker), seqBounds: w, slopeInfo: E };
    }, { msg: a, seqBounds: l, slopeInfo: c } = await o(e, r == null ? void 0 : r.yAxis), p = a ? a.cand.category : null, h = l.map((b, m) => ({
      start: b.start,
      end: b.end,
      slopeInfo: c[m],
      magnitude: ry(e, b.start, b.end, n),
      volatility: ny(e, b.start, b.end, n),
      area: i.slice(b.start, b.end - 1).reduce((w, f) => w + f.area, 0)
    }));
    if (h.length === 1)
      h[0].message = p, h[0].messageStart = a ? 0 : null, h[0].messageEnd = a ? e.length : null;
    else
      for (const b of h) {
        const { msg: m } = await o(e.slice(b.start, b.end), r == null ? void 0 : r.yAxis);
        m ? (b.message = m.cand.category, b.messageStart = b.start + m.cand.params[0], b.messageEnd = b.start + m.cand.params.at(-1)) : (b.message = null, b.messageStart = null, b.messageEnd = null);
      }
    let d = [];
    if (a) {
      const b = a.cand.params.slice(0, -1);
      d = Array.from(h.keys()).filter(
        (m) => b.includes(h[m].start)
      );
    }
    return {
      stats: n,
      volatility: ny(e, 0, e.length, n),
      area: i.reduce((b, m) => b + m.area, 0),
      message: p,
      messageSeqs: d,
      // will be [] if message === null
      segments: i,
      runs: s,
      sequences: h
    };
  }
};
function pr(t) {
  let e, r, n;
  return e = t, (i, s, o) => {
    if (o.value != null)
      o.value = gk(o.value, e, r, n);
    else if (o.get != null)
      o.get = gk(o.get, e, r, n);
    else
      throw "Only put a Memoize() decorator on a method or get accessor.";
  };
}
const aw = /* @__PURE__ */ new Map();
function gk(t, e, r = 0, n) {
  const i = Symbol("__memoized_map__");
  return function(...s) {
    let o;
    this.hasOwnProperty(i) || Object.defineProperty(this, i, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: /* @__PURE__ */ new Map()
    });
    let a = this[i];
    if (Array.isArray(n))
      for (const l of n)
        aw.has(l) ? aw.get(l).push(a) : aw.set(l, [a]);
    if (e || s.length > 0 || r > 0) {
      let l;
      e === !0 ? l = s.map((h) => h.toString()).join("!") : e ? l = e.apply(this, s) : l = s[0];
      const c = `${l}__timestamp`;
      let p = !1;
      if (r > 0)
        if (!a.has(c))
          p = !0;
        else {
          let h = a.get(c);
          p = Date.now() - h > r;
        }
      a.has(l) && !p ? o = a.get(l) : (o = t.apply(this, s), a.set(l, o), r > 0 && a.set(c, Date.now()));
    } else {
      const l = this;
      a.has(l) ? o = a.get(l) : (o = t.apply(this, s), a.set(l, o));
    }
    return o;
  };
}
var QO = (t) => {
  throw TypeError(t);
}, KO = (t, e, r) => e.has(t) || QO("Cannot " + r), mk = (t, e, r) => (KO(t, e, "read from private field"), r ? r.call(t) : e.get(t)), yk = (t, e, r) => e.has(t) ? QO("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), bk = (t, e, r, n) => (KO(t, e, "write to private field"), e.set(t, r), r);
const iy = "[a-fA-F0-9]", dd = "[a-zA-Z0-9-._~]", Zs = "[!$&'()*+,;=]", Ih = `%${iy}${iy}`, Cm = "(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])", OE = `${Cm}\\.${Cm}\\.${Cm}\\.${Cm}`, Tr = `${iy}{1,4}`, yu = `(?:${Tr}:${Tr}|${OE})`, MG = `(?:(?:${Tr}:){6}${yu}|::(?:${Tr}:){5}${yu}|(?:${Tr})?::(?:${Tr}:){4}${yu}|(?:(?:${Tr}:){0,1}${Tr})?::(?:${Tr}:){3}${yu}|(?:(?:${Tr}:){0,2}${Tr})?::(?:${Tr}:){2}${yu}|(?:(?:${Tr}:){0,3}${Tr})?::(?:${Tr}:){1}${yu}|(?:(?:${Tr}:){0,4}${Tr})?::${yu}|(?:(?:${Tr}:){0,5}${Tr})?::${Tr}|(?:(?:${Tr}:){0,6}${Tr})?::)`, NG = `v${iy}+\\.(?:${dd}|${Zs}|:)+`, YO = `\\[(?:${MG}|${NG})\\]`, fd = "(?<scheme>[a-zA-Z][a-zA-Z0-9-+.]*)", ZO = ":(?<port>\\d*)", DG = `(?:${dd}|${Ih}|${Zs})*?`, $G = `(?<host>${YO}|${OE}|${DG})`, jG = `(?<userinfo>(?:${dd}|${Ih}|${Zs}|:)*)`, TE = `(?:${dd}|${Ih}|${Zs}|:|@)`, JO = `${TE}*?`, XO = `(?:/${JO})*`, LE = `(?<authority>(?:${jG}@)?${$G}(?:${ZO})?)`, ME = `(?<path>${XO})`, NE = `(?<path2>${JO}${XO})`, DE = `(?:\\?(?<query>(?:${TE}|/|\\?)*))?`, eT = `(?:#(?<fragment>(?:${TE}|/|\\?)*))?`, BG = `^${fd}:(?://${LE}${ME}|${NE})${DE}${eT}$`, FG = `^(?:${fd}:|)(?://${LE}${ME}|${NE})${DE}${eT}$`, zG = `^${fd}:(?://${LE}${ME}|${NE})${DE}$`, sg = "[a-zA-Z0-9-._~\\00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF\\u10000-\\u1FFFD\\u20000-\\u2FFFD\\u30000-\\u3FFFD\\u40000-\\u4FFFD\\u50000-\\u5FFFD\\u60000-\\u6FFFD\\u70000-\\u7FFFD\\u80000-\\u8FFFD\\u90000-\\u9FFFD\\uA0000-\\uAFFFD\\uB0000-\\uBFFFD\\uC0000-\\uCFFFD\\uD0000-\\uDFFFD\\uE1000-\\uEFFFD]", VG = "[\\uE000-\\uF8FF\\uF0000-\\uFFFFD\\u100000-\\u10FFFD]", UG = `(?:${sg}|${Ih}|${Zs})*?`, HG = `(?<host>${YO}|${OE}|${UG})`, GG = `(?<userinfo>(?:${sg}|${Ih}|${Zs}|:)*)`, $E = `(?:${sg}|${Ih}|${Zs}|:|@)`, tT = `${$E}*?`, rT = `(?:/${tT})*`, jE = `(?<authority>(?:${GG}@)?${HG}(?:${ZO})?)`, BE = `(?<path>${rT})`, FE = `(?<path2>${tT}${rT})`, zE = `(?:\\?(?<query>(?:${$E}|${VG}|/|\\?)*))?`, nT = `(?:#(?<fragment>(?:${$E}|/|\\?)*))?`, iT = `^${fd}:(?://${jE}${BE}|${FE})${zE}${nT}$`, sT = `^(?:${fd}:|)(?://${jE}${BE}|${FE})${zE}${nT}$`, oT = `^${fd}:(?://${jE}${BE}|${FE})${zE}$`, WG = (t) => (e, r) => {
  const n = (
    /** @type IdentifierComponents */
    t.parseReference(e)
  );
  if (n.scheme === void 0) {
    const i = t.parseAbsolute(r);
    n.scheme = i.scheme, n.authority === void 0 && (n.authority = i.authority, n.path === "" ? (n.path = i.path, n.query === void 0 && (n.query = i.query)) : n.path.startsWith("/") || (n.path = qG(n.path, i)));
  }
  return aT(t, n);
}, qG = (t, e) => {
  if (e.authority && e.path === "")
    return "/" + t;
  {
    const r = e.path.lastIndexOf("/");
    return r === -1 ? t : e.path.slice(0, r + 1) + t;
  }
}, QG = /^\.?\.\/|^\.\.?$/, KG = /^\/\.(?:\/|$)/, YG = /^\/\.\.(?:\/|$)/, ZG = (t) => {
  let e = "";
  for (; t.length > 0; )
    if (QG.test(t))
      t = vk(t);
    else if (KG.test(t))
      t = wk(t);
    else if (YG.test(t))
      t = wk(t), e = JG(e);
    else {
      const r = XG(t);
      t = vk(t), e += r;
    }
  return e;
}, vk = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "" : "/" + t.slice(e + 1);
}, wk = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "/" : "/" + t.slice(e + 1);
}, JG = (t) => {
  const e = t.lastIndexOf("/");
  return e === -1 ? t : t.slice(0, e);
}, XG = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? t : t.slice(0, e);
}, aT = (t, e) => {
  let r = e.scheme.toLowerCase() + ":";
  return r += e.authority === void 0 ? "" : "//" + e.authority.toLowerCase(), r += t.normalizePath(e.path), r += e.query === void 0 ? "" : "?" + t.normalizeQuery(e.query), r += e.fragment === void 0 ? "" : "#" + t.normalizeFragment(e.fragment), r;
}, lT = new RegExp(Ih, "g"), cT = (t) => (e) => {
  const r = parseInt(e.slice(1), 16), n = String.fromCharCode(r);
  return t(n) ? n : e.toUpperCase();
};
RegExp.prototype.test.bind(new RegExp(`${dd}|${Zs}|[:@]`));
const eW = RegExp.prototype.test.bind(new RegExp(`${sg}|${Zs}|[:@]`)), tW = (t) => (e) => ZG(e).replaceAll(lT, cT(t));
RegExp.prototype.test.bind(new RegExp(`${dd}|${Zs}|[:@/?]`));
const xk = RegExp.prototype.test.bind(new RegExp(`${sg}|${Zs}|[:@/?]`)), Ek = (t) => (e) => e.replaceAll(lT, cT(t));
RegExp.prototype.test.bind(new RegExp(BG));
RegExp.prototype.test.bind(new RegExp(FG));
RegExp.prototype.test.bind(new RegExp(zG));
RegExp.prototype.test.bind(new RegExp(iT));
RegExp.prototype.test.bind(new RegExp(sT));
RegExp.prototype.test.bind(new RegExp(oT));
const VE = (t, e) => (r) => {
  const n = t.exec(r);
  if (n === null)
    throw Error(`Invalid ${e}: ${r}`);
  const i = (
    /** @type Record<string, string> */
    n.groups
  );
  return i.authority === void 0 && (i.path = i.path2), delete i.path2, /** @type A */
  i;
}, UE = (
  /** @type Parser<IdentifierComponents> */
  VE(new RegExp(iT), "IRI")
), uT = (
  /** @type Parser<RelativeIdentifierComponents> */
  VE(new RegExp(sT), "IRI-reference")
), rW = (
  /** @type Parser<AbsoluteIdentifierComponents> */
  VE(new RegExp(oT), "absolute-IRI")
), hT = {
  iri: {
    parseAbsolute: rW,
    parseReference: uT,
    parse: UE,
    normalizePath: tW(eW),
    normalizeQuery: Ek(xk),
    normalizeFragment: Ek(xk)
  }
}, nW = (t) => (e) => {
  const r = t.parse(e);
  return delete r.fragment, aT(t, r);
}, Hu = nW(hT.iri), l0 = WG(hT.iri), iW = "", dx = function* (t) {
  if (t.length > 0 && t[0] !== "/")
    throw Error("Invalid JSON Pointer");
  let e = 1, r = 0;
  for (; r < t.length; ) {
    const n = t.indexOf("/", e);
    r = n === -1 ? t.length : n;
    const i = t.slice(e, r);
    e = r + 1, yield aW(i);
  }
}, sW = (t, e = void 0) => {
  if (e === void 0) {
    const r = [...dx(t)];
    return (n) => Sk(r, n);
  } else
    return Sk(dx(t), e);
}, Sk = (t, e) => {
  let r = iW;
  for (const n of t)
    e = cW(e, n, r), r = eh(n, r);
  return e;
}, eh = (t, e) => e + "/" + oW(t), oW = (t) => t.toString().replace(/~/g, "~0").replace(/\//g, "~1"), aW = (t) => t.toString().replace(/~1/g, "/").replace(/~0/g, "~"), lW = (t, e) => Array.isArray(t) && e === "-" ? t.length : e, cW = (t, e, r = "") => {
  if (t === void 0)
    throw TypeError(`Value at '${r}' is undefined and does not have property '${e}'`);
  if (t === null)
    throw TypeError(`Value at '${r}' is null and does not have property '${e}'`);
  if (uW(t))
    throw TypeError(`Value at '${r}' is a ${typeof t} and does not have property '${e}'`);
  {
    const n = lW(t, e);
    return t[n];
  }
}, uW = (t) => t === null || typeof t != "object", pT = (t) => {
  const e = typeof t;
  switch (e) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JSON compatible type: ${r}`);
    }
  }
}, dT = (t) => {
  const e = t.indexOf("#"), r = e === -1 ? t.length : e;
  return t.slice(0, r);
}, fT = (t) => decodeURIComponent(uT(t).fragment || ""), sy = {}, V2 = (t) => {
  if (t.indexOf("#") !== -1) {
    const e = dT(t);
    return { ...sy[e], id: t };
  }
  return sy[t];
}, hW = (t, e) => {
  const r = pW(t, e);
  if (!r)
    throw Error(`Encountered unknown keyword '${t}'`);
  const n = V2(r);
  if (!n)
    throw Error(`Encountered unsupported keyword ${t}. You can provide an implementation for the '${r}' keyword using the 'addKeyword' function.`);
  return n;
}, at = (t) => {
  sy[t.id] = t;
}, fx = {}, pc = (t, e) => {
  fx[t] = e;
}, Uf = {}, gx = {}, lw = {}, pW = (t, e) => {
  var r;
  return ((r = gT(e)) == null ? void 0 : r[t]) || (gx[e] || t.startsWith("x-")) && `https://json-schema.org/keyword/unknown#${t}`;
}, Yr = (t, e) => {
  const r = gT(t);
  for (const n in r)
    if (r[n] === e)
      return n;
}, gT = (t) => {
  if (!(t in Uf))
    throw Error(`Encountered unknown dialect '${t}'`);
  return Uf[t];
}, mT = (t, e, r = !1, n = !0) => {
  gx[t] = r, lw[t] = lw[t] || n, Uf[t] = {}, Object.entries(e).forEach(([i, s]) => {
    if (i in fx)
      Object.entries(fx[i]).forEach(([o, a]) => {
        !(a in sy) && !s && (a = `https://json-schema.org/keyword/unknown#${o}`), Uf[t][o] = a;
      });
    else if (!r || s)
      throw delete Uf[t], delete gx[t], delete lw[t], Error(`Unrecognized vocabulary: ${i}. You can define this vocabulary with the 'defineVocabulary' function.`);
  });
};
var Ak = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function yT(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Im = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var kk;
function dW() {
  if (kk) return Im;
  kk = 1;
  var t = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, e = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, n = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  Im.format = o, Im.parse = a;
  function o(h) {
    if (!h || typeof h != "object")
      throw new TypeError("argument obj is required");
    var d = h.parameters, b = h.type;
    if (!b || !s.test(b))
      throw new TypeError("invalid type");
    var m = b;
    if (d && typeof d == "object")
      for (var w, f = Object.keys(d).sort(), E = 0; E < f.length; E++) {
        if (w = f[E], !r.test(w))
          throw new TypeError("invalid parameter name");
        m += "; " + w + "=" + c(d[w]);
      }
    return m;
  }
  function a(h) {
    if (!h)
      throw new TypeError("argument string is required");
    var d = typeof h == "object" ? l(h) : h;
    if (typeof d != "string")
      throw new TypeError("argument string is required to be a string");
    var b = d.indexOf(";"), m = b !== -1 ? d.slice(0, b).trim() : d.trim();
    if (!s.test(m))
      throw new TypeError("invalid media type");
    var w = new p(m.toLowerCase());
    if (b !== -1) {
      var f, E, A;
      for (t.lastIndex = b; E = t.exec(d); ) {
        if (E.index !== b)
          throw new TypeError("invalid parameter format");
        b += E[0].length, f = E[1].toLowerCase(), A = E[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(n, "$1"))), w.parameters[f] = A;
      }
      if (b !== d.length)
        throw new TypeError("invalid parameter format");
    }
    return w;
  }
  function l(h) {
    var d;
    if (typeof h.getHeader == "function" ? d = h.getHeader("content-type") : typeof h.headers == "object" && (d = h.headers && h.headers["content-type"]), typeof d != "string")
      throw new TypeError("content-type header is missing from object");
    return d;
  }
  function c(h) {
    var d = String(h);
    if (r.test(d))
      return d;
    if (d.length > 0 && !e.test(d))
      throw new TypeError("invalid parameter value");
    return '"' + d.replace(i, "\\$1") + '"';
  }
  function p(h) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = h;
  }
  return Im;
}
var bT = dW();
const fW = /* @__PURE__ */ yT(bT), c0 = {}, vT = (t, e) => {
  c0[t] = e;
}, gW = (t) => {
  const e = t.headers.get("content-type");
  if (e === null)
    throw new xW("The media type of the response could not be determined. Make sure the response includes a 'Content-Type' header.", { cause: t });
  const r = bT.parse(e);
  for (const n in c0)
    if (bW(n, r.type))
      return c0[n].parse(t);
  throw new wW(r.type, `'${r.type}' is not supported. Use the 'addMediaTypePlugin' function to add support for this media type.`, {
    cause: t
  });
}, mW = "A-Za-z", cw = `[!#$%&'*\\-_.^\`|~\\d${mW}]+`, yW = `(?<type>${cw})/(?<subType>${cw}(?:\\+(?<suffix>${cw}))?)`, _k = new RegExp(yW), bW = (t, e) => {
  var r, n;
  if (t === e)
    return !0;
  const i = (r = _k.exec(t)) == null ? void 0 : r.groups;
  if (!i)
    throw Error(`Unable to parse media-range: ${t}`);
  const s = (n = _k.exec(e)) == null ? void 0 : n.groups;
  if (!s)
    throw Error(`Unable to parse media-type: ${e}`);
  return (i.type === s.type || i.type === "*") && (i.subType === s.subType || i.subType === "*" || i.subType === s.suffix);
}, vW = () => {
  let t = "";
  for (const e in c0)
    t = Ck(t, e, c0[e].quality);
  return Ck(t, "*/*", "0.001");
}, Ck = (t, e, r) => (t.length > 0 && (t += ", "), t += e, r && (t += `; q=${r}`), t);
let wW = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.mediaType = e;
  }
}, xW = class extends Error {
  constructor(e = void 0) {
    super(e), this.name = this.constructor.name;
  }
};
const EW = (t, e = void 0) => JSON.parse(t, (r, n) => {
  const i = n !== null && typeof n.$ref == "string" ? new Nu(n.$ref) : n;
  return e ? e(r, i) : i;
});
var p1, d1;
let Nu = class {
  constructor(e, r = void 0) {
    yk(this, p1), yk(this, d1), bk(this, p1, e), bk(this, d1, r ?? { $ref: e });
  }
  get href() {
    return mk(this, p1);
  }
  toJSON() {
    return mk(this, d1);
  }
};
p1 = /* @__PURE__ */ new WeakMap(), d1 = /* @__PURE__ */ new WeakMap();
const wT = (t) => {
  const e = typeof t;
  switch (e) {
    case "bigint":
      return "number";
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (t instanceof Nu)
        return "reference";
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype || Object.getPrototypeOf(t) === null)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JRef compatible type: ${r}`);
    }
  }
}, SW = {
  parse: async (t) => ({
    baseUri: t.url,
    root: EW(await t.text()),
    anchorLocation: AW
  }),
  fileMatcher: (t) => /[^/]\.jref$/.test(t)
}, AW = (t) => decodeURI(t || ""), mx = {}, xT = (t, e) => {
  mx[t] = e;
}, kW = (t, e) => {
  t = l0(t, e);
  const { scheme: r } = UE(t);
  if (!(r in mx))
    throw new _W(r, `The '${r}:' URI scheme is not supported. Use the 'addUriSchemePlugin' function to add support for '${r}:' URIs.`);
  return mx[r].retrieve(t, e);
};
let _W = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.scheme = e;
  }
};
const CW = /* @__PURE__ */ new Set([200, 203]), IW = async (t) => {
  const e = await fetch(t, { headers: { Accept: vW() } });
  if (e.status >= 400)
    throw new Ik(e, `Failed to retrieve '${t}'`);
  if (!CW.has(e.status))
    throw new Ik(e, "Unsupported HTTP response status code");
  return e;
}, ET = { retrieve: IW };
let Ik = class extends Error {
  constructor(e, r = void 0) {
    super(`${e.status} ${e.statusText}${r ? ` -- ${r}` : ""}`), this.name = this.constructor.name, this.response = e;
  }
};
var ST = PW;
function PW(t, e) {
  return function r() {
    e == null && (e = t.length);
    var n = [].slice.call(arguments);
    return n.length >= e ? t.apply(this, n) : function() {
      return r.apply(this, n.concat([].slice.call(arguments)));
    };
  };
}
const RW = () => {
  var t, e;
  return ((e = (t = globalThis.document) == null ? void 0 : t.location) == null ? void 0 : e.toString()) ?? "";
}, U2 = async (t, e = { _cache: {} }) => {
  var r, n, i;
  const s = ((r = e.document) == null ? void 0 : r.baseUri) ?? RW();
  t = l0(t, s);
  const o = Hu(t), { fragment: a } = UE(t), l = e._cache[o] ?? ((i = (n = e.document) == null ? void 0 : n.embedded) == null ? void 0 : i[o]);
  if (l)
    e.document = l, e.uri = t, e.cursor = e.document.anchorLocation(a);
  else {
    try {
      const c = await kW(t, s);
      e.document = await gW(c), e.uri = c.url + (a === void 0 ? "" : `#${a}`), e.cursor = e.document.anchorLocation(a);
    } catch (c) {
      const p = e.uri ? ` Referenced from '${e.uri}'.` : "";
      throw new TW(`Unable to load resource '${t}'.${p}`, c);
    }
    e._cache[o] = e.document;
  }
  return e._value = sW(e.cursor, e.document.root), AT(e);
}, AT = (t) => wT(Ct(t)) === "reference" ? U2(Ct(t).href, t) : t, Ct = (t) => t._value, Oa = (t) => wT(t._value), kT = (t, e) => t in e._value, _T = (t) => t._value.length, qs = ST((t, e) => AT({
  ...e,
  cursor: eh(`${t}`, e.cursor),
  _value: e._value[t]
})), dc = async function* (t) {
  for (let e = 0; e < Ct(t).length; e++)
    yield qs(e, t);
}, yx = function* (t) {
  for (const e in Ct(t))
    yield e;
}, OW = async function* (t) {
  for (const e in Ct(t))
    yield qs(e, t);
}, th = async function* (t) {
  for (const e in Ct(t))
    yield [e, await qs(e, t)];
};
let TW = class extends Error {
  constructor(e, r) {
    super(e, { cause: r }), this.name = this.constructor.name;
  }
};
vT("application/reference+json", SW);
xT("http", ET);
xT("https", ET);
const LW = {
  parse: async (t) => {
    const e = fW.parse(t.headers.get("content-type") ?? ""), r = e.parameters.schema ?? e.parameters.profile;
    return ay(await t.json(), t.url, r);
  },
  fileMatcher: async (t) => /(\.|\/)schema\.json$/.test(t)
}, oy = {}, MW = async (t, e = void 0) => {
  e || (e = { _cache: {} });
  for (const n in oy)
    n in e._cache || (e._cache[n] = oy[n]);
  const r = await U2(t, { ...e });
  if (typeof r.document.dialectId != "string")
    throw Error(`The document at ${r.document.baseUri} is not a schema.`);
  return r;
}, Va = (t, e, r) => {
  t = structuredClone(t);
  const n = ay(t, e, r);
  if (n.baseUri in oy)
    throw Error(`A schema has already been registered for '${n.baseUri}. You can use 'unregisterSchema' to remove the old schema before registering the new one.`);
  if (n.baseUri.startsWith("file:"))
    throw Error(`Registering a schema with a 'file:' URI scheme is not allowed: ${n.baseUri}`);
  oy[n.baseUri] = n;
}, ay = (t, e, r, n = {}) => {
  if (typeof t.$schema == "string" && (r = t.$schema, delete t.$schema), !r)
    throw Error("Unable to determine a dialect for the schema. The dialect can be declared in a number of ways, but the recommended way is to use the '$schema' keyword in your schema.");
  r = Hu(r);
  const i = Yr(r, "https://json-schema.org/keyword/draft-04/id"), s = Yr(r, "https://json-schema.org/keyword/id") || i;
  if (!t[s] && !e)
    throw Error(`Unable to determine an identifier for the schema. Use the '${s}' keyword or pass a retrievalUri when loading the schema.`);
  const o = l0(t[s] ?? "", e ?? "");
  e = Hu(o), i && o.length > e.length ? t[s] = "#" + fT(o) : delete t[s];
  const a = Yr(r, "https://json-schema.org/keyword/vocabulary");
  if (pT(t[a]) === "object") {
    const h = t[a]["https://json-schema.org/draft/2019-09/vocab/core"] || t[a]["https://json-schema.org/draft/2020-12/vocab/core"];
    mT(e, t[a], h, !1), delete t[a];
  }
  const l = { "": "" }, c = {}, p = Yr(r, "https://json-schema.org/keyword/draft-2019-09/recursiveAnchor");
  return t[p] === !0 && (c[""] = `${e}#`), delete t[p], n[e] = {
    baseUri: e,
    dialectId: r,
    root: bx(t, e, r, "", n, l, c),
    anchorLocation: (h) => {
      if (h === void 0)
        return "";
      if (h = decodeURI(h), h[0] === "/")
        return h;
      if (h in l)
        return l[h];
      throw Error(`No such anchor '${e}#${encodeURI(h)}'`);
    },
    anchors: l,
    dynamicAnchors: c,
    embedded: n
  }, n[e];
}, bx = (t, e, r, n, i, s, o) => {
  if (pT(t) === "object") {
    const a = typeof t.$schema == "string" ? Hu(t.$schema) : r, l = Yr(a, "https://json-schema.org/keyword/id");
    if (typeof t[l] == "string") {
      const m = Hu(l0(t[l], e));
      return t[l] = m, i[m] = ay(t, m, a, i), new Nu(m, {});
    }
    const c = Yr(a, "https://json-schema.org/keyword/draft-04/id");
    if (typeof t[c] == "string")
      if (t[c][0] === "#") {
        const m = decodeURIComponent(t[c].slice(1));
        s[m] = n, delete t[c];
      } else {
        const m = Hu(l0(t[c], e));
        return t[c] = m, i[m] = ay(t, m, a, i), new Nu(m, {});
      }
    const p = Yr(r, "https://json-schema.org/keyword/draft-04/ref");
    if (typeof t[p] == "string")
      return new Nu(t[p], t);
    const h = Yr(r, "https://json-schema.org/keyword/anchor");
    typeof t[h] == "string" && (s[t[h]] = n, delete t[h]);
    const d = Yr(r, "https://json-schema.org/keyword/dynamicAnchor");
    typeof t[d] == "string" && (o[t[d]] = `${e}#${encodeURI(n)}`, delete t[d]);
    const b = Yr(r, "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor");
    typeof t[b] == "string" && (o[t[b]] = `${e}#${encodeURI(n)}`, s[t[b]] = n, delete t[b]);
    for (const m in t) {
      const w = Yr(r, "https://json-schema.org/keyword/ref");
      m === w && typeof t[m] == "string" ? t[m] = new Nu(t[m], t[m]) : t[m] = bx(t[m], e, r, eh(m, n), i, s, o);
    }
  } else if (Array.isArray(t))
    for (let a = 0; a < t.length; a++)
      t[a] = bx(t[a], e, r, eh(a, n), i, s, o);
  return t;
}, Fp = (t) => `${t.document.baseUri}#${encodeURI(t.cursor)}`, gd = (
  /** @type API.curry */
  (t) => (...e) => {
    const r = t.length === 1 ? (
      /** @type Extract<typeof fn, (a: any) => any> */
      t(e[0])
    ) : t(e[0], e[1]), n = (
      /** @type I */
      e[t.length]
    );
    return n === void 0 ? r : r(n);
  }
), CT = gd((t) => function* (e) {
  for (const r of e)
    yield t(r);
}), Qn = gd((t) => async function* (e) {
  for await (const r of e)
    yield t(r);
}), IT = gd((t) => function* (e) {
  for (const r of e)
    t(r) && (yield r);
}), NW = gd((t) => function* (e) {
  let r = 0;
  for (const n of e)
    r++ >= t && (yield n);
}), DW = (t) => {
  const e = OT(t).next();
  return e.done ? void 0 : e.value;
}, PT = function* (t, e) {
  for (let r = t; e === void 0; r++)
    yield r;
}, Pk = function* () {
}, HE = function* (t, e) {
  const r = OT(e);
  for (const n of t)
    yield [n, r.next().value];
}, $W = function* (...t) {
  for (const e of t)
    yield* e;
}, RT = (
  /** @type API.reduce */
  gd(
    // eslint-disable-next-line @stylistic/no-extra-parens
    /** @type API.reduce */
    (t, e) => (r) => {
      for (const n of r)
        e = t(
          e,
          /** @type any */
          n
        );
      return e;
    }
  )
), Js = async (t) => {
  const e = [];
  for await (const r of t)
    e.push(r);
  return e;
}, jW = (t) => {
  const e = /* @__PURE__ */ new Set();
  for (const r of t)
    e.add(r);
  return e;
}, vx = async (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  for await (const [r, n] of t)
    e[r] = n;
  return e;
}, BW = gd((t) => (e) => {
  let r = DW(e) ?? "";
  for (const n of e)
    r += t + n;
  return r;
}), OT = (t) => {
  if (typeof (t == null ? void 0 : t[Symbol.iterator]) == "function")
    return t[Symbol.iterator]();
  throw TypeError("`iter` is not iterable");
}, fn = (
  /** @type (acc: any, ...fns: ((a: any) => any)[]) => any */
  (t, ...e) => RT((r, n) => n(r), t, e)
), f1 = (t, e = "", r = "", n = void 0) => {
  const i = typeof t;
  switch (i) {
    case "number":
    case "string":
    case "boolean":
      return mf(e, r, t, i, [], n);
    case "object":
      if (t === null)
        return mf(e, r, t, "null", [], n);
      if (Array.isArray(t)) {
        const s = mf(e, r, t, "array", [], n);
        return s.children = t.map((o, a) => f1(o, e, eh(a, r), s)), s;
      } else if (Object.getPrototypeOf(t) === Object.prototype) {
        const s = mf(e, r, t, "object", [], n);
        return s.children = Object.entries(t).map((o) => {
          const a = eh(o[0], r), l = mf(e, a, void 0, "property", [], s);
          return l.children = o.map((c) => f1(c, e, a, l)), l;
        }), s;
      } else if (t instanceof Nu)
        return f1(t.toJSON(), e, r, n);
    default: {
      const s = i === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : i;
      throw Error(`Not a JSON compatible type: ${s}`);
    }
  }
}, mf = (t, e, r, n, i, s) => {
  const o = {
    baseUri: t ? Hu(t) : "",
    pointer: e,
    value: r,
    type: n,
    children: i,
    parent: s,
    valid: !0,
    errors: {},
    annotations: {}
  };
  return o.root = (s == null ? void 0 : s.root) ?? o, o;
}, FW = (t) => `${t.baseUri}#${encodeURI(t.pointer)}`, Sr = (t) => t.value, Ht = (t) => t.type, zp = (t, e) => t in e.value, Ph = function* (t) {
  t.type === "array" && (yield* t.children);
}, GE = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      yield e.children[0];
}, zW = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children[1] && (yield e.children[1]);
}, fc = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children.length === 2 && (yield e.children);
}, og = (t) => {
  if (t.type === "array")
    return t.children.length;
}, wx = function* (t) {
  switch (yield t, Ht(t)) {
    case "object":
      for (const e of zW(t))
        yield* wx(e);
      break;
    case "array":
      for (const e of Ph(t))
        yield* wx(e);
      break;
  }
}, Op = {};
let VW = 0;
const UW = (t, e) => {
  t in Op || (Op[t] = {});
  const r = `pubsub_subscription_${VW++}`;
  return Op[t][r] = e, r;
}, HW = async (t, e) => {
  const r = [];
  for (const n in Op)
    if (n === t || t.startsWith(`${n}.`))
      for (const i in Op[n])
        r.push(Op[t][i](t, e));
  await Promise.all(r);
};
let TT;
const GW = () => TT, WW = (t) => {
  TT = t;
};
let qW = class extends Error {
  constructor(e) {
    super("Invalid Schema"), this.name = this.constructor.name, this.output = e;
  }
};
const LT = "https://json-schema.org/evaluation/validate", QW = async (t, e) => {
  await HW("validate.metaValidate", t), t.document.baseUri in e.metaData || (e.metaData[t.document.baseUri] = {
    dynamicAnchors: t.document.dynamicAnchors
  });
  const r = Fp(t);
  if (!(r in e)) {
    e[r] = !1;
    const n = Ct(t);
    if (!["object", "boolean"].includes(typeof n))
      throw Error(`No schema found at '${r}'`);
    e[r] = typeof n == "boolean" ? n : await fn(
      th(t),
      Qn(async ([i, s]) => {
        const o = hW(i, t.document.dialectId), a = await o.compile(s, e, t);
        return [o.id, eh(i, Fp(t)), a];
      }),
      Js
    );
  }
  return r;
}, KW = (t, e, r, n, i = !1) => {
  n = { ...r.metaData[dT(t)].dynamicAnchors, ...n };
  let s = !0;
  if (typeof r[t] == "boolean")
    s = r[t];
  else
    for (const [o, a, l] of r[t])
      e.valid = V2(o).interpret(l, e, r, n, i, t), e.valid || (i || (e.errors[a] = o), s = !1);
  return s || (e.errors[t] = LT), e.valid = s, s;
}, YW = /* @__PURE__ */ new Set(), ZW = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedProperties")
      continue;
    const l = V2(o), c = "collectEvaluatedProperties" in l ? l.collectEvaluatedProperties(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && YW;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, JW = /* @__PURE__ */ new Set(), XW = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedItems")
      continue;
    const l = V2(o), c = "collectEvaluatedItems" in l ? l.collectEvaluatedItems(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && JW;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, He = { id: LT, compile: QW, interpret: KW, collectEvaluatedProperties: ZW, collectEvaluatedItems: XW }, ly = {}, eq = (t, e) => {
  if (e in ly)
    return ly[e](t);
  throw Error(`The '${e}' error format is not supported`);
};
ly.FLAG = (t) => ({ valid: t.valid });
ly.BASIC = (t) => {
  const e = {
    valid: t.valid
  };
  if (!t.valid) {
    e.errors = [];
    for (const r of wx(t))
      for (const [n, i] of Object.entries(r.errors).reverse())
        i !== "https://json-schema.org/evaluation/validate" && !r.valid && e.errors.unshift({
          keyword: i,
          absoluteKeywordLocation: n,
          instanceLocation: FW(r),
          valid: r.valid
        });
  }
  return e;
};
const MT = "FLAG";
WW(MT);
const tq = async (t) => {
  const e = { metaData: {} }, r = await He.compile(t, e);
  return { ast: e, schemaUri: r };
}, rq = ST(({ ast: t, schemaUri: e }, r, n = MT) => (He.interpret(e, r, t, {}), eq(r, n))), uw = {};
UW("validate.metaValidate", async (t, e) => {
  if (!e.document.validated) {
    if (e.document.validated = !0, !(e.document.dialectId in uw)) {
      const i = await MW(e.document.dialectId, e), s = await tq(i);
      uw[e.document.dialectId] = rq(s);
    }
    const r = f1(e.document.root, e.document.baseUri), n = uw[e.document.dialectId](r, GW());
    if (!n.valid)
      throw new qW(n);
  }
});
const nq = "https://json-schema.org/keyword/additionalProperties", iq = async (t, e, r) => {
  const n = Yr(t.document.dialectId, "https://json-schema.org/keyword/properties"), i = await qs(n, r), s = Oa(i) === "object" ? CT((p) => "^" + sq(p) + "$", yx(i)) : Pk(), o = Yr(t.document.dialectId, "https://json-schema.org/keyword/patternProperties"), a = await qs(o, r), l = Oa(a) === "object" ? yx(a) : Pk(), c = fn(
    $W(s, l),
    BW("|")
  ) || "(?!)";
  return [new RegExp(c, "u"), await He.compile(t, e)];
}, sq = (t) => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), oq = ([t, e], r, n, i, s) => {
  if (Ht(r) !== "object")
    return !0;
  let o = !0;
  for (const [a, l] of fc(r)) {
    const c = Sr(a);
    !t.test(c) && !He.interpret(e, l, n, i, s) && (o = !1);
  }
  return o;
}, aq = ([t, e], r, n, i) => {
  if (Ht(r) !== "object")
    return !0;
  const s = /* @__PURE__ */ new Set();
  for (const [o, a] of fc(r)) {
    const l = Sr(o);
    if (!t.test(l)) {
      if (!He.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, lq = { id: nq, compile: iq, interpret: oq, collectEvaluatedProperties: aq }, cq = "https://json-schema.org/keyword/allOf", uq = (t, e) => fn(
  dc(t),
  Qn((r) => He.compile(r, e)),
  Js
), hq = (t, e, r, n, i) => {
  let s = !0;
  for (const o of t)
    He.interpret(o, e, r, n, i) || (s = !1);
  return s;
}, pq = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = He.collectEvaluatedProperties(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, dq = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = He.collectEvaluatedItems(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, fq = { id: cq, compile: uq, interpret: hq, collectEvaluatedProperties: pq, collectEvaluatedItems: dq }, gq = { id: "https://json-schema.org/keyword/anchor" }, mq = "https://json-schema.org/keyword/anyOf", yq = (t, e) => fn(
  dc(t),
  Qn((r) => He.compile(r, e)),
  Js
), bq = (t, e, r, n, i) => t.filter((s) => He.interpret(s, e, r, n, i)).length > 0, vq = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = He.collectEvaluatedProperties(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, wq = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = He.collectEvaluatedItems(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, xq = { id: mq, compile: yq, interpret: bq, collectEvaluatedProperties: vq, collectEvaluatedItems: wq }, Eq = "https://json-schema.org/keyword/conditional", Sq = (t, e) => fn(
  dc(t),
  NT,
  Qn((r) => He.compile(r, e)),
  Js
), Aq = (t, e, r, n, i) => {
  for (let s = 0; s < t.length; s += 2) {
    const o = He.interpret(t[s], e, r, n, i);
    if (s + 1 === t.length)
      return o;
    if (o)
      return He.interpret(t[s + 1], e, r, n, i);
  }
  return !0;
}, kq = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = He.collectEvaluatedProperties(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return He.collectEvaluatedProperties(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, _q = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = He.collectEvaluatedItems(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return He.collectEvaluatedItems(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, NT = async function* (t, e = 1) {
  for await (const r of t)
    e > 0 && Oa(r) === "array" ? yield* NT(dc(r), e - 1) : yield r;
}, Cq = { id: Eq, compile: Sq, interpret: Aq, collectEvaluatedProperties: kq, collectEvaluatedItems: _q };
var Rk, Ok;
function Iq() {
  return Ok || (Ok = 1, Rk = {
    space: "",
    cycles: !1,
    replacer: (t, e) => e,
    stringify: JSON.stringify
  }), Rk;
}
var Tk, Lk;
function bu() {
  return Lk || (Lk = 1, Tk = {
    isArray: Array.isArray,
    assign: Object.assign,
    isObject: (t) => typeof t == "object",
    isFunction: (t) => typeof t == "function",
    isBoolean: (t) => typeof t == "boolean",
    isRegex: (t) => t instanceof RegExp,
    keys: Object.keys
  }), Tk;
}
var hw, Mk;
function Pq() {
  if (Mk) return hw;
  Mk = 1;
  const t = Iq(), e = bu().isFunction, r = bu().isBoolean, n = bu().isObject, i = bu().isArray, s = bu().isRegex, o = bu().assign, a = bu().keys;
  function l(p) {
    return p == null ? p : s(p) ? p.toString() : p.toJSON ? p.toJSON() : p;
  }
  function c(p, h) {
    h = h || o({}, t), e(h) && (h = { compare: h });
    const d = h.space || t.space, b = r(h.cycles) ? h.cycles : t.cycles, m = h.replacer || t.replacer, w = h.stringify || t.stringify, f = h.compare && /* @__PURE__ */ function(A) {
      return function(x) {
        return function(g, v) {
          const k = { key: g, value: x[g] }, S = { key: v, value: x[v] };
          return A(k, S);
        };
      };
    }(h.compare);
    b || w(p);
    const E = [];
    return function A(x, g, v, k) {
      const S = d ? `
` + new Array(k + 1).join(d) : "", R = d ? ": " : ":";
      if (v = l(v), v = m.call(x, g, v), v !== void 0) {
        if (!n(v) || v === null) return w(v);
        if (i(v)) {
          const L = [];
          for (let F = 0; F < v.length; F++) {
            const z = A(v, F, v[F], k + 1) || w(null);
            L.push(S + d + z);
          }
          return "[" + L.join(",") + S + "]";
        } else {
          if (b) {
            if (E.indexOf(v) !== -1)
              return w("[Circular]");
            E.push(v);
          }
          const L = a(v).sort(f && f(v)), F = [];
          for (let z = 0; z < L.length; z++) {
            const j = L[z], ee = A(v, j, v[j], k + 1);
            if (!ee) continue;
            const X = w(j) + R + ee;
            F.push(S + d + X);
          }
          return E.splice(E.indexOf(v), 1), "{" + F.join(",") + S + "}";
        }
      }
    }({ "": p }, "", p, 0);
  }
  return hw = c, hw;
}
var Rq = Pq();
const ag = /* @__PURE__ */ yT(Rq), Oq = "https://json-schema.org/keyword/const", Tq = (t) => ag(Ct(t)), Lq = (t, e) => ag(Sr(e)) === t, Mq = { id: Oq, compile: Tq, interpret: Lq }, Nq = "https://json-schema.org/keyword/contains", Dq = async (t, e, r) => {
  const n = await He.compile(t, e), i = Yr(t.document.dialectId, "https://json-schema.org/keyword/minContains"), s = await qs(i, r), o = Oa(s) === "number" ? Ct(s) : 1, a = Yr(t.document.dialectId, "https://json-schema.org/keyword/maxContains"), l = await qs(a, r), c = Oa(l) === "number" ? Ct(l) : Number.MAX_SAFE_INTEGER;
  return { contains: n, minContains: o, maxContains: c };
}, DT = ({ contains: t, minContains: e, maxContains: r }, n, i, s, o) => {
  const a = Ht(n) !== "array" || fn(
    Ph(n),
    IT((l) => He.interpret(t, l, i, s, o)),
    RT((l) => l + 1, 0)
  );
  return a >= e && a <= r;
}, $q = (t, e, r, n) => DT(t, e, r, n, !0) && Ht(e) === "array" && fn(
  HE(Ph(e), PT(0)),
  IT(([i]) => He.interpret(t.contains, i, r, n, !0)),
  CT(([, i]) => i),
  jW
), jq = { id: Nq, compile: Dq, interpret: DT, collectEvaluatedItems: $q }, Bq = "https://json-schema.org/keyword/comment", Fq = () => {
}, zq = () => !0, Vq = { id: Bq, compile: Fq, interpret: zq }, As = (t, e, r, n) => {
  e in t.annotations || (t.annotations[e] = {}), t.annotations[e][r] = n;
}, $T = "https://json-schema.org/keyword/contentEncoding", Uq = (t) => Ct(t), Hq = (t, e, r, n, i, s) => (As(e, $T, s, t), !0), Gq = { id: $T, compile: Uq, interpret: Hq }, jT = "https://json-schema.org/keyword/contentMediaType", Wq = (t) => Ct(t), qq = (t, e, r, n, i, s) => (As(e, jT, s, t), !0), Qq = { id: jT, compile: Wq, interpret: qq }, BT = "https://json-schema.org/keyword/contentSchema", Kq = (t) => Fp(t), Yq = (t, e, r, n, i, s) => (As(e, BT, s, t), !0), Zq = { id: BT, compile: Kq, interpret: Yq }, FT = "https://json-schema.org/keyword/default", Jq = (t) => Ct(t), Xq = (t, e, r, n, i, s) => (As(e, FT, s, t), !0), eQ = { id: FT, compile: Jq, interpret: Xq }, tQ = "https://json-schema.org/keyword/definitions", rQ = (t, e) => fn(
  OW(t),
  Qn((r) => He.compile(r, e)),
  Js
), nQ = () => !0, iQ = { id: tQ, compile: rQ, interpret: nQ }, sQ = "https://json-schema.org/keyword/dependentRequired", oQ = (t) => fn(
  th(t),
  Qn(([e, r]) => [e, Ct(r)]),
  Js
), aQ = (t, e) => {
  if (Ht(e) !== "object")
    return !0;
  let r = !0;
  for (const [n, i] of t)
    zp(n, e) && !i.every((s) => zp(s, e)) && (r = !1);
  return r;
}, lQ = { id: sQ, compile: oQ, interpret: aQ }, cQ = "https://json-schema.org/keyword/dependentSchemas", uQ = (t, e) => fn(
  th(t),
  Qn(async ([r, n]) => [r, await He.compile(n, e)]),
  Js
), hQ = (t, e, r, n, i) => {
  if (Ht(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    zp(o, e) && !He.interpret(a, e, r, n, i) && (s = !1);
  return s;
}, pQ = (t, e, r, n) => {
  if (Ht(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    if (zp(s, e)) {
      const a = He.collectEvaluatedProperties(o, e, r, n);
      if (a === !1)
        return !1;
      a.forEach(Set.prototype.add.bind(i));
    }
  return i;
}, dQ = { id: cQ, compile: uQ, interpret: hQ, collectEvaluatedProperties: pQ }, zT = "https://json-schema.org/keyword/deprecated", fQ = (t) => Ct(t), gQ = (t, e, r, n, i, s) => (As(e, zT, s, t), !0), mQ = { id: zT, compile: fQ, interpret: gQ }, VT = "https://json-schema.org/keyword/description", yQ = (t) => Ct(t), bQ = (t, e, r, n, i, s) => (As(e, VT, s, t), !0), vQ = { id: VT, compile: yQ, interpret: bQ }, wQ = { id: "https://json-schema.org/keyword/dynamicAnchor" }, xQ = "https://json-schema.org/keyword/dynamicRef", EQ = async (t, e) => {
  const r = Ct(t), n = await U2(t.document.baseUri, t);
  return await He.compile(n, e), r;
}, WE = (t, e, r, n, i, s) => {
  if (!(e in i))
    throw Error(`No dynamic anchor found for "${e}"`);
  return t(i[e], r, n, i, s);
}, SQ = (...t) => WE(He.interpret, ...t), AQ = (...t) => WE(He.collectEvaluatedProperties, ...t), kQ = (...t) => WE(He.collectEvaluatedItems, ...t), _Q = { id: xQ, compile: EQ, interpret: SQ, collectEvaluatedProperties: AQ, collectEvaluatedItems: kQ }, CQ = "https://json-schema.org/keyword/else", IQ = async (t, e, r) => {
  const n = Yr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (kT(n, r)) {
    const i = await qs(n, r);
    return [await He.compile(i, e), await He.compile(t, e)];
  } else
    return [];
}, PQ = ([t, e], r, n, i, s) => t === void 0 || He.interpret(t, r, n, i, !0) || He.interpret(e, r, n, i, s), RQ = ([t, e], r, n, i) => t === void 0 || He.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : He.collectEvaluatedProperties(e, r, n, i), OQ = ([t, e], r, n, i) => t === void 0 || He.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : He.collectEvaluatedItems(e, r, n, i), TQ = { id: CQ, compile: IQ, interpret: PQ, collectEvaluatedProperties: RQ, collectEvaluatedItems: OQ }, LQ = "https://json-schema.org/keyword/enum", MQ = (t) => fn(
  dc(t),
  Qn(Ct),
  Qn(ag),
  Js
), NQ = (t, e) => {
  const r = ag(Sr(e));
  return t.some((n) => r === n);
}, DQ = { id: LQ, compile: MQ, interpret: NQ }, UT = "https://json-schema.org/keyword/examples", $Q = (t) => Ct(t), jQ = (t, e, r, n, i, s) => (As(e, UT, s, t), !0), BQ = { id: UT, compile: $Q, interpret: jQ }, FQ = "https://json-schema.org/keyword/exclusiveMaximum", zQ = (t) => Ct(t), VQ = (t, e) => Ht(e) !== "number" || Sr(e) < t, UQ = { id: FQ, compile: zQ, interpret: VQ }, HQ = "https://json-schema.org/keyword/exclusiveMinimum", GQ = (t) => Ct(t), WQ = (t, e) => Ht(e) !== "number" || Sr(e) > t, qQ = { id: HQ, compile: GQ, interpret: WQ }, HT = "https://json-schema.org/keyword/format", QQ = (t) => Ct(t), KQ = (t, e, r, n, i, s) => (As(e, HT, s, t), !0), YQ = { id: HT, compile: QQ, interpret: KQ }, ZQ = { id: "https://json-schema.org/keyword/id" }, JQ = "https://json-schema.org/keyword/if", XQ = (t, e) => He.compile(t, e), eK = (t, e, r, n) => (He.interpret(t, e, r, n, !0), !0), tK = (t, e, r, n) => He.collectEvaluatedProperties(t, e, r, n) || [], rK = (t, e, r, n) => He.collectEvaluatedItems(t, e, r, n) || /* @__PURE__ */ new Set(), nK = { id: JQ, compile: XQ, interpret: eK, collectEvaluatedProperties: tK, collectEvaluatedItems: rK }, iK = () => {
  const t = cs(!1), e = cs(!0);
  return _n(t, e), { start: t, end: e };
}, sK = (t) => {
  const e = cs(!1), r = cs(!0);
  return hK(e, r, t), { start: e, end: r };
}, oK = (t, e) => t === void 0 ? e : (_n(t.end, e.start), t.end.isEnd = !1, { start: t.start, end: e.end }), aK = (t, e) => {
  const r = cs(!1);
  _n(r, t.start), _n(r, e.start);
  const n = cs(!0);
  return _n(t.end, n), t.end.isEnd = !1, _n(e.end, n), e.end.isEnd = !1, { start: r, end: n };
}, lK = (t) => {
  const e = cs(!1), r = cs(!0);
  return _n(e, r), _n(e, t.start), _n(t.end, r), _n(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, cK = (t) => {
  const e = cs(!1), r = cs(!0);
  return _n(e, r), _n(e, t.start), _n(t.end, r), t.end.isEnd = !1, { start: e, end: r };
}, uK = (t) => {
  const e = cs(!1), r = cs(!0);
  return _n(e, t.start), _n(t.end, r), _n(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, _n = (t, e) => {
  t.epsilonTransitions.push(e);
}, hK = (t, e, r) => {
  t.transition[r] = e;
}, cs = (t) => ({
  isEnd: t,
  transition: {},
  epsilonTransitions: []
}), pK = "https://json-schema.org/keyword/itemPattern", GT = async (t, e) => {
  const r = [[]];
  let n = r[0];
  for await (const i of dc(t))
    if (Oa(i) === "string") {
      const s = Ct(i);
      if (s === "*")
        n.push(lK(n.pop()));
      else if (s === "?")
        n.push(cK(n.pop()));
      else if (s === "+")
        n.push(uK(n.pop()));
      else if (s === "|")
        n = [], r.push(n);
      else
        throw Error(`Unsupported pattern syntax: ${s}`);
    } else {
      const s = Oa(i) === "array" ? GT(i, e) : sK(await He.compile(i, e));
      n.push(await s);
    }
  return _T(t) === 0 ? iK() : r.map((i) => i.reduce(oK)).reduce(aK);
}, qE = (t) => (e, r, n, i, s) => {
  if (Ht(r) !== "array")
    return !0;
  let o = [];
  xx(e.start, o, []);
  for (const a of Ph(r)) {
    const l = [];
    for (const c of o) {
      const p = dK(t, c.transition, a, n, i, s);
      p && xx(p, l, []);
    }
    o = l;
  }
  return !!o.find((a) => a.isEnd);
}, xx = (t, e, r) => {
  if (t.epsilonTransitions.length)
    for (const n of t.epsilonTransitions)
      r.find((i) => i === n) || (r.push(n), xx(n, e, r));
  else
    e.push(t);
}, dK = (t, e, r, n, i, s) => {
  for (const o in e)
    if (t(o, r, n, i, s))
      return e[o];
}, fK = qE(He.interpret), gK = qE(He.collectEvaluatedProperties), mK = qE(He.collectEvaluatedItems), yK = { id: pK, compile: GT, interpret: fK, collectEvalatedProperties: gK, collectEvalatedItems: mK }, bK = "https://json-schema.org/keyword/items", vK = async (t, e, r) => {
  const n = Yr(t.document.dialectId, "https://json-schema.org/keyword/prefixItems"), i = await qs(n, r);
  return [Oa(i) === "array" ? _T(i) : 0, await He.compile(t, e)];
}, WT = ([t, e], r, n, i, s) => {
  if (Ht(r) !== "array")
    return !0;
  let o = !0;
  for (const a of NW(t, Ph(r)))
    He.interpret(e, a, n, i, s) || (o = !1);
  return o;
}, wK = (t, e, r, n) => {
  if (!WT(t, e, r, n, !0))
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (let s = t[0]; s < og(e); s++)
    i.add(s);
  return i;
}, xK = { id: bK, compile: vK, interpret: WT, collectEvaluatedItems: wK }, EK = "https://json-schema.org/keyword/maxContains", SK = (t) => Ct(t), AK = () => !0, kK = { id: EK, compile: SK, interpret: AK }, _K = "https://json-schema.org/keyword/maxItems", CK = (t) => Ct(t), IK = (t, e) => Ht(e) !== "array" || og(e) <= t, PK = { id: _K, compile: CK, interpret: IK }, RK = "https://json-schema.org/keyword/maxLength", OK = (t) => Ct(t), TK = (t, e) => Ht(e) !== "string" || [...Sr(e)].length <= t, LK = { id: RK, compile: OK, interpret: TK }, MK = "https://json-schema.org/keyword/maxProperties", NK = (t) => Ct(t), DK = (t, e) => Ht(e) !== "object" || [...GE(e)].length <= t, $K = { id: MK, compile: NK, interpret: DK }, jK = "https://json-schema.org/keyword/maximum", BK = (t) => Ct(t), FK = (t, e) => Ht(e) !== "number" || Sr(e) <= t, zK = { id: jK, compile: BK, interpret: FK }, VK = "https://json-schema.org/keyword/minContains", UK = (t) => Ct(t), HK = () => !0, GK = { id: VK, compile: UK, interpret: HK }, WK = "https://json-schema.org/keyword/minItems", qK = (t) => Ct(t), QK = (t, e) => Ht(e) !== "array" || og(e) >= t, KK = { id: WK, compile: qK, interpret: QK }, YK = "https://json-schema.org/keyword/minLength", ZK = (t) => Ct(t), JK = (t, e) => Ht(e) !== "string" || [...Sr(e)].length >= t, XK = { id: YK, compile: ZK, interpret: JK }, eY = "https://json-schema.org/keyword/minProperties", tY = (t) => Ct(t), rY = (t, e) => Ht(e) !== "object" || [...GE(e)].length >= t, nY = { id: eY, compile: tY, interpret: rY }, iY = "https://json-schema.org/keyword/minimum", sY = (t) => Ct(t), oY = (t, e) => Ht(e) !== "number" || Sr(e) >= t, aY = { id: iY, compile: sY, interpret: oY }, lY = "https://json-schema.org/keyword/multipleOf", cY = (t) => Ct(t), uY = (t, e) => {
  if (Ht(e) !== "number")
    return !0;
  const r = Sr(e) % t;
  return Nk(0, r) || Nk(t, r);
}, Nk = (t, e) => Math.abs(t - e) < 11920929e-14, hY = { id: lY, compile: cY, interpret: uY }, pY = "https://json-schema.org/keyword/not", dY = (...t) => He.compile(...t), fY = (...t) => !He.interpret(...t), gY = { id: pY, compile: dY, interpret: fY }, mY = "https://json-schema.org/keyword/oneOf", yY = (t, e) => fn(
  dc(t),
  Qn((r) => He.compile(r, e)),
  Js
), bY = (t, e, r, n, i) => {
  let s = 0;
  for (const o of t)
    He.interpret(o, e, r, n, i) && s++;
  return s === 1;
}, vY = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = He.collectEvaluatedProperties(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, wY = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = He.collectEvaluatedItems(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, xY = { id: mY, compile: yY, interpret: bY, collectEvaluatedProperties: vY, collectEvaluatedItems: wY }, EY = "https://json-schema.org/keyword/pattern", SY = (t) => new RegExp(Ct(t), "u"), AY = (t, e) => Ht(e) !== "string" || t.test(Sr(e)), kY = { id: EY, compile: SY, interpret: AY }, _Y = "https://json-schema.org/keyword/patternProperties", CY = (t, e) => fn(
  th(t),
  Qn(async ([r, n]) => [
    new RegExp(r, "u"),
    await He.compile(n, e)
  ]),
  Js
), IY = (t, e, r, n, i) => {
  if (Ht(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    for (const [l, c] of fc(e)) {
      const p = Sr(l);
      o.test(p) && !He.interpret(a, c, r, n, i) && (s = !1);
    }
  return s;
}, PY = (t, e, r, n) => {
  if (Ht(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    for (const [a, l] of fc(e)) {
      const c = Sr(a);
      if (s.test(c)) {
        if (!He.interpret(o, l, r, n, !0))
          return !1;
        i.add(c);
      }
    }
  return i;
}, RY = { id: _Y, compile: CY, interpret: IY, collectEvaluatedProperties: PY }, OY = "https://json-schema.org/keyword/prefixItems", TY = (t, e) => fn(
  dc(t),
  Qn((r) => He.compile(r, e)),
  Js
), qT = (t, e, r, n, i) => {
  if (Ht(e) !== "array")
    return !0;
  let s = !0, o = 0;
  const a = og(e);
  for (const [l, c] of HE(t, Ph(e))) {
    if (o >= a)
      break;
    He.interpret(l, c, r, n, i) || (s = !1), o++;
  }
  return s;
}, LY = (t, e, r, n) => qT(t, e, r, n, !0) && new Set(t.map((i, s) => s)), MY = { id: OY, compile: TY, interpret: qT, collectEvaluatedItems: LY }, NY = "https://json-schema.org/keyword/properties", DY = (t, e) => fn(
  th(t),
  Qn(async ([r, n]) => [r, await He.compile(n, e)]),
  vx
), $Y = (t, e, r, n, i) => {
  if (Ht(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of fc(e)) {
    const l = Sr(o);
    l in t && !He.interpret(t[l], a, r, n, i) && (s = !1);
  }
  return s;
}, jY = (t, e, r, n) => {
  if (Ht(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of fc(e)) {
    const a = Sr(s);
    if (a in t) {
      if (!He.interpret(t[a], o, r, n, !0))
        return !1;
      i.add(a);
    }
  }
  return i;
}, BY = { id: NY, compile: DY, interpret: $Y, collectEvaluatedProperties: jY }, FY = "https://json-schema.org/keyword/propertyDependencies", zY = (t, e) => fn(
  th(t),
  Qn(async ([r, n]) => [r, await fn(
    th(n),
    Qn(async ([i, s]) => [i, await He.compile(s, e)]),
    vx
  )]),
  vx
), VY = (t, e, r, n, i) => {
  if (Ht(e) !== "object")
    return !0;
  let s = !0;
  const o = Sr(e);
  for (const [a, l] of Object.entries(t)) {
    const c = o[a];
    zp(a, e) && c in l && !He.interpret(l[c], e, r, n, i) && (s = !1);
  }
  return s;
}, UY = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s in t) {
    const o = Sr(e)[s], a = t[s];
    if (zp(s, e) && o in a) {
      const l = He.collectEvaluatedProperties(a[o], e, r, n);
      if (!l)
        return !1;
      l.forEach(i.add, i);
    }
  }
  return i;
}, HY = { id: FY, compile: zY, interpret: VY, collectEvaluatedProperties: UY }, GY = "https://json-schema.org/keyword/propertyNames", WY = (t, e) => He.compile(t, e), qY = (t, e, r, n) => {
  if (Ht(e) !== "object")
    return !0;
  let i = !0;
  for (const s of GE(e))
    He.interpret(t, s, r, n, !0) || (i = !1);
  return i;
}, QY = { id: GY, compile: WY, interpret: qY }, QT = "https://json-schema.org/keyword/readOnly", KY = (t) => Ct(t), YY = (t, e, r, n, i, s) => (As(e, QT, s, t), !0), ZY = { id: QT, compile: KY, interpret: YY }, JY = "https://json-schema.org/keyword/ref", XY = (...t) => He.compile(...t), eZ = (...t) => He.interpret(...t), tZ = (...t) => He.collectEvaluatedProperties(...t), rZ = (...t) => He.collectEvaluatedItems(...t), nZ = { id: JY, compile: XY, interpret: eZ, collectEvaluatedProperties: tZ, collectEvaluatedItems: rZ }, iZ = "https://json-schema.org/keyword/requireAllExcept", sZ = async (t, e, r) => {
  const n = await Ct(t), i = Yr(t.document.dialectId, "https://json-schema.org/keyword/properties"), s = await qs(i, r), o = Oa(s) === "object" ? yx(s) : [], a = new Set(o);
  return n.forEach((l) => o.remove(l)), [...a];
}, oZ = (t, e) => Ht(e) !== "object" || t.every((r) => Object.hasOwn(Sr(e), r)), aZ = { id: iZ, compile: sZ, interpret: oZ }, lZ = "https://json-schema.org/keyword/required", cZ = (t) => Ct(t), uZ = (t, e) => Ht(e) !== "object" || t.every((r) => Object.hasOwn(Sr(e), r)), hZ = { id: lZ, compile: cZ, interpret: uZ }, KT = "https://json-schema.org/keyword/title", pZ = (t) => Ct(t), dZ = (t, e, r, n, i, s) => (As(e, KT, s, t), !0), fZ = { id: KT, compile: pZ, interpret: dZ }, gZ = "https://json-schema.org/keyword/then", mZ = async (t, e, r) => {
  const n = Yr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (kT(n, r)) {
    const i = await qs(n, r);
    return [await He.compile(i, e), await He.compile(t, e)];
  } else
    return [];
}, yZ = ([t, e], r, n, i, s) => t === void 0 || !He.interpret(t, r, n, i, !0) || He.interpret(e, r, n, i, s), bZ = ([t, e], r, n, i) => t === void 0 || !He.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : He.collectEvaluatedProperties(e, r, n, i), vZ = ([t, e], r, n, i) => t === void 0 || !He.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : He.collectEvaluatedItems(e, r, n, i), wZ = { id: gZ, compile: mZ, interpret: yZ, collectEvaluatedProperties: bZ, collectEvaluatedItems: vZ }, xZ = "https://json-schema.org/keyword/type", EZ = (t) => Ct(t), SZ = (t, e) => typeof t == "string" ? Dk(e)(t) : t.some(Dk(e)), Dk = (t) => (e) => e === "integer" ? Ht(t) === "number" && Number.isInteger(Sr(t)) : Ht(t) === e, AZ = { id: xZ, compile: EZ, interpret: SZ }, kZ = "https://json-schema.org/keyword/unevaluatedItems", _Z = async (t, e, r) => [Fp(r), await He.compile(t, e)], CZ = ([t, e], r, n, i, s) => {
  if (Ht(r) !== "array")
    return !0;
  const o = He.collectEvaluatedItems(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of HE(Ph(r), PT(0)))
    !o.has(c) && !He.interpret(e, l, n, i, s) && (a = !1);
  return a;
}, IZ = (t, e, r, n) => {
  const i = He.collectEvaluatedItems(t[0], e, r, n, !0);
  if (!i)
    return !1;
  const s = /* @__PURE__ */ new Set();
  for (let o = 0; o < og(e); o++)
    i.has(o) || s.add(o);
  return s;
}, PZ = { id: kZ, compile: _Z, interpret: CZ, collectEvaluatedItems: IZ }, RZ = "https://json-schema.org/keyword/unevaluatedProperties", OZ = async (t, e, r) => [Fp(r), await He.compile(t, e)], TZ = ([t, e], r, n, i, s) => {
  if (Ht(r) !== "object")
    return !0;
  const o = He.collectEvaluatedProperties(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of fc(r)) {
    const p = Sr(l);
    !o.has(p) && !He.interpret(e, c, n, i, s) && (a = !1);
  }
  return a;
}, LZ = ([t, e], r, n, i) => {
  if (Ht(r) !== "object")
    return !0;
  const s = He.collectEvaluatedProperties(t, r, n, i, !0);
  if (!s)
    return !1;
  for (const [o, a] of fc(r)) {
    const l = Sr(o);
    if (!s.has(l)) {
      if (!He.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, MZ = { id: RZ, compile: OZ, interpret: TZ, collectEvaluatedProperties: LZ }, NZ = "https://json-schema.org/keyword/uniqueItems", DZ = (t) => Ct(t), $Z = (t, e) => {
  if (Ht(e) !== "array" || t === !1)
    return !0;
  const r = Sr(e).map(ag);
  return new Set(r).size === r.length;
}, jZ = { id: NZ, compile: DZ, interpret: $Z }, YT = "https://json-schema.org/keyword/unknown", BZ = (t) => [[...dx(t.cursor)].pop(), Ct(t)], FZ = ([t, e], r, n, i, s, o) => {
  const a = `${YT}#${t}`;
  return As(r, a, o, e), !0;
}, zZ = { id: YT, compile: BZ, interpret: FZ }, VZ = { id: "https://json-schema.org/keyword/vocabulary" }, ZT = "https://json-schema.org/keyword/writeOnly", UZ = (t) => Ct(t), HZ = (t, e, r, n, i, s) => (As(e, ZT, s, t), !0), GZ = { id: ZT, compile: UZ, interpret: HZ };
vT("application/schema+json", LW);
at(lq);
at(fq);
at(gq);
at(xq);
at(Cq);
at(Mq);
at(jq);
at(Vq);
at(Gq);
at(Qq);
at(Zq);
at(eQ);
at(iQ);
at(lQ);
at(dQ);
at(mQ);
at(vQ);
at(wQ);
at(_Q);
at(TQ);
at(DQ);
at(BQ);
at(UQ);
at(qQ);
at(YQ);
at(ZQ);
at(nK);
at(yK);
at(xK);
at(kK);
at(PK);
at(LK);
at($K);
at(zK);
at(GK);
at(KK);
at(XK);
at(nY);
at(aY);
at(hY);
at(gY);
at(xY);
at(kY);
at(RY);
at(MY);
at(BY);
at(HY);
at(QY);
at(ZY);
at(nZ);
at(aZ);
at(hZ);
at(fZ);
at(wZ);
at(AZ);
at(PZ);
at(MZ);
at(jZ);
at(zZ);
at(VZ);
at(GZ);
const WZ = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://json-schema.org/draft/2020-12/schema",
  $vocabulary: {
    "https://json-schema.org/draft/2020-12/vocab/core": !0,
    "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
    "https://json-schema.org/draft/2020-12/vocab/validation": !0,
    "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
    "https://json-schema.org/draft/2020-12/vocab/content": !0
  },
  $dynamicAnchor: "meta",
  title: "Core and Validation specifications meta-schema",
  allOf: [
    { $ref: "meta/core" },
    { $ref: "meta/applicator" },
    { $ref: "meta/unevaluated" },
    { $ref: "meta/validation" },
    { $ref: "meta/meta-data" },
    { $ref: "meta/format-annotation" },
    { $ref: "meta/content" }
  ],
  type: ["object", "boolean"],
  properties: {
    definitions: {
      $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    dependencies: {
      $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
      type: "object",
      additionalProperties: {
        anyOf: [
          { $dynamicRef: "#meta" },
          { $ref: "meta/validation#/$defs/stringArray" }
        ]
      }
    }
  }
}, qZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/core",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Core vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    $id: {
      type: "string",
      format: "uri-reference",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $anchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicRef: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicAnchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        type: "string",
        format: "uri"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    }
  }
}, QZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/applicator",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    prefixItems: { $ref: "#/$defs/schemaArray" },
    items: { $dynamicRef: "#meta" },
    contains: { $dynamicRef: "#meta" },
    additionalProperties: { $dynamicRef: "#meta" },
    properties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      propertyNames: { format: "regex" },
      default: {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      }
    },
    propertyNames: { $dynamicRef: "#meta" },
    if: { $dynamicRef: "#meta" },
    then: { $dynamicRef: "#meta" },
    else: { $dynamicRef: "#meta" },
    allOf: { $ref: "#/$defs/schemaArray" },
    anyOf: { $ref: "#/$defs/schemaArray" },
    oneOf: { $ref: "#/$defs/schemaArray" },
    not: { $dynamicRef: "#meta" }
  },
  $defs: {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: { $dynamicRef: "#meta" }
    }
  }
}, KZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/validation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Validation vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: { $ref: "#/$defs/nonNegativeInteger" },
    minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: { $ref: "#/$defs/nonNegativeInteger" },
    minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    uniqueItems: {
      type: "boolean",
      default: !1
    },
    maxContains: { $ref: "#/$defs/nonNegativeInteger" },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 1
    },
    maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
    minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    required: { $ref: "#/$defs/stringArray" },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    },
    const: !0,
    enum: {
      type: "array",
      items: !0
    },
    type: {
      anyOf: [
        { $ref: "#/$defs/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/$defs/simpleTypes" },
          minItems: 1,
          uniqueItems: !0
        }
      ]
    }
  },
  $defs: {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 0
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: []
    }
  }
}, YZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Meta-data vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    default: !0,
    deprecated: {
      type: "boolean",
      default: !1
    },
    readOnly: {
      type: "boolean",
      default: !1
    },
    writeOnly: {
      type: "boolean",
      default: !1
    },
    examples: {
      type: "array",
      items: !0
    }
  }
}, ZZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for annotation results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, JZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-assertion",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for assertion results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, XZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/content",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Content vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    contentSchema: { $dynamicRef: "#meta" }
  }
}, eJ = {
  $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Unevaluated applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    unevaluatedItems: { $dynamicRef: "#meta" },
    unevaluatedProperties: { $dynamicRef: "#meta" }
  }
}, tJ = { id: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor" }, rJ = "https://json-schema.org/keyword/draft-2020-12/dynamicRef", nJ = async (t, e) => {
  const r = fT(Ct(t)), n = await U2(Ct(t), t);
  return await He.compile(n, e), [n.document.baseUri, r, Fp(n)];
}, QE = (t, [e, r, n], i, s, o, a) => r in s.metaData[e].dynamicAnchors ? (o = { ...s.metaData[e].dynamicAnchors, ...o }, t(o[r], i, s, o, a)) : t(n, i, s, o, a), iJ = (...t) => QE(He.interpret, ...t), sJ = (...t) => QE(He.collectEvaluatedProperties, ...t), oJ = (...t) => QE(He.collectEvaluatedItems, ...t), aJ = { id: rJ, compile: nJ, interpret: iJ, collectEvaluatedProperties: sJ, collectEvaluatedItems: oJ };
at(aJ);
at(tJ);
pc("https://json-schema.org/draft/2020-12/vocab/core", {
  $anchor: "https://json-schema.org/keyword/anchor",
  $comment: "https://json-schema.org/keyword/comment",
  $defs: "https://json-schema.org/keyword/definitions",
  $dynamicAnchor: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor",
  $dynamicRef: "https://json-schema.org/keyword/draft-2020-12/dynamicRef",
  $id: "https://json-schema.org/keyword/id",
  $ref: "https://json-schema.org/keyword/ref",
  $vocabulary: "https://json-schema.org/keyword/vocabulary"
});
pc("https://json-schema.org/draft/2020-12/vocab/applicator", {
  additionalProperties: "https://json-schema.org/keyword/additionalProperties",
  allOf: "https://json-schema.org/keyword/allOf",
  anyOf: "https://json-schema.org/keyword/anyOf",
  contains: "https://json-schema.org/keyword/contains",
  dependentSchemas: "https://json-schema.org/keyword/dependentSchemas",
  if: "https://json-schema.org/keyword/if",
  then: "https://json-schema.org/keyword/then",
  else: "https://json-schema.org/keyword/else",
  items: "https://json-schema.org/keyword/items",
  not: "https://json-schema.org/keyword/not",
  oneOf: "https://json-schema.org/keyword/oneOf",
  patternProperties: "https://json-schema.org/keyword/patternProperties",
  prefixItems: "https://json-schema.org/keyword/prefixItems",
  properties: "https://json-schema.org/keyword/properties",
  propertyNames: "https://json-schema.org/keyword/propertyNames"
});
pc("https://json-schema.org/draft/2020-12/vocab/validation", {
  const: "https://json-schema.org/keyword/const",
  dependentRequired: "https://json-schema.org/keyword/dependentRequired",
  enum: "https://json-schema.org/keyword/enum",
  exclusiveMaximum: "https://json-schema.org/keyword/exclusiveMaximum",
  exclusiveMinimum: "https://json-schema.org/keyword/exclusiveMinimum",
  maxContains: "https://json-schema.org/keyword/maxContains",
  maxItems: "https://json-schema.org/keyword/maxItems",
  maxLength: "https://json-schema.org/keyword/maxLength",
  maxProperties: "https://json-schema.org/keyword/maxProperties",
  maximum: "https://json-schema.org/keyword/maximum",
  minContains: "https://json-schema.org/keyword/minContains",
  minItems: "https://json-schema.org/keyword/minItems",
  minLength: "https://json-schema.org/keyword/minLength",
  minProperties: "https://json-schema.org/keyword/minProperties",
  minimum: "https://json-schema.org/keyword/minimum",
  multipleOf: "https://json-schema.org/keyword/multipleOf",
  pattern: "https://json-schema.org/keyword/pattern",
  required: "https://json-schema.org/keyword/required",
  type: "https://json-schema.org/keyword/type",
  uniqueItems: "https://json-schema.org/keyword/uniqueItems"
});
pc("https://json-schema.org/draft/2020-12/vocab/meta-data", {
  default: "https://json-schema.org/keyword/default",
  deprecated: "https://json-schema.org/keyword/deprecated",
  description: "https://json-schema.org/keyword/description",
  examples: "https://json-schema.org/keyword/examples",
  readOnly: "https://json-schema.org/keyword/readOnly",
  title: "https://json-schema.org/keyword/title",
  writeOnly: "https://json-schema.org/keyword/writeOnly"
});
pc("https://json-schema.org/draft/2020-12/vocab/format-annotation", {
  format: "https://json-schema.org/keyword/format"
});
pc("https://json-schema.org/draft/2020-12/vocab/format-assertion", {
  format: "https://json-schema.org/keyword/format-assertion"
});
pc("https://json-schema.org/draft/2020-12/vocab/content", {
  contentEncoding: "https://json-schema.org/keyword/contentEncoding",
  contentMediaType: "https://json-schema.org/keyword/contentMediaType",
  contentSchema: "https://json-schema.org/keyword/contentSchema"
});
pc("https://json-schema.org/draft/2020-12/vocab/unevaluated", {
  unevaluatedItems: "https://json-schema.org/keyword/unevaluatedItems",
  unevaluatedProperties: "https://json-schema.org/keyword/unevaluatedProperties"
});
mT("https://json-schema.org/draft/2020-12/schema", {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, !0);
Va(WZ);
Va(qZ);
Va(QZ);
Va(KZ);
Va(YZ);
Va(ZZ);
Va(JZ);
Va(XZ);
Va(eJ);
function Pm(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var $k = { exports: {} };
/*! jsonpath 1.1.1 */
var jk;
function lJ() {
  return jk || (jk = 1, function(t, e) {
    (function(r) {
      t.exports = r();
    })(function() {
      return function r(n, i, s) {
        function o(c, p) {
          if (!i[c]) {
            if (!n[c]) {
              var h = typeof Pm == "function" && Pm;
              if (!p && h) return h(c, !0);
              if (a) return a(c, !0);
              var d = new Error("Cannot find module '" + c + "'");
              throw d.code = "MODULE_NOT_FOUND", d;
            }
            var b = i[c] = { exports: {} };
            n[c][0].call(b.exports, function(m) {
              var w = n[c][1][m];
              return o(w || m);
            }, b, b.exports, r, n, i, s);
          }
          return i[c].exports;
        }
        for (var a = typeof Pm == "function" && Pm, l = 0; l < s.length; l++) o(s[l]);
        return o;
      }({ "./aesprim": [function(r, n, i) {
        (function(s, o) {
          o(typeof i < "u" ? i : s.esprima = {});
        })(this, function(s) {
          var o, a, l, c, p, h, d, b, m, w, f, E, A, x, g, v, k, S;
          o = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
          }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
            "(",
            "{",
            "[",
            "in",
            "typeof",
            "instanceof",
            "new",
            "return",
            "case",
            "delete",
            "throw",
            "void",
            // assignment operators
            "=",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "<<=",
            ">>=",
            ">>>=",
            "&=",
            "|=",
            "^=",
            ",",
            // binary/unary operators
            "+",
            "-",
            "*",
            "/",
            "%",
            "++",
            "--",
            "<<",
            ">>",
            ">>>",
            "&",
            "|",
            "^",
            "!",
            "~",
            "&&",
            "||",
            "?",
            ":",
            "===",
            "==",
            ">=",
            "<=",
            "<",
            ">",
            "!=",
            "!=="
          ], c = {
            AssignmentExpression: "AssignmentExpression",
            ArrayExpression: "ArrayExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            Program: "Program",
            Property: "Property",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SwitchStatement: "SwitchStatement",
            SwitchCase: "SwitchCase",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement"
          }, p = {
            Data: 1,
            Get: 2,
            Set: 4
          }, h = {
            UnexpectedToken: "Unexpected token %0",
            UnexpectedNumber: "Unexpected number",
            UnexpectedString: "Unexpected string",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedEOS: "Unexpected end of input",
            NewlineAfterThrow: "Illegal newline after throw",
            InvalidRegExp: "Invalid regular expression",
            UnterminatedRegExp: "Invalid regular expression: missing /",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NoCatchOrFinally: "Missing catch or finally after try",
            UnknownLabel: "Undefined label '%0'",
            Redeclaration: "%0 '%1' has already been declared",
            IllegalContinue: "Illegal continue statement",
            IllegalBreak: "Illegal break statement",
            IllegalReturn: "Illegal return statement",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
            AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
            AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode"
          }, d = {
            NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
            NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
          };
          function R(u, y) {
            if (!u)
              throw new Error("ASSERT: " + y);
          }
          function L(u) {
            return u >= 48 && u <= 57;
          }
          function F(u) {
            return "0123456789abcdefABCDEF".indexOf(u) >= 0;
          }
          function z(u) {
            return "01234567".indexOf(u) >= 0;
          }
          function j(u) {
            return u === 32 || u === 9 || u === 11 || u === 12 || u === 160 || u >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(u) >= 0;
          }
          function ee(u) {
            return u === 10 || u === 13 || u === 8232 || u === 8233;
          }
          function X(u) {
            return u == 64 || u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierStart.test(String.fromCharCode(u));
          }
          function ie(u) {
            return u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u >= 48 && u <= 57 || // 0..9
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierPart.test(String.fromCharCode(u));
          }
          function ce(u) {
            switch (u) {
              case "class":
              case "enum":
              case "export":
              case "extends":
              case "import":
              case "super":
                return !0;
              default:
                return !1;
            }
          }
          function ke(u) {
            switch (u) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return !0;
              default:
                return !1;
            }
          }
          function ye(u) {
            return u === "eval" || u === "arguments";
          }
          function Ce(u) {
            if (w && ke(u))
              return !0;
            switch (u.length) {
              case 2:
                return u === "if" || u === "in" || u === "do";
              case 3:
                return u === "var" || u === "for" || u === "new" || u === "try" || u === "let";
              case 4:
                return u === "this" || u === "else" || u === "case" || u === "void" || u === "with" || u === "enum";
              case 5:
                return u === "while" || u === "break" || u === "catch" || u === "throw" || u === "const" || u === "yield" || u === "class" || u === "super";
              case 6:
                return u === "return" || u === "typeof" || u === "delete" || u === "switch" || u === "export" || u === "import";
              case 7:
                return u === "default" || u === "finally" || u === "extends";
              case 8:
                return u === "function" || u === "continue" || u === "debugger";
              case 10:
                return u === "instanceof";
              default:
                return !1;
            }
          }
          function Ie(u, y, _, T, U) {
            var ne;
            R(typeof _ == "number", "Comment must have valid position"), !(k.lastCommentStart >= _) && (k.lastCommentStart = _, ne = {
              type: u,
              value: y
            }, S.range && (ne.range = [_, T]), S.loc && (ne.loc = U), S.comments.push(ne), S.attachComment && (S.leadingComments.push(ne), S.trailingComments.push(ne)));
          }
          function Te(u) {
            var y, _, T, U;
            for (y = f - u, _ = {
              start: {
                line: E,
                column: f - A - u
              }
            }; f < x; )
              if (T = m.charCodeAt(f), ++f, ee(T)) {
                S.comments && (U = m.slice(y + u, f - 1), _.end = {
                  line: E,
                  column: f - A - 1
                }, Ie("Line", U, y, f - 1, _)), T === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f;
                return;
              }
            S.comments && (U = m.slice(y + u, f), _.end = {
              line: E,
              column: f - A
            }, Ie("Line", U, y, f, _));
          }
          function ue() {
            var u, y, _, T;
            for (S.comments && (u = f - 2, y = {
              start: {
                line: E,
                column: f - A - 2
              }
            }); f < x; )
              if (_ = m.charCodeAt(f), ee(_))
                _ === 13 && m.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && ge({}, h.UnexpectedToken, "ILLEGAL");
              else if (_ === 42) {
                if (m.charCodeAt(f + 1) === 47) {
                  ++f, ++f, S.comments && (T = m.slice(u + 2, f - 2), y.end = {
                    line: E,
                    column: f - A
                  }, Ie("Block", T, u, f, y));
                  return;
                }
                ++f;
              } else
                ++f;
            ge({}, h.UnexpectedToken, "ILLEGAL");
          }
          function O() {
            var u, y;
            for (y = f === 0; f < x; )
              if (u = m.charCodeAt(f), j(u))
                ++f;
              else if (ee(u))
                ++f, u === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f, y = !0;
              else if (u === 47)
                if (u = m.charCodeAt(f + 1), u === 47)
                  ++f, ++f, Te(2), y = !0;
                else if (u === 42)
                  ++f, ++f, ue();
                else
                  break;
              else if (y && u === 45)
                if (m.charCodeAt(f + 1) === 45 && m.charCodeAt(f + 2) === 62)
                  f += 3, Te(3);
                else
                  break;
              else if (u === 60)
                if (m.slice(f + 1, f + 4) === "!--")
                  ++f, ++f, ++f, ++f, Te(4);
                else
                  break;
              else
                break;
          }
          function N(u) {
            var y, _, T, U = 0;
            for (_ = u === "u" ? 4 : 2, y = 0; y < _; ++y)
              if (f < x && F(m[f]))
                T = m[f++], U = U * 16 + "0123456789abcdef".indexOf(T.toLowerCase());
              else
                return "";
            return String.fromCharCode(U);
          }
          function Z() {
            var u, y;
            for (u = m.charCodeAt(f++), y = String.fromCharCode(u), u === 92 && (m.charCodeAt(f) !== 117 && ge({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !X(u.charCodeAt(0))) && ge({}, h.UnexpectedToken, "ILLEGAL"), y = u); f < x && (u = m.charCodeAt(f), !!ie(u)); )
              ++f, y += String.fromCharCode(u), u === 92 && (y = y.substr(0, y.length - 1), m.charCodeAt(f) !== 117 && ge({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !ie(u.charCodeAt(0))) && ge({}, h.UnexpectedToken, "ILLEGAL"), y += u);
            return y;
          }
          function re() {
            var u, y;
            for (u = f++; f < x; ) {
              if (y = m.charCodeAt(f), y === 92)
                return f = u, Z();
              if (ie(y))
                ++f;
              else
                break;
            }
            return m.slice(u, f);
          }
          function le() {
            var u, y, _;
            return u = f, y = m.charCodeAt(f) === 92 ? Z() : re(), y.length === 1 ? _ = o.Identifier : Ce(y) ? _ = o.Keyword : y === "null" ? _ = o.NullLiteral : y === "true" || y === "false" ? _ = o.BooleanLiteral : _ = o.Identifier, {
              type: _,
              value: y,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function te() {
            var u = f, y = m.charCodeAt(f), _, T = m[f], U, ne, _e;
            switch (y) {
              case 46:
              case 40:
              case 41:
              case 59:
              case 44:
              case 123:
              case 125:
              case 91:
              case 93:
              case 58:
              case 63:
              case 126:
                return ++f, S.tokenize && (y === 40 ? S.openParenToken = S.tokens.length : y === 123 && (S.openCurlyToken = S.tokens.length)), {
                  type: o.Punctuator,
                  value: String.fromCharCode(y),
                  lineNumber: E,
                  lineStart: A,
                  start: u,
                  end: f
                };
              default:
                if (_ = m.charCodeAt(f + 1), _ === 61)
                  switch (y) {
                    case 43:
                    case 45:
                    case 47:
                    case 60:
                    case 62:
                    case 94:
                    case 124:
                    case 37:
                    case 38:
                    case 42:
                      return f += 2, {
                        type: o.Punctuator,
                        value: String.fromCharCode(y) + String.fromCharCode(_),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                    case 33:
                    case 61:
                      return f += 2, m.charCodeAt(f) === 61 && ++f, {
                        type: o.Punctuator,
                        value: m.slice(u, f),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                  }
            }
            if (_e = m.substr(f, 4), _e === ">>>=")
              return f += 4, {
                type: o.Punctuator,
                value: _e,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (ne = _e.substr(0, 3), ne === ">>>" || ne === "<<=" || ne === ">>=")
              return f += 3, {
                type: o.Punctuator,
                value: ne,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (U = ne.substr(0, 2), T === U[1] && "+-<>&|".indexOf(T) >= 0 || U === "=>")
              return f += 2, {
                type: o.Punctuator,
                value: U,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if ("<>=!+-*%&|^/".indexOf(T) >= 0)
              return ++f, {
                type: o.Punctuator,
                value: T,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            ge({}, h.UnexpectedToken, "ILLEGAL");
          }
          function oe(u) {
            for (var y = ""; f < x && F(m[f]); )
              y += m[f++];
            return y.length === 0 && ge({}, h.UnexpectedToken, "ILLEGAL"), X(m.charCodeAt(f)) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt("0x" + y, 16),
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function fe(u) {
            for (var y = "0" + m[f++]; f < x && z(m[f]); )
              y += m[f++];
            return (X(m.charCodeAt(f)) || L(m.charCodeAt(f))) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt(y, 8),
              octal: !0,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function H() {
            var u, y, _;
            if (_ = m[f], R(
              L(_.charCodeAt(0)) || _ === ".",
              "Numeric literal must start with a decimal digit or a decimal point"
            ), y = f, u = "", _ !== ".") {
              if (u = m[f++], _ = m[f], u === "0") {
                if (_ === "x" || _ === "X")
                  return ++f, oe(y);
                if (z(_))
                  return fe(y);
                _ && L(_.charCodeAt(0)) && ge({}, h.UnexpectedToken, "ILLEGAL");
              }
              for (; L(m.charCodeAt(f)); )
                u += m[f++];
              _ = m[f];
            }
            if (_ === ".") {
              for (u += m[f++]; L(m.charCodeAt(f)); )
                u += m[f++];
              _ = m[f];
            }
            if (_ === "e" || _ === "E")
              if (u += m[f++], _ = m[f], (_ === "+" || _ === "-") && (u += m[f++]), L(m.charCodeAt(f)))
                for (; L(m.charCodeAt(f)); )
                  u += m[f++];
              else
                ge({}, h.UnexpectedToken, "ILLEGAL");
            return X(m.charCodeAt(f)) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseFloat(u),
              lineNumber: E,
              lineStart: A,
              start: y,
              end: f
            };
          }
          function J() {
            var u = "", y, _, T, U, ne, _e, Ne = !1, et, Xe;
            for (et = E, Xe = A, y = m[f], R(
              y === "'" || y === '"',
              "String literal must starts with a quote"
            ), _ = f, ++f; f < x; )
              if (T = m[f++], T === y) {
                y = "";
                break;
              } else if (T === "\\")
                if (T = m[f++], !T || !ee(T.charCodeAt(0)))
                  switch (T) {
                    case "u":
                    case "x":
                      _e = f, ne = N(T), ne ? u += ne : (f = _e, u += T);
                      break;
                    case "n":
                      u += `
`;
                      break;
                    case "r":
                      u += "\r";
                      break;
                    case "t":
                      u += "	";
                      break;
                    case "b":
                      u += "\b";
                      break;
                    case "f":
                      u += "\f";
                      break;
                    case "v":
                      u += "\v";
                      break;
                    default:
                      z(T) ? (U = "01234567".indexOf(T), U !== 0 && (Ne = !0), f < x && z(m[f]) && (Ne = !0, U = U * 8 + "01234567".indexOf(m[f++]), "0123".indexOf(T) >= 0 && f < x && z(m[f]) && (U = U * 8 + "01234567".indexOf(m[f++]))), u += String.fromCharCode(U)) : u += T;
                      break;
                  }
                else
                  ++E, T === "\r" && m[f] === `
` && ++f, A = f;
              else {
                if (ee(T.charCodeAt(0)))
                  break;
                u += T;
              }
            return y !== "" && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.StringLiteral,
              value: u,
              octal: Ne,
              startLineNumber: et,
              startLineStart: Xe,
              lineNumber: E,
              lineStart: A,
              start: _,
              end: f
            };
          }
          function Se(u, y) {
            var _;
            try {
              _ = new RegExp(u, y);
            } catch {
              ge({}, h.InvalidRegExp);
            }
            return _;
          }
          function Re() {
            var u, y, _, T, U;
            for (u = m[f], R(u === "/", "Regular expression literal must start with a slash"), y = m[f++], _ = !1, T = !1; f < x; )
              if (u = m[f++], y += u, u === "\\")
                u = m[f++], ee(u.charCodeAt(0)) && ge({}, h.UnterminatedRegExp), y += u;
              else if (ee(u.charCodeAt(0)))
                ge({}, h.UnterminatedRegExp);
              else if (_)
                u === "]" && (_ = !1);
              else if (u === "/") {
                T = !0;
                break;
              } else u === "[" && (_ = !0);
            return T || ge({}, h.UnterminatedRegExp), U = y.substr(1, y.length - 2), {
              value: U,
              literal: y
            };
          }
          function Fe() {
            var u, y, _, T;
            for (y = "", _ = ""; f < x && (u = m[f], !!ie(u.charCodeAt(0))); )
              if (++f, u === "\\" && f < x)
                if (u = m[f], u === "u") {
                  if (++f, T = f, u = N("u"), u)
                    for (_ += u, y += "\\u"; T < f; ++T)
                      y += m[T];
                  else
                    f = T, _ += "u", y += "\\u";
                  be({}, h.UnexpectedToken, "ILLEGAL");
                } else
                  y += "\\", be({}, h.UnexpectedToken, "ILLEGAL");
              else
                _ += u, y += u;
            return {
              value: _,
              literal: y
            };
          }
          function Le() {
            var u, y, _, T;
            return v = null, O(), u = f, y = Re(), _ = Fe(), T = Se(y.value, _.value), S.tokenize ? {
              type: o.RegularExpression,
              value: T,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            } : {
              literal: y.literal + _.literal,
              value: T,
              start: u,
              end: f
            };
          }
          function ze() {
            var u, y, _, T;
            return O(), u = f, y = {
              start: {
                line: E,
                column: f - A
              }
            }, _ = Le(), y.end = {
              line: E,
              column: f - A
            }, S.tokenize || (S.tokens.length > 0 && (T = S.tokens[S.tokens.length - 1], T.range[0] === u && T.type === "Punctuator" && (T.value === "/" || T.value === "/=") && S.tokens.pop()), S.tokens.push({
              type: "RegularExpression",
              value: _.literal,
              range: [u, f],
              loc: y
            })), _;
          }
          function tt(u) {
            return u.type === o.Identifier || u.type === o.Keyword || u.type === o.BooleanLiteral || u.type === o.NullLiteral;
          }
          function Pe() {
            var u, y;
            if (u = S.tokens[S.tokens.length - 1], !u)
              return ze();
            if (u.type === "Punctuator") {
              if (u.value === "]")
                return te();
              if (u.value === ")")
                return y = S.tokens[S.openParenToken - 1], y && y.type === "Keyword" && (y.value === "if" || y.value === "while" || y.value === "for" || y.value === "with") ? ze() : te();
              if (u.value === "}") {
                if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 4], !y)
                    return te();
                } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 5], !y)
                    return ze();
                } else
                  return te();
                return l.indexOf(y.value) >= 0 ? te() : ze();
              }
              return ze();
            }
            return u.type === "Keyword" ? ze() : te();
          }
          function At() {
            var u;
            return O(), f >= x ? {
              type: o.EOF,
              lineNumber: E,
              lineStart: A,
              start: f,
              end: f
            } : (u = m.charCodeAt(f), X(u) ? le() : u === 40 || u === 41 || u === 59 ? te() : u === 39 || u === 34 ? J() : u === 46 ? L(m.charCodeAt(f + 1)) ? H() : te() : L(u) ? H() : S.tokenize && u === 47 ? Pe() : te());
          }
          function er() {
            var u, y, _;
            return O(), u = {
              start: {
                line: E,
                column: f - A
              }
            }, y = At(), u.end = {
              line: E,
              column: f - A
            }, y.type !== o.EOF && (_ = m.slice(y.start, y.end), S.tokens.push({
              type: a[y.type],
              value: _,
              range: [y.start, y.end],
              loc: u
            })), y;
          }
          function me() {
            var u;
            return u = v, f = u.end, E = u.lineNumber, A = u.lineStart, v = typeof S.tokens < "u" ? er() : At(), f = u.end, E = u.lineNumber, A = u.lineStart, u;
          }
          function ht() {
            var u, y, _;
            u = f, y = E, _ = A, v = typeof S.tokens < "u" ? er() : At(), f = u, E = y, A = _;
          }
          function it(u, y) {
            this.line = u, this.column = y;
          }
          function kt(u, y, _, T) {
            this.start = new it(u, y), this.end = new it(_, T);
          }
          b = {
            name: "SyntaxTree",
            processComment: function(u) {
              var y, _;
              if (!(u.type === c.Program && u.body.length > 0)) {
                for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= u.range[1] ? (_ = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= u.range[1] && (_ = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= u.range[0]; )
                  y = S.bottomRightStack.pop();
                y ? y.leadingComments && y.leadingComments[y.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = y.leadingComments, delete y.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = S.leadingComments, S.leadingComments = []), _ && (u.trailingComments = _), S.bottomRightStack.push(u);
              }
            },
            markEnd: function(u, y) {
              return S.range && (u.range = [y.start, f]), S.loc && (u.loc = new kt(
                y.startLineNumber === void 0 ? y.lineNumber : y.startLineNumber,
                y.start - (y.startLineStart === void 0 ? y.lineStart : y.startLineStart),
                E,
                f - A
              ), this.postProcess(u)), S.attachComment && this.processComment(u), u;
            },
            postProcess: function(u) {
              return S.source && (u.loc.source = S.source), u;
            },
            createArrayExpression: function(u) {
              return {
                type: c.ArrayExpression,
                elements: u
              };
            },
            createAssignmentExpression: function(u, y, _) {
              return {
                type: c.AssignmentExpression,
                operator: u,
                left: y,
                right: _
              };
            },
            createBinaryExpression: function(u, y, _) {
              var T = u === "||" || u === "&&" ? c.LogicalExpression : c.BinaryExpression;
              return {
                type: T,
                operator: u,
                left: y,
                right: _
              };
            },
            createBlockStatement: function(u) {
              return {
                type: c.BlockStatement,
                body: u
              };
            },
            createBreakStatement: function(u) {
              return {
                type: c.BreakStatement,
                label: u
              };
            },
            createCallExpression: function(u, y) {
              return {
                type: c.CallExpression,
                callee: u,
                arguments: y
              };
            },
            createCatchClause: function(u, y) {
              return {
                type: c.CatchClause,
                param: u,
                body: y
              };
            },
            createConditionalExpression: function(u, y, _) {
              return {
                type: c.ConditionalExpression,
                test: u,
                consequent: y,
                alternate: _
              };
            },
            createContinueStatement: function(u) {
              return {
                type: c.ContinueStatement,
                label: u
              };
            },
            createDebuggerStatement: function() {
              return {
                type: c.DebuggerStatement
              };
            },
            createDoWhileStatement: function(u, y) {
              return {
                type: c.DoWhileStatement,
                body: u,
                test: y
              };
            },
            createEmptyStatement: function() {
              return {
                type: c.EmptyStatement
              };
            },
            createExpressionStatement: function(u) {
              return {
                type: c.ExpressionStatement,
                expression: u
              };
            },
            createForStatement: function(u, y, _, T) {
              return {
                type: c.ForStatement,
                init: u,
                test: y,
                update: _,
                body: T
              };
            },
            createForInStatement: function(u, y, _) {
              return {
                type: c.ForInStatement,
                left: u,
                right: y,
                body: _,
                each: !1
              };
            },
            createFunctionDeclaration: function(u, y, _, T) {
              return {
                type: c.FunctionDeclaration,
                id: u,
                params: y,
                defaults: _,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createFunctionExpression: function(u, y, _, T) {
              return {
                type: c.FunctionExpression,
                id: u,
                params: y,
                defaults: _,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createIdentifier: function(u) {
              return {
                type: c.Identifier,
                name: u
              };
            },
            createIfStatement: function(u, y, _) {
              return {
                type: c.IfStatement,
                test: u,
                consequent: y,
                alternate: _
              };
            },
            createLabeledStatement: function(u, y) {
              return {
                type: c.LabeledStatement,
                label: u,
                body: y
              };
            },
            createLiteral: function(u) {
              return {
                type: c.Literal,
                value: u.value,
                raw: m.slice(u.start, u.end)
              };
            },
            createMemberExpression: function(u, y, _) {
              return {
                type: c.MemberExpression,
                computed: u === "[",
                object: y,
                property: _
              };
            },
            createNewExpression: function(u, y) {
              return {
                type: c.NewExpression,
                callee: u,
                arguments: y
              };
            },
            createObjectExpression: function(u) {
              return {
                type: c.ObjectExpression,
                properties: u
              };
            },
            createPostfixExpression: function(u, y) {
              return {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !1
              };
            },
            createProgram: function(u) {
              return {
                type: c.Program,
                body: u
              };
            },
            createProperty: function(u, y, _) {
              return {
                type: c.Property,
                key: y,
                value: _,
                kind: u
              };
            },
            createReturnStatement: function(u) {
              return {
                type: c.ReturnStatement,
                argument: u
              };
            },
            createSequenceExpression: function(u) {
              return {
                type: c.SequenceExpression,
                expressions: u
              };
            },
            createSwitchCase: function(u, y) {
              return {
                type: c.SwitchCase,
                test: u,
                consequent: y
              };
            },
            createSwitchStatement: function(u, y) {
              return {
                type: c.SwitchStatement,
                discriminant: u,
                cases: y
              };
            },
            createThisExpression: function() {
              return {
                type: c.ThisExpression
              };
            },
            createThrowStatement: function(u) {
              return {
                type: c.ThrowStatement,
                argument: u
              };
            },
            createTryStatement: function(u, y, _, T) {
              return {
                type: c.TryStatement,
                block: u,
                guardedHandlers: y,
                handlers: _,
                finalizer: T
              };
            },
            createUnaryExpression: function(u, y) {
              return u === "++" || u === "--" ? {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !0
              } : {
                type: c.UnaryExpression,
                operator: u,
                argument: y,
                prefix: !0
              };
            },
            createVariableDeclaration: function(u, y) {
              return {
                type: c.VariableDeclaration,
                declarations: u,
                kind: y
              };
            },
            createVariableDeclarator: function(u, y) {
              return {
                type: c.VariableDeclarator,
                id: u,
                init: y
              };
            },
            createWhileStatement: function(u, y) {
              return {
                type: c.WhileStatement,
                test: u,
                body: y
              };
            },
            createWithStatement: function(u, y) {
              return {
                type: c.WithStatement,
                object: u,
                body: y
              };
            }
          };
          function Ze() {
            var u, y, _, T;
            return u = f, y = E, _ = A, O(), T = E !== y, f = u, E = y, A = _, T;
          }
          function ge(u, y) {
            var _, T = Array.prototype.slice.call(arguments, 2), U = y.replace(
              /%(\d)/g,
              function(ne, _e) {
                return R(_e < T.length, "Message reference must be in range"), T[_e];
              }
            );
            throw typeof u.lineNumber == "number" ? (_ = new Error("Line " + u.lineNumber + ": " + U), _.index = u.start, _.lineNumber = u.lineNumber, _.column = u.start - A + 1) : (_ = new Error("Line " + E + ": " + U), _.index = f, _.lineNumber = E, _.column = f - A + 1), _.description = U, _;
          }
          function be() {
            try {
              ge.apply(null, arguments);
            } catch (u) {
              if (S.errors)
                S.errors.push(u);
              else
                throw u;
            }
          }
          function Je(u) {
            if (u.type === o.EOF && ge(u, h.UnexpectedEOS), u.type === o.NumericLiteral && ge(u, h.UnexpectedNumber), u.type === o.StringLiteral && ge(u, h.UnexpectedString), u.type === o.Identifier && ge(u, h.UnexpectedIdentifier), u.type === o.Keyword) {
              if (ce(u.value))
                ge(u, h.UnexpectedReserved);
              else if (w && ke(u.value)) {
                be(u, h.StrictReservedWord);
                return;
              }
              ge(u, h.UnexpectedToken, u.value);
            }
            ge(u, h.UnexpectedToken, u.value);
          }
          function C(u) {
            var y = me();
            (y.type !== o.Punctuator || y.value !== u) && Je(y);
          }
          function $(u) {
            var y = me();
            (y.type !== o.Keyword || y.value !== u) && Je(y);
          }
          function D(u) {
            return v.type === o.Punctuator && v.value === u;
          }
          function ae(u) {
            return v.type === o.Keyword && v.value === u;
          }
          function pe() {
            var u;
            return v.type !== o.Punctuator ? !1 : (u = v.value, u === "=" || u === "*=" || u === "/=" || u === "%=" || u === "+=" || u === "-=" || u === "<<=" || u === ">>=" || u === ">>>=" || u === "&=" || u === "^=" || u === "|=");
          }
          function Ee() {
            var u;
            if (m.charCodeAt(f) === 59 || D(";")) {
              me();
              return;
            }
            u = E, O(), E === u && v.type !== o.EOF && !D("}") && Je(v);
          }
          function Me(u) {
            return u.type === c.Identifier || u.type === c.MemberExpression;
          }
          function ot() {
            var u = [], y;
            for (y = v, C("["); !D("]"); )
              D(",") ? (me(), u.push(null)) : (u.push(W()), D("]") || C(","));
            return me(), g.markEnd(g.createArrayExpression(u), y);
          }
          function dt(u, y) {
            var _, T, U;
            return _ = w, U = v, T = Un(), y && w && ye(u[0].name) && be(y, h.StrictParamName), w = _, g.markEnd(g.createFunctionExpression(null, u, [], T), U);
          }
          function St() {
            var u, y;
            return y = v, u = me(), u.type === o.StringLiteral || u.type === o.NumericLiteral ? (w && u.octal && be(u, h.StrictOctalLiteral), g.markEnd(g.createLiteral(u), y)) : g.markEnd(g.createIdentifier(u.value), y);
          }
          function rt() {
            var u, y, _, T, U, ne;
            if (u = v, ne = v, u.type === o.Identifier)
              return _ = St(), u.value === "get" && !D(":") ? (y = St(), C("("), C(")"), T = dt([]), g.markEnd(g.createProperty("get", y, T), ne)) : u.value === "set" && !D(":") ? (y = St(), C("("), u = v, u.type !== o.Identifier ? (C(")"), be(u, h.UnexpectedToken, u.value), T = dt([])) : (U = [he()], C(")"), T = dt(U, u)), g.markEnd(g.createProperty("set", y, T), ne)) : (C(":"), T = W(), g.markEnd(g.createProperty("init", _, T), ne));
            if (u.type === o.EOF || u.type === o.Punctuator)
              Je(u);
            else
              return y = St(), C(":"), T = W(), g.markEnd(g.createProperty("init", y, T), ne);
          }
          function zt() {
            var u = [], y, _, T, U, ne = {}, _e = String, Ne;
            for (Ne = v, C("{"); !D("}"); )
              y = rt(), y.key.type === c.Identifier ? _ = y.key.name : _ = _e(y.key.value), U = y.kind === "init" ? p.Data : y.kind === "get" ? p.Get : p.Set, T = "$" + _, Object.prototype.hasOwnProperty.call(ne, T) ? (ne[T] === p.Data ? w && U === p.Data ? be({}, h.StrictDuplicateProperty) : U !== p.Data && be({}, h.AccessorDataProperty) : U === p.Data ? be({}, h.AccessorDataProperty) : ne[T] & U && be({}, h.AccessorGetSet), ne[T] |= U) : ne[T] = U, u.push(y), D("}") || C(",");
            return C("}"), g.markEnd(g.createObjectExpression(u), Ne);
          }
          function Xt() {
            var u;
            return C("("), u = G(), C(")"), u;
          }
          function tr() {
            var u, y, _, T;
            if (D("("))
              return Xt();
            if (D("["))
              return ot();
            if (D("{"))
              return zt();
            if (u = v.type, T = v, u === o.Identifier)
              _ = g.createIdentifier(me().value);
            else if (u === o.StringLiteral || u === o.NumericLiteral)
              w && v.octal && be(v, h.StrictOctalLiteral), _ = g.createLiteral(me());
            else if (u === o.Keyword) {
              if (ae("function"))
                return uu();
              ae("this") ? (me(), _ = g.createThisExpression()) : Je(me());
            } else u === o.BooleanLiteral ? (y = me(), y.value = y.value === "true", _ = g.createLiteral(y)) : u === o.NullLiteral ? (y = me(), y.value = null, _ = g.createLiteral(y)) : D("/") || D("/=") ? (typeof S.tokens < "u" ? _ = g.createLiteral(ze()) : _ = g.createLiteral(Le()), ht()) : Je(me());
            return g.markEnd(_, T);
          }
          function Nr() {
            var u = [];
            if (C("("), !D(")"))
              for (; f < x && (u.push(W()), !D(")")); )
                C(",");
            return C(")"), u;
          }
          function ki() {
            var u, y;
            return y = v, u = me(), tt(u) || Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function Zt() {
            return C("."), ki();
          }
          function Vn() {
            var u;
            return C("["), u = G(), C("]"), u;
          }
          function M() {
            var u, y, _;
            return _ = v, $("new"), u = q(), y = D("(") ? Nr() : [], g.markEnd(g.createNewExpression(u, y), _);
          }
          function V() {
            var u, y, _, T, U;
            for (U = v, u = k.allowIn, k.allowIn = !0, y = ae("new") ? M() : tr(), k.allowIn = u; ; ) {
              if (D("."))
                T = Zt(), y = g.createMemberExpression(".", y, T);
              else if (D("("))
                _ = Nr(), y = g.createCallExpression(y, _);
              else if (D("["))
                T = Vn(), y = g.createMemberExpression("[", y, T);
              else
                break;
              g.markEnd(y, U);
            }
            return y;
          }
          function q() {
            var u, y, _, T;
            for (T = v, u = k.allowIn, y = ae("new") ? M() : tr(), k.allowIn = u; D(".") || D("["); )
              D("[") ? (_ = Vn(), y = g.createMemberExpression("[", y, _)) : (_ = Zt(), y = g.createMemberExpression(".", y, _)), g.markEnd(y, T);
            return y;
          }
          function de() {
            var u, y, _ = v;
            return u = V(), v.type === o.Punctuator && (D("++") || D("--")) && !Ze() && (w && u.type === c.Identifier && ye(u.name) && be({}, h.StrictLHSPostfix), Me(u) || be({}, h.InvalidLHSInAssignment), y = me(), u = g.markEnd(g.createPostfixExpression(y.value, u), _)), u;
          }
          function ve() {
            var u, y, _;
            return v.type !== o.Punctuator && v.type !== o.Keyword ? y = de() : D("++") || D("--") ? (_ = v, u = me(), y = ve(), w && y.type === c.Identifier && ye(y.name) && be({}, h.StrictLHSPrefix), Me(y) || be({}, h.InvalidLHSInAssignment), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _)) : D("+") || D("-") || D("~") || D("!") ? (_ = v, u = me(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _)) : ae("delete") || ae("void") || ae("typeof") ? (_ = v, u = me(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _), w && y.operator === "delete" && y.argument.type === c.Identifier && be({}, h.StrictDelete)) : y = de(), y;
          }
          function Y(u, y) {
            var _ = 0;
            if (u.type !== o.Punctuator && u.type !== o.Keyword)
              return 0;
            switch (u.value) {
              case "||":
                _ = 1;
                break;
              case "&&":
                _ = 2;
                break;
              case "|":
                _ = 3;
                break;
              case "^":
                _ = 4;
                break;
              case "&":
                _ = 5;
                break;
              case "==":
              case "!=":
              case "===":
              case "!==":
                _ = 6;
                break;
              case "<":
              case ">":
              case "<=":
              case ">=":
              case "instanceof":
                _ = 7;
                break;
              case "in":
                _ = y ? 7 : 0;
                break;
              case "<<":
              case ">>":
              case ">>>":
                _ = 8;
                break;
              case "+":
              case "-":
                _ = 9;
                break;
              case "*":
              case "/":
              case "%":
                _ = 11;
                break;
            }
            return _;
          }
          function I() {
            var u, y, _, T, U, ne, _e, Ne, et, Xe;
            if (u = v, et = ve(), T = v, U = Y(T, k.allowIn), U === 0)
              return et;
            for (T.prec = U, me(), y = [u, v], _e = ve(), ne = [et, T, _e]; (U = Y(v, k.allowIn)) > 0; ) {
              for (; ne.length > 2 && U <= ne[ne.length - 2].prec; )
                _e = ne.pop(), Ne = ne.pop().value, et = ne.pop(), _ = g.createBinaryExpression(Ne, et, _e), y.pop(), u = y[y.length - 1], g.markEnd(_, u), ne.push(_);
              T = me(), T.prec = U, ne.push(T), y.push(v), _ = ve(), ne.push(_);
            }
            for (Xe = ne.length - 1, _ = ne[Xe], y.pop(); Xe > 1; )
              _ = g.createBinaryExpression(ne[Xe - 1].value, ne[Xe - 2], _), Xe -= 2, u = y.pop(), g.markEnd(_, u);
            return _;
          }
          function B() {
            var u, y, _, T, U;
            return U = v, u = I(), D("?") && (me(), y = k.allowIn, k.allowIn = !0, _ = W(), k.allowIn = y, C(":"), T = W(), u = g.createConditionalExpression(u, _, T), g.markEnd(u, U)), u;
          }
          function W() {
            var u, y, _, T, U;
            return u = v, U = v, T = y = B(), pe() && (Me(y) || be({}, h.InvalidLHSInAssignment), w && y.type === c.Identifier && ye(y.name) && be(u, h.StrictLHSAssignment), u = me(), _ = W(), T = g.markEnd(g.createAssignmentExpression(u.value, y, _), U)), T;
          }
          function G() {
            var u, y = v;
            if (u = W(), D(",")) {
              for (u = g.createSequenceExpression([u]); f < x && D(","); )
                me(), u.expressions.push(W());
              g.markEnd(u, y);
            }
            return u;
          }
          function K() {
            for (var u = [], y; f < x && !(D("}") || (y = Ir(), typeof y > "u")); )
              u.push(y);
            return u;
          }
          function se() {
            var u, y;
            return y = v, C("{"), u = K(), C("}"), g.markEnd(g.createBlockStatement(u), y);
          }
          function he() {
            var u, y;
            return y = v, u = me(), u.type !== o.Identifier && Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function we(u) {
            var y = null, _, T;
            return T = v, _ = he(), w && ye(_.name) && be({}, h.StrictVarName), u === "const" ? (C("="), y = W()) : D("=") && (me(), y = W()), g.markEnd(g.createVariableDeclarator(_, y), T);
          }
          function Ae(u) {
            var y = [];
            do {
              if (y.push(we(u)), !D(","))
                break;
              me();
            } while (f < x);
            return y;
          }
          function $e() {
            var u;
            return $("var"), u = Ae(), Ee(), g.createVariableDeclaration(u, "var");
          }
          function je(u) {
            var y, _;
            return _ = v, $(u), y = Ae(u), Ee(), g.markEnd(g.createVariableDeclaration(y, u), _);
          }
          function Qe() {
            return C(";"), g.createEmptyStatement();
          }
          function ut() {
            var u = G();
            return Ee(), g.createExpressionStatement(u);
          }
          function st() {
            var u, y, _;
            return $("if"), C("("), u = G(), C(")"), y = Ot(), ae("else") ? (me(), _ = Ot()) : _ = null, g.createIfStatement(u, y, _);
          }
          function Rt() {
            var u, y, _;
            return $("do"), _ = k.inIteration, k.inIteration = !0, u = Ot(), k.inIteration = _, $("while"), C("("), y = G(), C(")"), D(";") && me(), g.createDoWhileStatement(u, y);
          }
          function $t() {
            var u, y, _;
            return $("while"), C("("), u = G(), C(")"), _ = k.inIteration, k.inIteration = !0, y = Ot(), k.inIteration = _, g.createWhileStatement(u, y);
          }
          function Or() {
            var u, y, _;
            return _ = v, u = me(), y = Ae(), g.markEnd(g.createVariableDeclaration(y, u.value), _);
          }
          function an() {
            var u, y, _, T, U, ne, _e;
            return u = y = _ = null, $("for"), C("("), D(";") ? me() : (ae("var") || ae("let") ? (k.allowIn = !1, u = Or(), k.allowIn = !0, u.declarations.length === 1 && ae("in") && (me(), T = u, U = G(), u = null)) : (k.allowIn = !1, u = G(), k.allowIn = !0, ae("in") && (Me(u) || be({}, h.InvalidLHSInForIn), me(), T = u, U = G(), u = null)), typeof T > "u" && C(";")), typeof T > "u" && (D(";") || (y = G()), C(";"), D(")") || (_ = G())), C(")"), _e = k.inIteration, k.inIteration = !0, ne = Ot(), k.inIteration = _e, typeof T > "u" ? g.createForStatement(u, y, _, ne) : g.createForInStatement(T, U, ne);
          }
          function wo() {
            var u = null, y;
            return $("continue"), m.charCodeAt(f) === 59 ? (me(), k.inIteration || ge({}, h.IllegalContinue), g.createContinueStatement(null)) : Ze() ? (k.inIteration || ge({}, h.IllegalContinue), g.createContinueStatement(null)) : (v.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(k.labelSet, y) || ge({}, h.UnknownLabel, u.name)), Ee(), u === null && !k.inIteration && ge({}, h.IllegalContinue), g.createContinueStatement(u));
          }
          function xo() {
            var u = null, y;
            return $("break"), m.charCodeAt(f) === 59 ? (me(), k.inIteration || k.inSwitch || ge({}, h.IllegalBreak), g.createBreakStatement(null)) : Ze() ? (k.inIteration || k.inSwitch || ge({}, h.IllegalBreak), g.createBreakStatement(null)) : (v.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(k.labelSet, y) || ge({}, h.UnknownLabel, u.name)), Ee(), u === null && !(k.inIteration || k.inSwitch) && ge({}, h.IllegalBreak), g.createBreakStatement(u));
          }
          function ru() {
            var u = null;
            return $("return"), k.inFunctionBody || be({}, h.IllegalReturn), m.charCodeAt(f) === 32 && X(m.charCodeAt(f + 1)) ? (u = G(), Ee(), g.createReturnStatement(u)) : Ze() ? g.createReturnStatement(null) : (D(";") || !D("}") && v.type !== o.EOF && (u = G()), Ee(), g.createReturnStatement(u));
          }
          function nu() {
            var u, y;
            return w && (O(), be({}, h.StrictModeWith)), $("with"), C("("), u = G(), C(")"), y = Ot(), g.createWithStatement(u, y);
          }
          function iu() {
            var u, y = [], _, T;
            for (T = v, ae("default") ? (me(), u = null) : ($("case"), u = G()), C(":"); f < x && !(D("}") || ae("default") || ae("case")); )
              _ = Ot(), y.push(_);
            return g.markEnd(g.createSwitchCase(u, y), T);
          }
          function su() {
            var u, y, _, T, U;
            if ($("switch"), C("("), u = G(), C(")"), C("{"), y = [], D("}"))
              return me(), g.createSwitchStatement(u, y);
            for (T = k.inSwitch, k.inSwitch = !0, U = !1; f < x && !D("}"); )
              _ = iu(), _.test === null && (U && ge({}, h.MultipleDefaultsInSwitch), U = !0), y.push(_);
            return k.inSwitch = T, C("}"), g.createSwitchStatement(u, y);
          }
          function ou() {
            var u;
            return $("throw"), Ze() && ge({}, h.NewlineAfterThrow), u = G(), Ee(), g.createThrowStatement(u);
          }
          function au() {
            var u, y, _;
            return _ = v, $("catch"), C("("), D(")") && Je(v), u = he(), w && ye(u.name) && be({}, h.StrictCatchVariable), C(")"), y = se(), g.markEnd(g.createCatchClause(u, y), _);
          }
          function lu() {
            var u, y = [], _ = null;
            return $("try"), u = se(), ae("catch") && y.push(au()), ae("finally") && (me(), _ = se()), y.length === 0 && !_ && ge({}, h.NoCatchOrFinally), g.createTryStatement(u, [], y, _);
          }
          function cu() {
            return $("debugger"), Ee(), g.createDebuggerStatement();
          }
          function Ot() {
            var u = v.type, y, _, T, U;
            if (u === o.EOF && Je(v), u === o.Punctuator && v.value === "{")
              return se();
            if (U = v, u === o.Punctuator)
              switch (v.value) {
                case ";":
                  return g.markEnd(Qe(), U);
                case "(":
                  return g.markEnd(ut(), U);
              }
            if (u === o.Keyword)
              switch (v.value) {
                case "break":
                  return g.markEnd(xo(), U);
                case "continue":
                  return g.markEnd(wo(), U);
                case "debugger":
                  return g.markEnd(cu(), U);
                case "do":
                  return g.markEnd(Rt(), U);
                case "for":
                  return g.markEnd(an(), U);
                case "function":
                  return g.markEnd(Rs(), U);
                case "if":
                  return g.markEnd(st(), U);
                case "return":
                  return g.markEnd(ru(), U);
                case "switch":
                  return g.markEnd(su(), U);
                case "throw":
                  return g.markEnd(ou(), U);
                case "try":
                  return g.markEnd(lu(), U);
                case "var":
                  return g.markEnd($e(), U);
                case "while":
                  return g.markEnd($t(), U);
                case "with":
                  return g.markEnd(nu(), U);
              }
            return y = G(), y.type === c.Identifier && D(":") ? (me(), T = "$" + y.name, Object.prototype.hasOwnProperty.call(k.labelSet, T) && ge({}, h.Redeclaration, "Label", y.name), k.labelSet[T] = !0, _ = Ot(), delete k.labelSet[T], g.markEnd(g.createLabeledStatement(y, _), U)) : (Ee(), g.markEnd(g.createExpressionStatement(y), U));
          }
          function Un() {
            var u, y = [], _, T, U, ne, _e, Ne, et, Xe;
            for (Xe = v, C("{"); f < x && !(v.type !== o.StringLiteral || (_ = v, u = Ir(), y.push(u), u.expression.type !== c.Literal)); )
              T = m.slice(_.start + 1, _.end - 1), T === "use strict" ? (w = !0, U && be(U, h.StrictOctalLiteral)) : !U && _.octal && (U = _);
            for (ne = k.labelSet, _e = k.inIteration, Ne = k.inSwitch, et = k.inFunctionBody, k.labelSet = {}, k.inIteration = !1, k.inSwitch = !1, k.inFunctionBody = !0; f < x && !(D("}") || (u = Ir(), typeof u > "u")); )
              y.push(u);
            return C("}"), k.labelSet = ne, k.inIteration = _e, k.inSwitch = Ne, k.inFunctionBody = et, g.markEnd(g.createBlockStatement(y), Xe);
          }
          function Ps(u) {
            var y, _ = [], T, U, ne, _e, Ne;
            if (C("("), !D(")"))
              for (ne = {}; f < x && (T = v, y = he(), _e = "$" + T.value, w ? (ye(T.value) && (U = T, Ne = h.StrictParamName), Object.prototype.hasOwnProperty.call(ne, _e) && (U = T, Ne = h.StrictParamDupe)) : u || (ye(T.value) ? (u = T, Ne = h.StrictParamName) : ke(T.value) ? (u = T, Ne = h.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ne, _e) && (u = T, Ne = h.StrictParamDupe)), _.push(y), ne[_e] = !0, !D(")")); )
                C(",");
            return C(")"), {
              params: _,
              stricted: U,
              firstRestricted: u,
              message: Ne
            };
          }
          function Rs() {
            var u, y = [], _, T, U, ne, _e, Ne, et, Xe;
            return Xe = v, $("function"), T = v, u = he(), w ? ye(T.value) && be(T, h.StrictFunctionName) : ye(T.value) ? (_e = T, Ne = h.StrictFunctionName) : ke(T.value) && (_e = T, Ne = h.StrictReservedWord), ne = Ps(_e), y = ne.params, U = ne.stricted, _e = ne.firstRestricted, ne.message && (Ne = ne.message), et = w, _ = Un(), w && _e && ge(_e, Ne), w && U && be(U, Ne), w = et, g.markEnd(g.createFunctionDeclaration(u, y, [], _), Xe);
          }
          function uu() {
            var u, y = null, _, T, U, ne, _e = [], Ne, et, Xe;
            return Xe = v, $("function"), D("(") || (u = v, y = he(), w ? ye(u.value) && be(u, h.StrictFunctionName) : ye(u.value) ? (T = u, U = h.StrictFunctionName) : ke(u.value) && (T = u, U = h.StrictReservedWord)), ne = Ps(T), _e = ne.params, _ = ne.stricted, T = ne.firstRestricted, ne.message && (U = ne.message), et = w, Ne = Un(), w && T && ge(T, U), w && _ && be(_, U), w = et, g.markEnd(g.createFunctionExpression(y, _e, [], Ne), Xe);
          }
          function Ir() {
            if (v.type === o.Keyword)
              switch (v.value) {
                case "const":
                case "let":
                  return je(v.value);
                case "function":
                  return Rs();
                default:
                  return Ot();
              }
            if (v.type !== o.EOF)
              return Ot();
          }
          function hu() {
            for (var u, y = [], _, T, U; f < x && (_ = v, !(_.type !== o.StringLiteral || (u = Ir(), y.push(u), u.expression.type !== c.Literal))); )
              T = m.slice(_.start + 1, _.end - 1), T === "use strict" ? (w = !0, U && be(U, h.StrictOctalLiteral)) : !U && _.octal && (U = _);
            for (; f < x && (u = Ir(), !(typeof u > "u")); )
              y.push(u);
            return y;
          }
          function pu() {
            var u, y;
            return O(), ht(), y = v, w = !1, u = hu(), g.markEnd(g.createProgram(u), y);
          }
          function Os() {
            var u, y, _, T = [];
            for (u = 0; u < S.tokens.length; ++u)
              y = S.tokens[u], _ = {
                type: y.type,
                value: y.value
              }, S.range && (_.range = y.range), S.loc && (_.loc = y.loc), T.push(_);
            S.tokens = T;
          }
          function du(u, y) {
            var _, T, U;
            _ = String, typeof u != "string" && !(u instanceof String) && (u = _(u)), g = b, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, v = null, k = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, y = y || {}, y.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []);
            try {
              if (ht(), v.type === o.EOF)
                return S.tokens;
              for (T = me(); v.type !== o.EOF; )
                try {
                  T = me();
                } catch (ne) {
                  if (T = v, S.errors) {
                    S.errors.push(ne);
                    break;
                  } else
                    throw ne;
                }
              Os(), U = S.tokens, typeof S.comments < "u" && (U.comments = S.comments), typeof S.errors < "u" && (U.errors = S.errors);
            } catch (ne) {
              throw ne;
            } finally {
              S = {};
            }
            return U;
          }
          function fu(u, y) {
            var _, T;
            T = String, typeof u != "string" && !(u instanceof String) && (u = T(u)), g = b, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, v = null, k = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, typeof y < "u" && (S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, S.attachComment = typeof y.attachComment == "boolean" && y.attachComment, S.loc && y.source !== null && y.source !== void 0 && (S.source = T(y.source)), typeof y.tokens == "boolean" && y.tokens && (S.tokens = []), typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
            try {
              _ = pu(), typeof S.comments < "u" && (_.comments = S.comments), typeof S.tokens < "u" && (Os(), _.tokens = S.tokens), typeof S.errors < "u" && (_.errors = S.errors);
            } catch (U) {
              throw U;
            } finally {
              S = {};
            }
            return _;
          }
          s.version = "1.2.2", s.tokenize = du, s.parse = fu, s.Syntax = function() {
            var u, y = {};
            typeof Object.create == "function" && (y = /* @__PURE__ */ Object.create(null));
            for (u in c)
              c.hasOwnProperty(u) && (y[u] = c[u]);
            return typeof Object.freeze == "function" && Object.freeze(y), y;
          }();
        });
      }, {}], 1: [function(r, n, i) {
        (function(s) {
          var o = function() {
            var a = {
              trace: function() {
              },
              yy: {},
              symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
              terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
              productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
              performAction: function(h, d, b, m, w, f, E) {
                m.ast || (m.ast = l, l.initialize());
                var A = f.length - 1;
                switch (w) {
                  case 1:
                    return m.ast.set({ expression: { type: "root", value: f[A] } }), m.ast.unshift(), m.ast.yield();
                  case 2:
                    return m.ast.set({ expression: { type: "root", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 3:
                    return m.ast.unshift(), m.ast.yield();
                  case 4:
                    return m.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 5:
                    break;
                  case 6:
                    break;
                  case 7:
                    m.ast.set({ operation: "member" }), m.ast.push();
                    break;
                  case 8:
                    m.ast.set({ operation: "subscript" }), m.ast.push();
                    break;
                  case 9:
                    m.ast.set({ scope: "child" });
                    break;
                  case 10:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 11:
                    break;
                  case 12:
                    m.ast.set({ scope: "child", operation: "member" });
                    break;
                  case 13:
                    break;
                  case 14:
                    m.ast.set({ expression: { type: "wildcard", value: f[A] } });
                    break;
                  case 15:
                    m.ast.set({ expression: { type: "identifier", value: f[A] } });
                    break;
                  case 16:
                    m.ast.set({ expression: { type: "script_expression", value: f[A] } });
                    break;
                  case 17:
                    m.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                    break;
                  case 18:
                    break;
                  case 19:
                    m.ast.set({ scope: "child" });
                    break;
                  case 20:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 21:
                    break;
                  case 22:
                    break;
                  case 23:
                    break;
                  case 24:
                    f[A].length > 1 ? m.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                    break;
                  case 25:
                    this.$ = [f[A]];
                    break;
                  case 26:
                    this.$ = f[A - 2].concat(f[A]);
                    break;
                  case 27:
                    this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, m.ast.set(this.$);
                    break;
                  case 28:
                    this.$ = { expression: { type: "string_literal", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 29:
                    this.$ = { expression: { type: "slice", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 30:
                    this.$ = { expression: { type: "wildcard", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 31:
                    this.$ = { expression: { type: "script_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 32:
                    this.$ = { expression: { type: "filter_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 33:
                    this.$ = f[A];
                    break;
                  case 34:
                    this.$ = f[A];
                    break;
                }
              },
              table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
              defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
              parseError: function(h, d) {
                if (d.recoverable)
                  this.trace(h);
                else
                  throw new Error(h);
              },
              parse: function(h) {
                var d = this, b = [0], m = [null], w = [], f = this.table, E = "", A = 0, x = 0, g = 2, v = 1, k = w.slice.call(arguments, 1);
                this.lexer.setInput(h), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
                var S = this.lexer.yylloc;
                w.push(S);
                var R = this.lexer.options && this.lexer.options.ranges;
                typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
                function L() {
                  var Ie;
                  return Ie = d.lexer.lex() || v, typeof Ie != "number" && (Ie = d.symbols_[Ie] || Ie), Ie;
                }
                for (var F, z, j, ee, X = {}, ie, ce, ke, ye; ; ) {
                  if (z = b[b.length - 1], this.defaultActions[z] ? j = this.defaultActions[z] : ((F === null || typeof F > "u") && (F = L()), j = f[z] && f[z][F]), typeof j > "u" || !j.length || !j[0]) {
                    var Ce = "";
                    ye = [];
                    for (ie in f[z])
                      this.terminals_[ie] && ie > g && ye.push("'" + this.terminals_[ie] + "'");
                    this.lexer.showPosition ? Ce = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + ye.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : Ce = "Parse error on line " + (A + 1) + ": Unexpected " + (F == v ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(Ce, {
                      text: this.lexer.match,
                      token: this.terminals_[F] || F,
                      line: this.lexer.yylineno,
                      loc: S,
                      expected: ye
                    });
                  }
                  if (j[0] instanceof Array && j.length > 1)
                    throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + F);
                  switch (j[0]) {
                    case 1:
                      b.push(F), m.push(this.lexer.yytext), w.push(this.lexer.yylloc), b.push(j[1]), F = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                      break;
                    case 2:
                      if (ce = this.productions_[j[1]][1], X.$ = m[m.length - ce], X._$ = {
                        first_line: w[w.length - (ce || 1)].first_line,
                        last_line: w[w.length - 1].last_line,
                        first_column: w[w.length - (ce || 1)].first_column,
                        last_column: w[w.length - 1].last_column
                      }, R && (X._$.range = [
                        w[w.length - (ce || 1)].range[0],
                        w[w.length - 1].range[1]
                      ]), ee = this.performAction.apply(X, [
                        E,
                        x,
                        A,
                        this.yy,
                        j[1],
                        m,
                        w
                      ].concat(k)), typeof ee < "u")
                        return ee;
                      ce && (b = b.slice(0, -1 * ce * 2), m = m.slice(0, -1 * ce), w = w.slice(0, -1 * ce)), b.push(this.productions_[j[1]][0]), m.push(X.$), w.push(X._$), ke = f[b[b.length - 2]][b[b.length - 1]], b.push(ke);
                      break;
                    case 3:
                      return !0;
                  }
                }
                return !0;
              }
            }, l = {
              initialize: function() {
                this._nodes = [], this._node = {}, this._stash = [];
              },
              set: function(h) {
                for (var d in h) this._node[d] = h[d];
                return this._node;
              },
              node: function(h) {
                return arguments.length && (this._node = h), this._node;
              },
              push: function() {
                this._nodes.push(this._node), this._node = {};
              },
              unshift: function() {
                this._nodes.unshift(this._node), this._node = {};
              },
              yield: function() {
                var h = this._nodes;
                return this.initialize(), h;
              }
            }, c = /* @__PURE__ */ function() {
              var h = {
                EOF: 1,
                parseError: function(d, b) {
                  if (this.yy.parser)
                    this.yy.parser.parseError(d, b);
                  else
                    throw new Error(d);
                },
                // resets the lexer, sets new input
                setInput: function(d) {
                  return this._input = d, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                  }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
                },
                // consumes and returns one char from the input
                input: function() {
                  var d = this._input[0];
                  this.yytext += d, this.yyleng++, this.offset++, this.match += d, this.matched += d;
                  var b = d.match(/(?:\r\n?|\n).*/g);
                  return b ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), d;
                },
                // unshifts one char (or a string) into the input
                unput: function(d) {
                  var b = d.length, m = d.split(/(?:\r\n?|\n)/g);
                  this._input = d + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - b - 1), this.offset -= b;
                  var w = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
                  var f = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: m ? (m.length === w.length ? this.yylloc.first_column : 0) + w[w.length - m.length].length - m[0].length : this.yylloc.first_column - b
                  }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - b]), this.yyleng = this.yytext.length, this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function() {
                  return this._more = !0, this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function() {
                  if (this.options.backtrack_lexer)
                    this._backtrack = !0;
                  else
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                      text: "",
                      token: null,
                      line: this.yylineno
                    });
                  return this;
                },
                // retain first n characters of the match
                less: function(d) {
                  this.unput(this.match.slice(d));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function() {
                  var d = this.matched.substr(0, this.matched.length - this.match.length);
                  return (d.length > 20 ? "..." : "") + d.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function() {
                  var d = this.match;
                  return d.length < 20 && (d += this._input.substr(0, 20 - d.length)), (d.substr(0, 20) + (d.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function() {
                  var d = this.pastInput(), b = new Array(d.length + 1).join("-");
                  return d + this.upcomingInput() + `
` + b + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function(d, b) {
                  var m, w, f;
                  if (this.options.backtrack_lexer && (f = {
                    yylineno: this.yylineno,
                    yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                  }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), w = d[0].match(/(?:\r\n?|\n).*/g), w && (this.yylineno += w.length), this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: w ? w[w.length - 1].length - w[w.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + d[0].length
                  }, this.yytext += d[0], this.match += d[0], this.matches = d, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(d[0].length), this.matched += d[0], m = this.performAction.call(this, this.yy, this, b, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
                    return m;
                  if (this._backtrack) {
                    for (var E in f)
                      this[E] = f[E];
                    return !1;
                  }
                  return !1;
                },
                // return next match in input
                next: function() {
                  if (this.done)
                    return this.EOF;
                  this._input || (this.done = !0);
                  var d, b, m, w;
                  this._more || (this.yytext = "", this.match = "");
                  for (var f = this._currentRules(), E = 0; E < f.length; E++)
                    if (m = this._input.match(this.rules[f[E]]), m && (!b || m[0].length > b[0].length)) {
                      if (b = m, w = E, this.options.backtrack_lexer) {
                        if (d = this.test_match(m, f[E]), d !== !1)
                          return d;
                        if (this._backtrack) {
                          b = !1;
                          continue;
                        } else
                          return !1;
                      } else if (!this.options.flex)
                        break;
                    }
                  return b ? (d = this.test_match(b, f[w]), d !== !1 ? d : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                },
                // return next match that has a token
                lex: function() {
                  var d = this.next();
                  return d || this.lex();
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function(d) {
                  this.conditionStack.push(d);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function() {
                  var d = this.conditionStack.length - 1;
                  return d > 0 ? this.conditionStack.pop() : this.conditionStack[0];
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function() {
                  return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function(d) {
                  return d = this.conditionStack.length - 1 - Math.abs(d || 0), d >= 0 ? this.conditionStack[d] : "INITIAL";
                },
                // alias for begin(condition)
                pushState: function(d) {
                  this.begin(d);
                },
                // return the number of states currently on the stack
                stateStackSize: function() {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function(d, b, m, w) {
                  switch (m) {
                    case 0:
                      return 4;
                    case 1:
                      return 14;
                    case 2:
                      return 12;
                    case 3:
                      return 15;
                    case 4:
                      return 16;
                    case 5:
                      return 22;
                    case 6:
                      return 24;
                    case 7:
                      return 28;
                    case 8:
                      return 30;
                    case 9:
                      return 18;
                    case 10:
                      return b.yytext = b.yytext.substr(1, b.yyleng - 2), 32;
                    case 11:
                      return b.yytext = b.yytext.substr(1, b.yyleng - 2), 33;
                    case 12:
                      return 17;
                    case 13:
                      return 31;
                  }
                },
                rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
                conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
              };
              return h;
            }();
            a.lexer = c;
            function p() {
              this.yy = {};
            }
            return p.prototype = a, a.Parser = p, new p();
          }();
          typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
            return o.parse.apply(o, arguments);
          }, i.main = function(a) {
            a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
            var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
            return i.parser.parse(l);
          }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
        }).call(this, r("_process"));
      }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
        n.exports = {
          identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
          integer: "-?(?:0|[1-9][0-9]*)",
          qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
          q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
        };
      }, {}], 3: [function(r, n, i) {
        var s = r("./dict"), o = r("fs"), a = {
          lex: {
            macros: {
              esc: "\\\\",
              int: s.integer
            },
            rules: [
              ["\\$", "return 'DOLLAR'"],
              ["\\.\\.", "return 'DOT_DOT'"],
              ["\\.", "return 'DOT'"],
              ["\\*", "return 'STAR'"],
              [s.identifier, "return 'IDENTIFIER'"],
              ["\\[", "return '['"],
              ["\\]", "return ']'"],
              [",", "return ','"],
              ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
              ["{int}", "return 'INTEGER'"],
              [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
              [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
              ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
              ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
            ]
          },
          start: "JSON_PATH",
          bnf: {
            JSON_PATH: [
              ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
              ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
            ],
            PATH_COMPONENTS: [
              ["PATH_COMPONENT", ""],
              ["PATH_COMPONENTS PATH_COMPONENT", ""]
            ],
            PATH_COMPONENT: [
              ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
              ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
            ],
            MEMBER_COMPONENT: [
              ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_MEMBER_COMPONENT: [
              ["DOT MEMBER_EXPRESSION", ""]
            ],
            LEADING_CHILD_MEMBER_EXPRESSION: [
              ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
            ],
            DESCENDANT_MEMBER_COMPONENT: [
              ["DOT_DOT MEMBER_EXPRESSION", ""]
            ],
            MEMBER_EXPRESSION: [
              ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
              ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
              ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
              ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
              ["END", ""]
            ],
            SUBSCRIPT_COMPONENT: [
              ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_SUBSCRIPT_COMPONENT: [
              ["[ SUBSCRIPT ]", ""]
            ],
            DESCENDANT_SUBSCRIPT_COMPONENT: [
              ["DOT_DOT [ SUBSCRIPT ]", ""]
            ],
            SUBSCRIPT: [
              ["SUBSCRIPT_EXPRESSION", ""],
              ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
            ],
            SUBSCRIPT_EXPRESSION_LIST: [
              ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
              ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
            ],
            SUBSCRIPT_EXPRESSION_LISTABLE: [
              ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
              ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
              ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
            ],
            SUBSCRIPT_EXPRESSION: [
              ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
              ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
              ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
            ],
            STRING_LITERAL: [
              ["QQ_STRING", "$$ = $1"],
              ["Q_STRING", "$$ = $1"]
            ]
          }
        };
        o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
      }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
        var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
          return this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.traverse = b(!0), this.descend = b();
        }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
          var g = [x.operation, x.scope, x.expression.type].join("-"), v = this._fns[g];
          if (!v) throw new Error("couldn't resolve key: " + g);
          return v.bind(this);
        }, c.prototype.register = function(x, g) {
          if (!g instanceof Function)
            throw new Error("handler must be a function");
          this._fns[x] = g;
        }, c.prototype._fns = {
          "member-child-identifier": function(x, g) {
            var v = x.expression.value, k = g.value;
            if (k instanceof Object && v in k)
              return [{ value: k[v], path: g.path.concat(v) }];
          },
          "member-descendant-identifier": w(function(x, g, v) {
            return x == v;
          }),
          "subscript-child-numeric_literal": m(function(x, g, v) {
            return x === v;
          }),
          "member-child-numeric_literal": m(function(x, g, v) {
            return String(x) === String(v);
          }),
          "subscript-descendant-numeric_literal": w(function(x, g, v) {
            return x === v;
          }),
          "member-child-wildcard": m(function() {
            return !0;
          }),
          "member-descendant-wildcard": w(function() {
            return !0;
          }),
          "subscript-descendant-wildcard": w(function() {
            return !0;
          }),
          "subscript-child-wildcard": m(function() {
            return !0;
          }),
          "subscript-child-slice": function(x, g) {
            if (h(g.value)) {
              var v = x.expression.value.split(":").map(A), k = g.value.map(function(S, R) {
                return { value: S, path: g.path.concat(R) };
              });
              return o.apply(null, [k].concat(v));
            }
          },
          "subscript-child-union": function(x, g) {
            var v = [];
            return x.expression.value.forEach(function(k) {
              var S = { operation: "subscript", scope: "child", expression: k.expression }, R = this.resolve(S), L = R(S, g);
              L && (v = v.concat(L));
            }, this), E(v);
          },
          "subscript-descendant-union": function(x, g, v) {
            var k = r(".."), S = this, R = [], L = k.nodes(g, "$..*").slice(1);
            return L.forEach(function(F) {
              R.length >= v || x.expression.value.forEach(function(z) {
                var j = { operation: "subscript", scope: "child", expression: z.expression }, ee = S.resolve(j), X = ee(j, F);
                R = R.concat(X);
              });
            }), E(R);
          },
          "subscript-child-filter_expression": function(x, g, v) {
            var k = x.expression.value.slice(2, -1), S = s.parse(k).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.descend(g, null, R, v);
          },
          "subscript-descendant-filter_expression": function(x, g, v) {
            var k = x.expression.value.slice(2, -1), S = s.parse(k).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.traverse(g, null, R, v);
          },
          "subscript-child-script_expression": function(x, g) {
            var v = x.expression.value.slice(1, -1);
            return p(g, v, "$[{{value}}]");
          },
          "member-child-script_expression": function(x, g) {
            var v = x.expression.value.slice(1, -1);
            return p(g, v, "$.{{value}}");
          },
          "member-descendant-script_expression": function(x, g) {
            var v = x.expression.value.slice(1, -1);
            return p(g, v, "$..value");
          }
        }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
        function p(x, g, v) {
          var k = r("./index"), S = s.parse(g).body[0].expression, R = f(S, { "@": x.value }), L = v.replace(/\{\{\s*value\s*\}\}/g, R), F = k.nodes(x.value, L);
          return F.forEach(function(z) {
            z.path = x.path.concat(z.path.slice(1));
          }), F;
        }
        function h(x) {
          return Array.isArray(x);
        }
        function d(x) {
          return x && !(x instanceof Array) && x instanceof Object;
        }
        function b(x) {
          return function(g, v, k, S) {
            var R = g.value, L = g.path, F = [], z = (function(j, ee) {
              h(j) ? (j.forEach(function(X, ie) {
                F.length >= S || k(ie, X, v) && F.push({ path: ee.concat(ie), value: X });
              }), j.forEach(function(X, ie) {
                F.length >= S || x && z(X, ee.concat(ie));
              })) : d(j) && (this.keys(j).forEach(function(X) {
                F.length >= S || k(X, j[X], v) && F.push({ path: ee.concat(X), value: j[X] });
              }), this.keys(j).forEach(function(X) {
                F.length >= S || x && z(j[X], ee.concat(X));
              }));
            }).bind(this);
            return z(R, L), F;
          };
        }
        function m(x) {
          return function(g, v, k) {
            return this.descend(v, g.expression.value, x, k);
          };
        }
        function w(x) {
          return function(g, v, k) {
            return this.traverse(v, g.expression.value, x, k);
          };
        }
        function f() {
          try {
            return a.apply(this, arguments);
          } catch {
          }
        }
        function E(x) {
          return x = x.filter(function(g) {
            return g;
          }), l(
            x,
            function(g) {
              return g.path.map(function(v) {
                return String(v).replace("-", "--");
              }).join("-");
            }
          );
        }
        function A(x) {
          var g = String(x);
          return g.match(/^-?[0-9]+$/) ? parseInt(g) : null;
        }
        n.exports = c;
      }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
        var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
          this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.parser = new a(), this.handlers = new l();
        }, c.prototype.parse = function(d) {
          return s.ok(p(d), "we need a path"), this.parser.parse(d);
        }, c.prototype.parent = function(d, b) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
          var m = this.nodes(d, b)[0];
          return m.path.pop(), this.value(d, m.path);
        }, c.prototype.apply = function(d, b, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), s.equal(typeof m, "function", "fn needs to be function");
          var w = this.nodes(d, b).sort(function(f, E) {
            return E.path.length - f.path.length;
          });
          return w.forEach(function(f) {
            var E = f.path.pop(), A = this.value(d, this.stringify(f.path)), x = f.value = m.call(d, A[E]);
            A[E] = x;
          }, this), w;
        }, c.prototype.value = function(d, b, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), arguments.length >= 3) {
            var w = this.nodes(d, b).shift();
            if (!w) return this._vivify(d, b, m);
            var f = w.path.slice(-1).shift(), E = this.parent(d, this.stringify(w.path));
            E[f] = m;
          }
          return this.query(d, this.stringify(b), 1).shift();
        }, c.prototype._vivify = function(d, b, m) {
          var w = this;
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
          var f = this.parser.parse(b).map(function(A) {
            return A.expression.value;
          }), E = function(A, x) {
            var g = A.pop(), v = w.value(d, A);
            v || (E(A.concat(), typeof g == "string" ? {} : []), v = w.value(d, A)), v[g] = x;
          };
          return E(f, m), this.query(d, b)[0];
        }, c.prototype.query = function(d, b, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(p(b), "we need a path");
          var w = this.nodes(d, b, m).map(function(f) {
            return f.value;
          });
          return w;
        }, c.prototype.paths = function(d, b, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
          var w = this.nodes(d, b, m).map(function(f) {
            return f.path;
          });
          return w;
        }, c.prototype.nodes = function(d, b, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), m === 0) return [];
          var w = this.parser.parse(b), f = this.handlers, E = [{ path: ["$"], value: d }], A = [];
          return w.length && w[0].expression.type == "root" && w.shift(), w.length ? (w.forEach(function(x, g) {
            if (!(A.length >= m)) {
              var v = f.resolve(x), k = [];
              E.forEach(function(S) {
                if (!(A.length >= m)) {
                  var R = v(x, S, m);
                  g == w.length - 1 ? A = A.concat(R || []) : k = k.concat(R || []);
                }
              }), E = k;
            }
          }), m ? A.slice(0, m) : A) : E;
        }, c.prototype.stringify = function(d) {
          s.ok(d, "we need a path");
          var b = "$", m = {
            "descendant-member": "..{{value}}",
            "child-member": ".{{value}}",
            "descendant-subscript": "..[{{value}}]",
            "child-subscript": "[{{value}}]"
          };
          return d = this._normalize(d), d.forEach(function(w) {
            if (w.expression.type != "root") {
              var f = [w.scope, w.operation].join("-"), E = m[f], A;
              if (w.expression.type == "string_literal" ? A = JSON.stringify(w.expression.value) : A = w.expression.value, !E) throw new Error("couldn't find template " + f);
              b += E.replace(/{{value}}/, A);
            }
          }), b;
        }, c.prototype._normalize = function(d) {
          if (s.ok(d, "we need a path"), typeof d == "string")
            return this.parser.parse(d);
          if (Array.isArray(d) && typeof d[0] == "string") {
            var b = [{ expression: { type: "root", value: "$" } }];
            return d.forEach(function(m, w) {
              if (!(m == "$" && w === 0))
                if (typeof m == "string" && m.match("^" + o.identifier + "$"))
                  b.push({
                    operation: "member",
                    scope: "child",
                    expression: { value: m, type: "identifier" }
                  });
                else {
                  var f = typeof m == "number" ? "numeric_literal" : "string_literal";
                  b.push({
                    operation: "subscript",
                    scope: "child",
                    expression: { value: m, type: f }
                  });
                }
            }), b;
          } else if (Array.isArray(d) && typeof d[0] == "object")
            return d;
          throw new Error("couldn't understand path " + d);
        };
        function p(d) {
          return Object.prototype.toString.call(d) == "[object String]";
        }
        c.Handlers = l, c.Parser = a;
        var h = new c();
        h.JSONPath = c, n.exports = h;
      }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
        var s = r("./grammar"), o = r("../generated/parser"), a = function() {
          var l = new o.Parser(), c = l.parseError;
          return l.yy.parseError = function() {
            l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
          }, l;
        };
        a.grammar = s, n.exports = a;
      }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
        n.exports = function(o, a, l, c) {
          if (typeof a == "string") throw new Error("start cannot be a string");
          if (typeof l == "string") throw new Error("end cannot be a string");
          if (typeof c == "string") throw new Error("step cannot be a string");
          var p = o.length;
          if (c === 0) throw new Error("step cannot be zero");
          if (c = c ? s(c) : 1, a = a < 0 ? p + a : a, l = l < 0 ? p + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : p - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? p : -1)), a = c > 0 ? Math.max(0, a) : Math.min(p, a), l = c > 0 ? Math.min(l, p) : Math.max(-1, l), c > 0 && l <= a) return [];
          if (c < 0 && a <= l) return [];
          for (var h = [], d = a; d != l && !(c < 0 && d <= l || c > 0 && d >= l); d += c)
            h.push(o[d]);
          return h;
        };
        function s(o) {
          return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
        }
      }, {}], 8: [function(r, n, i) {
        var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = b;
        l.AssertionError = function(g) {
          this.name = "AssertionError", this.actual = g.actual, this.expected = g.expected, this.operator = g.operator, g.message ? (this.message = g.message, this.generatedMessage = !1) : (this.message = h(this), this.generatedMessage = !0);
          var v = g.stackStartFunction || d;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, v);
          else {
            var k = new Error();
            if (k.stack) {
              var S = k.stack, R = v.name, L = S.indexOf(`
` + R);
              if (L >= 0) {
                var F = S.indexOf(`
`, L + 1);
                S = S.substring(F + 1);
              }
              this.stack = S;
            }
          }
        }, s.inherits(l.AssertionError, Error);
        function c(g, v) {
          return s.isUndefined(v) ? "" + v : s.isNumber(v) && !isFinite(v) || s.isFunction(v) || s.isRegExp(v) ? v.toString() : v;
        }
        function p(g, v) {
          return s.isString(g) ? g.length < v ? g : g.slice(0, v) : g;
        }
        function h(g) {
          return p(JSON.stringify(g.actual, c), 128) + " " + g.operator + " " + p(JSON.stringify(g.expected, c), 128);
        }
        function d(g, v, k, S, R) {
          throw new l.AssertionError({
            message: k,
            actual: g,
            expected: v,
            operator: S,
            stackStartFunction: R
          });
        }
        l.fail = d;
        function b(g, v) {
          g || d(g, !0, v, "==", l.ok);
        }
        l.ok = b, l.equal = function(g, v, k) {
          g != v && d(g, v, k, "==", l.equal);
        }, l.notEqual = function(g, v, k) {
          g == v && d(g, v, k, "!=", l.notEqual);
        }, l.deepEqual = function(g, v, k) {
          m(g, v) || d(g, v, k, "deepEqual", l.deepEqual);
        };
        function m(g, v) {
          if (g === v)
            return !0;
          if (s.isBuffer(g) && s.isBuffer(v)) {
            if (g.length != v.length) return !1;
            for (var k = 0; k < g.length; k++)
              if (g[k] !== v[k]) return !1;
            return !0;
          } else return s.isDate(g) && s.isDate(v) ? g.getTime() === v.getTime() : s.isRegExp(g) && s.isRegExp(v) ? g.source === v.source && g.global === v.global && g.multiline === v.multiline && g.lastIndex === v.lastIndex && g.ignoreCase === v.ignoreCase : !s.isObject(g) && !s.isObject(v) ? g == v : f(g, v);
        }
        function w(g) {
          return Object.prototype.toString.call(g) == "[object Arguments]";
        }
        function f(g, v) {
          if (s.isNullOrUndefined(g) || s.isNullOrUndefined(v) || g.prototype !== v.prototype) return !1;
          if (s.isPrimitive(g) || s.isPrimitive(v))
            return g === v;
          var k = w(g), S = w(v);
          if (k && !S || !k && S)
            return !1;
          if (k)
            return g = o.call(g), v = o.call(v), m(g, v);
          var R = x(g), L = x(v), F, z;
          if (R.length != L.length)
            return !1;
          for (R.sort(), L.sort(), z = R.length - 1; z >= 0; z--)
            if (R[z] != L[z])
              return !1;
          for (z = R.length - 1; z >= 0; z--)
            if (F = R[z], !m(g[F], v[F])) return !1;
          return !0;
        }
        l.notDeepEqual = function(g, v, k) {
          m(g, v) && d(g, v, k, "notDeepEqual", l.notDeepEqual);
        }, l.strictEqual = function(g, v, k) {
          g !== v && d(g, v, k, "===", l.strictEqual);
        }, l.notStrictEqual = function(g, v, k) {
          g === v && d(g, v, k, "!==", l.notStrictEqual);
        };
        function E(g, v) {
          return !g || !v ? !1 : Object.prototype.toString.call(v) == "[object RegExp]" ? v.test(g) : g instanceof v ? !0 : v.call({}, g) === !0;
        }
        function A(g, v, k, S) {
          var R;
          s.isString(k) && (S = k, k = null);
          try {
            v();
          } catch (L) {
            R = L;
          }
          if (S = (k && k.name ? " (" + k.name + ")." : ".") + (S ? " " + S : "."), g && !R && d(R, k, "Missing expected exception" + S), !g && E(R, k) && d(R, k, "Got unwanted exception" + S), g && R && k && !E(R, k) || !g && R)
            throw R;
        }
        l.throws = function(g, v, k) {
          A.apply(this, [!0].concat(o.call(arguments)));
        }, l.doesNotThrow = function(g, v) {
          A.apply(this, [!1].concat(o.call(arguments)));
        }, l.ifError = function(g) {
          if (g)
            throw g;
        };
        var x = Object.keys || function(g) {
          var v = [];
          for (var k in g)
            a.call(g, k) && v.push(k);
          return v;
        };
      }, { "util/": 11 }], 9: [function(r, n, i) {
        typeof Object.create == "function" ? n.exports = function(s, o) {
          s.super_ = o, s.prototype = Object.create(o.prototype, {
            constructor: {
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : n.exports = function(s, o) {
          s.super_ = o;
          var a = function() {
          };
          a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
        };
      }, {}], 10: [function(r, n, i) {
        n.exports = function(s) {
          return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
        };
      }, {}], 11: [function(r, n, i) {
        (function(s, o) {
          var a = /%[sdj%]/g;
          i.format = function(O) {
            if (!L(O)) {
              for (var N = [], Z = 0; Z < arguments.length; Z++)
                N.push(p(arguments[Z]));
              return N.join(" ");
            }
            for (var Z = 1, re = arguments, le = re.length, te = String(O).replace(a, function(H) {
              if (H === "%%") return "%";
              if (Z >= le) return H;
              switch (H) {
                case "%s":
                  return String(re[Z++]);
                case "%d":
                  return Number(re[Z++]);
                case "%j":
                  try {
                    return JSON.stringify(re[Z++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return H;
              }
            }), oe = re[Z]; Z < le; oe = re[++Z])
              k(oe) || !ee(oe) ? te += " " + oe : te += " " + p(oe);
            return te;
          }, i.deprecate = function(O, N) {
            if (z(o.process))
              return function() {
                return i.deprecate(O, N).apply(this, arguments);
              };
            if (s.noDeprecation === !0)
              return O;
            var Z = !1;
            function re() {
              if (!Z) {
                if (s.throwDeprecation)
                  throw new Error(N);
                s.traceDeprecation ? console.trace(N) : console.error(N), Z = !0;
              }
              return O.apply(this, arguments);
            }
            return re;
          };
          var l = {}, c;
          i.debuglog = function(O) {
            if (z(c) && (c = s.env.NODE_DEBUG || ""), O = O.toUpperCase(), !l[O])
              if (new RegExp("\\b" + O + "\\b", "i").test(c)) {
                var N = s.pid;
                l[O] = function() {
                  var Z = i.format.apply(i, arguments);
                  console.error("%s %d: %s", O, N, Z);
                };
              } else
                l[O] = function() {
                };
            return l[O];
          };
          function p(O, N) {
            var Z = {
              seen: [],
              stylize: d
            };
            return arguments.length >= 3 && (Z.depth = arguments[2]), arguments.length >= 4 && (Z.colors = arguments[3]), v(N) ? Z.showHidden = N : N && i._extend(Z, N), z(Z.showHidden) && (Z.showHidden = !1), z(Z.depth) && (Z.depth = 2), z(Z.colors) && (Z.colors = !1), z(Z.customInspect) && (Z.customInspect = !0), Z.colors && (Z.stylize = h), m(Z, O, Z.depth);
          }
          i.inspect = p, p.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, p.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function h(O, N) {
            var Z = p.styles[N];
            return Z ? "\x1B[" + p.colors[Z][0] + "m" + O + "\x1B[" + p.colors[Z][1] + "m" : O;
          }
          function d(O, N) {
            return O;
          }
          function b(O) {
            var N = {};
            return O.forEach(function(Z, re) {
              N[Z] = !0;
            }), N;
          }
          function m(O, N, Z) {
            if (O.customInspect && N && ce(N.inspect) && // Filter out the util module, it's inspect function is special
            N.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
            !(N.constructor && N.constructor.prototype === N)) {
              var re = N.inspect(Z, O);
              return L(re) || (re = m(O, re, Z)), re;
            }
            var le = w(O, N);
            if (le)
              return le;
            var te = Object.keys(N), oe = b(te);
            if (O.showHidden && (te = Object.getOwnPropertyNames(N)), ie(N) && (te.indexOf("message") >= 0 || te.indexOf("description") >= 0))
              return f(N);
            if (te.length === 0) {
              if (ce(N)) {
                var fe = N.name ? ": " + N.name : "";
                return O.stylize("[Function" + fe + "]", "special");
              }
              if (j(N))
                return O.stylize(RegExp.prototype.toString.call(N), "regexp");
              if (X(N))
                return O.stylize(Date.prototype.toString.call(N), "date");
              if (ie(N))
                return f(N);
            }
            var H = "", J = !1, Se = ["{", "}"];
            if (g(N) && (J = !0, Se = ["[", "]"]), ce(N)) {
              var Re = N.name ? ": " + N.name : "";
              H = " [Function" + Re + "]";
            }
            if (j(N) && (H = " " + RegExp.prototype.toString.call(N)), X(N) && (H = " " + Date.prototype.toUTCString.call(N)), ie(N) && (H = " " + f(N)), te.length === 0 && (!J || N.length == 0))
              return Se[0] + H + Se[1];
            if (Z < 0)
              return j(N) ? O.stylize(RegExp.prototype.toString.call(N), "regexp") : O.stylize("[Object]", "special");
            O.seen.push(N);
            var Fe;
            return J ? Fe = E(O, N, Z, oe, te) : Fe = te.map(function(Le) {
              return A(O, N, Z, oe, Le, J);
            }), O.seen.pop(), x(Fe, H, Se);
          }
          function w(O, N) {
            if (z(N))
              return O.stylize("undefined", "undefined");
            if (L(N)) {
              var Z = "'" + JSON.stringify(N).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return O.stylize(Z, "string");
            }
            if (R(N))
              return O.stylize("" + N, "number");
            if (v(N))
              return O.stylize("" + N, "boolean");
            if (k(N))
              return O.stylize("null", "null");
          }
          function f(O) {
            return "[" + Error.prototype.toString.call(O) + "]";
          }
          function E(O, N, Z, re, le) {
            for (var te = [], oe = 0, fe = N.length; oe < fe; ++oe)
              ue(N, String(oe)) ? te.push(A(
                O,
                N,
                Z,
                re,
                String(oe),
                !0
              )) : te.push("");
            return le.forEach(function(H) {
              H.match(/^\d+$/) || te.push(A(
                O,
                N,
                Z,
                re,
                H,
                !0
              ));
            }), te;
          }
          function A(O, N, Z, re, le, te) {
            var oe, fe, H;
            if (H = Object.getOwnPropertyDescriptor(N, le) || { value: N[le] }, H.get ? H.set ? fe = O.stylize("[Getter/Setter]", "special") : fe = O.stylize("[Getter]", "special") : H.set && (fe = O.stylize("[Setter]", "special")), ue(re, le) || (oe = "[" + le + "]"), fe || (O.seen.indexOf(H.value) < 0 ? (k(Z) ? fe = m(O, H.value, null) : fe = m(O, H.value, Z - 1), fe.indexOf(`
`) > -1 && (te ? fe = fe.split(`
`).map(function(J) {
              return "  " + J;
            }).join(`
`).substr(2) : fe = `
` + fe.split(`
`).map(function(J) {
              return "   " + J;
            }).join(`
`))) : fe = O.stylize("[Circular]", "special")), z(oe)) {
              if (te && le.match(/^\d+$/))
                return fe;
              oe = JSON.stringify("" + le), oe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (oe = oe.substr(1, oe.length - 2), oe = O.stylize(oe, "name")) : (oe = oe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), oe = O.stylize(oe, "string"));
            }
            return oe + ": " + fe;
          }
          function x(O, N, Z) {
            var re = O.reduce(function(le, te) {
              return te.indexOf(`
`) >= 0, le + te.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return re > 60 ? Z[0] + (N === "" ? "" : N + `
 `) + " " + O.join(`,
  `) + " " + Z[1] : Z[0] + N + " " + O.join(", ") + " " + Z[1];
          }
          function g(O) {
            return Array.isArray(O);
          }
          i.isArray = g;
          function v(O) {
            return typeof O == "boolean";
          }
          i.isBoolean = v;
          function k(O) {
            return O === null;
          }
          i.isNull = k;
          function S(O) {
            return O == null;
          }
          i.isNullOrUndefined = S;
          function R(O) {
            return typeof O == "number";
          }
          i.isNumber = R;
          function L(O) {
            return typeof O == "string";
          }
          i.isString = L;
          function F(O) {
            return typeof O == "symbol";
          }
          i.isSymbol = F;
          function z(O) {
            return O === void 0;
          }
          i.isUndefined = z;
          function j(O) {
            return ee(O) && ye(O) === "[object RegExp]";
          }
          i.isRegExp = j;
          function ee(O) {
            return typeof O == "object" && O !== null;
          }
          i.isObject = ee;
          function X(O) {
            return ee(O) && ye(O) === "[object Date]";
          }
          i.isDate = X;
          function ie(O) {
            return ee(O) && (ye(O) === "[object Error]" || O instanceof Error);
          }
          i.isError = ie;
          function ce(O) {
            return typeof O == "function";
          }
          i.isFunction = ce;
          function ke(O) {
            return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || // ES6 symbol
            typeof O > "u";
          }
          i.isPrimitive = ke, i.isBuffer = r("./support/isBuffer");
          function ye(O) {
            return Object.prototype.toString.call(O);
          }
          function Ce(O) {
            return O < 10 ? "0" + O.toString(10) : O.toString(10);
          }
          var Ie = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function Te() {
            var O = /* @__PURE__ */ new Date(), N = [
              Ce(O.getHours()),
              Ce(O.getMinutes()),
              Ce(O.getSeconds())
            ].join(":");
            return [O.getDate(), Ie[O.getMonth()], N].join(" ");
          }
          i.log = function() {
            console.log("%s - %s", Te(), i.format.apply(i, arguments));
          }, i.inherits = r("inherits"), i._extend = function(O, N) {
            if (!N || !ee(N)) return O;
            for (var Z = Object.keys(N), re = Z.length; re--; )
              O[Z[re]] = N[Z[re]];
            return O;
          };
          function ue(O, N) {
            return Object.prototype.hasOwnProperty.call(O, N);
          }
        }).call(this, r("_process"), typeof Ak < "u" ? Ak : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
      }, {}], 13: [function(r, n, i) {
        (function(s) {
          function o(p, h) {
            for (var d = 0, b = p.length - 1; b >= 0; b--) {
              var m = p[b];
              m === "." ? p.splice(b, 1) : m === ".." ? (p.splice(b, 1), d++) : d && (p.splice(b, 1), d--);
            }
            if (h)
              for (; d--; d)
                p.unshift("..");
            return p;
          }
          i.resolve = function() {
            for (var p = "", h = !1, d = arguments.length - 1; d >= -1 && !h; d--) {
              var b = d >= 0 ? arguments[d] : s.cwd();
              if (typeof b != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              b && (p = b + "/" + p, h = b.charAt(0) === "/");
            }
            return p = o(l(p.split("/"), function(m) {
              return !!m;
            }), !h).join("/"), (h ? "/" : "") + p || ".";
          }, i.normalize = function(p) {
            var h = i.isAbsolute(p), d = c(p, -1) === "/";
            return p = o(l(p.split("/"), function(b) {
              return !!b;
            }), !h).join("/"), !p && !h && (p = "."), p && d && (p += "/"), (h ? "/" : "") + p;
          }, i.isAbsolute = function(p) {
            return p.charAt(0) === "/";
          }, i.join = function() {
            var p = Array.prototype.slice.call(arguments, 0);
            return i.normalize(l(p, function(h, d) {
              if (typeof h != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return h;
            }).join("/"));
          }, i.relative = function(p, h) {
            p = i.resolve(p).substr(1), h = i.resolve(h).substr(1);
            function d(x) {
              for (var g = 0; g < x.length && x[g] === ""; g++)
                ;
              for (var v = x.length - 1; v >= 0 && x[v] === ""; v--)
                ;
              return g > v ? [] : x.slice(g, v - g + 1);
            }
            for (var b = d(p.split("/")), m = d(h.split("/")), w = Math.min(b.length, m.length), f = w, E = 0; E < w; E++)
              if (b[E] !== m[E]) {
                f = E;
                break;
              }
            for (var A = [], E = f; E < b.length; E++)
              A.push("..");
            return A = A.concat(m.slice(f)), A.join("/");
          }, i.sep = "/", i.delimiter = ":", i.dirname = function(p) {
            if (typeof p != "string" && (p = p + ""), p.length === 0) return ".";
            for (var h = p.charCodeAt(0), d = h === 47, b = -1, m = !0, w = p.length - 1; w >= 1; --w)
              if (h = p.charCodeAt(w), h === 47) {
                if (!m) {
                  b = w;
                  break;
                }
              } else
                m = !1;
            return b === -1 ? d ? "/" : "." : d && b === 1 ? "/" : p.slice(0, b);
          };
          function a(p) {
            typeof p != "string" && (p = p + "");
            var h = 0, d = -1, b = !0, m;
            for (m = p.length - 1; m >= 0; --m)
              if (p.charCodeAt(m) === 47) {
                if (!b) {
                  h = m + 1;
                  break;
                }
              } else d === -1 && (b = !1, d = m + 1);
            return d === -1 ? "" : p.slice(h, d);
          }
          i.basename = function(p, h) {
            var d = a(p);
            return h && d.substr(-1 * h.length) === h && (d = d.substr(0, d.length - h.length)), d;
          }, i.extname = function(p) {
            typeof p != "string" && (p = p + "");
            for (var h = -1, d = 0, b = -1, m = !0, w = 0, f = p.length - 1; f >= 0; --f) {
              var E = p.charCodeAt(f);
              if (E === 47) {
                if (!m) {
                  d = f + 1;
                  break;
                }
                continue;
              }
              b === -1 && (m = !1, b = f + 1), E === 46 ? h === -1 ? h = f : w !== 1 && (w = 1) : h !== -1 && (w = -1);
            }
            return h === -1 || b === -1 || // We saw a non-dot character immediately before the dot
            w === 0 || // The (right-most) trimmed path component is exactly '..'
            w === 1 && h === b - 1 && h === d + 1 ? "" : p.slice(h, b);
          };
          function l(p, h) {
            if (p.filter) return p.filter(h);
            for (var d = [], b = 0; b < p.length; b++)
              h(p[b], b, p) && d.push(p[b]);
            return d;
          }
          var c = "ab".substr(-1) === "b" ? function(p, h, d) {
            return p.substr(h, d);
          } : function(p, h, d) {
            return h < 0 && (h = p.length + h), p.substr(h, d);
          };
        }).call(this, r("_process"));
      }, { _process: 14 }], 14: [function(r, n, i) {
        var s = n.exports = {}, o, a;
        function l() {
          throw new Error("setTimeout has not been defined");
        }
        function c() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? o = setTimeout : o = l;
          } catch {
            o = l;
          }
          try {
            typeof clearTimeout == "function" ? a = clearTimeout : a = c;
          } catch {
            a = c;
          }
        })();
        function p(g) {
          if (o === setTimeout)
            return setTimeout(g, 0);
          if ((o === l || !o) && setTimeout)
            return o = setTimeout, setTimeout(g, 0);
          try {
            return o(g, 0);
          } catch {
            try {
              return o.call(null, g, 0);
            } catch {
              return o.call(this, g, 0);
            }
          }
        }
        function h(g) {
          if (a === clearTimeout)
            return clearTimeout(g);
          if ((a === c || !a) && clearTimeout)
            return a = clearTimeout, clearTimeout(g);
          try {
            return a(g);
          } catch {
            try {
              return a.call(null, g);
            } catch {
              return a.call(this, g);
            }
          }
        }
        var d = [], b = !1, m, w = -1;
        function f() {
          !b || !m || (b = !1, m.length ? d = m.concat(d) : w = -1, d.length && E());
        }
        function E() {
          if (!b) {
            var g = p(f);
            b = !0;
            for (var v = d.length; v; ) {
              for (m = d, d = []; ++w < v; )
                m && m[w].run();
              w = -1, v = d.length;
            }
            m = null, b = !1, h(g);
          }
        }
        s.nextTick = function(g) {
          var v = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var k = 1; k < arguments.length; k++)
              v[k - 1] = arguments[k];
          d.push(new A(g, v)), d.length === 1 && !b && p(E);
        };
        function A(g, v) {
          this.fun = g, this.array = v;
        }
        A.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
        function x() {
        }
        s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(g) {
          return [];
        }, s.binding = function(g) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(g) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 15: [function(r, n, i) {
        var s = r("escodegen").generate;
        n.exports = function(o, a) {
          a || (a = {});
          var l = {}, c = function p(h, d) {
            if (h.type === "Literal")
              return h.value;
            if (h.type === "UnaryExpression") {
              var b = p(h.argument);
              return h.operator === "+" ? +b : h.operator === "-" ? -b : h.operator === "~" ? ~b : h.operator === "!" ? !b : l;
            } else if (h.type === "ArrayExpression") {
              for (var m = [], w = 0, f = h.elements.length; w < f; w++) {
                var E = p(h.elements[w]);
                if (E === l) return l;
                m.push(E);
              }
              return m;
            } else if (h.type === "ObjectExpression") {
              for (var A = {}, w = 0; w < h.properties.length; w++) {
                var x = h.properties[w], g = x.value === null ? x.value : p(x.value);
                if (g === l) return l;
                A[x.key.value || x.key.name] = g;
              }
              return A;
            } else if (h.type === "BinaryExpression" || h.type === "LogicalExpression") {
              var f = p(h.left);
              if (f === l) return l;
              var v = p(h.right);
              if (v === l) return l;
              var k = h.operator;
              return k === "==" ? f == v : k === "===" ? f === v : k === "!=" ? f != v : k === "!==" ? f !== v : k === "+" ? f + v : k === "-" ? f - v : k === "*" ? f * v : k === "/" ? f / v : k === "%" ? f % v : k === "<" ? f < v : k === "<=" ? f <= v : k === ">" ? f > v : k === ">=" ? f >= v : k === "|" ? f | v : k === "&" ? f & v : k === "^" ? f ^ v : k === "&&" ? f && v : k === "||" ? f || v : l;
            } else {
              if (h.type === "Identifier")
                return {}.hasOwnProperty.call(a, h.name) ? a[h.name] : l;
              if (h.type === "ThisExpression")
                return {}.hasOwnProperty.call(a, "this") ? a.this : l;
              if (h.type === "CallExpression") {
                var S = p(h.callee);
                if (S === l || typeof S != "function") return l;
                var R = h.callee.object ? p(h.callee.object) : l;
                R === l && (R = null);
                for (var L = [], w = 0, f = h.arguments.length; w < f; w++) {
                  var E = p(h.arguments[w]);
                  if (E === l) return l;
                  L.push(E);
                }
                return S.apply(R, L);
              } else if (h.type === "MemberExpression") {
                var A = p(h.object);
                if (A === l || typeof A == "function")
                  return l;
                if (h.property.type === "Identifier")
                  return A[h.property.name];
                var x = p(h.property);
                return x === l ? l : A[x];
              } else if (h.type === "ConditionalExpression") {
                var b = p(h.test);
                return b === l ? l : p(b ? h.consequent : h.alternate);
              } else if (h.type === "ExpressionStatement") {
                var b = p(h.expression);
                return b === l ? l : b;
              } else {
                if (h.type === "ReturnStatement")
                  return p(h.argument);
                if (h.type === "FunctionExpression") {
                  var F = h.body.body, z = {};
                  Object.keys(a).forEach(function(Ie) {
                    z[Ie] = a[Ie];
                  });
                  for (var w = 0; w < h.params.length; w++) {
                    var j = h.params[w];
                    if (j.type == "Identifier")
                      a[j.name] = null;
                    else return l;
                  }
                  for (var w in F)
                    if (p(F[w]) === l)
                      return l;
                  a = z;
                  var ee = Object.keys(a), X = ee.map(function(Ie) {
                    return a[Ie];
                  });
                  return Function(ee.join(", "), "return " + s(h)).apply(null, X);
                } else if (h.type === "TemplateLiteral") {
                  for (var ie = "", w = 0; w < h.expressions.length; w++)
                    ie += p(h.quasis[w]), ie += p(h.expressions[w]);
                  return ie += p(h.quasis[w]), ie;
                } else if (h.type === "TaggedTemplateExpression") {
                  var ce = p(h.tag), ke = h.quasi, ye = ke.quasis.map(p), Ce = ke.expressions.map(p);
                  return ce.apply(null, [ye].concat(Ce));
                } else return h.type === "TemplateElement" ? h.value.cooked : l;
              }
            }
          }(o);
          return c === l ? void 0 : c;
        };
      }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
        n.exports = r("./lib/index");
      }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
    });
  }($k)), $k.exports;
}
lJ();
function cJ(t) {
  return t.replace(/\W+/g, "_").toLowerCase();
}
const Ex = {
  line: "line",
  stepline: "line",
  bar: "bar",
  column: "bar",
  lollipop: "bar",
  histogram: "histogram",
  scatter: "scatter",
  heatmap: "scatter",
  pie: "pastry",
  donut: "pastry",
  graph: "graph"
};
(() => {
  const t = {
    line: [],
    bar: [],
    pastry: [],
    scatter: [],
    histogram: [],
    graph: []
  };
  for (let e of Object.keys(Ex))
    t[Ex[e]].push(e);
  return t;
})();
function uJ(t) {
  var e, r, n = t.length;
  if (n === 1)
    e = 0, r = t[0][1];
  else {
    for (var i = 0, s = 0, o = 0, a = 0, l, c, p, h = 0; h < n; h++)
      l = t[h], c = l[0], p = l[1], i += c, s += p, o += c * c, a += c * p;
    e = (n * a - i * s) / (n * o - i * i), r = s / n - e * i / n;
  }
  return {
    m: e,
    b: r
  };
}
function hJ(t) {
  if (t.length === 0)
    throw new Error("min requires at least one data point");
  for (var e = t[0], r = 1; r < t.length; r++)
    t[r] < e && (e = t[r]);
  return e;
}
function pJ(t) {
  if (t.length === 0)
    throw new Error("max requires at least one data point");
  for (var e = t[0], r = 1; r < t.length; r++)
    t[r] > e && (e = t[r]);
  return e;
}
var dJ = Object.defineProperty, fJ = (t, e, r) => e in t ? dJ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Tp = (t, e, r) => (fJ(t, typeof e != "symbol" ? e + "" : e, r), r);
let gJ = class extends Error {
  constructor(e) {
    super(`line must have at least ${e} points`);
  }
}, mJ = class extends Error {
  constructor() {
    super("The first array in a zipped array must not be longer than the second.");
  }
};
const yJ = { width: 3, height: 1 };
function bJ(t, e, r, n) {
  let { start: i, end: s } = r;
  return i === s && (i -= 1, s += 1), {
    x: (t.x - e.start) * n.width / (e.end - e.start),
    y: (t.y - i) * n.height / (s - i)
  };
}
function Hf(t) {
  return Math.atan(t) * 180 / Math.PI;
}
function Gu(t, e) {
  const r = [];
  for (let n = 0; n < t; n++)
    r.push(e(n));
  return r;
}
function vJ(t, e) {
  if (t.length > e.length)
    throw new mJ();
  return t.map(function(r, n) {
    return [r, e[n]];
  });
}
let u0 = class Ep {
  /**
   * @param points - The line's points.
   * @param key - Optional string key for identifying the line.
   */
  constructor(e, r) {
    Tp(this, "computedBestFit"), this.points = e, this.key = r;
  }
  /**
   * Create a new Line from an array of y-values.
   * @param values - Y-values.
   * @param key - Optional string key for identifying the line.
   * @returns New Line.
   */
  static fromValues(e, r) {
    return new Ep(e.map((n, i) => ({ x: i, y: n })), r);
  }
  /**
   * Generate a straight line given starting and ending y-values.
   * @param y1 - Starting y-value.
   * @param y2 - Ending y-value.
   * @param n - Number of points.
   * @param startX - Optional starting x-value.
   * @param xStep - Optional x step value.
   * @param key - Optional string key for identifying the line.
   * @returns New Line.
   */
  static generate(e, r, n, i = 0, s = 1, o) {
    const a = (r - e) / (n - 1), l = [{ x: i, y: e }];
    for (let c = 1; c < n - 1; c++)
      l.push({ x: i + c * s, y: e + c * a });
    return l.push({ x: i + l.length * s, y: r }), new Ep(l, o);
  }
  /**
   * Number of points in the line.
   */
  get length() {
    return this.points.length;
  }
  /**
   * Get a sub-sequence of the line.
   * @param start - As in Array.prototype.slice().
   * @param end - As in Array.prototype.slice().
   * @returns The slice.
   */
  slice(e, r) {
    return new Ep(this.points.slice(e, r));
  }
  /**
   * Create a new line by concatenating the line with another line.
   * @param line - The other line.
   * @returns The new line.
   */
  concat(e) {
    return new Ep(this.points.concat(e.points));
  }
  /**
   * Inserts new points at the start of the line.
   * @param points - New points.
   * @returns New number of points in the line.
   */
  unshift(...e) {
    return e.length ? (this.computedBestFit = void 0, this.points.unshift(...e)) : this.points.length;
  }
  /**
   * Removes the first point of the line.
   * @returns The removed point.
   */
  shift() {
    return this.computedBestFit = void 0, this.points.shift();
  }
  /**
   * Inserts new points at the end of the line.
   * @param points - New points.
   * @returns New number of points in the line.
   */
  push(...e) {
    return e.length ? (this.computedBestFit = void 0, this.points.push(...e)) : this.points.length;
  }
  /**
   * Removes the last point of the line.
   * @returns The removed point.
   */
  pop() {
    return this.computedBestFit = void 0, this.points.pop();
  }
  /**
   * Extract a section of the line within an x-value interval.
   * If one or both interval bounds fall between existing points,
   * (a) new endpoint(s) will be produced via interpolation. 
   * @param interval - The x-value interval of the line section to extract.
   * @returns The extracted line section.
   */
  extractSection(e) {
    if (e.end < e.start || e.start > this.points.at(-1).x || e.start < this.points[0].x || e.end < this.points[0].x || e.end > this.points.at(-1).x)
      return;
    const r = this.points.findIndex((l) => l.x >= e.start);
    let n = this.points.findIndex((l) => l.x > e.end) - 1;
    n === -2 && (n = this.points.length - 1);
    const i = this.slice(r, n + 1), s = this.points[r].x > e.start, o = this.points[n].x < e.end;
    if (!s && !o)
      return i;
    const a = this.points[1].x - this.points[0].x;
    if (s) {
      const l = (e.start - this.points[r - 1].x) / a;
      i.unshift({
        x: e.start,
        y: this.points[r - 1].y + (this.points[r].y - this.points[r - 1].y) * l
      });
    }
    if (o && e.start !== e.end) {
      const l = (e.end - this.points[n].x) / a;
      i.push({
        x: e.end,
        y: this.points[n].y + (this.points[n + 1].y - this.points[n].y) * l
      });
    }
    return i;
  }
  /**
   * Project line into another coordinate system.
   * @param xAxis - Source chart display x-axis bounds.
   * @param yAxis - Source chart display y-axis bounds.
   * @param destSize - Destination coordinate system size (default: the shared training coord sys).
   * @returns Projected line.
   */
  project(e, r, n = yJ) {
    return new Ep(this.points.map((i) => bJ(i, e ?? this.xBounds(), r ?? this.yBounds(), n)));
  }
  /**
   * Compute line's min and max x-values.
   * @returns X bounds.
   */
  xBounds() {
    return { start: this.points[0].x, end: this.points.at(-1).x };
  }
  /**
   * Compute line's min and max y-values.
   * @returns Y bounds.
   */
  yBounds() {
    const e = this.points.map((r) => r.y);
    return { start: hJ(e), end: pJ(e) };
  }
  /**
   * Compute the magnitude of the x-value range covered by the line.
   * @returns X-value range.
   */
  xRange() {
    const e = this.xBounds();
    return e.end - e.start;
  }
  /**
   * Compute the magnitude of the y-value range covered by the line.
   * @returns Y-value range.
   */
  yRange() {
    const e = this.yBounds();
    return e.end - e.start;
  }
  /**
   * Extract the line segments comprising the line.
   * @returns The line segments.
   */
  getSegments() {
    return this.points.slice(0, -1).map((e, r) => new JT({ start: e, end: this.points[r + 1] }));
  }
  /**
   * Get the best-fit straight line approximating this line. 
   * @returns Best-fit line.
   */
  get bestFit() {
    return this.computedBestFit || (this.computedBestFit = new wJ(this)), this.computedBestFit;
  }
}, JT = class {
  /**
   * @param endpoints - Endpoints of the segment.
   */
  constructor(e) {
    Tp(this, "computedSlope"), Tp(this, "computedAngle"), this.endpoints = e;
  }
  /**
   * Slope of the segment.
   */
  get slope() {
    return this.computedSlope === void 0 && (this.computedSlope = (this.endpoints.end.y - this.endpoints.start.y) / (this.endpoints.end.x - this.endpoints.start.x)), this.computedSlope;
  }
  /** Angle of the segment with the x-axis. */
  get xAngle() {
    return this.computedAngle === void 0 && (this.computedAngle = Hf(this.slope)), this.computedAngle;
  }
}, wJ = class extends JT {
  /**
   * @param line - Line to approximate.
   */
  constructor(e) {
    if (e.length < 3)
      throw new gJ(3);
    const r = uJ(e.points.map((i) => [i.x, i.y])), n = e.points.map((i) => ({ x: i.x, y: r.m * i.x + r.b }));
    super({ start: n[0], end: n.at(-1) }), Tp(this, "intercept"), Tp(this, "points"), Tp(this, "residuals"), this.line = e, this.computedSlope = r.m, this.intercept = r.b, this.points = n, this.residuals = e.points.map((i, s) => i.y - n[s].y);
  }
  /**
   * Compute the residual sum of squares.
   * @returns Residual sum of squares.
   */
  rss() {
    return this.residuals.map((e) => e ** 2).reduce((e, r) => e + r);
  }
};
function Ti(t, e, r, n, i) {
  return Ta(e, ((s, o) => {
    const a = s[o];
    if (a === void 0)
      throw new TypeError(V6(o));
    return a;
  })(t, e), r, n, i);
}
function Ta(t, e, r, n, i, s) {
  const o = p0(e, r, n);
  if (i && e !== o)
    throw new RangeError(pM(t, e, r, n, s));
  return o;
}
function gi(t) {
  return t !== null && /object|function/.test(typeof t);
}
function us(t, e = Map) {
  const r = new e();
  return (n, ...i) => {
    if (r.has(n))
      return r.get(n);
    const s = t(n, ...i);
    return r.set(n, s), s;
  };
}
function h0(t) {
  return Vp({
    name: t
  }, 1);
}
function Vp(t, e) {
  return La((r) => ({
    value: r,
    configurable: 1,
    writable: !e
  }), t);
}
function xJ(t) {
  return La((e) => ({
    get: e,
    configurable: 1
  }), t);
}
function KE(t) {
  return {
    [Symbol.toStringTag]: {
      value: t,
      configurable: 1
    }
  };
}
function md(t, e) {
  const r = {};
  let n = t.length;
  for (const i of e)
    r[t[--n]] = i;
  return r;
}
function La(t, e, r) {
  const n = {};
  for (const i in e)
    n[i] = t(e[i], i, r);
  return n;
}
function H2(t, e, r) {
  const n = {};
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    n[s] = t(s, i, r);
  }
  return n;
}
function XT(t, e, r) {
  const n = {};
  for (let i = 0; i < t.length; i++)
    n[e[i]] = r[t[i]];
  return n;
}
function Xs(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const n of t)
    r[n] = e[n];
  return r;
}
function Bk(t, e) {
  for (const r of e)
    if (r in t)
      return 1;
  return 0;
}
function eL(t, e, r) {
  for (const n of t)
    if (e[n] !== r[n])
      return 0;
  return 1;
}
function tL(t, e, r) {
  const n = {
    ...r
  };
  for (let i = 0; i < e; i++)
    n[t[i]] = 0;
  return n;
}
function nr(t, ...e) {
  return (...r) => t(...e, ...r);
}
function Fk(t) {
  return t[0].toUpperCase() + t.substring(1);
}
function lg(t) {
  return t.slice().sort();
}
function cy(t, e) {
  return String(e).padStart(t, "0");
}
function Dl(t, e) {
  return Math.sign(t - e);
}
function p0(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
function va(t, e) {
  return [Math.floor(t / e), Gf(t, e)];
}
function Gf(t, e) {
  return (t % e + e) % e;
}
function ql(t, e) {
  return [G2(t, e), YE(t, e)];
}
function G2(t, e) {
  return Math.trunc(t / e) || 0;
}
function YE(t, e) {
  return t % e || 0;
}
function Rm(t) {
  return Math.abs(t % 1) === 0.5;
}
function rL(t, e, r) {
  let n = 0, i = 0;
  for (let a = 0; a <= e; a++) {
    const l = t[r[a]], c = zo[a], p = jr / c, [h, d] = ql(l, p);
    n += d * c, i += h;
  }
  const [s, o] = ql(n, jr);
  return [i + s, o];
}
function W2(t, e, r) {
  const n = {};
  for (let i = e; i >= 0; i--) {
    const s = zo[i];
    n[r[i]] = G2(t, s), t = YE(t, s);
  }
  return n;
}
function EJ(t) {
  if (t !== void 0)
    return Jn(t);
}
function SJ(t) {
  if (t !== void 0)
    return ha(t);
}
function nL(t) {
  if (t !== void 0)
    return ZE(t);
}
function ha(t) {
  return oL(ZE(t));
}
function ZE(t) {
  return sL(Lee(t));
}
function iL(t, e) {
  if (e == null)
    throw new RangeError(V6(t));
  return e;
}
function cg(t) {
  if (!gi(t))
    throw new TypeError(iee);
  return t;
}
function JE(t, e, r = t) {
  if (typeof e !== t)
    throw new TypeError(wc(r, e));
  return e;
}
function sL(t, e = "number") {
  if (!Number.isInteger(t))
    throw new RangeError(JX(e, t));
  return t || 0;
}
function oL(t, e = "number") {
  if (t <= 0)
    throw new RangeError(XX(e, t));
  return t;
}
function XE(t) {
  if (typeof t == "symbol")
    throw new TypeError(nee);
  return String(t);
}
function g1(t, e) {
  return gi(t) ? String(t) : Jn(t, e);
}
function e6(t) {
  if (typeof t == "string")
    return BigInt(t);
  if (typeof t != "bigint")
    throw new TypeError(ree(t));
  return t;
}
function aL(t, e = "number") {
  if (typeof t == "bigint")
    throw new TypeError(tee(e));
  if (t = Number(t), !Number.isFinite(t))
    throw new RangeError(eee(e, t));
  return t;
}
function ii(t, e) {
  return Math.trunc(aL(t, e)) || 0;
}
function t6(t, e) {
  return sL(aL(t, e), e);
}
function zk(t, e) {
  return oL(ii(t, e), e);
}
function r6(t, e) {
  let [r, n] = ql(e, jr), i = t + r;
  const s = Math.sign(i);
  return s && s === -Math.sign(n) && (i -= s, n += s * jr), [i, n];
}
function Up(t, e, r = 1) {
  return r6(t[0] + e[0] * r, t[1] + e[1] * r);
}
function rh(t, e) {
  return r6(t[0], t[1] + e);
}
function Bo(t, e) {
  return Up(e, t, -1);
}
function hs(t, e) {
  return Dl(t[0], e[0]) || Dl(t[1], e[1]);
}
function lL(t, e, r) {
  return hs(t, e) === -1 || hs(t, r) === 1;
}
function n6(t, e = 1) {
  const r = BigInt(jr / e);
  return [Number(t / r), Number(t % r) * e];
}
function uy(t, e = 1) {
  const r = jr / e, [n, i] = ql(t, r);
  return [n, i * e];
}
function Fo(t, e = 1, r) {
  const [n, i] = t, [s, o] = ql(i, e);
  return n * (jr / e) + (s + (r ? o / e : 0));
}
function i6(t, e, r = va) {
  const [n, i] = t, [s, o] = r(i, e);
  return [n * (jr / e) + s, o];
}
function s6(t) {
  return Ti(t, "isoYear", b0, y0, 1), t.isoYear === b0 ? Ti(t, "isoMonth", 4, 12, 1) : t.isoYear === y0 && Ti(t, "isoMonth", 1, 9, 1), t;
}
function js(t) {
  return Vi({
    ...t,
    ...Ui,
    isoHour: 12
  }), t;
}
function Vi(t) {
  const e = Ti(t, "isoYear", b0, y0, 1), r = e === b0 ? 1 : e === y0 ? -1 : 0;
  return r && Jo(Pn({
    ...t,
    isoDay: t.isoDay + r,
    isoNanosecond: t.isoNanosecond - r
  })), t;
}
function Jo(t) {
  if (!t || lL(t, zee, Fee))
    throw new RangeError(xc);
  return t;
}
function Ql(t) {
  return rL(t, 5, ro)[1];
}
function q2(t) {
  const [e, r] = va(t, jr);
  return [W2(r, 5, ro), e];
}
function Vk(t) {
  return i6(t, No);
}
function ai(t) {
  return yd(t.isoYear, t.isoMonth, t.isoDay, t.isoHour, t.isoMinute, t.isoSecond, t.isoMillisecond);
}
function Pn(t) {
  const e = ai(t);
  if (e !== void 0) {
    const [r, n] = ql(e, Bi);
    return [r, n * Ga + (t.isoMicrosecond || 0) * mg + (t.isoNanosecond || 0)];
  }
}
function o6(t, e) {
  const [r, n] = q2(Ql(t) - e);
  return Jo(Pn({
    ...t,
    isoDay: t.isoDay + n,
    ...r
  }));
}
function hy(...t) {
  return yd(...t) / xM;
}
function yd(...t) {
  const [e, r] = cL(...t), n = e.valueOf();
  if (!isNaN(n))
    return n - r * Bi;
}
function cL(t, e = 1, r = 1, n = 0, i = 0, s = 0, o = 0) {
  const a = t === b0 ? 1 : t === y0 ? -1 : 0, l = /* @__PURE__ */ new Date();
  return l.setUTCHours(n, i, s, o), l.setUTCFullYear(t, e - 1, r + a), [l, a];
}
function bd(t, e) {
  let [r, n] = rh(t, e);
  n < 0 && (n += jr, r -= 1);
  const [i, s] = va(n, Ga), [o, a] = va(s, mg);
  return Q2(r * Bi + i, o, a);
}
function Q2(t, e = 0, r = 0) {
  const n = Math.ceil(Math.max(0, Math.abs(t) - Bee) / Bi) * Math.sign(t), i = new Date(t - n * Bi);
  return md(gb, [i.getUTCFullYear(), i.getUTCMonth() + 1, i.getUTCDate() + n, i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds(), e, r]);
}
function a6(t, e) {
  if (e < -864e13)
    throw new RangeError(xc);
  const r = t.formatToParts(e), n = {};
  for (const i of r)
    n[i.type] = i.value;
  return n;
}
function l6(t) {
  return [t.isoYear, t.isoMonth, t.isoDay];
}
function uL(t, e) {
  return [e, 0];
}
function hL() {
  return hl;
}
function pL(t, e) {
  switch (e) {
    case 2:
      return c6(t) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function dL(t) {
  return c6(t) ? 366 : 365;
}
function c6(t) {
  return t % 4 == 0 && (t % 100 != 0 || t % 400 == 0);
}
function fL(t) {
  const [e, r] = cL(t.isoYear, t.isoMonth, t.isoDay);
  return Gf(e.getUTCDay() - r, 7) || 7;
}
function gL(t) {
  return this.id === _d ? (({ isoYear: e }) => e < 1 ? ["gregory-inverse", 1 - e] : ["gregory", e])(t) : this.id === Zl ? Hee(t) : [];
}
function AJ(t) {
  const e = ai(t);
  if (e < Uee) {
    const { isoYear: s } = t;
    return s < 1 ? ["japanese-inverse", 1 - s] : ["japanese", s];
  }
  const r = a6(l5(Zl), e), { era: n, eraYear: i } = tM(r, Zl);
  return [n, i];
}
function K2(t) {
  return Rh(t), vd(t, 1), t;
}
function Rh(t) {
  return mL(t, 1), t;
}
function Uk(t) {
  return eL(Z6, t, mL(t));
}
function mL(t, e) {
  const { isoYear: r } = t, n = Ti(t, "isoMonth", 1, hL(), e);
  return {
    isoYear: r,
    isoMonth: n,
    isoDay: Ti(t, "isoDay", 1, pL(r, n), e)
  };
}
function vd(t, e) {
  return md(ro, [Ti(t, "isoHour", 0, 23, e), Ti(t, "isoMinute", 0, 59, e), Ti(t, "isoSecond", 0, 59, e), Ti(t, "isoMillisecond", 0, 999, e), Ti(t, "isoMicrosecond", 0, 999, e), Ti(t, "isoNanosecond", 0, 999, e)]);
}
function gr(t) {
  return t === void 0 ? 0 : $M(cg(t));
}
function Y2(t, e = 0) {
  t = Xo(t);
  const r = jM(t), n = ete(t, e);
  return [$M(t), n, r];
}
function wd(t, e, r, n = 9, i = 0, s = 4) {
  e = Xo(e);
  let o = DM(e, n, i), a = p6(e), l = vg(e, s);
  const c = bg(e, n, i, 1);
  return o == null ? o = Math.max(r, c) : wL(o, c), a = d6(a, c, 1), t && (l = ((p) => p < 4 ? (p + 2) % 4 : p)(l)), [o, c, a, l];
}
function Z2(t, e = 6, r) {
  let n = p6(t = J2(t, yy));
  const i = vg(t, 7);
  let s = bg(t, e);
  return s = iL(yy, s), n = d6(n, s, void 0, r), [s, n, i];
}
function u6(t) {
  return X6(Xo(t));
}
function yL(t, e) {
  return h6(Xo(t), e);
}
function kJ(t) {
  const e = J2(t, vw), r = gc(vw, Jee, e, 0);
  if (!r)
    throw new RangeError(wc(vw, r));
  return r;
}
function h6(t, e = 4) {
  const r = vL(t);
  return [vg(t, 4), ...bL(bg(t, e), r)];
}
function bL(t, e) {
  return t != null ? [zo[t], t < 4 ? 9 - 3 * t : -1] : [e === void 0 ? 1 : 10 ** (9 - e), e];
}
function p6(t) {
  const e = t[Wf];
  return e === void 0 ? 1 : ii(e, Wf);
}
function d6(t, e, r, n) {
  const i = n ? jr : zo[e + 1];
  if (i) {
    const s = zo[e];
    if (i % ((t = Ta(Wf, t, 1, i / s - (n ? 0 : 1), 1)) * s))
      throw new RangeError(wc(Wf, t));
  } else
    t = Ta(Wf, t, 1, r ? 10 ** 9 : 1, 1);
  return t;
}
function vL(t) {
  let e = t[bw];
  if (e !== void 0) {
    if (typeof e != "number") {
      if (XE(e) === "auto")
        return;
      throw new RangeError(wc(bw, e));
    }
    e = Ta(bw, Math.floor(e), 0, 9, 1);
  }
  return e;
}
function Xo(t) {
  return t === void 0 ? {} : cg(t);
}
function J2(t, e) {
  return typeof t == "string" ? {
    [e]: t
  } : cg(t);
}
function X2(t) {
  return {
    overflow: Gee[t]
  };
}
function f6(t, e, r = 9, n = 0, i) {
  let s = e[t];
  if (s === void 0)
    return i ? n : void 0;
  if (s = XE(s), s === "auto")
    return i ? n : null;
  let o = _x[s];
  if (o === void 0 && (o = Dee[s]), o === void 0)
    throw new RangeError(fM(t, s, _x));
  return Ta(t, o, n, r, 1, U6), o;
}
function gc(t, e, r, n = 0) {
  const i = r[t];
  if (i === void 0)
    return n;
  const s = XE(i), o = e[s];
  if (o === void 0)
    throw new RangeError(fM(t, s, e));
  return o;
}
function wL(t, e) {
  if (e > t)
    throw new RangeError(kee);
}
function Ua(t) {
  return {
    branding: n5,
    epochNanoseconds: t
  };
}
function eo(t, e, r) {
  return {
    branding: Ec,
    calendar: r,
    timeZone: e,
    epochNanoseconds: t
  };
}
function to(t, e = t.calendar) {
  return {
    branding: Cd,
    calendar: e,
    ...Xs($ee, t)
  };
}
function Ha(t, e = t.calendar) {
  return {
    branding: wg,
    calendar: e,
    ...Xs(J6, t)
  };
}
function d0(t, e = t.calendar) {
  return {
    branding: e5,
    calendar: e,
    ...Xs(J6, t)
  };
}
function py(t, e = t.calendar) {
  return {
    branding: t5,
    calendar: e,
    ...Xs(J6, t)
  };
}
function ea(t) {
  return {
    branding: r5,
    ...Xs(OM, t)
  };
}
function gn(t) {
  return {
    branding: i5,
    sign: mc(t),
    ...Xs(Q6, t)
  };
}
function g6(t) {
  return i6(t.epochNanoseconds, Ga)[0];
}
function _J(t) {
  return ((e, r = 1) => {
    const [n, i] = e, s = Math.floor(i / r), o = jr / r;
    return BigInt(n) * BigInt(o) + BigInt(s);
  })(t.epochNanoseconds);
}
function xL(t) {
  return t.epochNanoseconds;
}
function CJ(t, e, r, n, i) {
  const s = nh(n), [o, a] = ((E, A) => {
    const x = A((E = J2(E, Px))[MM]);
    let g = Xee(E);
    return g = iL(Px, g), [g, x];
  })(i, t), l = Math.max(o, s);
  if (!a && g0(l, a))
    return Hk(n, o);
  if (!a)
    throw new RangeError(pb);
  if (!n.sign)
    return 0;
  const [c, p, h] = ib(e, r, a), d = A6(h), b = sb(h), m = k6(h), w = b(p, c, n);
  Hp(a) || (Vi(c), Vi(w));
  const f = m(p, c, w, o);
  return g0(o, a) ? Hk(f, o) : ((E, A, x, g, v, k, S) => {
    const R = mc(E), [L, F] = m6(g, Y6(x, E), x, R, v, k, S), z = y6(A, L, F);
    return E[vr[x]] + z * R;
  })(f, d(w), o, p, c, d, b);
}
function Hk(t, e) {
  return Fo(Tn(t), zo[e], 1);
}
function m6(t, e, r, n, i, s, o) {
  const a = vr[r], l = {
    ...e,
    [a]: e[a] + n
  }, c = o(t, i, e), p = o(t, i, l);
  return [s(c), s(p)];
}
function y6(t, e, r) {
  const n = Fo(Bo(e, r));
  if (!n)
    throw new RangeError(kd);
  return Fo(Bo(e, t)) / n;
}
function IJ(t, e) {
  const [r, n, i] = Z2(e, 5, 1);
  return Ua(tb(t.epochNanoseconds, r, n, i, 1));
}
function PJ(t, e, r) {
  let { epochNanoseconds: n, timeZone: i, calendar: s } = e;
  const [o, a, l] = Z2(r);
  if (o === 0 && a === 1)
    return e;
  const c = t(i);
  if (o === 6)
    n = ((p, h, d, b) => {
      const m = ds(d, h), [w, f] = p(m), E = d.epochNanoseconds, A = Yl(h, w), x = Yl(h, f);
      if (lL(E, A, x))
        throw new RangeError(kd);
      return _L(y6(E, A, x), b) ? x : A;
    })(AL, c, e, l);
  else {
    const p = c.R(n);
    n = xd(c, EL(bd(n, p), o, a, l), p, 2, 0, 1);
  }
  return eo(n, i, s);
}
function RJ(t, e) {
  return to(EL(t, ...Z2(e)), t.calendar);
}
function OJ(t, e) {
  const [r, n, i] = Z2(e, 5);
  var s;
  return ea((s = i, b6(t, ug(r, n), s)[0]));
}
function TJ(t, e) {
  const r = t(e.timeZone), n = ds(e, r), [i, s] = AL(n), o = Fo(Bo(Yl(r, i), Yl(r, s)), fb, 1);
  if (o <= 0)
    throw new RangeError(kd);
  return o;
}
function LJ(t, e) {
  const { timeZone: r, calendar: n } = e, i = ((s, o, a) => Yl(o, s(ds(a, o))))(kL, t(r), e);
  return eo(i, r, n);
}
function EL(t, e, r, n) {
  return SL(t, ug(e, r), n);
}
function SL(t, e, r) {
  const [n, i] = b6(t, e, r);
  return Vi({
    ...Oh(t, i),
    ...n
  });
}
function b6(t, e, r) {
  return q2(Kl(Ql(t), e, r));
}
function dy(t) {
  return Kl(t, db, 7);
}
function ug(t, e) {
  return zo[t] * e;
}
function AL(t) {
  const e = kL(t);
  return [e, Oh(e, 1)];
}
function kL(t) {
  return jee(6, t);
}
function MJ(t, e, r) {
  const n = Math.min(nh(t), 6);
  return Ed(rb(Tn(t, n), e, r), n);
}
function eb(t, e, r, n, i, s, o, a, l, c) {
  if (n === 0 && i === 1)
    return t;
  const p = g0(n, a) ? Hp(a) && n < 6 && r >= 6 ? DJ : NJ : $J;
  let [h, d, b] = p(t, e, r, n, i, s, o, a, l, c);
  return b && n !== 7 && (h = ((m, w, f, E, A, x, g, v) => {
    const k = mc(m);
    for (let S = E + 1; S <= f; S++) {
      if (S === 7 && f !== 7)
        continue;
      const R = Y6(S, m);
      R[vr[S]] += k;
      const L = Fo(Bo(g(v(A, x, R)), w));
      if (L && Math.sign(L) !== k)
        break;
      m = R;
    }
    return m;
  })(h, d, r, Math.max(6, n), o, a, l, c)), h;
}
function tb(t, e, r, n, i) {
  if (e === 6) {
    const s = ((o) => o[0] + o[1] / jr)(t);
    return [Kl(s, r, n), 0];
  }
  return rb(t, ug(e, r), n, i);
}
function rb(t, e, r, n) {
  let [i, s] = t;
  n && s < 0 && (s += jr, i -= 1);
  const [o, a] = va(Kl(s, e, r), jr);
  return r6(i + o, a);
}
function Kl(t, e, r) {
  return _L(t / e, r) * e;
}
function _L(t, e) {
  return nte[e](t);
}
function NJ(t, e, r, n, i, s) {
  const o = mc(t), a = Tn(t), l = tb(a, n, i, s), c = Bo(a, l), p = Math.sign(l[0] - a[0]) === o, h = Ed(l, Math.min(r, 6));
  return [{
    ...t,
    ...h
  }, Up(e, c), p];
}
function DJ(t, e, r, n, i, s, o, a, l, c) {
  const p = mc(t) || 1, h = Fo(Tn(t, 5)), d = ug(n, i);
  let b = Kl(h, d, s);
  const [m, w] = m6(o, {
    ...t,
    ...K6
  }, 6, p, a, l, c), f = b - Fo(Bo(m, w));
  let E = 0;
  f && Math.sign(f) !== p ? e = rh(m, b) : (E += p, b = Kl(f, d, s), e = rh(w, b));
  const A = ob(b);
  return [{
    ...t,
    ...A,
    days: t.days + E
  }, e, !!E];
}
function $J(t, e, r, n, i, s, o, a, l, c) {
  const p = mc(t), h = vr[n], d = Y6(n, t);
  n === 7 && (t = {
    ...t,
    weeks: t.weeks + Math.trunc(t.days / 7)
  });
  const b = G2(t[h], i) * i;
  d[h] = b;
  const [m, w] = m6(o, d, n, i * p, a, l, c), f = b + y6(e, m, w) * p * i, E = Kl(f, i, s), A = Math.sign(E - f) === p;
  return d[h] = E, [d, A ? w : m, A];
}
function Gk(t, e, r, n) {
  const [i, s, o, a] = ((c) => {
    const p = h6(c = Xo(c));
    return [c.timeZone, ...p];
  })(n), l = i !== void 0;
  return ((c, p, h, d, b, m) => {
    h = rb(h, b, d, 1);
    const w = p.R(h);
    return v6(bd(h, w), m) + (c ? hg(dy(w)) : "Z");
  })(l, e(l ? t(i) : Nh), r.epochNanoseconds, s, o, a);
}
function Wk(t, e, r) {
  const [n, i, s, o, a, l] = ((c) => {
    c = Xo(c);
    const p = X6(c), h = vL(c), d = rte(c), b = vg(c, 4), m = bg(c, 4);
    return [p, tte(c), d, b, ...bL(m, h)];
  })(r);
  return ((c, p, h, d, b, m, w, f, E, A) => {
    d = rb(d, E, f, 1);
    const x = c(h).R(d);
    return v6(bd(d, x), A) + hg(dy(x), w) + ((g, v) => v !== 1 ? "[" + (v === 2 ? "!" : "") + g + "]" : "")(h, m) + w6(p, b);
  })(t, e.calendar, e.timeZone, e.epochNanoseconds, n, i, s, o, a, l);
}
function qk(t, e) {
  const [r, n, i, s] = ((c) => (c = Xo(c), [X6(c), ...h6(c)]))(e);
  return o = t.calendar, a = r, l = s, v6(SL(t, i, n), l) + w6(o, a);
  var o, a, l;
}
function Qk(t, e) {
  return r = t.calendar, n = t, i = u6(e), fy(n) + w6(r, i);
  var r, n, i;
}
function Kk(t, e) {
  return CL(t.calendar, IL, t, u6(e));
}
function Yk(t, e) {
  return CL(t.calendar, jJ, t, u6(e));
}
function Zk(t, e) {
  const [r, n, i] = yL(e);
  return s = i, PL(b6(t, n, r)[0], s);
  var s;
}
function pw(t, e) {
  const [r, n, i] = yL(e, 3);
  return n > 1 && Th(t = {
    ...t,
    ...MJ(t, n, r)
  }), ((s, o) => {
    const { sign: a } = s, l = a === -1 ? mi(s) : s, { hours: c, minutes: p } = l, [h, d] = i6(Tn(l, 3), No, ql);
    LL(h);
    const b = x6(d, o), m = o >= 0 || !a || b;
    return (a < 0 ? "-" : "") + "P" + Jk({
      Y: vu(l.years),
      M: vu(l.months),
      W: vu(l.weeks),
      D: vu(l.days)
    }) + (c || p || h || m ? "T" + Jk({
      H: vu(c),
      M: vu(p),
      S: vu(h, m) + b
    }) : "");
  })(t, i);
}
function CL(t, e, r, n) {
  const i = n > 1 || n === 0 && t !== cr;
  return n === 1 ? t === cr ? e(r) : fy(r) : i ? fy(r) + RL(t, n === 2) : e(r);
}
function Jk(t) {
  const e = [];
  for (const r in t) {
    const n = t[r];
    n && e.push(n, r);
  }
  return e.join("");
}
function v6(t, e) {
  return fy(t) + "T" + PL(t, e);
}
function fy(t) {
  return IL(t) + "-" + Bs(t.isoDay);
}
function IL(t) {
  const { isoYear: e } = t;
  return (e < 0 || e > 9999 ? OL(e) + cy(6, Math.abs(e)) : cy(4, e)) + "-" + Bs(t.isoMonth);
}
function jJ(t) {
  return Bs(t.isoMonth) + "-" + Bs(t.isoDay);
}
function PL(t, e) {
  const r = [Bs(t.isoHour), Bs(t.isoMinute)];
  return e !== -1 && r.push(Bs(t.isoSecond) + ((n, i, s, o) => x6(n * Ga + i * mg + s, o))(t.isoMillisecond, t.isoMicrosecond, t.isoNanosecond, e)), r.join(":");
}
function hg(t, e = 0) {
  if (e === 1)
    return "";
  const [r, n] = va(Math.abs(t), fb), [i, s] = va(n, db), [o, a] = va(s, No);
  return OL(t) + Bs(r) + ":" + Bs(i) + (o || a ? ":" + Bs(o) + x6(a) : "");
}
function w6(t, e) {
  return e !== 1 && (e > 1 || e === 0 && t !== cr) ? RL(t, e === 2) : "";
}
function RL(t, e) {
  return "[" + (e ? "!" : "") + "u-ca=" + t + "]";
}
function x6(t, e) {
  let r = cy(9, t);
  return r = e === void 0 ? r.replace(ote, "") : r.slice(0, e), r ? "." + r : "";
}
function OL(t) {
  return t < 0 ? "-" : "+";
}
function vu(t, e) {
  return t || e ? t.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function BJ(t, e) {
  const { epochNanoseconds: r } = t, n = (e.R ? e : e(t.timeZone)).R(r), i = bd(r, n);
  return {
    calendar: t.calendar,
    ...i,
    offsetNanoseconds: n
  };
}
function xd(t, e, r, n = 0, i = 0, s, o) {
  if (r !== void 0 && n === 1 && (n === 1 || o))
    return o6(e, r);
  const a = t.I(e);
  if (r !== void 0 && n !== 3) {
    const l = ((c, p, h, d) => {
      const b = Pn(p);
      d && (h = dy(h));
      for (const m of c) {
        let w = Fo(Bo(m, b));
        if (d && (w = dy(w)), w === h)
          return m;
      }
    })(a, e, r, s);
    if (l !== void 0)
      return l;
    if (n === 0)
      throw new RangeError(vee);
  }
  return o ? Pn(e) : pg(t, e, i, a);
}
function pg(t, e, r = 0, n = t.I(e)) {
  if (n.length === 1)
    return n[0];
  if (r === 1)
    throw new RangeError(wee);
  if (n.length)
    return n[r === 3 ? 1 : 0];
  const i = Pn(e), s = ((a, l) => {
    const c = a.R(rh(l, -864e11));
    return ((p) => {
      if (p > jr)
        throw new RangeError(bee);
      return p;
    })(a.R(rh(l, jr)) - c);
  })(t, i), o = s * (r === 2 ? -1 : 1);
  return (n = t.I(bd(i, o)))[r === 2 ? 0 : n.length - 1];
}
function Yl(t, e) {
  const r = t.I(e);
  if (r.length)
    return r[0];
  const n = rh(Pn(e), -864e11);
  return t.O(n, 1);
}
function Xk(t, e, r) {
  return Ua(Jo(Up(e.epochNanoseconds, ((n) => {
    if (ML(n))
      throw new RangeError(See);
    return Tn(n, 5);
  })(t ? mi(r) : r))));
}
function e7(t, e, r, n, i, s = /* @__PURE__ */ Object.create(null)) {
  const o = e(n.timeZone), a = t(n.calendar);
  return {
    ...n,
    ...E6(o, a, n, r ? mi(i) : i, s)
  };
}
function t7(t, e, r, n, i = /* @__PURE__ */ Object.create(null)) {
  const { calendar: s } = r;
  return to(S6(t(s), r, e ? mi(n) : n, i), s);
}
function r7(t, e, r, n, i) {
  const { calendar: s } = r;
  return Ha(nb(t(s), r, e ? mi(n) : n, i), s);
}
function n7(t, e, r, n, i) {
  const s = r.calendar, o = t(s);
  let a = js(f0(o, r));
  e && (n = _6(n)), n.sign < 0 && (a = o.P(a, {
    ...Ln,
    months: 1
  }), a = Oh(a, -1));
  const l = o.P(a, n, i);
  return d0(f0(o, l), s);
}
function i7(t, e, r) {
  return ea(TL(e, t ? mi(r) : r)[0]);
}
function E6(t, e, r, n, i) {
  const s = Tn(n, 5);
  let o = r.epochNanoseconds;
  if (ML(n)) {
    const a = ds(r, t);
    o = Up(pg(t, {
      ...nb(e, a, {
        ...n,
        ...K6
      }, i),
      ...Xs(ro, a)
    }), s);
  } else
    o = Up(o, s), gr(i);
  return {
    epochNanoseconds: Jo(o)
  };
}
function S6(t, e, r, n) {
  const [i, s] = TL(e, r);
  return Vi({
    ...nb(t, e, {
      ...r,
      ...K6,
      days: r.days + s
    }, n),
    ...i
  });
}
function nb(t, e, r, n) {
  if (r.years || r.months || r.weeks)
    return t.P(e, r, n);
  gr(n);
  const i = r.days + Tn(r, 5)[0];
  return i ? js(Oh(e, i)) : e;
}
function f0(t, e, r = 1) {
  return Oh(e, r - t.day(e));
}
function TL(t, e) {
  const [r, n] = Tn(e, 5), [i, s] = q2(Ql(t) + n);
  return [i, r + s];
}
function Oh(t, e) {
  return e ? {
    ...t,
    ...Q2(ai(t) + e * Bi)
  } : t;
}
function ib(t, e, r) {
  const n = t(r.calendar);
  return Hp(r) ? [r, n, e(r.timeZone)] : [{
    ...r,
    ...Ui
  }, n];
}
function A6(t) {
  return t ? xL : Pn;
}
function sb(t) {
  return t ? nr(E6, t) : S6;
}
function k6(t) {
  return t ? nr(cX, t) : uX;
}
function Hp(t) {
  return t && t.epochNanoseconds;
}
function g0(t, e) {
  return t <= 6 - (Hp(e) ? 1 : 0);
}
function s7(t, e, r, n, i, s, o) {
  const a = t(Xo(o).relativeTo), l = Math.max(nh(i), nh(s));
  if (g0(l, a))
    return gn(Th(((w, f, E, A) => {
      const x = Up(Tn(w), Tn(f), A ? -1 : 1);
      if (!Number.isFinite(x[0]))
        throw new RangeError(xc);
      return {
        ...Ln,
        ...Ed(x, E)
      };
    })(i, s, l, n)));
  if (!a)
    throw new RangeError(pb);
  n && (s = mi(s));
  const [c, p, h] = ib(e, r, a), d = sb(h), b = k6(h), m = d(p, c, i);
  return gn(b(p, c, d(p, m, s), l));
}
function FJ(t, e, r, n, i) {
  const s = nh(n), [o, a, l, c, p] = ((k, S, R) => {
    k = J2(k, yy);
    let L = DM(k);
    const F = R(k[MM]);
    let z = p6(k);
    const j = vg(k, 7);
    let ee = bg(k);
    if (L === void 0 && ee === void 0)
      throw new RangeError(Aee);
    if (ee == null && (ee = 0), L == null && (L = Math.max(ee, S)), wL(L, ee), z = d6(z, ee, 1), z > 1 && ee > 5 && L !== ee)
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    return [L, ee, z, j, F];
  })(i, s, t), h = Math.max(s, o);
  if (!p && h <= 6)
    return gn(Th(((k, S, R, L, F) => {
      const z = tb(Tn(k), R, L, F);
      return {
        ...Ln,
        ...Ed(z, S)
      };
    })(n, o, a, l, c)));
  if (!Hp(p) && !n.sign)
    return n;
  if (!p)
    throw new RangeError(pb);
  const [d, b, m] = ib(e, r, p), w = A6(m), f = sb(m), E = k6(m), A = f(b, d, n);
  Hp(p) || (Vi(d), Vi(A));
  let x = E(b, d, A, o);
  const g = n.sign, v = mc(x);
  if (g && v && g !== v)
    throw new RangeError(kd);
  return x = eb(x, w(A), o, a, l, c, b, d, w, f), gn(x);
}
function zJ(t) {
  return t.sign === -1 ? _6(t) : t;
}
function _6(t) {
  return gn(mi(t));
}
function mi(t) {
  const e = {};
  for (const r of vr)
    e[r] = -1 * t[r] || 0;
  return e;
}
function VJ(t) {
  return !t.sign;
}
function mc(t, e = vr) {
  let r = 0;
  for (const n of e) {
    const i = Math.sign(t[n]);
    if (i) {
      if (r && r !== i)
        throw new RangeError(Eee);
      r = i;
    }
  }
  return r;
}
function Th(t) {
  for (const e of Nee)
    Ta(e, t[e], -4294967295, ate, 1);
  return LL(Fo(Tn(t), No)), t;
}
function LL(t) {
  if (!Number.isSafeInteger(t))
    throw new RangeError(xee);
}
function Tn(t, e = 6) {
  return rL(t, e, vr);
}
function Ed(t, e = 6) {
  const [r, n] = t, i = W2(n, e, vr);
  if (i[vr[e]] += r * (jr / zo[e]), !Number.isFinite(i[vr[e]]))
    throw new RangeError(xc);
  return i;
}
function ob(t, e = 5) {
  return W2(t, e, vr);
}
function ML(t) {
  return !!mc(t, RM);
}
function nh(t) {
  let e = 9;
  for (; e > 0 && !t[vr[e]]; e--)
    ;
  return e;
}
function UJ(t, e) {
  return [t, e];
}
function o7(t) {
  const e = Math.floor(t / y1) * y1;
  return [e, e + y1];
}
function HJ(t) {
  const e = yc(t = g1(t));
  if (!e)
    throw new RangeError(Ni(t));
  let r;
  if (e.j)
    r = 0;
  else {
    if (!e.offset)
      throw new RangeError(Ni(t));
    r = Lh(e.offset);
  }
  return e.timeZone && O6(e.timeZone, 1), Ua(o6(K2(e), r));
}
function GJ(t) {
  const e = yc(Jn(t));
  if (!e)
    throw new RangeError(Ni(t));
  if (e.timeZone)
    return NL(e, e.offset ? Lh(e.offset) : void 0);
  if (e.j)
    throw new RangeError(Ni(t));
  return $L(e);
}
function WJ(t, e) {
  const r = yc(Jn(t));
  if (!r || !r.timeZone)
    throw new RangeError(Ni(t));
  const { offset: n } = r, i = n ? Lh(n) : void 0, [, s, o] = Y2(e);
  return NL(r, i, s, o);
}
function Lh(t) {
  const e = O6(t);
  if (e === void 0)
    throw new RangeError(Ni(t));
  return e;
}
function qJ(t) {
  const e = yc(Jn(t));
  if (!e || e.j)
    throw new RangeError(Ni(t));
  return to(DL(e));
}
function C6(t, e, r) {
  let n = yc(Jn(t));
  if (!n || n.j)
    throw new RangeError(Ni(t));
  return e ? n.calendar === cr && (n = n.isoYear === -271821 && n.isoMonth === 4 ? {
    ...n,
    isoDay: 20,
    ...Ui
  } : {
    ...n,
    isoDay: 1,
    ...Ui
  }) : r && n.calendar === cr && (n = {
    ...n,
    isoYear: xa
  }), Ha(n.C ? DL(n) : $L(n));
}
function QJ(t, e) {
  const r = P6(Jn(e));
  if (r)
    return I6(r), d0(s6(Rh(r)));
  const n = C6(e, 1);
  return d0(f0(t(n.calendar), n));
}
function I6(t) {
  if (t.calendar !== cr)
    throw new RangeError(wa(t.calendar));
}
function KJ(t, e) {
  const r = R6(Jn(e));
  if (r)
    return I6(r), py(Rh(r));
  const n = C6(e, 0, 1), { calendar: i } = n, s = t(i), [o, a, l] = s.v(n), [c, p] = s.q(o, a), [h, d] = s.G(c, p, l);
  return py(js(s.V(h, d, l)), i);
}
function YJ(t) {
  let e, r = ((n) => {
    const i = fte.exec(n);
    return i ? (ab(i[10]), FL(i)) : void 0;
  })(Jn(t));
  if (!r) {
    if (r = yc(t), !r)
      throw new RangeError(Ni(t));
    if (!r.C)
      throw new RangeError(Ni(t));
    if (r.j)
      throw new RangeError(wa("Z"));
    I6(r);
  }
  if ((e = P6(t)) && Uk(e))
    throw new RangeError(Ni(t));
  if ((e = R6(t)) && Uk(e))
    throw new RangeError(Ni(t));
  return ea(vd(r, 1));
}
function ZJ(t) {
  const e = ((r) => {
    const n = yte.exec(r);
    return n ? ((i) => {
      function s(p, h, d) {
        let b = 0, m = 0;
        if (d && ([b, l] = va(l, zo[d])), p !== void 0) {
          if (a)
            throw new RangeError(wa(p));
          m = ((w) => {
            const f = parseInt(w);
            if (!Number.isFinite(f))
              throw new RangeError(wa(w));
            return f;
          })(p), o = 1, h && (l = T6(h) * (zo[d] / No), a = 1);
        }
        return b + m;
      }
      let o = 0, a = 0, l = 0, c = {
        ...md(vr, [s(i[2]), s(i[3]), s(i[4]), s(i[5]), s(i[6], i[7], 5), s(i[8], i[9], 4), s(i[10], i[11], 3)]),
        ...W2(l, 2, vr)
      };
      if (!o)
        throw new RangeError(dM(vr));
      return L6(i[1]) < 0 && (c = mi(c)), c;
    })(n) : void 0;
  })(Jn(t));
  if (!e)
    throw new RangeError(Ni(t));
  return gn(Th(e));
}
function JJ(t) {
  const e = yc(t) || P6(t) || R6(t);
  return e ? e.calendar : t;
}
function XJ(t) {
  const e = yc(t);
  return e && (e.timeZone || e.j && Nh || e.offset) || t;
}
function NL(t, e, r = 0, n = 0) {
  const i = M6(t.timeZone), s = Qt(i);
  let o;
  return K2(t), o = t.C ? xd(s, t, e, r, n, !s.$, t.j) : Yl(s, t), eo(o, i, hb(t.calendar));
}
function DL(t) {
  return jL(Vi(K2(t)));
}
function $L(t) {
  return jL(js(Rh(t)));
}
function jL(t) {
  return {
    ...t,
    calendar: hb(t.calendar)
  };
}
function yc(t) {
  const e = dte.exec(t);
  return e ? ((r) => {
    const n = r[10], i = (n || "").toUpperCase() === "Z";
    return {
      isoYear: BL(r),
      isoMonth: parseInt(r[4]),
      isoDay: parseInt(r[5]),
      ...FL(r.slice(5)),
      ...ab(r[16]),
      C: !!r[6],
      j: i,
      offset: i ? void 0 : n
    };
  })(e) : void 0;
}
function P6(t) {
  const e = hte.exec(t);
  return e ? ((r) => ({
    isoYear: BL(r),
    isoMonth: parseInt(r[4]),
    isoDay: 1,
    ...ab(r[5])
  }))(e) : void 0;
}
function R6(t) {
  const e = pte.exec(t);
  return e ? ((r) => ({
    isoYear: xa,
    isoMonth: parseInt(r[1]),
    isoDay: parseInt(r[2]),
    ...ab(r[3])
  }))(e) : void 0;
}
function O6(t, e) {
  const r = gte.exec(t);
  return r ? ((n, i) => {
    const s = n[4] || n[5];
    if (i && s)
      throw new RangeError(wa(s));
    return ((o) => {
      if (Math.abs(o) >= jr)
        throw new RangeError(yee);
      return o;
    })((Lp(n[2]) * fb + Lp(n[3]) * db + Lp(n[4]) * No + T6(n[5] || "")) * L6(n[1]));
  })(r, e) : void 0;
}
function BL(t) {
  const e = L6(t[1]), r = parseInt(t[2] || t[3]);
  if (e < 0 && !r)
    throw new RangeError(wa(-0));
  return e * r;
}
function FL(t) {
  const e = Lp(t[3]);
  return {
    ...q2(T6(t[4] || ""))[0],
    isoHour: Lp(t[1]),
    isoMinute: Lp(t[2]),
    isoSecond: e === 60 ? 59 : e
  };
}
function ab(t) {
  let e, r;
  const n = [];
  if (t.replace(mte, (i, s, o) => {
    const a = !!s, [l, c] = o.split("=").reverse();
    if (c) {
      if (c === "u-ca")
        n.push(l), e || (e = a);
      else if (a || /[A-Z]/.test(c))
        throw new RangeError(wa(i));
    } else {
      if (r)
        throw new RangeError(wa(i));
      r = l;
    }
    return "";
  }), n.length > 1 && e)
    throw new RangeError(wa(t));
  return {
    timeZone: r,
    calendar: n[0] || cr
  };
}
function T6(t) {
  return parseInt(t.padEnd(9, "0"));
}
function Sd(t) {
  return new RegExp(`^${t}$`, "i");
}
function L6(t) {
  return t && t !== "+" ? -1 : 1;
}
function Lp(t) {
  return t === void 0 ? 0 : parseInt(t);
}
function eX(t) {
  return M6(Jn(t));
}
function M6(t) {
  const e = N6(t);
  return typeof e == "number" ? hg(e) : e ? ((r) => {
    if (wte.test(r))
      throw new RangeError(bM(r));
    if (vte.test(r))
      throw new RangeError(mee);
    return r.toLowerCase().split("/").map((n, i) => (n.length <= 3 || /\d/.test(n)) && !/etc|yap/.test(n) ? n.toUpperCase() : n.replace(/baja|dumont|[a-z]+/g, (s, o) => s.length <= 2 && !i || s === "in" || s === "chat" ? s.toUpperCase() : s.length > 2 || !o ? Fk(s).replace(/island|noronha|murdo|rivadavia|urville/, Fk) : s)).join("/");
  })(t) : Nh;
}
function a7(t) {
  const e = N6(t);
  return typeof e == "number" ? e : e ? e.resolvedOptions().timeZone : Nh;
}
function N6(t) {
  const e = O6(t = t.toUpperCase(), 1);
  return e !== void 0 ? e : t !== Nh ? bte(t) : void 0;
}
function zL(t, e) {
  return hs(t.epochNanoseconds, e.epochNanoseconds);
}
function VL(t, e) {
  return hs(t.epochNanoseconds, e.epochNanoseconds);
}
function tX(t, e, r, n, i, s) {
  const o = t(Xo(s).relativeTo), a = Math.max(nh(n), nh(i));
  if (eL(vr, n, i))
    return 0;
  if (g0(a, o))
    return hs(Tn(n), Tn(i));
  if (!o)
    throw new RangeError(pb);
  const [l, c, p] = ib(e, r, o), h = A6(p), d = sb(p);
  return hs(h(d(c, l, n)), h(d(c, l, i)));
}
function UL(t, e) {
  return Ad(t, e) || D6(t, e);
}
function Ad(t, e) {
  return Dl(ai(t), ai(e));
}
function D6(t, e) {
  return Dl(Ql(t), Ql(e));
}
function rX(t, e) {
  return !zL(t, e);
}
function nX(t, e) {
  return !VL(t, e) && !!HL(t.timeZone, e.timeZone) && t.calendar === e.calendar;
}
function iX(t, e) {
  return !UL(t, e) && t.calendar === e.calendar;
}
function sX(t, e) {
  return !Ad(t, e) && t.calendar === e.calendar;
}
function oX(t, e) {
  return !Ad(t, e) && t.calendar === e.calendar;
}
function aX(t, e) {
  return !Ad(t, e) && t.calendar === e.calendar;
}
function lX(t, e) {
  return !D6(t, e);
}
function HL(t, e) {
  if (t === e)
    return 1;
  try {
    return a7(t) === a7(e);
  } catch {
  }
}
function l7(t, e, r, n) {
  const i = wd(t, n, 3, 5), s = lb(e.epochNanoseconds, r.epochNanoseconds, ...i);
  return gn(t ? mi(s) : s);
}
function c7(t, e, r, n, i, s) {
  const o = ub(n.calendar, i.calendar), [a, l, c, p] = wd(r, s, 5), h = n.epochNanoseconds, d = i.epochNanoseconds, b = hs(d, h);
  let m;
  if (b)
    if (a < 6)
      m = lb(h, d, a, l, c, p);
    else {
      const w = e(((E, A) => {
        if (!HL(E, A))
          throw new RangeError(vM);
        return E;
      })(n.timeZone, i.timeZone)), f = t(o);
      m = WL(f, w, n, i, b, a, s), m = eb(m, d, a, l, c, p, f, n, xL, nr(E6, w));
    }
  else
    m = Ln;
  return gn(r ? mi(m) : m);
}
function u7(t, e, r, n, i) {
  const s = ub(r.calendar, n.calendar), [o, a, l, c] = wd(e, i, 6), p = Pn(r), h = Pn(n), d = hs(h, p);
  let b;
  if (d)
    if (o <= 6)
      b = lb(p, h, o, a, l, c);
    else {
      const m = t(s);
      b = qL(m, r, n, d, o, i), b = eb(b, h, o, a, l, c, m, r, Pn, S6);
    }
  else
    b = Ln;
  return gn(e ? mi(b) : b);
}
function h7(t, e, r, n, i) {
  const s = ub(r.calendar, n.calendar);
  return GL(e, () => t(s), r, n, ...wd(e, i, 6, 9, 6));
}
function p7(t, e, r, n, i) {
  const s = ub(r.calendar, n.calendar), o = wd(e, i, 9, 9, 8), a = t(s), l = f0(a, r), c = f0(a, n);
  return l.isoYear === c.isoYear && l.isoMonth === c.isoMonth && l.isoDay === c.isoDay ? gn(Ln) : GL(e, () => a, js(l), js(c), ...o, 8);
}
function GL(t, e, r, n, i, s, o, a, l = 6) {
  const c = Pn(r), p = Pn(n);
  if (c === void 0 || p === void 0)
    throw new RangeError(xc);
  let h;
  if (hs(p, c))
    if (i === 6)
      h = lb(c, p, i, s, o, a);
    else {
      const d = e();
      h = d.N(r, n, i), s === l && o === 1 || (h = eb(h, p, i, s, o, a, d, r, Pn, nb));
    }
  else
    h = Ln;
  return gn(t ? mi(h) : h);
}
function d7(t, e, r, n) {
  const [i, s, o, a] = wd(t, n, 5, 5), l = Kl($6(e, r), ug(s, o), a), c = {
    ...Ln,
    ...ob(l, i)
  };
  return gn(t ? mi(c) : c);
}
function cX(t, e, r, n, i, s) {
  const o = hs(n.epochNanoseconds, r.epochNanoseconds);
  return o ? i < 6 ? QL(r.epochNanoseconds, n.epochNanoseconds, i) : WL(e, t, r, n, o, i, s) : Ln;
}
function uX(t, e, r, n, i) {
  const s = Pn(e), o = Pn(r), a = hs(o, s);
  return a ? n <= 6 ? QL(s, o, n) : qL(t, e, r, a, n, i) : Ln;
}
function WL(t, e, r, n, i, s, o) {
  const [a, l, c] = ((d, b, m, w) => {
    function f() {
      return S = {
        ...Oh(x, v++ * -w),
        ...A
      }, R = pg(d, S), hs(g, R) === -w;
    }
    const E = ds(b, d), A = Xs(ro, E), x = ds(m, d), g = m.epochNanoseconds;
    let v = 0;
    const k = $6(E, x);
    let S, R;
    if (Math.sign(k) === -w && v++, f() && (w === -1 || f()))
      throw new RangeError(kd);
    const L = Fo(Bo(R, g));
    return [E, S, L];
  })(e, r, n, i);
  var p, h;
  return {
    ...s === 6 ? (p = a, h = l, {
      ...Ln,
      days: KL(p, h)
    }) : t.N(a, l, s, o),
    ...ob(c)
  };
}
function qL(t, e, r, n, i, s) {
  const [o, a, l] = ((c, p, h) => {
    let d = p, b = $6(c, p);
    return Math.sign(b) === -h && (d = Oh(p, -h), b += jr * h), [c, d, b];
  })(e, r, n);
  return {
    ...t.N(o, a, i, s),
    ...ob(l)
  };
}
function lb(t, e, r, n, i, s) {
  return {
    ...Ln,
    ...Ed(tb(Bo(t, e), n, i, s), r)
  };
}
function QL(t, e, r) {
  return {
    ...Ln,
    ...Ed(Bo(t, e), r)
  };
}
function KL(t, e) {
  return cb(ai(t), ai(e));
}
function cb(t, e) {
  return Math.trunc((e - t) / Bi);
}
function $6(t, e) {
  return Ql(e) - Ql(t);
}
function ub(t, e) {
  if (t !== e)
    throw new RangeError(yM);
  return t;
}
function YL(t) {
  return this.m(t)[0];
}
function ZL(t) {
  return this.m(t)[1];
}
function j6(t) {
  const [e] = this.v(t);
  return cb(this.p(e), ai(t)) + 1;
}
function B6(t) {
  const e = xte.exec(t);
  if (!e)
    throw new RangeError(fee(t));
  return [parseInt(e[1]), !!e[2]];
}
function dg(t, e) {
  return "M" + Bs(t) + (e ? "L" : "");
}
function gy(t, e, r) {
  return t + (e || r && t >= r ? 1 : 0);
}
function F6(t, e) {
  return t - (e && t >= e ? 1 : 0);
}
function JL(t, e) {
  return (e + t) * (Math.sign(e) || 1) || 0;
}
function Sx(t) {
  return IM[eM(t)];
}
function XL(t) {
  return Oee[eM(t)];
}
function eM(t) {
  return ih(t.id || cr);
}
function hX(t) {
  function e(i) {
    return ((s, o) => ({
      ...tM(s, o),
      o: s.month,
      day: parseInt(s.day)
    }))(a6(r, i), n);
  }
  const r = l5(t), n = ih(t);
  return {
    id: t,
    h: pX(e),
    l: dX(e)
  };
}
function pX(t) {
  return us((e) => {
    const r = ai(e);
    return t(r);
  }, WeakMap);
}
function dX(t) {
  const e = t(0).year - Vee;
  return us((r) => {
    let n, i = yd(r - e), s = 0;
    const o = [], a = [];
    do
      i += 400 * Bi;
    while ((n = t(i)).year <= r);
    do
      if (i += (1 - n.day) * Bi, n.year === r && (o.push(i), a.push(n.o)), i -= Bi, ++s > 100 || i < -864e13)
        throw new RangeError(kd);
    while ((n = t(i)).year >= r);
    return {
      i: o.reverse(),
      u: wM(a.reverse())
    };
  });
}
function tM(t, e) {
  let r, n, i = rM(t);
  if (t.era) {
    const s = IM[e], o = PM[e] || {};
    s !== void 0 && (r = e === "islamic" ? "ah" : t.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), r === "bc" || r === "b" ? r = "bce" : r === "ad" || r === "a" ? r = "ce" : r === "beforeroc" && (r = "broc"), r = o[r] || r, n = i, i = JL(n, s[r] || 0));
  }
  return {
    era: r,
    eraYear: n,
    year: i
  };
}
function rM(t) {
  return parseInt(t.relatedYear || t.year);
}
function my(t) {
  const { year: e, o: r, day: n } = this.h(t), { u: i } = this.l(e);
  return [e, i[r] + 1, n];
}
function m0(t, e = 1, r = 1) {
  return this.l(t).i[e - 1] + (r - 1) * Bi;
}
function nM(t, e) {
  const r = m1.call(this, t);
  return [F6(e, r), r === e];
}
function m1(t) {
  const e = g7(this, t), r = g7(this, t - 1), n = e.length;
  if (n > r.length) {
    const i = XL(this);
    if (i < 0)
      return -i;
    for (let s = 0; s < n; s++)
      if (e[s] !== r[s])
        return s + 1;
  }
}
function Om(t) {
  return cb(m0.call(this, t), m0.call(this, t + 1));
}
function f7(t, e) {
  const { i: r } = this.l(t);
  let n = e + 1, i = r;
  return n > r.length && (n = 1, i = this.l(t + 1).i), cb(r[e - 1], i[n - 1]);
}
function Tm(t) {
  return this.l(t).i.length;
}
function iM(t) {
  const e = this.h(t);
  return [e.era, e.eraYear];
}
function g7(t, e) {
  return Object.keys(t.l(e).u);
}
function fg(t) {
  return hb(Jn(t));
}
function hb(t) {
  if ((t = t.toLowerCase()) !== cr && t !== _d) {
    const e = l5(t).resolvedOptions().calendar;
    if (ih(t) !== ih(e))
      throw new RangeError(mM(t));
    return e;
  }
  return t;
}
function ih(t) {
  return t === "islamicc" && (t = "islamic"), t.split("-")[0];
}
function sM(t, e) {
  return (r) => r === cr ? t : r === _d || r === Zl ? Object.assign(Object.create(t), {
    id: r
  }) : Object.assign(Object.create(e), Ete(r));
}
function fX(t, e, r, n) {
  const i = bc(r, n, qa, [], AM);
  if (i.timeZone !== void 0) {
    const s = r.F(i), o = gg(i), a = t(i.timeZone);
    return {
      epochNanoseconds: xd(e(a), {
        ...s,
        ...o
      }, i.offset !== void 0 ? Lh(i.offset) : void 0),
      timeZone: a
    };
  }
  return {
    ...r.F(i),
    ...Ui
  };
}
function gX(t, e, r, n, i, s) {
  const o = bc(r, i, qa, EM, AM), a = t(o.timeZone), [l, c, p] = Y2(s), h = r.F(o, X2(l)), d = gg(o, l);
  return eo(xd(e(a), {
    ...h,
    ...d
  }, o.offset !== void 0 ? Lh(o.offset) : void 0, c, p), a, n);
}
function mX(t, e, r) {
  const n = bc(t, e, qa, [], Wa), i = gr(r);
  return to(Vi({
    ...t.F(n, X2(i)),
    ...gg(n, i)
  }));
}
function yX(t, e, r, n = []) {
  const i = bc(t, e, qa, n);
  return t.F(i, r);
}
function bX(t, e, r, n) {
  const i = bc(t, e, q6, n);
  return t.K(i, r);
}
function vX(t, e, r, n) {
  const i = bc(t, r, qa, yg);
  return e && i.month !== void 0 && i.monthCode === void 0 && i.year === void 0 && (i.year = xa), t._(i, n);
}
function wX(t, e) {
  return ea(gg(ps(t, Cx, [], 1), gr(e)));
}
function xX(t) {
  const e = ps(t, Q6);
  return gn(Th({
    ...Ln,
    ...e
  }));
}
function bc(t, e, r, n = [], i = []) {
  return ps(e, [...t.fields(r), ...i].sort(), n);
}
function ps(t, e, r, n = !r) {
  const i = {};
  let s, o = 0;
  for (const a of e) {
    if (a === s)
      throw new RangeError(oee(a));
    if (a === "constructor" || a === "__proto__")
      throw new RangeError(see(a));
    let l = t[a];
    if (l !== void 0)
      o = 1, m7[a] && (l = m7[a](l, a)), i[a] = l;
    else if (r) {
      if (r.includes(a))
        throw new TypeError(V6(a));
      i[a] = CM[a];
    }
    s = a;
  }
  if (n && !o)
    throw new TypeError(dM(e));
  return i;
}
function gg(t, e) {
  return vd(c5({
    ...CM,
    ...t
  }), e);
}
function EX(t, e, r, n, i) {
  const { calendar: s, timeZone: o } = r, a = t(s), l = e(o), c = [...a.fields(qa), ...SM].sort(), p = ((E) => {
    const A = ds(E, Qt), x = hg(A.offsetNanoseconds), g = yb(E.calendar), [v, k, S] = g.v(A), [R, L] = g.q(v, k), F = dg(R, L);
    return {
      ...Rte(A),
      year: v,
      monthCode: F,
      day: S,
      offset: x
    };
  })(r), h = ps(n, c), d = a.k(p, h), b = {
    ...p,
    ...h
  }, [m, w, f] = Y2(i, 2);
  return eo(xd(l, {
    ...a.F(d, X2(m)),
    ...vd(c5(b), m)
  }, Lh(b.offset), w, f), o, s);
}
function SX(t, e, r, n) {
  const i = t(e.calendar), s = [...i.fields(qa), ...Wa].sort(), o = {
    ...aM(a = e),
    hour: a.isoHour,
    minute: a.isoMinute,
    second: a.isoSecond,
    millisecond: a.isoMillisecond,
    microsecond: a.isoMicrosecond,
    nanosecond: a.isoNanosecond
  };
  var a;
  const l = ps(r, s), c = gr(n), p = i.k(o, l), h = {
    ...o,
    ...l
  };
  return to(Vi({
    ...i.F(p, X2(c)),
    ...vd(c5(h), c)
  }));
}
function AX(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(qa).sort(), o = aM(e), a = ps(r, s), l = i.k(o, a);
  return i.F(l, n);
}
function kX(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(q6).sort(), o = ((c) => {
    const p = yb(c.calendar), [h, d] = p.v(c), [b, m] = p.q(h, d);
    return {
      year: h,
      monthCode: dg(b, m)
    };
  })(e), a = ps(r, s), l = i.k(o, a);
  return i.K(l, n);
}
function _X(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(qa).sort(), o = ((c) => {
    const p = yb(c.calendar), [h, d, b] = p.v(c), [m, w] = p.q(h, d);
    return {
      monthCode: dg(m, w),
      day: b
    };
  })(e), a = ps(r, s), l = i.k(o, a);
  return i._(l, n);
}
function CX(t, e, r) {
  return ea(((n, i, s) => gg({
    ...Xs(Cx, n),
    ...ps(i, Cx)
  }, gr(s)))(t, e, r));
}
function IX(t, e) {
  return gn((r = t, n = e, Th({
    ...r,
    ...ps(n, Q6)
  })));
  var r, n;
}
function oM(t, e, r, n, i) {
  e = Xs(r = t.fields(r), e), n = ps(n, i = t.fields(i), []);
  let s = t.k(e, n);
  return s = ps(s, [...r, ...i].sort(), []), t.F(s);
}
function dw(t, e) {
  const r = Sx(t), n = PM[t.id || ""] || {};
  let { era: i, eraYear: s, year: o } = e;
  if (i !== void 0 || s !== void 0) {
    if (i === void 0 || s === void 0)
      throw new TypeError(uee);
    if (!r)
      throw new RangeError(cee);
    const a = r[n[i] || i];
    if (a === void 0)
      throw new RangeError(pee(i));
    const l = JL(s, a);
    if (o !== void 0 && o !== l)
      throw new RangeError(hee);
    o = l;
  } else if (o === void 0)
    throw new TypeError(dee(r));
  return o;
}
function Lm(t, e, r, n) {
  let { month: i, monthCode: s } = e;
  if (s !== void 0) {
    const o = ((a, l, c, p) => {
      const h = a.L(c), [d, b] = B6(l);
      let m = gy(d, b, h);
      if (b) {
        const w = XL(a);
        if (w === void 0)
          throw new RangeError(bf);
        if (w > 0) {
          if (m > w)
            throw new RangeError(bf);
          if (h === void 0) {
            if (p === 1)
              throw new RangeError(bf);
            m--;
          }
        } else {
          if (m !== -w)
            throw new RangeError(bf);
          if (h === void 0 && p === 1)
            throw new RangeError(bf);
        }
      }
      return m;
    })(t, s, r, n);
    if (i !== void 0 && i !== o)
      throw new RangeError(gee);
    i = o, n = 1;
  } else if (i === void 0)
    throw new TypeError(gM);
  return Ta("month", i, 1, t.B(r), n);
}
function fw(t, e, r, n, i) {
  return Ti(e, "day", 1, t.U(n, r), i);
}
function gw(t, e, r, n) {
  let i = 0;
  const s = [];
  for (const o of r)
    e[o] !== void 0 ? i = 1 : s.push(o);
  if (Object.assign(t, e), i)
    for (const o of n || s)
      delete t[o];
}
function aM(t) {
  const e = yb(t.calendar), [r, n, i] = e.v(t), [s, o] = e.q(r, n);
  return {
    year: r,
    monthCode: dg(s, o),
    day: i
  };
}
function PX(t) {
  return Ua(Jo(n6(e6(t))));
}
function RX(t, e, r, n, i = cr) {
  return eo(Jo(n6(e6(r))), e(n), t(i));
}
function OX(t, e, r, n, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, p = cr) {
  return to(Vi(K2(La(ii, md(gb, [e, r, n, i, s, o, a, l, c])))), t(p));
}
function TX(t, e, r, n, i = cr) {
  return Ha(js(Rh(La(ii, {
    isoYear: e,
    isoMonth: r,
    isoDay: n
  }))), t(i));
}
function LX(t, e, r, n = cr, i = 1) {
  const s = ii(e), o = ii(r), a = t(n);
  return d0(s6(Rh({
    isoYear: s,
    isoMonth: o,
    isoDay: ii(i)
  })), a);
}
function MX(t, e, r, n = cr, i = xa) {
  const s = ii(e), o = ii(r), a = t(n);
  return py(js(Rh({
    isoYear: ii(i),
    isoMonth: s,
    isoDay: o
  })), a);
}
function NX(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0) {
  return ea(vd(La(ii, md(ro, [t, e, r, n, i, s])), 1));
}
function DX(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0) {
  return gn(Th(La(t6, md(vr, [t, e, r, n, i, s, o, a, l, c]))));
}
function $X(t, e, r = cr) {
  return eo(t.epochNanoseconds, e, r);
}
function jX(t) {
  return Ua(t.epochNanoseconds);
}
function lM(t, e) {
  return to(ds(e, t));
}
function cM(t, e) {
  return Ha(ds(e, t));
}
function uM(t, e) {
  return ea(ds(e, t));
}
function BX(t, e, r, n) {
  const i = ((s, o, a, l) => {
    const c = ((p) => jM(Xo(p)))(l);
    return pg(s(o), a, c);
  })(t, r, e, n);
  return eo(Jo(i), r, e.calendar);
}
function FX(t, e, r, n, i) {
  const s = t(i.timeZone), o = i.plainTime, a = o !== void 0 ? e(o) : void 0, l = r(s);
  let c;
  return c = a ? pg(l, {
    ...n,
    ...a
  }) : Yl(l, {
    ...n,
    ...Ui
  }), eo(c, s, n.calendar);
}
function zX(t, e = Ui) {
  return to(Vi({
    ...t,
    ...e
  }));
}
function VX(t, e, r) {
  return ((n, i) => {
    const s = bc(n, i, kM);
    return n.K(s, void 0);
  })(t(e.calendar), r);
}
function UX(t, e, r) {
  return ((n, i) => {
    const s = bc(n, i, _M);
    return n._(s);
  })(t(e.calendar), r);
}
function HX(t, e, r, n) {
  return ((i, s, o) => oM(i, s, kM, cg(o), yg))(t(e.calendar), r, n);
}
function GX(t, e, r, n) {
  return ((i, s, o) => oM(i, s, _M, cg(o), H6))(t(e.calendar), r, n);
}
function WX(t) {
  return Ua(Jo(uy(t6(t), Ga)));
}
function qX(t) {
  return Ua(Jo(n6(e6(t))));
}
function Mh(t, e, r) {
  const n = new Set(r);
  return (i, s) => {
    const o = r && Bk(i, r);
    if (!Bk(i = ((a, l) => {
      const c = {};
      for (const p in l)
        a.has(p) || (c[p] = l[p]);
      return c;
    })(n, i), t)) {
      if (s && o)
        throw new TypeError("Invalid formatting options");
      i = {
        ...e,
        ...i
      };
    }
    return r && (i.timeZone = Nh, ["full", "long"].includes(i.J) && (i.J = "medium")), i;
  };
}
function vc(t, e = hM, r = 0) {
  const [n, , , i] = t;
  return (s, o = Kte, ...a) => {
    const l = e(i && i(...a), s, o, n, r), c = l.resolvedOptions();
    return [l, ...QX(t, c, a)];
  };
}
function hM(t, e, r, n, i) {
  if (r = n(r, i), t) {
    if (r.timeZone !== void 0)
      throw new TypeError(Cee);
    r.timeZone = t;
  }
  return new $l(e, r);
}
function QX(t, e, r) {
  const [, n, i] = t;
  return r.map((s) => (s.calendar && ((o, a, l) => {
    if ((l || o !== cr) && o !== a)
      throw new RangeError(yM);
  })(s.calendar, e.calendar, i), n(s, e)));
}
function KX(t, e, r) {
  const n = e.timeZone, i = t(n), s = {
    ...ds(e, i),
    ...r || Ui
  };
  let o;
  return o = r ? xd(i, s, s.offsetNanoseconds, 2) : Yl(i, s), eo(o, n, e.calendar);
}
function YX(t, e = Ui) {
  return to(Vi({
    ...t,
    ...e
  }));
}
function z6(t, e) {
  return {
    ...t,
    calendar: e
  };
}
function ZX(t, e) {
  return {
    ...t,
    timeZone: e
  };
}
function mw(t) {
  const e = Ax();
  return bd(e, t.R(e));
}
function Ax() {
  return uy(Date.now(), Ga);
}
function yf() {
  return y7 || (y7 = new $l().resolvedOptions().timeZone);
}
const JX = (t, e) => `Non-integer ${t}: ${e}`, XX = (t, e) => `Non-positive ${t}: ${e}`, eee = (t, e) => `Non-finite ${t}: ${e}`, tee = (t) => `Cannot convert bigint to ${t}`, ree = (t) => `Invalid bigint: ${t}`, nee = "Cannot convert Symbol to string", iee = "Invalid object", pM = (t, e, r, n, i) => i ? pM(t, i[e], i[r], i[n]) : wc(t, e) + `; must be between ${r}-${n}`, wc = (t, e) => `Invalid ${t}: ${e}`, V6 = (t) => `Missing ${t}`, see = (t) => `Invalid field ${t}`, oee = (t) => `Duplicate field ${t}`, dM = (t) => "No valid fields: " + t.join(), aee = "Invalid bag", fM = (t, e, r) => wc(t, e) + "; must be " + Object.keys(r).join(), lee = "Cannot use valueOf", kx = "Invalid calling context", cee = "Forbidden era/eraYear", uee = "Mismatching era/eraYear", hee = "Mismatching year/eraYear", pee = (t) => `Invalid era: ${t}`, dee = (t) => "Missing year" + (t ? "/era/eraYear" : ""), fee = (t) => `Invalid monthCode: ${t}`, gee = "Mismatching month/monthCode", gM = "Missing month/monthCode", bf = "Invalid leap month", kd = "Invalid protocol results", mM = (t) => wc("Calendar", t), yM = "Mismatching Calendars", bM = (t) => wc("TimeZone", t), vM = "Mismatching TimeZones", mee = "Forbidden ICU TimeZone", yee = "Out-of-bounds offset", bee = "Out-of-bounds TimeZone gap", vee = "Invalid TimeZone offset", wee = "Ambiguous offset", xc = "Out-of-bounds date", xee = "Out-of-bounds duration", Eee = "Cannot mix duration signs", pb = "Missing relativeTo", See = "Cannot use large units", Aee = "Required smallestUnit or largestUnit", kee = "smallestUnit > largestUnit", Ni = (t) => `Cannot parse: ${t}`, wa = (t) => `Invalid substring: ${t}`, _ee = (t) => `Cannot format ${t}`, yw = "Mismatching types for formatting", Cee = "Cannot specify TimeZone", wM = /* @__PURE__ */ nr(H2, (t, e) => e), Gp = /* @__PURE__ */ nr(H2, (t, e, r) => r), Bs = /* @__PURE__ */ nr(cy, 2), _x = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, U6 = /* @__PURE__ */ Object.keys(_x), Bi = 864e5, xM = 1e3, mg = 1e3, Ga = 1e6, No = 1e9, db = 6e10, fb = 36e11, jr = 864e11, zo = [1, mg, Ga, No, db, fb, jr], Wa = /* @__PURE__ */ U6.slice(0, 6), Cx = /* @__PURE__ */ lg(Wa), Iee = ["offset"], EM = ["timeZone"], SM = /* @__PURE__ */ Wa.concat(Iee), AM = /* @__PURE__ */ SM.concat(EM), Ix = ["era", "eraYear"], Pee = /* @__PURE__ */ Ix.concat(["year"]), H6 = ["year"], G6 = ["monthCode"], W6 = /* @__PURE__ */ ["month"].concat(G6), yg = ["day"], q6 = /* @__PURE__ */ W6.concat(H6), kM = /* @__PURE__ */ G6.concat(H6), qa = /* @__PURE__ */ yg.concat(q6), Ree = /* @__PURE__ */ yg.concat(W6), _M = /* @__PURE__ */ yg.concat(G6), CM = /* @__PURE__ */ Gp(Wa, 0), cr = "iso8601", _d = "gregory", Zl = "japanese", IM = {
  [_d]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [Zl]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, PM = {
  [_d]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [Zl]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
}, Oee = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, Jn = /* @__PURE__ */ nr(JE, "string"), Tee = /* @__PURE__ */ nr(JE, "boolean"), Lee = /* @__PURE__ */ nr(JE, "number"), vr = /* @__PURE__ */ U6.map((t) => t + "s"), Q6 = /* @__PURE__ */ lg(vr), Mee = /* @__PURE__ */ vr.slice(0, 6), RM = /* @__PURE__ */ vr.slice(6), Nee = /* @__PURE__ */ RM.slice(1), Dee = /* @__PURE__ */ wM(vr), Ln = /* @__PURE__ */ Gp(vr, 0), K6 = /* @__PURE__ */ Gp(Mee, 0), Y6 = /* @__PURE__ */ nr(tL, vr), ro = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"], Z6 = ["isoDay", "isoMonth", "isoYear"], gb = /* @__PURE__ */ ro.concat(Z6), J6 = /* @__PURE__ */ lg(Z6), OM = /* @__PURE__ */ lg(ro), $ee = /* @__PURE__ */ lg(gb), Ui = /* @__PURE__ */ Gp(OM, 0), jee = /* @__PURE__ */ nr(tL, gb), TM = 1e8, Bee = TM * Bi, Fee = [TM, 0], zee = [-1e8, 0], y0 = 275760, b0 = -271821, $l = Intl.DateTimeFormat, LM = "en-GB", Vee = 1970, xa = 1972, hl = 12, Uee = /* @__PURE__ */ yd(1868, 9, 8), Hee = /* @__PURE__ */ us(AJ, WeakMap), yy = "smallestUnit", Px = "unit", Wf = "roundingIncrement", bw = "fractionalSecondDigits", MM = "relativeTo", vw = "direction", NM = {
  constrain: 0,
  reject: 1
}, Gee = /* @__PURE__ */ Object.keys(NM), Wee = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}, qee = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}, Qee = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}, Kee = {
  auto: 0,
  never: 1,
  critical: 2
}, Yee = {
  auto: 0,
  never: 1
}, Zee = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}, Jee = {
  previous: -1,
  next: 1
}, bg = /* @__PURE__ */ nr(f6, yy), DM = /* @__PURE__ */ nr(f6, "largestUnit"), Xee = /* @__PURE__ */ nr(f6, Px), $M = /* @__PURE__ */ nr(gc, "overflow", NM), jM = /* @__PURE__ */ nr(gc, "disambiguation", Wee), ete = /* @__PURE__ */ nr(gc, "offset", qee), X6 = /* @__PURE__ */ nr(gc, "calendarName", Qee), tte = /* @__PURE__ */ nr(gc, "timeZoneName", Kee), rte = /* @__PURE__ */ nr(gc, "offset", Yee), vg = /* @__PURE__ */ nr(gc, "roundingMode", Zee), e5 = "PlainYearMonth", t5 = "PlainMonthDay", wg = "PlainDate", Cd = "PlainDateTime", r5 = "PlainTime", Ec = "ZonedDateTime", n5 = "Instant", i5 = "Duration", nte = [Math.floor, (t) => Rm(t) ? Math.floor(t) : Math.round(t), Math.ceil, (t) => Rm(t) ? Math.ceil(t) : Math.round(t), Math.trunc, (t) => Rm(t) ? Math.trunc(t) || 0 : Math.round(t), (t) => t < 0 ? Math.floor(t) : Math.ceil(t), (t) => Math.sign(t) * Math.round(Math.abs(t)) || 0, (t) => Rm(t) ? (t = Math.trunc(t) || 0) + t % 2 : Math.round(t)], Nh = "UTC", y1 = 5184e3, ite = /* @__PURE__ */ hy(1847), ste = /* @__PURE__ */ hy(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10), ote = /0+$/, ds = /* @__PURE__ */ us(BJ, WeakMap), ate = 2 ** 32 - 1, Qt = /* @__PURE__ */ us((t) => {
  const e = N6(t);
  return typeof e == "object" ? new cte(e) : new lte(e || 0);
});
class lte {
  constructor(e) {
    this.$ = e;
  }
  R() {
    return this.$;
  }
  I(e) {
    return ((r) => {
      const n = Pn({
        ...r,
        ...Ui
      });
      if (!n || Math.abs(n[0]) > 1e8)
        throw new RangeError(xc);
    })(e), [o6(e, this.$)];
  }
  O() {
  }
}
class cte {
  constructor(e) {
    this.nn = ((r) => {
      function n(c) {
        const p = p0(c, a, l), [h, d] = o7(p), b = s(h), m = s(d);
        return b === m ? b : i(o(h, d), b, m, c);
      }
      function i(c, p, h, d) {
        let b, m;
        for (; (d === void 0 || (b = d < c[0] ? p : d >= c[1] ? h : void 0) === void 0) && (m = c[1] - c[0]); ) {
          const w = c[0] + Math.floor(m / 2);
          r(w) === h ? c[1] = w : c[0] = w + 1;
        }
        return b;
      }
      const s = us(r), o = us(UJ);
      let a = ite, l = ste;
      return {
        tn(c) {
          const p = n(c - 86400), h = n(c + 86400), d = c - p, b = c - h;
          if (p === h)
            return [d];
          const m = n(d);
          return m === n(b) ? [c - m] : p > h ? [d, b] : [];
        },
        rn: n,
        O(c, p) {
          const h = p0(c, a, l);
          let [d, b] = o7(h);
          const m = y1 * p, w = p < 0 ? () => b > a || (a = h, 0) : () => d < l || (l = h, 0);
          for (; w(); ) {
            const f = s(d), E = s(b);
            if (f !== E) {
              const A = o(d, b);
              i(A, f, E);
              const x = A[0];
              if ((Dl(x, c) || 1) === p)
                return x;
            }
            d += m, b += m;
          }
        }
      };
    })(/* @__PURE__ */ ((r) => (n) => {
      const i = a6(r, n * xM);
      return hy(rM(i), parseInt(i.month), parseInt(i.day), parseInt(i.hour), parseInt(i.minute), parseInt(i.second)) - n;
    })(e));
  }
  R(e) {
    return this.nn.rn(((r) => Vk(r)[0])(e)) * No;
  }
  I(e) {
    const [r, n] = [hy((i = e).isoYear, i.isoMonth, i.isoDay, i.isoHour, i.isoMinute, i.isoSecond), i.isoMillisecond * Ga + i.isoMicrosecond * mg + i.isoNanosecond];
    var i;
    return this.nn.tn(r).map((s) => Jo(rh(uy(s, No), n)));
  }
  O(e, r) {
    const [n, i] = Vk(e), s = this.nn.O(n + (r > 0 || i ? 1 : 0), r);
    if (s !== void 0)
      return uy(s, No);
  }
}
const s5 = "([+-])", b1 = "(?:[.,](\\d{1,9}))?", BM = `(?:(?:${s5}(\\d{6}))|(\\d{4}))-?(\\d{2})`, o5 = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + b1 + ")?)?", a5 = s5 + o5, ute = BM + "-?(\\d{2})(?:[T ]" + o5 + "(Z|" + a5 + ")?)?", FM = "\\[(!?)([^\\]]*)\\]", mb = `((?:${FM}){0,9})`, hte = /* @__PURE__ */ Sd(BM + mb), pte = /* @__PURE__ */ Sd("(?:--)?(\\d{2})-?(\\d{2})" + mb), dte = /* @__PURE__ */ Sd(ute + mb), fte = /* @__PURE__ */ Sd("T?" + o5 + "(?:" + a5 + ")?" + mb), gte = /* @__PURE__ */ Sd(a5), mte = /* @__PURE__ */ new RegExp(FM, "g"), yte = /* @__PURE__ */ Sd(`${s5}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${b1}H)?(?:(\\d+)${b1}M)?(?:(\\d+)${b1}S)?)?`), bte = /* @__PURE__ */ us((t) => new $l(LM, {
  timeZone: t,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
})), vte = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, wte = /[^\w\/:+-]+/, xte = /^M(\d{2})(L?)$/, Ete = /* @__PURE__ */ us(hX), l5 = /* @__PURE__ */ us((t) => new $l(LM, {
  calendar: t,
  timeZone: Nh,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
})), zM = {
  P(t, e, r) {
    const n = gr(r);
    let i, { years: s, months: o, weeks: a, days: l } = e;
    if (l += Tn(e, 5)[0], s || o)
      i = ((c, p, h, d, b) => {
        let [m, w, f] = c.v(p);
        if (h) {
          const [E, A] = c.q(m, w);
          m += h, w = gy(E, A, c.L(m)), w = Ta("month", w, 1, c.B(m), b);
        }
        return d && ([m, w] = c.un(m, w, d)), f = Ta("day", f, 1, c.U(m, w), b), c.p(m, w, f);
      })(this, t, s, o, n);
    else {
      if (!a && !l)
        return t;
      i = ai(t);
    }
    if (i === void 0)
      throw new RangeError(xc);
    return i += (7 * a + l) * Bi, js(Q2(i));
  },
  N(t, e, r) {
    if (r <= 7) {
      let l = 0, c = KL({
        ...t,
        ...Ui
      }, {
        ...e,
        ...Ui
      });
      return r === 7 && ([l, c] = ql(c, 7)), {
        ...Ln,
        weeks: l,
        days: c
      };
    }
    const n = this.v(t), i = this.v(e);
    let [s, o, a] = ((l, c, p, h, d, b, m) => {
      let w = d - c, f = b - p, E = m - h;
      if (w || f) {
        const A = Math.sign(w || f);
        let x = l.U(d, b), g = 0;
        if (Math.sign(E) === -A) {
          const v = x;
          [d, b] = l.un(d, b, -A), w = d - c, f = b - p, x = l.U(d, b), g = A < 0 ? -v : x;
        }
        if (E = m - Math.min(h, x) + g, w) {
          const [v, k] = l.q(c, p), [S, R] = l.q(d, b);
          if (f = S - v || Number(R) - Number(k), Math.sign(f) === -A) {
            const L = A < 0 && -l.B(d);
            w = (d -= A) - c, f = b - gy(v, k, l.L(d)) + (L || l.B(d));
          }
        }
      }
      return [w, f, E];
    })(this, ...n, ...i);
    return r === 8 && (o += this.cn(s, n[0]), s = 0), {
      ...Ln,
      years: s,
      months: o,
      days: a
    };
  },
  F(t, e) {
    const r = gr(e), n = dw(this, t), i = Lm(this, t, n, r), s = fw(this, t, i, n, r);
    return Ha(js(this.V(n, i, s)), this.id || cr);
  },
  K(t, e) {
    const r = gr(e), n = dw(this, t), i = Lm(this, t, n, r);
    return d0(s6(this.V(n, i, 1)), this.id || cr);
  },
  _(t, e) {
    const r = gr(e);
    let n, i, s, o = t.eraYear !== void 0 || t.year !== void 0 ? dw(this, t) : void 0;
    const a = !this.id;
    if (o === void 0 && a && (o = xa), o !== void 0) {
      const h = Lm(this, t, o, r);
      n = fw(this, t, h, o, r);
      const d = this.L(o);
      i = F6(h, d), s = h === d;
    } else {
      if (t.monthCode === void 0)
        throw new TypeError(gM);
      if ([i, s] = B6(t.monthCode), this.id && this.id !== _d && this.id !== Zl)
        if (this.id && ih(this.id) === "coptic" && r === 0) {
          const h = s || i !== 13 ? 30 : 6;
          n = t.day, n = p0(n, 1, h);
        } else if (this.id && ih(this.id) === "chinese" && r === 0) {
          const h = !s || i !== 1 && i !== 9 && i !== 10 && i !== 11 && i !== 12 ? 30 : 29;
          n = t.day, n = p0(n, 1, h);
        } else
          n = t.day;
      else
        n = fw(this, t, Lm(this, t, xa, r), xa, r);
    }
    const l = this.G(i, s, n);
    if (!l)
      throw new RangeError("Cannot guess year");
    const [c, p] = l;
    return py(js(this.V(c, p, n)), this.id || cr);
  },
  fields(t) {
    return Sx(this) && t.includes("year") ? [...t, ...Ix] : t;
  },
  k(t, e) {
    const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
    return gw(r, e, W6), Sx(this) && (gw(r, e, Pee), this.id === Zl && gw(r, e, Ree, Ix)), r;
  },
  inLeapYear(t) {
    const [e] = this.v(t);
    return this.sn(e);
  },
  monthsInYear(t) {
    const [e] = this.v(t);
    return this.B(e);
  },
  daysInMonth(t) {
    const [e, r] = this.v(t);
    return this.U(e, r);
  },
  daysInYear(t) {
    const [e] = this.v(t);
    return this.fn(e);
  },
  dayOfYear: j6,
  era(t) {
    return this.hn(t)[0];
  },
  eraYear(t) {
    return this.hn(t)[1];
  },
  monthCode(t) {
    const [e, r] = this.v(t), [n, i] = this.q(e, r);
    return dg(n, i);
  },
  dayOfWeek: fL,
  daysInWeek() {
    return 7;
  }
}, Ste = {
  v: l6,
  hn: gL,
  q: uL
}, Ate = {
  dayOfYear: j6,
  v: l6,
  p: yd
}, kte = /* @__PURE__ */ Object.assign({}, Ate, {
  weekOfYear: YL,
  yearOfWeek: ZL,
  m(t) {
    function e(b) {
      return (7 - b < n ? 7 : 0) - b;
    }
    function r(b) {
      const m = dL(d + b), w = b || 1, f = e(Gf(l + m * w, 7));
      return p = (m + (f - c) * w) / 7;
    }
    const n = this.id ? 1 : 4, i = fL(t), s = this.dayOfYear(t), o = Gf(i - 1, 7), a = s - 1, l = Gf(o - a, 7), c = e(l);
    let p, h = Math.floor((a - c) / 7) + 1, d = t.isoYear;
    return h ? h > r(0) && (h = 1, d++) : (h = r(-1), d--), [h, d, p];
  }
}), _te = /* @__PURE__ */ Object.assign({}, zM, kte, {
  v: l6,
  hn: gL,
  q: uL,
  G(t, e) {
    if (!e)
      return [xa, t];
  },
  sn: c6,
  L() {
  },
  B: hL,
  cn: (t) => t * hl,
  U: pL,
  fn: dL,
  V: (t, e, r) => ({
    isoYear: t,
    isoMonth: e,
    isoDay: r
  }),
  p: yd,
  un: (t, e, r) => (t += G2(r, hl), (e += YE(r, hl)) < 1 ? (t--, e += hl) : e > hl && (t++, e -= hl), [t, e]),
  year(t) {
    return t.isoYear;
  },
  month(t) {
    return t.isoMonth;
  },
  day: (t) => t.isoDay
}), Cte = {
  v: my,
  hn: iM,
  q: nM
}, Ite = {
  dayOfYear: j6,
  v: my,
  p: m0,
  weekOfYear: YL,
  yearOfWeek: ZL,
  m() {
    return [];
  }
}, Pte = /* @__PURE__ */ Object.assign({}, zM, Ite, {
  v: my,
  hn: iM,
  q: nM,
  G(t, e, r) {
    const n = this.id && ih(this.id) === "chinese" ? ((c, p, h) => {
      if (p)
        switch (c) {
          case 1:
            return 1651;
          case 2:
            return h < 30 ? 1947 : 1765;
          case 3:
            return h < 30 ? 1966 : 1955;
          case 4:
            return h < 30 ? 1963 : 1944;
          case 5:
            return h < 30 ? 1971 : 1952;
          case 6:
            return h < 30 ? 1960 : 1941;
          case 7:
            return h < 30 ? 1968 : 1938;
          case 8:
            return h < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      return 1972;
    })(t, e, r) : xa;
    let [i, s, o] = my.call(this, {
      isoYear: n,
      isoMonth: hl,
      isoDay: 31
    });
    const a = m1.call(this, i), l = s === a;
    (Dl(t, F6(s, a)) || Dl(Number(e), Number(l)) || Dl(r, o)) === 1 && i--;
    for (let c = 0; c < 100; c++) {
      const p = i - c, h = m1.call(this, p), d = gy(t, e, h);
      if (e === (d === h) && r <= f7.call(this, p, d))
        return [p, d];
    }
  },
  sn(t) {
    const e = Om.call(this, t);
    return e > Om.call(this, t - 1) && e > Om.call(this, t + 1);
  },
  L: m1,
  B: Tm,
  cn(t, e) {
    const r = e + t, n = Math.sign(t), i = n < 0 ? -1 : 0;
    let s = 0;
    for (let o = e; o !== r; o += n)
      s += Tm.call(this, o + i);
    return s;
  },
  U: f7,
  fn: Om,
  V(t, e, r) {
    return Q2(m0.call(this, t, e, r));
  },
  p: m0,
  un(t, e, r) {
    if (r) {
      if (e += r, !Number.isSafeInteger(e))
        throw new RangeError(xc);
      if (r < 0)
        for (; e < 1; )
          e += Tm.call(this, --t);
      else {
        let n;
        for (; e > (n = Tm.call(this, t)); )
          e -= n, t++;
      }
    }
    return [t, e];
  },
  year(t) {
    return this.h(t).year;
  },
  month(t) {
    const { year: e, o: r } = this.h(t), { u: n } = this.l(e);
    return n[r] + 1;
  },
  day(t) {
    return this.h(t).day;
  }
}), yb = /* @__PURE__ */ sM(Ste, Cte), jt = /* @__PURE__ */ sM(_te, Pte), m7 = {
  era: g1,
  eraYear: ii,
  year: ii,
  month: zk,
  monthCode(t) {
    const e = g1(t);
    return B6(e), e;
  },
  day: zk,
  .../* @__PURE__ */ Gp(Wa, ii),
  .../* @__PURE__ */ Gp(vr, t6),
  offset(t) {
    const e = g1(t);
    return Lh(e), e;
  }
}, c5 = /* @__PURE__ */ nr(XT, Wa, ro), Rte = /* @__PURE__ */ nr(XT, ro, Wa), jl = "numeric", xg = ["timeZoneName"], VM = {
  month: jl,
  day: jl
}, u5 = {
  year: jl,
  month: jl
}, h5 = /* @__PURE__ */ Object.assign({}, u5, {
  day: jl
}), p5 = {
  hour: jl,
  minute: jl,
  second: jl
}, d5 = /* @__PURE__ */ Object.assign({}, h5, p5), Ote = /* @__PURE__ */ Object.assign({}, d5, {
  timeZoneName: "short"
}), Tte = /* @__PURE__ */ Object.keys(u5), Lte = /* @__PURE__ */ Object.keys(VM), Mte = /* @__PURE__ */ Object.keys(h5), Nte = /* @__PURE__ */ Object.keys(p5), f5 = ["dateStyle"], Dte = /* @__PURE__ */ Tte.concat(f5), $te = /* @__PURE__ */ Lte.concat(f5), g5 = /* @__PURE__ */ Mte.concat(f5, ["weekday"]), Eg = /* @__PURE__ */ Nte.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]), m5 = /* @__PURE__ */ g5.concat(Eg), jte = /* @__PURE__ */ xg.concat(Eg), Bte = /* @__PURE__ */ xg.concat(g5), Fte = /* @__PURE__ */ xg.concat(["day", "weekday"], Eg), zte = /* @__PURE__ */ xg.concat(["year", "weekday"], Eg), Vte = /* @__PURE__ */ Mh(m5, d5), Ute = /* @__PURE__ */ Mh(m5, Ote), Hte = /* @__PURE__ */ Mh(m5, d5, xg), Gte = /* @__PURE__ */ Mh(g5, h5, jte), Wte = /* @__PURE__ */ Mh(Eg, p5, Bte), qte = /* @__PURE__ */ Mh(Dte, u5, Fte), Qte = /* @__PURE__ */ Mh($te, VM, zte), Kte = {}, UM = new $l(void 0, {
  calendar: cr
}).resolvedOptions().calendar === cr, HM = [Vte, g6], Yte = [Ute, g6, 0, (t, e) => {
  const r = t.timeZone;
  if (e && e.timeZone !== r)
    throw new RangeError(vM);
  return r;
}], GM = [Hte, ai], WM = [Gte, ai], qM = [Wte, (t) => Ql(t) / Ga], QM = [qte, ai, UM], KM = [Qte, ai, UM];
let y7;
function Sc(t, e, r, n, i) {
  function s(...l) {
    if (!(this instanceof s))
      throw new TypeError(kx);
    w7(this, e(...l));
  }
  function o(l, c) {
    return Object.defineProperties(function(...p) {
      return l.call(this, a(this), ...p);
    }, h0(c));
  }
  function a(l) {
    const c = yi(l);
    if (!c || c.branding !== t)
      throw new TypeError(kx);
    return c;
  }
  return Object.defineProperties(s.prototype, {
    ...xJ(La(o, r)),
    ...Vp(La(o, n)),
    ...KE("Temporal." + t)
  }), Object.defineProperties(s, {
    ...Vp(i),
    ...h0(t)
  }), [s, (l) => {
    const c = Object.create(s.prototype);
    return w7(c, l), c;
  }, a];
}
function Id(t) {
  if (yi(t) || t.calendar !== void 0 || t.timeZone !== void 0)
    throw new TypeError(aee);
  return t;
}
function Sg(t) {
  return YM(t) || cr;
}
function YM(t) {
  const { calendar: e } = t;
  if (e !== void 0)
    return bb(e);
}
function bb(t) {
  if (gi(t)) {
    const { calendar: e } = yi(t) || {};
    if (!e)
      throw new TypeError(mM(t));
    return e;
  }
  return ((e) => hb(JJ(Jn(e))))(t);
}
function y5(t) {
  const e = {};
  for (const r in t)
    e[r] = (n) => {
      const { calendar: i } = n;
      return jt(i)[r](n);
    };
  return e;
}
function Ac() {
  throw new TypeError(lee);
}
function ss(t) {
  if (gi(t)) {
    const { timeZone: e } = yi(t) || {};
    if (!e)
      throw new TypeError(bM(t));
    return e;
  }
  return ((e) => M6(XJ(Jn(e))))(t);
}
function ln(t) {
  if (gi(t)) {
    const e = yi(t);
    return e && e.branding === i5 ? e : xX(t);
  }
  return ZJ(t);
}
function vf(t) {
  if (t !== void 0) {
    if (gi(t)) {
      const e = yi(t) || {};
      switch (e.branding) {
        case Ec:
        case wg:
          return e;
        case Cd:
          return Ha(e);
      }
      const r = Sg(t);
      return {
        ...fX(ss, Qt, jt(r), t),
        calendar: r
      };
    }
    return GJ(t);
  }
}
function pl(t, e) {
  if (gi(t)) {
    const n = yi(t) || {};
    switch (n.branding) {
      case r5:
        return gr(e), n;
      case Cd:
        return gr(e), ea(n);
      case Ec:
        return gr(e), uM(Qt, n);
    }
    return wX(t, e);
  }
  const r = YJ(t);
  return gr(e), r;
}
function b5(t) {
  return t === void 0 ? void 0 : pl(t);
}
function ep(t, e) {
  if (gi(t)) {
    const n = yi(t) || {};
    switch (n.branding) {
      case Cd:
        return gr(e), n;
      case wg:
        return gr(e), to({
          ...n,
          ...Ui
        });
      case Ec:
        return gr(e), lM(Qt, n);
    }
    return mX(jt(Sg(t)), t, e);
  }
  const r = qJ(t);
  return gr(e), r;
}
function b7(t, e) {
  if (gi(t)) {
    const n = yi(t);
    if (n && n.branding === t5)
      return gr(e), n;
    const i = YM(t);
    return vX(jt(i || cr), !i, t, e);
  }
  const r = KJ(jt, t);
  return gr(e), r;
}
function tp(t, e) {
  if (gi(t)) {
    const n = yi(t);
    return n && n.branding === e5 ? (gr(e), n) : bX(jt(Sg(t)), t, e);
  }
  const r = QJ(jt, t);
  return gr(e), r;
}
function rp(t, e) {
  if (gi(t)) {
    const n = yi(t) || {};
    switch (n.branding) {
      case wg:
        return gr(e), n;
      case Cd:
        return gr(e), Ha(n);
      case Ec:
        return gr(e), cM(Qt, n);
    }
    return yX(jt(Sg(t)), t, e);
  }
  const r = C6(t);
  return gr(e), r;
}
function np(t, e) {
  if (gi(t)) {
    const r = yi(t);
    if (r && r.branding === Ec)
      return Y2(e), r;
    const n = Sg(t);
    return gX(ss, Qt, jt(n), n, t, e);
  }
  return WJ(t, e);
}
function v7(t) {
  return La((e) => (r) => e(Rx(r)), t);
}
function Rx(t) {
  return ds(t, Qt);
}
function ip(t) {
  if (gi(t)) {
    const e = yi(t);
    if (e)
      switch (e.branding) {
        case n5:
          return e;
        case Ec:
          return Ua(e.epochNanoseconds);
      }
  }
  return HJ(t);
}
function Zte() {
  function t(s, o) {
    return new e(s, o);
  }
  function e(s, o = /* @__PURE__ */ Object.create(null)) {
    vy.set(this, ((a, l) => {
      const c = new $l(a, l), p = c.resolvedOptions(), h = p.locale, d = Xs(Object.keys(l), p), b = us(ere), m = (w, ...f) => {
        if (w) {
          if (f.length !== 2)
            throw new TypeError(yw);
          for (const g of f)
            if (g === void 0)
              throw new TypeError(yw);
        }
        w || f[0] !== void 0 || (f = []);
        const E = f.map((g) => yi(g) || Number(g));
        let A, x = 0;
        for (const g of E) {
          const v = typeof g == "object" ? g.branding : void 0;
          if (x++ && v !== A)
            throw new TypeError(yw);
          A = v;
        }
        return A ? b(A)(h, d, ...E) : [c, ...E];
      };
      return m.X = c, m;
    })(s, o));
  }
  const r = $l.prototype, n = Object.getOwnPropertyDescriptors(r), i = Object.getOwnPropertyDescriptors($l);
  for (const s in n) {
    const o = n[s], a = s.startsWith("format") && Jte(s);
    typeof o.value == "function" ? o.value = s === "constructor" ? t : a || Xte(s) : a && (o.get = function() {
      if (!vy.has(this))
        throw new TypeError(kx);
      return (...l) => a.apply(this, l);
    }, Object.defineProperties(o.get, h0(`get ${s}`)));
  }
  return i.prototype.value = e.prototype = Object.create({}, n), Object.defineProperties(t, i), t;
}
function Jte(t) {
  return Object.defineProperties(function(...e) {
    const r = vy.get(this), [n, ...i] = r(t.includes("Range"), ...e);
    return n[t](...i);
  }, h0(t));
}
function Xte(t) {
  return Object.defineProperties(function(...e) {
    return vy.get(this).X[t](...e);
  }, h0(t));
}
function ere(t) {
  const e = ore[t];
  if (!e)
    throw new TypeError(_ee(t));
  return vc(e, us(hM), 1);
}
const by = /* @__PURE__ */ new WeakMap(), yi = /* @__PURE__ */ by.get.bind(by), w7 = /* @__PURE__ */ by.set.bind(by), ZM = {
  era: EJ,
  eraYear: nL,
  year: ZE,
  month: ha,
  daysInMonth: ha,
  daysInYear: ha,
  inLeapYear: Tee,
  monthsInYear: ha
}, v5 = {
  monthCode: Jn
}, JM = {
  day: ha
}, tre = {
  dayOfWeek: ha,
  dayOfYear: ha,
  weekOfYear: SJ,
  yearOfWeek: nL,
  daysInWeek: ha
}, w5 = /* @__PURE__ */ y5(/* @__PURE__ */ Object.assign({}, ZM, v5, JM, tre)), rre = /* @__PURE__ */ y5({
  ...ZM,
  ...v5
}), nre = /* @__PURE__ */ y5({
  ...v5,
  ...JM
}), Ag = {
  calendarId: (t) => t.calendar
}, ire = /* @__PURE__ */ H2((t) => (e) => e[t], vr.concat("sign")), x5 = /* @__PURE__ */ H2((t, e) => (r) => r[ro[e]], Wa), XM = {
  epochMilliseconds: g6,
  epochNanoseconds: _J
}, [sre, Zr, MCe] = Sc(i5, DX, {
  ...ire,
  blank: VJ
}, {
  with: (t, e) => Zr(IX(t, e)),
  negated: (t) => Zr(_6(t)),
  abs: (t) => Zr(zJ(t)),
  add: (t, e, r) => Zr(s7(vf, jt, Qt, 0, t, ln(e), r)),
  subtract: (t, e, r) => Zr(s7(vf, jt, Qt, 1, t, ln(e), r)),
  round: (t, e) => Zr(FJ(vf, jt, Qt, t, e)),
  total: (t, e) => CJ(vf, jt, Qt, t, e),
  toLocaleString(t, e, r) {
    return Intl.DurationFormat ? new Intl.DurationFormat(e, r).format(this) : pw(t);
  },
  toString: pw,
  toJSON: (t) => pw(t),
  valueOf: Ac
}, {
  from: (t) => Zr(ln(t)),
  compare: (t, e, r) => tX(vf, jt, Qt, ln(t), ln(e), r)
}), ore = {
  Instant: HM,
  PlainDateTime: GM,
  PlainDate: WM,
  PlainTime: qM,
  PlainYearMonth: QM,
  PlainMonthDay: KM
}, are = /* @__PURE__ */ vc(HM), lre = /* @__PURE__ */ vc(Yte), cre = /* @__PURE__ */ vc(GM), ure = /* @__PURE__ */ vc(WM), hre = /* @__PURE__ */ vc(qM), pre = /* @__PURE__ */ vc(QM), dre = /* @__PURE__ */ vc(KM), [fre, kl] = Sc(r5, NX, x5, {
  with(t, e, r) {
    return kl(CX(this, Id(e), r));
  },
  add: (t, e) => kl(i7(0, t, ln(e))),
  subtract: (t, e) => kl(i7(1, t, ln(e))),
  until: (t, e, r) => Zr(d7(0, t, pl(e), r)),
  since: (t, e, r) => Zr(d7(1, t, pl(e), r)),
  round: (t, e) => kl(OJ(t, e)),
  equals: (t, e) => lX(t, pl(e)),
  toLocaleString(t, e, r) {
    const [n, i] = hre(e, r, t);
    return n.format(i);
  },
  toString: Zk,
  toJSON: (t) => Zk(t),
  valueOf: Ac
}, {
  from: (t, e) => kl(pl(t, e)),
  compare: (t, e) => D6(pl(t), pl(e))
}), [gre, Eo] = Sc(Cd, nr(OX, fg), {
  ...Ag,
  ...w5,
  ...x5
}, {
  with: (t, e, r) => Eo(SX(jt, t, Id(e), r)),
  withCalendar: (t, e) => Eo(z6(t, bb(e))),
  withPlainTime: (t, e) => Eo(YX(t, b5(e))),
  add: (t, e, r) => Eo(t7(jt, 0, t, ln(e), r)),
  subtract: (t, e, r) => Eo(t7(jt, 1, t, ln(e), r)),
  until: (t, e, r) => Zr(u7(jt, 0, t, ep(e), r)),
  since: (t, e, r) => Zr(u7(jt, 1, t, ep(e), r)),
  round: (t, e) => Eo(RJ(t, e)),
  equals: (t, e) => iX(t, ep(e)),
  toZonedDateTime: (t, e, r) => ti(BX(Qt, t, ss(e), r)),
  toPlainDate: (t) => Io(Ha(t)),
  toPlainTime: (t) => kl(ea(t)),
  toLocaleString(t, e, r) {
    const [n, i] = cre(e, r, t);
    return n.format(i);
  },
  toString: qk,
  toJSON: (t) => qk(t),
  valueOf: Ac
}, {
  from: (t, e) => Eo(ep(t, e)),
  compare: (t, e) => UL(ep(t), ep(e))
}), [mre, Ox, NCe] = Sc(t5, nr(MX, fg), {
  ...Ag,
  ...nre
}, {
  with: (t, e, r) => Ox(_X(jt, t, Id(e), r)),
  equals: (t, e) => aX(t, b7(e)),
  toPlainDate(t, e) {
    return Io(GX(jt, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = dre(e, r, t);
    return n.format(i);
  },
  toString: Yk,
  toJSON: (t) => Yk(t),
  valueOf: Ac
}, {
  from: (t, e) => Ox(b7(t, e))
}), [yre, Tf, DCe] = Sc(e5, nr(LX, fg), {
  ...Ag,
  ...rre
}, {
  with: (t, e, r) => Tf(kX(jt, t, Id(e), r)),
  add: (t, e, r) => Tf(n7(jt, 0, t, ln(e), r)),
  subtract: (t, e, r) => Tf(n7(jt, 1, t, ln(e), r)),
  until: (t, e, r) => Zr(p7(jt, 0, t, tp(e), r)),
  since: (t, e, r) => Zr(p7(jt, 1, t, tp(e), r)),
  equals: (t, e) => oX(t, tp(e)),
  toPlainDate(t, e) {
    return Io(HX(jt, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = pre(e, r, t);
    return n.format(i);
  },
  toString: Kk,
  toJSON: (t) => Kk(t),
  valueOf: Ac
}, {
  from: (t, e) => Tf(tp(t, e)),
  compare: (t, e) => Ad(tp(t), tp(e))
}), [bre, Io, $Ce] = Sc(wg, nr(TX, fg), {
  ...Ag,
  ...w5
}, {
  with: (t, e, r) => Io(AX(jt, t, Id(e), r)),
  withCalendar: (t, e) => Io(z6(t, bb(e))),
  add: (t, e, r) => Io(r7(jt, 0, t, ln(e), r)),
  subtract: (t, e, r) => Io(r7(jt, 1, t, ln(e), r)),
  until: (t, e, r) => Zr(h7(jt, 0, t, rp(e), r)),
  since: (t, e, r) => Zr(h7(jt, 1, t, rp(e), r)),
  equals: (t, e) => sX(t, rp(e)),
  toZonedDateTime(t, e) {
    const r = gi(e) ? e : {
      timeZone: e
    };
    return ti(FX(ss, pl, Qt, t, r));
  },
  toPlainDateTime: (t, e) => Eo(zX(t, b5(e))),
  toPlainYearMonth(t) {
    return Tf(VX(jt, t, this));
  },
  toPlainMonthDay(t) {
    return Ox(UX(jt, t, this));
  },
  toLocaleString(t, e, r) {
    const [n, i] = ure(e, r, t);
    return n.format(i);
  },
  toString: Qk,
  toJSON: (t) => Qk(t),
  valueOf: Ac
}, {
  from: (t, e) => Io(rp(t, e)),
  compare: (t, e) => Ad(rp(t), rp(e))
}), [vre, ti] = Sc(Ec, nr(RX, fg, eX), {
  ...XM,
  ...Ag,
  ...v7(w5),
  ...v7(x5),
  offset: (t) => hg(Rx(t).offsetNanoseconds),
  offsetNanoseconds: (t) => Rx(t).offsetNanoseconds,
  timeZoneId: (t) => t.timeZone,
  hoursInDay: (t) => TJ(Qt, t)
}, {
  with: (t, e, r) => ti(EX(jt, Qt, t, Id(e), r)),
  withCalendar: (t, e) => ti(z6(t, bb(e))),
  withTimeZone: (t, e) => ti(ZX(t, ss(e))),
  withPlainTime: (t, e) => ti(KX(Qt, t, b5(e))),
  add: (t, e, r) => ti(e7(jt, Qt, 0, t, ln(e), r)),
  subtract: (t, e, r) => ti(e7(jt, Qt, 1, t, ln(e), r)),
  until: (t, e, r) => Zr(gn(c7(jt, Qt, 0, t, np(e), r))),
  since: (t, e, r) => Zr(gn(c7(jt, Qt, 1, t, np(e), r))),
  round: (t, e) => ti(PJ(Qt, t, e)),
  startOfDay: (t) => ti(LJ(Qt, t)),
  equals: (t, e) => nX(t, np(e)),
  toInstant: (t) => dl(jX(t)),
  toPlainDateTime: (t) => Eo(lM(Qt, t)),
  toPlainDate: (t) => Io(cM(Qt, t)),
  toPlainTime: (t) => kl(uM(Qt, t)),
  toLocaleString(t, e, r = {}) {
    const [n, i] = lre(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => Wk(Qt, t, e),
  toJSON: (t) => Wk(Qt, t),
  valueOf: Ac,
  getTimeZoneTransition(t, e) {
    const { timeZone: r, epochNanoseconds: n } = t, i = kJ(e), s = Qt(r).O(n, i);
    return s ? ti({
      ...t,
      epochNanoseconds: s
    }) : null;
  }
}, {
  from: (t, e) => ti(np(t, e)),
  compare: (t, e) => VL(np(t), np(e))
}), [wre, dl, jCe] = Sc(n5, PX, XM, {
  add: (t, e) => dl(Xk(0, t, ln(e))),
  subtract: (t, e) => dl(Xk(1, t, ln(e))),
  until: (t, e, r) => Zr(l7(0, t, ip(e), r)),
  since: (t, e, r) => Zr(l7(1, t, ip(e), r)),
  round: (t, e) => dl(IJ(t, e)),
  equals: (t, e) => rX(t, ip(e)),
  toZonedDateTimeISO: (t, e) => ti($X(t, ss(e))),
  toLocaleString(t, e, r) {
    const [n, i] = are(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => Gk(ss, Qt, t, e),
  toJSON: (t) => Gk(ss, Qt, t),
  valueOf: Ac
}, {
  from: (t) => dl(ip(t)),
  fromEpochMilliseconds: (t) => dl(WX(t)),
  fromEpochNanoseconds: (t) => dl(qX(t)),
  compare: (t, e) => zL(ip(t), ip(e))
}), xre = /* @__PURE__ */ Object.defineProperties({}, {
  ...KE("Temporal.Now"),
  ...Vp({
    timeZoneId: () => yf(),
    instant: () => dl(Ua(Ax())),
    zonedDateTimeISO: (t = yf()) => ti(eo(Ax(), ss(t), cr)),
    plainDateTimeISO: (t = yf()) => Eo(to(mw(Qt(ss(t))), cr)),
    plainDateISO: (t = yf()) => Io(Ha(mw(Qt(ss(t))), cr)),
    plainTimeISO: (t = yf()) => kl(ea(mw(Qt(ss(t)))))
  })
}), Tx = /* @__PURE__ */ Object.defineProperties({}, {
  ...KE("Temporal"),
  ...Vp({
    PlainYearMonth: yre,
    PlainMonthDay: mre,
    PlainDate: bre,
    PlainTime: fre,
    PlainDateTime: gre,
    ZonedDateTime: vre,
    Instant: wre,
    Duration: sre,
    Now: xre
  })
}), Ere = /* @__PURE__ */ Zte(), vy = /* @__PURE__ */ new WeakMap();
Vp({
  DateTimeFormat: Ere
});
let x7 = class extends Error {
  constructor(e) {
    super(`[ParaModel]: ${e}`);
  }
};
function Wn(t) {
  const e = [];
  let r = 0;
  for (const n of t)
    e.push([n, r]), r++;
  return e;
}
function eN(t, e, r) {
  if (e.length !== r.length)
    return !1;
  for (const [n, i] of vJ(e, r))
    if (!t(n, i))
      return !1;
  return !0;
}
function qf(t) {
  return Tx.Instant.fromEpochMilliseconds(t).toZonedDateTimeISO("UTC").toPlainDateTime();
}
let Lx = class {
  constructor(e) {
    this.points = [e];
  }
  add(e) {
    this.points.push(e);
  }
};
function Sre(t, e) {
  if (t.length <= 1)
    return t;
  const r = [];
  e(t[0], t[1]) ? r.push(new Lx(t[0])) : r.push(t[0]);
  for (let n = 1; n < t.length - 1; n++)
    e(t[n - 1], t[n]) ? r.at(-1).add(t[n]) : e(t[n], t[n + 1]) ? r.push(new Lx(t[n])) : r.push(t[n]);
  return e(t.at(-2), t.at(-1)) ? r.at(-1).add(t.at(-1)) : r.push(t.at(-1)), r;
}
function Mx(t) {
  return t === "number" || t === "date";
}
let E5 = class {
  constructor(e) {
    this.raw = e, this.value = this.convertRaw(e);
  }
};
class Are extends E5 {
  convertRaw(e) {
    const r = parseFloat(e);
    if (isNaN(r))
      throw new Error("x values in Numeric Datapoints must be numbers");
    return r;
  }
  isNumber() {
    return !0;
  }
  isString() {
    return !1;
  }
  isDate() {
    return !1;
  }
  isEqual(e) {
    return this.value === e.value;
  }
  isNumberLike() {
    return !0;
  }
  asNumber() {
    return this.value;
  }
  datatype() {
    return "number";
  }
}
class kre extends E5 {
  convertRaw(e) {
    return e;
  }
  isNumber() {
    return !1;
  }
  isString() {
    return !0;
  }
  isDate() {
    return !1;
  }
  isEqual(e) {
    return this.value === e.value;
  }
  isNumberLike() {
    return !1;
  }
  asNumber() {
    return null;
  }
  datatype() {
    return "string";
  }
}
const _re = ["01", "04", "07", "10"];
function Cre(t) {
  let e = parseFloat(t), r = 0;
  return t[0] === "Q" && (r = parseInt(t[1]) - 1, t[3] === "'" ? e = parseInt(t.substring(4)) + 2e3 : e = parseInt(t.substring(3))), Number.isNaN(e) || Number.isNaN(r) ? null : `${e}${_re[r]}01`;
}
class Ire extends E5 {
  convertRaw(e) {
    const r = Cre(e);
    if (r === null)
      throw new x7(`Raw date string "${e}" could not be parsed.`);
    try {
      return Tx.PlainDateTime.from(r);
    } catch (n) {
      throw new x7(`RFC9557 date string "${r}" could not be parsed. Parsing error: ${n}`);
    }
  }
  isNumber() {
    return !1;
  }
  isString() {
    return !1;
  }
  isDate() {
    return !0;
  }
  isEqual(e) {
    return Tx.PlainDateTime.compare(this.value, e.value) === 0;
  }
  isNumberLike() {
    return !0;
  }
  // Temporal requires PlaneDateTimes be converted to ZonedDateTimes to get their milliseconds since
  //   the epoch (1/1/1970). We convert PlaneDateTimes to an arbitrary time zone here (UTC, i.e. 
  //   Greenwich mean time) as we are only concerned with the relative differences between PlaneDateTimes
  asNumber() {
    return this.value.toZonedDateTime("UTC").epochMilliseconds;
  }
  datatype() {
    return "date";
  }
}
const Pre = {
  string: kre,
  number: Are,
  date: Ire
};
let tN = class {
  constructor() {
    this.boxes = [];
  }
  get values() {
    return this.boxes;
  }
  has(e) {
    return this.boxes.some((r) => e.isEqual(r));
  }
  add(e) {
    this.has(e) || this.boxes.push(e);
  }
  merge(e) {
    e.forEach((r) => this.add(r));
  }
};
function Rre(t) {
  if (t.length === 0)
    return 0;
  var e = t[0], r = 0, n;
  if (typeof e != "number")
    return Number.NaN;
  for (var i = 1; i < t.length; i++) {
    if (typeof t[i] != "number")
      return Number.NaN;
    n = e + t[i], Math.abs(e) >= Math.abs(t[i]) ? r += e - n + t[i] : r += t[i] - n + e, e = n;
  }
  return e + r;
}
function Vo(t) {
  if (t.length === 0)
    throw new Error("mean requires at least one data point");
  return Rre(t) / t.length;
}
function Ore(t, e) {
  var r = Vo(t), n = 0, i, s;
  for (s = 0; s < t.length; s++)
    i = t[s] - r, n += i * i;
  return n;
}
function Tre(t) {
  if (t.length === 0)
    throw new Error("mode requires at least one data point");
  if (t.length === 1)
    return t[0];
  for (var e = t[0], r = Number.NaN, n = 0, i = 1, s = 1; s < t.length + 1; s++)
    t[s] !== e ? (i > n && (n = i, r = e), i = 1, e = t[s]) : i++;
  return r;
}
function Lre(t) {
  return t.slice().sort(function(e, r) {
    return e - r;
  });
}
function Mre(t) {
  return Tre(Lre(t));
}
function E7(t, e) {
  var r = t.length * e;
  if (t.length === 0)
    throw new Error("quantile requires at least one data point.");
  if (e < 0 || e > 1)
    throw new Error("quantiles must be between 0 and 1");
  return e === 1 ? t[t.length - 1] : e === 0 ? t[0] : r % 1 !== 0 ? t[Math.ceil(r) - 1] : t.length % 2 === 0 ? (t[r - 1] + t[r]) / 2 : t[r];
}
function v1(t, e, r, n) {
  for (r = r || 0, n = n || t.length - 1; n > r; ) {
    if (n - r > 600) {
      var i = n - r + 1, s = e - r + 1, o = Math.log(i), a = 0.5 * Math.exp(2 * o / 3), l = 0.5 * Math.sqrt(o * a * (i - a) / i);
      s - i / 2 < 0 && (l *= -1);
      var c = Math.max(r, Math.floor(e - s * a / i + l)), p = Math.min(
        n,
        Math.floor(e + (i - s) * a / i + l)
      );
      v1(t, e, c, p);
    }
    var h = t[e], d = r, b = n;
    for (wf(t, r, e), t[n] > h && wf(t, r, n); d < b; ) {
      for (wf(t, d, b), d++, b--; t[d] < h; )
        d++;
      for (; t[b] > h; )
        b--;
    }
    t[r] === h ? wf(t, r, b) : (b++, wf(t, b, n)), b <= e && (r = b + 1), e <= b && (n = b - 1);
  }
}
function wf(t, e, r) {
  var n = t[e];
  t[e] = t[r], t[r] = n;
}
function Nre(t, e) {
  var r = t.slice();
  if (Array.isArray(e)) {
    Dre(r, e);
    for (var n = [], i = 0; i < e.length; i++)
      n[i] = E7(r, e[i]);
    return n;
  } else {
    var s = nN(r.length, e);
    return rN(r, s, 0, r.length - 1), E7(r, e);
  }
}
function rN(t, e, r, n) {
  e % 1 === 0 ? v1(t, e, r, n) : (e = Math.floor(e), v1(t, e, r, n), v1(t, e + 1, e + 1, n));
}
function Dre(t, e) {
  for (var r = [0], n = 0; n < e.length; n++)
    r.push(nN(t.length, e[n]));
  r.push(t.length - 1), r.sort($re);
  for (var i = [0, r.length - 1]; i.length; ) {
    var s = Math.ceil(i.pop()), o = Math.floor(i.pop());
    if (!(s - o <= 1)) {
      var a = Math.floor((o + s) / 2);
      rN(
        t,
        r[a],
        Math.floor(r[o]),
        Math.ceil(r[s])
      ), i.push(o, a, a, s);
    }
  }
}
function $re(t, e) {
  return t - e;
}
function nN(t, e) {
  var r = t * e;
  return e === 1 ? t - 1 : e === 0 ? 0 : r % 1 !== 0 ? Math.ceil(r) - 1 : t % 2 === 0 ? r - 0.5 : r;
}
function jre(t) {
  return +Nre(t, 0.5);
}
function Bre(t, e) {
  if (t.length !== e.length)
    throw new Error("sampleCovariance requires samples with equal lengths");
  if (t.length < 2)
    throw new Error(
      "sampleCovariance requires at least two data points in each sample"
    );
  for (var r = Vo(t), n = Vo(e), i = 0, s = 0; s < t.length; s++)
    i += (t[s] - r) * (e[s] - n);
  var o = t.length - 1;
  return i / o;
}
function Fre(t) {
  if (t.length < 2)
    throw new Error("sampleVariance requires at least two data points");
  var e = Ore(t), r = t.length - 1;
  return e / r;
}
function Nx(t) {
  var e = Fre(t);
  return Math.sqrt(e);
}
function zre(t, e) {
  var r = Bre(t, e), n = Nx(t), i = Nx(e);
  return r / n / i;
}
var Dx = 9e15, kc = 1e9, $x = "0123456789abcdef", wy = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", xy = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", jx = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -9e15,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: Dx,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, iN, pa, Lt = !0, vb = "[DecimalError] ", sh = vb + "Invalid argument: ", sN = vb + "Precision limit exceeded", oN = vb + "crypto unavailable", Mn = Math.floor, Sn = Math.pow, Vre = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, Ure = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, Hre = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, Gre = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Fs = 1e7, vt = 7, Wre = 9007199254740991, qre = wy.length - 1, Bx = xy.length - 1, Ve = { name: "[object Decimal]" };
Ve.absoluteValue = Ve.abs = function() {
  var t = new this.constructor(this);
  return t.s < 0 && (t.s = 1), gt(t);
};
Ve.ceil = function() {
  return gt(new this.constructor(this), this.e + 1, 2);
};
Ve.comparedTo = Ve.cmp = function(t) {
  var e, r, n, i, s = this, o = s.d, a = (t = new s.constructor(t)).d, l = s.s, c = t.s;
  if (!o || !a)
    return !l || !c ? NaN : l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? l : a[0] ? -c : 0;
  if (l !== c) return l;
  if (s.e !== t.e) return s.e > t.e ^ l < 0 ? 1 : -1;
  for (n = o.length, i = a.length, e = 0, r = n < i ? n : i; e < r; ++e)
    if (o[e] !== a[e]) return o[e] > a[e] ^ l < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
};
Ve.cosine = Ve.cos = function() {
  var t, e, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + vt, n.rounding = 1, r = Qre(n, hN(n, r)), n.precision = t, n.rounding = e, gt(pa == 2 || pa == 3 ? r.neg() : r, t, e, !0)) : new n(1) : new n(NaN);
};
Ve.cubeRoot = Ve.cbrt = function() {
  var t, e, r, n, i, s, o, a, l, c, p = this, h = p.constructor;
  if (!p.isFinite() || p.isZero()) return new h(p);
  for (Lt = !1, s = p.s * Math.pow(p.s * p, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = hn(p.d), t = p.e, (s = (t - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Math.pow(r, 1 / 3), t = Mn((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + t : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + t), n = new h(r), n.s = p.s) : n = new h(s.toString()), o = (t = h.precision) + 3; ; )
    if (a = n, l = a.times(a).times(a), c = l.plus(p), n = or(c.plus(p).times(a), c.plus(l), o + 2, 1), hn(a.d).slice(0, o) === (r = hn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (gt(a, t + 1, 0), a.times(a).times(a).eq(p))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (gt(n, t + 1, 1), e = !n.times(n).times(n).eq(p));
        break;
      }
  return Lt = !0, gt(n, t, h.rounding, e);
};
Ve.decimalPlaces = Ve.dp = function() {
  var t, e = this.d, r = NaN;
  if (e) {
    if (t = e.length - 1, r = (t - Mn(this.e / vt)) * vt, t = e[t], t) for (; t % 10 == 0; t /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
Ve.dividedBy = Ve.div = function(t) {
  return or(this, new this.constructor(t));
};
Ve.dividedToIntegerBy = Ve.divToInt = function(t) {
  var e = this, r = e.constructor;
  return gt(or(e, new r(t), 0, 1, 1), r.precision, r.rounding);
};
Ve.equals = Ve.eq = function(t) {
  return this.cmp(t) === 0;
};
Ve.floor = function() {
  return gt(new this.constructor(this), this.e + 1, 3);
};
Ve.greaterThan = Ve.gt = function(t) {
  return this.cmp(t) > 0;
};
Ve.greaterThanOrEqualTo = Ve.gte = function(t) {
  var e = this.cmp(t);
  return e == 1 || e === 0;
};
Ve.hyperbolicCosine = Ve.cosh = function() {
  var t, e, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (t = Math.ceil(i / 3), e = Math.pow(4, -t).toString()) : (t = 16, e = "2.3283064365386962890625e-10"), s = Wp(o, 1, s.times(e), new o(1), !0);
  for (var l, c = t, p = new o(8); c--; )
    l = s.times(s), s = a.minus(l.times(p.minus(l.times(p))));
  return gt(s, o.precision = r, o.rounding = n, !0);
};
Ve.hyperbolicSine = Ve.sinh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero()) return new s(i);
  if (e = s.precision, r = s.rounding, s.precision = e + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = Wp(s, 2, i, i, !0);
  else {
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, i = i.times(Math.pow(5, -t)), i = Wp(s, 2, i, i, !0);
    for (var o, a = new s(5), l = new s(16), c = new s(20); t--; )
      o = i.times(i), i = i.times(a.plus(o.times(l.times(o).plus(c))));
  }
  return s.precision = e, s.rounding = r, gt(i, e, r, !0);
};
Ve.hyperbolicTangent = Ve.tanh = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 7, n.rounding = 1, or(r.sinh(), r.cosh(), n.precision = t, n.rounding = e)) : new n(r.s);
};
Ve.inverseCosine = Ve.acos = function() {
  var t, e = this, r = e.constructor, n = e.abs().cmp(1), i = r.precision, s = r.rounding;
  return n !== -1 ? n === 0 ? e.isNeg() ? Ms(r, i, s) : new r(0) : new r(NaN) : e.isZero() ? Ms(r, i + 4, s).times(0.5) : (r.precision = i + 6, r.rounding = 1, e = e.asin(), t = Ms(r, i + 4, s).times(0.5), r.precision = i, r.rounding = s, t.minus(e));
};
Ve.inverseHyperbolicCosine = Ve.acosh = function() {
  var t, e, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, Lt = !1, r = r.times(r).minus(1).sqrt().plus(r), Lt = !0, n.precision = t, n.rounding = e, r.ln()) : new n(r);
};
Ve.inverseHyperbolicSine = Ve.asinh = function() {
  var t, e, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, Lt = !1, r = r.times(r).plus(1).sqrt().plus(r), Lt = !0, n.precision = t, n.rounding = e, r.ln());
};
Ve.inverseHyperbolicTangent = Ve.atanh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (t = s.precision, e = s.rounding, n = i.sd(), Math.max(n, t) < 2 * -i.e - 1 ? gt(new s(i), t, e, !0) : (s.precision = r = n - i.e, i = or(i.plus(1), new s(1).minus(i), r + t, 1), s.precision = t + 4, s.rounding = 1, i = i.ln(), s.precision = t, s.rounding = e, i.times(0.5))) : new s(NaN);
};
Ve.inverseSine = Ve.asin = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (e = i.abs().cmp(1), r = s.precision, n = s.rounding, e !== -1 ? e === 0 ? (t = Ms(s, r + 4, n).times(0.5), t.s = i.s, t) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
Ve.inverseTangent = Ve.atan = function() {
  var t, e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new p(c);
    if (c.abs().eq(1) && h + 4 <= Bx)
      return o = Ms(p, h + 4, d).times(0.25), o.s = c.s, o;
  } else {
    if (!c.s) return new p(NaN);
    if (h + 4 <= Bx)
      return o = Ms(p, h + 4, d).times(0.5), o.s = c.s, o;
  }
  for (p.precision = a = h + 10, p.rounding = 1, r = Math.min(28, a / vt + 2 | 0), t = r; t; --t) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (Lt = !1, e = Math.ceil(a / vt), n = 1, l = c.times(c), o = new p(c), i = c; t !== -1; )
    if (i = i.times(l), s = o.minus(i.div(n += 2)), i = i.times(l), o = s.plus(i.div(n += 2)), o.d[e] !== void 0) for (t = e; o.d[t] === s.d[t] && t--; ) ;
  return r && (o = o.times(2 << r - 1)), Lt = !0, gt(o, p.precision = h, p.rounding = d, !0);
};
Ve.isFinite = function() {
  return !!this.d;
};
Ve.isInteger = Ve.isInt = function() {
  return !!this.d && Mn(this.e / vt) > this.d.length - 2;
};
Ve.isNaN = function() {
  return !this.s;
};
Ve.isNegative = Ve.isNeg = function() {
  return this.s < 0;
};
Ve.isPositive = Ve.isPos = function() {
  return this.s > 0;
};
Ve.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
Ve.lessThan = Ve.lt = function(t) {
  return this.cmp(t) < 0;
};
Ve.lessThanOrEqualTo = Ve.lte = function(t) {
  return this.cmp(t) < 1;
};
Ve.logarithm = Ve.log = function(t) {
  var e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding, b = 5;
  if (t == null)
    t = new p(10), e = !0;
  else {
    if (t = new p(t), r = t.d, t.s < 0 || !r || !r[0] || t.eq(1)) return new p(NaN);
    e = t.eq(10);
  }
  if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1))
    return new p(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (e)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      s = i !== 1;
    }
  if (Lt = !1, a = h + b, o = Rl(c, a), n = e ? Ey(p, a + 10) : Rl(t, a), l = or(o, n, a, 1), v0(l.d, i = h, d))
    do
      if (a += 10, o = Rl(c, a), n = e ? Ey(p, a + 10) : Rl(t, a), l = or(o, n, a, 1), !s) {
        +hn(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = gt(l, h + 1, 0));
        break;
      }
    while (v0(l.d, i += 10, d));
  return Lt = !0, gt(l, h, d);
};
Ve.minus = Ve.sub = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, b = this, m = b.constructor;
  if (t = new m(t), !b.d || !t.d)
    return !b.s || !t.s ? t = new m(NaN) : b.d ? t.s = -t.s : t = new m(t.d || b.s !== t.s ? b : NaN), t;
  if (b.s != t.s)
    return t.s = -t.s, b.plus(t);
  if (c = b.d, d = t.d, a = m.precision, l = m.rounding, !c[0] || !d[0]) {
    if (d[0]) t.s = -t.s;
    else if (c[0]) t = new m(b);
    else return new m(l === 3 ? -0 : 0);
    return Lt ? gt(t, a, l) : t;
  }
  if (r = Mn(t.e / vt), p = Mn(b.e / vt), c = c.slice(), s = p - r, s) {
    for (h = s < 0, h ? (e = c, s = -s, o = d.length) : (e = d, r = p, o = c.length), n = Math.max(Math.ceil(a / vt), o) + 2, s > n && (s = n, e.length = 1), e.reverse(), n = s; n--; ) e.push(0);
    e.reverse();
  } else {
    for (n = c.length, o = d.length, h = n < o, h && (o = n), n = 0; n < o; n++)
      if (c[n] != d[n]) {
        h = c[n] < d[n];
        break;
      }
    s = 0;
  }
  for (h && (e = c, c = d, d = e, t.s = -t.s), o = c.length, n = d.length - o; n > 0; --n) c[o++] = 0;
  for (n = d.length; n > s; ) {
    if (c[--n] < d[n]) {
      for (i = n; i && c[--i] === 0; ) c[i] = Fs - 1;
      --c[i], c[n] += Fs;
    }
    c[n] -= d[n];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --r;
  return c[0] ? (t.d = c, t.e = wb(c, r), Lt ? gt(t, a, l) : t) : new m(l === 3 ? -0 : 0);
};
Ve.modulo = Ve.mod = function(t) {
  var e, r = this, n = r.constructor;
  return t = new n(t), !r.d || !t.s || t.d && !t.d[0] ? new n(NaN) : !t.d || r.d && !r.d[0] ? gt(new n(r), n.precision, n.rounding) : (Lt = !1, n.modulo == 9 ? (e = or(r, t.abs(), 0, 3, 1), e.s *= t.s) : e = or(r, t, 0, n.modulo, 1), e = e.times(t), Lt = !0, r.minus(e));
};
Ve.naturalExponential = Ve.exp = function() {
  return Fx(this);
};
Ve.naturalLogarithm = Ve.ln = function() {
  return Rl(this);
};
Ve.negated = Ve.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s, gt(t);
};
Ve.plus = Ve.add = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h = this, d = h.constructor;
  if (t = new d(t), !h.d || !t.d)
    return !h.s || !t.s ? t = new d(NaN) : h.d || (t = new d(t.d || h.s === t.s ? h : NaN)), t;
  if (h.s != t.s)
    return t.s = -t.s, h.minus(t);
  if (c = h.d, p = t.d, a = d.precision, l = d.rounding, !c[0] || !p[0])
    return p[0] || (t = new d(h)), Lt ? gt(t, a, l) : t;
  if (s = Mn(h.e / vt), n = Mn(t.e / vt), c = c.slice(), i = s - n, i) {
    for (i < 0 ? (r = c, i = -i, o = p.length) : (r = p, n = s, o = c.length), s = Math.ceil(a / vt), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = c.length, i = p.length, o - i < 0 && (i = o, r = p, p = c, c = r), e = 0; i; )
    e = (c[--i] = c[i] + p[i] + e) / Fs | 0, c[i] %= Fs;
  for (e && (c.unshift(e), ++n), o = c.length; c[--o] == 0; ) c.pop();
  return t.d = c, t.e = wb(c, n), Lt ? gt(t, a, l) : t;
};
Ve.precision = Ve.sd = function(t) {
  var e, r = this;
  if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(sh + t);
  return r.d ? (e = aN(r.d), t && r.e + 1 > e && (e = r.e + 1)) : e = NaN, e;
};
Ve.round = function() {
  var t = this, e = t.constructor;
  return gt(new e(t), t.e + 1, e.rounding);
};
Ve.sine = Ve.sin = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + vt, n.rounding = 1, r = Yre(n, hN(n, r)), n.precision = t, n.rounding = e, gt(pa > 2 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Ve.squareRoot = Ve.sqrt = function() {
  var t, e, r, n, i, s, o = this, a = o.d, l = o.e, c = o.s, p = o.constructor;
  if (c !== 1 || !a || !a[0])
    return new p(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (Lt = !1, c = Math.sqrt(+o), c == 0 || c == 1 / 0 ? (e = hn(a), (e.length + l) % 2 == 0 && (e += "0"), c = Math.sqrt(e), l = Mn((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? e = "1e" + l : (e = c.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + l), n = new p(e)) : n = new p(c.toString()), r = (l = p.precision) + 3; ; )
    if (s = n, n = s.plus(or(o, s, r + 2, 1)).times(0.5), hn(s.d).slice(0, r) === (e = hn(n.d)).slice(0, r))
      if (e = e.slice(r - 3, r + 1), e == "9999" || !i && e == "4999") {
        if (!i && (gt(s, l + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (gt(n, l + 1, 1), t = !n.times(n).eq(o));
        break;
      }
  return Lt = !0, gt(n, l, p.rounding, t);
};
Ve.tangent = Ve.tan = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = or(r, new n(1).minus(r.times(r)).sqrt(), t + 10, 0), n.precision = t, n.rounding = e, gt(pa == 2 || pa == 4 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Ve.times = Ve.mul = function(t) {
  var e, r, n, i, s, o, a, l, c, p = this, h = p.constructor, d = p.d, b = (t = new h(t)).d;
  if (t.s *= p.s, !d || !d[0] || !b || !b[0])
    return new h(!t.s || d && !d[0] && !b || b && !b[0] && !d ? NaN : !d || !b ? t.s / 0 : t.s * 0);
  for (r = Mn(p.e / vt) + Mn(t.e / vt), l = d.length, c = b.length, l < c && (s = d, d = b, b = s, o = l, l = c, c = o), s = [], o = l + c, n = o; n--; ) s.push(0);
  for (n = c; --n >= 0; ) {
    for (e = 0, i = l + n; i > n; )
      a = s[i] + b[n] * d[i - n - 1] + e, s[i--] = a % Fs | 0, e = a / Fs | 0;
    s[i] = (s[i] + e) % Fs | 0;
  }
  for (; !s[--o]; ) s.pop();
  return e ? ++r : s.shift(), t.d = s, t.e = wb(s, r), Lt ? gt(t, h.precision, h.rounding) : t;
};
Ve.toBinary = function(t, e) {
  return S5(this, 2, t, e);
};
Ve.toDecimalPlaces = Ve.toDP = function(t, e) {
  var r = this, n = r.constructor;
  return r = new n(r), t === void 0 ? r : (li(t, 0, kc), e === void 0 ? e = n.rounding : li(e, 0, 8), gt(r, t + r.e + 1, e));
};
Ve.toExponential = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Uo(n, !0) : (li(t, 0, kc), e === void 0 ? e = i.rounding : li(e, 0, 8), n = gt(new i(n), t + 1, e), r = Uo(n, !0, t + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ve.toFixed = function(t, e) {
  var r, n, i = this, s = i.constructor;
  return t === void 0 ? r = Uo(i) : (li(t, 0, kc), e === void 0 ? e = s.rounding : li(e, 0, 8), n = gt(new s(i), t + i.e + 1, e), r = Uo(n, !1, t + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
Ve.toFraction = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, b = this, m = b.d, w = b.constructor;
  if (!m) return new w(b);
  if (c = r = new w(1), n = l = new w(0), e = new w(n), s = e.e = aN(m) - b.e - 1, o = s % vt, e.d[0] = Sn(10, o < 0 ? vt + o : o), t == null)
    t = s > 0 ? e : c;
  else {
    if (a = new w(t), !a.isInt() || a.lt(c)) throw Error(sh + a);
    t = a.gt(e) ? s > 0 ? e : c : a;
  }
  for (Lt = !1, a = new w(hn(m)), p = w.precision, w.precision = s = m.length * vt * 2; h = or(a, e, 0, 1, 1), i = r.plus(h.times(n)), i.cmp(t) != 1; )
    r = n, n = i, i = c, c = l.plus(h.times(i)), l = i, i = e, e = a.minus(h.times(i)), a = i;
  return i = or(t.minus(r), n, 0, 1, 1), l = l.plus(i.times(c)), r = r.plus(i.times(n)), l.s = c.s = b.s, d = or(c, n, s, 1).minus(b).abs().cmp(or(l, r, s, 1).minus(b).abs()) < 1 ? [c, n] : [l, r], w.precision = p, Lt = !0, d;
};
Ve.toHexadecimal = Ve.toHex = function(t, e) {
  return S5(this, 16, t, e);
};
Ve.toNearest = function(t, e) {
  var r = this, n = r.constructor;
  if (r = new n(r), t == null) {
    if (!r.d) return r;
    t = new n(1), e = n.rounding;
  } else {
    if (t = new n(t), e === void 0 ? e = n.rounding : li(e, 0, 8), !r.d) return t.s ? r : t;
    if (!t.d)
      return t.s && (t.s = r.s), t;
  }
  return t.d[0] ? (Lt = !1, r = or(r, t, 0, e, 1).times(t), Lt = !0, gt(r)) : (t.s = r.s, r = t), r;
};
Ve.toNumber = function() {
  return +this;
};
Ve.toOctal = function(t, e) {
  return S5(this, 8, t, e);
};
Ve.toPower = Ve.pow = function(t) {
  var e, r, n, i, s, o, a = this, l = a.constructor, c = +(t = new l(t));
  if (!a.d || !t.d || !a.d[0] || !t.d[0]) return new l(Sn(+a, c));
  if (a = new l(a), a.eq(1)) return a;
  if (n = l.precision, s = l.rounding, t.eq(1)) return gt(a, n, s);
  if (e = Mn(t.e / vt), e >= t.d.length - 1 && (r = c < 0 ? -c : c) <= Wre)
    return i = lN(l, a, r, n), t.s < 0 ? new l(1).div(i) : gt(i, n, s);
  if (o = a.s, o < 0) {
    if (e < t.d.length - 1) return new l(NaN);
    if (!(t.d[e] & 1) && (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = Sn(+a, c), e = r == 0 || !isFinite(r) ? Mn(c * (Math.log("0." + hn(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, e > l.maxE + 1 || e < l.minE - 1 ? new l(e > 0 ? o / 0 : 0) : (Lt = !1, l.rounding = a.s = 1, r = Math.min(12, (e + "").length), i = Fx(t.times(Rl(a, n + r)), n), i.d && (i = gt(i, n + 5, 1), v0(i.d, n, s) && (e = n + 10, i = gt(Fx(t.times(Rl(a, e + r)), e), e + 5, 1), +hn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = gt(i, n + 1, 0)))), i.s = o, Lt = !0, l.rounding = s, gt(i, n, s));
};
Ve.toPrecision = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Uo(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (li(t, 1, kc), e === void 0 ? e = i.rounding : li(e, 0, 8), n = gt(new i(n), t, e), r = Uo(n, t <= n.e || n.e <= i.toExpNeg, t)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ve.toSignificantDigits = Ve.toSD = function(t, e) {
  var r = this, n = r.constructor;
  return t === void 0 ? (t = n.precision, e = n.rounding) : (li(t, 1, kc), e === void 0 ? e = n.rounding : li(e, 0, 8)), gt(new n(r), t, e);
};
Ve.toString = function() {
  var t = this, e = t.constructor, r = Uo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() && !t.isZero() ? "-" + r : r;
};
Ve.truncated = Ve.trunc = function() {
  return gt(new this.constructor(this), this.e + 1, 1);
};
Ve.valueOf = Ve.toJSON = function() {
  var t = this, e = t.constructor, r = Uo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() ? "-" + r : r;
};
function hn(t) {
  var e, r, n, i = t.length - 1, s = "", o = t[0];
  if (i > 0) {
    for (s += o, e = 1; e < i; e++)
      n = t[e] + "", r = vt - n.length, r && (s += fl(r)), s += n;
    o = t[e], n = o + "", r = vt - n.length, r && (s += fl(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function li(t, e, r) {
  if (t !== ~~t || t < e || t > r)
    throw Error(sh + t);
}
function v0(t, e, r, n) {
  var i, s, o, a;
  for (s = t[0]; s >= 10; s /= 10) --e;
  return --e < 0 ? (e += vt, i = 0) : (i = Math.ceil((e + 1) / vt), e %= vt), s = Sn(10, vt - e), a = t[i] % s | 0, n == null ? e < 3 ? (e == 0 ? a = a / 100 | 0 : e == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 100 | 0) == Sn(10, e - 2) - 1 || (a == s / 2 || a == 0) && (t[i + 1] / s / 100 | 0) == 0 : e < 4 ? (e == 0 ? a = a / 1e3 | 0 : e == 1 ? a = a / 100 | 0 : e == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 1e3 | 0) == Sn(10, e - 3) - 1, o;
}
function w1(t, e, r) {
  for (var n, i = [0], s, o = 0, a = t.length; o < a; ) {
    for (s = i.length; s--; ) i[s] *= e;
    for (i[0] += $x.indexOf(t.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function Qre(t, e) {
  var r, n, i = e.d.length;
  i < 32 ? (r = Math.ceil(i / 3), n = Math.pow(4, -r).toString()) : (r = 16, n = "2.3283064365386962890625e-10"), t.precision += r, e = Wp(t, 1, e.times(n), new t(1));
  for (var s = r; s--; ) {
    var o = e.times(e);
    e = o.times(o).minus(o).times(8).plus(1);
  }
  return t.precision -= r, e;
}
var or = /* @__PURE__ */ function() {
  function t(n, i, s) {
    var o, a = 0, l = n.length;
    for (n = n.slice(); l--; )
      o = n[l] * i + a, n[l] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function e(n, i, s, o) {
    var a, l;
    if (s != o)
      l = s > o ? 1 : -1;
    else
      for (a = l = 0; a < s; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, o, a, l) {
    var c, p, h, d, b, m, w, f, E, A, x, g, v, k, S, R, L, F, z, j, ee = n.constructor, X = n.s == i.s ? 1 : -1, ie = n.d, ce = i.d;
    if (!ie || !ie[0] || !ce || !ce[0])
      return new ee(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (ie ? ce && ie[0] == ce[0] : !ce) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          ie && ie[0] == 0 || !ce ? X * 0 : X / 0
        )
      );
    for (l ? (b = 1, p = n.e - i.e) : (l = Fs, b = vt, p = Mn(n.e / b) - Mn(i.e / b)), z = ce.length, L = ie.length, E = new ee(X), A = E.d = [], h = 0; ce[h] == (ie[h] || 0); h++) ;
    if (ce[h] > (ie[h] || 0) && p--, s == null ? (k = s = ee.precision, o = ee.rounding) : a ? k = s + (n.e - i.e) + 1 : k = s, k < 0)
      A.push(1), m = !0;
    else {
      if (k = k / b + 2 | 0, h = 0, z == 1) {
        for (d = 0, ce = ce[0], k++; (h < L || d) && k--; h++)
          S = d * l + (ie[h] || 0), A[h] = S / ce | 0, d = S % ce | 0;
        m = d || h < L;
      } else {
        for (d = l / (ce[0] + 1) | 0, d > 1 && (ce = t(ce, d, l), ie = t(ie, d, l), z = ce.length, L = ie.length), R = z, x = ie.slice(0, z), g = x.length; g < z; ) x[g++] = 0;
        j = ce.slice(), j.unshift(0), F = ce[0], ce[1] >= l / 2 && ++F;
        do
          d = 0, c = e(ce, x, z, g), c < 0 ? (v = x[0], z != g && (v = v * l + (x[1] || 0)), d = v / F | 0, d > 1 ? (d >= l && (d = l - 1), w = t(ce, d, l), f = w.length, g = x.length, c = e(w, x, f, g), c == 1 && (d--, r(w, z < f ? j : ce, f, l))) : (d == 0 && (c = d = 1), w = ce.slice()), f = w.length, f < g && w.unshift(0), r(x, w, g, l), c == -1 && (g = x.length, c = e(ce, x, z, g), c < 1 && (d++, r(x, z < g ? j : ce, g, l))), g = x.length) : c === 0 && (d++, x = [0]), A[h++] = d, c && x[0] ? x[g++] = ie[R] || 0 : (x = [ie[R]], g = 1);
        while ((R++ < L || x[0] !== void 0) && k--);
        m = x[0] !== void 0;
      }
      A[0] || A.shift();
    }
    if (b == 1)
      E.e = p, iN = m;
    else {
      for (h = 1, d = A[0]; d >= 10; d /= 10) h++;
      E.e = h + p * b - 1, gt(E, a ? s + E.e + 1 : s, o, m);
    }
    return E;
  };
}();
function gt(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, b = t.constructor;
  e: if (e != null) {
    if (h = t.d, !h) return t;
    for (i = 1, a = h[0]; a >= 10; a /= 10) i++;
    if (s = e - i, s < 0)
      s += vt, o = e, p = h[d = 0], l = p / Sn(10, i - o - 1) % 10 | 0;
    else if (d = Math.ceil((s + 1) / vt), a = h.length, d >= a)
      if (n) {
        for (; a++ <= d; ) h.push(0);
        p = l = 0, i = 1, s %= vt, o = s - vt + 1;
      } else
        break e;
    else {
      for (p = a = h[d], i = 1; a >= 10; a /= 10) i++;
      s %= vt, o = s - vt + i, l = o < 0 ? 0 : p / Sn(10, i - o - 1) % 10 | 0;
    }
    if (n = n || e < 0 || h[d + 1] !== void 0 || (o < 0 ? p : p % Sn(10, i - o - 1)), c = r < 4 ? (l || n) && (r == 0 || r == (t.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? p / Sn(10, i - o) : 0 : h[d - 1]) % 10 & 1 || r == (t.s < 0 ? 8 : 7)), e < 1 || !h[0])
      return h.length = 0, c ? (e -= t.e + 1, h[0] = Sn(10, (vt - e % vt) % vt), t.e = -e || 0) : h[0] = t.e = 0, t;
    if (s == 0 ? (h.length = d, a = 1, d--) : (h.length = d + 1, a = Sn(10, vt - s), h[d] = o > 0 ? (p / Sn(10, i - o) % Sn(10, o) | 0) * a : 0), c)
      for (; ; )
        if (d == 0) {
          for (s = 1, o = h[0]; o >= 10; o /= 10) s++;
          for (o = h[0] += a, a = 1; o >= 10; o /= 10) a++;
          s != a && (t.e++, h[0] == Fs && (h[0] = 1));
          break;
        } else {
          if (h[d] += a, h[d] != Fs) break;
          h[d--] = 0, a = 1;
        }
    for (s = h.length; h[--s] === 0; ) h.pop();
  }
  return Lt && (t.e > b.maxE ? (t.d = null, t.e = NaN) : t.e < b.minE && (t.e = 0, t.d = [0])), t;
}
function Uo(t, e, r) {
  if (!t.isFinite()) return uN(t);
  var n, i = t.e, s = hn(t.d), o = s.length;
  return e ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + fl(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (t.e < 0 ? "e" : "e+") + t.e) : i < 0 ? (s = "0." + fl(-i - 1) + s, r && (n = r - o) > 0 && (s += fl(n))) : i >= o ? (s += fl(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + fl(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += fl(n))), s;
}
function wb(t, e) {
  var r = t[0];
  for (e *= vt; r >= 10; r /= 10) e++;
  return e;
}
function Ey(t, e, r) {
  if (e > qre)
    throw Lt = !0, r && (t.precision = r), Error(sN);
  return gt(new t(wy), e, 1, !0);
}
function Ms(t, e, r) {
  if (e > Bx) throw Error(sN);
  return gt(new t(xy), e, r, !0);
}
function aN(t) {
  var e = t.length - 1, r = e * vt + 1;
  if (e = t[e], e) {
    for (; e % 10 == 0; e /= 10) r--;
    for (e = t[0]; e >= 10; e /= 10) r++;
  }
  return r;
}
function fl(t) {
  for (var e = ""; t--; ) e += "0";
  return e;
}
function lN(t, e, r, n) {
  var i, s = new t(1), o = Math.ceil(n / vt + 4);
  for (Lt = !1; ; ) {
    if (r % 2 && (s = s.times(e), k7(s.d, o) && (i = !0)), r = Mn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    e = e.times(e), k7(e.d, o);
  }
  return Lt = !0, s;
}
function S7(t) {
  return t.d[t.d.length - 1] & 1;
}
function cN(t, e, r) {
  for (var n, i = new t(e[0]), s = 0; ++s < e.length; )
    if (n = new t(e[s]), n.s)
      i[r](n) && (i = n);
    else {
      i = n;
      break;
    }
  return i;
}
function Fx(t, e) {
  var r, n, i, s, o, a, l, c = 0, p = 0, h = 0, d = t.constructor, b = d.rounding, m = d.precision;
  if (!t.d || !t.d[0] || t.e > 17)
    return new d(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
  for (e == null ? (Lt = !1, l = m) : l = e, a = new d(0.03125); t.e > -2; )
    t = t.times(a), h += 5;
  for (n = Math.log(Sn(2, h)) / Math.LN10 * 2 + 5 | 0, l += n, r = s = o = new d(1), d.precision = l; ; ) {
    if (s = gt(s.times(t), l, 1), r = r.times(++p), a = o.plus(or(s, r, l, 1)), hn(a.d).slice(0, l) === hn(o.d).slice(0, l)) {
      for (i = h; i--; ) o = gt(o.times(o), l, 1);
      if (e == null)
        if (c < 3 && v0(o.d, l - n, b, c))
          d.precision = l += 10, r = s = a = new d(1), p = 0, c++;
        else
          return gt(o, d.precision = m, b, Lt = !0);
      else
        return d.precision = m, o;
    }
    o = a;
  }
}
function Rl(t, e) {
  var r, n, i, s, o, a, l, c, p, h, d, b = 1, m = 10, w = t, f = w.d, E = w.constructor, A = E.rounding, x = E.precision;
  if (w.s < 0 || !f || !f[0] || !w.e && f[0] == 1 && f.length == 1)
    return new E(f && !f[0] ? -1 / 0 : w.s != 1 ? NaN : f ? 0 : w);
  if (e == null ? (Lt = !1, p = x) : p = e, E.precision = p += m, r = hn(f), n = r.charAt(0), Math.abs(s = w.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      w = w.times(t), r = hn(w.d), n = r.charAt(0), b++;
    s = w.e, n > 1 ? (w = new E("0." + r), s++) : w = new E(n + "." + r.slice(1));
  } else
    return c = Ey(E, p + 2, x).times(s + ""), w = Rl(new E(n + "." + r.slice(1)), p - m).plus(c), E.precision = x, e == null ? gt(w, x, A, Lt = !0) : w;
  for (h = w, l = o = w = or(w.minus(1), w.plus(1), p, 1), d = gt(w.times(w), p, 1), i = 3; ; ) {
    if (o = gt(o.times(d), p, 1), c = l.plus(or(o, new E(i), p, 1)), hn(c.d).slice(0, p) === hn(l.d).slice(0, p))
      if (l = l.times(2), s !== 0 && (l = l.plus(Ey(E, p + 2, x).times(s + ""))), l = or(l, new E(b), p, 1), e == null)
        if (v0(l.d, p - m, A, a))
          E.precision = p += m, c = o = w = or(h.minus(1), h.plus(1), p, 1), d = gt(w.times(w), p, 1), i = a = 1;
        else
          return gt(l, E.precision = x, A, Lt = !0);
      else
        return E.precision = x, l;
    l = c, i += 2;
  }
}
function uN(t) {
  return String(t.s * t.s / 0);
}
function A7(t, e) {
  var r, n, i;
  for ((r = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (r = e.length), n = 0; e.charCodeAt(n) === 48; n++) ;
  for (i = e.length; e.charCodeAt(i - 1) === 48; --i) ;
  if (e = e.slice(n, i), e) {
    if (i -= n, t.e = r = r - n - 1, t.d = [], n = (r + 1) % vt, r < 0 && (n += vt), n < i) {
      for (n && t.d.push(+e.slice(0, n)), i -= vt; n < i; ) t.d.push(+e.slice(n, n += vt));
      e = e.slice(n), n = vt - e.length;
    } else
      n -= i;
    for (; n--; ) e += "0";
    t.d.push(+e), Lt && (t.e > t.constructor.maxE ? (t.d = null, t.e = NaN) : t.e < t.constructor.minE && (t.e = 0, t.d = [0]));
  } else
    t.e = 0, t.d = [0];
  return t;
}
function Kre(t, e) {
  var r, n, i, s, o, a, l, c, p;
  if (e === "Infinity" || e === "NaN")
    return +e || (t.s = NaN), t.e = NaN, t.d = null, t;
  if (Ure.test(e))
    r = 16, e = e.toLowerCase();
  else if (Vre.test(e))
    r = 2;
  else if (Hre.test(e))
    r = 8;
  else
    throw Error(sh + e);
  for (s = e.search(/p/i), s > 0 ? (l = +e.slice(s + 1), e = e.substring(2, s)) : e = e.slice(2), s = e.indexOf("."), o = s >= 0, n = t.constructor, o && (e = e.replace(".", ""), a = e.length, s = a - s, i = lN(n, new n(r), s, s * 2)), c = w1(e, r, Fs), p = c.length - 1, s = p; c[s] === 0; --s) c.pop();
  return s < 0 ? new n(t.s * 0) : (t.e = wb(c, p), t.d = c, Lt = !1, o && (t = or(t, i, a * 4)), l && (t = t.times(Math.abs(l) < 54 ? Math.pow(2, l) : kg.pow(2, l))), Lt = !0, t);
}
function Yre(t, e) {
  var r, n = e.d.length;
  if (n < 3) return Wp(t, 2, e, e);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, e = e.times(Math.pow(5, -r)), e = Wp(t, 2, e, e);
  for (var i, s = new t(5), o = new t(16), a = new t(20); r--; )
    i = e.times(e), e = e.times(s.plus(i.times(o.times(i).minus(a))));
  return e;
}
function Wp(t, e, r, n, i) {
  var s, o, a, l, c = t.precision, p = Math.ceil(c / vt);
  for (Lt = !1, l = r.times(r), a = new t(n); ; ) {
    if (o = or(a.times(l), new t(e++ * e++), c, 1), a = i ? n.plus(o) : n.minus(o), n = or(o.times(l), new t(e++ * e++), c, 1), o = a.plus(n), o.d[p] !== void 0) {
      for (s = p; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = n, n = o, o = s;
  }
  return Lt = !0, o.d.length = p + 1, o;
}
function hN(t, e) {
  var r, n = e.s < 0, i = Ms(t, t.precision, 1), s = i.times(0.5);
  if (e = e.abs(), e.lte(s))
    return pa = n ? 4 : 1, e;
  if (r = e.divToInt(i), r.isZero())
    pa = n ? 3 : 2;
  else {
    if (e = e.minus(r.times(i)), e.lte(s))
      return pa = S7(r) ? n ? 2 : 3 : n ? 4 : 1, e;
    pa = S7(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return e.minus(i).abs();
}
function S5(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, b = t.constructor, m = r !== void 0;
  if (m ? (li(r, 1, kc), n === void 0 ? n = b.rounding : li(n, 0, 8)) : (r = b.precision, n = b.rounding), !t.isFinite())
    p = uN(t);
  else {
    for (p = Uo(t), o = p.indexOf("."), m ? (i = 2, e == 16 ? r = r * 4 - 3 : e == 8 && (r = r * 3 - 2)) : i = e, o >= 0 && (p = p.replace(".", ""), d = new b(1), d.e = p.length - o, d.d = w1(Uo(d), 10, i), d.e = d.d.length), h = w1(p, 10, i), s = l = h.length; h[--l] == 0; ) h.pop();
    if (!h[0])
      p = m ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (t = new b(t), t.d = h, t.e = s, t = or(t, d, r, n, 0, i), h = t.d, s = t.e, c = iN), o = h[r], a = i / 2, c = c || h[r + 1] !== void 0, c = n < 4 ? (o !== void 0 || c) && (n === 0 || n === (t.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || c || n === 6 && h[r - 1] & 1 || n === (t.s < 0 ? 8 : 7)), h.length = r, c)
        for (; ++h[--r] > i - 1; )
          h[r] = 0, r || (++s, h.unshift(1));
      for (l = h.length; !h[l - 1]; --l) ;
      for (o = 0, p = ""; o < l; o++) p += $x.charAt(h[o]);
      if (m) {
        if (l > 1)
          if (e == 16 || e == 8) {
            for (o = e == 16 ? 4 : 3, --l; l % o; l++) p += "0";
            for (h = w1(p, i, e), l = h.length; !h[l - 1]; --l) ;
            for (o = 1, p = "1."; o < l; o++) p += $x.charAt(h[o]);
          } else
            p = p.charAt(0) + "." + p.slice(1);
        p = p + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) p = "0" + p;
        p = "0." + p;
      } else if (++s > l) for (s -= l; s--; ) p += "0";
      else s < l && (p = p.slice(0, s) + "." + p.slice(s));
    }
    p = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + p;
  }
  return t.s < 0 ? "-" + p : p;
}
function k7(t, e) {
  if (t.length > e)
    return t.length = e, !0;
}
function Zre(t) {
  return new this(t).abs();
}
function Jre(t) {
  return new this(t).acos();
}
function Xre(t) {
  return new this(t).acosh();
}
function ene(t, e) {
  return new this(t).plus(e);
}
function tne(t) {
  return new this(t).asin();
}
function rne(t) {
  return new this(t).asinh();
}
function nne(t) {
  return new this(t).atan();
}
function ine(t) {
  return new this(t).atanh();
}
function sne(t, e) {
  t = new this(t), e = new this(e);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !t.s || !e.s ? r = new this(NaN) : !t.d && !e.d ? (r = Ms(this, s, 1).times(e.s > 0 ? 0.25 : 0.75), r.s = t.s) : !e.d || t.isZero() ? (r = e.s < 0 ? Ms(this, n, i) : new this(0), r.s = t.s) : !t.d || e.isZero() ? (r = Ms(this, s, 1).times(0.5), r.s = t.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(or(t, e, s, 1)), e = Ms(this, s, 1), this.precision = n, this.rounding = i, r = t.s < 0 ? r.minus(e) : r.plus(e)) : r = this.atan(or(t, e, s, 1)), r;
}
function one(t) {
  return new this(t).cbrt();
}
function ane(t) {
  return gt(t = new this(t), t.e + 1, 2);
}
function lne(t) {
  if (!t || typeof t != "object") throw Error(vb + "Object expected");
  var e, r, n, i = t.defaults === !0, s = [
    "precision",
    1,
    kc,
    "rounding",
    0,
    8,
    "toExpNeg",
    -9e15,
    0,
    "toExpPos",
    0,
    Dx,
    "maxE",
    0,
    Dx,
    "minE",
    -9e15,
    0,
    "modulo",
    0,
    9
  ];
  for (e = 0; e < s.length; e += 3)
    if (r = s[e], i && (this[r] = jx[r]), (n = t[r]) !== void 0)
      if (Mn(n) === n && n >= s[e + 1] && n <= s[e + 2]) this[r] = n;
      else throw Error(sh + r + ": " + n);
  if (r = "crypto", i && (this[r] = jx[r]), (n = t[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(oN);
      else
        this[r] = !1;
    else
      throw Error(sh + r + ": " + n);
  return this;
}
function cne(t) {
  return new this(t).cos();
}
function une(t) {
  return new this(t).cosh();
}
function pN(t) {
  var e, r, n;
  function i(s) {
    var o, a, l, c = this;
    if (!(c instanceof i)) return new i(s);
    if (c.constructor = i, s instanceof i) {
      c.s = s.s, c.e = s.e, c.d = (s = s.d) ? s.slice() : s;
      return;
    }
    if (l = typeof s, l === "number") {
      if (s === 0) {
        c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        c.e = o, c.d = [s];
        return;
      } else if (s * 0 !== 0) {
        s || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return A7(c, s.toString());
    } else if (l !== "string")
      throw Error(sh + s);
    return s.charCodeAt(0) === 45 ? (s = s.slice(1), c.s = -1) : c.s = 1, Gre.test(s) ? A7(c, s) : Kre(c, s);
  }
  if (i.prototype = Ve, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = lne, i.clone = pN, i.isDecimal = gne, i.abs = Zre, i.acos = Jre, i.acosh = Xre, i.add = ene, i.asin = tne, i.asinh = rne, i.atan = nne, i.atanh = ine, i.atan2 = sne, i.cbrt = one, i.ceil = ane, i.cos = cne, i.cosh = une, i.div = hne, i.exp = pne, i.floor = dne, i.hypot = fne, i.ln = mne, i.log = yne, i.log10 = vne, i.log2 = bne, i.max = wne, i.min = xne, i.mod = Ene, i.mul = Sne, i.pow = Ane, i.random = kne, i.round = _ne, i.sign = Cne, i.sin = Ine, i.sinh = Pne, i.sqrt = Rne, i.sub = One, i.tan = Tne, i.tanh = Lne, i.trunc = Mne, t === void 0 && (t = {}), t && t.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; ) t.hasOwnProperty(r = n[e++]) || (t[r] = this[r]);
  return i.config(t), i;
}
function hne(t, e) {
  return new this(t).div(e);
}
function pne(t) {
  return new this(t).exp();
}
function dne(t) {
  return gt(t = new this(t), t.e + 1, 3);
}
function fne() {
  var t, e, r = new this(0);
  for (Lt = !1, t = 0; t < arguments.length; )
    if (e = new this(arguments[t++]), e.d)
      r.d && (r = r.plus(e.times(e)));
    else {
      if (e.s)
        return Lt = !0, new this(1 / 0);
      r = e;
    }
  return Lt = !0, r.sqrt();
}
function gne(t) {
  return t instanceof kg || t && t.name === "[object Decimal]" || !1;
}
function mne(t) {
  return new this(t).ln();
}
function yne(t, e) {
  return new this(t).log(e);
}
function bne(t) {
  return new this(t).log(2);
}
function vne(t) {
  return new this(t).log(10);
}
function wne() {
  return cN(this, arguments, "lt");
}
function xne() {
  return cN(this, arguments, "gt");
}
function Ene(t, e) {
  return new this(t).mod(e);
}
function Sne(t, e) {
  return new this(t).mul(e);
}
function Ane(t, e) {
  return new this(t).pow(e);
}
function kne(t) {
  var e, r, n, i, s = 0, o = new this(1), a = [];
  if (t === void 0 ? t = this.precision : li(t, 1, kc), n = Math.ceil(t / vt), this.crypto)
    if (crypto.getRandomValues)
      for (e = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = e[s], i >= 429e7 ? e[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (e = crypto.randomBytes(n *= 4); s < n; )
        i = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((e[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(oN);
  else for (; s < n; ) a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], t %= vt, n && t && (i = Sn(10, vt - t), a[s] = (n / i | 0) * i); a[s] === 0; s--) a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= vt) a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
    n < vt && (r -= vt - n);
  }
  return o.e = r, o.d = a, o;
}
function _ne(t) {
  return gt(t = new this(t), t.e + 1, this.rounding);
}
function Cne(t) {
  return t = new this(t), t.d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN;
}
function Ine(t) {
  return new this(t).sin();
}
function Pne(t) {
  return new this(t).sinh();
}
function Rne(t) {
  return new this(t).sqrt();
}
function One(t, e) {
  return new this(t).sub(e);
}
function Tne(t) {
  return new this(t).tan();
}
function Lne(t) {
  return new this(t).tanh();
}
function Mne(t) {
  return gt(t = new this(t), t.e + 1, 1);
}
var kg = pN(jx);
wy = new kg(wy);
xy = new kg(xy);
function Nne(t) {
  let e = 0.01;
  switch (!0) {
    case t.gte(1e12):
      e = 1e12;
      break;
    case t.gte(1e9):
      e = 1e9;
      break;
    case t.gte(1e6):
      e = 1e6;
      break;
    case t.gte(1e3):
      e = 1e3;
      break;
    case t.gte(1):
      e = 1;
      break;
  }
  return { number: t.div(e).toNumber(), scale: e };
}
function Dne(t) {
  if (t.length < 2)
    return t.length;
  const e = [];
  e: for (const r of t) {
    for (const n of e)
      if (r.equals(n))
        continue e;
    e.push(r);
  }
  return e.length;
}
function $ne(t, e) {
  return t.cmp(e);
}
function jne(t) {
  const e = t.map((a) => a.number * a.scale), r = new Set(e).size, n = e.map((a) => new kg(a));
  let i = !0, s = 3, o = [];
  for (; i; ) {
    o = n.map((l) => l.toSD(s));
    const a = Dne(o);
    r === a ? i = !1 : s++, s === 10 && (i = !1);
  }
  return o.map((a, l) => ({ ...Nne(a), roundingDirection: $ne(a, n[l]) }));
}
function dN(t, e) {
  const r = e.map((a) => a.facetValueAsNumber(t)), n = Math.min(...r), i = Math.max(...r), s = e.filter((a) => a.facetValueAsNumber(t) === n), o = e.filter((a) => a.facetValueAsNumber(t) === i);
  return {
    min: { value: n, datapoints: s },
    max: { value: i, datapoints: o },
    range: i - n,
    mean: Vo(r),
    median: jre(r),
    mode: Mre(r)
  };
}
function Bne(t, e) {
  const r = e.map((n) => ({ number: n, scale: t }));
  return jne(r);
}
function Fne(t, e, r) {
  const n = [], i = [];
  for (const d of t) {
    n.push(...d.datapoints.map((m) => m.facetValue("y")));
    const b = d.getFacetStats("y");
    i.push(
      d.datapoints[0].facetValue("y"),
      d.datapoints.at(-1).facetValue("y"),
      b.max.value,
      b.min.value
    );
  }
  const s = n.concat(i);
  s.push(...e.map((d) => d.value));
  const o = Bne(r ?? 1, s);
  let a = t[0].length;
  const l = {};
  for (let d = 0; d < t.length; d++) {
    const b = t[d];
    l[b.key] = o.slice(d * a, d + 1 * a);
  }
  let c = t.length * a;
  a = 4;
  const p = {};
  for (let d = 0; d < t.length; d++) {
    const b = t[d];
    p[b.key] = {
      start: o[d * a + c],
      end: o[d * a + c + 1],
      max: o[d * a + c + 2],
      min: o[d * a + c + 3]
    };
  }
  c += t.length * 4;
  const h = o.slice(c);
  return [l, p, h];
}
function zne(t, e) {
  if (!eN((r, n) => r === n, Object.keys(t), Object.keys(e)))
    return !1;
  for (const r in t)
    if (!t[r].isEqual(e[r]))
      return !1;
  return !0;
}
class Vne {
  constructor(e) {
    if (this.facets = e, this.facetKeyIndexMap = {}, this.facets.length === 0)
      throw new Error("dataframes must have at least 1 column");
    this.columns = Gu(this.facets.length, (r) => []), this.facets.forEach((r, n) => {
      this.facetKeyIndexMap[r.key] = n;
    });
  }
  addDatapoint(e) {
    const r = Object.keys(e).length;
    if (r !== this.nColumns)
      throw new Error(`datapoint ${e} cannot be added to dataframe. This dataframe has ${this.nColumns} columns, but this datapoint as ${r} facets`);
    Gu(this.nColumns, (n) => {
      const i = this.facets[n], s = e[i.key];
      if (s === void 0)
        throw new Error(`datapoint ${e} is missing the facet ${i.key}`);
      this.columns[n].push(new Pre[i.datatype](s));
    });
  }
  get nRows() {
    return this.columns[0].length;
  }
  get nColumns() {
    return this.columns.length;
  }
  get rows() {
    return Gu(this.nRows, (e) => {
      const r = {};
      return this.columns.forEach((n, i) => {
        r[this.facets[i].key] = n[e];
      }), r;
    });
  }
  facet(e) {
    return this.columns[this.facetKeyIndexMap[e]] ?? null;
  }
  /** Iterate over the rows, producing DataFrames of one row. */
  /* *[Symbol.iterator]() {
    for (let i = 0; i < this.nRows; i++) {
      yield [i, this.slice(i, i + 1)] as [number, DataFrame];
    }
  }*/
  /** Iterate over the columns, producing Series. */
  /*get iterCols() {
      return new ColumnIterable(this.data);
    }
  
    private checkRowBounds(row: number) {
      if (row < 0) {
        if (row < -this.nRows) {
          throw new Error(`row index '${row}' out of bounds`);
        }
        row = this.data[0].length + row;
      } else if (row >= this.nRows) {
        throw new Error(`row index '${row}' out of bounds`);
      }
    }*/
  /**
   * Retrieve the row at the given index as a series.
   * @param row - The row.
   * @remarks
   * Will fail if all columns are not of the same type.
   */
  /*row(row: number) {
      this.checkRowBounds(row);
      if (this.data.length === 0) {
        throw new Error('data frame has no columns');
      }
      const type = this.data[0].dtype;
      this.data.slice(1).forEach(series => {
        if (series.dtype !== type) {
          throw new Error(`all columns must have type '${type}'`);
        }
      }); 
      return new seriesTypes[type](this.data.map(series => series.at(row)) as ScalarArray);
    }
  
    col(name: string) {
      const series = this.data.find(series => series.name === name);
      if (!series) {  
        throw new Error(`no column with name '${name}'`);
      }
      return series;
    }
  
    slice(start?: number, end?: number) {
      return new DataFrame(
        this.data.map(series => series.slice(start, end)));
    }
  
    at(row: number, col: string) {
      this.checkRowBounds(row);
      const series = this.data.find(series => series.name === col);
      if (!series) {
        throw new Error(`no column with name '${col}'`);
      }
      return series.atBoxed(row);
    }
  
    private assertColsExist(colNames: string[]) {
      const existingColNames = this.data.map(series => series.name!);
      colNames.forEach(name => {
        if (!existingColNames.includes(name)) {
          throw new Error(`no such column '${name}'`);
        }
      });
    }
  
    takeCols(colNames: string[]) {
      this.assertColsExist(colNames);
      return new DataFrame(colNames.map(name => this.col(name)!));
    }
  
    dropCols(colNames: string[]) {
      this.assertColsExist(colNames);
      const existingColNames = this.data.map(series => series.name!);
      return new DataFrame(
        existingColNames
          .filter(name => !colNames.includes(name))
          .map(name => this.col(name)!));
    }
  
    map<T>(fn: (el: DataFrame, index: number) => T): T[] {
      const out: T[] = [];
      for (const [i, row] of this) {
        out.push(fn(row, i));
      }
      return out;
    }
  
    mapCols<T>(fn: (el: Series<Scalar>, index: number) => T): T[] {
      const out: T[] = [];
      for (const [i, col] of this.iterCols) {
        out.push(fn(col, i));
      }
      return out;
    }*/
}
var Une = Object.defineProperty, Hne = Object.getOwnPropertyDescriptor, xb = (t, e, r, n) => {
  for (var i = Hne(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && Une(e, r, i), i;
};
let Pd = class {
  constructor(e, r, n) {
    this.data = e, this.seriesKey = r, this.datapointIndex = n;
  }
  entries() {
    return Object.entries(this.data)[Symbol.iterator]();
  }
  facetBox(e) {
    return this.data[e] ?? null;
  }
  facetValue(e) {
    return this.data[e].value ?? null;
  }
  facetValueAsNumber(e) {
    const r = this.data[e];
    return r === void 0 || !r.isNumberLike() ? null : r.asNumber();
  }
  facetValueNumericized(e) {
    const r = this.data[e];
    return r === void 0 ? null : r.isNumber() ? r.value : r.isDate() ? r.asNumber() : this.datapointIndex;
  }
  convertFacetValuesToXYForLine(e, r) {
    const n = this.facetValueNumericized(e), i = this.facetValueNumericized(r);
    return n === null || i === null ? null : { x: n, y: i };
  }
  equals(e) {
    return zne(this.data, e.data) && this.seriesKey === e.seriesKey && this.datapointIndex === e.datapointIndex;
  }
  getNavcode() {
    return `datapoint-${this.seriesKey}-${this.datapointIndex}`;
  }
};
xb([
  pr()
], Pd.prototype, "facetValueAsNumber");
xb([
  pr()
], Pd.prototype, "facetValueNumericized");
xb([
  pr()
], Pd.prototype, "convertFacetValuesToXYForLine");
xb([
  pr()
], Pd.prototype, "getNavcode");
class Gne extends Pd {
  constructor(e, r, n, i, s) {
    if (super(e, r, n), this.indepKey = i, this.depKey = s, !(i in e))
      throw new Error(`'PlaneDatapoint' is missing the '${i}' independent axis facet value`);
    if (!(s in e))
      throw new Error(`'PlaneDatapoint' is missing the '${s}' dependent axis facet value`);
  }
  get indepBox() {
    return this.data[this.indepKey];
  }
  get depBox() {
    return this.data[this.depKey];
  }
  // TODO: Is this needed any more with PlaneSeries?
  convertToActualXYForLine() {
    return this.convertFacetValuesToXYForLine(this.indepKey, this.depKey);
  }
}
var Wne = Object.defineProperty, qne = Object.getOwnPropertyDescriptor, Qa = (t, e, r, n) => {
  for (var i = qne(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && Wne(e, r, i), i;
};
let ta = class {
  constructor(e, r, n, i, s) {
    this.manifest = e, this.rawData = r, this.facetSignatures = n, this.indepKey = i, this.depKey = s, this.datapoints = [], this.facetKeys = [], this._uniqueValuesForFacetMappedByKey = {}, this._facetDatatypeMappedByKey = {}, this.originalKey = this.manifest.key, this.key = cJ(this.originalKey), this.label = this.manifest.label ?? this.originalKey, this.facetSignatures.forEach((o) => {
      this.facetKeys.push(o.key), this._uniqueValuesForFacetMappedByKey[o.key] = new tN(), this._facetDatatypeMappedByKey[o.key] = o.datatype;
    }), this._dataframe = new Vne(n), this.length = this.rawData.length, this.rawData.forEach((o) => this._dataframe.addDatapoint(o)), this._dataframe.rows.forEach((o, a) => {
      const l = this.constructDatapoint(o, this.key, a);
      this[a] = l, this.datapoints.push(l), Object.keys(o).forEach(
        (c) => this._uniqueValuesForFacetMappedByKey[c].add(o[c])
      );
    });
  }
  constructDatapoint(e, r, n) {
    return new Pd(e, r, n);
  }
  facetBoxes(e) {
    return this._dataframe.facet(e);
  }
  allFacetValues(e) {
    var r;
    return ((r = this._uniqueValuesForFacetMappedByKey[e]) == null ? void 0 : r.values) ?? null;
  }
  getFacetDatatype(e) {
    return this._facetDatatypeMappedByKey[e] ?? null;
  }
  createLineFromFacets(e, r) {
    if (!this.facetKeys.includes(e) || !this.facetKeys.includes(r))
      return null;
    const n = this.datapoints.map((i) => i.convertFacetValuesToXYForLine(e, r));
    return new u0(n, this.key);
  }
  facetAverage(e) {
    const r = this._facetDatatypeMappedByKey[e];
    return Mx(r) ? Vo(this.datapoints.map((n) => n.facetValueAsNumber(e))) : null;
  }
  getFacetStats(e) {
    const r = this._facetDatatypeMappedByKey[e];
    return Mx(r) ? dN(e, this.datapoints) : null;
  }
  [Symbol.iterator]() {
    return this.datapoints[Symbol.iterator]();
  }
  // Assumes at most one datapoint at that value at that facet
  datapointAt(e, r) {
    const n = this._facetDatatypeMappedByKey[e];
    if (n === void 0 || r.datatype() !== n)
      return null;
    for (const i of this.datapoints)
      if (i.facetBox(e).isEqual(r))
        return i;
    return null;
  }
  getLabel() {
    return this.label ? this.label : this.key;
  }
};
Qa([
  pr()
], ta.prototype, "facetBoxes");
Qa([
  pr()
], ta.prototype, "allFacetValues");
Qa([
  pr()
], ta.prototype, "getFacetDatatype");
Qa([
  pr()
], ta.prototype, "createLineFromFacets");
Qa([
  pr()
], ta.prototype, "facetAverage");
Qa([
  pr()
], ta.prototype, "getFacetStats");
Qa([
  pr()
], ta.prototype, "getLabel");
let Eb = class extends ta {
  /*protected xMap: Map<ScalarMap[X], number[]>;
  private yMap: Map<number, ScalarMap[X][]>;*/
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), console.assert(this.facetKeys.includes(i), `[ParaModel/Internal]: PlaneSeries constructed with unknown indepKey ${i}`), console.assert(this.facetKeys.includes(s), `[ParaModel/Internal]: PlaneSeries constructed with unknown depKey ${s}`), console.assert(Mx(this.getFacetDatatype(s)), `[ParaModel/Internal]: PlaneSeries depKey ${s} has non-number-like ${this.getFacetDatatype(s)} datatype`);
  }
  constructDatapoint(e, r, n) {
    return new Gne(e, r, n, this.indepKey, this.depKey);
  }
  getActualLine() {
    return this.createLineFromFacets(this.indepKey, this.depKey);
  }
  getIndepAverage() {
    return this.facetAverage(this.indepKey);
  }
  // TODO: Add This
  /*@Memoize()
  public getAnalyzer(): SingleSeriesMetadataAnalyzer {
    return new BasicSingleSeriesAnalyzer(this.createActualLine());
  }*/
  /*atX(x: ScalarMap[X]): number[] | null {
      return this.xMap.get(x) ?? null;
    }
  
    atY(y: number): ScalarMap[X][] | null {
      return this.yMap.get(y) ?? null;
    }*/
};
Qa([
  pr()
], Eb.prototype, "getActualLine");
Qa([
  pr()
], Eb.prototype, "getIndepAverage");
function Qne(t, e) {
  if (!t.records)
    throw new Error("only series manifests with inline data can use this method.");
  return new ta(t, t.records, e);
}
function Kne(t, e, r, n) {
  if (!t.records)
    throw new Error("only series manifests with inline data can use this method.");
  return new Eb(
    t,
    t.records,
    e,
    r,
    n
  );
}
const Wu = {
  numPointsNotEqual: 0,
  segStartNotBeforeEnd: 1,
  seriesWithoutKey: 2
}, Yne = {
  [Wu.numPointsNotEqual]: "number of points in each time series must be equal",
  [Wu.segStartNotBeforeEnd]: "The start x value of a segment must be less than the end x value of the segment.",
  [Wu.seriesWithoutKey]: "Every series must have a key"
};
let Sy = class extends Error {
  /**
   * Constructs the Err class
   * @param code - The code of the error
   */
  constructor(e) {
    super(Yne[e]), this.code = e;
  }
};
function _7(t, e) {
  return { start: t.points[e], end: t.points[e + 1] };
}
let fN = class {
  constructor(e, r, n) {
    if (this.series1 = e, this.series2 = r, e.length !== r.length)
      throw new Sy(Wu.numPointsNotEqual);
    this.allSegPairProps = Gu(
      e.length - 1,
      (o) => this.checkIntersection(_7(e, o), _7(r, o), n, o)
    ), this.intersectingSegPairs = this.getIntersections(), this.parallelSegPairs = this.getParallelSegPairs();
    const { dominant: i, timeOnTop: s } = this.findDominant();
    this.dominant = i, this.timeOnTop = s, this.averageGap = e.points.map((o, a) => Math.abs(o.y - r.points[a].y)).reduce((o, a) => o + a, 0) / e.length;
  }
  // This is public only for testing
  getIntersections() {
    return this.allSegPairProps.filter((e) => e.intersection !== "None");
  }
  getParallelSegPairs() {
    return this.allSegPairProps.filter(
      (e) => e.relationship === 3 || e.relationship === 4
      /* FunctionallyParallel */
    );
  }
  findDominant() {
    const e = this.series1.points[1].x - this.series1.points[0].x;
    let r = 0;
    this.allSegPairProps.forEach((i, s) => {
      const o = i.segs;
      if (i.relationship === 0) {
        const a = i.intersection;
        a.crosspoint.x === o[0].start.x ? o[0].end.y > o[1].end.y && (r += e) : a.crosspoint.x === o[0].end.x ? o[0].start.y > o[1].start.y && (r += e) : o[0].start.y > o[1].start.y ? r += a.crosspoint.x - o[0].start.x : r += o[0].end.x - a.crosspoint.x;
      } else i.relationship !== 2 && o[0].start.y > o[1].start.y && (r += e);
    }), r /= this.series1.points.at(-1).x - this.series1.points[0].x;
    const n = r > 0.5 ? 1 : r < 0.5 ? 2 : -1;
    return { dominant: n, timeOnTop: n === 1 ? r : 1 - r };
  }
  /**
   * Check for the relationship between two lines. 
   * Uses a vector cross-product approach described on StackOverflow:
   * http://stackoverflow.com/a/565282/786339
   */
  // This is only public for testing
  checkIntersection(e, r, n, i) {
    const s = this.findSlope(e, n), o = this.findSlope(r, n);
    let a = {
      i,
      segs: [e, r],
      relationship: 1,
      slopes: {
        a: s,
        b: o
      },
      category: "",
      //TODO: add categories?
      intersection: "None"
    };
    return Math.max(e.start.y, e.end.y) < Math.min(r.start.y, r.end.y) || Math.min(e.start.y, e.end.y) > Math.max(r.start.y, r.end.y) ? a.relationship = this.getParallelApproximation(a.slopes.a, a.slopes.b) : e.start.y === r.start.y || e.end.y === r.end.y ? e.end.y !== r.end.y || e.start.y !== r.start.y ? (a.relationship = 0, a.intersection = {
      crosspoint: e.end.y !== r.end.y ? e.start : e.end,
      angle: this.findAngle(s, o),
      atRecord: !0
    }) : (a.relationship = 2, a.intersection = "Overlap") : this.calculateLineIntersectionPoints(e, r, a), a;
  }
  /**
   * Check for the relationship between two lines. 
   * Uses a vector cross-product approach described on StackOverflow:
   * http://stackoverflow.com/a/565282/786339
   *  
   * The formula expressed in this module takes advantage of vector representations for number lines. 
   * A typical numberline is expressed in start and end points on an x, y plane or axis.Example line:
   * 
   * p (1,2) as the startpoint
   * p2 (3,6) as the endpoint 
   * 
   * Points on a number line can also be expressed as a 2 x 1 vector
   *  p = |1|
   *      |2|
   * 
   * And therefore line segments are expressed by vector addition: 
   * p + r where 
   * p = original point on the number line.
   * r = the transformation. This can de thought of as the difference, or change between point p and point p2.
   * 
   * this means r = p2 - p.    
   * 
   * so in the above points r = (2, 3) of r = |2|
   *                                          |3|
   *   
   * p in this case is the same as the above. It is the startpoint of the number line.
   * 
   * The rest of this function references the above formula fairly closely. 
   */
  calculateLineIntersectionPoints(e, r, n) {
    const i = this.subtractPoints(e.end, e.start), s = this.subtractPoints(r.end, r.start), o = this.crossProduct(this.subtractPoints(r.start, e.start), i), a = this.crossProduct(i, s);
    if (a === 0 && o !== 0)
      n.relationship = 3;
    else {
      const l = o / a, c = this.crossProduct(this.subtractPoints(r.start, e.start), i) / a;
      if (c >= 0 && c <= 1 && l >= 0 && l <= 1) {
        let p = { x: i.x * c, y: i.y * c };
        const h = this.addPoints(p, e.start);
        n.relationship = 0, n.intersection = {
          crosspoint: h,
          //NOTE: the left and right angles here will be the same
          angle: this.findAngle(n.slopes.a, n.slopes.b),
          atRecord: !1
        };
      } else
        this.getParallelApproximation(n.slopes.a, n.slopes.b);
    }
  }
  /**
   */
  getParallelApproximation(e, r) {
    const n = Hf(e), i = Hf(r), s = 5, o = Math.abs(n - i);
    return n === i ? 3 : o < s ? 4 : 1;
  }
  /**
   * Find the apparent slope/gradient of a segment, scaled to the x and y ranges that the graph displays.
   *   NOTE:  run can always be considered 1, as the two points of a segment are adjacent.
   *   NOTE: Horizontal lines are 0. Verticle lines are impossible, as x1 must be strictly greater than x2.
   * @returns the slope as a float.
   */
  findSlope(e, r) {
    if (e.end.x <= e.start.x)
      throw new Sy(Wu.segStartNotBeforeEnd);
    const n = (e.end.y - e.start.y) * r;
    return n === 0 ? 0 : n / 1;
  }
  /**
   * Calculate the cross product of two points.
   * @param point1 - point object with x and y coordinates
   * @param point2 - point object with x and y coordinates
   * @returns The cross product result as a float
   */
  crossProduct(e, r) {
    return e.x * r.y - e.y * r.x;
  }
  /**
   * Subtracts the second point from the first.
   * @param point1 - point object with x and y coordinates
   * @param point2 - point object with x and y coordinates
   * @returns The subtraction result as a point object
   */
  subtractPoints(e, r) {
    return { x: e.x - r.x, y: e.y - r.y };
  }
  /**
   * Add two points.
   * @param point1 - point object with x and y coordinates
   * @param point2 - point object with x and y coordinates
   * @returns The addition result as a point object
   */
  addPoints(e, r) {
    return {
      x: Number((e.x + r.x).toFixed(3)),
      y: Number((e.y + r.y).toFixed(3))
    };
  }
  getSlopeClass(e) {
    return e > 0 ? "positive" : e < 0 ? "negative" : "zero";
  }
  oppositeSlopes(e, r) {
    return e === "positive" && r === "negative" || r === "positive" && e === "negative";
  }
  // NOTE: if lineAt45DegreesY == startTopY then acuteAngle == obtuseAngle == 90
  findAngle(e, r) {
    const n = this.findLineIntersectionAngle(e, r), i = this.getSlopeClass(e), s = this.getSlopeClass(r);
    if (this.oppositeSlopes(i, s)) {
      const [o, a] = i === "positive" ? [e, r] : [r, e], l = -1 / a;
      if (o > l)
        return 180 - n;
    }
    return n;
  }
  /**
   * Finds the acute angle of intersection between two line segments, using their slopes. 
   *   Note that parallel and colinear lines will return an angle of 0.
   * @param m1 - the numeric value of the first slope.
   * @param m2 - the numeric value of the second slope.
   * @returns the acute angle of intersection in degrees.
   */
  findLineIntersectionAngle(e, r) {
    const n = Math.abs((r - e) / (1 + e * r));
    return Hf(n);
  }
}, gN = class {
  //screenCoordSysSize: [xScreenSize, yScreenSize], only ratio matters
  constructor(e, r, n, i) {
    const s = r[0] / r[1], o = e[0].length - 1;
    n = n ?? 0, i = i ?? Math.max(...e.map((c) => c.yBounds().end));
    const a = o / (i - n);
    this.yScale = a * s, this.intersections = [], this.overlaps = [], this.parallels = [], this.pairs = [], this.trackingGroups = [], this.trackingZones = [], this.clusters = [], this.clusterOutliers = [];
    const l = e.length;
    if (l !== 1)
      for (let c = 0; c < l - 1; c++) {
        const p = e[c];
        if (p.key === void 0)
          throw new Sy(Wu.seriesWithoutKey);
        for (let h = c + 1; h < l; h++) {
          const d = e[h];
          if (d.key === void 0)
            throw new Sy(Wu.seriesWithoutKey);
          const b = [p.key, d.key], m = new fN(p, d, this.yScale), w = m.intersectingSegPairs;
          for (let k = 0; k < w.length; k++) {
            const S = w[k];
            if (S.relationship === 2)
              continue;
            const R = S.intersection;
            let L;
            const F = this.generateAngleDetails(S, b, "start");
            let z, j, ee;
            if (R.atRecord) {
              if (k < w.length - 1 && w[k + 1].relationship === 2 || k > 0 && w[k - 1].relationship === 2)
                continue;
              if (L = {
                // the exact record the intersection took place at
                labelValue: R.crosspoint.x,
                beforeValue: null,
                afterValue: null
              }, R.crosspoint.x === p.points[0].x)
                z = null, j = F, ee = this.getTransversal(S.segs, b, "start");
              else if (R.crosspoint.x === p.points.at(-1).x)
                z = F, j = null, ee = this.getTransversal(S.segs, b, "end");
              else {
                k++;
                const X = w[k];
                z = F, j = {
                  top: this.getTop(X.segs, b, "end"),
                  angle: X.intersection.angle,
                  //TODO: explain cast
                  slope: {
                    [p.key]: X.slopes.a,
                    [d.key]: X.slopes.b
                  }
                }, ee = this.getTransversalOnRecord(S.segs, X.segs, b);
              }
            } else
              L = {
                labelValue: null,
                // the intersection occurred between two record indexes, therefore the prior and post record labels are populated
                beforeValue: S.segs[0].start.x,
                afterValue: S.segs[0].end.x
              }, z = F, j = F, j.top = this.getTop(S.segs, b, "end"), ee = this.getTransversal(S.segs, b, "middle");
            this.intersections.push({
              // the record labels for the intersection
              record: L,
              // the value of the intersection point, in y-axis units
              value: S.intersection.crosspoint.y,
              // TODO: explain cast
              // the list of series labels for all the series that participated in the intersection
              series: b,
              incomingAngle: this.generateAngleMetadata(z, b),
              outgoingAngle: this.generateAngleMetadata(j, b),
              transversality: ee
            });
          }
          let f = this.blankOverlap(b), E = !1;
          for (let k = 0; k < w.length; k++) {
            const S = w[k];
            if (S.relationship === 2) {
              const R = S.segs[0].start, L = S.segs[0].end;
              E ? f.datapoints.push([L.x.toString(), L.y]) : (f.incomingAngle = k === 0 ? null : this.generateAngleMetadata(this.generateAngleDetails(
                w[k - 1],
                b,
                "start"
              ), b), f.datapoints.push([R.x.toString(), R.y]), f.datapoints.push([L.x.toString(), L.y]), E = !0);
            } else
              E && (f.outgoingAngle = this.generateAngleMetadata(
                this.generateAngleDetails(w[k], b, "end"),
                b
              ), this.overlaps.push(structuredClone(f)), f = this.blankOverlap(b), E = !1);
          }
          E && this.overlaps.push(f);
          const A = m.allSegPairProps;
          let x = this.blankParallel(b), g = !1, v = 0;
          for (let k = 0; k < A.length; k++) {
            const S = A[k];
            if (S.relationship === 3 || S.relationship === 4) {
              const R = S.segs[0].start, L = S.segs[0].end;
              v++, S.relationship === 4 && (x.kind = "functional"), g ? x.records.push({ label: L.x.toString() }) : (x.incomingDirection = k === 0 ? null : this.determineDirection(A[k - 1], "start"), x.records.push({ label: R.x.toString() }), x.records.push({ label: L.x.toString() }), g = !0);
            } else
              g && (x.outgoingDirection = k === A.length - 1 ? null : this.determineDirection(A[k + 1], "end"), this.parallels.push(structuredClone(x)), x = this.blankParallel(b), g = !1);
          }
          g && this.parallels.push(x), this.pairs.push({
            series: b,
            dominant: m.dominant === -1 ? null : b[m.dominant - 1],
            dominantPercent: m.timeOnTop,
            parallelPercent: v / A.length * 100
          });
        }
      }
  }
  getIntersections() {
    return this.intersections;
  }
  getOverlaps() {
    return this.overlaps;
  }
  getParallels() {
    return this.parallels;
  }
  getPairs() {
    return this.pairs;
  }
  getTrackingGroups() {
    return this.trackingGroups;
  }
  getTrackingZones() {
    return this.trackingZones;
  }
  getClusters() {
    return this.clusters;
  }
  getClusterOutliers() {
    return this.clusterOutliers;
  }
  generateAngleDetails(e, r, n) {
    return {
      top: this.getTop(e.segs, r, n),
      angle: e.intersection.angle,
      //TODO: explain cast
      slope: {
        [r[0]]: e.slopes.a,
        [r[1]]: e.slopes.b
      }
    };
  }
  generateAngleMetadata(e, r) {
    return e === null ? null : {
      [r[0]]: {
        [r[1]]: e
      },
      [r[1]]: {
        [r[0]]: e
      }
    };
  }
  blankOverlap(e) {
    return {
      datapoints: [],
      series: e,
      incomingAngle: null,
      outgoingAngle: null
    };
  }
  blankParallel(e) {
    return {
      records: [],
      series: e,
      incomingDirection: null,
      outgoingDirection: null,
      kind: "perfect"
    };
  }
  getTop(e, r, n) {
    const i = this.getTopIndex(e, n);
    return i === null ? null : r[i];
  }
  getTopIndex(e, r) {
    const n = e[0][r].y, i = e[1][r].y;
    return n > i ? 0 : n < i ? 1 : null;
  }
  determineDirection(e, r) {
    const n = Math.abs(e.segs[0].start.y - e.segs[1].start.y), i = Math.abs(e.segs[0].end.y - e.segs[1].end.y);
    return (r === "start" ? i : n) < (r === "start" ? n : i) ? "converge" : "diverge";
  }
  getTransversal(e, r, n) {
    let i, s;
    if (n !== "middle") {
      i = "edge";
      const a = n === "start" ? "end" : "start";
      s = this.getTopIndex(e, a);
    } else {
      s = this.getTopIndex(e, "start");
      const a = this.getTopIndex(e, "end");
      s === a ? i = "touch" : i = "cross";
    }
    const o = +(s === 0);
    return i === "cross" ? {
      kind: i,
      topToBottom: r[s],
      bottomToTop: r[o]
    } : {
      kind: i,
      top: r[s],
      bottom: r[o]
    };
  }
  getTransversalOnRecord(e, r, n) {
    const i = this.getTopIndex(e, "start"), s = this.getTopIndex(r, "end");
    if (i === s) {
      const o = +(i === 0);
      return {
        kind: "touch",
        top: n[i],
        bottom: n[o]
      };
    } else
      return {
        kind: "cross",
        topToBottom: n[i],
        bottomToTop: n[s]
      };
  }
};
function Zne(t) {
  return t === "" ? "" : t[0].toLowerCase() + t.slice(1);
}
function mN(t, e) {
  let r = Zne(t);
  return e === "proportion" && r.startsWith("proportion of ") && (r = r.slice(14)), { baseQuantity: r, baseKind: e };
}
function Jne(t) {
  if (!t.multi)
    return t.getSeriesTheme(t.seriesKeys[0]);
  const e = t.family === "pastry" ? "proportion" : "number";
  return mN(t.title ?? "value", e);
}
function Xne(t, e) {
  if (!e.multi && e.hasExplictChartTheme())
    return e.getChartTheme();
  const r = e.family === "pastry" ? "proportion" : "number";
  return mN(e.atKey(t).label, r);
}
var eie = Object.defineProperty, tie = Object.getOwnPropertyDescriptor, bi = (t, e, r, n) => {
  for (var i = tie(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && eie(e, r, i), i;
};
let ks = class {
  constructor(e, r) {
    if (this.series = e, this.facetKeys = [], this.dependentFacetKeys = [], this.independentFacetKeys = [], this.seriesKeys = [], this.originalSeriesKeys = [], this.allPoints = [], this._facetMap = {}, this._facetDatatypeMap = {}, this._facetDisplayTypeMap = {}, this._uniqueValuesForFacet = {}, this._axisFacetKeys = [], this._seriesMap = {}, this._seriesThemeMap = {}, this._seriesLabelMap = {}, this.series.length === 0)
      throw new Error("models must have at least one series");
    this.multi = this.series.length > 1, this._dataset = r.datasets[0], this.title = this._dataset.title, this.description = this._dataset.description, this.type = this._dataset.type, this.family = Ex[this.type], this._theme = this._dataset.chartTheme, this.facetSignatures = this.series[0].facetSignatures, this.facetSignatures.forEach((n) => {
      this.facetKeys.push(n.key), this._uniqueValuesForFacet[n.key] = new tN(), this._facetDatatypeMap[n.key] = n.datatype;
    }), this.facetKeys.forEach((n) => {
      const i = this._dataset.facets[n];
      this._facetDisplayTypeMap[n] = i.displayType, this._facetMap[n] = i, i.variableType === "dependent" && this.dependentFacetKeys.push(n), i.variableType === "independent" && this.independentFacetKeys.push(n);
    }), this.numSeries = this.series.length;
    for (const [n, i] of Wn(this.series)) {
      if (this.seriesKeys.includes(n.key))
        throw new Error("every series in a model must have a unique key");
      if (!eN(
        (s, o) => s.key === o.key && s.datatype === o.datatype,
        n.facetSignatures,
        this.facetSignatures
      ))
        throw new Error("every series in a model must have the same facets");
      this.seriesKeys.push(n.key), this.originalSeriesKeys.push(n.originalKey), this[i] = n, this._seriesMap[n.key] = n, this._seriesLabelMap[n.getLabel()] = n.key, this.allPoints.push(...n), Object.keys(this._uniqueValuesForFacet).forEach((s) => {
        this._uniqueValuesForFacet[s].merge(n.allFacetValues(s));
      }), this._seriesThemeMap[n.key] = n.manifest.theme;
    }
  }
  atKey(e) {
    return this._seriesMap[e] ?? null;
  }
  atKeyAndIndex(e, r) {
    var n;
    return ((n = this.atKey(e)) == null ? void 0 : n[r]) ?? null;
  }
  allFacetValues(e) {
    var r;
    return ((r = this._uniqueValuesForFacet[e]) == null ? void 0 : r.values) ?? null;
  }
  getFacetStats(e) {
    return this._facetDatatypeMap[e] !== "number" ? null : dN(e, this.allPoints);
  }
  getFacetInterval(e) {
    const r = this.getFacetStats(e);
    return r ? { start: r.min.value, end: r.max.value } : null;
  }
  getFacet(e) {
    return this._facetMap[e] ?? null;
  }
  hasExplictChartTheme() {
    return this._theme !== void 0;
  }
  getChartTheme() {
    return this._theme ?? Jne(this);
  }
  getSeriesTheme(e) {
    return this.atKey(e) === null ? null : this._seriesThemeMap[e] ?? Xne(e, this);
  }
  isPlaneModel() {
    return !1;
  }
  prevDatapoint(e) {
    const r = this.atKey(e.seriesKey);
    return r === null ? null : r.datapoints.at(e.datapointIndex - 1) ?? null;
  }
  nextDatapoint(e) {
    const r = this.atKey(e.seriesKey);
    return r === null ? null : r.datapoints.at(e.datapointIndex + 1) ?? null;
  }
  atLabel(e) {
    const r = this._seriesLabelMap[e];
    return r === void 0 ? null : this.atKey(r);
  }
};
bi([
  pr()
], ks.prototype, "atKey");
bi([
  pr()
], ks.prototype, "allFacetValues");
bi([
  pr()
], ks.prototype, "getFacetStats");
bi([
  pr()
], ks.prototype, "getFacetInterval");
bi([
  pr()
], ks.prototype, "getFacet");
bi([
  pr()
], ks.prototype, "hasExplictChartTheme");
bi([
  pr()
], ks.prototype, "getChartTheme");
bi([
  pr()
], ks.prototype, "getSeriesTheme");
bi([
  pr()
], ks.prototype, "atLabel");
let _c = class extends ks {
  /*public readonly xs: ScalarMap[X][];
  public readonly ys: number[];*/
  constructor(e, r, n, i = gN, s = !0) {
    var o;
    if (super(e, r), this.seriesAnalyzerConstructor = n, this.pairAnalyzerConstructor = i, this._useWorker = s, this.intersections = [], this.clusters = [], this.clusterOutliers = [], this.trackingGroups = [], this.trackingZones = [], this._seriesPairAnalyzer = null, this._seriesLineMap = {}, this._seriesAnalysisDone = !1, this.grouped = this._dataset.seriesRelations === "grouped", this.facetKeys.forEach((a) => {
      const l = this._dataset.facets[a];
      l.displayType.type === "axis" && (l.displayType.orientation === "horizontal" ? this.horizontalAxisKey = a : l.displayType.orientation === "vertical" && (this.verticalAxisKey = a));
    }), this.dependentAxisKey = this.dependentFacetKeys[0], this.independentAxisKey = this.independentFacetKeys[0], (this.horizontalAxisKey === void 0 || this.verticalAxisKey === void 0) && (this.horizontalAxisKey = this.independentAxisKey, this.verticalAxisKey = this.dependentAxisKey), this.family === "line" || this.family === "bar" || this.family === "histogram") {
      for (const a of this.series)
        this._seriesLineMap[a.key] = a.getActualLine();
      if (this.multi) {
        const a = this.getAxisInterval(this.getAxisOrientation("dependent"));
        this._seriesPairAnalyzer = new this.pairAnalyzerConstructor(
          Object.values(this._seriesLineMap),
          [1, 1],
          //FIXME: get actual screen size
          a.start,
          a.end
        ), this.intersections = this._seriesPairAnalyzer.getIntersections(), this.clusters = this._seriesPairAnalyzer.getClusters(), this.clusterOutliers = this._seriesPairAnalyzer.getClusterOutliers(), this.trackingGroups = this._seriesPairAnalyzer.getTrackingGroups(), this.trackingZones = this._seriesPairAnalyzer.getTrackingZones();
      }
      [this.seriesScaledValues, this.seriesStatsScaledValues, this.intersectionScaledValues] = Fne(this.series, this.intersections, (o = this.getAxisFacet("vert")) == null ? void 0 : o.multiplier);
    }
  }
  async generateSeriesAnalyses() {
    if (this._seriesAnalysisDone)
      return;
    const e = new this.seriesAnalyzerConstructor();
    this._seriesAnalysisMap = {};
    for (const r in this._seriesLineMap)
      this._seriesAnalysisMap[r] = await e.analyzeSeries(
        this._seriesLineMap[r],
        {
          useWorker: this._useWorker,
          yAxis: this.getAxisInterval(this.getAxisOrientation("dependent"))
        }
      );
    this._seriesAnalysisDone = !0;
  }
  atKey(e) {
    return super.atKey(e);
  }
  getAxisFacet(e) {
    return e === "horiz" ? this.horizontalAxisKey ? this._facetMap[this.horizontalAxisKey] : null : this.verticalAxisKey ? this._facetMap[this.verticalAxisKey] : null;
  }
  getAxisOrientation(e) {
    return (e === "dependent" ? this.dependentAxisKey : this.independentAxisKey) === this.verticalAxisKey ? "vert" : "horiz";
  }
  getAxisInterval(e) {
    var r, n, i, s, o, a;
    const l = e === "horiz" ? this.horizontalAxisKey : this.verticalAxisKey, c = this.getFacetInterval(l);
    if (!c)
      return null;
    let { start: p, end: h } = c;
    const d = ((i = (n = (r = this._dataset.settings) == null ? void 0 : r.axis) == null ? void 0 : n[l]) == null ? void 0 : i.minValue) ?? "unset", b = ((a = (o = (s = this._dataset.settings) == null ? void 0 : s.axis) == null ? void 0 : o[l]) == null ? void 0 : a.maxValue) ?? "unset";
    return d !== "unset" && (p = d), b !== "unset" && (h = b), { start: p, end: h };
  }
  async getSeriesAnalysis(e) {
    return this.type === "scatter" || !this.seriesAnalyzerConstructor || !this.seriesKeys.includes(e) ? null : (await this.generateSeriesAnalyses(), this._seriesAnalysisMap[e]);
  }
  isPlaneModel() {
    return !0;
  }
  getChordAt(e, r) {
    const n = this._facetDatatypeMap[e];
    return n === void 0 || r.datatype() !== n ? null : this.series.map((i) => i.datapointAt(e, r)).filter((i) => i !== null);
  }
};
bi([
  pr()
], _c.prototype, "atKey");
bi([
  pr()
], _c.prototype, "getAxisFacet");
bi([
  pr()
], _c.prototype, "getAxisOrientation");
bi([
  pr()
], _c.prototype, "getAxisInterval");
bi([
  pr()
], _c.prototype, "getSeriesAnalysis");
function _g(t) {
  return Object.keys(t.facets).map((e) => ({ key: e, datatype: t.facets[e].datatype }));
}
function yN(t) {
  const e = Object.entries(t.facets).filter(([n, i]) => i.displayType.type === "axis").filter(([n, i]) => i.variableType === "independent").map(([n, i]) => n).at(0), r = Object.entries(t.facets).filter(([n, i]) => i.displayType.type === "axis").filter(([n, i]) => i.variableType === "dependent").map(([n, i]) => n).at(0);
  return { independentAxisKey: e, dependentAxisKey: r };
}
function rie(t) {
  const e = t.datasets[0];
  if (e.data.source !== "inline")
    throw new Error("only manifests with inline data can use this method.");
  const r = _g(e), n = e.series.map(
    (i) => Qne(i, r)
  );
  return new ks(n, t);
}
function nie(t, e) {
  const r = _g(e.datasets[0]), n = Object.keys(t).map((i) => {
    const s = e.datasets[0].series.filter((o) => o.key === i)[0];
    return new ta(s, t[i], r);
  });
  return new ks(n, e);
}
function iie(t, e, r, n) {
  const i = t.datasets[0];
  if (i.data.source !== "inline")
    throw new Error("only manifests with inline data can use this function.");
  const { independentAxisKey: s, dependentAxisKey: o } = yN(i);
  if (!s || !o)
    throw new Error("only manifests with 2D axes can use this function.");
  const a = _g(i), l = i.series.map(
    (c) => Kne(c, a, s, o)
  );
  return new _c(l, t, e, r, n);
}
function sie(t, e, r, n, i) {
  const s = e.datasets[0], { independentAxisKey: o, dependentAxisKey: a } = yN(s);
  if (!o || !a)
    throw new Error("only manifests with 2D axes can use this function.");
  const l = _g(s), c = Object.keys(t).map((p) => {
    const h = s.series.filter((d) => d.key === p)[0];
    return new Eb(h, t[p], l, o, a);
  });
  return new _c(c, e, r, n, i);
}
let C7 = class {
  /**
   * Constructor
   * @param {*} options 
   * @constructor
   */
  constructor(e) {
    this._options = e;
  }
  /**
   * Initializes the module and calls the different methods in order.
   * @private
   * @memberOf module:@fizz/svmjs
   */
  async _init() {
  }
  // data is NxD array of floats. labels are 1 or -1.
  train(e, r, n) {
    this.data = e, this.labels = r, n = n || {};
    const i = n.C || 1, s = n.tol || 1e-4, o = n.alphatol || 1e-7, a = n.maxiter || 1e4, l = n.numpasses || 10;
    let c = ww;
    if (this.kernelType = "linear", "kernel" in n)
      if (typeof n.kernel == "string") {
        if (n.kernel === "linear" && (this.kernelType = "linear", c = ww), n.kernel === "rbf") {
          const m = n.rbfsigma || 0.5;
          this.rbfSigma = m, this.kernelType = "rbf", c = I7(m);
        }
      } else
        this.kernelType = "custom", c = n.kernel;
    this.kernel = c, this.N = e.length;
    const p = this.N;
    if (this.D = e[0].length, this.D, this.alpha = aie(p), this.b = 0, this.usew_ = !1, n.memoize) {
      this.kernelResults = new Array(p);
      for (let m = 0; m < p; m++) {
        this.kernelResults[m] = new Array(p);
        for (let w = 0; w < p; w++)
          this.kernelResults[m][w] = c(e[m], e[w]);
      }
    }
    let h = 0, d = 0;
    for (; d < l && h < a; ) {
      let m = 0;
      for (let w = 0; w < p; w++) {
        const f = this.marginOne(e[w]) - r[w];
        if (r[w] * f < -s && this.alpha[w] < i || r[w] * f > s && this.alpha[w] > 0) {
          let E = w;
          for (; E === w; ) E = oie(0, this.N);
          const A = this.marginOne(e[E]) - r[E];
          let x = this.alpha[w], g = this.alpha[E], v = 0, k = i;
          if (r[w] === r[E] ? (v = Math.max(0, x + g - i), k = Math.min(i, x + g)) : (v = Math.max(0, g - x), k = Math.min(i, i + g - x)), Math.abs(v - k) < 1e-4) continue;
          const S = 2 * this.kernelResult(w, E) - this.kernelResult(w, w) - this.kernelResult(E, E);
          if (S >= 0) continue;
          let R = g - r[E] * (f - A) / S;
          if (R > k && (R = k), R < v && (R = v), Math.abs(g - R) < 1e-4) continue;
          this.alpha[E] = R;
          const L = x + r[w] * r[E] * (g - R);
          this.alpha[w] = L;
          const F = this.b - f - r[w] * (L - x) * this.kernelResult(w, w) - r[E] * (R - g) * this.kernelResult(w, E), z = this.b - A - r[w] * (L - x) * this.kernelResult(w, E) - r[E] * (R - g) * this.kernelResult(E, E);
          this.b = 0.5 * (F + z), L > 0 && L < i && (this.b = F), R > 0 && R < i && (this.b = z), m++;
        }
      }
      h++, m == 0 ? d++ : d = 0;
    }
    if (this.kernelType === "linear") {
      this.w = new Array(this.D);
      for (let m = 0; m < this.D; m++) {
        let w = 0;
        for (let f = 0; f < this.N; f++)
          w += this.alpha[f] * r[f] * e[f][m];
        this.w[m] = w, this.usew_ = !0;
      }
    } else {
      const m = [], w = [], f = [];
      for (let E = 0; E < this.N; E++)
        this.alpha[E] > o && (m.push(this.data[E]), w.push(this.labels[E]), f.push(this.alpha[E]));
      this.data = m, this.labels = w, this.alpha = f, this.N = this.data.length;
    }
    const b = {};
    return b.iters = h, b;
  }
  // inst is an array of length D. Returns margin of given example
  // this is the core prediction function. All others are for convenience mostly
  // and end up calling this one somehow.
  marginOne(e) {
    let r = this.b;
    if (this.usew_)
      for (let n = 0; n < this.D; n++)
        r += e[n] * this.w[n];
    else
      for (let n = 0; n < this.N; n++)
        r += this.alpha[n] * this.labels[n] * this.kernel(e, this.data[n]);
    return r;
  }
  predictOne(e) {
    return this.marginOne(e) > 0 ? 1 : -1;
  }
  // data is an NxD array. Returns array of margins.
  margins(e) {
    const r = e.length, n = new Array(r);
    for (let i = 0; i < r; i++)
      n[i] = this.marginOne(e[i]);
    return n;
  }
  kernelResult(e, r) {
    return this.kernelResults ? this.kernelResults[e][r] : this.kernel(this.data[e], this.data[r]);
  }
  // data is NxD array. Returns array of 1 or -1, predictions
  predict(e) {
    const r = this.margins(e);
    for (let n = 0; n < r.length; n++)
      r[n] = r[n] > 0 ? 1 : -1;
    return r;
  }
  // THIS FUNCTION IS NOW DEPRECATED. WORKS FINE BUT NO NEED TO USE ANYMORE. 
  // LEAVING IT HERE JUST FOR BACKWARDS COMPATIBILITY FOR A WHILE.
  // if we trained a linear svm, it is possible to calculate just the weights and the offset
  // prediction is then yhat = sign(X * w + b)
  getWeights() {
    const e = new Array(this.D);
    for (let r = 0; r < this.D; r++) {
      let n = 0;
      for (let i = 0; i < this.N; i++)
        n += this.alpha[i] * this.labels[i] * this.data[i][r];
      e[r] = n;
    }
    return { w: e, b: this.b };
  }
  toJSON() {
    if (this.kernelType === "custom")
      return console.log("Can't save this SVM because it's using custom, unsupported kernel..."), {};
    const e = {};
    return e.N = this.N, e.D = this.D, e.b = this.b, e.kernelType = this.kernelType, this.kernelType === "linear" && (e.w = this.w), this.kernelType === "rbf" && (e.rbfSigma = this.rbfSigma, e.data = this.data, e.labels = this.labels, e.alpha = this.alpha), e;
  }
  fromJSON(e) {
    this.N = e.N, this.D = e.D, this.b = e.b, this.kernelType = e.kernelType, this.kernelType === "linear" ? (this.w = e.w, this.usew_ = !0, this.kernel = ww) : this.kernelType == "rbf" ? (this.rbfSigma = e.rbfSigma, this.kernel = I7(this.rbfSigma), this.data = e.data, this.labels = e.labels, this.alpha = e.alpha) : console.log("ERROR! unrecognized kernel type." + this.kernelType);
  }
};
function I7(t) {
  return function(e, r) {
    let n = 0;
    for (let i = 0; i < e.length; i++)
      n += (e[i] - r[i]) * (e[i] - r[i]);
    return Math.exp(-n / (2 * t * t));
  };
}
function ww(t, e) {
  let r = 0;
  for (let n = 0; n < t.length; n++)
    r += t[n] * e[n];
  return r;
}
function oie(t, e) {
  return Math.floor(Math.random() * (e - t) + t);
}
function aie(t) {
  const e = new Array(t);
  for (let r = 0; r < t; r++)
    e[r] = 0;
  return e;
}
class lie {
  constructor(e) {
    e && (this.df = e);
  }
  LogGamma(e) {
    const r = 1 + 76.18009173 / e - 86.50532033 / (e + 1) + 24.01409822 / (e + 2) - 1.231739516 / (e + 3) + 0.00120858003 / (e + 4) - 536382e-11 / (e + 5);
    return (e - 0.5) * Math.log(e + 4.5) - (e + 4.5) + Math.log(r * 2.50662827465);
  }
  Betinc(e, r, n) {
    let i = 0, s = 1, o = 1, a = 1, l = 0, c = 0, p;
    for (; Math.abs((o - c) / o) > 1e-5; )
      c = o, p = -(r + l) * (r + n + l) * e / (r + 2 * l) / (r + 2 * l + 1), i = o + p * i, s = a + p * s, l = l + 1, p = l * (n - l) * e / (r + 2 * l - 1) / (r + 2 * l), o = i + p * o, a = s + p * a, i = i / a, s = s / a, o = o / a, a = 1;
    return o / r;
  }
  cumulativeProbability(e, r) {
    r || (r = this.df);
    let n;
    if (r <= 0)
      console.error("Degrees of freedom must be positive");
    else {
      const i = r / 2, s = i + 0.5, o = r / (r + e * e), a = Math.exp(this.LogGamma(s) - this.LogGamma(0.5) - this.LogGamma(i) + i * Math.log(o) + 0.5 * Math.log(1 - o));
      let l;
      o < (i + 1) / (s + 2) ? l = a * this.Betinc(o, i, 0.5) : l = 1 - a * this.Betinc(1 - o, 0.5, i), e < 0 ? n = l / 2 : n = 1 - l / 2;
    }
    return n = Math.round(n * 1e5) / 1e5, n;
  }
  invCumulativeProbability(e, r) {
    if (r || (r = this.df), e >= 0.5) {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(o, r) >= e); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(n + o / 100) >= e); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(i + o / 1e4) >= e); o += 1)
        s = i + o / 1e4;
      return s;
    } else {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-o, r) <= e); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-n - o / 100) <= e); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-i - o / 1e4) <= e); o += 1)
        s = i + o / 1e4;
      return -s;
    }
  }
}
class cie {
  constructor(e, r) {
    this.df1 = e, this.df2 = r, this.EPSILON = 1e-10;
  }
  L504(e, r, n, i) {
    const s = e * r / (e * r + n), o = Math.sqrt(s), a = Math.log(o), l = Math.sqrt(1 - s), c = Math.log(l);
    let p = 1 - 2 * Math.atan(o / Math.sqrt(-o * o + 1)) / Math.PI, h = 0;
    if (n != 1) {
      const d = Math.log(2 * o / Math.PI);
      if (p -= Math.exp(d + c), n != 3) {
        const b = Math.floor((n - 3) / 2);
        for (let m = 1; m <= b; m++) {
          const w = 2 * m + 1;
          h += Math.log((w - 1) / w);
          const f = h + c * w + d;
          f > -78.4 && (p -= Math.exp(f));
        }
      }
    }
    if (e != 1) {
      let d = h;
      if (n > 1 && (d += Math.log(n - 1)), d += Math.log(2 / Math.PI) + a + c * n, d > -78.4 && (p += Math.exp(d)), e != 3) {
        const b = Math.floor((e - 3) / 2);
        h = 0;
        for (let m = 1; m <= b; m++) {
          const w = m * 2 + 1;
          h += Math.log((n + w - 2) / w);
          const f = h + a * (w - 1) + d;
          f > -78.4 && (p += Math.exp(f));
        }
      }
    }
    return p;
  }
  L401(e, r, n, i) {
    const s = e * r / (e * r + n), o = Math.log(s);
    let a = 0;
    const l = Math.log(1 - s) * n / 2;
    if (l > -78.4 && (a = Math.exp(l)), e != 2) {
      const c = Math.floor(e / 2 - 1);
      let p = 0;
      for (let h = 1; h <= c; h++) {
        const d = 2 * h;
        p += Math.log(n + d - 2) - Math.log(d) + o, p + l > -78.4 && (a += Math.exp(p + l));
      }
    }
    return i == 1 && (a = 1 - a), a;
  }
  ProbF(e, r, n) {
    let i = n, s = e, o = r, a = 0;
    return Math.floor(s / 2) * 2 == s ? this.L401(s, i, o, a) : Math.floor(o / 2) * 2 != o ? this.L504(s, i, o, a) : (i = 1 / i, s = r, o = e, a = 1, this.L401(s, i, o, a));
  }
  cumulativeProbability(e) {
    if (this.df1 > 0.01 && this.df2 > 0.01 && e > this.EPSILON)
      return 1 - this.ProbF(this.df1, this.df2, e);
    console.error("df1, df2, and F must be numbers greater than 0.");
  }
}
const P7 = [
  1.4142024783770517,
  1.7285350177358225,
  1.975558322080508,
  2.165309701618668,
  2.3223314597870495,
  2.43666896580902,
  2.539575597098922,
  2.629725259756139,
  2.6946351910160824,
  2.7571690989287108,
  2.82429436007275,
  2.86976990061697,
  2.911181488216127,
  2.9562785307147474,
  2.991043137459134,
  3.031892332910388,
  3.0390882779033968,
  3.084150339177206,
  3.1068126593538534,
  3.1377944664764175,
  3.1526730795266236,
  3.1856353298858746,
  3.1923941584623616,
  3.2232152987382205,
  3.2423279731889063,
  3.2672678614514434,
  3.28815589678312,
  3.306598538588182,
  3.3169876930034423,
  3.3426537588982366,
  3.338808432731316,
  3.3551800156910674,
  3.3677857453596176,
  3.3801704122612546,
  3.3894353098402292,
  3.4103476461664384,
  3.420758782190955,
  3.4234022273067235,
  3.4377591100482245,
  3.4495251663075597,
  3.45784133640642,
  3.4655169406594553,
  3.499664208072353,
  3.5075228374867624,
  3.4963470841468247,
  3.5194522982765517,
  3.50887461478777,
  3.517883433127914,
  3.527130862311399,
  3.5478465903324174,
  3.5524335509017972,
  3.5453727082671342,
  3.556173872494318,
  3.557087103502499,
  3.589369632641309,
  3.5859140345184524,
  3.572323092223869,
  3.6004177405174853,
  3.6100996977289306,
  3.601519301860006,
  3.606430559116003,
  3.623484959486857,
  3.6110156117453704,
  3.6398254610166214,
  3.6485762129590045,
  3.6369984456518214,
  3.6420217039991707,
  3.6515502039986543,
  3.6534596174533878,
  3.6659253039539754,
  3.678204062277477,
  3.673013776537585,
  3.6873396028854244,
  3.677549442478252,
  3.672393117945697,
  3.694338890356745,
  3.698559967922895,
  3.7088383298959364,
  3.6960214124422732,
  3.6962804693332054,
  3.7259363906151113,
  3.6945941836261005,
  3.7123614650012637,
  3.7266182166220743,
  3.726433940762783,
  3.7262288936328507,
  3.73068538678121,
  3.7464587039431216,
  3.734498500854471,
  3.7666496106093086,
  3.7577811376185797,
  3.755885408241557,
  3.7653220485067256,
  3.759612302718265,
  3.750000422234468,
  3.776893666562007,
  3.7656945047078376
], uie = [
  [
    12.92876788710003,
    18.669362102797844,
    20.708185574014465
  ],
  [
    12.893379950402329,
    17.838738753100234,
    20.009145166260716
  ],
  [
    12.567620517329296,
    17.39284624657391,
    19.327403214291675
  ],
  [
    12.44012368783225,
    17.159725181804923,
    19.031999514734718
  ],
  [
    12.258810404004157,
    16.643626920880678,
    18.520644599539708
  ],
  [
    12.490936102639248,
    17.07031258707699,
    19.26763537042604
  ],
  [
    12.230582644506537,
    16.8611702133535,
    19.04138451550924
  ],
  [
    12.285890759032673,
    16.72028694459538,
    18.998686524252154
  ],
  [
    12.265830882960202,
    16.861313711298223,
    19.01741086021432
  ],
  [
    12.221592293386445,
    16.856569952690425,
    18.679522968116675
  ],
  [
    12.207863926087379,
    16.466760433982508,
    18.327798576854196
  ],
  [
    12.23047144884862,
    16.604698640112442,
    18.778749913667404
  ],
  [
    12.310880515319493,
    16.75477031068603,
    18.61887265606582
  ],
  [
    12.09088910593483,
    16.680683526842817,
    19.10909766756724
  ],
  [
    12.28969274656454,
    16.494346369998592,
    18.555323182091747
  ],
  [
    12.351479909044647,
    17.231085800266705,
    19.12315903511468
  ],
  [
    12.232654018508402,
    17.03319706813043,
    19.36238761950663
  ],
  [
    12.24175327982118,
    17.01249507542771,
    19.29261479388184
  ],
  [
    12.240819762926595,
    16.958668959199564,
    18.703343358289676
  ],
  [
    12.325576191647679,
    16.741637280941735,
    18.706270613293825
  ],
  [
    12.29079270883332,
    16.83580567418819,
    18.885633182327588
  ],
  [
    12.105579742321321,
    16.801481191805877,
    18.74917129995002
  ],
  [
    12.241506985184987,
    16.421107838741005,
    18.51907643327747
  ],
  [
    12.22772321442409,
    16.76637698315794,
    18.59944945667253
  ],
  [
    12.146827427372807,
    16.504491710455042,
    18.624893334253915
  ],
  [
    12.099825423105056,
    16.517727777727934,
    18.389759370770282
  ],
  [
    12.241793182544008,
    16.69983166753318,
    18.199273554649118
  ],
  [
    12.133827646762477,
    16.937161124066893,
    18.865979715097055
  ],
  [
    12.014897172400497,
    16.64164656731907,
    18.52796800753582
  ],
  [
    12.03194886183511,
    16.448427247716083,
    18.360165754021324
  ],
  [
    12.060576333659972,
    16.972556324548336,
    18.909884009510286
  ],
  [
    12.130919558394593,
    16.846538605893603,
    18.974105413083418
  ],
  [
    12.167013704292577,
    16.962535224497064,
    18.952800614645692
  ],
  [
    12.307745895005242,
    16.69776947316106,
    18.73020815902911
  ],
  [
    12.03703814065202,
    16.744259233990512,
    19.40987043616083
  ],
  [
    12.23158902787162,
    16.992381220472012,
    19.23258888861058
  ],
  [
    12.30313545083327,
    16.80175925410746,
    18.88639508508212
  ],
  [
    12.216506652052612,
    16.95978747527697,
    19.07369251354378
  ],
  [
    12.289633178985905,
    17.037358965358983,
    18.978000598844293
  ],
  [
    12.114391564747471,
    16.353909897952686,
    18.35011390560238
  ],
  [
    12.208213936084457,
    16.12841887472018,
    18.239736208276152
  ],
  [
    12.326886082604242,
    16.87043068171149,
    18.900551155302647
  ],
  [
    12.24602935198574,
    16.740078446411406,
    18.57610242578182
  ],
  [
    12.154508067768113,
    16.70375179351137,
    18.84458221820561
  ],
  [
    12.053162931004179,
    16.63616478058826,
    18.764716631834734
  ],
  [
    12.242031428895839,
    16.870439498648583,
    18.946299240629287
  ],
  [
    12.172676093456305,
    16.57616403586386,
    18.901254056077153
  ],
  [
    12.234873290793098,
    16.849691971911838,
    19.020953521536004
  ],
  [
    12.307356477970162,
    17.070904468883104,
    19.124634537613513
  ],
  [
    12.258316325281726,
    16.98236293001686,
    19.362641577913156
  ],
  [
    12.236258781616636,
    16.835948685325945,
    18.872615556171525
  ],
  [
    12.218214829379882,
    16.72052856570416,
    18.576319895769533
  ],
  [
    12.266452802779268,
    17.001974682521503,
    19.397512454689892
  ],
  [
    12.142229768023105,
    16.760040761542093,
    18.73221439686166
  ],
  [
    12.362128316602698,
    16.779263655428466,
    18.690631800055144
  ],
  [
    12.23248525532616,
    16.78957578482738,
    19.290187946573045
  ],
  [
    12.194978246692179,
    16.66872414977679,
    18.38065055971982
  ],
  [
    12.364346090585878,
    16.78308783969924,
    18.787944141467552
  ],
  [
    12.213523054233821,
    16.745070120633624,
    18.779462580096293
  ],
  [
    12.120562728816676,
    16.72947148909386,
    18.540581750860838
  ],
  [
    12.147441684285011,
    16.362711939455345,
    18.5928909502196
  ],
  [
    12.349013958141011,
    17.115157968739332,
    19.074081167238724
  ],
  [
    12.169896474381117,
    16.779107284309674,
    19.095614865501265
  ],
  [
    12.212332899050487,
    17.15220159015151,
    19.18433312800504
  ],
  [
    12.427266331944576,
    17.19802901185036,
    19.08282870552354
  ],
  [
    12.208415329256482,
    16.698611123996386,
    18.437039290733527
  ],
  [
    12.150857540075965,
    16.747967767000077,
    18.522105916017864
  ],
  [
    12.185133777587764,
    16.716543085287885,
    18.75368115517968
  ],
  [
    12.202518998568662,
    16.695350960024488,
    18.766605345681214
  ],
  [
    12.293516845096802,
    16.848652152520355,
    18.73818931670063
  ],
  [
    12.264328782539446,
    16.898700733974184,
    18.91736903501125
  ],
  [
    12.283442238272498,
    16.79113139749197,
    18.762641899116595
  ],
  [
    12.288571666812464,
    16.947956362708894,
    19.26608413111616
  ],
  [
    12.199938820517241,
    16.73882101164454,
    18.649824259785902
  ],
  [
    12.281399931209005,
    16.74455321404603,
    18.993644280454557
  ],
  [
    11.978508088635845,
    16.751385791647305,
    19.067980524092103
  ],
  [
    12.352190443412464,
    17.002035355108024,
    18.910150024775536
  ],
  [
    12.11299191492474,
    16.85211409238294,
    19.21553533835868
  ],
  [
    12.252946905996852,
    16.77267825853487,
    18.758060103809566
  ],
  [
    12.253428278525488,
    17.05117162481038,
    19.437396636388712
  ],
  [
    12.365555609949542,
    17.217797222036967,
    19.557725250431925
  ],
  [
    12.446856234792692,
    17.13219895129848,
    19.189823799758685
  ],
  [
    12.378913383861864,
    16.69420382596318,
    18.614200176451167
  ],
  [
    12.209646506057828,
    17.049298470931937,
    19.21471558598783
  ],
  [
    12.07451389049845,
    16.52146599860598,
    18.646538442813565
  ],
  [
    12.242992826481506,
    17.118044327693312,
    19.109033882498373
  ],
  [
    12.031588638774476,
    16.440292876584916,
    18.365137461548116
  ],
  [
    12.256327863966023,
    16.937124809805663,
    19.055448755862216
  ],
  [
    12.152502866561859,
    16.51661734703226,
    18.292867488178068
  ],
  [
    12.240166584135661,
    17.01144955716148,
    19.269980514360167
  ],
  [
    12.288087364649998,
    16.9124768573556,
    18.78496409520197
  ],
  [
    12.261031067472498,
    17.080660923120398,
    18.993376274931116
  ],
  [
    12.149516099981419,
    16.429960356660846,
    18.693814658804264
  ],
  [
    12.189972968413274,
    16.360091390089806,
    18.372140642711813
  ],
  [
    12.247713311640034,
    16.85901876289993,
    18.747152105084417
  ],
  [
    12.235996387439796,
    16.719425800548546,
    18.73463631602104
  ]
], qu = {
  minLen3: 0,
  minLen6: 1,
  tooManyPoints: 2
}, hie = {
  [qu.minLen3]: "line must have at least 3 points",
  [qu.minLen6]: "line must have at least 6 points",
  [qu.tooManyPoints]: "line contains too many points"
};
let Sb = class extends Error {
  constructor(e) {
    super(hie[e]), this.code = e;
  }
};
function pie(t, e, r) {
  return t.map((n) => n - e).map((n) => n / r);
}
function xw(t) {
  const e = t.bestFit, r = e.rss();
  return {
    se: Math.sqrt(r / t.length),
    rss: r,
    resid: e.residuals,
    slope: e.slope,
    inter: e.intercept
  };
}
function die(t) {
  if (t.length < 3)
    throw new Sb(qu.minLen3);
  const e = zre(t.points.map((r) => r.x), t.points.map((r) => r.y));
  return Number.isNaN(e) ? 1 : Math.abs(e);
}
function fie(t) {
  const e = t.length;
  if (e < 6)
    throw new Sb(qu.minLen6);
  const { se: r } = xw(t);
  if (r === 0)
    return { feats: [0, 0, 0] };
  const n = uie[e - 6], i = [];
  for (let a = 2; a < e - 3; a++) {
    const l = a + 1, { se: c } = xw(t.slice(0, l)), { se: p } = xw(t.slice(l));
    i.push(c ** l * p ** (e - l) / r ** e);
  }
  const s = Math.min(...i), o = -Math.log(s);
  return {
    feats: n.map((a) => o > a ? 1 : 0),
    logLambda: o,
    t: i.indexOf(s) + 2
  };
}
function gie(t) {
  const e = t.length;
  if (e < 6)
    throw new Sb(qu.minLen6);
  const r = t.bestFit.rss(), n = [0, 0];
  if (r === 0)
    return { feats: n };
  const i = [], s = t.points.map((f) => f.x), o = t.points.map((f) => f.y), a = (f) => f.reduce((E, A) => E + A), l = (f, E) => a(f.map((A, x) => A * E[x])), c = [], p = [];
  for (let f = 2; f < e - 3; f++) {
    const E = s.slice(0, f + 1), A = o.slice(0, f + 1), x = a(E), g = a(A), v = l(E, A), k = a(E.map((le) => le ** 2)), S = v - x * g / (f + 1), R = k - x ** 2 / (f + 1), L = S / R, F = Vo(A) - L * Vo(E), z = s[f], j = F + L * z, ee = s.slice(f + 1), X = o.slice(f + 1), ie = a(ee), ce = a(X), ke = l(ee, X), ye = a(ee.map((le) => le ** 2)), Ce = ce - (t.length - (f + 1)) * j, Ie = ie - (t.length - (f + 1)) * z, Te = Ce / Ie, ue = ke / ie - Te * ye / ie, O = E.map((le) => F + L * le), N = a(E.map((le, te) => (A[te] - O[te]) ** 2)), Z = ee.map((le) => ue + Te * le), re = a(ee.map((le, te) => (X[te] - Z[te]) ** 2));
    i.push(N + re), c.push({ a1: F, b1: L, a2: ue, b2: Te }), p.push(O.concat(Z));
  }
  const h = Math.min(...i);
  let d, b = (r - h) / 2 / (h / (e - 4));
  b <= 0 && (b = 1e-3), b === 1 / 0 ? d = 0 : d = 1 - new cie(2, e - 4).cumulativeProbability(b);
  const m = i.indexOf(h) + 2, w = { rssMin: h, rssl: r, F: b, p: d, split: m, params: c[m - 2], yhats: p[m - 2] };
  return d < 0.1 && (n[0] = 1), d < 0.05 && (n[1] = 1), { feats: n, debug: w };
}
function mie(t) {
  const e = t.bestFit.residuals.map(Math.sign), { r, nminus: n, nplus: i } = e.reduce(
    (a, l, c) => (c && l !== e[c - 1] && a.r++, l || (l = 1), a[l === 1 ? "nplus" : "nminus"]++, a),
    { r: 1, nminus: 0, nplus: 0 }
  ), s = 2 * i * n / (i + n) + 1, o = Math.abs(Math.sqrt(
    2 * i * n * (2 * i * n - i - n) / (Math.pow(i + n, 2) * (i + n - 1))
  ));
  return { feats: [r < s - o / 2 ? 1 : r > s + o / 2 ? -1 : 0, r, s, o, Math.abs(r - s) / s] };
}
function yie(t) {
  const e = t.length;
  if (e > P7.length + 4)
    throw new Sb(qu.tooManyPoints);
  const r = t.bestFit.residuals, n = Math.sqrt(
    r.map((d) => d ** 2 / (e - 2)).reduce((d, b) => d + b)
  );
  if (n === 0)
    return [-1, 0];
  const i = t.points.map((d) => d.x), s = Vo(i), o = i.map((d) => (d - s) ** 2), a = o.reduce((d, b) => d + b), l = o.map((d) => n * Math.sqrt(1 - 1 / e - d / a)), c = r.map((d, b) => d / l[b]).map((d) => Math.abs(d)), p = Math.max(...c), h = P7[e - 4];
  return [p, c.filter((d) => d > h).length];
}
function bie(t) {
  const e = t.bestFit.rss(), r = t.points.at(-1).x - t.points[0].x, n = Math.sqrt(e / t.length) / r, i = Math.atan(t.bestFit.slope);
  return [n, n * Math.cos(i) ** 2];
}
class vie {
  /**
   * Compute non-standardized feature columns from examples.
   * @param examples - Training examples
   * @returns Feature columns
   */
  computeFeatures(e) {
    function r(i, s) {
      const o = i[0].length, a = {};
      for (let l = 0; l < o; l++)
        a[`${s}${l + 1}`] = [];
      for (const l of i)
        l.forEach((c, p) => a[`${s}${p + 1}`].push(c));
      return a;
    }
    const n = {
      absCorrCoeff: e.map((i) => die(i.data)),
      nPoints: e.map((i) => i.data.length),
      ...r(e.map((i) => bie(i.data)), "scaledS"),
      nPointsChart: e.map((i) => i.chartLength),
      chartPct: e.map((i) => (i.data.length - 1) / (i.chartLength - 1))
    };
    return e[0].data.length >= 6 && Object.assign(
      n,
      r(e.map((i) => fie(i.data).feats), "qTest"),
      r(e.map((i) => gie(i.data).feats), "fTest"),
      r(e.map((i) => mie(i.data).feats), "runsTest"),
      r(e.map((i) => yie(i.data)), "outlierTest")
    ), n;
  }
  /**
   * Standardize feature columns.
   * @param featCols - Non-standardized feature columns
   * @param featStats - Feature column statistics
   * @returns Standardized feature columns
   */
  standardizeFeatures(e, r) {
    const n = {};
    for (const [i, s] of Object.entries(e)) {
      const o = r[i];
      n[i] = o ? pie(s, o.mean, o.stdDev) : s;
    }
    return n;
  }
  /**
   * Assemble feature matrix from standardized feature columns.
   * @param stdFeatCols - Standardized feature columns.
   * @returns Feature matrix (array of example rows)
   */
  assembleMatrix(e) {
    const r = Object.values(e)[0].length, n = Gu(r, (i) => []);
    for (const [i, s] of Object.entries(e))
      s.forEach((o, a) => n[a].push(o));
    return n;
  }
  /**
   * Compute feature matrix from examples.
   * @param examples - Training examples
   * @param featStats - Feature column statistics
   * @returns Feature matrix (array of example rows)
   */
  computeMatrix(e, r) {
    const n = this.computeFeatures(e), i = this.standardizeFeatures(n, r);
    return this.assembleMatrix(i);
  }
}
const bN = {
  "188b757048e": {
    breaks: "breaks_JF_CM3",
    small: {
      model: {
        N: 216,
        D: 6,
        b: 1.0301052191704447,
        kernelType: "linear",
        w: [
          -0.3670377924881308,
          0.24109852608042484,
          0.10770417080350453,
          3.7309289892912494,
          -0.24351287768173968,
          0.1773538767010703
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6613098596026764,
          stdDev: 0.32645241503938466
        },
        nPoints: {
          mean: 4.027777777777778,
          stdDev: 0.79484775003546
        },
        scaledS1: {
          mean: 0.2738191427566398,
          stdDev: 0.31274618795081666
        },
        scaledS2: {
          mean: 0.16552447256379144,
          stdDev: 0.22401114065292482
        },
        nPointsChart: {
          mean: 18.88425925925926,
          stdDev: 11.50047652834366
        },
        chartPct: {
          mean: 0.24575562721992683,
          stdDev: 0.17658868716036033
        }
      }
    },
    big: {
      model: {
        N: 818,
        D: 18,
        b: -0.5949603608497636,
        kernelType: "linear",
        w: [
          -0.4977108970919176,
          0.7541270816821308,
          0.9144109510673445,
          1.6047203771838476,
          -1.4368172642074537,
          -0.21592712823176308,
          0.07644318713996778,
          0.014636523739875784,
          0.1763324579259402,
          1.106707575171747,
          -0.47385129596321995,
          0.45987873914033983,
          0.35112878139332787,
          -0.6236067182671058,
          0.9485075089484734,
          0.19163220544936868,
          0.20546829454342905,
          -0.06915930322456987
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6452237813470705,
          stdDev: 0.3240018443609284
        },
        nPoints: {
          mean: 14.583129584352077,
          stdDev: 8.99604477133496
        },
        scaledS1: {
          mean: 0.10594325137217282,
          stdDev: 0.09177436527475356
        },
        scaledS2: {
          mean: 0.08668479622616888,
          stdDev: 0.07415105573907281
        },
        nPointsChart: {
          mean: 27.0880195599022,
          stdDev: 12.696709863610126
        },
        chartPct: {
          mean: 0.5831555684741223,
          stdDev: 0.28777669079271473
        },
        runsTest2: {
          mean: 5.10757946210269,
          stdDev: 2.511304431521282
        },
        runsTest3: {
          mean: 8.050945471288665,
          stdDev: 4.446028922152818
        },
        runsTest4: {
          mean: 1.6812783091074126,
          stdDev: 0.5646901163167827
        },
        runsTest5: {
          mean: 0.337916669549109,
          stdDev: 0.20151780352623566
        },
        outlierTest1: {
          mean: 2.100035193879811,
          stdDev: 0.5296286424653459
        },
        outlierTest2: {
          mean: 0.05867970660146699,
          stdDev: 0.2351680408679939
        }
      }
    }
  },
  "18afd2f54c7": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3380856560371651,
        kernelType: "linear",
        w: [
          -0.756517811722315,
          0.37069999610745497,
          0.21673055797213336,
          1.1244975473636247,
          0.035519868943893806,
          0.6975781903311828
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6866332461949628,
          stdDev: 0.3229548134968895
        },
        nPoints: {
          mean: 4.069767441860465,
          stdDev: 0.8050959803624481
        },
        scaledS1: {
          mean: 0.03965686197121996,
          stdDev: 0.0338017466328698
        },
        scaledS2: {
          mean: 0.038745499336644146,
          stdDev: 0.033324943757710994
        },
        nPointsChart: {
          mean: 15.078488372093023,
          stdDev: 8.898337515306299
        },
        chartPct: {
          mean: 0.2979532652417984,
          stdDev: 0.1884678355817908
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.22042056305341218,
        kernelType: "linear",
        w: [
          -0.3280468854878086,
          -0.11665058369931192,
          -0.0022542536097451466,
          2.219103384778342,
          0.0342024760983941,
          0.4293989826596215,
          0.2975608661999607,
          -0.6077251584818741,
          0.4000527465309003,
          0.4042384593088002,
          0.001186586425212074,
          0.5190085928118862,
          -0.23537053975123523,
          0.0715945226988598,
          0.033154145420287044,
          -0.06347880606856209,
          0.1850990704458409,
          -0.001228864486559927
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6223429821764429,
          stdDev: 0.3110591999188207
        },
        nPoints: {
          mean: 13.731607629427794,
          stdDev: 8.370686093707965
        },
        scaledS1: {
          mean: 0.03544093688268208,
          stdDev: 0.026611386439376005
        },
        scaledS2: {
          mean: 0.03455363316854854,
          stdDev: 0.026077505679786228
        },
        nPointsChart: {
          mean: 23.768392370572208,
          stdDev: 11.730176258926388
        },
        chartPct: {
          mean: 0.6094307363719895,
          stdDev: 0.26692294365220165
        },
        runsTest2: {
          mean: 5.151226158038147,
          stdDev: 2.6793673522936645
        },
        runsTest3: {
          mean: 7.583581141916727,
          stdDev: 4.081715945141601
        },
        runsTest4: {
          mean: 1.6148756585462214,
          stdDev: 0.5411094264297078
        },
        runsTest5: {
          mean: 0.3153327018423893,
          stdDev: 0.19626169453505887
        },
        outlierTest1: {
          mean: 2.118980108638941,
          stdDev: 0.6300714899329056
        },
        outlierTest2: {
          mean: 0.09128065395095368,
          stdDev: 0.2882041970351209
        }
      }
    }
  },
  "18b1686ceb4": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3309416402875685,
        kernelType: "linear",
        w: [
          -0.20000267112106263,
          0.42809635761540643,
          0.46656203058966117,
          1.841671684760453,
          -0.6434524674952959,
          0.49143545422517687
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6764124363859395,
          stdDev: 0.3236057116921364
        },
        nPoints: {
          mean: 4.116279069767442,
          stdDev: 0.8069465847859293
        },
        scaledS1: {
          mean: 0.1858035195675879,
          stdDev: 0.21428670248595916
        },
        scaledS2: {
          mean: 0.12950420831848175,
          stdDev: 0.15751874574784924
        },
        nPointsChart: {
          mean: 15.761627906976743,
          stdDev: 9.783137376835176
        },
        chartPct: {
          mean: 0.300526358561615,
          stdDev: 0.1927265795559554
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.33318046701370874,
        kernelType: "linear",
        w: [
          0.032315062605570585,
          0.48106580584263436,
          -1.1047252909009055,
          3.7368759283052406,
          -0.6183759573768267,
          0.6939892440180402,
          0.3861182101902436,
          -0.4528094207813589,
          0.19685209857044894,
          0.5317134144006395,
          -0.3268861531591498,
          0.5416909853776097,
          0.11204746654248579,
          -0.042886524593192116,
          0.04725504450122949,
          0.09451185559860642,
          -0.011544267888957445,
          0.17029310632188632
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6349627683741144,
          stdDev: 0.3047569778403939
        },
        nPoints: {
          mean: 13.728882833787466,
          stdDev: 8.419998905023999
        },
        scaledS1: {
          mean: 0.07039535118699393,
          stdDev: 0.06922873611482698
        },
        scaledS2: {
          mean: 0.06255041459772398,
          stdDev: 0.05952611432033109
        },
        nPointsChart: {
          mean: 23.705722070844686,
          stdDev: 11.739000887557054
        },
        chartPct: {
          mean: 0.6095266522529739,
          stdDev: 0.26470522117524425
        },
        runsTest2: {
          mean: 5.129427792915531,
          stdDev: 2.7706078547777717
        },
        runsTest3: {
          mean: 7.603857452118007,
          stdDev: 4.140301994340143
        },
        runsTest4: {
          mean: 1.6191709447588931,
          stdDev: 0.5436847808406448
        },
        runsTest5: {
          mean: 0.32151695128382807,
          stdDev: 0.19159541197646354
        },
        outlierTest1: {
          mean: 2.116230031599242,
          stdDev: 0.5977792703826863
        },
        outlierTest2: {
          mean: 0.09400544959128065,
          stdDev: 0.29203530028780983
        }
      }
    }
  }
};
function wie() {
  return Object.keys(bN).sort();
}
function xie(t) {
  return bN[t ?? wie().at(-1)];
}
var Eie = Object.defineProperty, Sie = (t, e, r) => e in t ? Eie(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Aie = (t, e, r) => (Sie(t, e + "", r), r);
const kie = 0.2;
function vN(t, e, r = kie) {
  if (t.length === 3)
    return 1;
  const n = t.points.at(-1).x - t.points[0].x, i = (t.points.at(-1).y - t.points[0].y) / n, s = Math.atan(i), o = Math.cos(s), a = t.points.map((f) => f.y), l = t.slice(1, t.length - 1);
  let c = a.indexOf(Math.min(...a)) - 1;
  (c < 0 || c === l.length) && (c = null);
  let p = a.indexOf(Math.max(...a)) - 1;
  (p < 0 || p === l.length) && (p = null);
  const h = [], d = l.points.map((f) => {
    const E = f.x - t.points[0].x, A = Math.abs(f.y - (i * E + t.points[0].y));
    return h.push(A), A * o;
  }), b = d.indexOf(Math.max(...d));
  let m = !1;
  c !== null && Math.abs(c - b) / (e - 1) <= r && (m = h[c] > d[b]);
  let w = !1;
  return p !== null && Math.abs(p - b) / (e - 1) <= r && (w = h[p] > d[b]), w ? p + 1 : m ? c + 1 : b + 1;
}
class _ie {
  /**
   * @param model - (Optional) ID of split model to use.
   */
  constructor(e = void 0) {
    Aie(this, "models");
    const r = xie(e);
    if (r)
      this.models = {
        small: {
          svm: new C7(),
          stats: r.small.stats
        },
        big: {
          svm: new C7(),
          stats: r.big.stats
        }
      };
    else
      throw new Error(`unknown model ID: '${e}'`);
    this.models.small.svm.fromJSON(r.small.model), this.models.big.svm.fromJSON(r.big.model);
  }
  /**
   * Predict whether a sequence should be split.
   * @param seq - Data points of sequence to evaluate. 
   * @param chartLength - Number of data points in the complete chart
   * of which 'seq' is a part.
   * @returns Whether the sequence should be split.
   */
  shouldSplit(e, r) {
    if (e.length < 3 || e.points.every((a) => a.y === e.points[0].y))
      return !1;
    const n = new vie(), i = e.length < 6 ? "small" : "big", [s] = n.computeMatrix(
      [{ data: e, chartLength: r }],
      this.models[i].stats
    ), [o] = this.models[i].svm.predict([s]);
    return o === 1;
  }
  /**
   * Predict trend sequences a series should be split into.
   * @param series - Data points of series to split.
   * @param yAxis - Displayed chart y-axis bounds; defaults to extreme values of data
   * @param pipCloseness - Max distance (as % of chart length) a sequence-local 
   * min/max point can be from the PIP to be a possible split point.
   * @returns List of index pairs denoting the start and end of each sequence.
   * @remarks
   * As in slices, the end index in a pair is not included in the set of indices
   * included in a sequence.
   * NB: Adjacent sequences share the point where they were split.
   * E.g., a hypothetical set of sequences might look like:
   *   [\{start: 0, end: 5\}, \{start: 4, end: 7\}, \{start: 6, end: 10\}]
   * where the first two sequences share the point at index 4, and the last
   * two share the point at index 6.
   */
  getSequences(e, r, n) {
    const i = e.length;
    e = e.project(void 0, r);
    const s = [], o = (a, l) => {
      const c = e.slice(a, l);
      if (this.shouldSplit(c, e.length)) {
        const p = vN(c, e.length, n) + a;
        o(a, p + 1), o(p, l);
      } else
        s.push({ start: a, end: l });
    };
    return o(0, i), s;
  }
}
const Cie = 6, Iie = 5;
function Pie(t) {
  const e = Vo(t), r = t.map((n) => n - e);
  return Math.sqrt(r.reduce((n, i) => n + i ** 2, 0));
}
function Mm(t) {
  return Math.sign(t);
}
function Rie(t, e = Iie, r = e) {
  const n = t.length;
  if (n < 3) {
    let i = (t.points[1].y - t.points[0].y) / (t.points[1].x - t.points[0].x);
    const s = Hf(i);
    return Math.abs(s) < r && (i = 0), { classes: [Mm(i)], slope: i, angle: s };
  } else {
    const i = t.bestFit.rss();
    if (n < Cie) {
      let h = Mm(t.bestFit.slope);
      return Math.abs(t.bestFit.xAngle) < r && (h = 0), { classes: [h], slope: t.bestFit.slope, angle: t.bestFit.xAngle };
    }
    const s = t.points.map((h) => h.x), o = Math.sqrt(i / (n - 2)) / Pie(s), a = 1 - 0.05 / 2, l = new lie(n - 2).invCumulativeProbability(a) * o, c = [t.bestFit.slope - l, t.bestFit.slope + l], p = [];
    return Math.sign(c[0]) !== Math.sign(c[1]) ? (p.push(0), Math.abs(t.bestFit.xAngle) >= e && p.push(Mm(t.bestFit.slope))) : (p.push(Mm(t.bestFit.slope)), Math.abs(t.bestFit.xAngle) < e && t.bestFit.slope && p.push(0)), { classes: p, slope: t.bestFit.slope, angle: t.bestFit.xAngle, moe: l };
  }
}
function Oie(t, e) {
  return t.size !== e.size ? !1 : Array.from(t).every((r) => e.has(r));
}
function Tie(t) {
  const e = [];
  for (let r = 0; r < t.length; r++)
    for (let n = r + 1; n < t.length; n++)
      e.push([t[r], t[n]]);
  return e;
}
function Lie(t, e) {
  return {
    start: Math.min(t.start, e.start),
    end: Math.max(t.end, e.end)
  };
}
function Mie(t, e) {
  return t.start === e.start && t.end === e.end;
}
function Nie(t, e) {
  return t.start >= e.start && t.start <= e.end || e.start >= t.start && e.start <= e.end;
}
function Die(t, e) {
  const r = [t.points[0].x, ...e, t.points.at(-1).x], n = [];
  for (let i = 1; i < r.length; i++)
    n.push({ start: r[i - 1], end: r[i] });
  return n;
}
let zx = class ul {
  /**
   * Do not use; call TrackingGroup.getGroups() to create tracking groups.
   * @internal
   */
  constructor(e, r, n) {
    this.keys = e, this.interval = r, this.seriesByKey = n;
  }
  /**
   * Compute tracking groups for the set of series of a chart.
   * @param allSeries - All series of a chart.
   * @param minSize - Value between 0 and 1 determining the minimum size of a 
   * tracking group (as a percentage of chart width).
   * @param closeness - Value between 0 and 1 determining the degree of tracking
   * closeness required for lines to pair/group.
   * @returns The tracking groups.
   */
  static getGroups(e, r = 0.25, n = 0.9) {
    const i = /* @__PURE__ */ new Map();
    e.forEach((p) => i.set(p.key, p));
    const s = Tie(e).map(([p, h]) => [p.key, h.key]);
    let o = [];
    const a = Math.min(...e.map((p) => p.yBounds().start)), l = {
      start: 0,
      end: Math.max(...e.map((p) => p.yBounds().end)) - a
    };
    for (const p of s) {
      const h = new Vie(
        i.get(p[0]),
        i.get(p[1]),
        0.5
      ).getRelativeTrajectories(l).filter((d) => d.type === "tracking" && d.interval.end - d.interval.start >= e[0].xRange() * r && d.degree >= n).map((d) => ({ keyPair: p, interval: d.interval }));
      o = o.concat(h);
    }
    let c = ul.createGroupsFromPairs(o, i);
    return c = ul.normalizeGroups(c), c.reverse(), c;
  }
  static createGroupsFromPairs(e, r) {
    const n = [];
    function i(l) {
      return n.findIndex((c) => c.start === l.start && c.end === l.end);
    }
    for (const l of e)
      i(l.interval) === -1 && n.push(l.interval);
    const s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    for (const { keyPair: l, interval: c } of e) {
      const p = i(c);
      let h = s.get(p);
      h || (h = [], s.set(p, h)), h.push(l);
      let d = o.get(p);
      d || (d = [], o.set(p, d));
      for (const b of l)
        d.includes(b) || d.push(b);
    }
    const a = [];
    for (const [l, c] of o) {
      const p = s.get(l);
      let h = [];
      for (const d of p) {
        const b = h.find((w) => w.has(d[0])), m = h.find((w) => w.has(d[1]));
        !b && !m ? h.push(new Set(d)) : b && m && b !== m ? (m.forEach((w) => b.add(w)), h = h.filter((w) => w !== m)) : b ? b.add(d[1]) : m.add(d[0]);
      }
      for (const d of h)
        a.push(new ul(d, n[l], r));
    }
    return a;
  }
  /**
   * Supplement smaller tracking groups contained entirely within larger ones.
   * Line groups are updated in-place.
   * @internal
   */
  static suppleteGroups(e) {
    let r = !1;
    e.sort((n, i) => {
      const s = n.interval.end - n.interval.start, o = i.interval.end - i.interval.start;
      return Math.sign(o - s);
    });
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      for (let s = n + 1; s < e.length; s++) {
        const o = e[s];
        if (!(i.interval.start > o.interval.start || i.interval.end < o.interval.end))
          if (i.interval.end - i.interval.start === o.interval.end - o.interval.start) {
            const a = i.supplete(o), l = o.supplete(i);
            r || (r = a || l);
          } else {
            const a = i.supplete(o);
            r || (r = a);
          }
      }
    }
    return r;
  }
  /**
   * Supplete group 'other' in-place.
   */
  supplete(e) {
    let r = !1;
    if (Array.from(this.keys).some((n) => e.keys.has(n)))
      for (const n of this.keys)
        e.keys.has(n) || (e.keys.add(n), r = !0);
    return r;
  }
  /**
   * Create a new array of tracking groups by merging any groups
   * that overlap (or abut) and consist of the same set of lines.
   * @param groups - Original array of tracking groups
   * @returns New array of tracking groups
   * @internal
   */
  static mergeGroups(e) {
    if (e.length) {
      let r;
      do {
        r = [];
        const n = [];
        e:
          for (let i = 0; i < e.length; i++) {
            const s = e[i];
            for (let o = i + 1; o < e.length; o++) {
              const a = e[o];
              if (Nie(s.interval, a.interval) && Oie(s.keys, a.keys)) {
                r.push(new ul(
                  s.keys,
                  Lie(s.interval, a.interval),
                  s.seriesByKey
                )), n.push(s, a);
                break e;
              }
            }
          }
        e = e.filter((i) => !n.includes(i)).concat(r);
      } while (r.length);
    }
    return e;
  }
  /**
   * Iteratively supplete and merge a set of tracking groups until
   * we can't supplete any group further.
   * @internal
   */
  static normalizeGroups(e) {
    let r = ul.suppleteGroups(e);
    do
      e = ul.mergeGroups(e), r = ul.suppleteGroups(e);
    while (r);
    return e;
  }
  /**
   * Get series not included in the tracking group.
   * @returns The outlier line keys relative to the group.
   */
  outliers() {
    return Array.from(this.seriesByKey.keys()).filter((e) => !this.keys.has(e)).sort();
  }
  /**
   * Compute the line of averaged values from the lines in the tracking group.
   * @returns The average line.
   */
  averageLine() {
    const e = Array.from(this.keys).map((n) => this.seriesByKey.get(n).extractSection(this.interval)), r = e.length;
    return new u0(Gu(e[0].length, (n) => ({
      x: e[0].points[n].x,
      y: Gu(r, (i) => e[i].points[n].y).reduce((i, s) => i + s) / r
    })));
  }
}, $ie = class wN {
  /**
   * Do not use; call TrackingZone.getZones() to create tracking zones.
   */
  constructor(e, r) {
    this.trackingGroups = e, this.interval = r;
  }
  /**
   * Compute tracking zones from a set of tracking groups.
   * @param trackingGroups - Tracking groups of the chart.
   * @returns The list of tracking zones.
   * @public
   */
  static getZones(e) {
    const r = /* @__PURE__ */ new Set();
    e.forEach((o) => {
      r.add(o.interval.start), r.add(o.interval.end);
    });
    const n = Array.from(r).sort().slice(1, -1), i = Die(
      e[0].seriesByKey.values().next().value,
      n
    ), s = [];
    for (const o of i) {
      let a = !1;
      for (const l of e)
        if (l.interval.start <= o.start && l.interval.end >= o.end) {
          const c = s.find((h) => Mie(o, h.interval)), p = new zx(new Set(l.keys), o, l.seriesByKey);
          c ? c.trackingGroups.push(p) : (s.push(new wN([p], o)), a = !0);
        }
      if (a) {
        const l = s.at(-1);
        l.trackingGroups = zx.normalizeGroups(l.trackingGroups);
      }
    }
    return s;
  }
};
const jie = 2, Vx = -1;
function Bie(t, e, r) {
  const n = r.map((i) => Math.abs(e - i));
  return n.sort((i, s) => Math.sign(i - s)), n[t];
}
function Fie(t, e, r, n) {
  let i = -1;
  const s = /* @__PURE__ */ new Map();
  for (const o of t) {
    if (s.get(o) !== void 0)
      continue;
    const a = R7(t, e, o, r);
    if (a.length < n) {
      s.set(o, Vx);
      continue;
    }
    i++, s.set(o, i);
    const l = new Set(Array.from(a).filter((c) => c !== o));
    for (const c of l) {
      if (s.get(c) === Vx && s.set(c, i), s.get(c) !== void 0)
        continue;
      s.set(c, i);
      const p = R7(t, e, c, r);
      if (p.length >= n)
        for (const h of p)
          l.add(h);
    }
  }
  return s;
}
function R7(t, e, r, n) {
  return t.filter((i) => e(r, i) <= n);
}
class zie {
  /**
   * @param allSeries - All series of a chart.
   * @param minPts - Optional min neighbors (including itself) a point must have
   * to be considered a core point.
   */
  constructor(e, r = jie) {
    this.clusters = [], this.noise = [];
    const n = e.map((h) => Vo(h.points.map((d) => d.y))), i = n.map((h) => Bie(1, h, n)).toSorted((h, d) => -Math.sign(h - d)), s = u0.fromValues(i), o = vN(s, s.length), a = Math.min(...e.map((h) => h.yBounds().start)), l = (Math.max(...e.map((h) => h.yBounds().end)) - a) / 10, c = Math.max(i[o], l), p = Fie(n, (h, d) => Math.abs(h - d), c, r);
    for (let h = 0; h < n.length; h++) {
      const d = p.get(n[h]);
      if (d === Vx)
        this.noise.push(e[h]);
      else {
        let b = this.clusters[d];
        b || (this.clusters[d] = b = []), b.push(e[h]);
      }
    }
  }
}
class Vie extends fN {
  constructor(e, r, n) {
    super(e, r, n), this.differentialLine = this.computeDifferentialLine();
  }
  computeDifferentialLine() {
    let e = new u0(this.series1.points.map(
      (n, i) => ({ x: n.x, y: Math.abs(n.y - this.series2.points[i].y) })
    ));
    const r = this.intersectingSegPairs.filter((n) => n.intersection !== "Overlap").filter((n) => !n.intersection.atRecord).map((n) => n.intersection.crosspoint);
    for (const n of r) {
      const i = e.points.findLastIndex((o) => n.x > o.x), s = Array.from(e.points);
      s.splice(i + 1, 0, { x: n.x, y: 0 }), e = new u0(s);
    }
    return e;
  }
  /**
   * 
   * @param yAxis - Interval from 0 to the y-range of the chart, representing
   * the minimum and maximum possible y-value differences between records of two series.
   * @returns 
   */
  getRelativeTrajectories(e) {
    const r = [], n = new _ie().getSequences(this.differentialLine, e), i = this.differentialLine.project(void 0, e), s = n.map(
      ({ start: a, end: l }) => Rie(i.slice(a, l))
    );
    for (let a = 0; a < n.length; a++) {
      const l = s[a];
      if (l.classes.length === 2 && Math.abs(l.moe) < Math.abs(l.slope)) {
        const p = l.classes.indexOf(0);
        Math.abs(l.angle) < 5 ? l.classes.splice(1 - p, 1) : l.classes.splice(p, 1);
      }
      const c = {
        start: this.differentialLine.points[n[a].start].x,
        end: this.differentialLine.points[n[a].end - 1].x
      };
      l.classes[0] === 0 ? r.push({
        interval: c,
        type: "tracking",
        degree: 1 - Nx(
          this.differentialLine.slice(n[a].start, n[a].end).points.map((p) => p.y)
        ) / e.end
      }) : r.push({
        interval: c,
        type: l.classes[0] === 1 ? "diverging" : "converging",
        degree: Math.abs(l.angle / 90)
      });
    }
    const o = [];
    if (r.length) {
      o.push(r[0]);
      for (let a = 1; a < r.length; a++)
        r[a].type === r[a - 1].type ? o.at(-1).interval.end = r[a].interval.end : o.push(r[a]);
    }
    return o;
  }
}
let Uie = class extends gN {
  constructor(e, r, n, i) {
    super(e, r, n, i);
    const s = zx.getGroups(e, void 0, 0.9);
    this.trackingGroups = s.map((a) => this.generateTrackingGroupMetadata(a)), s.length && (this.trackingZones = $ie.getZones(s).map((a) => this.generateTrackingZoneMetadata(a)));
    const o = new zie(e);
    this.clusters = o.clusters.map((a) => a.map((l) => l.key)), this.clusterOutliers = o.noise.map((a) => a.key);
  }
  generateTrackingGroupMetadata(e) {
    return {
      keys: Array.from(e.keys),
      outliers: e.outliers(),
      valueInterval: [e.interval.start, e.interval.end],
      averageLine: e.averageLine().points.map((r) => [r.x, r.y])
    };
  }
  generateTrackingZoneMetadata(e) {
    return {
      groups: e.trackingGroups.map((r) => this.generateTrackingGroupMetadata(r)),
      valueInterval: [e.interval.start, e.interval.end]
    };
  }
};
var Hie = /* @__PURE__ */ ((t) => (t[t.NONE = 0] = "NONE", t[t.SOME = 1] = "SOME", t[t.MOST = 2] = "MOST", t[t.ALL = 3] = "ALL", t))(Hie || {});
let xN = 2;
function eIe(t) {
  xN = t;
}
class Gie {
  constructor(e, r) {
    this.name = e, this.level = r;
  }
  /**
   * Log an info message. Only prints if level is ALL.
   * @param data - The data to log.
   */
  info(...e) {
    this.level === 3 && console.log(`[${this.name}]`, ...e);
  }
  /**
   * Log a warning message. Prints if level is MOST or ALL.
   * @param data - The data to log.
   */
  warn(...e) {
    this.level >= 2 && console.warn(`[${this.name}]`, ...e);
  }
  /**
   * Log an error message. Prints if level is SOME, MOST, or ALL.
   * @param data - The data to log.
   */
  error(...e) {
    this.level >= 1 && console.error(`[${this.name}]`, ...e);
  }
}
function qt(t) {
  return new Gie(t, xN);
}
function Wie(t) {
  return typeof t == "function" ? t() : t;
}
const $2 = class $2 extends Event {
  /**
   * @param  {string} key of the state that has changed
   * @param  {unknown} value for the changed key
   */
  constructor(e, r, n) {
    super($2.eventName, {
      cancelable: !1
    }), this.key = e, this.value = r, this.state = n;
  }
};
$2.eventName = "lit-state-changed";
let Qu = $2;
const qie = (t, e) => e !== t && (e === e || t === t), H9 = class H9 extends EventTarget {
  static initPropertyMap() {
    this.propertyMap || (this.propertyMap = /* @__PURE__ */ new Map());
  }
  get propertyMap() {
    return this.constructor.propertyMap;
  }
  get stateValue() {
    return Object.fromEntries([...this.propertyMap].map(([e]) => [e, this[e]]));
  }
  constructor() {
    super(), this.hookMap = /* @__PURE__ */ new Map(), this.constructor.finalize(), this.propertyMap && [...this.propertyMap].forEach(([e, r]) => {
      if (r.initialValue !== void 0) {
        const n = Wie(r.initialValue);
        this[e] = n, r.value = n;
      }
    });
  }
  static finalize() {
    if (this.finalized)
      return !1;
    this.finalized = !0;
    const e = Object.keys(this.properties || {});
    for (const r of e)
      this.createProperty(r, this.properties[r]);
    return !0;
  }
  static createProperty(e, r) {
    this.finalize();
    const n = typeof e == "symbol" ? Symbol() : `__${e}`, i = this.getPropertyDescriptor(String(e), n, r);
    Object.defineProperty(this.prototype, e, i);
  }
  static getPropertyDescriptor(e, r, n) {
    const i = (n == null ? void 0 : n.hasChanged) || qie;
    return {
      get() {
        return this[r];
      },
      set(s) {
        const o = this[e];
        this[r] = s, i(s, o) === !0 && this.dispatchStateEvent(e, s, this);
      },
      configurable: !0,
      enumerable: !0
    };
  }
  /**
   * Reset the state to its original values, skipping
   * properties marked as skipReset
   */
  reset() {
    this.hookMap.forEach((e) => e.reset()), [...this.propertyMap].filter(([e, r]) => !(r.skipReset === !0 || r.resetValue === void 0)).forEach(([e, r]) => {
      this[e] = r.resetValue;
    });
  }
  /**
   * subscribe to state change event. The callback will be called anytime
   * a state property change if `nameOrNames` is undefined, or only for matching
   * property values specified by `nameOrNames`
   * @param callback the callback function to call
   * @param nameOrNames
   * @returns a unsubscribe function.
   */
  subscribe(e, r, n) {
    r && !Array.isArray(r) && (r = [r]);
    const i = (s) => {
      (!r || r.includes(s.key)) && e(s.key, s.value, this);
    };
    return this.addEventListener(Qu.eventName, i, n), () => this.removeEventListener(Qu.eventName, i);
  }
  dispatchStateEvent(e, r, n) {
    this.dispatchEvent(new Qu(e, r, n));
  }
};
H9.finalized = !1;
let Ay = H9;
class A5 {
  constructor(e, r, n) {
    this.host = e, this.state = r, this.callback = n || (() => this.host.requestUpdate()), this.host.addController(this);
  }
  dispose() {
    this.state.removeEventListener(Qu.eventName, this.callback);
  }
  hostConnected() {
    this.state.addEventListener(Qu.eventName, this.callback), this.callback();
  }
  hostDisconnected() {
    this.dispose();
  }
}
function Ar(t) {
  return (e, r) => {
    if (Object.getOwnPropertyDescriptor(e, r))
      throw new Error("@property must be called before all state decorators");
    const n = e.constructor;
    n.initPropertyMap();
    const i = e.hasOwnProperty(r);
    return n.propertyMap.set(r, {
      ...t,
      initialValue: t == null ? void 0 : t.value,
      resetValue: t == null ? void 0 : t.value
    }), n.createProperty(r, t), i ? Object.getOwnPropertyDescriptor(e, r) : void 0;
  };
}
new URL(location.href);
class ts extends $r {
  get store() {
    return this._store;
  }
  set store(e) {
    this._store = e, this._storeState = new A5(this, e);
  }
  extractStyles(e) {
    const r = this.shadowRoot.adoptedStyleSheets, n = [];
    for (const i of r) {
      const s = i.cssRules;
      for (let o = 0; o < s.length; o++) {
        const a = s.item(o);
        n.push(a.cssText.replace(/^:host/, `#${e}`));
      }
    }
    return n.join(`
`);
  }
}
class Qie {
  constructor(e) {
    this._store = e, this._voice = null, this._lang = "en-US", this._rate = 1, this._volume = 1, this._pitch = 1, this._utterance = null, this._highlightIndex = null, this._speakingCount = 0, this.log = qt("Voicing"), this._voice = window.speechSynthesis, this._voice || this.log.warn("Speech Synthesis unsupported");
  }
  get highlightIndex() {
    return this._highlightIndex;
  }
  get isSpeaking() {
    return this._speakingCount > 0;
  }
  speak(e, r, n = 0) {
    if (this._voice) {
      this.shutUp(), this._utterance = this.speakText(e), this._speakingCount++;
      const i = (s) => r.findIndex((o) => s >= o.start && s < o.end);
      this._utterance.onboundary = (s) => {
        const o = i(s.charIndex);
        if (o === -1) {
          this._highlightIndex = null;
          return;
        }
        this._highlightIndex = o;
        const a = r[this._highlightIndex];
        this._store.paraChart.postNotice("utteranceBoundary", a);
      }, this._utterance.onend = (s) => {
        this._store.paraChart.postNotice("utteranceEnd", null), this._speakingCount--;
      };
    }
  }
  speakText(e) {
    return this._utterance = new SpeechSynthesisUtterance(e), this._utterance.rate = this._rate, this._utterance.lang = this._lang, this._utterance.pitch = this._pitch, this._utterance.volume = this._volume, this._voice.speak(this._utterance), this._utterance;
  }
  pause() {
    var e;
    (e = this._voice) == null || e.pause();
  }
  resume() {
    var e;
    (e = this._voice) == null || e.resume();
  }
  togglePaused() {
    this.isPaused ? this.resume() : this.pause();
  }
  get isPaused() {
    var e;
    return (e = this._voice) == null ? void 0 : e.paused;
  }
  shutUp() {
    this._voice && this._voice.speaking && (this._voice.cancel(), this._highlightIndex = null);
  }
  get lang() {
    return this._lang;
  }
  set lang(e) {
    this._lang = e;
  }
  get rate() {
    return this._rate;
  }
  set rate(e) {
    this._rate = e;
  }
  get volume() {
    return this._volume;
  }
  set volume(e) {
    this._volume = e;
  }
  get pitch() {
    return this._pitch;
  }
  set pitch(e) {
    this._pitch = e;
  }
}
const k5 = Nt`
  :host,
  :root {
    --axis-line-color: hsl(0, 0%, 0%);
    --label-color: hsl(0, 0%, 0%);
    --tick-grid-color: hsl(270, 50%, 50%);
    --background-color: white;
    --theme-color: var(--fizz-theme-color, purple);
    --theme-color-light: var(--fizz-theme-color-light, hsl(275.4, 100%, 88%));
    --theme-contrast-color: white;
    --fizz-theme-color: var(--paracharts-theme-color, navy);
    --fizz-theme-color-light: var(--paracharts-theme-color-light, hsl(210.5, 100%, 88%));
    /*--visited-color: red;*/
    --selected-color: var(--label-color);
    --datapoint-centroid: 50% 50%;
    --focus-animation: all 0.5s ease-in-out;
    --chart-cursor: pointer;
    --data-cursor: cell;

    /* default color palette */
    --color-palette-series-0: hsl(225, 30%, 52%);
    --color-palette-series-1: hsl(12, 69%, 35%);
    --color-palette-series-2: hsl(75, 43%, 45%);
    --color-palette-series-3: hsl(40, 100%, 49%);
    --color-palette-series-4: hsl(215, 37%, 66%);
    --color-palette-series-5: hsl(63, 100%, 23%);
    --color-palette-series-6: hsl(34, 57%, 46%);
    --color-palette-series-7: hsl(51, 56%, 64%);
    --color-palette-series-8: hsl(253, 26%, 43%);
    --color-palette-series-9: hsl(85, 65%, 36%);

    --focus-shadow-color: gray;
    --focus-shadow: drop-shadow(0px 0px 4px var(--focus-shadow-color));
  }

  .hidden { display: none !important; }

  /* https://kittygiraudel.com/snippets/sr-only-class/ */
  .sr-only {
    border: 0 !important;
    clip: rect(1px, 1px, 1px, 1px) !important;
    -webkit-clip-path: inset(50%) !important;
    clip-path: inset(50%) !important;
    height: 1px !important;
    overflow: hidden !important;
    margin: -1px !important;
    padding: 0 !important;
    position: absolute !important;
    width: 1px !important;
    white-space: nowrap !important;
  }

  * {
    font-family: "Trebuchet MS", Helvetica, sans-serif;
  }
  #y-axis-line {
    fill: none;
    stroke: var(--axis-line-color);
    stroke-width: 2px;
    stroke-linecap: round;
  }
  #x-axis-line {
    fill: none;
    stroke: var(--axis-line-color);
    opacity: 1;
    stroke-width: 2px;
    stroke-linecap: round;
  }
  .chart-title {
    font-size: 1.25rem;
  }
  /*.chart-title .middle {
    text-anchor: middle;
  }
  .chart-title .end {
    text-anchor: end;
  }*/
  .label {
    display: block;
    fill: var(--label-color);
  }
  .axis-title {
    text-anchor: middle;
  }
  .tick-label {
    fill: var(--label-color);
  }
  /*.tick-label.horiz {
    text-anchor: middle;
  }
  .tick-label.horiz.rotated {
    text-anchor: end;
  }
  .tick-label.horiz.rotated.north {
    text-anchor: start;
  }
  .tick-label.vert {
    text-anchor: end;
  }
  .tick-label.vert.east {
    text-anchor: start;
  }*/
  .tickmark-y {
    opacity: 0.2;
  }
  .tickmark-y-0 {
    fill: var(--tick-grid-color);
    stroke: var(--tick-grid-color);
    opacity: 1;
    stroke-width: 2px;
    stroke-linecap: round;
  }
  .tick-group-y:hover, .tick-group-y:hover .tickmark-y {
    font-weight: bold;
    opacity: 1;
  }
  .tickmark-x {
    opacity: 0.2;
  }
  .tickmark-x-0 {
    fill: var(--tick-grid-color);
    stroke: var(--tick-grid-color);
    opacity: 1;
    stroke-width: 2px;
    stroke-linecap: round;
  }
  .tick-group-x:hover, .tick-group-x:hover .tickmark_x {
    font-weight: bold;
    opacity: 1;
  }
  rect#data-backdrop {
    stroke: none;
    fill: none;
    pointer-events: all;
  }
  .stack {
    stroke-width: 0;
  }
  .bar:hover, .bar:focus {
    fill: hsl(270, 50%, 65%);
    outline: 2px auto -webkit-focus-ring-color;
  }
  .datapoint_background {
    fill: none;
    stroke: none;
    pointer-events: all;
    outline: none;
  }
  .datapoint_background:hover,
  .datapoint_background:focus {
    outline: 2px auto -webkit-focus-ring-color;
    box-shadow: none;
  }
  .data-line {
    fill: none;
    /*stroke-width: 3px;*/
    stroke-linecap: round;
  }
  .data_area {
    stroke: hsl(270, 50%, 50%);
    stroke-width: 3px;
    stroke-linecap: round;
    fill: none;
  }
  .data_area_background {
    stroke: none;
    fill: hsl(270, 50%, 50%);
    fill-opacity: 0.8;
  }
  .trendline {
    stroke: red;
    stroke-width: 3px;
    fill: none;
  }
  .center_label > tspan.subtext {
    font-size: 2rem;
    text-anchor: middle;
  }
  /*g.datapoint {
    transform-origin: var(--datapoint-centroid);
  }*/
  g.datapoint g.datapoint_popup rect {
    fill: hsl(0, 0%, 25%);
  }
  g.datapoint g.datapoint_popup text {
    fill: white;
    font-size: 1rem;
    text-anchor: middle;
  }
  g.datapoint g.datapoint_popup {
    stroke: none;
    opacity: 0.0;
    transition: opacity 0.3s ease-in-out;
  }
  g.datapoint:focus g.datapoint_popup, g.datapoint:hover g.datapoint_popup {
    opacity: 1.0;
    transition: opacity 0.3s ease-in-out;
  }
  g.datapoint g.datapoint_popup .desc {
    opacity: 0.0;
  }
  g.datapoint:focus g.datapoint_popup .desc, g.datapoint:hover g.datapoint_popup .desc {
    opacity: 1.0;
    transition: opacity 0.3s ease-in-out 2s;
  }
  g.datapoint.visited {
    fill: var(--visited-color, red);
    stroke: var(--visited-color, red);
    transform-box: fill-box;
/*    transition: var(--focus-animation); */
  }
  g.datapoint.visited:focus {
    /*outline: none;
    box-shadow: none;*/
    transition: var(--focus-animation);
    filter: var(--focus-shadow);
    /*animation: pulse-animation 2s infinite;*/
  }

  [data-charttype="stepline"] g.datapoint.visited {
    fill: var(--visited-color, red);
    stroke: var(--visited-color, red);
    transform: none;
/*    transition: var(--focus-animation); */
  }

  /* use#visited-mark {
    fill: inherit;
    stroke: inherit;
    transition: inherit;
  } */
  use.visited-mark {
    pointer-events: none;
  }
  @keyframes pulse-animation {
    0% {
      filter: drop-shadow(0px 0px 0px gray);
    }
    100% {
      filter: drop-shadow(0px 0px 12px gray);
    }
  }
  /*[data-charttype="line"] g.datapoint.visited {
    transform: scale(1.5);
  }
  [data-charttype="bar"] g.datapoint.visited {
    transform: scaleX(1.15);
  }*/
  .selected-datapoint-marker {
    fill: transparent;
    stroke: var(--selected-color);
    stroke-width: 3px;
    /*opacity: 0.5;*/
    pointer-events: none;
    stroke-linejoin: round;
  }
  .symbol {
    /*stroke-width: 2;*/
    stroke-linejoin: round;
  }
  .symbol.outline {
    fill: white;
  }
  .slice path {
    stroke: none;
    /*opacity: 0.5;*/
  }
  .slice text {
    fill: black;
    stroke: black;
    text-anchor: middle;
  }

  :fullscreen,
  ::backdrop {
    background-color: var(--background-color);
  }

  /* COLOR PALETTES */

  .theme-diva {
    --color-palette-series-0: hsl(225, 30%, 52%);
    --color-palette-series-1: hsl(12, 69%, 35%);
    --color-palette-series-2: hsl(75, 43%, 45%);
    --color-palette-series-3: hsl(40, 100%, 49%);
    --color-palette-series-4: hsl(215, 37%, 66%);
    --color-palette-series-5: hsl(63, 100%, 23%);
    --color-palette-series-6: hsl(34, 57%, 46%);
    --color-palette-series-7: hsl(51, 56%, 64%);
    --color-palette-series-8: hsl(253, 26%, 43%);
    --color-palette-series-9: hsl(85, 65%, 36%);
  }

  /* NOTE: not real deutan color palette! Replace after research */
  .theme-deutan {
    --color-palette-series-0: #800080;
    --color-palette-series-1: #ff00ff;
    --color-palette-series-2: #ca0088;
    --color-palette-series-3: #fa0080;
    --color-palette-series-4: #b400b4;
    --color-palette-series-5: #4477AA;
    --color-palette-series-6: #EE6677;
    --color-palette-series-7: #228833;
    --color-palette-series-8: #CCBB44;
    --color-palette-series-9: #66CCEE;
    --color-palette-series-10: #AA3377;
  }

  /* NOTE: not real protan color palette! Replace after research */
  .theme-protan {
    --color-palette-series-0: hsl(39, 70%, 54%);
    --color-palette-series-1: hsl(206, 68%, 66%);
    --color-palette-series-2: hsl(154, 39%, 44%);
    --color-palette-series-3: hsl(56, 81%, 66%);
    --color-palette-series-4: hsl(209, 57%, 43%);
    --color-palette-series-5: hsl(24, 68%, 46%);
    --color-palette-series-6: hsl(324, 35%, 62%);
  }

  /* NOTE: not real tritan color palette! Replace after research */
  .theme-tritan {
    --color-palette-series-0: #77AADD;
    --color-palette-series-1: #99DDFF;
    --color-palette-series-2: #44BB99;
    --color-palette-series-3: #BBCC33;
    --color-palette-series-4: #AAAAOO;
    --color-palette-series-5: #EEDD88;
    --color-palette-series-6: #FFAABB;
  }

  /* NOTE: not real grayscale color palette! Replace after research */
  .theme-grayscale {
    --color-palette-series-0: #262626;
    --color-palette-series-1: #595959;
    --color-palette-series-2: #7f7f7f;
    --color-palette-series-3: #a1a1a1;
    --color-palette-series-4: #bababa;
    --color-palette-series-5: #d4d4d4;
    --color-palette-series-6: #ededed;
  }

  .series-0 {
    fill: var(--color-palette-series-0);
    stroke: var(--color-palette-series-0);
  }
  .series-1 {
    fill: var(--color-palette-series-1);
    stroke: var(--color-palette-series-1);
  }
  .series-2 {
    fill: var(--color-palette-series-2);
    stroke: var(--color-palette-series-2);
  }
  .series-3 {
    fill: var(--color-palette-series-3);
    stroke: var(--color-palette-series-3);
  }
  .series-4 {
    fill: var(--color-palette-series-4);
    stroke: var(--color-palette-series-4);
  }
  .series-5 {
    fill: var(--color-palette-series-5);
    stroke: var(--color-palette-series-5);
  }
  .series-6 {
    fill: var(--color-palette-series-6);
    stroke: var(--color-palette-series-6);
  }
  .series-7 {
    fill: var(--color-palette-series-7);
    stroke: var(--color-palette-series-7);
  }
  .series-8 {
    fill: var(--color-palette-series-8);
    stroke: var(--color-palette-series-8);
  }
  .series-9 {
    fill: var(--color-palette-series-9);
    stroke: var(--color-palette-series-9);
  }

  .range-highlights {
    fill: pink;
    stroke: pink;
    fill-opacity: 0.25;
    stroke-width: 4px;
    stroke-opacity: 0.5;
  }
  .range-highlights rect[data-id="0"] {
    fill: orange;
    stroke: orange;
  }
  .range-highlights rect[data-id="1"] {
    fill: cyan;
    stroke: cyan;
  }
  .linebreaker[data-state=active] .linebreaker-marker {
    stroke: dodgerblue;
    stroke-width: 3px;
  }
  .best_fit_line[data-state=active] {
    display: inline;
    fill: none;
    stroke: hsl(315, 89%, 46%);
    stroke-width: 8px;
    stroke-linecap: butt;
    stroke-dasharray: 12 12;
    stroke-opacity: 0.5;
  }
  .best_fit_line[data-state=inactive] {
    display: none;
  }

  .setting-views {
    display: flex;
    gap: 1rem;
  }

  .setting-views+.setting-views {
    margin-top: 0.5rem;
  }

  figure {
    display: inline-block;
  }

  svg {
    display: block;
  }


  /* details box styles*/

  .tab-content {
    display: flex;
    flex-direction: row;
    gap: 1rem;
    align-items: center;
    justify-content: space-between;
    padding: 0.2rem;
  }

  .tab-content.stacked {
    flex-direction: column;
    gap: 0.1rem;
    align-items: flex-start;
    justify-content: space-between;
    padding: 0.5rem 0.2rem;
  }

  #chart-colors-presets {
    border: none;
    padding: 0;
    margin: 0;
  }

  #chart-colors-presets label {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
  }

  #chart-colors-presets label span {
    text-align: center;
    word-spacing: 20em;
  }

  /* dialog styles */

  #output_dialog {
    margin: 0 auto;
  }

  #output-dialog::backdrop {
    background: repeating-linear-gradient(
      45deg,
      rgba(128,0,128, 0.2),
      rgba(128,0,128, 0.2) 1px,
      rgba(128,0,128, 0.3) 1px,
      rgba(128,0,128, 0.3) 20px
    );
  }

  #output-dialog button {
    color: white;
    background-color: var(--theme-color);
    border: 1px solid var(--theme-color);
  }

  #output-dialog h1 {
    color: black;
    font-size: 1.3rem;
    font-weight: normal;
  }

  /* Tab Page styles */

  button {
    margin: 0.2rem;
    background-color: var(--theme-color);
    color: var(--theme-contrast-color);
    border: thin solid var(--theme-color);
    border-radius: 0.2em;
    padding: 0.2em;
  }

  #status_split {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }

  [role="graphics-document"] {
    cursor: var(--chart-cursor);
  }

  #chart-layers {
    cursor: var(--data-cursor);
  }
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Kie = (t) => t.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Ab = { ATTRIBUTE: 1, CHILD: 2 }, kb = (t) => (...e) => ({ _$litDirective$: t, values: e });
let _b = class {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, r, n) {
    this._$Ct = e, this._$AM = r, this._$Ci = n;
  }
  _$AS(e, r) {
    return this.update(e, r);
  }
  update(e, r) {
    return this.render(...r);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Qf = (t, e) => {
  var n;
  const r = t._$AN;
  if (r === void 0) return !1;
  for (const i of r) (n = i._$AO) == null || n.call(i, e, !1), Qf(i, e);
  return !0;
}, ky = (t) => {
  let e, r;
  do {
    if ((e = t._$AM) === void 0) break;
    r = e._$AN, r.delete(t), t = e;
  } while ((r == null ? void 0 : r.size) === 0);
}, EN = (t) => {
  for (let e; e = t._$AM; t = e) {
    let r = e._$AN;
    if (r === void 0) e._$AN = r = /* @__PURE__ */ new Set();
    else if (r.has(t)) break;
    r.add(t), Jie(e);
  }
};
function Yie(t) {
  this._$AN !== void 0 ? (ky(this), this._$AM = t, EN(this)) : this._$AM = t;
}
function Zie(t, e = !1, r = 0) {
  const n = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0) if (e) if (Array.isArray(n)) for (let s = r; s < n.length; s++) Qf(n[s], !1), ky(n[s]);
  else n != null && (Qf(n, !1), ky(n));
  else Qf(this, t);
}
const Jie = (t) => {
  t.type == Ab.CHILD && (t._$AP ?? (t._$AP = Zie), t._$AQ ?? (t._$AQ = Yie));
};
class Xie extends _b {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(e, r, n) {
    super._$AT(e, r, n), EN(this), this.isConnected = e._$AU;
  }
  _$AO(e, r = !0) {
    var n, i;
    e !== this.isConnected && (this.isConnected = e, e ? (n = this.reconnected) == null || n.call(this) : (i = this.disconnected) == null || i.call(this)), r && (Qf(this, e), ky(this));
  }
  setValue(e) {
    if (Kie(this._$Ct)) this._$Ct._$AI(e, this);
    else {
      const r = [...this._$Ct._$AH];
      r[this._$Ci] = e, this._$Ct._$AI(r, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Et = () => new ese();
class ese {
}
const Ew = /* @__PURE__ */ new WeakMap(), yt = kb(class extends Xie {
  render(t) {
    return De;
  }
  update(t, [e]) {
    var n;
    const r = e !== this.G;
    return r && this.G !== void 0 && this.rt(void 0), (r || this.lt !== this.ct) && (this.G = e, this.ht = (n = t.options) == null ? void 0 : n.host, this.rt(this.ct = t.element)), De;
  }
  rt(t) {
    if (this.isConnected || (t = void 0), typeof this.G == "function") {
      const e = this.ht ?? globalThis;
      let r = Ew.get(e);
      r === void 0 && (r = /* @__PURE__ */ new WeakMap(), Ew.set(e, r)), r.get(this.G) !== void 0 && this.G.call(this.ht, void 0), r.set(this.G, t), t !== void 0 && this.G.call(this.ht, t);
    } else this.G.value = t;
  }
  get lt() {
    var t, e;
    return typeof this.G == "function" ? (t = Ew.get(this.ht ?? globalThis)) == null ? void 0 : t.get(this.G) : (e = this.G) == null ? void 0 : e.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Dt = (t) => (e, r) => {
  r !== void 0 ? r.addInitializer(() => {
    customElements.define(t, e);
  }) : customElements.define(t, e);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const tse = { attribute: !0, type: String, converter: X1, reflect: !1, hasChanged: SE }, rse = (t = tse, e, r) => {
  const { kind: n, metadata: i } = r;
  let s = globalThis.litPropertyMetadata.get(i);
  if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = /* @__PURE__ */ new Map()), n === "setter" && ((t = Object.create(t)).wrapped = !0), s.set(r.name, t), n === "accessor") {
    const { name: o } = r;
    return { set(a) {
      const l = e.get.call(this);
      e.set.call(this, a), this.requestUpdate(o, l, t);
    }, init(a) {
      return a !== void 0 && this.C(o, void 0, t, a), a;
    } };
  }
  if (n === "setter") {
    const { name: o } = r;
    return function(a) {
      const l = this[o];
      e.call(this, a), this.requestUpdate(o, l, t);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function Ke(t) {
  return (e, r) => typeof r == "object" ? rse(t, e, r) : ((n, i, s) => {
    const o = i.hasOwnProperty(s);
    return i.constructor.createProperty(s, n), o ? Object.getOwnPropertyDescriptor(i, s) : void 0;
  })(t, e, r);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Vr(t) {
  return Ke({ ...t, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const SN = (t, e, r) => (r.configurable = !0, r.enumerable = !0, Reflect.decorate && typeof e != "object" && Object.defineProperty(t, e, r), r);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Cg(t) {
  return (e, r) => {
    const { slot: n, selector: i } = t ?? {}, s = "slot" + (n ? `[name=${n}]` : ":not([name])");
    return SN(e, r, { get() {
      var l;
      const o = (l = this.renderRoot) == null ? void 0 : l.querySelector(s), a = (o == null ? void 0 : o.assignedElements(t)) ?? [];
      return i === void 0 ? a : a.filter((c) => c.matches(i));
    } });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function nse(t) {
  return (e, r) => {
    const { slot: n } = {}, i = "slot" + (n ? `[name=${n}]` : ":not([name])");
    return SN(e, r, { get() {
      var o;
      const s = (o = this.renderRoot) == null ? void 0 : o.querySelector(i);
      return (s == null ? void 0 : s.assignedNodes(t)) ?? [];
    } });
  };
}
const Sl = class Sl {
  /**
   * Create a ScreenReaderBridge instance.
   * @param captionElement - the "caption" element, typically a span or div element
   */
  constructor(e) {
    this._maxNumPaddingCharacters = 3, this._numPaddingCharacters = 0, this._element = e, this._lastCreatedElement = null;
  }
  /**
   * Add the required aria attributes to an element for screen readers to properly work.
   * In order for the greatest number of screen reader and browser combinations to work, the following attributes must
   * be set on the element:
   * aria-live: assertive
   * roll: status
   * aria-atomic: true
   * aria-relevant: additions text
   * For the aria-live attribute, "polite" may also work, but that will create a queue of messages for the screen
   * reader to read out one after another which is probably not what you want.
   * @param element - the "caption" element which will host the messages for the screen reader to speak
   * @param [ariaLive] - the politeness of the aria-live attribute, one of "off", "assertive", or "polite"
   * @static
   */
  static addAriaAttributes(e, r = "assertive") {
    e.setAttribute("aria-live", r), e.setAttribute("role", "status"), e.setAttribute("aria-relevant", "additions text");
  }
  /**
   * The last created child element of the "caption" element.
   */
  get lastCreatedElement() {
    return this._lastCreatedElement;
  }
  /**
   * Clear the contents of the live region
   */
  clear() {
    this._element.innerHTML = "";
  }
  /**
   * Insert the provided text into the aria-live region.
   * @param text - the text to inserts
   */
  render(e) {
    const r = this._createPaddedText(e), n = document.createElement("div");
    n.textContent = r, n.setAttribute(
      Sl.ORIGINAL_TEXT_ATTRIBUTE,
      e
    ), n.setAttribute("data-created", Date.now().toString()), this.lastCreatedElement && (this._removeOldElements(), this.lastCreatedElement.style.display = "none"), this._element.appendChild(n), this._lastCreatedElement = n;
  }
  /**
   * Pad the provided text with the padding character.
   * Padding the text tricks screen readers into speaking it, even if they think it should be suppressed.
   * @param text - the text to pad
   * @private
   */
  _createPaddedText(e) {
    let r = "";
    for (let n = 0; n < this._numPaddingCharacters; n++)
      r += Sl.PADDING_CHARACTER;
    return this._numPaddingCharacters = (this._numPaddingCharacters + 1) % this._maxNumPaddingCharacters, e + r;
  }
  /**
   * Remove any hidden elements that were hidden longer than the set milliseconds.
   * We wait to remove those elements even though they are hidden because some screen readers don't like the DOM
   * changing that much.
   * @private
   */
  _removeOldElements() {
    const e = Date.now();
    Array.from(this._element.children).forEach((r) => {
      const n = Number(r.getAttribute("data-time"));
      e - n > Sl.REMOVAL_DELAY && this._element.removeChild(r);
    });
  }
};
Sl.PADDING_CHARACTER = "", Sl.REMOVAL_DELAY = 25, Sl.ORIGINAL_TEXT_ATTRIBUTE = "data-original-text";
let w0 = Sl;
const j2 = class j2 extends w0 {
  /**
   * Insert the provided text & highlights into the aria-live region.
   * @param text - the text to insert
   * @param highlights - the highlights to insert
   */
  renderHighlights(e, r) {
    super.render(e), this._lastCreatedElement.setAttribute(
      j2.ORIGINAL_HIGHLIGHT_ATTRIBUTE,
      JSON.stringify(r)
    );
  }
};
j2.ORIGINAL_HIGHLIGHT_ATTRIBUTE = "data-original-highlight";
let _y = j2;
var ise = Object.defineProperty, sse = Object.getOwnPropertyDescriptor, AN = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? sse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && ise(e, r, i), i;
};
let Cy = class extends ts {
  constructor() {
    super(...arguments), this.announcement = { text: "", html: "", highlights: [], startFrom: 0 }, this._ariaLiveRef = Et(), this._history = [], this._historyDialogRef = Et();
  }
  get voicing() {
    return this._voicing;
  }
  // @simonvarey: I added this so that `Voicing` could receive `store` and `shadowRoot` for highlighting.
  //   In theory, it should have been possible to add this to `_initAriaLiveRegion`, but that
  //   caused errors when I tried.
  connectedCallback() {
    super.connectedCallback(), this._voicing = new Qie(this.store);
  }
  _setHistory(t) {
    this._history = t, this._historyDialogRef.value.history = t;
  }
  willUpdate(t) {
    t.has("announcement") && this.announcement.text && (this.announcement.clear && this._srb.clear(), this._srb.renderHighlights(this.announcement.text, this.announcement.highlights));
  }
  firstUpdated(t) {
    var e;
    this._initAriaLiveRegion((e = this.shadowRoot) == null ? void 0 : e.querySelector("div"));
  }
  _initAriaLiveRegion(t) {
    w0.addAriaAttributes(t), t.setAttribute("lang", "en"), this._srb = new _y(t), new MutationObserver((r) => {
      r.forEach((n) => {
        if (n.addedNodes.length === 0)
          return;
        const i = n.addedNodes[0], s = i.getAttribute(w0.ORIGINAL_TEXT_ATTRIBUTE), o = i.getAttribute(_y.ORIGINAL_HIGHLIGHT_ATTRIBUTE);
        this._setHistory([...this._history, s ?? ""]), s && this._store.settings.ui.isVoicingEnabled && this._store.settings.ui.isAnnouncementEnabled && this._voicing.speak(s, JSON.parse(o), this.announcement.startFrom);
      });
    }).observe(t, {
      childList: !0
    });
  }
  showHistoryDialog() {
    this._historyDialogRef.value.show();
  }
  clear() {
    this._srb.clear();
  }
  get lastAnnouncement() {
    var t;
    return (t = this._srb.lastCreatedElement) == null ? void 0 : t.textContent;
  }
  replay() {
    const t = this.lastAnnouncement;
    t && this._store.announce(t);
  }
  render() {
    return this._voicing.rate = this._store.settings.ui.speechRate, qe`
      <div
        ${yt(this._ariaLiveRef)}
        class="sr-only"
        data-testid="sr-status"
      ></div>
      <para-aria-live-history-dialog
        ${yt(this._historyDialogRef)}
      ></para-aria-live-history-dialog>
    `;
  }
};
Cy.styles = [
  k5,
  Nt`
      div {
        white-space: pre-line;
      }
    `
];
AN([
  Ke({ type: Object })
], Cy.prototype, "announcement", 2);
Cy = AN([
  Dt("para-aria-live-region")
], Cy);
var ose = Object.defineProperty, ase = Object.getOwnPropertyDescriptor, _5 = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? ase(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && ose(e, r, i), i;
};
let x0 = class extends ts {
  constructor() {
    super(...arguments), this._dialogRef = Et(), this.btnText = "Okay", this.history = [];
  }
  render() {
    const t = [{ tag: "cancel", text: this.btnText }];
    return qe`
      <fizz-dialog
        ${yt(this._dialogRef)} 
        title="History" 
        .buttons=${t}
      >
        <ul class="history"
        >
          ${this.history.map((e) => qe`
              <li>${e}</li>
            `)}
        </ul>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
x0.styles = Nt`
    .history {
      align-self: stretch;
    }
  `;
_5([
  Ke()
], x0.prototype, "btnText", 2);
_5([
  Ke({ type: Array })
], x0.prototype, "history", 2);
x0 = _5([
  Dt("para-aria-live-history-dialog")
], x0);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const kN = "important", lse = " !" + kN, mn = kb(class extends _b {
  constructor(t) {
    var e;
    if (super(t), t.type !== Ab.ATTRIBUTE || t.name !== "style" || ((e = t.strings) == null ? void 0 : e.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t) {
    return Object.keys(t).reduce((e, r) => {
      const n = t[r];
      return n == null ? e : e + `${r = r.includes("-") ? r : r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${n};`;
    }, "");
  }
  update(t, [e]) {
    const { style: r } = t.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(e)), this.render(e);
    for (const n of this.ft) e[n] == null && (this.ft.delete(n), n.includes("-") ? r.removeProperty(n) : r[n] = null);
    for (const n in e) {
      const i = e[n];
      if (i != null) {
        this.ft.add(n);
        const s = typeof i == "string" && i.endsWith(lse);
        n.includes("-") || s ? r.setProperty(n, s ? i.slice(0, -11) : i, s ? kN : "") : r[n] = i;
      }
    }
    return Ra;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Br = kb(class extends _b {
  constructor(t) {
    var e;
    if (super(t), t.type !== Ab.ATTRIBUTE || t.name !== "class" || ((e = t.strings) == null ? void 0 : e.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t) {
    return " " + Object.keys(t).filter((e) => t[e]).join(" ") + " ";
  }
  update(t, [e]) {
    var n, i;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this.nt = new Set(t.strings.join(" ").split(/\s/).filter((s) => s !== "")));
      for (const s in e) e[s] && !((n = this.nt) != null && n.has(s)) && this.st.add(s);
      return this.render(e);
    }
    const r = t.element.classList;
    for (const s of this.st) s in e || (r.remove(s), this.st.delete(s));
    for (const s in e) {
      const o = !!e[s];
      o === this.st.has(s) || (i = this.nt) != null && i.has(s) || (o ? (r.add(s), this.st.add(s)) : (r.remove(s), this.st.delete(s)));
    }
    return Ra;
  }
}), ra = Nt`
  :host {
    --theme-color: var(--fizz-theme-color, purple);
    --theme-contrast-color: var(--fizz-theme-contrast-color, ghostwhite);
    --theme-extra-color: var(--fizz-theme-extra-color, ghostwhite);
    --theme-color-light: var(--fizz-theme-color-light, hsl(275.4, 100%, 88%));
    --theme-text-color: var(--fizz-theme-text-color, var(--theme-color, black));
    --theme-unselected-text-color: var(--fizz-theme-unselected-text-color, var(--theme-contrast-color, black));
    --theme-selected-text-decoration: var(--fizz-theme-selected-text-decoration, none);
    --control-panel-icon-color: var(--theme-unselected-text-color, ghostwhite);
    --contents-overflow: hidden;
  }

  /* * {
    background: var(--background, var(--theme-contrast-color));
  }*/
  .hidden {
    display: none !important;
  }

  .sr-only {
    width:1px;
    height:1px;
    overflow:hidden;
  }

`;
var cse = Object.defineProperty, use = Object.getOwnPropertyDescriptor, zn = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? use(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && cse(e, r, i), i;
};
let oh = class extends $r {
  constructor() {
    super(...arguments), this.inline = !1, this.mode = "labels", this.tabs = [], this.icons = [], this.tabListRef = Et(), this.tabRefs = [];
  }
  set panelGroup(e) {
    if (this._panelGroup)
      throw new Error("panel group element is already set");
    this._panelGroup = e;
  }
  set currentPanel(e) {
    this.tabRefs.forEach((r, n) => {
      r.value.selected = n === e;
    }), this._panelGroup.currentPanel = e;
  }
  connectedCallback() {
    super.connectedCallback(), this.inline && (this.style.display = "inline-block");
  }
  updated(e) {
    e.get("tabs") && (this.currentPanel = 0);
  }
  keyListener(e) {
    console.log("keyListener", e.detail.key), console.log("target", e.target), console.log("currentTarget", e.currentTarget);
  }
  // @keydown=${this.keyListener}
  render() {
    const e = {
      background: "none",
      padding: "0",
      "flex-grow": 1
    };
    return qe`
      <ul
        ${yt(this.tabListRef)}
        role="tablist"
        class="tablist"
        style=${this.inline ? mn(e) : De}
        @tabclick=${(r) => {
      this.currentPanel = r.detail;
    }}
        @keynav=${(r) => {
      this.keyListener(r);
    }}
      >
        ${this.tabs.map((r, n) => {
      var i;
      return (i = this.tabRefs)[n] ?? (i[n] = Et()), qe`
              <fizz-tab
                ${yt(this.tabRefs[n])}
                .mode=${this.mode}
                .icon=${this.icons[n]}
                index=${n}
              >
                <span>${r}</span>
              </fizz-tab>
            `;
    })}
      </ul>
    `;
  }
};
oh.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      .tablist {
        display: flex;
        background: var(--background, var(--theme-color));
        padding: var(--padding, 0.25rem 0.25rem 0 0.25rem);
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
        gap: var(--tab-gap, 0);
        font-size: var(--tab-font-size, unset);
        font-weight: var(--tab-font-weight, unset);
        margin: 0;
      }
    `
];
zn([
  Ke({ type: Boolean })
], oh.prototype, "inline", 2);
zn([
  Ke()
], oh.prototype, "mode", 2);
zn([
  Vr()
], oh.prototype, "tabs", 2);
zn([
  Vr()
], oh.prototype, "icons", 2);
oh = zn([
  Dt("fizz-tab-list")
], oh);
let Iy = class extends $r {
  constructor() {
    super(...arguments), this._currentPanel = 0;
  }
  get numPanels() {
    return this.panelEls.length;
  }
  get currentPanel() {
    return this._currentPanel;
  }
  set currentPanel(e) {
    this._currentPanel = e, this.panelEls.forEach(
      (r, n) => r.setSelected(n === this._currentPanel)
    );
  }
  connectedCallback() {
    super.connectedCallback(), this.tabListEl = this.findTabList(), this.tabListEl.panelGroup = this;
  }
  findTabList() {
    let e = this.parentElement;
    for (; e; ) {
      const r = e.querySelector("fizz-tab-list");
      if (r)
        return r;
      e = e.parentElement;
    }
    throw new Error("unable to locate tab list");
  }
  render() {
    return qe`
      <div class="panels">
        <slot @slotchange=${(e) => {
      var r;
      this.tabListEl.tabs = this.panelEls.map((n) => n.tabLabel), (r = this.panelEls[0]) != null && r.icon && (this.tabListEl.icons = this.panelEls.map((n) => {
        if (n.icon)
          return n.icon;
        throw new Error(`panel '${n.tabLabel}' icon missing`);
      }));
    }}></slot>
      </div>
    `;
  }
};
Iy.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      .panels {
        border-radius: var(--border-radius, 0 0 0.15rem 0.15rem);
      }
    `
];
zn([
  Cg()
], Iy.prototype, "panelEls", 2);
Iy = zn([
  Dt("fizz-tab-panel-group")
], Iy);
let ah = class extends $r {
  constructor() {
    super(...arguments), this.tabLabel = "TAB", this.visible = !1, this.panelRef = Et();
  }
  // get slottedNodes() {
  //   return this.slotRef.value!.assignedNodes();
  // }
  firstUpdated(e) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  render() {
    return qe`
      <div
        ${yt(this.panelRef)}
        role="tabpanel"
        tabindex="0"
        class="panel"
        ?hidden=${!this.visible}
      >
        <slot></slot>
      </div>
    `;
  }
  setSelected(e) {
    this.visible = e;
  }
};
ah.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      .panel {
        border-radius: var(--border-radius, 0 0 0.15rem 0.15rem);
      }
    `
];
zn([
  Ke()
], ah.prototype, "tabLabel", 2);
zn([
  Ke()
], ah.prototype, "icon", 2);
zn([
  nse()
], ah.prototype, "contentNodes", 2);
zn([
  Vr()
], ah.prototype, "visible", 2);
ah = zn([
  Dt("fizz-tab-panel")
], ah);
let qp = class extends $r {
  constructor() {
    super(...arguments), this.selected = !1, this.ref = Et();
  }
  activate(e) {
    e.preventDefault(), e.stopPropagation(), this.dispatchEvent(
      new CustomEvent(
        "tabclick",
        {
          bubbles: !0,
          composed: !0,
          detail: this.index
        }
      )
    );
  }
  keyListener(e) {
    e.preventDefault(), e.stopPropagation(), this.dispatchEvent(
      new CustomEvent(
        "keynav",
        {
          bubbles: !0,
          composed: !0,
          detail: e
        }
      )
    );
  }
  render() {
    const e = {
      hidden: this.mode === "icons" || this.mode === "icons-current-label" && !this.selected
    }, r = {
      icon: this.mode !== "labels"
    }, n = {
      mask: this.icon ? `url("${this.icon}") no-repeat 50% 50%` : void 0,
      "mask-size": "cover"
    };
    return qe`
      <li
        role="presentation"
      >
        <button
          ${yt(this.ref)}
          role="tab"
          id="tab${this.index}"
          tabindex=${this.selected ? De : "-1"}
          aria-selected=${this.selected ? "true" : "false"}
          class="tab"
          @keydown=${(i) => {
      this.keyListener(i);
    }}
          @click=${(i) => this.activate(i)}
        >
          ${this.icon ? qe`
            <span
              class=${Br(r)}
              style=${mn(n)}
            >
            </span>
          ` : ""}
          <slot class=${Br(e)}>
            TAB LABEL
          </slot>
        </button>
      </li>
    `;
  }
};
qp.styles = [
  ra,
  Nt`
      :host {
        background: none !important;
      }
      li {
        list-style-type: none;
      }
      .tab {
        padding: var(--padding, 0.25rem 0.4rem);
        cursor: pointer;
        border: none;
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
      }
      [role='tab'] {
        color: var(--background-selected, var(--theme-unselected-text-color, var(--theme-extra-color)));
        background: none;
      }
      [role='tab'][aria-selected='true'] {
        background: var(--background-selected, var(--theme-extra-color));
        color: var(--theme-text-color, var(--color-selected, var(--theme-color)));
        text-decoration: var(--theme-selected-text-decoration) var(--theme-text-color);
        text-underline-offset: 0.25rem;
      }
      .icon {
        height: 1.2rem;
        width: 1.2rem;
        vertical-align: middle;
        background-color: currentColor;
        display: inline-block;
        margin-top: -0.5rem;
      }
      [role='tab-delete'] {
        background: var(--color, var(--theme-color));
      }
    `
];
zn([
  Ke({ type: Number })
], qp.prototype, "index", 2);
zn([
  Vr()
], qp.prototype, "selected", 2);
zn([
  Vr()
], qp.prototype, "mode", 2);
qp = zn([
  Dt("fizz-tab")
], qp);
const hse = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2016.9%2016.9'%3e%3cg%20id='layer1'%3e%3ccircle%20style='fill:%23ffffff;%20stroke-width:0.3;'%20id='path1'%20cx='8.5'%20cy='8.5'%20r='8.5'%20/%3e%3cpath%20id='path2'%20style='fill:%23040404;%20stroke-width:0.3'%20d='M%204.2,5.3%205.3,4.2%208.5,7.4%2011.6,4.2%2012.7,5.3%209.5,8.5%2012.7,11.6%2011.6,12.7%208.5,9.5%205.3,12.7%204.2,11.6%207.4,8.5%20Z'%20/%3e%3c/g%3e%3c/svg%3e";
var pse = Object.defineProperty, dse = Object.getOwnPropertyDescriptor, Ur = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? dse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && pse(e, r, i), i;
};
let Hi = class extends $r {
  constructor() {
    super(), this.dialogRef = Et(), this.xButtonRef = Et(), this.cancel = { key: !0, button: !0, click: !0 }, this.modal = !1, this.x = "0", this.y = "0", this.tx = 0, this.ty = 0, this.open = !1, this.title = "", this.onDocumentClick = (e) => {
      this.isWithinRect(e.clientX, e.clientY, this.dialogRef.value.getBoundingClientRect()) || this.didCancel(e);
    };
  }
  isWithinRect(e, r, n) {
    return !(e < n.left || e > n.right || r < n.top || r > n.bottom);
  }
  render() {
    const e = this.modal ? { translate: `${this.tx}px ${this.ty}px;` } : {
      left: this.x,
      top: this.y,
      margin: 0
    };
    return this.width && (e.width = this.width), this.height && (e.height = this.height), qe`
      <dialog
        ${yt(this.dialogRef)}
        @cancel=${this.didCancel}
        style=${mn(e)}
		aria-label = ${this.title}
      >
        <div class="content">
          ${this.cancel.button ? qe`
              <button type="button" class="close-x" @click=${this.didCancel}>
                <img src=${hse} alt="Dialog close button">
                <span>Close</span>
              </button>
              ` : ""}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  firstUpdated(e) {
    this.open && this.show(), this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  async didCancel(e) {
    if (e.preventDefault(), !(e.type === "cancel" && !this.cancel.key || e.type === "click" && e.target === this.xButtonRef.value && !this.cancel.button))
      if (this.onCancel) {
        const r = await this.onCancel();
        r.close && this.close(r.value);
      } else
        this.close();
  }
  /**
   * Show the overlay.
   * @param afterShow - A function that will be called immediately after showing the overlay.
   * Can be useful if awaiting this method.
   * @returns Promise of string return value (typically the tag of the button
   * that caused the closure).
   * @remarks
   * This method can be awaited until the overlay is closed.
   */
  show(e) {
    return this.dialogRef.value.open ? this.promise : (this.modal ? this.dialogRef.value.showModal() : this.dialogRef.value.show(), this.cancel.click && setTimeout(() => document.addEventListener("click", this.onDocumentClick)), this.promise = new Promise((r) => {
      this.resolve = r, this.xButtonRef.value.focus(), e == null || e();
    }), this.promise);
  }
  /**
   * Close the overlay.
   * @param value - Value to resolve the promise with.
   */
  close(e = "ui_default_close") {
    this.dialogRef.value.close(), this.cancel.click && document.removeEventListener("click", this.onDocumentClick), this.resolve(e);
  }
};
Hi.styles = Nt`
    dialog {
      padding: 0;
      border: none;
      box-shadow: 0 0 40px rgb(127, 127, 127);
      border-radius: var(--border-radius, 0.15rem);
      border: none;
    }
    dialog .content {
      position: relative;
      background: var(--theme-color-constrast, ghostwhite);
      border: solid var(--theme-color) 1px;
      border-radius: var(--border-radius, 0.15rem);
      min-width: 15rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
    }
    button.close-x {
      position: absolute;
      right: 0.25rem;
      top: 0.25rem;
      /*height: calc(100% - 0.5rem); // titlebar height minus padding */
      padding: 0;
      background: transparent;
      border: 0;
    }
    button.close-x img {
      height: 1.3em;
    }
    button.close-x span {
      display: none;
    }
  `;
Ur([
  Ke({ type: Object })
], Hi.prototype, "cancel", 2);
Ur([
  Ke({ type: Boolean })
], Hi.prototype, "modal", 2);
Ur([
  Ke()
], Hi.prototype, "x", 2);
Ur([
  Ke()
], Hi.prototype, "y", 2);
Ur([
  Ke()
], Hi.prototype, "width", 2);
Ur([
  Ke()
], Hi.prototype, "height", 2);
Ur([
  Ke({ type: Number })
], Hi.prototype, "tx", 2);
Ur([
  Ke({ type: Number })
], Hi.prototype, "ty", 2);
Ur([
  Ke({ type: Boolean })
], Hi.prototype, "open", 2);
Ur([
  Ke()
], Hi.prototype, "title", 2);
Hi = Ur([
  Dt("fizz-overlay")
], Hi);
let E0 = class extends $r {
  constructor() {
    super(), this.prevX = 0, this.prevY = 0, this.tx = 0, this.ty = 0, this.title = "TITLE", this.buttons = [
      { tag: "cancel", text: "Cancel" },
      { tag: "okay", text: "Okay" }
    ], this.moveListener = this.move.bind(this);
  }
  render() {
    const e = JSON.stringify({ key: !0, button: !0, click: !1 });
    return qe`
      <fizz-overlay modal cancel=${e} title = ${this.title}>
        <div
          class="title"
          @pointerdown=${this.titlebarPointerDown}
          @pointerup=${this.titlebarPointerUp}
        >
          ${this.title}
        </div>
        <slot></slot>
        <div class="buttons">
          ${this.buttons.map((r) => qe`
            <button id=${r.tag} ?disabled=${r.disabled} @click=${this.btnClicked}>
              ${r.text}
            </button>
            `)}
        </div>
      </fizz-overlay>
    `;
  }
  firstUpdated(e) {
    this.titlebar = this.renderRoot.querySelector(".title"), this.btnsWrapper = this.renderRoot.querySelector(".buttons"), this.overlay = this.renderRoot.querySelector("fizz-overlay"), this.overlay.onCancel = async () => await this.didCancel();
  }
  titlebarPointerDown(e) {
    this.prevX = e.clientX, this.prevY = e.clientY, this.titlebar.addEventListener("pointermove", this.moveListener), this.titlebar.setPointerCapture(e.pointerId);
  }
  titlebarPointerUp(e) {
    this.titlebar.removeEventListener("pointermove", this.moveListener), this.titlebar.releasePointerCapture(e.pointerId);
  }
  move(e) {
    this.tx += e.clientX - this.prevX, this.prevX = e.clientX, this.ty += e.clientY - this.prevY, this.prevY = e.clientY, this.overlay.tx = this.tx, this.overlay.ty = this.ty;
  }
  async didCancel() {
    const e = this.buttonInfo("cancel");
    if (e) {
      const r = e.closeHook;
      return { close: r ? await r("cancel") : !0, value: "cancel" };
    } else
      return { close: !0 };
  }
  /**
   * Get the disabled state of all buttons.
   * @returns Mapping of button tags to disabled states.
   */
  getButtonsDisabled() {
    const e = {};
    for (const { tag: r } of this.buttons)
      e[r] = this.renderRoot.querySelector(`#${r}`).disabled;
    return e;
  }
  /**
   * Set the disabled state of specific buttons.
   * @param state - Mapping of button tags to desired disabled values.
   * All buttons will be disabled if this is omitted.
   * @returns Previous button disabled states if called with no argument.
   */
  setButtonsDisabled(e) {
    if (e)
      for (const [r, n] of Object.entries(e))
        this.renderRoot.querySelector(`#${r}`).disabled = n;
    else {
      const r = this.getButtonsDisabled();
      return this.renderRoot.querySelectorAll("button").forEach((n) => {
        n.disabled = !0;
      }), r;
    }
  }
  buttonInfo(e) {
    return this.buttons.find((r) => r.tag === e);
  }
  /**
   * Get the button corresponding to a specific tag..
   * @param tag - Button tag.
   * @returns Button element (or null).
   */
  button(e) {
    return this.renderRoot.querySelector(`#${e}`);
  }
  async btnClicked(e) {
    const r = this.setButtonsDisabled(), n = this.buttonInfo(e.target.id);
    (!n.closeHook || await n.closeHook(n.tag)) && this.overlay.close(n.tag), this.setButtonsDisabled(r);
  }
  /**
   * Show the dialog.
   * @param afterShow - A function that will be called immediately after showing the dialog.
   * Can be useful if awaiting this method.
   * @returns Promise of string return value (typically the tag of the button
   * that caused the closure).
   * @remarks
   * This method can be awaited until the dialog is closed.
   */
  show(e) {
    for (const { tag: r, disabled: n } of this.buttons)
      this.renderRoot.querySelector(`#${r}`).disabled = !!n;
    return this.overlay.tx = 0, this.overlay.ty = 0, this.tx = 0, this.ty = 0, this.prevX = 0, this.prevY = 0, this.overlay.show(e);
  }
};
E0.styles = Nt`
    .title {
      /*background: darkblue;
      color: white;*/
      font-weight: bold;
      align-self: stretch;
      text-align: center;
      padding: 0.25rem;
      margin-bottom: 0.5rem;
      border-radius: var(--border-radius, 0.15rem);
      /* If I leave this out, the title content area ends up every so slightly
         taller than the button image.*/
      height: 1rlh;
    }
    .buttons {
      padding: 0.5rem;
      display: flex;
      gap: 0.5rem;
    }


    .buttons button {
      --theme-color: purple;
      --theme-contrast-color: ghostwhite;

      margin: 0.2rem;
      background-color: var(--theme-color);
      color: var(--theme-contrast-color);
      border: thin solid var(--theme-color);
      border-radius: 0.2em;
      padding: 0.2em 0.4em;
    }
  `;
Ur([
  Ke()
], E0.prototype, "title", 2);
Ur([
  Ke({ type: Array })
], E0.prototype, "buttons", 2);
E0 = Ur([
  Dt("fizz-dialog")
], E0);
let Py = class extends $r {
  constructor() {
    super(...arguments), this.btnText = "Okay", this.text = "Your message here";
  }
  render() {
    const e = JSON.stringify([{ tag: "cancel", text: this.btnText }]);
    return qe`
      <fizz-dialog title="Message" buttons=${e}>
        <div class="text">${this.text}</div>
      </fizz-dialog>
    `;
  }
  firstUpdated(e) {
    this.dialog = this.renderRoot.querySelector("fizz-dialog");
  }
  /**
   * Show the dialog
   * @param text - Optional message text.
   */
  async show(e) {
    e && (this.text = e), await this.dialog.show(() => this.dialog.button("cancel").focus());
  }
};
Ur([
  Ke()
], Py.prototype, "btnText", 2);
Ur([
  Ke()
], Py.prototype, "text", 2);
Py = Ur([
  Dt("fizz-msg-dialog")
], Py);
let S0 = class extends $r {
  constructor() {
    super(...arguments), this.cancelText = "Cancel", this.okayText = "Okay", this.text = "Text";
  }
  render() {
    const e = JSON.stringify([
      { tag: "cancel", text: this.cancelText },
      { tag: "okay", text: this.okayText }
    ]);
    return qe`
      <fizz-dialog title="Confirm" buttons=${e}>
        <div class="text">${this.text}</div>
      </fizz-dialog>
    `;
  }
  firstUpdated(e) {
    this.dialog = this.renderRoot.querySelector("fizz-dialog");
  }
  /**
   * Show the dialog.
   * @param text - Message text.
   * @param cancelText - Cancel button text.
   * @param okayText - Confirm (okay) button text.
   * @returns Promise of boolean indicating whether the user confirmed or cancelled.
   */
  async show(e, r, n) {
    return e && (this.text = e), r && (this.cancelText = r), n && (this.okayText = n), await this.dialog.show(() => this.dialog.button("okay").focus()) === "okay";
  }
};
Ur([
  Ke()
], S0.prototype, "cancelText", 2);
Ur([
  Ke()
], S0.prototype, "okayText", 2);
Ur([
  Ke()
], S0.prototype, "text", 2);
S0 = Ur([
  Dt("fizz-conf-dialog")
], S0);
var fse = Object.defineProperty, gse = Object.getOwnPropertyDescriptor, _N = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? gse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && fse(e, r, i), i;
};
let Ry = class extends $r {
  constructor() {
    super(...arguments), this.inputDescriptors = {};
  }
  /*private ref(key: string) {
    console.log(`this.ref("${key}")`);
    if (this.refs.has(key)) {
      console.log('found ref');
      return this.refs.get(key);
    } else {
      const r = createRef<HTMLInputElement>();
      console.log('new ref:', r);
      this.refs.set(key, r);
      return r;
    }
  }*/
  firstUpdated(e) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  render() {
    return qe`
      <fieldset>
        <legend>
          <slot name="legend"></slot>
        </legend>
        <slot name="before"></slot>
        ${Object.entries(this.inputDescriptors).map(([e, r]) => qe`
            <label for=${e.toLowerCase()}>
              ${r.label}
              <input
                id=${e.toLowerCase()}
                type=${r.type ?? "text"}
                value=${r.value ?? De}
                placeholder=${r.placeholder ?? De}
                size=${r.size ?? De}
                min=${r.min ?? De}
                max=${r.max ?? De}
                @input=${(n) => this.dispatchEvent(
      new CustomEvent("edit", { bubbles: !0, composed: !0 })
    )}
                @change=${(n) => this.dispatchEvent(
      new CustomEvent("commit", { bubbles: !0, composed: !0 })
    )}
              />
            </label>
          `)}
        <slot name="after"></slot>
      </fieldset>
    `;
  }
  getInputs() {
    const e = {};
    for (const r of Object.keys(this.inputDescriptors))
      e[r] = this.renderRoot.querySelector(`#${r.toLowerCase()}`);
    return e;
  }
  /**
   * Determine whether all text fields are set to a value or not.
   * @returns Whether all fields have non-empty values.
   */
  isAllFieldsSet() {
    return Object.values(this.getInputs()).every((e) => e.value);
  }
  /**
   * Retrieve the current values of all text fields.
   * @returns Mapping of field keys to string values.
   */
  fieldValues() {
    const e = {};
    for (const [r, n] of Object.entries(this.getInputs()))
      e[r] = n.value;
    return e;
  }
  /**
   * Set the values of all text fields.
   * @param values - Mapping of field keys to new values.
   */
  setFieldValues(e) {
    const r = this.getInputs();
    for (const [n, i] of Object.entries(e))
      r[n].value = i;
  }
};
Ry.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      fieldset {
        display: flex;
        flex-direction: column;
        border-radius: var(--border-radius, 0.15rem);
        border-style: solid;
        border-width: 1px;
        border-color: var(--fieldset-border-color, var(--theme-color));
        color: var(--color, black);
        padding: 1rem;
        align-items: stretch;
      }
      legend {
        border-radius: var(--legend-border-radius, 0.15rem);
        padding: 0.25rem 0.5rem;
        background: var(--legend-background, var(--theme-color));
        color: var(--legend-color, var(--theme-extra-color));
      }
      label {
        display: flex;
        flex-direction: column;
        font-size: 0.75rem;
      }
      input {
        margin-left: 0;
        background: var(--input-background, white);
      }
    `
];
_N([
  Ke({ type: Object })
], Ry.prototype, "inputDescriptors", 2);
Ry = _N([
  Dt("fizz-textfieldset")
], Ry);
const mse = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2016.93%2016.93'%3e%3cdefs%20id='defs1'%20/%3e%3cg%20id='layer1'%3e%3ccircle%20style='fill:%23000000;stroke-width:0.36;fill-opacity:1'%20id='circle'%20cx='8.5'%20cy='8.5'%20r='8.5'%20/%3e%3cpath%20style='fill:%23ffffff;stroke-width:0.26;'%20d='m%207.4,9.4%20q%200,-0.6%200.25,-0.9%20Q%207.9,8.1%208.5,7.6%208.97,7.3%209.2,7%20q%200.25,-0.3%200.25,-0.6%200,-0.4%20-0.3,-0.54%20Q%208.88,5.66%208.41,5.66%207.93,5.66%207.47,5.80%207.01,5.95%206.52,6.20%20L%205.92,4.99%20Q%206.47,4.69%207.12,4.49%207.76,4.30%208.53,4.30%20q%201.17,0%201.81,0.6%200.65,0.6%200.65,1.43%200,0.46%20-0.14,0.80%20-0.14,0.33%20-0.44,0.63%20Q%2010.12,8.02%209.68,8.34%209.35,8.58%209.17,8.75%208.99,8.92%208.92,9.08%208.87,9.23%208.87,9.47%20V%209.80%20H%207.4%20Z%20m%20-0.18,2.29%20q%200,-0.51%200.28,-0.72%200.28,-0.21%200.68,-0.21%200.39,0%200.67,0.21%200.28,0.20%200.28,0.72%200,0.49%20-0.28,0.72%20-0.28,0.21%20-0.67,0.21%20-0.40,0%20-0.68,-0.21%20-0.28,-0.25%20-0.28,-0.72%20z'%20id='questionmark'%20aria-label='?'%20/%3e%3c/g%3e%3c/svg%3e";
var yse = (t, e, r, n) => {
  for (var i = e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let Ux = class extends $r {
  render() {
    return qe`
      <button type="button" class="icon" @click=${this.onIconClick}>
        <img src=${mse} alt="Info pop-up icon">
        <span>Get info about this item</span>
      </button>
      <fizz-overlay>
        <slot></slot>
      </fizz-overlay>
    `;
  }
  firstUpdated(e) {
    this.overlay = this.renderRoot.querySelector("fizz-overlay"), this.icon = this.renderRoot.querySelector(".icon"), this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  onIconClick(e) {
    const r = this.icon.getBoundingClientRect();
    this.overlay.x = `calc(${r.x}px + 0.5rem)`, this.overlay.y = `calc(${r.y}px + 0.5rem)`, this.overlay.show();
  }
};
Ux.styles = Nt`
    button.icon {
      padding: 0;
      background: none;
      color: white;
      padding: 0;
      border: 0;
    }
    button.icon img {
      height: 1rem;
      vertical-align: bottom;
    }
    button.icon:hover {
    }
    button.icon span {
        display: none;
    }
  `;
Ux = yse([
  Dt("fizz-infopopup")
], Ux);
const C5 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMS4yNXJlbSIgaGVpZ2h0PSIxLjI1cmVtIiB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGNpcmNsZSBzdHlsZT0ic3Ryb2tlOmdob3N0d2hpdGU7IHN0cm9rZS13aWR0aDoxLjhweDsgZmlsbDpub25lOyIgY3g9IjEwIiBjeT0iMTAiIHI9IjkiLz48dGV4dCB4PSIxMCIgeT0iMTYiIHN0eWxlPSJmaWxsOmdob3N0d2hpdGU7IGZvbnQ6Ym9sZCAxOHB4ICdUaW1lcyBOZXcgUm9tYW4nLFRpbWVzLHNlcmlmOyB0ZXh0LWFuY2hvcjptaWRkbGU7Ij5pPC90ZXh0Pgo8L3N2Zz4K";
var bse = Object.defineProperty, vse = Object.getOwnPropertyDescriptor, I5 = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? vse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && bse(e, r, i), i;
};
let A0 = class extends $r {
  constructor() {
    super(...arguments), this.open = !1;
  }
  render() {
    return qe`
      <details ?open=${this.open} @toggle=${() => this.dispatchEvent(new CustomEvent(
      this.details.open ? "open" : "close",
      { bubbles: !0, composed: !0 }
    ))}>
        <summary>
          <slot name="summary">Label</slot>
        </summary>
        <div class="content">
          <slot name="content">Contents</slot>
        </div>
      </details>
    `;
  }
  firstUpdated(e) {
    this.details = this.renderRoot.querySelector("details"), this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  /**
   * Replace the contents with the given elements.
   * @param newElements - Elements.
   */
  setContents(...e) {
    this.contents.forEach((r) => r.remove()), e.forEach((r) => {
      r.slot = "contents", this.append(r);
    });
  }
};
A0.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      details {
        /* Only shows up at the corners of the content area */
        background: var(--background, var(--theme-color));
        border-radius: var(--border-radius, 0.15rem);
        border: 1px solid var(--background, var(--border, var(--theme-color)));
      }
      summary {
        background: var(--background, var(--theme-color));
        color: var(--color, var(--theme-contrast-color));
        padding: 0;
        padding-top: 2px;
        padding-left: 2px;
        list-style-type: none;
      }
      summary::before {
        display: inline-block;
        width: var(--summary-marker-size, 1.1rem);
        height: var(--summary-marker-size, 1.1rem);
        margin-left: 2px;
        margin-top: 1px;
        margin-right: 2px;
        content: '';
        background-color: var(--summary-marker-color, var(--theme-contrast-color));
        mask-image: var(--summary-marker, url(${Ju(C5)}));
        mask-size: cover;
        cursor: pointer;
      }
      .content {
        background: var(--content-background, var(--theme-contrast-color));
        color: var(--content-color, black);
        padding: var(--content-padding, 0 0.25rem);
        border-radius: var(--border-radius, 0.15rem);
        overflow: var(--content-overflow, hidden);
      }
    `
];
I5([
  Ke({ type: Boolean })
], A0.prototype, "open", 2);
I5([
  Cg({ slot: "contents" })
], A0.prototype, "contents", 2);
A0 = I5([
  Dt("fizz-details")
], A0);
var wse = Object.defineProperty, xse = Object.getOwnPropertyDescriptor, Ig = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? xse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && wse(e, r, i), i;
};
let lh = class extends $r {
  constructor() {
    super(...arguments), this.label = "LABEL", this.options = [], this.selectRef = Et();
  }
  connectedCallback() {
    super.connectedCallback(), this.selected === void 0 && (this.selected = this.placeholder !== void 0 ? -1 : 0);
  }
  /*protected firstUpdated(_changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>) {
    this.dispatchEvent(new CustomEvent('dropdownfirstupdate', {bubbles: true, composed: true}));
  }*/
  optionSelected(e) {
    this.dispatchEvent(
      new CustomEvent("select", {
        detail: e,
        bubbles: !0,
        composed: !0
      })
    );
  }
  render() {
    return qe`
      <label>
        ${this.label}
        <select 
          ${yt(this.selectRef)}
          autocomplete="off"
          @change=${(e) => {
      const r = e.target.value;
      this.optionSelected(r === "" ? -1 : +r.slice(3));
    }}>
          ${this.placeholder ? qe`
              <option value="">${this.placeholder}</option>
            ` : ""}
          ${this.options.map((e, r) => qe`
              <option 
                value="opt${r}" 
                .selected=${r === this.selected}
              >
                ${e}
              </option>
            `)}
        </select>
      </label>
    `;
  }
  get selectedIndex() {
    return this.placeholder !== void 0 ? this.selectRef.value.selectedIndex - 1 : this.selectRef.value.selectedIndex;
  }
  /**
   * Select a specific option by index.
   * @param index - Index of option to select.
   * @remarks
   * If a placeholder is set, passing -1 as the index will select it.
   */
  select(e) {
    const r = this.placeholder ? -1 : 0;
    if (e < r || e >= this.options.length)
      throw new Error(`invalid selection index '${e}'`);
    this.selectRef.value.selectedIndex = this.placeholder !== void 0 ? e + 1 : e, this.optionSelected(e);
  }
};
lh.styles = Nt`
  `;
Ig([
  Ke()
], lh.prototype, "label", 2);
Ig([
  Ke()
], lh.prototype, "placeholder", 2);
Ig([
  Ke({ type: Array })
], lh.prototype, "options", 2);
Ig([
  Ke({ type: Number })
], lh.prototype, "selected", 2);
lh = Ig([
  Dt("fizz-dropdown")
], lh);
var Ese = Object.defineProperty, Sse = Object.getOwnPropertyDescriptor, _s = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Sse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && Ese(e, r, i), i;
};
let ci = class extends $r {
  constructor() {
    super(...arguments), this.label = "LABEL", this.key = "slider", this.showValue = !1, this.compact = !1, this.min = 0, this.max = 100, this.step = 1, this.percent = !1, this.inputRef = Et(), this._value = 50;
  }
  set value(e) {
    this._value = e;
  }
  get value() {
    return this._value;
  }
  connectedCallback() {
    super.connectedCallback(), this.lowBound ?? (this.lowBound = this.min), this.highBound ?? (this.highBound = this.max);
  }
  formatLabel() {
    const e = this.value;
    return this.percent ? `${Math.round(e * 100)}%` : `${e}`;
  }
  // protected firstUpdated(_changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>): void {
  //   this.dispatchEvent(
  //     new CustomEvent('sliderfirstupdate', {
  //       bubbles: true,
  //       composed: true
  //     }));
  // }
  /*protected updated(changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>) {
    if (changedProperties.has('value')) {
      this.inputRef.value!.value = this.value.toString();
    }
  }*/
  render() {
    return qe`
      <div
        class=${this.compact ? "compact" : De}
      >
        <span>
          <label for=${this.key}>${this.label}:</label>
          ${this.showValue && this.compact ? qe`
            <output for=${this.key}>
              ${this.formatLabel()}
            </output>
          ` : ""}
        </span>
        <input
          ${yt(this.inputRef)}
          id=${this.key}
          type="range"
          min=${this.min} max=${this.max} step=${this.step}
          .value=${this.value}
          @input=${() => {
      const e = +this.inputRef.value.value;
      e < this.lowBound || e > this.highBound ? this.inputRef.value.value = this._value.toString() : (this._value = +this.inputRef.value.value, this.dispatchEvent(new CustomEvent(
        "update",
        { bubbles: !0, composed: !0, detail: this._value }
      )), this.requestUpdate());
    }}
        >
        ${this.showValue && !this.compact ? qe`
            <output for=${this.key}>
              ${this.formatLabel()}
            </output>
          ` : ""}
      </div>
    `;
  }
};
ci.styles = [
  ra,
  Nt`
      div {
        display: flex;
        flex-direction: row;
        gap: 0.5rem;
        align-items: flex-start;
      }
      div.compact {
        flex-direction: column;
        gap: 0;
      }
      input {
        width: var(--width, unset);
      }
    `
];
_s([
  Ke()
], ci.prototype, "label", 2);
_s([
  Ke({ type: String })
], ci.prototype, "key", 2);
_s([
  Ke({ type: Number })
], ci.prototype, "value", 1);
_s([
  Ke({ type: Boolean })
], ci.prototype, "showValue", 2);
_s([
  Ke({ type: Boolean })
], ci.prototype, "compact", 2);
_s([
  Ke({ type: Number })
], ci.prototype, "min", 2);
_s([
  Ke({ type: Number })
], ci.prototype, "max", 2);
_s([
  Ke({ type: Number })
], ci.prototype, "lowBound", 2);
_s([
  Ke({ type: Number })
], ci.prototype, "highBound", 2);
_s([
  Ke({ type: Number })
], ci.prototype, "step", 2);
_s([
  Ke({ type: Boolean })
], ci.prototype, "percent", 2);
ci = _s([
  Dt("fizz-slider")
], ci);
var Ase = Object.defineProperty, kse = Object.getOwnPropertyDescriptor, Pg = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? kse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && Ase(e, r, i), i;
};
let CN = class {
  constructor(e, r, n, i, s) {
    this.key = e, this.descriptor = r, this.checked = n, this.type = i, this.group = s, this._inputRef = Et();
  }
  get input() {
    return this._inputRef.value;
  }
  classMap() {
    return { [this.type]: !0 };
  }
  render() {
    return qe`
      <label class=${Br(this.classMap())} title=${this.descriptor.title ?? De} for=${this.key}>
        <input
          ${yt(this._inputRef)}
          id=${this.key}
          type="radio"
          name="radio"
          .checked=${this.checked}
          @change=${(e) => this.group.dispatchEvent(
      new CustomEvent("select", { bubbles: !0, composed: !0, detail: this.key })
    )}
        />
        ${this.content()}
      </label>
    `;
  }
};
const IN = class extends CN {
  constructor(e, r, n, i) {
    super(e, r, n, "plain", i);
  }
  classMap() {
    const e = super.classMap();
    return e[`layout-${this.group.layout}`] = !0, e;
  }
  content() {
    return qe`
      <span class="main">
        ${this.descriptor.label}
      </span>
      ${this.descriptor.subLabel ? qe`
        <span class="sub">${this.descriptor.subLabel}</span>
      ` : ""}
    `;
  }
};
IN.styles = Nt`
    label.plain {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
    }
    label.plain.layout-compress {
      flex-direction: column;
      gap: 0;
    }
    label.plain span {
      text-align: center;
    }
  `;
let PN = IN;
const RN = class extends CN {
  constructor(e, r, n, i) {
    super(e, r, n, "icon", i);
  }
  content() {
    return qe`
      <div class="tile">
        ${this.descriptor.icon ? qe`
          <img src=${this.descriptor.icon} alt="">
        ` : ""}
        <span>
          ${this.descriptor.label}
          ${this.descriptor.subLabel ? qe`<br>${this.descriptor.subLabel}` : ""}
        </span>
      </div>
    `;
  }
};
RN.styles = Nt`
    label.icon {
      position: relative;
      height: 4rem;
      width: 4rem;
    }
    img {
      width: 3.2rem;
      background: inherit;
    }
    label.icon input {
      opacity: 0;
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
      margin: 0;
      cursor: pointer;
    }
    .tile {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
      width: 100%;
      height: 100%;
      border: 2px solid var(--theme-color-light, unset);
      border-radius: 5px;
      padding: 0.5rem;
      transition: transform 300ms ease;
    }
    label.icon span {
      text-align: center;
      font-size: 0.7rem;
      font-weight: 550;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--theme-text-color, unset);
    }
    label.icon input:checked + .tile {
      background-color: var(--theme-color-light, unset);
      border: 2px solid var(--theme-color-light, unset);
      color: var(--theme-text-color, unset);
      font-weight: 700;
      transform: scale(1.1, 1.1);
    }
    label.icon input:checked + .tile span {
      color: var(--theme-text-color, unset);
      background-color: var(--theme-color-light, unset);
    }
  `;
let ON = RN, ch = class extends $r {
  constructor() {
    super(...arguments), this.buttons = {}, this.layout = "horiz", this.wrap = !1, this.radios = {};
  }
  /*protected firstUpdated(_changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>): void {
    this.dispatchEvent(
      new CustomEvent('radiofirstupdate', {
        bubbles: true,
        composed: true
      }));
  }*/
  connectedCallback() {
    super.connectedCallback(), this.selected ?? (this.selected = Object.keys(this.buttons)[0]);
  }
  updated(e) {
    if (e.has("selected"))
      for (const [r, n] of Object.entries(this.radios))
        n.input.checked = r === this.selected;
  }
  render() {
    const e = this.buttons[Object.keys(this.buttons)[0]].icon ? ON : PN;
    this.radios = {};
    for (const [n, i] of Object.entries(this.buttons))
      this.radios[n] = new e(n, i, n === this.selected, this);
    const r = {
      wrapper: !0,
      [this.layout]: !0,
      wrap: this.wrap
    };
    return qe`
      <fieldset>
        <legend>
          <slot name="legend"></slot>
        </legend>
        <div class=${Br(r)}>
          ${Object.entries(this.radios).map(([n, i]) => i.render())}
        </div>
      </fieldset>
    `;
  }
};
ch.styles = [
  ra,
  Nt`
      :host * {
        box-sizing: border-box;
      }
      .wrapper {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
      }
      .wrapper.vert {
        flex-direction: column;
        align-items: flex-start;
        width: min-content;
        margin-left: auto;
        margin-right: auto;
      }
      .wrapper.wrap {
        flex-wrap: wrap;
      }
      fieldset {
        border: var(--border, none);
        padding: 0;
        margin: 0;
      }
      legend {
        border-radius: var(--legend-border-radius, 0.15rem);
        padding: 0.25rem 0.5rem;
        margin-left: auto;
        margin-right: auto;
        background: var(--legend-background, unset);
        color: var(--legend-color, unset);
      }
    `,
  PN.styles,
  ON.styles
];
Pg([
  Ke({ type: Object })
], ch.prototype, "buttons", 2);
Pg([
  Ke()
], ch.prototype, "selected", 2);
Pg([
  Ke()
], ch.prototype, "layout", 2);
Pg([
  Ke({ type: Boolean })
], ch.prototype, "wrap", 2);
ch = Pg([
  Dt("fizz-radiogroup")
], ch);
var _se = Object.defineProperty, Cse = Object.getOwnPropertyDescriptor, no = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Cse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && _se(e, r, i), i;
};
let Gi = class extends $r {
  constructor() {
    super(...arguments), this.open = !1, this.default = 0, this.tabLabelMode = "labels", this.openButtonAriaLabel = "Open or close tabbed interface", this.tabListAriaLabel = "Tabs", this.tabLabels = [], this._tabIcons = [], this._hiddenTabs = [], this._detailsRef = Et(), this._tabRefs = [], this._panelsWrapperRef = Et(), this._allPanelContents = [], this._ready = !1;
  }
  set selectedTab(e) {
    this._selectedTab = e, this._tabRefs[e].value.focus();
  }
  get selectedTab() {
    return this._selectedTab;
  }
  connectedCallback() {
    super.connectedCallback(), this._selectedTab = this.default;
  }
  firstUpdated(e) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  updated(e) {
    var r;
    e.get("tabLabels") && this.tabLabels.length, this._tabRefs.length && ((r = this._tabRefs[this.selectedTab].value) == null || r.scrollIntoView({ behavior: "smooth", block: "nearest" })), this._allPanelContents.length && !this._ready && (this._ready = !0, this.dispatchEvent(new CustomEvent("ready", { bubbles: !0, composed: !0 })));
  }
  hide(e) {
    if (this.tabLabels.indexOf(e) === -1)
      throw new Error(`no tab with label '${e}'`);
    this._hiddenTabs.includes(e) || (this._hiddenTabs = [...this._hiddenTabs, e]);
  }
  show(e) {
    if (!this.tabLabels.includes(e))
      throw new Error(`no tab with label '${e}'`);
    const r = this._hiddenTabs.indexOf(e);
    r !== -1 && (this._hiddenTabs = this._hiddenTabs.toSpliced(r, 1));
  }
  _activateTab(e, r) {
    e.preventDefault(), e.stopPropagation(), this.selectedTab = r;
  }
  _renderTab(e, r) {
    var n;
    if ((n = this._tabRefs)[r] ?? (n[r] = Et()), this._hiddenTabs.includes(e))
      return qe``;
    const i = this.selectedTab === r, s = {
      hidden: this.tabLabelMode === "icons" || this.tabLabelMode === "icons-current-label" && !i
    }, o = {
      icon: this.tabLabelMode !== "labels"
    }, a = {
      mask: this._tabIcons[r] ? `url("${this._tabIcons[r]}") no-repeat 50% 50%` : void 0,
      "mask-size": "cover"
    };
    return qe`
      <li
        role="presentation"
      >
        <button
          ${yt(this._tabRefs[r])}
          role="tab"
          id="tab${r}"
          tabindex=${i ? De : -1}
          aria-selected=${i ? "true" : "false"}
          aria-controls="panel${r}"
          class="tab"
          @keydown=${(l) => {
      l.key === "ArrowLeft" || l.key === "ArrowUp" ? this._activateTab(l, r === 0 ? this.tabLabels.length - 1 : r - 1) : (l.key === "ArrowRight" || l.key === "ArrowDown") && this._activateTab(l, (r + 1) % this.tabLabels.length);
    }}
          @click=${(l) => this._activateTab(l, r)}
        >
          ${this._tabIcons[r] ? qe`
            <span
              class=${Br(o)}
              style=${mn(a)}
            >
            </span>
          ` : ""}
          <span class=${Br(s)}>
            ${e}
          </span>
        </button>
      </li>
    `;
  }
  _absorbPanels() {
    this._allPanelContents = this._panelEls.map((e) => e.contentNodes), this._panelEls.forEach((e) => e.remove()), this.requestUpdate();
  }
  render() {
    return qe`
      <details
        ${yt(this._detailsRef)}
        ?open=${this.open}
        @toggle=${() => {
      this.dispatchEvent(new CustomEvent(
        this.open ? "open" : "close",
        { bubbles: !0, composed: !0 }
      ));
    }}>
        <summary
          tabindex="0"
          aria-label=${this.openButtonAriaLabel}
          @click=${(e) => {
      e.preventDefault(), this.open = !this._detailsRef.value.open;
    }}
        >
          <menu
            role="tablist"
            class="tablist ${this.open ? "" : "hidden"}"
            aria-label=${this.tabListAriaLabel}
          >
            ${this.tabLabels.map((e, r) => this._renderTab(e, r))}
          </menu>
        </summary>
        <div class="panels"
          ${yt(this._panelsWrapperRef)}
        >
          ${this._allPanelContents.map((e, r) => qe`
              <section
                id="panel${r}"
                ?hidden=${this._hiddenTabs.includes(this.tabLabels[r])}
                tabindex="0"
                role="tabpanel"
                aria-labelledby="tab${r}"
                class="panel ${this.selectedTab === r ? "" : "hidden"}"
              >
                ${e}
              </section>
            `)}
          <slot @slotchange=${(e) => {
      var r;
      if (!this.tabLabels.length)
        if (this.tabLabels = this._panelEls.map((n) => n.tabLabel), (r = this._panelEls[0]) != null && r.icon && (this._tabIcons = this._panelEls.map((n, i) => {
          if (n.id = `panel${i}`, n.icon)
            return n.icon;
          throw new Error(`panel '${n.tabLabel}' icon missing`);
        })), this._panelEls.forEach((n) => {
          n.hidden && this.hide(n.tabLabel);
        }), this._panelEls.map((n) => n.hasUpdated).every((n) => n))
          this._absorbPanels();
        else {
          const n = this._panelEls.filter((i) => !i.hasUpdated);
          n.forEach((i) => i.addEventListener("firstupdate", (s) => {
            s.stopPropagation(), n.map((o) => o.hasUpdated).every((o) => o) && this._absorbPanels();
          }, { once: !0 }));
        }
    }}></slot>
        </div>
      </details>
    `;
  }
};
Gi.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      details {
        background: var(--background, var(--theme-contrast-color));
        color: var(--color, black);
        border-radius: var(--border-radius, 0.15rem);
      }

      summary {
        background: var(--summary-background, var(--theme-color));
        border-radius: var(--summary-border-radius, 0);
        padding: 0;
        padding-top: 2px;
        padding-left: 2px;
        list-style-type: none;
      }
      summary::before {
        display: inline-block;
        width: var(--summary-marker-size, 1.1rem);
        height: var(--summary-marker-size, 1.1rem);
        margin-left: 2px;
        margin-top: 2px;
        margin-right: 2px;
        padding: 1px;
        content: '';
        background-color: var(--summary-marker-color, ghostwhite);
        mask-image: var(--summary-marker-icon, url(${Ju(C5)}));
        mask-size: cover;
        cursor: pointer;
        z-index: 1;
      }

      details {
        border: var(--border, 1px solid var(--theme-color));
      }
      details[open] summary {
        border-radius: var(--summary-border-radius-open, 0);
      }
      details:not([open]) {
        /*
          marker width + marker margins + marker padding + summary left padding
          + summary left padding added on the right
        */
        width: calc(1.1rem + 4px + 2px + 2px + 2px);
        background: none;
        /*
          Keep the icon from moving by making the border transparent
          rather than removing it
        */
        border: 1px solid transparent;
      }
      details:not([open]) summary::before {
        background-color: var(--theme-color, ghostwhite);
      }
      details:not([open]) summary {
        background: none;
      }
      .panels {
        background: var(--contents-background, var(--theme-contrast-color));
        padding: var(--contents-padding, 0 0.25rem);
        margin: var(--contents-margin, 0);
        overflow: var(--contents-overflow, hidden);
        border-radius: var(--border-radius, 0 0 0.15rem 0.15rem);
        z-index: 3;
      }
      .tablist {
        display: inline-flex;
        padding: 0;
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
        gap: var(--tab-gap, 0);
        font-size: var(--tab-font-size, unset);
        font-weight: var(--tab-font-weight, unset);
        margin: 0;
        background: none;
        flex-grow: 1;
        width: calc(100% - 2rem);
      }
      li {
        list-style-type: none;
      }
      .tab {
        padding: var(--padding, 0.25rem 0.4rem);
        cursor: pointer;
        border: none;
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
      }
      [role='tab'] {
        color: var(--background-selected, var(--theme-unselected-text-color, var(--theme-extra-color)));
        background: none;
      }
      [role='tab'][aria-selected='true'] {
        background: var(--background-selected, var(--theme-extra-color));
        color: var(--theme-text-color, var(--color-selected, var(--theme-color)));
        text-decoration: var(--theme-selected-text-decoration) var(--theme-text-color);
        text-underline-offset: 0.25rem;
      }
      .icon {
        height: 1rem;
        width: 1rem;
        vertical-align: middle;
        background-color: currentColor;
        display: inline-block;
      }
      @media screen and (max-width: 600px) {
        .tablist {
          flex-direction: column;
          overflow-y: scroll;
          height: 3.5rem;
          /*gap: 0.1rem;*/
        }
        .tab {
          width: 100%;
        }
      }
    `
];
no([
  Ke({ type: Boolean })
], Gi.prototype, "open", 2);
no([
  Ke({ type: Number })
], Gi.prototype, "default", 2);
no([
  Ke()
], Gi.prototype, "tabLabelMode", 2);
no([
  Ke()
], Gi.prototype, "openButtonAriaLabel", 2);
no([
  Ke()
], Gi.prototype, "tabListAriaLabel", 2);
no([
  Vr()
], Gi.prototype, "tabLabels", 2);
no([
  Vr()
], Gi.prototype, "_tabIcons", 2);
no([
  Vr()
], Gi.prototype, "_hiddenTabs", 2);
no([
  Vr()
], Gi.prototype, "selectedTab", 1);
no([
  Cg()
], Gi.prototype, "_panelEls", 2);
Gi = no([
  Dt("fizz-tab-details")
], Gi);
var Ise = Object.defineProperty, Pse = Object.getOwnPropertyDescriptor, io = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Pse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && Ise(e, r, i), i;
};
let Wi = class extends $r {
  constructor() {
    super(...arguments), this.open = !1, this.default = 0, this.tabLabelMode = "labels", this.tabListAriaLabel = "Tabs", this.openButtonAriaLabel = "Toggle tab panel", this._tabLabels = [], this._tabIcons = [], this._hiddenTabs = [], this._tabRefs = [], this._panelsWrapperRef = Et(), this._allPanelContents = [], this._ready = !1;
  }
  set selectedTab(e) {
    this._selectedTab = e, this._tabRefs[e].value.focus();
  }
  get selectedTab() {
    return this._selectedTab;
  }
  connectedCallback() {
    super.connectedCallback(), this._selectedTab = this.default;
  }
  firstUpdated(e) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  updated(e) {
    var r;
    this._tabRefs.length && ((r = this._tabRefs[this.selectedTab].value) == null || r.scrollIntoView({ behavior: "smooth", block: "nearest" })), this._allPanelContents.length && !this._ready && (this._ready = !0, this.dispatchEvent(new CustomEvent("ready", { bubbles: !0, composed: !0 })));
  }
  hide(e) {
    if (this._tabLabels.indexOf(e) === -1)
      throw new Error(`no tab with label '${e}'`);
    this._hiddenTabs.includes(e) || (this._hiddenTabs = [...this._hiddenTabs, e]);
  }
  show(e) {
    if (!this._tabLabels.includes(e))
      throw new Error(`no tab with label '${e}'`);
    const r = this._hiddenTabs.indexOf(e);
    r !== -1 && (this._hiddenTabs = this._hiddenTabs.toSpliced(r, 1));
  }
  _activateTab(e, r) {
    e.preventDefault(), e.stopPropagation(), this.selectedTab = r;
  }
  _renderTab(e, r) {
    var n;
    if ((n = this._tabRefs)[r] ?? (n[r] = Et()), this._hiddenTabs.includes(e))
      return qe``;
    const i = this.selectedTab === r, s = {
      mask: this._tabIcons[r] ? `url("${this._tabIcons[r]}") no-repeat 50% 50%` : void 0,
      "mask-size": "cover"
    }, o = this.tabLabelMode === "icons" || this.tabLabelMode === "icons-labels" || this.tabLabelMode === "icons-current-label" && i, a = this.tabLabelMode === "labels" || this.tabLabelMode === "icons-labels" || this.tabLabelMode === "icons-current-label" && i;
    return qe`
      <li role="presentation">
        <button
          ${yt(this._tabRefs[r])}
          role="tab"
          id="tab${r}"
          tabindex=${i ? De : -1}
          aria-selected=${i ? "true" : "false"}
          aria-controls="panel${r}"
          class="tab"
          @keydown=${(l) => {
      l.key === "ArrowLeft" || l.key === "ArrowUp" ? this._activateTab(l, r === 0 ? this._tabLabels.length - 1 : r - 1) : (l.key === "ArrowRight" || l.key === "ArrowDown") && this._activateTab(l, (r + 1) % this._tabLabels.length);
    }}
          @click=${(l) => this._activateTab(l, r)}
        >
          ${o && this._tabIcons[r] ? qe`<span class="icon" style=${mn(s)}></span>` : De}
          ${a ? qe`<span>${e}</span>` : De}
        </button>
      </li>
    `;
  }
  _absorbPanels() {
    this._allPanelContents = this._panelEls.map((e) => e.contentNodes), this._panelEls.forEach((e) => e.remove()), this.requestUpdate();
  }
  render() {
    const e = qe`
      <button
        class="toggle"
        @click=${() => {
      this.open = !this.open, this.dispatchEvent(new CustomEvent(
        this.open ? "open" : "close",
        { bubbles: !0, composed: !0 }
      ));
    }}
		aria-label=${this.openButtonAriaLabel}
		aria-expanded=${this.open}
        aria-controls="tabs-container"
      ></button>
    `;
    return qe`
      <div id="tabs-container" class=${this.open ? "open" : ""}>
        ${this.open ? qe`
          <div class="tablist-wrapper">
            ${e}
            <ul
              role="tablist"
              class="tablist"
              aria-label=${this.tabListAriaLabel}
            >
              ${this._tabLabels.map((r, n) => this._renderTab(r, n))}
            </ul>
          </div>

          <div class="panels" ${yt(this._panelsWrapperRef)}>
            ${this._allPanelContents.map((r, n) => qe`
              <section
                id="panel${n}"
                ?hidden=${this._hiddenTabs.includes(this._tabLabels[n])}
                tabindex="0"
                role="tabpanel"
                aria-labelledby="tab${n}"
                class="panel ${this.selectedTab === n ? "" : "hidden"}"
              >
                ${r}
              </section>
            `)}
            <slot @slotchange=${(r) => {
      var n;
      if (!this._tabLabels.length)
        if (this._tabLabels = this._panelEls.map((i) => i.tabLabel), (n = this._panelEls[0]) != null && n.icon && (this._tabIcons = this._panelEls.map((i, s) => {
          if (i.id = `panel${s}`, i.icon) return i.icon;
          throw new Error(`panel '${i.tabLabel}' icon missing`);
        })), this._panelEls.forEach((i) => {
          i.hidden && this.hide(i.tabLabel);
        }), this._panelEls.map((i) => i.hasUpdated).every((i) => i))
          this._absorbPanels();
        else {
          const i = this._panelEls.filter((s) => !s.hasUpdated);
          i.forEach(
            (s) => s.addEventListener("firstupdate", (o) => {
              o.stopPropagation(), i.map((a) => a.hasUpdated).every((a) => a) && this._absorbPanels();
            }, { once: !0 })
          );
        }
    }}></slot>
          </div>` : qe`
          ${e}
        `}
      </div>
    `;
  }
};
Wi.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }

      #tabs-container {
        display: grid;
        border-radius: var(--border-radius, 0.15rem);
      }
      #tabs-container.open {
        border: 1px solid var(--theme-color);
      }

      button.toggle {
        width: var(--toggle-button-size, 1.1rem);
        height: var(--toggle-button-size, 1.1rem);
        background-color: var(--toggle-button-color, ghostwhite);
        mask-image: var(--toggle-button-icon, url(${Ju(C5)}));
        mask-size: cover;
        border: none;
        cursor: pointer;
        vertical-align: text-top;
        padding: 0 0.25rem;
      }
      #tabs-container.open button.toggle {
        justify-self: center;
        align-self: center;
      }
      #tabs-container:not(.open) button.toggle {
        background-color: var(--theme-color, ghostwhite);
      }

      .tablist-wrapper {
        display: grid;
        grid-template-columns: 1.5rem 1fr;
        background: var(--tablist-background, var(--theme-color));
        margin: 0;
      }

      .tablist {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 0;
        margin: 0;
        padding: 0;
      }

      li {
        display: contents;
        list-style-type: none;
        margin: 0;
      }

      .tab {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: var(--tab-padding, 0.25rem 0.4rem);
        border: none;
        border-radius: var(--border-radius, 0.1rem) var(--border-radius, 0.1rem) 0 0;
        cursor: pointer;
        background: none;
        font-size: var(--tab-font-size);
        font-weight: var(--tab-font-weight);
        margin: 0;
      }

      [role='tab'] {
        color: var(--theme-unselected-text-color);
      }

      [role='tab'][aria-selected='true'] {
        background: var(--theme-extra-color);
        color: var(--theme-text-color);
        text-decoration: var(--theme-selected-text-decoration);
        text-underline-offset: 0.25rem;
      }

      .icon {
        height: 1rem;
        width: 1rem;
        vertical-align: middle;
        background-color: currentColor;
        display: inline-block;
      }

      .panels {
        background: var(--theme-contrast-color);
        padding: var(--contents-padding);
        margin: 0;
        border-radius: 0 0 var(--border-radius, 0.1rem) var(--border-radius, 0.1rem);
      }

      @media screen and (max-width: 600px) {
        .tablist {
          flex-direction: column;
          overflow-y: auto;
          height: 3.5rem;
        }

        .tab {
          width: 100%;
        }
      }
    `
];
io([
  Ke({ type: Boolean, reflect: !0, useDefault: !0 })
], Wi.prototype, "open", 2);
io([
  Ke({ type: Number })
], Wi.prototype, "default", 2);
io([
  Ke()
], Wi.prototype, "tabLabelMode", 2);
io([
  Ke()
], Wi.prototype, "tabListAriaLabel", 2);
io([
  Ke({ type: String, attribute: "openbuttonarialabel" })
], Wi.prototype, "openButtonAriaLabel", 2);
io([
  Vr()
], Wi.prototype, "_tabLabels", 2);
io([
  Vr()
], Wi.prototype, "_tabIcons", 2);
io([
  Vr()
], Wi.prototype, "_hiddenTabs", 2);
io([
  Vr()
], Wi.prototype, "selectedTab", 1);
io([
  Cg()
], Wi.prototype, "_panelEls", 2);
Wi = io([
  Dt("fizz-tabs")
], Wi);
var Rse = Object.defineProperty, Ose = Object.getOwnPropertyDescriptor, Rg = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Ose(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && Rse(e, r, i), i;
};
let uh = class extends ts {
  constructor() {
    super(...arguments), this.title = "", this.btnText = "Close", this.contentArray = [], this._dialogRef = Et();
  }
  render() {
    const t = [{ tag: "cancel", text: this.btnText }];
    return qe`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="${this.title}"
        .buttons=${t}
      >
        ${this._content}
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   * @param contentArray - status bar display contentArray.
   */
  // async show(title: string, contentArray: string[]) {
  async show(t, e = qe``) {
    this.title = t, this._content = e, await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
uh.styles = Nt`
    .contentArray {
      align-self: stretch;
    }

    button {
      margin: 0.2rem;
      background-color: var(--theme-color);
      color: var(--theme-contrast-color);
      border: thin solid var(--theme-color);
      border-radius: 0.2em;
      padding: 0.2em;
    }


    pre {
      height: 60vh;
      width: 80vw;
      padding: 1rem;
      overflow-y:
      scroll; background-color:
      black; color: white;
    }

    table {
      border-collapse: collapse;
      margin: 0 2rem;
    }

    th, td {
      border-bottom: 1px solid hsl(0, 0%, 75%);
      padding: 0.35em 2.5em;
      text-align: left;
    }

    tbody th {
      font-weight: normal;
      padding-left: 0;
    }

    td:last-of-type {
      padding-right: 0;
    }
  `;
Rg([
  Ke()
], uh.prototype, "title", 2);
Rg([
  Ke()
], uh.prototype, "btnText", 2);
Rg([
  Ke({ type: Array })
], uh.prototype, "contentArray", 2);
Rg([
  Vr()
], uh.prototype, "_content", 2);
uh = Rg([
  Dt("para-dialog")
], uh);
var Tse = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Lse(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var TN = { exports: {} };
/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/
(function(t, e) {
  ((r, n) => {
    t.exports = n();
  })(Tse, function r() {
    var n = typeof self < "u" ? self : typeof window < "u" ? window : n !== void 0 ? n : {}, i, s = !n.document && !!n.postMessage, o = n.IS_PAPA_WORKER || !1, a = {}, l = 0, c = {};
    function p(R) {
      this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = { data: [], errors: [], meta: {} }, (function(L) {
        var F = v(L);
        F.chunkSize = parseInt(F.chunkSize), L.step || L.chunk || (F.chunkSize = null), this._handle = new w(F), (this._handle.streamer = this)._config = F;
      }).call(this, R), this.parseChunk = function(L, F) {
        var z = parseInt(this._config.skipFirstNLines) || 0;
        if (this.isFirstChunk && 0 < z) {
          let ee = this._config.newline;
          ee || (j = this._config.quoteChar || '"', ee = this._handle.guessLineEndings(L, j)), L = [...L.split(ee).slice(z)].join(ee);
        }
        this.isFirstChunk && S(this._config.beforeFirstChunk) && (j = this._config.beforeFirstChunk(L)) !== void 0 && (L = j), this.isFirstChunk = !1, this._halted = !1;
        var z = this._partialLine + L, j = (this._partialLine = "", this._handle.parse(z, this._baseIndex, !this._finished));
        if (!this._handle.paused() && !this._handle.aborted()) {
          if (L = j.meta.cursor, z = (this._finished || (this._partialLine = z.substring(L - this._baseIndex), this._baseIndex = L), j && j.data && (this._rowCount += j.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview), o) n.postMessage({ results: j, workerId: c.WORKER_ID, finished: z });
          else if (S(this._config.chunk) && !F) {
            if (this._config.chunk(j, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
            this._completeResults = j = void 0;
          }
          return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(j.data), this._completeResults.errors = this._completeResults.errors.concat(j.errors), this._completeResults.meta = j.meta), this._completed || !z || !S(this._config.complete) || j && j.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), z || j && j.meta.paused || this._nextChunk(), j;
        }
        this._halted = !0;
      }, this._sendError = function(L) {
        S(this._config.error) ? this._config.error(L) : o && this._config.error && n.postMessage({ workerId: c.WORKER_ID, error: L, finished: !1 });
      };
    }
    function h(R) {
      var L;
      (R = R || {}).chunkSize || (R.chunkSize = c.RemoteChunkSize), p.call(this, R), this._nextChunk = s ? function() {
        this._readChunk(), this._chunkLoaded();
      } : function() {
        this._readChunk();
      }, this.stream = function(F) {
        this._input = F, this._nextChunk();
      }, this._readChunk = function() {
        if (this._finished) this._chunkLoaded();
        else {
          if (L = new XMLHttpRequest(), this._config.withCredentials && (L.withCredentials = this._config.withCredentials), s || (L.onload = k(this._chunkLoaded, this), L.onerror = k(this._chunkError, this)), L.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !s), this._config.downloadRequestHeaders) {
            var F, z = this._config.downloadRequestHeaders;
            for (F in z) L.setRequestHeader(F, z[F]);
          }
          var j;
          this._config.chunkSize && (j = this._start + this._config.chunkSize - 1, L.setRequestHeader("Range", "bytes=" + this._start + "-" + j));
          try {
            L.send(this._config.downloadRequestBody);
          } catch (ee) {
            this._chunkError(ee.message);
          }
          s && L.status === 0 && this._chunkError();
        }
      }, this._chunkLoaded = function() {
        L.readyState === 4 && (L.status < 200 || 400 <= L.status ? this._chunkError() : (this._start += this._config.chunkSize || L.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((F) => (F = F.getResponseHeader("Content-Range")) !== null ? parseInt(F.substring(F.lastIndexOf("/") + 1)) : -1)(L), this.parseChunk(L.responseText)));
      }, this._chunkError = function(F) {
        F = L.statusText || F, this._sendError(new Error(F));
      };
    }
    function d(R) {
      (R = R || {}).chunkSize || (R.chunkSize = c.LocalChunkSize), p.call(this, R);
      var L, F, z = typeof FileReader < "u";
      this.stream = function(j) {
        this._input = j, F = j.slice || j.webkitSlice || j.mozSlice, z ? ((L = new FileReader()).onload = k(this._chunkLoaded, this), L.onerror = k(this._chunkError, this)) : L = new FileReaderSync(), this._nextChunk();
      }, this._nextChunk = function() {
        this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
      }, this._readChunk = function() {
        var j = this._input, ee = (this._config.chunkSize && (ee = Math.min(this._start + this._config.chunkSize, this._input.size), j = F.call(j, this._start, ee)), L.readAsText(j, this._config.encoding));
        z || this._chunkLoaded({ target: { result: ee } });
      }, this._chunkLoaded = function(j) {
        this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(j.target.result);
      }, this._chunkError = function() {
        this._sendError(L.error);
      };
    }
    function b(R) {
      var L;
      p.call(this, R = R || {}), this.stream = function(F) {
        return L = F, this._nextChunk();
      }, this._nextChunk = function() {
        var F, z;
        if (!this._finished) return F = this._config.chunkSize, L = F ? (z = L.substring(0, F), L.substring(F)) : (z = L, ""), this._finished = !L, this.parseChunk(z);
      };
    }
    function m(R) {
      p.call(this, R = R || {});
      var L = [], F = !0, z = !1;
      this.pause = function() {
        p.prototype.pause.apply(this, arguments), this._input.pause();
      }, this.resume = function() {
        p.prototype.resume.apply(this, arguments), this._input.resume();
      }, this.stream = function(j) {
        this._input = j, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
      }, this._checkIsFinished = function() {
        z && L.length === 1 && (this._finished = !0);
      }, this._nextChunk = function() {
        this._checkIsFinished(), L.length ? this.parseChunk(L.shift()) : F = !0;
      }, this._streamData = k(function(j) {
        try {
          L.push(typeof j == "string" ? j : j.toString(this._config.encoding)), F && (F = !1, this._checkIsFinished(), this.parseChunk(L.shift()));
        } catch (ee) {
          this._streamError(ee);
        }
      }, this), this._streamError = k(function(j) {
        this._streamCleanUp(), this._sendError(j);
      }, this), this._streamEnd = k(function() {
        this._streamCleanUp(), z = !0, this._streamData("");
      }, this), this._streamCleanUp = k(function() {
        this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
      }, this);
    }
    function w(R) {
      var L, F, z, j, ee = Math.pow(2, 53), X = -ee, ie = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, ce = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, ke = this, ye = 0, Ce = 0, Ie = !1, Te = !1, ue = [], O = { data: [], errors: [], meta: {} };
      function N(te) {
        return R.skipEmptyLines === "greedy" ? te.join("").trim() === "" : te.length === 1 && te[0].length === 0;
      }
      function Z() {
        if (O && z && (le("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + c.DefaultDelimiter + "'"), z = !1), R.skipEmptyLines && (O.data = O.data.filter(function(H) {
          return !N(H);
        })), re()) {
          let H = function(J, Se) {
            S(R.transformHeader) && (J = R.transformHeader(J, Se)), ue.push(J);
          };
          if (O) if (Array.isArray(O.data[0])) {
            for (var te = 0; re() && te < O.data.length; te++) O.data[te].forEach(H);
            O.data.splice(0, 1);
          } else O.data.forEach(H);
        }
        function oe(H, J) {
          for (var Se = R.header ? {} : [], Re = 0; Re < H.length; Re++) {
            var Fe = Re, Le = H[Re], Le = ((ze, tt) => ((Pe) => (R.dynamicTypingFunction && R.dynamicTyping[Pe] === void 0 && (R.dynamicTyping[Pe] = R.dynamicTypingFunction(Pe)), (R.dynamicTyping[Pe] || R.dynamicTyping) === !0))(ze) ? tt === "true" || tt === "TRUE" || tt !== "false" && tt !== "FALSE" && (((Pe) => {
              if (ie.test(Pe) && (Pe = parseFloat(Pe), X < Pe && Pe < ee))
                return 1;
            })(tt) ? parseFloat(tt) : ce.test(tt) ? new Date(tt) : tt === "" ? null : tt) : tt)(Fe = R.header ? Re >= ue.length ? "__parsed_extra" : ue[Re] : Fe, Le = R.transform ? R.transform(Le, Fe) : Le);
            Fe === "__parsed_extra" ? (Se[Fe] = Se[Fe] || [], Se[Fe].push(Le)) : Se[Fe] = Le;
          }
          return R.header && (Re > ue.length ? le("FieldMismatch", "TooManyFields", "Too many fields: expected " + ue.length + " fields but parsed " + Re, Ce + J) : Re < ue.length && le("FieldMismatch", "TooFewFields", "Too few fields: expected " + ue.length + " fields but parsed " + Re, Ce + J)), Se;
        }
        var fe;
        O && (R.header || R.dynamicTyping || R.transform) && (fe = 1, !O.data.length || Array.isArray(O.data[0]) ? (O.data = O.data.map(oe), fe = O.data.length) : O.data = oe(O.data, 0), R.header && O.meta && (O.meta.fields = ue), Ce += fe);
      }
      function re() {
        return R.header && ue.length === 0;
      }
      function le(te, oe, fe, H) {
        te = { type: te, code: oe, message: fe }, H !== void 0 && (te.row = H), O.errors.push(te);
      }
      S(R.step) && (j = R.step, R.step = function(te) {
        O = te, re() ? Z() : (Z(), O.data.length !== 0 && (ye += te.data.length, R.preview && ye > R.preview ? F.abort() : (O.data = O.data[0], j(O, ke))));
      }), this.parse = function(te, oe, fe) {
        var H = R.quoteChar || '"', H = (R.newline || (R.newline = this.guessLineEndings(te, H)), z = !1, R.delimiter ? S(R.delimiter) && (R.delimiter = R.delimiter(te), O.meta.delimiter = R.delimiter) : ((H = ((J, Se, Re, Fe, Le) => {
          var ze, tt, Pe, At;
          Le = Le || [",", "	", "|", ";", c.RECORD_SEP, c.UNIT_SEP];
          for (var er = 0; er < Le.length; er++) {
            for (var me, ht = Le[er], it = 0, kt = 0, Ze = 0, ge = (Pe = void 0, new E({ comments: Fe, delimiter: ht, newline: Se, preview: 10 }).parse(J)), be = 0; be < ge.data.length; be++) Re && N(ge.data[be]) ? Ze++ : (me = ge.data[be].length, kt += me, Pe === void 0 ? Pe = me : 0 < me && (it += Math.abs(me - Pe), Pe = me));
            0 < ge.data.length && (kt /= ge.data.length - Ze), (tt === void 0 || it <= tt) && (At === void 0 || At < kt) && 1.99 < kt && (tt = it, ze = ht, At = kt);
          }
          return { successful: !!(R.delimiter = ze), bestDelimiter: ze };
        })(te, R.newline, R.skipEmptyLines, R.comments, R.delimitersToGuess)).successful ? R.delimiter = H.bestDelimiter : (z = !0, R.delimiter = c.DefaultDelimiter), O.meta.delimiter = R.delimiter), v(R));
        return R.preview && R.header && H.preview++, L = te, F = new E(H), O = F.parse(L, oe, fe), Z(), Ie ? { meta: { paused: !0 } } : O || { meta: { paused: !1 } };
      }, this.paused = function() {
        return Ie;
      }, this.pause = function() {
        Ie = !0, F.abort(), L = S(R.chunk) ? "" : L.substring(F.getCharIndex());
      }, this.resume = function() {
        ke.streamer._halted ? (Ie = !1, ke.streamer.parseChunk(L, !0)) : setTimeout(ke.resume, 3);
      }, this.aborted = function() {
        return Te;
      }, this.abort = function() {
        Te = !0, F.abort(), O.meta.aborted = !0, S(R.complete) && R.complete(O), L = "";
      }, this.guessLineEndings = function(J, H) {
        J = J.substring(0, 1048576);
        var H = new RegExp(f(H) + "([^]*?)" + f(H), "gm"), fe = (J = J.replace(H, "")).split("\r"), H = J.split(`
`), J = 1 < H.length && H[0].length < fe[0].length;
        if (fe.length === 1 || J) return `
`;
        for (var Se = 0, Re = 0; Re < fe.length; Re++) fe[Re][0] === `
` && Se++;
        return Se >= fe.length / 2 ? `\r
` : "\r";
      };
    }
    function f(R) {
      return R.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function E(R) {
      var L = (R = R || {}).delimiter, F = R.newline, z = R.comments, j = R.step, ee = R.preview, X = R.fastMode, ie = null, ce = !1, ke = R.quoteChar == null ? '"' : R.quoteChar, ye = ke;
      if (R.escapeChar !== void 0 && (ye = R.escapeChar), (typeof L != "string" || -1 < c.BAD_DELIMITERS.indexOf(L)) && (L = ","), z === L) throw new Error("Comment character same as delimiter");
      z === !0 ? z = "#" : (typeof z != "string" || -1 < c.BAD_DELIMITERS.indexOf(z)) && (z = !1), F !== `
` && F !== "\r" && F !== `\r
` && (F = `
`);
      var Ce = 0, Ie = !1;
      this.parse = function(Te, ue, O) {
        if (typeof Te != "string") throw new Error("Input must be a string");
        var N = Te.length, Z = L.length, re = F.length, le = z.length, te = S(j), oe = [], fe = [], H = [], J = Ce = 0;
        if (!Te) return it();
        if (X || X !== !1 && Te.indexOf(ke) === -1) {
          for (var Se = Te.split(F), Re = 0; Re < Se.length; Re++) {
            if (H = Se[Re], Ce += H.length, Re !== Se.length - 1) Ce += F.length;
            else if (O) return it();
            if (!z || H.substring(0, le) !== z) {
              if (te) {
                if (oe = [], At(H.split(L)), kt(), Ie) return it();
              } else At(H.split(L));
              if (ee && ee <= Re) return oe = oe.slice(0, ee), it(!0);
            }
          }
          return it();
        }
        for (var Fe = Te.indexOf(L, Ce), Le = Te.indexOf(F, Ce), ze = new RegExp(f(ye) + f(ke), "g"), tt = Te.indexOf(ke, Ce); ; ) if (Te[Ce] === ke) for (tt = Ce, Ce++; ; ) {
          if ((tt = Te.indexOf(ke, tt + 1)) === -1) return O || fe.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: oe.length, index: Ce }), me();
          if (tt === N - 1) return me(Te.substring(Ce, tt).replace(ze, ke));
          if (ke === ye && Te[tt + 1] === ye) tt++;
          else if (ke === ye || tt === 0 || Te[tt - 1] !== ye) {
            Fe !== -1 && Fe < tt + 1 && (Fe = Te.indexOf(L, tt + 1));
            var Pe = er((Le = Le !== -1 && Le < tt + 1 ? Te.indexOf(F, tt + 1) : Le) === -1 ? Fe : Math.min(Fe, Le));
            if (Te.substr(tt + 1 + Pe, Z) === L) {
              H.push(Te.substring(Ce, tt).replace(ze, ke)), Te[Ce = tt + 1 + Pe + Z] !== ke && (tt = Te.indexOf(ke, Ce)), Fe = Te.indexOf(L, Ce), Le = Te.indexOf(F, Ce);
              break;
            }
            if (Pe = er(Le), Te.substring(tt + 1 + Pe, tt + 1 + Pe + re) === F) {
              if (H.push(Te.substring(Ce, tt).replace(ze, ke)), ht(tt + 1 + Pe + re), Fe = Te.indexOf(L, Ce), tt = Te.indexOf(ke, Ce), te && (kt(), Ie)) return it();
              if (ee && oe.length >= ee) return it(!0);
              break;
            }
            fe.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: oe.length, index: Ce }), tt++;
          }
        }
        else if (z && H.length === 0 && Te.substring(Ce, Ce + le) === z) {
          if (Le === -1) return it();
          Ce = Le + re, Le = Te.indexOf(F, Ce), Fe = Te.indexOf(L, Ce);
        } else if (Fe !== -1 && (Fe < Le || Le === -1)) H.push(Te.substring(Ce, Fe)), Ce = Fe + Z, Fe = Te.indexOf(L, Ce);
        else {
          if (Le === -1) break;
          if (H.push(Te.substring(Ce, Le)), ht(Le + re), te && (kt(), Ie)) return it();
          if (ee && oe.length >= ee) return it(!0);
        }
        return me();
        function At(Ze) {
          oe.push(Ze), J = Ce;
        }
        function er(Ze) {
          var ge = 0;
          return ge = Ze !== -1 && (Ze = Te.substring(tt + 1, Ze)) && Ze.trim() === "" ? Ze.length : ge;
        }
        function me(Ze) {
          return O || (Ze === void 0 && (Ze = Te.substring(Ce)), H.push(Ze), Ce = N, At(H), te && kt()), it();
        }
        function ht(Ze) {
          Ce = Ze, At(H), H = [], Le = Te.indexOf(F, Ce);
        }
        function it(Ze) {
          if (R.header && !ue && oe.length && !ce) {
            var ge = oe[0], be = /* @__PURE__ */ Object.create(null), Je = new Set(ge);
            let C = !1;
            for (let $ = 0; $ < ge.length; $++) {
              let D = ge[$];
              if (be[D = S(R.transformHeader) ? R.transformHeader(D, $) : D]) {
                let ae, pe = be[D];
                for (; ae = D + "_" + pe, pe++, Je.has(ae); ) ;
                Je.add(ae), ge[$] = ae, be[D]++, C = !0, (ie = ie === null ? {} : ie)[ae] = D;
              } else be[D] = 1, ge[$] = D;
              Je.add(D);
            }
            C && console.warn("Duplicate headers found and renamed."), ce = !0;
          }
          return { data: oe, errors: fe, meta: { delimiter: L, linebreak: F, aborted: Ie, truncated: !!Ze, cursor: J + (ue || 0), renamedHeaders: ie } };
        }
        function kt() {
          j(it()), oe = [], fe = [];
        }
      }, this.abort = function() {
        Ie = !0;
      }, this.getCharIndex = function() {
        return Ce;
      };
    }
    function A(R) {
      var L = R.data, F = a[L.workerId], z = !1;
      if (L.error) F.userError(L.error, L.file);
      else if (L.results && L.results.data) {
        var j = { abort: function() {
          z = !0, x(L.workerId, { data: [], errors: [], meta: { aborted: !0 } });
        }, pause: g, resume: g };
        if (S(F.userStep)) {
          for (var ee = 0; ee < L.results.data.length && (F.userStep({ data: L.results.data[ee], errors: L.results.errors, meta: L.results.meta }, j), !z); ee++) ;
          delete L.results;
        } else S(F.userChunk) && (F.userChunk(L.results, j, L.file), delete L.results);
      }
      L.finished && !z && x(L.workerId, L.results);
    }
    function x(R, L) {
      var F = a[R];
      S(F.userComplete) && F.userComplete(L), F.terminate(), delete a[R];
    }
    function g() {
      throw new Error("Not implemented.");
    }
    function v(R) {
      if (typeof R != "object" || R === null) return R;
      var L, F = Array.isArray(R) ? [] : {};
      for (L in R) F[L] = v(R[L]);
      return F;
    }
    function k(R, L) {
      return function() {
        R.apply(L, arguments);
      };
    }
    function S(R) {
      return typeof R == "function";
    }
    return c.parse = function(R, L) {
      var F = (L = L || {}).dynamicTyping || !1;
      if (S(F) && (L.dynamicTypingFunction = F, F = {}), L.dynamicTyping = F, L.transform = !!S(L.transform) && L.transform, !L.worker || !c.WORKERS_SUPPORTED) return F = null, c.NODE_STREAM_INPUT, typeof R == "string" ? (R = ((z) => z.charCodeAt(0) !== 65279 ? z : z.slice(1))(R), F = new (L.download ? h : b)(L)) : R.readable === !0 && S(R.read) && S(R.on) ? F = new m(L) : (n.File && R instanceof File || R instanceof Object) && (F = new d(L)), F.stream(R);
      (F = (() => {
        var z;
        return !!c.WORKERS_SUPPORTED && (z = (() => {
          var j = n.URL || n.webkitURL || null, ee = r.toString();
          return c.BLOB_URL || (c.BLOB_URL = j.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", ee, ")();"], { type: "text/javascript" })));
        })(), (z = new n.Worker(z)).onmessage = A, z.id = l++, a[z.id] = z);
      })()).userStep = L.step, F.userChunk = L.chunk, F.userComplete = L.complete, F.userError = L.error, L.step = S(L.step), L.chunk = S(L.chunk), L.complete = S(L.complete), L.error = S(L.error), delete L.worker, F.postMessage({ input: R, config: L, workerId: F.id });
    }, c.unparse = function(R, L) {
      var F = !1, z = !0, j = ",", ee = `\r
`, X = '"', ie = X + X, ce = !1, ke = null, ye = !1, Ce = ((() => {
        if (typeof L == "object") {
          if (typeof L.delimiter != "string" || c.BAD_DELIMITERS.filter(function(ue) {
            return L.delimiter.indexOf(ue) !== -1;
          }).length || (j = L.delimiter), typeof L.quotes != "boolean" && typeof L.quotes != "function" && !Array.isArray(L.quotes) || (F = L.quotes), typeof L.skipEmptyLines != "boolean" && typeof L.skipEmptyLines != "string" || (ce = L.skipEmptyLines), typeof L.newline == "string" && (ee = L.newline), typeof L.quoteChar == "string" && (X = L.quoteChar), typeof L.header == "boolean" && (z = L.header), Array.isArray(L.columns)) {
            if (L.columns.length === 0) throw new Error("Option columns is empty");
            ke = L.columns;
          }
          L.escapeChar !== void 0 && (ie = L.escapeChar + X), L.escapeFormulae instanceof RegExp ? ye = L.escapeFormulae : typeof L.escapeFormulae == "boolean" && L.escapeFormulae && (ye = /^[=+\-@\t\r].*$/);
        }
      })(), new RegExp(f(X), "g"));
      if (typeof R == "string" && (R = JSON.parse(R)), Array.isArray(R)) {
        if (!R.length || Array.isArray(R[0])) return Ie(null, R, ce);
        if (typeof R[0] == "object") return Ie(ke || Object.keys(R[0]), R, ce);
      } else if (typeof R == "object") return typeof R.data == "string" && (R.data = JSON.parse(R.data)), Array.isArray(R.data) && (R.fields || (R.fields = R.meta && R.meta.fields || ke), R.fields || (R.fields = Array.isArray(R.data[0]) ? R.fields : typeof R.data[0] == "object" ? Object.keys(R.data[0]) : []), Array.isArray(R.data[0]) || typeof R.data[0] == "object" || (R.data = [R.data])), Ie(R.fields || [], R.data || [], ce);
      throw new Error("Unable to serialize unrecognized input");
      function Ie(ue, O, N) {
        var Z = "", re = (typeof ue == "string" && (ue = JSON.parse(ue)), typeof O == "string" && (O = JSON.parse(O)), Array.isArray(ue) && 0 < ue.length), le = !Array.isArray(O[0]);
        if (re && z) {
          for (var te = 0; te < ue.length; te++) 0 < te && (Z += j), Z += Te(ue[te], te);
          0 < O.length && (Z += ee);
        }
        for (var oe = 0; oe < O.length; oe++) {
          var fe = (re ? ue : O[oe]).length, H = !1, J = re ? Object.keys(O[oe]).length === 0 : O[oe].length === 0;
          if (N && !re && (H = N === "greedy" ? O[oe].join("").trim() === "" : O[oe].length === 1 && O[oe][0].length === 0), N === "greedy" && re) {
            for (var Se = [], Re = 0; Re < fe; Re++) {
              var Fe = le ? ue[Re] : Re;
              Se.push(O[oe][Fe]);
            }
            H = Se.join("").trim() === "";
          }
          if (!H) {
            for (var Le = 0; Le < fe; Le++) {
              0 < Le && !J && (Z += j);
              var ze = re && le ? ue[Le] : Le;
              Z += Te(O[oe][ze], Le);
            }
            oe < O.length - 1 && (!N || 0 < fe && !J) && (Z += ee);
          }
        }
        return Z;
      }
      function Te(ue, O) {
        var N, Z;
        return ue == null ? "" : ue.constructor === Date ? JSON.stringify(ue).slice(1, 25) : (Z = !1, ye && typeof ue == "string" && ye.test(ue) && (ue = "'" + ue, Z = !0), N = ue.toString().replace(Ce, ie), (Z = Z || F === !0 || typeof F == "function" && F(ue, O) || Array.isArray(F) && F[O] || ((re, le) => {
          for (var te = 0; te < le.length; te++) if (-1 < re.indexOf(le[te])) return !0;
          return !1;
        })(N, c.BAD_DELIMITERS) || -1 < N.indexOf(j) || N.charAt(0) === " " || N.charAt(N.length - 1) === " ") ? X + N + X : N);
      }
    }, c.RECORD_SEP = "", c.UNIT_SEP = "", c.BYTE_ORDER_MARK = "\uFEFF", c.BAD_DELIMITERS = ["\r", `
`, '"', c.BYTE_ORDER_MARK], c.WORKERS_SUPPORTED = !s && !!n.Worker, c.NODE_STREAM_INPUT = 1, c.LocalChunkSize = 10485760, c.RemoteChunkSize = 5242880, c.DefaultDelimiter = ",", c.Parser = E, c.ParserHandle = w, c.NetworkStreamer = h, c.FileStreamer = d, c.StringStreamer = b, c.ReadableStreamStreamer = m, n.jQuery && ((i = n.jQuery).fn.parse = function(R) {
      var L = R.config || {}, F = [];
      return this.each(function(ee) {
        if (!(i(this).prop("tagName").toUpperCase() === "INPUT" && i(this).attr("type").toLowerCase() === "file" && n.FileReader) || !this.files || this.files.length === 0) return !0;
        for (var X = 0; X < this.files.length; X++) F.push({ file: this.files[X], inputElem: this, instanceConfig: i.extend({}, L) });
      }), z(), this;
      function z() {
        if (F.length === 0) S(R.complete) && R.complete();
        else {
          var ee, X, ie, ce, ke = F[0];
          if (S(R.before)) {
            var ye = R.before(ke.file, ke.inputElem);
            if (typeof ye == "object") {
              if (ye.action === "abort") return ee = "AbortError", X = ke.file, ie = ke.inputElem, ce = ye.reason, void (S(R.error) && R.error({ name: ee }, X, ie, ce));
              if (ye.action === "skip") return void j();
              typeof ye.config == "object" && (ke.instanceConfig = i.extend(ke.instanceConfig, ye.config));
            } else if (ye === "skip") return void j();
          }
          var Ce = ke.instanceConfig.complete;
          ke.instanceConfig.complete = function(Ie) {
            S(Ce) && Ce(Ie, ke.file, ke.inputElem), j();
          }, c.parse(ke.file, ke.instanceConfig);
        }
      }
      function j() {
        F.splice(0, 1), z();
      }
    }), o && (n.onmessage = function(R) {
      R = R.data, c.WORKER_ID === void 0 && R && (c.WORKER_ID = R.workerId), typeof R.input == "string" ? n.postMessage({ workerId: c.WORKER_ID, results: c.parse(R.input, R.config), finished: !0 }) : (n.File && R.input instanceof File || R.input instanceof Object) && (R = c.parse(R.input, R.config)) && n.postMessage({ workerId: c.WORKER_ID, results: R, finished: !0 });
    }), (h.prototype = Object.create(p.prototype)).constructor = h, (d.prototype = Object.create(p.prototype)).constructor = d, (b.prototype = Object.create(b.prototype)).constructor = b, (m.prototype = Object.create(p.prototype)).constructor = m, c;
  });
})(TN);
var Mse = TN.exports;
const LN = /* @__PURE__ */ Lse(Mse);
var P5 = Symbol.for("immer-nothing"), Kf = Symbol.for("immer-draftable"), qi = Symbol.for("immer-state"), MN = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(t) {
    return `The plugin for '${t}' has not been loaded into Immer. To enable the plugin, import and call \`enable${t}()\` when initializing your application.`;
  },
  function(t) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${t}'`;
  },
  "This object has been frozen and should not be mutated",
  function(t) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + t;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(t) {
    return `'current' expects a draft, got: ${t}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(t) {
    return `'original' expects a draft, got: ${t}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function nn(t, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const r = MN[t], n = typeof r == "function" ? r.apply(null, e) : r;
    throw new Error(`[Immer] ${n}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var hh = Object.getPrototypeOf;
function ph(t) {
  return !!t && !!t[qi];
}
function Jl(t) {
  var e;
  return t ? NN(t) || Array.isArray(t) || !!t[Kf] || !!((e = t.constructor) != null && e[Kf]) || Og(t) || Tg(t) : !1;
}
var Nse = Object.prototype.constructor.toString();
function NN(t) {
  if (!t || typeof t != "object")
    return !1;
  const e = hh(t);
  if (e === null)
    return !0;
  const r = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return r === Object ? !0 : typeof r == "function" && Function.toString.call(r) === Nse;
}
function k0(t, e) {
  dh(t) === 0 ? Reflect.ownKeys(t).forEach((r) => {
    e(r, t[r], t);
  }) : t.forEach((r, n) => e(n, r, t));
}
function dh(t) {
  const e = t[qi];
  return e ? e.type_ : Array.isArray(t) ? 1 : Og(t) ? 2 : Tg(t) ? 3 : 0;
}
function _0(t, e) {
  return dh(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function Sw(t, e) {
  return dh(t) === 2 ? t.get(e) : t[e];
}
function DN(t, e, r) {
  const n = dh(t);
  n === 2 ? t.set(e, r) : n === 3 ? t.add(r) : t[e] = r;
}
function Dse(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function Og(t) {
  return t instanceof Map;
}
function Tg(t) {
  return t instanceof Set;
}
function Ru(t) {
  return t.copy_ || t.base_;
}
function Hx(t, e) {
  if (Og(t))
    return new Map(t);
  if (Tg(t))
    return new Set(t);
  if (Array.isArray(t))
    return Array.prototype.slice.call(t);
  const r = NN(t);
  if (e === !0 || e === "class_only" && !r) {
    const n = Object.getOwnPropertyDescriptors(t);
    delete n[qi];
    let i = Reflect.ownKeys(n);
    for (let s = 0; s < i.length; s++) {
      const o = i[s], a = n[o];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (n[o] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: t[o]
      });
    }
    return Object.create(hh(t), n);
  } else {
    const n = hh(t);
    if (n !== null && r)
      return { ...t };
    const i = Object.create(n);
    return Object.assign(i, t);
  }
}
function R5(t, e = !1) {
  return Cb(t) || ph(t) || !Jl(t) || (dh(t) > 1 && (t.set = t.add = t.clear = t.delete = $se), Object.freeze(t), e && Object.entries(t).forEach(([r, n]) => R5(n, !0))), t;
}
function $se() {
  nn(2);
}
function Cb(t) {
  return Object.isFrozen(t);
}
var Gx = {};
function fh(t) {
  const e = Gx[t];
  return e || nn(0, t), e;
}
function jse(t, e) {
  Gx[t] || (Gx[t] = e);
}
var C0;
function $N() {
  return C0;
}
function Bse(t, e) {
  return {
    drafts_: [],
    parent_: t,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function O7(t, e) {
  e && (fh("Patches"), t.patches_ = [], t.inversePatches_ = [], t.patchListener_ = e);
}
function Wx(t) {
  qx(t), t.drafts_.forEach(Fse), t.drafts_ = null;
}
function qx(t) {
  t === C0 && (C0 = t.parent_);
}
function T7(t) {
  return C0 = Bse(C0, t);
}
function Fse(t) {
  const e = t[qi];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function L7(t, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const r = e.drafts_[0];
  return t !== void 0 && t !== r ? (r[qi].modified_ && (Wx(e), nn(4)), Jl(t) && (t = Oy(e, t), e.parent_ || Ty(e, t)), e.patches_ && fh("Patches").generateReplacementPatches_(
    r[qi].base_,
    t,
    e.patches_,
    e.inversePatches_
  )) : t = Oy(e, r, []), Wx(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), t !== P5 ? t : void 0;
}
function Oy(t, e, r) {
  if (Cb(e))
    return e;
  const n = e[qi];
  if (!n)
    return k0(
      e,
      (i, s) => M7(t, n, e, i, s, r)
    ), e;
  if (n.scope_ !== t)
    return e;
  if (!n.modified_)
    return Ty(t, n.base_, !0), n.base_;
  if (!n.finalized_) {
    n.finalized_ = !0, n.scope_.unfinalizedDrafts_--;
    const i = n.copy_;
    let s = i, o = !1;
    n.type_ === 3 && (s = new Set(i), i.clear(), o = !0), k0(
      s,
      (a, l) => M7(t, n, i, a, l, r, o)
    ), Ty(t, i, !1), r && t.patches_ && fh("Patches").generatePatches_(
      n,
      r,
      t.patches_,
      t.inversePatches_
    );
  }
  return n.copy_;
}
function M7(t, e, r, n, i, s, o) {
  if (process.env.NODE_ENV !== "production" && i === r && nn(5), ph(i)) {
    const a = s && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !_0(e.assigned_, n) ? s.concat(n) : void 0, l = Oy(t, i, a);
    if (DN(r, n, l), ph(l))
      t.canAutoFreeze_ = !1;
    else
      return;
  } else o && r.add(i);
  if (Jl(i) && !Cb(i)) {
    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1)
      return;
    Oy(t, i), (!e || !e.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(r, n) && Ty(t, i);
  }
}
function Ty(t, e, r = !1) {
  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && R5(e, r);
}
function zse(t, e) {
  const r = Array.isArray(t), n = {
    type_: r ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : $N(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: t,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = n, s = O5;
  r && (i = [n], s = I0);
  const { revoke: o, proxy: a } = Proxy.revocable(i, s);
  return n.draft_ = a, n.revoke_ = o, a;
}
var O5 = {
  get(t, e) {
    if (e === qi)
      return t;
    const r = Ru(t);
    if (!_0(r, e))
      return Vse(t, r, e);
    const n = r[e];
    return t.finalized_ || !Jl(n) ? n : n === Aw(t.base_, e) ? (kw(t), t.copy_[e] = Kx(n, t)) : n;
  },
  has(t, e) {
    return e in Ru(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(Ru(t));
  },
  set(t, e, r) {
    const n = jN(Ru(t), e);
    if (n != null && n.set)
      return n.set.call(t.draft_, r), !0;
    if (!t.modified_) {
      const i = Aw(Ru(t), e), s = i == null ? void 0 : i[qi];
      if (s && s.base_ === r)
        return t.copy_[e] = r, t.assigned_[e] = !1, !0;
      if (Dse(r, i) && (r !== void 0 || _0(t.base_, e)))
        return !0;
      kw(t), Qx(t);
    }
    return t.copy_[e] === r && // special case: handle new props with value 'undefined'
    (r !== void 0 || e in t.copy_) || // special case: NaN
    Number.isNaN(r) && Number.isNaN(t.copy_[e]) || (t.copy_[e] = r, t.assigned_[e] = !0), !0;
  },
  deleteProperty(t, e) {
    return Aw(t.base_, e) !== void 0 || e in t.base_ ? (t.assigned_[e] = !1, kw(t), Qx(t)) : delete t.assigned_[e], t.copy_ && delete t.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(t, e) {
    const r = Ru(t), n = Reflect.getOwnPropertyDescriptor(r, e);
    return n && {
      writable: !0,
      configurable: t.type_ !== 1 || e !== "length",
      enumerable: n.enumerable,
      value: r[e]
    };
  },
  defineProperty() {
    nn(11);
  },
  getPrototypeOf(t) {
    return hh(t.base_);
  },
  setPrototypeOf() {
    nn(12);
  }
}, I0 = {};
k0(O5, (t, e) => {
  I0[t] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
I0.deleteProperty = function(t, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && nn(13), I0.set.call(this, t, e, void 0);
};
I0.set = function(t, e, r) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && nn(14), O5.set.call(this, t[0], e, r, t[0]);
};
function Aw(t, e) {
  const r = t[qi];
  return (r ? Ru(r) : t)[e];
}
function Vse(t, e, r) {
  var i;
  const n = jN(e, r);
  return n ? "value" in n ? n.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = n.get) == null ? void 0 : i.call(t.draft_)
  ) : void 0;
}
function jN(t, e) {
  if (!(e in t))
    return;
  let r = hh(t);
  for (; r; ) {
    const n = Object.getOwnPropertyDescriptor(r, e);
    if (n)
      return n;
    r = hh(r);
  }
}
function Qx(t) {
  t.modified_ || (t.modified_ = !0, t.parent_ && Qx(t.parent_));
}
function kw(t) {
  t.copy_ || (t.copy_ = Hx(
    t.base_,
    t.scope_.immer_.useStrictShallowCopy_
  ));
}
var Use = class {
  constructor(t) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, r, n) => {
      if (typeof e == "function" && typeof r != "function") {
        const s = r;
        r = e;
        const o = this;
        return function(l = s, ...c) {
          return o.produce(l, (p) => r.call(this, p, ...c));
        };
      }
      typeof r != "function" && nn(6), n !== void 0 && typeof n != "function" && nn(7);
      let i;
      if (Jl(e)) {
        const s = T7(this), o = Kx(e, void 0);
        let a = !0;
        try {
          i = r(o), a = !1;
        } finally {
          a ? Wx(s) : qx(s);
        }
        return O7(s, n), L7(i, s);
      } else if (!e || typeof e != "object") {
        if (i = r(e), i === void 0 && (i = e), i === P5 && (i = void 0), this.autoFreeze_ && R5(i, !0), n) {
          const s = [], o = [];
          fh("Patches").generateReplacementPatches_(e, i, s, o), n(s, o);
        }
        return i;
      } else
        nn(1, e);
    }, this.produceWithPatches = (e, r) => {
      if (typeof e == "function")
        return (o, ...a) => this.produceWithPatches(o, (l) => e(l, ...a));
      let n, i;
      return [this.produce(e, r, (o, a) => {
        n = o, i = a;
      }), n, i];
    }, typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze), typeof (t == null ? void 0 : t.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(t.useStrictShallowCopy);
  }
  createDraft(t) {
    Jl(t) || nn(8), ph(t) && (t = Hse(t));
    const e = T7(this), r = Kx(t, void 0);
    return r[qi].isManual_ = !0, qx(e), r;
  }
  finishDraft(t, e) {
    const r = t && t[qi];
    (!r || !r.isManual_) && nn(9);
    const { scope_: n } = r;
    return O7(n, e), L7(void 0, n);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(t) {
    this.autoFreeze_ = t;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(t) {
    this.useStrictShallowCopy_ = t;
  }
  applyPatches(t, e) {
    let r;
    for (r = e.length - 1; r >= 0; r--) {
      const i = e[r];
      if (i.path.length === 0 && i.op === "replace") {
        t = i.value;
        break;
      }
    }
    r > -1 && (e = e.slice(r + 1));
    const n = fh("Patches").applyPatches_;
    return ph(t) ? n(t, e) : this.produce(
      t,
      (i) => n(i, e)
    );
  }
};
function Kx(t, e) {
  const r = Og(t) ? fh("MapSet").proxyMap_(t, e) : Tg(t) ? fh("MapSet").proxySet_(t, e) : zse(t, e);
  return (e ? e.scope_ : $N()).drafts_.push(r), r;
}
function Hse(t) {
  return ph(t) || nn(10, t), BN(t);
}
function BN(t) {
  if (!Jl(t) || Cb(t))
    return t;
  const e = t[qi];
  let r;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, r = Hx(t, e.scope_.immer_.useStrictShallowCopy_);
  } else
    r = Hx(t, !0);
  return k0(r, (n, i) => {
    DN(r, n, BN(i));
  }), e && (e.finalized_ = !1), r;
}
function Gse() {
  process.env.NODE_ENV !== "production" && MN.push(
    'Sets cannot have "replace" patches.',
    function(d) {
      return "Unsupported patch operation: " + d;
    },
    function(d) {
      return "Cannot apply patch, path doesn't resolve: " + d;
    },
    "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
  );
  const e = "replace", r = "add", n = "remove";
  function i(d, b, m, w) {
    switch (d.type_) {
      case 0:
      case 2:
        return o(
          d,
          b,
          m,
          w
        );
      case 1:
        return s(d, b, m, w);
      case 3:
        return a(
          d,
          b,
          m,
          w
        );
    }
  }
  function s(d, b, m, w) {
    let { base_: f, assigned_: E } = d, A = d.copy_;
    A.length < f.length && ([f, A] = [A, f], [m, w] = [w, m]);
    for (let x = 0; x < f.length; x++)
      if (E[x] && A[x] !== f[x]) {
        const g = b.concat([x]);
        m.push({
          op: e,
          path: g,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: h(A[x])
        }), w.push({
          op: e,
          path: g,
          value: h(f[x])
        });
      }
    for (let x = f.length; x < A.length; x++) {
      const g = b.concat([x]);
      m.push({
        op: r,
        path: g,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: h(A[x])
      });
    }
    for (let x = A.length - 1; f.length <= x; --x) {
      const g = b.concat([x]);
      w.push({
        op: n,
        path: g
      });
    }
  }
  function o(d, b, m, w) {
    const { base_: f, copy_: E } = d;
    k0(d.assigned_, (A, x) => {
      const g = Sw(f, A), v = Sw(E, A), k = x ? _0(f, A) ? e : r : n;
      if (g === v && k === e)
        return;
      const S = b.concat(A);
      m.push(k === n ? { op: k, path: S } : { op: k, path: S, value: v }), w.push(
        k === r ? { op: n, path: S } : k === n ? { op: r, path: S, value: h(g) } : { op: e, path: S, value: h(g) }
      );
    });
  }
  function a(d, b, m, w) {
    let { base_: f, copy_: E } = d, A = 0;
    f.forEach((x) => {
      if (!E.has(x)) {
        const g = b.concat([A]);
        m.push({
          op: n,
          path: g,
          value: x
        }), w.unshift({
          op: r,
          path: g,
          value: x
        });
      }
      A++;
    }), A = 0, E.forEach((x) => {
      if (!f.has(x)) {
        const g = b.concat([A]);
        m.push({
          op: r,
          path: g,
          value: x
        }), w.unshift({
          op: n,
          path: g,
          value: x
        });
      }
      A++;
    });
  }
  function l(d, b, m, w) {
    m.push({
      op: e,
      path: [],
      value: b === P5 ? void 0 : b
    }), w.push({
      op: e,
      path: [],
      value: d
    });
  }
  function c(d, b) {
    return b.forEach((m) => {
      const { path: w, op: f } = m;
      let E = d;
      for (let v = 0; v < w.length - 1; v++) {
        const k = dh(E);
        let S = w[v];
        typeof S != "string" && typeof S != "number" && (S = "" + S), (k === 0 || k === 1) && (S === "__proto__" || S === "constructor") && nn(19), typeof E == "function" && S === "prototype" && nn(19), E = Sw(E, S), typeof E != "object" && nn(18, w.join("/"));
      }
      const A = dh(E), x = p(m.value), g = w[w.length - 1];
      switch (f) {
        case e:
          switch (A) {
            case 2:
              return E.set(g, x);
            case 3:
              nn(16);
            default:
              return E[g] = x;
          }
        case r:
          switch (A) {
            case 1:
              return g === "-" ? E.push(x) : E.splice(g, 0, x);
            case 2:
              return E.set(g, x);
            case 3:
              return E.add(x);
            default:
              return E[g] = x;
          }
        case n:
          switch (A) {
            case 1:
              return E.splice(g, 1);
            case 2:
              return E.delete(g);
            case 3:
              return E.delete(m.value);
            default:
              return delete E[g];
          }
        default:
          nn(17, f);
      }
    }), d;
  }
  function p(d) {
    if (!Jl(d))
      return d;
    if (Array.isArray(d))
      return d.map(p);
    if (Og(d))
      return new Map(
        Array.from(d.entries()).map(([m, w]) => [m, p(w)])
      );
    if (Tg(d))
      return new Set(Array.from(d).map(p));
    const b = Object.create(hh(d));
    for (const m in d)
      b[m] = p(d[m]);
    return _0(d, Kf) && (b[Kf] = d[Kf]), b;
  }
  function h(d) {
    return ph(d) ? p(d) : d;
  }
  jse("Patches", {
    applyPatches_: c,
    generatePatches_: i,
    generateReplacementPatches_: l
  });
}
var Qi = new Use(), Wse = Qi.produce, qse = Qi.produceWithPatches.bind(
  Qi
);
Qi.setAutoFreeze.bind(Qi);
Qi.setUseStrictShallowCopy.bind(Qi);
Qi.applyPatches.bind(Qi);
Qi.createDraft.bind(Qi);
Qi.finishDraft.bind(Qi);
var FN = (t) => {
  throw TypeError(t);
}, zN = (t, e, r) => e.has(t) || FN("Cannot " + r), N7 = (t, e, r) => (zN(t, e, "read from private field"), r ? r.call(t) : e.get(t)), D7 = (t, e, r) => e.has(t) ? FN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), $7 = (t, e, r, n) => (zN(t, e, "write to private field"), e.set(t, r), r);
const Ly = "[a-fA-F0-9]", Rd = "[a-zA-Z0-9-._~]", so = "[!$&'()*+,;=]", Dh = `%${Ly}${Ly}`, Nm = "(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])", T5 = `${Nm}\\.${Nm}\\.${Nm}\\.${Nm}`, Lr = `${Ly}{1,4}`, wu = `(?:${Lr}:${Lr}|${T5})`, Qse = `(?:(?:${Lr}:){6}${wu}|::(?:${Lr}:){5}${wu}|(?:${Lr})?::(?:${Lr}:){4}${wu}|(?:(?:${Lr}:){0,1}${Lr})?::(?:${Lr}:){3}${wu}|(?:(?:${Lr}:){0,2}${Lr})?::(?:${Lr}:){2}${wu}|(?:(?:${Lr}:){0,3}${Lr})?::(?:${Lr}:){1}${wu}|(?:(?:${Lr}:){0,4}${Lr})?::${wu}|(?:(?:${Lr}:){0,5}${Lr})?::${Lr}|(?:(?:${Lr}:){0,6}${Lr})?::)`, Kse = `v${Ly}+\\.(?:${Rd}|${so}|:)+`, VN = `\\[(?:${Qse}|${Kse})\\]`, Od = "(?<scheme>[a-zA-Z][a-zA-Z0-9-+.]*)", UN = ":(?<port>\\d*)", Yse = `(?:${Rd}|${Dh}|${so})*?`, Zse = `(?<host>${VN}|${T5}|${Yse})`, Jse = `(?<userinfo>(?:${Rd}|${Dh}|${so}|:)*)`, L5 = `(?:${Rd}|${Dh}|${so}|:|@)`, HN = `${L5}*?`, GN = `(?:/${HN})*`, M5 = `(?<authority>(?:${Jse}@)?${Zse}(?:${UN})?)`, N5 = `(?<path>${GN})`, D5 = `(?<path2>${HN}${GN})`, $5 = `(?:\\?(?<query>(?:${L5}|/|\\?)*))?`, WN = `(?:#(?<fragment>(?:${L5}|/|\\?)*))?`, Xse = `^${Od}:(?://${M5}${N5}|${D5})${$5}${WN}$`, eoe = `^(?:${Od}:|)(?://${M5}${N5}|${D5})${$5}${WN}$`, toe = `^${Od}:(?://${M5}${N5}|${D5})${$5}$`, Lg = "[a-zA-Z0-9-._~\\00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF\\u10000-\\u1FFFD\\u20000-\\u2FFFD\\u30000-\\u3FFFD\\u40000-\\u4FFFD\\u50000-\\u5FFFD\\u60000-\\u6FFFD\\u70000-\\u7FFFD\\u80000-\\u8FFFD\\u90000-\\u9FFFD\\uA0000-\\uAFFFD\\uB0000-\\uBFFFD\\uC0000-\\uCFFFD\\uD0000-\\uDFFFD\\uE1000-\\uEFFFD]", roe = "[\\uE000-\\uF8FF\\uF0000-\\uFFFFD\\u100000-\\u10FFFD]", noe = `(?:${Lg}|${Dh}|${so})*?`, ioe = `(?<host>${VN}|${T5}|${noe})`, soe = `(?<userinfo>(?:${Lg}|${Dh}|${so}|:)*)`, j5 = `(?:${Lg}|${Dh}|${so}|:|@)`, qN = `${j5}*?`, QN = `(?:/${qN})*`, B5 = `(?<authority>(?:${soe}@)?${ioe}(?:${UN})?)`, F5 = `(?<path>${QN})`, z5 = `(?<path2>${qN}${QN})`, V5 = `(?:\\?(?<query>(?:${j5}|${roe}|/|\\?)*))?`, KN = `(?:#(?<fragment>(?:${j5}|/|\\?)*))?`, YN = `^${Od}:(?://${B5}${F5}|${z5})${V5}${KN}$`, ZN = `^(?:${Od}:|)(?://${B5}${F5}|${z5})${V5}${KN}$`, JN = `^${Od}:(?://${B5}${F5}|${z5})${V5}$`, ooe = (t) => (e, r) => {
  const n = (
    /** @type IdentifierComponents */
    t.parseReference(e)
  );
  if (n.scheme === void 0) {
    const i = t.parseAbsolute(r);
    n.scheme = i.scheme, n.authority === void 0 && (n.authority = i.authority, n.path === "" ? (n.path = i.path, n.query === void 0 && (n.query = i.query)) : n.path.startsWith("/") || (n.path = aoe(n.path, i)));
  }
  return XN(t, n);
}, aoe = (t, e) => {
  if (e.authority && e.path === "")
    return "/" + t;
  {
    const r = e.path.lastIndexOf("/");
    return r === -1 ? t : e.path.slice(0, r + 1) + t;
  }
}, loe = /^\.?\.\/|^\.\.?$/, coe = /^\/\.(?:\/|$)/, uoe = /^\/\.\.(?:\/|$)/, hoe = (t) => {
  let e = "";
  for (; t.length > 0; )
    if (loe.test(t))
      t = j7(t);
    else if (coe.test(t))
      t = B7(t);
    else if (uoe.test(t))
      t = B7(t), e = poe(e);
    else {
      const r = doe(t);
      t = j7(t), e += r;
    }
  return e;
}, j7 = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "" : "/" + t.slice(e + 1);
}, B7 = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "/" : "/" + t.slice(e + 1);
}, poe = (t) => {
  const e = t.lastIndexOf("/");
  return e === -1 ? t : t.slice(0, e);
}, doe = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? t : t.slice(0, e);
}, XN = (t, e) => {
  let r = e.scheme.toLowerCase() + ":";
  return r += e.authority === void 0 ? "" : "//" + e.authority.toLowerCase(), r += t.normalizePath(e.path), r += e.query === void 0 ? "" : "?" + t.normalizeQuery(e.query), r += e.fragment === void 0 ? "" : "#" + t.normalizeFragment(e.fragment), r;
}, eD = new RegExp(Dh, "g"), tD = (t) => (e) => {
  const r = parseInt(e.slice(1), 16), n = String.fromCharCode(r);
  return t(n) ? n : e.toUpperCase();
};
RegExp.prototype.test.bind(new RegExp(`${Rd}|${so}|[:@]`));
const foe = RegExp.prototype.test.bind(new RegExp(`${Lg}|${so}|[:@]`)), goe = (t) => (e) => hoe(e).replaceAll(eD, tD(t));
RegExp.prototype.test.bind(new RegExp(`${Rd}|${so}|[:@/?]`));
const F7 = RegExp.prototype.test.bind(new RegExp(`${Lg}|${so}|[:@/?]`)), z7 = (t) => (e) => e.replaceAll(eD, tD(t));
RegExp.prototype.test.bind(new RegExp(Xse));
RegExp.prototype.test.bind(new RegExp(eoe));
RegExp.prototype.test.bind(new RegExp(toe));
RegExp.prototype.test.bind(new RegExp(YN));
RegExp.prototype.test.bind(new RegExp(ZN));
RegExp.prototype.test.bind(new RegExp(JN));
const U5 = (t, e) => (r) => {
  const n = t.exec(r);
  if (n === null)
    throw Error(`Invalid ${e}: ${r}`);
  const i = (
    /** @type Record<string, string> */
    n.groups
  );
  return i.authority === void 0 && (i.path = i.path2), delete i.path2, /** @type A */
  i;
}, H5 = (
  /** @type Parser<IdentifierComponents> */
  U5(new RegExp(YN), "IRI")
), rD = (
  /** @type Parser<RelativeIdentifierComponents> */
  U5(new RegExp(ZN), "IRI-reference")
), moe = (
  /** @type Parser<AbsoluteIdentifierComponents> */
  U5(new RegExp(JN), "absolute-IRI")
), nD = {
  iri: {
    parseAbsolute: moe,
    parseReference: rD,
    parse: H5,
    normalizePath: goe(foe),
    normalizeQuery: z7(F7),
    normalizeFragment: z7(F7)
  }
}, yoe = (t) => (e) => {
  const r = t.parse(e);
  return delete r.fragment, XN(t, r);
}, Ku = yoe(nD.iri), P0 = ooe(nD.iri), boe = "", Yx = function* (t) {
  if (t.length > 0 && t[0] !== "/")
    throw Error("Invalid JSON Pointer");
  let e = 1, r = 0;
  for (; r < t.length; ) {
    const n = t.indexOf("/", e);
    r = n === -1 ? t.length : n;
    const i = t.slice(e, r);
    e = r + 1, yield xoe(i);
  }
}, voe = (t, e = void 0) => {
  if (e === void 0) {
    const r = [...Yx(t)];
    return (n) => V7(r, n);
  } else
    return V7(Yx(t), e);
}, V7 = (t, e) => {
  let r = boe;
  for (const n of t)
    e = Soe(e, n, r), r = gh(n, r);
  return e;
}, gh = (t, e) => e + "/" + woe(t), woe = (t) => t.toString().replace(/~/g, "~0").replace(/\//g, "~1"), xoe = (t) => t.toString().replace(/~1/g, "/").replace(/~0/g, "~"), Eoe = (t, e) => Array.isArray(t) && e === "-" ? t.length : e, Soe = (t, e, r = "") => {
  if (t === void 0)
    throw TypeError(`Value at '${r}' is undefined and does not have property '${e}'`);
  if (t === null)
    throw TypeError(`Value at '${r}' is null and does not have property '${e}'`);
  if (Aoe(t))
    throw TypeError(`Value at '${r}' is a ${typeof t} and does not have property '${e}'`);
  {
    const n = Eoe(t, e);
    return t[n];
  }
}, Aoe = (t) => t === null || typeof t != "object", iD = (t) => {
  const e = typeof t;
  switch (e) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JSON compatible type: ${r}`);
    }
  }
}, sD = (t) => {
  const e = t.indexOf("#"), r = e === -1 ? t.length : e;
  return t.slice(0, r);
}, oD = (t) => decodeURIComponent(rD(t).fragment || ""), My = {}, Ib = (t) => {
  if (t.indexOf("#") !== -1) {
    const e = sD(t);
    return { ...My[e], id: t };
  }
  return My[t];
}, koe = (t, e) => {
  const r = _oe(t, e);
  if (!r)
    throw Error(`Encountered unknown keyword '${t}'`);
  const n = Ib(r);
  if (!n)
    throw Error(`Encountered unsupported keyword ${t}. You can provide an implementation for the '${r}' keyword using the 'addKeyword' function.`);
  return n;
}, lt = (t) => {
  My[t.id] = t;
}, Zx = {}, Cc = (t, e) => {
  Zx[t] = e;
}, Yf = {}, Jx = {}, _w = {}, _oe = (t, e) => {
  var r;
  return ((r = aD(e)) == null ? void 0 : r[t]) || (Jx[e] || t.startsWith("x-")) && `https://json-schema.org/keyword/unknown#${t}`;
}, Jr = (t, e) => {
  const r = aD(t);
  for (const n in r)
    if (r[n] === e)
      return n;
}, aD = (t) => {
  if (!(t in Yf))
    throw Error(`Encountered unknown dialect '${t}'`);
  return Yf[t];
}, lD = (t, e, r = !1, n = !0) => {
  Jx[t] = r, _w[t] = _w[t] || n, Yf[t] = {}, Object.entries(e).forEach(([i, s]) => {
    if (i in Zx)
      Object.entries(Zx[i]).forEach(([o, a]) => {
        !(a in My) && !s && (a = `https://json-schema.org/keyword/unknown#${o}`), Yf[t][o] = a;
      });
    else if (!r || s)
      throw delete Yf[t], delete Jx[t], delete _w[t], Error(`Unrecognized vocabulary: ${i}. You can define this vocabulary with the 'defineVocabulary' function.`);
  });
};
var U7 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function cD(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Dm = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var H7;
function Coe() {
  if (H7) return Dm;
  H7 = 1;
  var t = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, e = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, n = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  Dm.format = o, Dm.parse = a;
  function o(h) {
    if (!h || typeof h != "object")
      throw new TypeError("argument obj is required");
    var d = h.parameters, b = h.type;
    if (!b || !s.test(b))
      throw new TypeError("invalid type");
    var m = b;
    if (d && typeof d == "object")
      for (var w, f = Object.keys(d).sort(), E = 0; E < f.length; E++) {
        if (w = f[E], !r.test(w))
          throw new TypeError("invalid parameter name");
        m += "; " + w + "=" + c(d[w]);
      }
    return m;
  }
  function a(h) {
    if (!h)
      throw new TypeError("argument string is required");
    var d = typeof h == "object" ? l(h) : h;
    if (typeof d != "string")
      throw new TypeError("argument string is required to be a string");
    var b = d.indexOf(";"), m = b !== -1 ? d.slice(0, b).trim() : d.trim();
    if (!s.test(m))
      throw new TypeError("invalid media type");
    var w = new p(m.toLowerCase());
    if (b !== -1) {
      var f, E, A;
      for (t.lastIndex = b; E = t.exec(d); ) {
        if (E.index !== b)
          throw new TypeError("invalid parameter format");
        b += E[0].length, f = E[1].toLowerCase(), A = E[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(n, "$1"))), w.parameters[f] = A;
      }
      if (b !== d.length)
        throw new TypeError("invalid parameter format");
    }
    return w;
  }
  function l(h) {
    var d;
    if (typeof h.getHeader == "function" ? d = h.getHeader("content-type") : typeof h.headers == "object" && (d = h.headers && h.headers["content-type"]), typeof d != "string")
      throw new TypeError("content-type header is missing from object");
    return d;
  }
  function c(h) {
    var d = String(h);
    if (r.test(d))
      return d;
    if (d.length > 0 && !e.test(d))
      throw new TypeError("invalid parameter value");
    return '"' + d.replace(i, "\\$1") + '"';
  }
  function p(h) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = h;
  }
  return Dm;
}
var uD = Coe();
const Ioe = /* @__PURE__ */ cD(uD), R0 = {}, hD = (t, e) => {
  R0[t] = e;
}, Poe = (t) => {
  const e = t.headers.get("content-type");
  if (e === null)
    throw new Noe("The media type of the response could not be determined. Make sure the response includes a 'Content-Type' header.", { cause: t });
  const r = uD.parse(e);
  for (const n in R0)
    if (Toe(n, r.type))
      return R0[n].parse(t);
  throw new Moe(r.type, `'${r.type}' is not supported. Use the 'addMediaTypePlugin' function to add support for this media type.`, {
    cause: t
  });
}, Roe = "A-Za-z", Cw = `[!#$%&'*\\-_.^\`|~\\d${Roe}]+`, Ooe = `(?<type>${Cw})/(?<subType>${Cw}(?:\\+(?<suffix>${Cw}))?)`, G7 = new RegExp(Ooe), Toe = (t, e) => {
  var r, n;
  if (t === e)
    return !0;
  const i = (r = G7.exec(t)) == null ? void 0 : r.groups;
  if (!i)
    throw Error(`Unable to parse media-range: ${t}`);
  const s = (n = G7.exec(e)) == null ? void 0 : n.groups;
  if (!s)
    throw Error(`Unable to parse media-type: ${e}`);
  return (i.type === s.type || i.type === "*") && (i.subType === s.subType || i.subType === "*" || i.subType === s.suffix);
}, Loe = () => {
  let t = "";
  for (const e in R0)
    t = W7(t, e, R0[e].quality);
  return W7(t, "*/*", "0.001");
}, W7 = (t, e, r) => (t.length > 0 && (t += ", "), t += e, r && (t += `; q=${r}`), t);
let Moe = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.mediaType = e;
  }
}, Noe = class extends Error {
  constructor(e = void 0) {
    super(e), this.name = this.constructor.name;
  }
};
const Doe = (t, e = void 0) => JSON.parse(t, (r, n) => {
  const i = n !== null && typeof n.$ref == "string" ? new Du(n.$ref) : n;
  return e ? e(r, i) : i;
});
var x1, E1;
let Du = class {
  constructor(e, r = void 0) {
    D7(this, x1), D7(this, E1), $7(this, x1, e), $7(this, E1, r ?? { $ref: e });
  }
  get href() {
    return N7(this, x1);
  }
  toJSON() {
    return N7(this, E1);
  }
};
x1 = /* @__PURE__ */ new WeakMap(), E1 = /* @__PURE__ */ new WeakMap();
const pD = (t) => {
  const e = typeof t;
  switch (e) {
    case "bigint":
      return "number";
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (t instanceof Du)
        return "reference";
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype || Object.getPrototypeOf(t) === null)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JRef compatible type: ${r}`);
    }
  }
}, $oe = {
  parse: async (t) => ({
    baseUri: t.url,
    root: Doe(await t.text()),
    anchorLocation: joe
  }),
  fileMatcher: (t) => /[^/]\.jref$/.test(t)
}, joe = (t) => decodeURI(t || ""), Xx = {}, dD = (t, e) => {
  Xx[t] = e;
}, Boe = (t, e) => {
  t = P0(t, e);
  const { scheme: r } = H5(t);
  if (!(r in Xx))
    throw new Foe(r, `The '${r}:' URI scheme is not supported. Use the 'addUriSchemePlugin' function to add support for '${r}:' URIs.`);
  return Xx[r].retrieve(t, e);
};
let Foe = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.scheme = e;
  }
};
const zoe = /* @__PURE__ */ new Set([200, 203]), Voe = async (t) => {
  const e = await fetch(t, { headers: { Accept: Loe() } });
  if (e.status >= 400)
    throw new q7(e, `Failed to retrieve '${t}'`);
  if (!zoe.has(e.status))
    throw new q7(e, "Unsupported HTTP response status code");
  return e;
}, fD = { retrieve: Voe };
let q7 = class extends Error {
  constructor(e, r = void 0) {
    super(`${e.status} ${e.statusText}${r ? ` -- ${r}` : ""}`), this.name = this.constructor.name, this.response = e;
  }
};
var gD = Uoe;
function Uoe(t, e) {
  return function r() {
    e == null && (e = t.length);
    var n = [].slice.call(arguments);
    return n.length >= e ? t.apply(this, n) : function() {
      return r.apply(this, n.concat([].slice.call(arguments)));
    };
  };
}
const Hoe = () => {
  var t, e;
  return ((e = (t = globalThis.document) == null ? void 0 : t.location) == null ? void 0 : e.toString()) ?? "";
}, Pb = async (t, e = { _cache: {} }) => {
  var r, n, i;
  const s = ((r = e.document) == null ? void 0 : r.baseUri) ?? Hoe();
  t = P0(t, s);
  const o = Ku(t), { fragment: a } = H5(t), l = e._cache[o] ?? ((i = (n = e.document) == null ? void 0 : n.embedded) == null ? void 0 : i[o]);
  if (l)
    e.document = l, e.uri = t, e.cursor = e.document.anchorLocation(a);
  else {
    try {
      const c = await Boe(t, s);
      e.document = await Poe(c), e.uri = c.url + (a === void 0 ? "" : `#${a}`), e.cursor = e.document.anchorLocation(a);
    } catch (c) {
      const p = e.uri ? ` Referenced from '${e.uri}'.` : "";
      throw new Woe(`Unable to load resource '${t}'.${p}`, c);
    }
    e._cache[o] = e.document;
  }
  return e._value = voe(e.cursor, e.document.root), mD(e);
}, mD = (t) => pD(It(t)) === "reference" ? Pb(It(t).href, t) : t, It = (t) => t._value, Ma = (t) => pD(t._value), yD = (t, e) => t in e._value, bD = (t) => t._value.length, Qs = gD((t, e) => mD({
  ...e,
  cursor: gh(`${t}`, e.cursor),
  _value: e._value[t]
})), Ic = async function* (t) {
  for (let e = 0; e < It(t).length; e++)
    yield Qs(e, t);
}, e4 = function* (t) {
  for (const e in It(t))
    yield e;
}, Goe = async function* (t) {
  for (const e in It(t))
    yield Qs(e, t);
}, mh = async function* (t) {
  for (const e in It(t))
    yield [e, await Qs(e, t)];
};
let Woe = class extends Error {
  constructor(e, r) {
    super(e, { cause: r }), this.name = this.constructor.name;
  }
};
hD("application/reference+json", $oe);
dD("http", fD);
dD("https", fD);
const qoe = {
  parse: async (t) => {
    const e = Ioe.parse(t.headers.get("content-type") ?? ""), r = e.parameters.schema ?? e.parameters.profile;
    return Dy(await t.json(), t.url, r);
  },
  fileMatcher: async (t) => /(\.|\/)schema\.json$/.test(t)
}, Ny = {}, Qoe = async (t, e = void 0) => {
  e || (e = { _cache: {} });
  for (const n in Ny)
    n in e._cache || (e._cache[n] = Ny[n]);
  const r = await Pb(t, { ...e });
  if (typeof r.document.dialectId != "string")
    throw Error(`The document at ${r.document.baseUri} is not a schema.`);
  return r;
}, Ka = (t, e, r) => {
  t = structuredClone(t);
  const n = Dy(t, e, r);
  if (n.baseUri in Ny)
    throw Error(`A schema has already been registered for '${n.baseUri}. You can use 'unregisterSchema' to remove the old schema before registering the new one.`);
  if (n.baseUri.startsWith("file:"))
    throw Error(`Registering a schema with a 'file:' URI scheme is not allowed: ${n.baseUri}`);
  Ny[n.baseUri] = n;
}, Dy = (t, e, r, n = {}) => {
  if (typeof t.$schema == "string" && (r = t.$schema, delete t.$schema), !r)
    throw Error("Unable to determine a dialect for the schema. The dialect can be declared in a number of ways, but the recommended way is to use the '$schema' keyword in your schema.");
  r = Ku(r);
  const i = Jr(r, "https://json-schema.org/keyword/draft-04/id"), s = Jr(r, "https://json-schema.org/keyword/id") || i;
  if (!t[s] && !e)
    throw Error(`Unable to determine an identifier for the schema. Use the '${s}' keyword or pass a retrievalUri when loading the schema.`);
  const o = P0(t[s] ?? "", e ?? "");
  e = Ku(o), i && o.length > e.length ? t[s] = "#" + oD(o) : delete t[s];
  const a = Jr(r, "https://json-schema.org/keyword/vocabulary");
  if (iD(t[a]) === "object") {
    const h = t[a]["https://json-schema.org/draft/2019-09/vocab/core"] || t[a]["https://json-schema.org/draft/2020-12/vocab/core"];
    lD(e, t[a], h, !1), delete t[a];
  }
  const l = { "": "" }, c = {}, p = Jr(r, "https://json-schema.org/keyword/draft-2019-09/recursiveAnchor");
  return t[p] === !0 && (c[""] = `${e}#`), delete t[p], n[e] = {
    baseUri: e,
    dialectId: r,
    root: t4(t, e, r, "", n, l, c),
    anchorLocation: (h) => {
      if (h === void 0)
        return "";
      if (h = decodeURI(h), h[0] === "/")
        return h;
      if (h in l)
        return l[h];
      throw Error(`No such anchor '${e}#${encodeURI(h)}'`);
    },
    anchors: l,
    dynamicAnchors: c,
    embedded: n
  }, n[e];
}, t4 = (t, e, r, n, i, s, o) => {
  if (iD(t) === "object") {
    const a = typeof t.$schema == "string" ? Ku(t.$schema) : r, l = Jr(a, "https://json-schema.org/keyword/id");
    if (typeof t[l] == "string") {
      const m = Ku(P0(t[l], e));
      return t[l] = m, i[m] = Dy(t, m, a, i), new Du(m, {});
    }
    const c = Jr(a, "https://json-schema.org/keyword/draft-04/id");
    if (typeof t[c] == "string")
      if (t[c][0] === "#") {
        const m = decodeURIComponent(t[c].slice(1));
        s[m] = n, delete t[c];
      } else {
        const m = Ku(P0(t[c], e));
        return t[c] = m, i[m] = Dy(t, m, a, i), new Du(m, {});
      }
    const p = Jr(r, "https://json-schema.org/keyword/draft-04/ref");
    if (typeof t[p] == "string")
      return new Du(t[p], t);
    const h = Jr(r, "https://json-schema.org/keyword/anchor");
    typeof t[h] == "string" && (s[t[h]] = n, delete t[h]);
    const d = Jr(r, "https://json-schema.org/keyword/dynamicAnchor");
    typeof t[d] == "string" && (o[t[d]] = `${e}#${encodeURI(n)}`, delete t[d]);
    const b = Jr(r, "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor");
    typeof t[b] == "string" && (o[t[b]] = `${e}#${encodeURI(n)}`, s[t[b]] = n, delete t[b]);
    for (const m in t) {
      const w = Jr(r, "https://json-schema.org/keyword/ref");
      m === w && typeof t[m] == "string" ? t[m] = new Du(t[m], t[m]) : t[m] = t4(t[m], e, r, gh(m, n), i, s, o);
    }
  } else if (Array.isArray(t))
    for (let a = 0; a < t.length; a++)
      t[a] = t4(t[a], e, r, gh(a, n), i, s, o);
  return t;
}, Qp = (t) => `${t.document.baseUri}#${encodeURI(t.cursor)}`, Td = (
  /** @type API.curry */
  (t) => (...e) => {
    const r = t.length === 1 ? (
      /** @type Extract<typeof fn, (a: any) => any> */
      t(e[0])
    ) : t(e[0], e[1]), n = (
      /** @type I */
      e[t.length]
    );
    return n === void 0 ? r : r(n);
  }
), vD = Td((t) => function* (e) {
  for (const r of e)
    yield t(r);
}), Kn = Td((t) => async function* (e) {
  for await (const r of e)
    yield t(r);
}), wD = Td((t) => function* (e) {
  for (const r of e)
    t(r) && (yield r);
}), Koe = Td((t) => function* (e) {
  let r = 0;
  for (const n of e)
    r++ >= t && (yield n);
}), Yoe = (t) => {
  const e = SD(t).next();
  return e.done ? void 0 : e.value;
}, xD = function* (t, e) {
  for (let r = t; e === void 0; r++)
    yield r;
}, Q7 = function* () {
}, G5 = function* (t, e) {
  const r = SD(e);
  for (const n of t)
    yield [n, r.next().value];
}, Zoe = function* (...t) {
  for (const e of t)
    yield* e;
}, ED = (
  /** @type API.reduce */
  Td(
    // eslint-disable-next-line @stylistic/no-extra-parens
    /** @type API.reduce */
    (t, e) => (r) => {
      for (const n of r)
        e = t(
          e,
          /** @type any */
          n
        );
      return e;
    }
  )
), oo = async (t) => {
  const e = [];
  for await (const r of t)
    e.push(r);
  return e;
}, Joe = (t) => {
  const e = /* @__PURE__ */ new Set();
  for (const r of t)
    e.add(r);
  return e;
}, r4 = async (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  for await (const [r, n] of t)
    e[r] = n;
  return e;
}, Xoe = Td((t) => (e) => {
  let r = Yoe(e) ?? "";
  for (const n of e)
    r += t + n;
  return r;
}), SD = (t) => {
  if (typeof (t == null ? void 0 : t[Symbol.iterator]) == "function")
    return t[Symbol.iterator]();
  throw TypeError("`iter` is not iterable");
}, yn = (
  /** @type (acc: any, ...fns: ((a: any) => any)[]) => any */
  (t, ...e) => ED((r, n) => n(r), t, e)
), S1 = (t, e = "", r = "", n = void 0) => {
  const i = typeof t;
  switch (i) {
    case "number":
    case "string":
    case "boolean":
      return xf(e, r, t, i, [], n);
    case "object":
      if (t === null)
        return xf(e, r, t, "null", [], n);
      if (Array.isArray(t)) {
        const s = xf(e, r, t, "array", [], n);
        return s.children = t.map((o, a) => S1(o, e, gh(a, r), s)), s;
      } else if (Object.getPrototypeOf(t) === Object.prototype) {
        const s = xf(e, r, t, "object", [], n);
        return s.children = Object.entries(t).map((o) => {
          const a = gh(o[0], r), l = xf(e, a, void 0, "property", [], s);
          return l.children = o.map((c) => S1(c, e, a, l)), l;
        }), s;
      } else if (t instanceof Du)
        return S1(t.toJSON(), e, r, n);
    default: {
      const s = i === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : i;
      throw Error(`Not a JSON compatible type: ${s}`);
    }
  }
}, xf = (t, e, r, n, i, s) => {
  const o = {
    baseUri: t ? Ku(t) : "",
    pointer: e,
    value: r,
    type: n,
    children: i,
    parent: s,
    valid: !0,
    errors: {},
    annotations: {}
  };
  return o.root = (s == null ? void 0 : s.root) ?? o, o;
}, eae = (t) => `${t.baseUri}#${encodeURI(t.pointer)}`, kr = (t) => t.value, Gt = (t) => t.type, Kp = (t, e) => t in e.value, $h = function* (t) {
  t.type === "array" && (yield* t.children);
}, W5 = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      yield e.children[0];
}, tae = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children[1] && (yield e.children[1]);
}, Pc = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children.length === 2 && (yield e.children);
}, Mg = (t) => {
  if (t.type === "array")
    return t.children.length;
}, n4 = function* (t) {
  switch (yield t, Gt(t)) {
    case "object":
      for (const e of tae(t))
        yield* n4(e);
      break;
    case "array":
      for (const e of $h(t))
        yield* n4(e);
      break;
  }
}, Mp = {};
let rae = 0;
const nae = (t, e) => {
  t in Mp || (Mp[t] = {});
  const r = `pubsub_subscription_${rae++}`;
  return Mp[t][r] = e, r;
}, iae = async (t, e) => {
  const r = [];
  for (const n in Mp)
    if (n === t || t.startsWith(`${n}.`))
      for (const i in Mp[n])
        r.push(Mp[t][i](t, e));
  await Promise.all(r);
};
let AD;
const sae = () => AD, oae = (t) => {
  AD = t;
};
let aae = class extends Error {
  constructor(e) {
    super("Invalid Schema"), this.name = this.constructor.name, this.output = e;
  }
};
const kD = "https://json-schema.org/evaluation/validate", lae = async (t, e) => {
  await iae("validate.metaValidate", t), t.document.baseUri in e.metaData || (e.metaData[t.document.baseUri] = {
    dynamicAnchors: t.document.dynamicAnchors
  });
  const r = Qp(t);
  if (!(r in e)) {
    e[r] = !1;
    const n = It(t);
    if (!["object", "boolean"].includes(typeof n))
      throw Error(`No schema found at '${r}'`);
    e[r] = typeof n == "boolean" ? n : await yn(
      mh(t),
      Kn(async ([i, s]) => {
        const o = koe(i, t.document.dialectId), a = await o.compile(s, e, t);
        return [o.id, gh(i, Qp(t)), a];
      }),
      oo
    );
  }
  return r;
}, cae = (t, e, r, n, i = !1) => {
  n = { ...r.metaData[sD(t)].dynamicAnchors, ...n };
  let s = !0;
  if (typeof r[t] == "boolean")
    s = r[t];
  else
    for (const [o, a, l] of r[t])
      e.valid = Ib(o).interpret(l, e, r, n, i, t), e.valid || (i || (e.errors[a] = o), s = !1);
  return s || (e.errors[t] = kD), e.valid = s, s;
}, uae = /* @__PURE__ */ new Set(), hae = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedProperties")
      continue;
    const l = Ib(o), c = "collectEvaluatedProperties" in l ? l.collectEvaluatedProperties(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && uae;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, pae = /* @__PURE__ */ new Set(), dae = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedItems")
      continue;
    const l = Ib(o), c = "collectEvaluatedItems" in l ? l.collectEvaluatedItems(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && pae;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, Ge = { id: kD, compile: lae, interpret: cae, collectEvaluatedProperties: hae, collectEvaluatedItems: dae }, $y = {}, fae = (t, e) => {
  if (e in $y)
    return $y[e](t);
  throw Error(`The '${e}' error format is not supported`);
};
$y.FLAG = (t) => ({ valid: t.valid });
$y.BASIC = (t) => {
  const e = {
    valid: t.valid
  };
  if (!t.valid) {
    e.errors = [];
    for (const r of n4(t))
      for (const [n, i] of Object.entries(r.errors).reverse())
        i !== "https://json-schema.org/evaluation/validate" && !r.valid && e.errors.unshift({
          keyword: i,
          absoluteKeywordLocation: n,
          instanceLocation: eae(r),
          valid: r.valid
        });
  }
  return e;
};
const _D = "FLAG";
oae(_D);
const gae = async (t) => {
  const e = { metaData: {} }, r = await Ge.compile(t, e);
  return { ast: e, schemaUri: r };
}, mae = gD(({ ast: t, schemaUri: e }, r, n = _D) => (Ge.interpret(e, r, t, {}), fae(r, n))), Iw = {};
nae("validate.metaValidate", async (t, e) => {
  if (!e.document.validated) {
    if (e.document.validated = !0, !(e.document.dialectId in Iw)) {
      const i = await Qoe(e.document.dialectId, e), s = await gae(i);
      Iw[e.document.dialectId] = mae(s);
    }
    const r = S1(e.document.root, e.document.baseUri), n = Iw[e.document.dialectId](r, sae());
    if (!n.valid)
      throw new aae(n);
  }
});
const yae = "https://json-schema.org/keyword/additionalProperties", bae = async (t, e, r) => {
  const n = Jr(t.document.dialectId, "https://json-schema.org/keyword/properties"), i = await Qs(n, r), s = Ma(i) === "object" ? vD((p) => "^" + vae(p) + "$", e4(i)) : Q7(), o = Jr(t.document.dialectId, "https://json-schema.org/keyword/patternProperties"), a = await Qs(o, r), l = Ma(a) === "object" ? e4(a) : Q7(), c = yn(
    Zoe(s, l),
    Xoe("|")
  ) || "(?!)";
  return [new RegExp(c, "u"), await Ge.compile(t, e)];
}, vae = (t) => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), wae = ([t, e], r, n, i, s) => {
  if (Gt(r) !== "object")
    return !0;
  let o = !0;
  for (const [a, l] of Pc(r)) {
    const c = kr(a);
    !t.test(c) && !Ge.interpret(e, l, n, i, s) && (o = !1);
  }
  return o;
}, xae = ([t, e], r, n, i) => {
  if (Gt(r) !== "object")
    return !0;
  const s = /* @__PURE__ */ new Set();
  for (const [o, a] of Pc(r)) {
    const l = kr(o);
    if (!t.test(l)) {
      if (!Ge.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, Eae = { id: yae, compile: bae, interpret: wae, collectEvaluatedProperties: xae }, Sae = "https://json-schema.org/keyword/allOf", Aae = (t, e) => yn(
  Ic(t),
  Kn((r) => Ge.compile(r, e)),
  oo
), kae = (t, e, r, n, i) => {
  let s = !0;
  for (const o of t)
    Ge.interpret(o, e, r, n, i) || (s = !1);
  return s;
}, _ae = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = Ge.collectEvaluatedProperties(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, Cae = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = Ge.collectEvaluatedItems(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, Iae = { id: Sae, compile: Aae, interpret: kae, collectEvaluatedProperties: _ae, collectEvaluatedItems: Cae }, Pae = { id: "https://json-schema.org/keyword/anchor" }, Rae = "https://json-schema.org/keyword/anyOf", Oae = (t, e) => yn(
  Ic(t),
  Kn((r) => Ge.compile(r, e)),
  oo
), Tae = (t, e, r, n, i) => t.filter((s) => Ge.interpret(s, e, r, n, i)).length > 0, Lae = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ge.collectEvaluatedProperties(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, Mae = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ge.collectEvaluatedItems(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, Nae = { id: Rae, compile: Oae, interpret: Tae, collectEvaluatedProperties: Lae, collectEvaluatedItems: Mae }, Dae = "https://json-schema.org/keyword/conditional", $ae = (t, e) => yn(
  Ic(t),
  CD,
  Kn((r) => Ge.compile(r, e)),
  oo
), jae = (t, e, r, n, i) => {
  for (let s = 0; s < t.length; s += 2) {
    const o = Ge.interpret(t[s], e, r, n, i);
    if (s + 1 === t.length)
      return o;
    if (o)
      return Ge.interpret(t[s + 1], e, r, n, i);
  }
  return !0;
}, Bae = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = Ge.collectEvaluatedProperties(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return Ge.collectEvaluatedProperties(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, Fae = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = Ge.collectEvaluatedItems(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return Ge.collectEvaluatedItems(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, CD = async function* (t, e = 1) {
  for await (const r of t)
    e > 0 && Ma(r) === "array" ? yield* CD(Ic(r), e - 1) : yield r;
}, zae = { id: Dae, compile: $ae, interpret: jae, collectEvaluatedProperties: Bae, collectEvaluatedItems: Fae };
var K7, Y7;
function Vae() {
  return Y7 || (Y7 = 1, K7 = {
    space: "",
    cycles: !1,
    replacer: (t, e) => e,
    stringify: JSON.stringify
  }), K7;
}
var Z7, J7;
function xu() {
  return J7 || (J7 = 1, Z7 = {
    isArray: Array.isArray,
    assign: Object.assign,
    isObject: (t) => typeof t == "object",
    isFunction: (t) => typeof t == "function",
    isBoolean: (t) => typeof t == "boolean",
    isRegex: (t) => t instanceof RegExp,
    keys: Object.keys
  }), Z7;
}
var Pw, X7;
function Uae() {
  if (X7) return Pw;
  X7 = 1;
  const t = Vae(), e = xu().isFunction, r = xu().isBoolean, n = xu().isObject, i = xu().isArray, s = xu().isRegex, o = xu().assign, a = xu().keys;
  function l(p) {
    return p == null ? p : s(p) ? p.toString() : p.toJSON ? p.toJSON() : p;
  }
  function c(p, h) {
    h = h || o({}, t), e(h) && (h = { compare: h });
    const d = h.space || t.space, b = r(h.cycles) ? h.cycles : t.cycles, m = h.replacer || t.replacer, w = h.stringify || t.stringify, f = h.compare && /* @__PURE__ */ function(A) {
      return function(x) {
        return function(g, v) {
          const k = { key: g, value: x[g] }, S = { key: v, value: x[v] };
          return A(k, S);
        };
      };
    }(h.compare);
    b || w(p);
    const E = [];
    return function A(x, g, v, k) {
      const S = d ? `
` + new Array(k + 1).join(d) : "", R = d ? ": " : ":";
      if (v = l(v), v = m.call(x, g, v), v !== void 0) {
        if (!n(v) || v === null) return w(v);
        if (i(v)) {
          const L = [];
          for (let F = 0; F < v.length; F++) {
            const z = A(v, F, v[F], k + 1) || w(null);
            L.push(S + d + z);
          }
          return "[" + L.join(",") + S + "]";
        } else {
          if (b) {
            if (E.indexOf(v) !== -1)
              return w("[Circular]");
            E.push(v);
          }
          const L = a(v).sort(f && f(v)), F = [];
          for (let z = 0; z < L.length; z++) {
            const j = L[z], ee = A(v, j, v[j], k + 1);
            if (!ee) continue;
            const X = w(j) + R + ee;
            F.push(S + d + X);
          }
          return E.splice(E.indexOf(v), 1), "{" + F.join(",") + S + "}";
        }
      }
    }({ "": p }, "", p, 0);
  }
  return Pw = c, Pw;
}
var Hae = Uae();
const Ng = /* @__PURE__ */ cD(Hae), Gae = "https://json-schema.org/keyword/const", Wae = (t) => Ng(It(t)), qae = (t, e) => Ng(kr(e)) === t, Qae = { id: Gae, compile: Wae, interpret: qae }, Kae = "https://json-schema.org/keyword/contains", Yae = async (t, e, r) => {
  const n = await Ge.compile(t, e), i = Jr(t.document.dialectId, "https://json-schema.org/keyword/minContains"), s = await Qs(i, r), o = Ma(s) === "number" ? It(s) : 1, a = Jr(t.document.dialectId, "https://json-schema.org/keyword/maxContains"), l = await Qs(a, r), c = Ma(l) === "number" ? It(l) : Number.MAX_SAFE_INTEGER;
  return { contains: n, minContains: o, maxContains: c };
}, ID = ({ contains: t, minContains: e, maxContains: r }, n, i, s, o) => {
  const a = Gt(n) !== "array" || yn(
    $h(n),
    wD((l) => Ge.interpret(t, l, i, s, o)),
    ED((l) => l + 1, 0)
  );
  return a >= e && a <= r;
}, Zae = (t, e, r, n) => ID(t, e, r, n, !0) && Gt(e) === "array" && yn(
  G5($h(e), xD(0)),
  wD(([i]) => Ge.interpret(t.contains, i, r, n, !0)),
  vD(([, i]) => i),
  Joe
), Jae = { id: Kae, compile: Yae, interpret: ID, collectEvaluatedItems: Zae }, Xae = "https://json-schema.org/keyword/comment", ele = () => {
}, tle = () => !0, rle = { id: Xae, compile: ele, interpret: tle }, Cs = (t, e, r, n) => {
  e in t.annotations || (t.annotations[e] = {}), t.annotations[e][r] = n;
}, PD = "https://json-schema.org/keyword/contentEncoding", nle = (t) => It(t), ile = (t, e, r, n, i, s) => (Cs(e, PD, s, t), !0), sle = { id: PD, compile: nle, interpret: ile }, RD = "https://json-schema.org/keyword/contentMediaType", ole = (t) => It(t), ale = (t, e, r, n, i, s) => (Cs(e, RD, s, t), !0), lle = { id: RD, compile: ole, interpret: ale }, OD = "https://json-schema.org/keyword/contentSchema", cle = (t) => Qp(t), ule = (t, e, r, n, i, s) => (Cs(e, OD, s, t), !0), hle = { id: OD, compile: cle, interpret: ule }, TD = "https://json-schema.org/keyword/default", ple = (t) => It(t), dle = (t, e, r, n, i, s) => (Cs(e, TD, s, t), !0), fle = { id: TD, compile: ple, interpret: dle }, gle = "https://json-schema.org/keyword/definitions", mle = (t, e) => yn(
  Goe(t),
  Kn((r) => Ge.compile(r, e)),
  oo
), yle = () => !0, ble = { id: gle, compile: mle, interpret: yle }, vle = "https://json-schema.org/keyword/dependentRequired", wle = (t) => yn(
  mh(t),
  Kn(([e, r]) => [e, It(r)]),
  oo
), xle = (t, e) => {
  if (Gt(e) !== "object")
    return !0;
  let r = !0;
  for (const [n, i] of t)
    Kp(n, e) && !i.every((s) => Kp(s, e)) && (r = !1);
  return r;
}, Ele = { id: vle, compile: wle, interpret: xle }, Sle = "https://json-schema.org/keyword/dependentSchemas", Ale = (t, e) => yn(
  mh(t),
  Kn(async ([r, n]) => [r, await Ge.compile(n, e)]),
  oo
), kle = (t, e, r, n, i) => {
  if (Gt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    Kp(o, e) && !Ge.interpret(a, e, r, n, i) && (s = !1);
  return s;
}, _le = (t, e, r, n) => {
  if (Gt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    if (Kp(s, e)) {
      const a = Ge.collectEvaluatedProperties(o, e, r, n);
      if (a === !1)
        return !1;
      a.forEach(Set.prototype.add.bind(i));
    }
  return i;
}, Cle = { id: Sle, compile: Ale, interpret: kle, collectEvaluatedProperties: _le }, LD = "https://json-schema.org/keyword/deprecated", Ile = (t) => It(t), Ple = (t, e, r, n, i, s) => (Cs(e, LD, s, t), !0), Rle = { id: LD, compile: Ile, interpret: Ple }, MD = "https://json-schema.org/keyword/description", Ole = (t) => It(t), Tle = (t, e, r, n, i, s) => (Cs(e, MD, s, t), !0), Lle = { id: MD, compile: Ole, interpret: Tle }, Mle = { id: "https://json-schema.org/keyword/dynamicAnchor" }, Nle = "https://json-schema.org/keyword/dynamicRef", Dle = async (t, e) => {
  const r = It(t), n = await Pb(t.document.baseUri, t);
  return await Ge.compile(n, e), r;
}, q5 = (t, e, r, n, i, s) => {
  if (!(e in i))
    throw Error(`No dynamic anchor found for "${e}"`);
  return t(i[e], r, n, i, s);
}, $le = (...t) => q5(Ge.interpret, ...t), jle = (...t) => q5(Ge.collectEvaluatedProperties, ...t), Ble = (...t) => q5(Ge.collectEvaluatedItems, ...t), Fle = { id: Nle, compile: Dle, interpret: $le, collectEvaluatedProperties: jle, collectEvaluatedItems: Ble }, zle = "https://json-schema.org/keyword/else", Vle = async (t, e, r) => {
  const n = Jr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (yD(n, r)) {
    const i = await Qs(n, r);
    return [await Ge.compile(i, e), await Ge.compile(t, e)];
  } else
    return [];
}, Ule = ([t, e], r, n, i, s) => t === void 0 || Ge.interpret(t, r, n, i, !0) || Ge.interpret(e, r, n, i, s), Hle = ([t, e], r, n, i) => t === void 0 || Ge.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ge.collectEvaluatedProperties(e, r, n, i), Gle = ([t, e], r, n, i) => t === void 0 || Ge.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ge.collectEvaluatedItems(e, r, n, i), Wle = { id: zle, compile: Vle, interpret: Ule, collectEvaluatedProperties: Hle, collectEvaluatedItems: Gle }, qle = "https://json-schema.org/keyword/enum", Qle = (t) => yn(
  Ic(t),
  Kn(It),
  Kn(Ng),
  oo
), Kle = (t, e) => {
  const r = Ng(kr(e));
  return t.some((n) => r === n);
}, Yle = { id: qle, compile: Qle, interpret: Kle }, ND = "https://json-schema.org/keyword/examples", Zle = (t) => It(t), Jle = (t, e, r, n, i, s) => (Cs(e, ND, s, t), !0), Xle = { id: ND, compile: Zle, interpret: Jle }, ece = "https://json-schema.org/keyword/exclusiveMaximum", tce = (t) => It(t), rce = (t, e) => Gt(e) !== "number" || kr(e) < t, nce = { id: ece, compile: tce, interpret: rce }, ice = "https://json-schema.org/keyword/exclusiveMinimum", sce = (t) => It(t), oce = (t, e) => Gt(e) !== "number" || kr(e) > t, ace = { id: ice, compile: sce, interpret: oce }, DD = "https://json-schema.org/keyword/format", lce = (t) => It(t), cce = (t, e, r, n, i, s) => (Cs(e, DD, s, t), !0), uce = { id: DD, compile: lce, interpret: cce }, hce = { id: "https://json-schema.org/keyword/id" }, pce = "https://json-schema.org/keyword/if", dce = (t, e) => Ge.compile(t, e), fce = (t, e, r, n) => (Ge.interpret(t, e, r, n, !0), !0), gce = (t, e, r, n) => Ge.collectEvaluatedProperties(t, e, r, n) || [], mce = (t, e, r, n) => Ge.collectEvaluatedItems(t, e, r, n) || /* @__PURE__ */ new Set(), yce = { id: pce, compile: dce, interpret: fce, collectEvaluatedProperties: gce, collectEvaluatedItems: mce }, bce = () => {
  const t = fs(!1), e = fs(!0);
  return Cn(t, e), { start: t, end: e };
}, vce = (t) => {
  const e = fs(!1), r = fs(!0);
  return kce(e, r, t), { start: e, end: r };
}, wce = (t, e) => t === void 0 ? e : (Cn(t.end, e.start), t.end.isEnd = !1, { start: t.start, end: e.end }), xce = (t, e) => {
  const r = fs(!1);
  Cn(r, t.start), Cn(r, e.start);
  const n = fs(!0);
  return Cn(t.end, n), t.end.isEnd = !1, Cn(e.end, n), e.end.isEnd = !1, { start: r, end: n };
}, Ece = (t) => {
  const e = fs(!1), r = fs(!0);
  return Cn(e, r), Cn(e, t.start), Cn(t.end, r), Cn(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, Sce = (t) => {
  const e = fs(!1), r = fs(!0);
  return Cn(e, r), Cn(e, t.start), Cn(t.end, r), t.end.isEnd = !1, { start: e, end: r };
}, Ace = (t) => {
  const e = fs(!1), r = fs(!0);
  return Cn(e, t.start), Cn(t.end, r), Cn(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, Cn = (t, e) => {
  t.epsilonTransitions.push(e);
}, kce = (t, e, r) => {
  t.transition[r] = e;
}, fs = (t) => ({
  isEnd: t,
  transition: {},
  epsilonTransitions: []
}), _ce = "https://json-schema.org/keyword/itemPattern", $D = async (t, e) => {
  const r = [[]];
  let n = r[0];
  for await (const i of Ic(t))
    if (Ma(i) === "string") {
      const s = It(i);
      if (s === "*")
        n.push(Ece(n.pop()));
      else if (s === "?")
        n.push(Sce(n.pop()));
      else if (s === "+")
        n.push(Ace(n.pop()));
      else if (s === "|")
        n = [], r.push(n);
      else
        throw Error(`Unsupported pattern syntax: ${s}`);
    } else {
      const s = Ma(i) === "array" ? $D(i, e) : vce(await Ge.compile(i, e));
      n.push(await s);
    }
  return bD(t) === 0 ? bce() : r.map((i) => i.reduce(wce)).reduce(xce);
}, Q5 = (t) => (e, r, n, i, s) => {
  if (Gt(r) !== "array")
    return !0;
  let o = [];
  i4(e.start, o, []);
  for (const a of $h(r)) {
    const l = [];
    for (const c of o) {
      const p = Cce(t, c.transition, a, n, i, s);
      p && i4(p, l, []);
    }
    o = l;
  }
  return !!o.find((a) => a.isEnd);
}, i4 = (t, e, r) => {
  if (t.epsilonTransitions.length)
    for (const n of t.epsilonTransitions)
      r.find((i) => i === n) || (r.push(n), i4(n, e, r));
  else
    e.push(t);
}, Cce = (t, e, r, n, i, s) => {
  for (const o in e)
    if (t(o, r, n, i, s))
      return e[o];
}, Ice = Q5(Ge.interpret), Pce = Q5(Ge.collectEvaluatedProperties), Rce = Q5(Ge.collectEvaluatedItems), Oce = { id: _ce, compile: $D, interpret: Ice, collectEvalatedProperties: Pce, collectEvalatedItems: Rce }, Tce = "https://json-schema.org/keyword/items", Lce = async (t, e, r) => {
  const n = Jr(t.document.dialectId, "https://json-schema.org/keyword/prefixItems"), i = await Qs(n, r);
  return [Ma(i) === "array" ? bD(i) : 0, await Ge.compile(t, e)];
}, jD = ([t, e], r, n, i, s) => {
  if (Gt(r) !== "array")
    return !0;
  let o = !0;
  for (const a of Koe(t, $h(r)))
    Ge.interpret(e, a, n, i, s) || (o = !1);
  return o;
}, Mce = (t, e, r, n) => {
  if (!jD(t, e, r, n, !0))
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (let s = t[0]; s < Mg(e); s++)
    i.add(s);
  return i;
}, Nce = { id: Tce, compile: Lce, interpret: jD, collectEvaluatedItems: Mce }, Dce = "https://json-schema.org/keyword/maxContains", $ce = (t) => It(t), jce = () => !0, Bce = { id: Dce, compile: $ce, interpret: jce }, Fce = "https://json-schema.org/keyword/maxItems", zce = (t) => It(t), Vce = (t, e) => Gt(e) !== "array" || Mg(e) <= t, Uce = { id: Fce, compile: zce, interpret: Vce }, Hce = "https://json-schema.org/keyword/maxLength", Gce = (t) => It(t), Wce = (t, e) => Gt(e) !== "string" || [...kr(e)].length <= t, qce = { id: Hce, compile: Gce, interpret: Wce }, Qce = "https://json-schema.org/keyword/maxProperties", Kce = (t) => It(t), Yce = (t, e) => Gt(e) !== "object" || [...W5(e)].length <= t, Zce = { id: Qce, compile: Kce, interpret: Yce }, Jce = "https://json-schema.org/keyword/maximum", Xce = (t) => It(t), eue = (t, e) => Gt(e) !== "number" || kr(e) <= t, tue = { id: Jce, compile: Xce, interpret: eue }, rue = "https://json-schema.org/keyword/minContains", nue = (t) => It(t), iue = () => !0, sue = { id: rue, compile: nue, interpret: iue }, oue = "https://json-schema.org/keyword/minItems", aue = (t) => It(t), lue = (t, e) => Gt(e) !== "array" || Mg(e) >= t, cue = { id: oue, compile: aue, interpret: lue }, uue = "https://json-schema.org/keyword/minLength", hue = (t) => It(t), pue = (t, e) => Gt(e) !== "string" || [...kr(e)].length >= t, due = { id: uue, compile: hue, interpret: pue }, fue = "https://json-schema.org/keyword/minProperties", gue = (t) => It(t), mue = (t, e) => Gt(e) !== "object" || [...W5(e)].length >= t, yue = { id: fue, compile: gue, interpret: mue }, bue = "https://json-schema.org/keyword/minimum", vue = (t) => It(t), wue = (t, e) => Gt(e) !== "number" || kr(e) >= t, xue = { id: bue, compile: vue, interpret: wue }, Eue = "https://json-schema.org/keyword/multipleOf", Sue = (t) => It(t), Aue = (t, e) => {
  if (Gt(e) !== "number")
    return !0;
  const r = kr(e) % t;
  return e_(0, r) || e_(t, r);
}, e_ = (t, e) => Math.abs(t - e) < 11920929e-14, kue = { id: Eue, compile: Sue, interpret: Aue }, _ue = "https://json-schema.org/keyword/not", Cue = (...t) => Ge.compile(...t), Iue = (...t) => !Ge.interpret(...t), Pue = { id: _ue, compile: Cue, interpret: Iue }, Rue = "https://json-schema.org/keyword/oneOf", Oue = (t, e) => yn(
  Ic(t),
  Kn((r) => Ge.compile(r, e)),
  oo
), Tue = (t, e, r, n, i) => {
  let s = 0;
  for (const o of t)
    Ge.interpret(o, e, r, n, i) && s++;
  return s === 1;
}, Lue = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ge.collectEvaluatedProperties(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, Mue = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ge.collectEvaluatedItems(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, Nue = { id: Rue, compile: Oue, interpret: Tue, collectEvaluatedProperties: Lue, collectEvaluatedItems: Mue }, Due = "https://json-schema.org/keyword/pattern", $ue = (t) => new RegExp(It(t), "u"), jue = (t, e) => Gt(e) !== "string" || t.test(kr(e)), Bue = { id: Due, compile: $ue, interpret: jue }, Fue = "https://json-schema.org/keyword/patternProperties", zue = (t, e) => yn(
  mh(t),
  Kn(async ([r, n]) => [
    new RegExp(r, "u"),
    await Ge.compile(n, e)
  ]),
  oo
), Vue = (t, e, r, n, i) => {
  if (Gt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    for (const [l, c] of Pc(e)) {
      const p = kr(l);
      o.test(p) && !Ge.interpret(a, c, r, n, i) && (s = !1);
    }
  return s;
}, Uue = (t, e, r, n) => {
  if (Gt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    for (const [a, l] of Pc(e)) {
      const c = kr(a);
      if (s.test(c)) {
        if (!Ge.interpret(o, l, r, n, !0))
          return !1;
        i.add(c);
      }
    }
  return i;
}, Hue = { id: Fue, compile: zue, interpret: Vue, collectEvaluatedProperties: Uue }, Gue = "https://json-schema.org/keyword/prefixItems", Wue = (t, e) => yn(
  Ic(t),
  Kn((r) => Ge.compile(r, e)),
  oo
), BD = (t, e, r, n, i) => {
  if (Gt(e) !== "array")
    return !0;
  let s = !0, o = 0;
  const a = Mg(e);
  for (const [l, c] of G5(t, $h(e))) {
    if (o >= a)
      break;
    Ge.interpret(l, c, r, n, i) || (s = !1), o++;
  }
  return s;
}, que = (t, e, r, n) => BD(t, e, r, n, !0) && new Set(t.map((i, s) => s)), Que = { id: Gue, compile: Wue, interpret: BD, collectEvaluatedItems: que }, Kue = "https://json-schema.org/keyword/properties", Yue = (t, e) => yn(
  mh(t),
  Kn(async ([r, n]) => [r, await Ge.compile(n, e)]),
  r4
), Zue = (t, e, r, n, i) => {
  if (Gt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of Pc(e)) {
    const l = kr(o);
    l in t && !Ge.interpret(t[l], a, r, n, i) && (s = !1);
  }
  return s;
}, Jue = (t, e, r, n) => {
  if (Gt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of Pc(e)) {
    const a = kr(s);
    if (a in t) {
      if (!Ge.interpret(t[a], o, r, n, !0))
        return !1;
      i.add(a);
    }
  }
  return i;
}, Xue = { id: Kue, compile: Yue, interpret: Zue, collectEvaluatedProperties: Jue }, ehe = "https://json-schema.org/keyword/propertyDependencies", the = (t, e) => yn(
  mh(t),
  Kn(async ([r, n]) => [r, await yn(
    mh(n),
    Kn(async ([i, s]) => [i, await Ge.compile(s, e)]),
    r4
  )]),
  r4
), rhe = (t, e, r, n, i) => {
  if (Gt(e) !== "object")
    return !0;
  let s = !0;
  const o = kr(e);
  for (const [a, l] of Object.entries(t)) {
    const c = o[a];
    Kp(a, e) && c in l && !Ge.interpret(l[c], e, r, n, i) && (s = !1);
  }
  return s;
}, nhe = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s in t) {
    const o = kr(e)[s], a = t[s];
    if (Kp(s, e) && o in a) {
      const l = Ge.collectEvaluatedProperties(a[o], e, r, n);
      if (!l)
        return !1;
      l.forEach(i.add, i);
    }
  }
  return i;
}, ihe = { id: ehe, compile: the, interpret: rhe, collectEvaluatedProperties: nhe }, she = "https://json-schema.org/keyword/propertyNames", ohe = (t, e) => Ge.compile(t, e), ahe = (t, e, r, n) => {
  if (Gt(e) !== "object")
    return !0;
  let i = !0;
  for (const s of W5(e))
    Ge.interpret(t, s, r, n, !0) || (i = !1);
  return i;
}, lhe = { id: she, compile: ohe, interpret: ahe }, FD = "https://json-schema.org/keyword/readOnly", che = (t) => It(t), uhe = (t, e, r, n, i, s) => (Cs(e, FD, s, t), !0), hhe = { id: FD, compile: che, interpret: uhe }, phe = "https://json-schema.org/keyword/ref", dhe = (...t) => Ge.compile(...t), fhe = (...t) => Ge.interpret(...t), ghe = (...t) => Ge.collectEvaluatedProperties(...t), mhe = (...t) => Ge.collectEvaluatedItems(...t), yhe = { id: phe, compile: dhe, interpret: fhe, collectEvaluatedProperties: ghe, collectEvaluatedItems: mhe }, bhe = "https://json-schema.org/keyword/requireAllExcept", vhe = async (t, e, r) => {
  const n = await It(t), i = Jr(t.document.dialectId, "https://json-schema.org/keyword/properties"), s = await Qs(i, r), o = Ma(s) === "object" ? e4(s) : [], a = new Set(o);
  return n.forEach((l) => o.remove(l)), [...a];
}, whe = (t, e) => Gt(e) !== "object" || t.every((r) => Object.hasOwn(kr(e), r)), xhe = { id: bhe, compile: vhe, interpret: whe }, Ehe = "https://json-schema.org/keyword/required", She = (t) => It(t), Ahe = (t, e) => Gt(e) !== "object" || t.every((r) => Object.hasOwn(kr(e), r)), khe = { id: Ehe, compile: She, interpret: Ahe }, zD = "https://json-schema.org/keyword/title", _he = (t) => It(t), Che = (t, e, r, n, i, s) => (Cs(e, zD, s, t), !0), Ihe = { id: zD, compile: _he, interpret: Che }, Phe = "https://json-schema.org/keyword/then", Rhe = async (t, e, r) => {
  const n = Jr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (yD(n, r)) {
    const i = await Qs(n, r);
    return [await Ge.compile(i, e), await Ge.compile(t, e)];
  } else
    return [];
}, Ohe = ([t, e], r, n, i, s) => t === void 0 || !Ge.interpret(t, r, n, i, !0) || Ge.interpret(e, r, n, i, s), The = ([t, e], r, n, i) => t === void 0 || !Ge.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ge.collectEvaluatedProperties(e, r, n, i), Lhe = ([t, e], r, n, i) => t === void 0 || !Ge.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ge.collectEvaluatedItems(e, r, n, i), Mhe = { id: Phe, compile: Rhe, interpret: Ohe, collectEvaluatedProperties: The, collectEvaluatedItems: Lhe }, Nhe = "https://json-schema.org/keyword/type", Dhe = (t) => It(t), $he = (t, e) => typeof t == "string" ? t_(e)(t) : t.some(t_(e)), t_ = (t) => (e) => e === "integer" ? Gt(t) === "number" && Number.isInteger(kr(t)) : Gt(t) === e, jhe = { id: Nhe, compile: Dhe, interpret: $he }, Bhe = "https://json-schema.org/keyword/unevaluatedItems", Fhe = async (t, e, r) => [Qp(r), await Ge.compile(t, e)], zhe = ([t, e], r, n, i, s) => {
  if (Gt(r) !== "array")
    return !0;
  const o = Ge.collectEvaluatedItems(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of G5($h(r), xD(0)))
    !o.has(c) && !Ge.interpret(e, l, n, i, s) && (a = !1);
  return a;
}, Vhe = (t, e, r, n) => {
  const i = Ge.collectEvaluatedItems(t[0], e, r, n, !0);
  if (!i)
    return !1;
  const s = /* @__PURE__ */ new Set();
  for (let o = 0; o < Mg(e); o++)
    i.has(o) || s.add(o);
  return s;
}, Uhe = { id: Bhe, compile: Fhe, interpret: zhe, collectEvaluatedItems: Vhe }, Hhe = "https://json-schema.org/keyword/unevaluatedProperties", Ghe = async (t, e, r) => [Qp(r), await Ge.compile(t, e)], Whe = ([t, e], r, n, i, s) => {
  if (Gt(r) !== "object")
    return !0;
  const o = Ge.collectEvaluatedProperties(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of Pc(r)) {
    const p = kr(l);
    !o.has(p) && !Ge.interpret(e, c, n, i, s) && (a = !1);
  }
  return a;
}, qhe = ([t, e], r, n, i) => {
  if (Gt(r) !== "object")
    return !0;
  const s = Ge.collectEvaluatedProperties(t, r, n, i, !0);
  if (!s)
    return !1;
  for (const [o, a] of Pc(r)) {
    const l = kr(o);
    if (!s.has(l)) {
      if (!Ge.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, Qhe = { id: Hhe, compile: Ghe, interpret: Whe, collectEvaluatedProperties: qhe }, Khe = "https://json-schema.org/keyword/uniqueItems", Yhe = (t) => It(t), Zhe = (t, e) => {
  if (Gt(e) !== "array" || t === !1)
    return !0;
  const r = kr(e).map(Ng);
  return new Set(r).size === r.length;
}, Jhe = { id: Khe, compile: Yhe, interpret: Zhe }, VD = "https://json-schema.org/keyword/unknown", Xhe = (t) => [[...Yx(t.cursor)].pop(), It(t)], epe = ([t, e], r, n, i, s, o) => {
  const a = `${VD}#${t}`;
  return Cs(r, a, o, e), !0;
}, tpe = { id: VD, compile: Xhe, interpret: epe }, rpe = { id: "https://json-schema.org/keyword/vocabulary" }, UD = "https://json-schema.org/keyword/writeOnly", npe = (t) => It(t), ipe = (t, e, r, n, i, s) => (Cs(e, UD, s, t), !0), spe = { id: UD, compile: npe, interpret: ipe };
hD("application/schema+json", qoe);
lt(Eae);
lt(Iae);
lt(Pae);
lt(Nae);
lt(zae);
lt(Qae);
lt(Jae);
lt(rle);
lt(sle);
lt(lle);
lt(hle);
lt(fle);
lt(ble);
lt(Ele);
lt(Cle);
lt(Rle);
lt(Lle);
lt(Mle);
lt(Fle);
lt(Wle);
lt(Yle);
lt(Xle);
lt(nce);
lt(ace);
lt(uce);
lt(hce);
lt(yce);
lt(Oce);
lt(Nce);
lt(Bce);
lt(Uce);
lt(qce);
lt(Zce);
lt(tue);
lt(sue);
lt(cue);
lt(due);
lt(yue);
lt(xue);
lt(kue);
lt(Pue);
lt(Nue);
lt(Bue);
lt(Hue);
lt(Que);
lt(Xue);
lt(ihe);
lt(lhe);
lt(hhe);
lt(yhe);
lt(xhe);
lt(khe);
lt(Ihe);
lt(Mhe);
lt(jhe);
lt(Uhe);
lt(Qhe);
lt(Jhe);
lt(tpe);
lt(rpe);
lt(spe);
const ope = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://json-schema.org/draft/2020-12/schema",
  $vocabulary: {
    "https://json-schema.org/draft/2020-12/vocab/core": !0,
    "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
    "https://json-schema.org/draft/2020-12/vocab/validation": !0,
    "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
    "https://json-schema.org/draft/2020-12/vocab/content": !0
  },
  $dynamicAnchor: "meta",
  title: "Core and Validation specifications meta-schema",
  allOf: [
    { $ref: "meta/core" },
    { $ref: "meta/applicator" },
    { $ref: "meta/unevaluated" },
    { $ref: "meta/validation" },
    { $ref: "meta/meta-data" },
    { $ref: "meta/format-annotation" },
    { $ref: "meta/content" }
  ],
  type: ["object", "boolean"],
  properties: {
    definitions: {
      $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    dependencies: {
      $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
      type: "object",
      additionalProperties: {
        anyOf: [
          { $dynamicRef: "#meta" },
          { $ref: "meta/validation#/$defs/stringArray" }
        ]
      }
    }
  }
}, ape = {
  $id: "https://json-schema.org/draft/2020-12/meta/core",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Core vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    $id: {
      type: "string",
      format: "uri-reference",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $anchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicRef: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicAnchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        type: "string",
        format: "uri"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    }
  }
}, lpe = {
  $id: "https://json-schema.org/draft/2020-12/meta/applicator",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    prefixItems: { $ref: "#/$defs/schemaArray" },
    items: { $dynamicRef: "#meta" },
    contains: { $dynamicRef: "#meta" },
    additionalProperties: { $dynamicRef: "#meta" },
    properties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      propertyNames: { format: "regex" },
      default: {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      }
    },
    propertyNames: { $dynamicRef: "#meta" },
    if: { $dynamicRef: "#meta" },
    then: { $dynamicRef: "#meta" },
    else: { $dynamicRef: "#meta" },
    allOf: { $ref: "#/$defs/schemaArray" },
    anyOf: { $ref: "#/$defs/schemaArray" },
    oneOf: { $ref: "#/$defs/schemaArray" },
    not: { $dynamicRef: "#meta" }
  },
  $defs: {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: { $dynamicRef: "#meta" }
    }
  }
}, cpe = {
  $id: "https://json-schema.org/draft/2020-12/meta/validation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Validation vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: { $ref: "#/$defs/nonNegativeInteger" },
    minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: { $ref: "#/$defs/nonNegativeInteger" },
    minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    uniqueItems: {
      type: "boolean",
      default: !1
    },
    maxContains: { $ref: "#/$defs/nonNegativeInteger" },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 1
    },
    maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
    minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    required: { $ref: "#/$defs/stringArray" },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    },
    const: !0,
    enum: {
      type: "array",
      items: !0
    },
    type: {
      anyOf: [
        { $ref: "#/$defs/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/$defs/simpleTypes" },
          minItems: 1,
          uniqueItems: !0
        }
      ]
    }
  },
  $defs: {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 0
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: []
    }
  }
}, upe = {
  $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Meta-data vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    default: !0,
    deprecated: {
      type: "boolean",
      default: !1
    },
    readOnly: {
      type: "boolean",
      default: !1
    },
    writeOnly: {
      type: "boolean",
      default: !1
    },
    examples: {
      type: "array",
      items: !0
    }
  }
}, hpe = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for annotation results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, ppe = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-assertion",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for assertion results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, dpe = {
  $id: "https://json-schema.org/draft/2020-12/meta/content",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Content vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    contentSchema: { $dynamicRef: "#meta" }
  }
}, fpe = {
  $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Unevaluated applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    unevaluatedItems: { $dynamicRef: "#meta" },
    unevaluatedProperties: { $dynamicRef: "#meta" }
  }
}, gpe = { id: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor" }, mpe = "https://json-schema.org/keyword/draft-2020-12/dynamicRef", ype = async (t, e) => {
  const r = oD(It(t)), n = await Pb(It(t), t);
  return await Ge.compile(n, e), [n.document.baseUri, r, Qp(n)];
}, K5 = (t, [e, r, n], i, s, o, a) => r in s.metaData[e].dynamicAnchors ? (o = { ...s.metaData[e].dynamicAnchors, ...o }, t(o[r], i, s, o, a)) : t(n, i, s, o, a), bpe = (...t) => K5(Ge.interpret, ...t), vpe = (...t) => K5(Ge.collectEvaluatedProperties, ...t), wpe = (...t) => K5(Ge.collectEvaluatedItems, ...t), xpe = { id: mpe, compile: ype, interpret: bpe, collectEvaluatedProperties: vpe, collectEvaluatedItems: wpe };
lt(xpe);
lt(gpe);
Cc("https://json-schema.org/draft/2020-12/vocab/core", {
  $anchor: "https://json-schema.org/keyword/anchor",
  $comment: "https://json-schema.org/keyword/comment",
  $defs: "https://json-schema.org/keyword/definitions",
  $dynamicAnchor: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor",
  $dynamicRef: "https://json-schema.org/keyword/draft-2020-12/dynamicRef",
  $id: "https://json-schema.org/keyword/id",
  $ref: "https://json-schema.org/keyword/ref",
  $vocabulary: "https://json-schema.org/keyword/vocabulary"
});
Cc("https://json-schema.org/draft/2020-12/vocab/applicator", {
  additionalProperties: "https://json-schema.org/keyword/additionalProperties",
  allOf: "https://json-schema.org/keyword/allOf",
  anyOf: "https://json-schema.org/keyword/anyOf",
  contains: "https://json-schema.org/keyword/contains",
  dependentSchemas: "https://json-schema.org/keyword/dependentSchemas",
  if: "https://json-schema.org/keyword/if",
  then: "https://json-schema.org/keyword/then",
  else: "https://json-schema.org/keyword/else",
  items: "https://json-schema.org/keyword/items",
  not: "https://json-schema.org/keyword/not",
  oneOf: "https://json-schema.org/keyword/oneOf",
  patternProperties: "https://json-schema.org/keyword/patternProperties",
  prefixItems: "https://json-schema.org/keyword/prefixItems",
  properties: "https://json-schema.org/keyword/properties",
  propertyNames: "https://json-schema.org/keyword/propertyNames"
});
Cc("https://json-schema.org/draft/2020-12/vocab/validation", {
  const: "https://json-schema.org/keyword/const",
  dependentRequired: "https://json-schema.org/keyword/dependentRequired",
  enum: "https://json-schema.org/keyword/enum",
  exclusiveMaximum: "https://json-schema.org/keyword/exclusiveMaximum",
  exclusiveMinimum: "https://json-schema.org/keyword/exclusiveMinimum",
  maxContains: "https://json-schema.org/keyword/maxContains",
  maxItems: "https://json-schema.org/keyword/maxItems",
  maxLength: "https://json-schema.org/keyword/maxLength",
  maxProperties: "https://json-schema.org/keyword/maxProperties",
  maximum: "https://json-schema.org/keyword/maximum",
  minContains: "https://json-schema.org/keyword/minContains",
  minItems: "https://json-schema.org/keyword/minItems",
  minLength: "https://json-schema.org/keyword/minLength",
  minProperties: "https://json-schema.org/keyword/minProperties",
  minimum: "https://json-schema.org/keyword/minimum",
  multipleOf: "https://json-schema.org/keyword/multipleOf",
  pattern: "https://json-schema.org/keyword/pattern",
  required: "https://json-schema.org/keyword/required",
  type: "https://json-schema.org/keyword/type",
  uniqueItems: "https://json-schema.org/keyword/uniqueItems"
});
Cc("https://json-schema.org/draft/2020-12/vocab/meta-data", {
  default: "https://json-schema.org/keyword/default",
  deprecated: "https://json-schema.org/keyword/deprecated",
  description: "https://json-schema.org/keyword/description",
  examples: "https://json-schema.org/keyword/examples",
  readOnly: "https://json-schema.org/keyword/readOnly",
  title: "https://json-schema.org/keyword/title",
  writeOnly: "https://json-schema.org/keyword/writeOnly"
});
Cc("https://json-schema.org/draft/2020-12/vocab/format-annotation", {
  format: "https://json-schema.org/keyword/format"
});
Cc("https://json-schema.org/draft/2020-12/vocab/format-assertion", {
  format: "https://json-schema.org/keyword/format-assertion"
});
Cc("https://json-schema.org/draft/2020-12/vocab/content", {
  contentEncoding: "https://json-schema.org/keyword/contentEncoding",
  contentMediaType: "https://json-schema.org/keyword/contentMediaType",
  contentSchema: "https://json-schema.org/keyword/contentSchema"
});
Cc("https://json-schema.org/draft/2020-12/vocab/unevaluated", {
  unevaluatedItems: "https://json-schema.org/keyword/unevaluatedItems",
  unevaluatedProperties: "https://json-schema.org/keyword/unevaluatedProperties"
});
lD("https://json-schema.org/draft/2020-12/schema", {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, !0);
Ka(ope);
Ka(ape);
Ka(lpe);
Ka(cpe);
Ka(upe);
Ka(hpe);
Ka(ppe);
Ka(dpe);
Ka(fpe);
function $m(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var r_ = { exports: {} };
/*! jsonpath 1.1.1 */
var n_;
function Epe() {
  return n_ || (n_ = 1, function(t, e) {
    (function(r) {
      t.exports = r();
    })(function() {
      return function r(n, i, s) {
        function o(c, p) {
          if (!i[c]) {
            if (!n[c]) {
              var h = typeof $m == "function" && $m;
              if (!p && h) return h(c, !0);
              if (a) return a(c, !0);
              var d = new Error("Cannot find module '" + c + "'");
              throw d.code = "MODULE_NOT_FOUND", d;
            }
            var b = i[c] = { exports: {} };
            n[c][0].call(b.exports, function(m) {
              var w = n[c][1][m];
              return o(w || m);
            }, b, b.exports, r, n, i, s);
          }
          return i[c].exports;
        }
        for (var a = typeof $m == "function" && $m, l = 0; l < s.length; l++) o(s[l]);
        return o;
      }({ "./aesprim": [function(r, n, i) {
        (function(s, o) {
          o(typeof i < "u" ? i : s.esprima = {});
        })(this, function(s) {
          var o, a, l, c, p, h, d, b, m, w, f, E, A, x, g, v, k, S;
          o = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
          }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
            "(",
            "{",
            "[",
            "in",
            "typeof",
            "instanceof",
            "new",
            "return",
            "case",
            "delete",
            "throw",
            "void",
            // assignment operators
            "=",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "<<=",
            ">>=",
            ">>>=",
            "&=",
            "|=",
            "^=",
            ",",
            // binary/unary operators
            "+",
            "-",
            "*",
            "/",
            "%",
            "++",
            "--",
            "<<",
            ">>",
            ">>>",
            "&",
            "|",
            "^",
            "!",
            "~",
            "&&",
            "||",
            "?",
            ":",
            "===",
            "==",
            ">=",
            "<=",
            "<",
            ">",
            "!=",
            "!=="
          ], c = {
            AssignmentExpression: "AssignmentExpression",
            ArrayExpression: "ArrayExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            Program: "Program",
            Property: "Property",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SwitchStatement: "SwitchStatement",
            SwitchCase: "SwitchCase",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement"
          }, p = {
            Data: 1,
            Get: 2,
            Set: 4
          }, h = {
            UnexpectedToken: "Unexpected token %0",
            UnexpectedNumber: "Unexpected number",
            UnexpectedString: "Unexpected string",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedEOS: "Unexpected end of input",
            NewlineAfterThrow: "Illegal newline after throw",
            InvalidRegExp: "Invalid regular expression",
            UnterminatedRegExp: "Invalid regular expression: missing /",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NoCatchOrFinally: "Missing catch or finally after try",
            UnknownLabel: "Undefined label '%0'",
            Redeclaration: "%0 '%1' has already been declared",
            IllegalContinue: "Illegal continue statement",
            IllegalBreak: "Illegal break statement",
            IllegalReturn: "Illegal return statement",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
            AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
            AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode"
          }, d = {
            NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
            NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
          };
          function R(u, y) {
            if (!u)
              throw new Error("ASSERT: " + y);
          }
          function L(u) {
            return u >= 48 && u <= 57;
          }
          function F(u) {
            return "0123456789abcdefABCDEF".indexOf(u) >= 0;
          }
          function z(u) {
            return "01234567".indexOf(u) >= 0;
          }
          function j(u) {
            return u === 32 || u === 9 || u === 11 || u === 12 || u === 160 || u >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(u) >= 0;
          }
          function ee(u) {
            return u === 10 || u === 13 || u === 8232 || u === 8233;
          }
          function X(u) {
            return u == 64 || u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierStart.test(String.fromCharCode(u));
          }
          function ie(u) {
            return u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u >= 48 && u <= 57 || // 0..9
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierPart.test(String.fromCharCode(u));
          }
          function ce(u) {
            switch (u) {
              case "class":
              case "enum":
              case "export":
              case "extends":
              case "import":
              case "super":
                return !0;
              default:
                return !1;
            }
          }
          function ke(u) {
            switch (u) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return !0;
              default:
                return !1;
            }
          }
          function ye(u) {
            return u === "eval" || u === "arguments";
          }
          function Ce(u) {
            if (w && ke(u))
              return !0;
            switch (u.length) {
              case 2:
                return u === "if" || u === "in" || u === "do";
              case 3:
                return u === "var" || u === "for" || u === "new" || u === "try" || u === "let";
              case 4:
                return u === "this" || u === "else" || u === "case" || u === "void" || u === "with" || u === "enum";
              case 5:
                return u === "while" || u === "break" || u === "catch" || u === "throw" || u === "const" || u === "yield" || u === "class" || u === "super";
              case 6:
                return u === "return" || u === "typeof" || u === "delete" || u === "switch" || u === "export" || u === "import";
              case 7:
                return u === "default" || u === "finally" || u === "extends";
              case 8:
                return u === "function" || u === "continue" || u === "debugger";
              case 10:
                return u === "instanceof";
              default:
                return !1;
            }
          }
          function Ie(u, y, _, T, U) {
            var ne;
            R(typeof _ == "number", "Comment must have valid position"), !(k.lastCommentStart >= _) && (k.lastCommentStart = _, ne = {
              type: u,
              value: y
            }, S.range && (ne.range = [_, T]), S.loc && (ne.loc = U), S.comments.push(ne), S.attachComment && (S.leadingComments.push(ne), S.trailingComments.push(ne)));
          }
          function Te(u) {
            var y, _, T, U;
            for (y = f - u, _ = {
              start: {
                line: E,
                column: f - A - u
              }
            }; f < x; )
              if (T = m.charCodeAt(f), ++f, ee(T)) {
                S.comments && (U = m.slice(y + u, f - 1), _.end = {
                  line: E,
                  column: f - A - 1
                }, Ie("Line", U, y, f - 1, _)), T === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f;
                return;
              }
            S.comments && (U = m.slice(y + u, f), _.end = {
              line: E,
              column: f - A
            }, Ie("Line", U, y, f, _));
          }
          function ue() {
            var u, y, _, T;
            for (S.comments && (u = f - 2, y = {
              start: {
                line: E,
                column: f - A - 2
              }
            }); f < x; )
              if (_ = m.charCodeAt(f), ee(_))
                _ === 13 && m.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && ge({}, h.UnexpectedToken, "ILLEGAL");
              else if (_ === 42) {
                if (m.charCodeAt(f + 1) === 47) {
                  ++f, ++f, S.comments && (T = m.slice(u + 2, f - 2), y.end = {
                    line: E,
                    column: f - A
                  }, Ie("Block", T, u, f, y));
                  return;
                }
                ++f;
              } else
                ++f;
            ge({}, h.UnexpectedToken, "ILLEGAL");
          }
          function O() {
            var u, y;
            for (y = f === 0; f < x; )
              if (u = m.charCodeAt(f), j(u))
                ++f;
              else if (ee(u))
                ++f, u === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f, y = !0;
              else if (u === 47)
                if (u = m.charCodeAt(f + 1), u === 47)
                  ++f, ++f, Te(2), y = !0;
                else if (u === 42)
                  ++f, ++f, ue();
                else
                  break;
              else if (y && u === 45)
                if (m.charCodeAt(f + 1) === 45 && m.charCodeAt(f + 2) === 62)
                  f += 3, Te(3);
                else
                  break;
              else if (u === 60)
                if (m.slice(f + 1, f + 4) === "!--")
                  ++f, ++f, ++f, ++f, Te(4);
                else
                  break;
              else
                break;
          }
          function N(u) {
            var y, _, T, U = 0;
            for (_ = u === "u" ? 4 : 2, y = 0; y < _; ++y)
              if (f < x && F(m[f]))
                T = m[f++], U = U * 16 + "0123456789abcdef".indexOf(T.toLowerCase());
              else
                return "";
            return String.fromCharCode(U);
          }
          function Z() {
            var u, y;
            for (u = m.charCodeAt(f++), y = String.fromCharCode(u), u === 92 && (m.charCodeAt(f) !== 117 && ge({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !X(u.charCodeAt(0))) && ge({}, h.UnexpectedToken, "ILLEGAL"), y = u); f < x && (u = m.charCodeAt(f), !!ie(u)); )
              ++f, y += String.fromCharCode(u), u === 92 && (y = y.substr(0, y.length - 1), m.charCodeAt(f) !== 117 && ge({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !ie(u.charCodeAt(0))) && ge({}, h.UnexpectedToken, "ILLEGAL"), y += u);
            return y;
          }
          function re() {
            var u, y;
            for (u = f++; f < x; ) {
              if (y = m.charCodeAt(f), y === 92)
                return f = u, Z();
              if (ie(y))
                ++f;
              else
                break;
            }
            return m.slice(u, f);
          }
          function le() {
            var u, y, _;
            return u = f, y = m.charCodeAt(f) === 92 ? Z() : re(), y.length === 1 ? _ = o.Identifier : Ce(y) ? _ = o.Keyword : y === "null" ? _ = o.NullLiteral : y === "true" || y === "false" ? _ = o.BooleanLiteral : _ = o.Identifier, {
              type: _,
              value: y,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function te() {
            var u = f, y = m.charCodeAt(f), _, T = m[f], U, ne, _e;
            switch (y) {
              case 46:
              case 40:
              case 41:
              case 59:
              case 44:
              case 123:
              case 125:
              case 91:
              case 93:
              case 58:
              case 63:
              case 126:
                return ++f, S.tokenize && (y === 40 ? S.openParenToken = S.tokens.length : y === 123 && (S.openCurlyToken = S.tokens.length)), {
                  type: o.Punctuator,
                  value: String.fromCharCode(y),
                  lineNumber: E,
                  lineStart: A,
                  start: u,
                  end: f
                };
              default:
                if (_ = m.charCodeAt(f + 1), _ === 61)
                  switch (y) {
                    case 43:
                    case 45:
                    case 47:
                    case 60:
                    case 62:
                    case 94:
                    case 124:
                    case 37:
                    case 38:
                    case 42:
                      return f += 2, {
                        type: o.Punctuator,
                        value: String.fromCharCode(y) + String.fromCharCode(_),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                    case 33:
                    case 61:
                      return f += 2, m.charCodeAt(f) === 61 && ++f, {
                        type: o.Punctuator,
                        value: m.slice(u, f),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                  }
            }
            if (_e = m.substr(f, 4), _e === ">>>=")
              return f += 4, {
                type: o.Punctuator,
                value: _e,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (ne = _e.substr(0, 3), ne === ">>>" || ne === "<<=" || ne === ">>=")
              return f += 3, {
                type: o.Punctuator,
                value: ne,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (U = ne.substr(0, 2), T === U[1] && "+-<>&|".indexOf(T) >= 0 || U === "=>")
              return f += 2, {
                type: o.Punctuator,
                value: U,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if ("<>=!+-*%&|^/".indexOf(T) >= 0)
              return ++f, {
                type: o.Punctuator,
                value: T,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            ge({}, h.UnexpectedToken, "ILLEGAL");
          }
          function oe(u) {
            for (var y = ""; f < x && F(m[f]); )
              y += m[f++];
            return y.length === 0 && ge({}, h.UnexpectedToken, "ILLEGAL"), X(m.charCodeAt(f)) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt("0x" + y, 16),
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function fe(u) {
            for (var y = "0" + m[f++]; f < x && z(m[f]); )
              y += m[f++];
            return (X(m.charCodeAt(f)) || L(m.charCodeAt(f))) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt(y, 8),
              octal: !0,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function H() {
            var u, y, _;
            if (_ = m[f], R(
              L(_.charCodeAt(0)) || _ === ".",
              "Numeric literal must start with a decimal digit or a decimal point"
            ), y = f, u = "", _ !== ".") {
              if (u = m[f++], _ = m[f], u === "0") {
                if (_ === "x" || _ === "X")
                  return ++f, oe(y);
                if (z(_))
                  return fe(y);
                _ && L(_.charCodeAt(0)) && ge({}, h.UnexpectedToken, "ILLEGAL");
              }
              for (; L(m.charCodeAt(f)); )
                u += m[f++];
              _ = m[f];
            }
            if (_ === ".") {
              for (u += m[f++]; L(m.charCodeAt(f)); )
                u += m[f++];
              _ = m[f];
            }
            if (_ === "e" || _ === "E")
              if (u += m[f++], _ = m[f], (_ === "+" || _ === "-") && (u += m[f++]), L(m.charCodeAt(f)))
                for (; L(m.charCodeAt(f)); )
                  u += m[f++];
              else
                ge({}, h.UnexpectedToken, "ILLEGAL");
            return X(m.charCodeAt(f)) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseFloat(u),
              lineNumber: E,
              lineStart: A,
              start: y,
              end: f
            };
          }
          function J() {
            var u = "", y, _, T, U, ne, _e, Ne = !1, et, Xe;
            for (et = E, Xe = A, y = m[f], R(
              y === "'" || y === '"',
              "String literal must starts with a quote"
            ), _ = f, ++f; f < x; )
              if (T = m[f++], T === y) {
                y = "";
                break;
              } else if (T === "\\")
                if (T = m[f++], !T || !ee(T.charCodeAt(0)))
                  switch (T) {
                    case "u":
                    case "x":
                      _e = f, ne = N(T), ne ? u += ne : (f = _e, u += T);
                      break;
                    case "n":
                      u += `
`;
                      break;
                    case "r":
                      u += "\r";
                      break;
                    case "t":
                      u += "	";
                      break;
                    case "b":
                      u += "\b";
                      break;
                    case "f":
                      u += "\f";
                      break;
                    case "v":
                      u += "\v";
                      break;
                    default:
                      z(T) ? (U = "01234567".indexOf(T), U !== 0 && (Ne = !0), f < x && z(m[f]) && (Ne = !0, U = U * 8 + "01234567".indexOf(m[f++]), "0123".indexOf(T) >= 0 && f < x && z(m[f]) && (U = U * 8 + "01234567".indexOf(m[f++]))), u += String.fromCharCode(U)) : u += T;
                      break;
                  }
                else
                  ++E, T === "\r" && m[f] === `
` && ++f, A = f;
              else {
                if (ee(T.charCodeAt(0)))
                  break;
                u += T;
              }
            return y !== "" && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.StringLiteral,
              value: u,
              octal: Ne,
              startLineNumber: et,
              startLineStart: Xe,
              lineNumber: E,
              lineStart: A,
              start: _,
              end: f
            };
          }
          function Se(u, y) {
            var _;
            try {
              _ = new RegExp(u, y);
            } catch {
              ge({}, h.InvalidRegExp);
            }
            return _;
          }
          function Re() {
            var u, y, _, T, U;
            for (u = m[f], R(u === "/", "Regular expression literal must start with a slash"), y = m[f++], _ = !1, T = !1; f < x; )
              if (u = m[f++], y += u, u === "\\")
                u = m[f++], ee(u.charCodeAt(0)) && ge({}, h.UnterminatedRegExp), y += u;
              else if (ee(u.charCodeAt(0)))
                ge({}, h.UnterminatedRegExp);
              else if (_)
                u === "]" && (_ = !1);
              else if (u === "/") {
                T = !0;
                break;
              } else u === "[" && (_ = !0);
            return T || ge({}, h.UnterminatedRegExp), U = y.substr(1, y.length - 2), {
              value: U,
              literal: y
            };
          }
          function Fe() {
            var u, y, _, T;
            for (y = "", _ = ""; f < x && (u = m[f], !!ie(u.charCodeAt(0))); )
              if (++f, u === "\\" && f < x)
                if (u = m[f], u === "u") {
                  if (++f, T = f, u = N("u"), u)
                    for (_ += u, y += "\\u"; T < f; ++T)
                      y += m[T];
                  else
                    f = T, _ += "u", y += "\\u";
                  be({}, h.UnexpectedToken, "ILLEGAL");
                } else
                  y += "\\", be({}, h.UnexpectedToken, "ILLEGAL");
              else
                _ += u, y += u;
            return {
              value: _,
              literal: y
            };
          }
          function Le() {
            var u, y, _, T;
            return v = null, O(), u = f, y = Re(), _ = Fe(), T = Se(y.value, _.value), S.tokenize ? {
              type: o.RegularExpression,
              value: T,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            } : {
              literal: y.literal + _.literal,
              value: T,
              start: u,
              end: f
            };
          }
          function ze() {
            var u, y, _, T;
            return O(), u = f, y = {
              start: {
                line: E,
                column: f - A
              }
            }, _ = Le(), y.end = {
              line: E,
              column: f - A
            }, S.tokenize || (S.tokens.length > 0 && (T = S.tokens[S.tokens.length - 1], T.range[0] === u && T.type === "Punctuator" && (T.value === "/" || T.value === "/=") && S.tokens.pop()), S.tokens.push({
              type: "RegularExpression",
              value: _.literal,
              range: [u, f],
              loc: y
            })), _;
          }
          function tt(u) {
            return u.type === o.Identifier || u.type === o.Keyword || u.type === o.BooleanLiteral || u.type === o.NullLiteral;
          }
          function Pe() {
            var u, y;
            if (u = S.tokens[S.tokens.length - 1], !u)
              return ze();
            if (u.type === "Punctuator") {
              if (u.value === "]")
                return te();
              if (u.value === ")")
                return y = S.tokens[S.openParenToken - 1], y && y.type === "Keyword" && (y.value === "if" || y.value === "while" || y.value === "for" || y.value === "with") ? ze() : te();
              if (u.value === "}") {
                if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 4], !y)
                    return te();
                } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 5], !y)
                    return ze();
                } else
                  return te();
                return l.indexOf(y.value) >= 0 ? te() : ze();
              }
              return ze();
            }
            return u.type === "Keyword" ? ze() : te();
          }
          function At() {
            var u;
            return O(), f >= x ? {
              type: o.EOF,
              lineNumber: E,
              lineStart: A,
              start: f,
              end: f
            } : (u = m.charCodeAt(f), X(u) ? le() : u === 40 || u === 41 || u === 59 ? te() : u === 39 || u === 34 ? J() : u === 46 ? L(m.charCodeAt(f + 1)) ? H() : te() : L(u) ? H() : S.tokenize && u === 47 ? Pe() : te());
          }
          function er() {
            var u, y, _;
            return O(), u = {
              start: {
                line: E,
                column: f - A
              }
            }, y = At(), u.end = {
              line: E,
              column: f - A
            }, y.type !== o.EOF && (_ = m.slice(y.start, y.end), S.tokens.push({
              type: a[y.type],
              value: _,
              range: [y.start, y.end],
              loc: u
            })), y;
          }
          function me() {
            var u;
            return u = v, f = u.end, E = u.lineNumber, A = u.lineStart, v = typeof S.tokens < "u" ? er() : At(), f = u.end, E = u.lineNumber, A = u.lineStart, u;
          }
          function ht() {
            var u, y, _;
            u = f, y = E, _ = A, v = typeof S.tokens < "u" ? er() : At(), f = u, E = y, A = _;
          }
          function it(u, y) {
            this.line = u, this.column = y;
          }
          function kt(u, y, _, T) {
            this.start = new it(u, y), this.end = new it(_, T);
          }
          b = {
            name: "SyntaxTree",
            processComment: function(u) {
              var y, _;
              if (!(u.type === c.Program && u.body.length > 0)) {
                for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= u.range[1] ? (_ = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= u.range[1] && (_ = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= u.range[0]; )
                  y = S.bottomRightStack.pop();
                y ? y.leadingComments && y.leadingComments[y.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = y.leadingComments, delete y.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = S.leadingComments, S.leadingComments = []), _ && (u.trailingComments = _), S.bottomRightStack.push(u);
              }
            },
            markEnd: function(u, y) {
              return S.range && (u.range = [y.start, f]), S.loc && (u.loc = new kt(
                y.startLineNumber === void 0 ? y.lineNumber : y.startLineNumber,
                y.start - (y.startLineStart === void 0 ? y.lineStart : y.startLineStart),
                E,
                f - A
              ), this.postProcess(u)), S.attachComment && this.processComment(u), u;
            },
            postProcess: function(u) {
              return S.source && (u.loc.source = S.source), u;
            },
            createArrayExpression: function(u) {
              return {
                type: c.ArrayExpression,
                elements: u
              };
            },
            createAssignmentExpression: function(u, y, _) {
              return {
                type: c.AssignmentExpression,
                operator: u,
                left: y,
                right: _
              };
            },
            createBinaryExpression: function(u, y, _) {
              var T = u === "||" || u === "&&" ? c.LogicalExpression : c.BinaryExpression;
              return {
                type: T,
                operator: u,
                left: y,
                right: _
              };
            },
            createBlockStatement: function(u) {
              return {
                type: c.BlockStatement,
                body: u
              };
            },
            createBreakStatement: function(u) {
              return {
                type: c.BreakStatement,
                label: u
              };
            },
            createCallExpression: function(u, y) {
              return {
                type: c.CallExpression,
                callee: u,
                arguments: y
              };
            },
            createCatchClause: function(u, y) {
              return {
                type: c.CatchClause,
                param: u,
                body: y
              };
            },
            createConditionalExpression: function(u, y, _) {
              return {
                type: c.ConditionalExpression,
                test: u,
                consequent: y,
                alternate: _
              };
            },
            createContinueStatement: function(u) {
              return {
                type: c.ContinueStatement,
                label: u
              };
            },
            createDebuggerStatement: function() {
              return {
                type: c.DebuggerStatement
              };
            },
            createDoWhileStatement: function(u, y) {
              return {
                type: c.DoWhileStatement,
                body: u,
                test: y
              };
            },
            createEmptyStatement: function() {
              return {
                type: c.EmptyStatement
              };
            },
            createExpressionStatement: function(u) {
              return {
                type: c.ExpressionStatement,
                expression: u
              };
            },
            createForStatement: function(u, y, _, T) {
              return {
                type: c.ForStatement,
                init: u,
                test: y,
                update: _,
                body: T
              };
            },
            createForInStatement: function(u, y, _) {
              return {
                type: c.ForInStatement,
                left: u,
                right: y,
                body: _,
                each: !1
              };
            },
            createFunctionDeclaration: function(u, y, _, T) {
              return {
                type: c.FunctionDeclaration,
                id: u,
                params: y,
                defaults: _,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createFunctionExpression: function(u, y, _, T) {
              return {
                type: c.FunctionExpression,
                id: u,
                params: y,
                defaults: _,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createIdentifier: function(u) {
              return {
                type: c.Identifier,
                name: u
              };
            },
            createIfStatement: function(u, y, _) {
              return {
                type: c.IfStatement,
                test: u,
                consequent: y,
                alternate: _
              };
            },
            createLabeledStatement: function(u, y) {
              return {
                type: c.LabeledStatement,
                label: u,
                body: y
              };
            },
            createLiteral: function(u) {
              return {
                type: c.Literal,
                value: u.value,
                raw: m.slice(u.start, u.end)
              };
            },
            createMemberExpression: function(u, y, _) {
              return {
                type: c.MemberExpression,
                computed: u === "[",
                object: y,
                property: _
              };
            },
            createNewExpression: function(u, y) {
              return {
                type: c.NewExpression,
                callee: u,
                arguments: y
              };
            },
            createObjectExpression: function(u) {
              return {
                type: c.ObjectExpression,
                properties: u
              };
            },
            createPostfixExpression: function(u, y) {
              return {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !1
              };
            },
            createProgram: function(u) {
              return {
                type: c.Program,
                body: u
              };
            },
            createProperty: function(u, y, _) {
              return {
                type: c.Property,
                key: y,
                value: _,
                kind: u
              };
            },
            createReturnStatement: function(u) {
              return {
                type: c.ReturnStatement,
                argument: u
              };
            },
            createSequenceExpression: function(u) {
              return {
                type: c.SequenceExpression,
                expressions: u
              };
            },
            createSwitchCase: function(u, y) {
              return {
                type: c.SwitchCase,
                test: u,
                consequent: y
              };
            },
            createSwitchStatement: function(u, y) {
              return {
                type: c.SwitchStatement,
                discriminant: u,
                cases: y
              };
            },
            createThisExpression: function() {
              return {
                type: c.ThisExpression
              };
            },
            createThrowStatement: function(u) {
              return {
                type: c.ThrowStatement,
                argument: u
              };
            },
            createTryStatement: function(u, y, _, T) {
              return {
                type: c.TryStatement,
                block: u,
                guardedHandlers: y,
                handlers: _,
                finalizer: T
              };
            },
            createUnaryExpression: function(u, y) {
              return u === "++" || u === "--" ? {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !0
              } : {
                type: c.UnaryExpression,
                operator: u,
                argument: y,
                prefix: !0
              };
            },
            createVariableDeclaration: function(u, y) {
              return {
                type: c.VariableDeclaration,
                declarations: u,
                kind: y
              };
            },
            createVariableDeclarator: function(u, y) {
              return {
                type: c.VariableDeclarator,
                id: u,
                init: y
              };
            },
            createWhileStatement: function(u, y) {
              return {
                type: c.WhileStatement,
                test: u,
                body: y
              };
            },
            createWithStatement: function(u, y) {
              return {
                type: c.WithStatement,
                object: u,
                body: y
              };
            }
          };
          function Ze() {
            var u, y, _, T;
            return u = f, y = E, _ = A, O(), T = E !== y, f = u, E = y, A = _, T;
          }
          function ge(u, y) {
            var _, T = Array.prototype.slice.call(arguments, 2), U = y.replace(
              /%(\d)/g,
              function(ne, _e) {
                return R(_e < T.length, "Message reference must be in range"), T[_e];
              }
            );
            throw typeof u.lineNumber == "number" ? (_ = new Error("Line " + u.lineNumber + ": " + U), _.index = u.start, _.lineNumber = u.lineNumber, _.column = u.start - A + 1) : (_ = new Error("Line " + E + ": " + U), _.index = f, _.lineNumber = E, _.column = f - A + 1), _.description = U, _;
          }
          function be() {
            try {
              ge.apply(null, arguments);
            } catch (u) {
              if (S.errors)
                S.errors.push(u);
              else
                throw u;
            }
          }
          function Je(u) {
            if (u.type === o.EOF && ge(u, h.UnexpectedEOS), u.type === o.NumericLiteral && ge(u, h.UnexpectedNumber), u.type === o.StringLiteral && ge(u, h.UnexpectedString), u.type === o.Identifier && ge(u, h.UnexpectedIdentifier), u.type === o.Keyword) {
              if (ce(u.value))
                ge(u, h.UnexpectedReserved);
              else if (w && ke(u.value)) {
                be(u, h.StrictReservedWord);
                return;
              }
              ge(u, h.UnexpectedToken, u.value);
            }
            ge(u, h.UnexpectedToken, u.value);
          }
          function C(u) {
            var y = me();
            (y.type !== o.Punctuator || y.value !== u) && Je(y);
          }
          function $(u) {
            var y = me();
            (y.type !== o.Keyword || y.value !== u) && Je(y);
          }
          function D(u) {
            return v.type === o.Punctuator && v.value === u;
          }
          function ae(u) {
            return v.type === o.Keyword && v.value === u;
          }
          function pe() {
            var u;
            return v.type !== o.Punctuator ? !1 : (u = v.value, u === "=" || u === "*=" || u === "/=" || u === "%=" || u === "+=" || u === "-=" || u === "<<=" || u === ">>=" || u === ">>>=" || u === "&=" || u === "^=" || u === "|=");
          }
          function Ee() {
            var u;
            if (m.charCodeAt(f) === 59 || D(";")) {
              me();
              return;
            }
            u = E, O(), E === u && v.type !== o.EOF && !D("}") && Je(v);
          }
          function Me(u) {
            return u.type === c.Identifier || u.type === c.MemberExpression;
          }
          function ot() {
            var u = [], y;
            for (y = v, C("["); !D("]"); )
              D(",") ? (me(), u.push(null)) : (u.push(W()), D("]") || C(","));
            return me(), g.markEnd(g.createArrayExpression(u), y);
          }
          function dt(u, y) {
            var _, T, U;
            return _ = w, U = v, T = Un(), y && w && ye(u[0].name) && be(y, h.StrictParamName), w = _, g.markEnd(g.createFunctionExpression(null, u, [], T), U);
          }
          function St() {
            var u, y;
            return y = v, u = me(), u.type === o.StringLiteral || u.type === o.NumericLiteral ? (w && u.octal && be(u, h.StrictOctalLiteral), g.markEnd(g.createLiteral(u), y)) : g.markEnd(g.createIdentifier(u.value), y);
          }
          function rt() {
            var u, y, _, T, U, ne;
            if (u = v, ne = v, u.type === o.Identifier)
              return _ = St(), u.value === "get" && !D(":") ? (y = St(), C("("), C(")"), T = dt([]), g.markEnd(g.createProperty("get", y, T), ne)) : u.value === "set" && !D(":") ? (y = St(), C("("), u = v, u.type !== o.Identifier ? (C(")"), be(u, h.UnexpectedToken, u.value), T = dt([])) : (U = [he()], C(")"), T = dt(U, u)), g.markEnd(g.createProperty("set", y, T), ne)) : (C(":"), T = W(), g.markEnd(g.createProperty("init", _, T), ne));
            if (u.type === o.EOF || u.type === o.Punctuator)
              Je(u);
            else
              return y = St(), C(":"), T = W(), g.markEnd(g.createProperty("init", y, T), ne);
          }
          function zt() {
            var u = [], y, _, T, U, ne = {}, _e = String, Ne;
            for (Ne = v, C("{"); !D("}"); )
              y = rt(), y.key.type === c.Identifier ? _ = y.key.name : _ = _e(y.key.value), U = y.kind === "init" ? p.Data : y.kind === "get" ? p.Get : p.Set, T = "$" + _, Object.prototype.hasOwnProperty.call(ne, T) ? (ne[T] === p.Data ? w && U === p.Data ? be({}, h.StrictDuplicateProperty) : U !== p.Data && be({}, h.AccessorDataProperty) : U === p.Data ? be({}, h.AccessorDataProperty) : ne[T] & U && be({}, h.AccessorGetSet), ne[T] |= U) : ne[T] = U, u.push(y), D("}") || C(",");
            return C("}"), g.markEnd(g.createObjectExpression(u), Ne);
          }
          function Xt() {
            var u;
            return C("("), u = G(), C(")"), u;
          }
          function tr() {
            var u, y, _, T;
            if (D("("))
              return Xt();
            if (D("["))
              return ot();
            if (D("{"))
              return zt();
            if (u = v.type, T = v, u === o.Identifier)
              _ = g.createIdentifier(me().value);
            else if (u === o.StringLiteral || u === o.NumericLiteral)
              w && v.octal && be(v, h.StrictOctalLiteral), _ = g.createLiteral(me());
            else if (u === o.Keyword) {
              if (ae("function"))
                return uu();
              ae("this") ? (me(), _ = g.createThisExpression()) : Je(me());
            } else u === o.BooleanLiteral ? (y = me(), y.value = y.value === "true", _ = g.createLiteral(y)) : u === o.NullLiteral ? (y = me(), y.value = null, _ = g.createLiteral(y)) : D("/") || D("/=") ? (typeof S.tokens < "u" ? _ = g.createLiteral(ze()) : _ = g.createLiteral(Le()), ht()) : Je(me());
            return g.markEnd(_, T);
          }
          function Nr() {
            var u = [];
            if (C("("), !D(")"))
              for (; f < x && (u.push(W()), !D(")")); )
                C(",");
            return C(")"), u;
          }
          function ki() {
            var u, y;
            return y = v, u = me(), tt(u) || Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function Zt() {
            return C("."), ki();
          }
          function Vn() {
            var u;
            return C("["), u = G(), C("]"), u;
          }
          function M() {
            var u, y, _;
            return _ = v, $("new"), u = q(), y = D("(") ? Nr() : [], g.markEnd(g.createNewExpression(u, y), _);
          }
          function V() {
            var u, y, _, T, U;
            for (U = v, u = k.allowIn, k.allowIn = !0, y = ae("new") ? M() : tr(), k.allowIn = u; ; ) {
              if (D("."))
                T = Zt(), y = g.createMemberExpression(".", y, T);
              else if (D("("))
                _ = Nr(), y = g.createCallExpression(y, _);
              else if (D("["))
                T = Vn(), y = g.createMemberExpression("[", y, T);
              else
                break;
              g.markEnd(y, U);
            }
            return y;
          }
          function q() {
            var u, y, _, T;
            for (T = v, u = k.allowIn, y = ae("new") ? M() : tr(), k.allowIn = u; D(".") || D("["); )
              D("[") ? (_ = Vn(), y = g.createMemberExpression("[", y, _)) : (_ = Zt(), y = g.createMemberExpression(".", y, _)), g.markEnd(y, T);
            return y;
          }
          function de() {
            var u, y, _ = v;
            return u = V(), v.type === o.Punctuator && (D("++") || D("--")) && !Ze() && (w && u.type === c.Identifier && ye(u.name) && be({}, h.StrictLHSPostfix), Me(u) || be({}, h.InvalidLHSInAssignment), y = me(), u = g.markEnd(g.createPostfixExpression(y.value, u), _)), u;
          }
          function ve() {
            var u, y, _;
            return v.type !== o.Punctuator && v.type !== o.Keyword ? y = de() : D("++") || D("--") ? (_ = v, u = me(), y = ve(), w && y.type === c.Identifier && ye(y.name) && be({}, h.StrictLHSPrefix), Me(y) || be({}, h.InvalidLHSInAssignment), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _)) : D("+") || D("-") || D("~") || D("!") ? (_ = v, u = me(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _)) : ae("delete") || ae("void") || ae("typeof") ? (_ = v, u = me(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _), w && y.operator === "delete" && y.argument.type === c.Identifier && be({}, h.StrictDelete)) : y = de(), y;
          }
          function Y(u, y) {
            var _ = 0;
            if (u.type !== o.Punctuator && u.type !== o.Keyword)
              return 0;
            switch (u.value) {
              case "||":
                _ = 1;
                break;
              case "&&":
                _ = 2;
                break;
              case "|":
                _ = 3;
                break;
              case "^":
                _ = 4;
                break;
              case "&":
                _ = 5;
                break;
              case "==":
              case "!=":
              case "===":
              case "!==":
                _ = 6;
                break;
              case "<":
              case ">":
              case "<=":
              case ">=":
              case "instanceof":
                _ = 7;
                break;
              case "in":
                _ = y ? 7 : 0;
                break;
              case "<<":
              case ">>":
              case ">>>":
                _ = 8;
                break;
              case "+":
              case "-":
                _ = 9;
                break;
              case "*":
              case "/":
              case "%":
                _ = 11;
                break;
            }
            return _;
          }
          function I() {
            var u, y, _, T, U, ne, _e, Ne, et, Xe;
            if (u = v, et = ve(), T = v, U = Y(T, k.allowIn), U === 0)
              return et;
            for (T.prec = U, me(), y = [u, v], _e = ve(), ne = [et, T, _e]; (U = Y(v, k.allowIn)) > 0; ) {
              for (; ne.length > 2 && U <= ne[ne.length - 2].prec; )
                _e = ne.pop(), Ne = ne.pop().value, et = ne.pop(), _ = g.createBinaryExpression(Ne, et, _e), y.pop(), u = y[y.length - 1], g.markEnd(_, u), ne.push(_);
              T = me(), T.prec = U, ne.push(T), y.push(v), _ = ve(), ne.push(_);
            }
            for (Xe = ne.length - 1, _ = ne[Xe], y.pop(); Xe > 1; )
              _ = g.createBinaryExpression(ne[Xe - 1].value, ne[Xe - 2], _), Xe -= 2, u = y.pop(), g.markEnd(_, u);
            return _;
          }
          function B() {
            var u, y, _, T, U;
            return U = v, u = I(), D("?") && (me(), y = k.allowIn, k.allowIn = !0, _ = W(), k.allowIn = y, C(":"), T = W(), u = g.createConditionalExpression(u, _, T), g.markEnd(u, U)), u;
          }
          function W() {
            var u, y, _, T, U;
            return u = v, U = v, T = y = B(), pe() && (Me(y) || be({}, h.InvalidLHSInAssignment), w && y.type === c.Identifier && ye(y.name) && be(u, h.StrictLHSAssignment), u = me(), _ = W(), T = g.markEnd(g.createAssignmentExpression(u.value, y, _), U)), T;
          }
          function G() {
            var u, y = v;
            if (u = W(), D(",")) {
              for (u = g.createSequenceExpression([u]); f < x && D(","); )
                me(), u.expressions.push(W());
              g.markEnd(u, y);
            }
            return u;
          }
          function K() {
            for (var u = [], y; f < x && !(D("}") || (y = Ir(), typeof y > "u")); )
              u.push(y);
            return u;
          }
          function se() {
            var u, y;
            return y = v, C("{"), u = K(), C("}"), g.markEnd(g.createBlockStatement(u), y);
          }
          function he() {
            var u, y;
            return y = v, u = me(), u.type !== o.Identifier && Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function we(u) {
            var y = null, _, T;
            return T = v, _ = he(), w && ye(_.name) && be({}, h.StrictVarName), u === "const" ? (C("="), y = W()) : D("=") && (me(), y = W()), g.markEnd(g.createVariableDeclarator(_, y), T);
          }
          function Ae(u) {
            var y = [];
            do {
              if (y.push(we(u)), !D(","))
                break;
              me();
            } while (f < x);
            return y;
          }
          function $e() {
            var u;
            return $("var"), u = Ae(), Ee(), g.createVariableDeclaration(u, "var");
          }
          function je(u) {
            var y, _;
            return _ = v, $(u), y = Ae(u), Ee(), g.markEnd(g.createVariableDeclaration(y, u), _);
          }
          function Qe() {
            return C(";"), g.createEmptyStatement();
          }
          function ut() {
            var u = G();
            return Ee(), g.createExpressionStatement(u);
          }
          function st() {
            var u, y, _;
            return $("if"), C("("), u = G(), C(")"), y = Ot(), ae("else") ? (me(), _ = Ot()) : _ = null, g.createIfStatement(u, y, _);
          }
          function Rt() {
            var u, y, _;
            return $("do"), _ = k.inIteration, k.inIteration = !0, u = Ot(), k.inIteration = _, $("while"), C("("), y = G(), C(")"), D(";") && me(), g.createDoWhileStatement(u, y);
          }
          function $t() {
            var u, y, _;
            return $("while"), C("("), u = G(), C(")"), _ = k.inIteration, k.inIteration = !0, y = Ot(), k.inIteration = _, g.createWhileStatement(u, y);
          }
          function Or() {
            var u, y, _;
            return _ = v, u = me(), y = Ae(), g.markEnd(g.createVariableDeclaration(y, u.value), _);
          }
          function an() {
            var u, y, _, T, U, ne, _e;
            return u = y = _ = null, $("for"), C("("), D(";") ? me() : (ae("var") || ae("let") ? (k.allowIn = !1, u = Or(), k.allowIn = !0, u.declarations.length === 1 && ae("in") && (me(), T = u, U = G(), u = null)) : (k.allowIn = !1, u = G(), k.allowIn = !0, ae("in") && (Me(u) || be({}, h.InvalidLHSInForIn), me(), T = u, U = G(), u = null)), typeof T > "u" && C(";")), typeof T > "u" && (D(";") || (y = G()), C(";"), D(")") || (_ = G())), C(")"), _e = k.inIteration, k.inIteration = !0, ne = Ot(), k.inIteration = _e, typeof T > "u" ? g.createForStatement(u, y, _, ne) : g.createForInStatement(T, U, ne);
          }
          function wo() {
            var u = null, y;
            return $("continue"), m.charCodeAt(f) === 59 ? (me(), k.inIteration || ge({}, h.IllegalContinue), g.createContinueStatement(null)) : Ze() ? (k.inIteration || ge({}, h.IllegalContinue), g.createContinueStatement(null)) : (v.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(k.labelSet, y) || ge({}, h.UnknownLabel, u.name)), Ee(), u === null && !k.inIteration && ge({}, h.IllegalContinue), g.createContinueStatement(u));
          }
          function xo() {
            var u = null, y;
            return $("break"), m.charCodeAt(f) === 59 ? (me(), k.inIteration || k.inSwitch || ge({}, h.IllegalBreak), g.createBreakStatement(null)) : Ze() ? (k.inIteration || k.inSwitch || ge({}, h.IllegalBreak), g.createBreakStatement(null)) : (v.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(k.labelSet, y) || ge({}, h.UnknownLabel, u.name)), Ee(), u === null && !(k.inIteration || k.inSwitch) && ge({}, h.IllegalBreak), g.createBreakStatement(u));
          }
          function ru() {
            var u = null;
            return $("return"), k.inFunctionBody || be({}, h.IllegalReturn), m.charCodeAt(f) === 32 && X(m.charCodeAt(f + 1)) ? (u = G(), Ee(), g.createReturnStatement(u)) : Ze() ? g.createReturnStatement(null) : (D(";") || !D("}") && v.type !== o.EOF && (u = G()), Ee(), g.createReturnStatement(u));
          }
          function nu() {
            var u, y;
            return w && (O(), be({}, h.StrictModeWith)), $("with"), C("("), u = G(), C(")"), y = Ot(), g.createWithStatement(u, y);
          }
          function iu() {
            var u, y = [], _, T;
            for (T = v, ae("default") ? (me(), u = null) : ($("case"), u = G()), C(":"); f < x && !(D("}") || ae("default") || ae("case")); )
              _ = Ot(), y.push(_);
            return g.markEnd(g.createSwitchCase(u, y), T);
          }
          function su() {
            var u, y, _, T, U;
            if ($("switch"), C("("), u = G(), C(")"), C("{"), y = [], D("}"))
              return me(), g.createSwitchStatement(u, y);
            for (T = k.inSwitch, k.inSwitch = !0, U = !1; f < x && !D("}"); )
              _ = iu(), _.test === null && (U && ge({}, h.MultipleDefaultsInSwitch), U = !0), y.push(_);
            return k.inSwitch = T, C("}"), g.createSwitchStatement(u, y);
          }
          function ou() {
            var u;
            return $("throw"), Ze() && ge({}, h.NewlineAfterThrow), u = G(), Ee(), g.createThrowStatement(u);
          }
          function au() {
            var u, y, _;
            return _ = v, $("catch"), C("("), D(")") && Je(v), u = he(), w && ye(u.name) && be({}, h.StrictCatchVariable), C(")"), y = se(), g.markEnd(g.createCatchClause(u, y), _);
          }
          function lu() {
            var u, y = [], _ = null;
            return $("try"), u = se(), ae("catch") && y.push(au()), ae("finally") && (me(), _ = se()), y.length === 0 && !_ && ge({}, h.NoCatchOrFinally), g.createTryStatement(u, [], y, _);
          }
          function cu() {
            return $("debugger"), Ee(), g.createDebuggerStatement();
          }
          function Ot() {
            var u = v.type, y, _, T, U;
            if (u === o.EOF && Je(v), u === o.Punctuator && v.value === "{")
              return se();
            if (U = v, u === o.Punctuator)
              switch (v.value) {
                case ";":
                  return g.markEnd(Qe(), U);
                case "(":
                  return g.markEnd(ut(), U);
              }
            if (u === o.Keyword)
              switch (v.value) {
                case "break":
                  return g.markEnd(xo(), U);
                case "continue":
                  return g.markEnd(wo(), U);
                case "debugger":
                  return g.markEnd(cu(), U);
                case "do":
                  return g.markEnd(Rt(), U);
                case "for":
                  return g.markEnd(an(), U);
                case "function":
                  return g.markEnd(Rs(), U);
                case "if":
                  return g.markEnd(st(), U);
                case "return":
                  return g.markEnd(ru(), U);
                case "switch":
                  return g.markEnd(su(), U);
                case "throw":
                  return g.markEnd(ou(), U);
                case "try":
                  return g.markEnd(lu(), U);
                case "var":
                  return g.markEnd($e(), U);
                case "while":
                  return g.markEnd($t(), U);
                case "with":
                  return g.markEnd(nu(), U);
              }
            return y = G(), y.type === c.Identifier && D(":") ? (me(), T = "$" + y.name, Object.prototype.hasOwnProperty.call(k.labelSet, T) && ge({}, h.Redeclaration, "Label", y.name), k.labelSet[T] = !0, _ = Ot(), delete k.labelSet[T], g.markEnd(g.createLabeledStatement(y, _), U)) : (Ee(), g.markEnd(g.createExpressionStatement(y), U));
          }
          function Un() {
            var u, y = [], _, T, U, ne, _e, Ne, et, Xe;
            for (Xe = v, C("{"); f < x && !(v.type !== o.StringLiteral || (_ = v, u = Ir(), y.push(u), u.expression.type !== c.Literal)); )
              T = m.slice(_.start + 1, _.end - 1), T === "use strict" ? (w = !0, U && be(U, h.StrictOctalLiteral)) : !U && _.octal && (U = _);
            for (ne = k.labelSet, _e = k.inIteration, Ne = k.inSwitch, et = k.inFunctionBody, k.labelSet = {}, k.inIteration = !1, k.inSwitch = !1, k.inFunctionBody = !0; f < x && !(D("}") || (u = Ir(), typeof u > "u")); )
              y.push(u);
            return C("}"), k.labelSet = ne, k.inIteration = _e, k.inSwitch = Ne, k.inFunctionBody = et, g.markEnd(g.createBlockStatement(y), Xe);
          }
          function Ps(u) {
            var y, _ = [], T, U, ne, _e, Ne;
            if (C("("), !D(")"))
              for (ne = {}; f < x && (T = v, y = he(), _e = "$" + T.value, w ? (ye(T.value) && (U = T, Ne = h.StrictParamName), Object.prototype.hasOwnProperty.call(ne, _e) && (U = T, Ne = h.StrictParamDupe)) : u || (ye(T.value) ? (u = T, Ne = h.StrictParamName) : ke(T.value) ? (u = T, Ne = h.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ne, _e) && (u = T, Ne = h.StrictParamDupe)), _.push(y), ne[_e] = !0, !D(")")); )
                C(",");
            return C(")"), {
              params: _,
              stricted: U,
              firstRestricted: u,
              message: Ne
            };
          }
          function Rs() {
            var u, y = [], _, T, U, ne, _e, Ne, et, Xe;
            return Xe = v, $("function"), T = v, u = he(), w ? ye(T.value) && be(T, h.StrictFunctionName) : ye(T.value) ? (_e = T, Ne = h.StrictFunctionName) : ke(T.value) && (_e = T, Ne = h.StrictReservedWord), ne = Ps(_e), y = ne.params, U = ne.stricted, _e = ne.firstRestricted, ne.message && (Ne = ne.message), et = w, _ = Un(), w && _e && ge(_e, Ne), w && U && be(U, Ne), w = et, g.markEnd(g.createFunctionDeclaration(u, y, [], _), Xe);
          }
          function uu() {
            var u, y = null, _, T, U, ne, _e = [], Ne, et, Xe;
            return Xe = v, $("function"), D("(") || (u = v, y = he(), w ? ye(u.value) && be(u, h.StrictFunctionName) : ye(u.value) ? (T = u, U = h.StrictFunctionName) : ke(u.value) && (T = u, U = h.StrictReservedWord)), ne = Ps(T), _e = ne.params, _ = ne.stricted, T = ne.firstRestricted, ne.message && (U = ne.message), et = w, Ne = Un(), w && T && ge(T, U), w && _ && be(_, U), w = et, g.markEnd(g.createFunctionExpression(y, _e, [], Ne), Xe);
          }
          function Ir() {
            if (v.type === o.Keyword)
              switch (v.value) {
                case "const":
                case "let":
                  return je(v.value);
                case "function":
                  return Rs();
                default:
                  return Ot();
              }
            if (v.type !== o.EOF)
              return Ot();
          }
          function hu() {
            for (var u, y = [], _, T, U; f < x && (_ = v, !(_.type !== o.StringLiteral || (u = Ir(), y.push(u), u.expression.type !== c.Literal))); )
              T = m.slice(_.start + 1, _.end - 1), T === "use strict" ? (w = !0, U && be(U, h.StrictOctalLiteral)) : !U && _.octal && (U = _);
            for (; f < x && (u = Ir(), !(typeof u > "u")); )
              y.push(u);
            return y;
          }
          function pu() {
            var u, y;
            return O(), ht(), y = v, w = !1, u = hu(), g.markEnd(g.createProgram(u), y);
          }
          function Os() {
            var u, y, _, T = [];
            for (u = 0; u < S.tokens.length; ++u)
              y = S.tokens[u], _ = {
                type: y.type,
                value: y.value
              }, S.range && (_.range = y.range), S.loc && (_.loc = y.loc), T.push(_);
            S.tokens = T;
          }
          function du(u, y) {
            var _, T, U;
            _ = String, typeof u != "string" && !(u instanceof String) && (u = _(u)), g = b, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, v = null, k = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, y = y || {}, y.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []);
            try {
              if (ht(), v.type === o.EOF)
                return S.tokens;
              for (T = me(); v.type !== o.EOF; )
                try {
                  T = me();
                } catch (ne) {
                  if (T = v, S.errors) {
                    S.errors.push(ne);
                    break;
                  } else
                    throw ne;
                }
              Os(), U = S.tokens, typeof S.comments < "u" && (U.comments = S.comments), typeof S.errors < "u" && (U.errors = S.errors);
            } catch (ne) {
              throw ne;
            } finally {
              S = {};
            }
            return U;
          }
          function fu(u, y) {
            var _, T;
            T = String, typeof u != "string" && !(u instanceof String) && (u = T(u)), g = b, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, v = null, k = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, typeof y < "u" && (S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, S.attachComment = typeof y.attachComment == "boolean" && y.attachComment, S.loc && y.source !== null && y.source !== void 0 && (S.source = T(y.source)), typeof y.tokens == "boolean" && y.tokens && (S.tokens = []), typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
            try {
              _ = pu(), typeof S.comments < "u" && (_.comments = S.comments), typeof S.tokens < "u" && (Os(), _.tokens = S.tokens), typeof S.errors < "u" && (_.errors = S.errors);
            } catch (U) {
              throw U;
            } finally {
              S = {};
            }
            return _;
          }
          s.version = "1.2.2", s.tokenize = du, s.parse = fu, s.Syntax = function() {
            var u, y = {};
            typeof Object.create == "function" && (y = /* @__PURE__ */ Object.create(null));
            for (u in c)
              c.hasOwnProperty(u) && (y[u] = c[u]);
            return typeof Object.freeze == "function" && Object.freeze(y), y;
          }();
        });
      }, {}], 1: [function(r, n, i) {
        (function(s) {
          var o = function() {
            var a = {
              trace: function() {
              },
              yy: {},
              symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
              terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
              productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
              performAction: function(h, d, b, m, w, f, E) {
                m.ast || (m.ast = l, l.initialize());
                var A = f.length - 1;
                switch (w) {
                  case 1:
                    return m.ast.set({ expression: { type: "root", value: f[A] } }), m.ast.unshift(), m.ast.yield();
                  case 2:
                    return m.ast.set({ expression: { type: "root", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 3:
                    return m.ast.unshift(), m.ast.yield();
                  case 4:
                    return m.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 5:
                    break;
                  case 6:
                    break;
                  case 7:
                    m.ast.set({ operation: "member" }), m.ast.push();
                    break;
                  case 8:
                    m.ast.set({ operation: "subscript" }), m.ast.push();
                    break;
                  case 9:
                    m.ast.set({ scope: "child" });
                    break;
                  case 10:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 11:
                    break;
                  case 12:
                    m.ast.set({ scope: "child", operation: "member" });
                    break;
                  case 13:
                    break;
                  case 14:
                    m.ast.set({ expression: { type: "wildcard", value: f[A] } });
                    break;
                  case 15:
                    m.ast.set({ expression: { type: "identifier", value: f[A] } });
                    break;
                  case 16:
                    m.ast.set({ expression: { type: "script_expression", value: f[A] } });
                    break;
                  case 17:
                    m.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                    break;
                  case 18:
                    break;
                  case 19:
                    m.ast.set({ scope: "child" });
                    break;
                  case 20:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 21:
                    break;
                  case 22:
                    break;
                  case 23:
                    break;
                  case 24:
                    f[A].length > 1 ? m.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                    break;
                  case 25:
                    this.$ = [f[A]];
                    break;
                  case 26:
                    this.$ = f[A - 2].concat(f[A]);
                    break;
                  case 27:
                    this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, m.ast.set(this.$);
                    break;
                  case 28:
                    this.$ = { expression: { type: "string_literal", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 29:
                    this.$ = { expression: { type: "slice", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 30:
                    this.$ = { expression: { type: "wildcard", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 31:
                    this.$ = { expression: { type: "script_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 32:
                    this.$ = { expression: { type: "filter_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 33:
                    this.$ = f[A];
                    break;
                  case 34:
                    this.$ = f[A];
                    break;
                }
              },
              table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
              defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
              parseError: function(h, d) {
                if (d.recoverable)
                  this.trace(h);
                else
                  throw new Error(h);
              },
              parse: function(h) {
                var d = this, b = [0], m = [null], w = [], f = this.table, E = "", A = 0, x = 0, g = 2, v = 1, k = w.slice.call(arguments, 1);
                this.lexer.setInput(h), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
                var S = this.lexer.yylloc;
                w.push(S);
                var R = this.lexer.options && this.lexer.options.ranges;
                typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
                function L() {
                  var Ie;
                  return Ie = d.lexer.lex() || v, typeof Ie != "number" && (Ie = d.symbols_[Ie] || Ie), Ie;
                }
                for (var F, z, j, ee, X = {}, ie, ce, ke, ye; ; ) {
                  if (z = b[b.length - 1], this.defaultActions[z] ? j = this.defaultActions[z] : ((F === null || typeof F > "u") && (F = L()), j = f[z] && f[z][F]), typeof j > "u" || !j.length || !j[0]) {
                    var Ce = "";
                    ye = [];
                    for (ie in f[z])
                      this.terminals_[ie] && ie > g && ye.push("'" + this.terminals_[ie] + "'");
                    this.lexer.showPosition ? Ce = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + ye.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : Ce = "Parse error on line " + (A + 1) + ": Unexpected " + (F == v ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(Ce, {
                      text: this.lexer.match,
                      token: this.terminals_[F] || F,
                      line: this.lexer.yylineno,
                      loc: S,
                      expected: ye
                    });
                  }
                  if (j[0] instanceof Array && j.length > 1)
                    throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + F);
                  switch (j[0]) {
                    case 1:
                      b.push(F), m.push(this.lexer.yytext), w.push(this.lexer.yylloc), b.push(j[1]), F = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                      break;
                    case 2:
                      if (ce = this.productions_[j[1]][1], X.$ = m[m.length - ce], X._$ = {
                        first_line: w[w.length - (ce || 1)].first_line,
                        last_line: w[w.length - 1].last_line,
                        first_column: w[w.length - (ce || 1)].first_column,
                        last_column: w[w.length - 1].last_column
                      }, R && (X._$.range = [
                        w[w.length - (ce || 1)].range[0],
                        w[w.length - 1].range[1]
                      ]), ee = this.performAction.apply(X, [
                        E,
                        x,
                        A,
                        this.yy,
                        j[1],
                        m,
                        w
                      ].concat(k)), typeof ee < "u")
                        return ee;
                      ce && (b = b.slice(0, -1 * ce * 2), m = m.slice(0, -1 * ce), w = w.slice(0, -1 * ce)), b.push(this.productions_[j[1]][0]), m.push(X.$), w.push(X._$), ke = f[b[b.length - 2]][b[b.length - 1]], b.push(ke);
                      break;
                    case 3:
                      return !0;
                  }
                }
                return !0;
              }
            }, l = {
              initialize: function() {
                this._nodes = [], this._node = {}, this._stash = [];
              },
              set: function(h) {
                for (var d in h) this._node[d] = h[d];
                return this._node;
              },
              node: function(h) {
                return arguments.length && (this._node = h), this._node;
              },
              push: function() {
                this._nodes.push(this._node), this._node = {};
              },
              unshift: function() {
                this._nodes.unshift(this._node), this._node = {};
              },
              yield: function() {
                var h = this._nodes;
                return this.initialize(), h;
              }
            }, c = /* @__PURE__ */ function() {
              var h = {
                EOF: 1,
                parseError: function(d, b) {
                  if (this.yy.parser)
                    this.yy.parser.parseError(d, b);
                  else
                    throw new Error(d);
                },
                // resets the lexer, sets new input
                setInput: function(d) {
                  return this._input = d, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                  }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
                },
                // consumes and returns one char from the input
                input: function() {
                  var d = this._input[0];
                  this.yytext += d, this.yyleng++, this.offset++, this.match += d, this.matched += d;
                  var b = d.match(/(?:\r\n?|\n).*/g);
                  return b ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), d;
                },
                // unshifts one char (or a string) into the input
                unput: function(d) {
                  var b = d.length, m = d.split(/(?:\r\n?|\n)/g);
                  this._input = d + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - b - 1), this.offset -= b;
                  var w = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
                  var f = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: m ? (m.length === w.length ? this.yylloc.first_column : 0) + w[w.length - m.length].length - m[0].length : this.yylloc.first_column - b
                  }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - b]), this.yyleng = this.yytext.length, this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function() {
                  return this._more = !0, this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function() {
                  if (this.options.backtrack_lexer)
                    this._backtrack = !0;
                  else
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                      text: "",
                      token: null,
                      line: this.yylineno
                    });
                  return this;
                },
                // retain first n characters of the match
                less: function(d) {
                  this.unput(this.match.slice(d));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function() {
                  var d = this.matched.substr(0, this.matched.length - this.match.length);
                  return (d.length > 20 ? "..." : "") + d.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function() {
                  var d = this.match;
                  return d.length < 20 && (d += this._input.substr(0, 20 - d.length)), (d.substr(0, 20) + (d.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function() {
                  var d = this.pastInput(), b = new Array(d.length + 1).join("-");
                  return d + this.upcomingInput() + `
` + b + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function(d, b) {
                  var m, w, f;
                  if (this.options.backtrack_lexer && (f = {
                    yylineno: this.yylineno,
                    yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                  }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), w = d[0].match(/(?:\r\n?|\n).*/g), w && (this.yylineno += w.length), this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: w ? w[w.length - 1].length - w[w.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + d[0].length
                  }, this.yytext += d[0], this.match += d[0], this.matches = d, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(d[0].length), this.matched += d[0], m = this.performAction.call(this, this.yy, this, b, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
                    return m;
                  if (this._backtrack) {
                    for (var E in f)
                      this[E] = f[E];
                    return !1;
                  }
                  return !1;
                },
                // return next match in input
                next: function() {
                  if (this.done)
                    return this.EOF;
                  this._input || (this.done = !0);
                  var d, b, m, w;
                  this._more || (this.yytext = "", this.match = "");
                  for (var f = this._currentRules(), E = 0; E < f.length; E++)
                    if (m = this._input.match(this.rules[f[E]]), m && (!b || m[0].length > b[0].length)) {
                      if (b = m, w = E, this.options.backtrack_lexer) {
                        if (d = this.test_match(m, f[E]), d !== !1)
                          return d;
                        if (this._backtrack) {
                          b = !1;
                          continue;
                        } else
                          return !1;
                      } else if (!this.options.flex)
                        break;
                    }
                  return b ? (d = this.test_match(b, f[w]), d !== !1 ? d : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                },
                // return next match that has a token
                lex: function() {
                  var d = this.next();
                  return d || this.lex();
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function(d) {
                  this.conditionStack.push(d);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function() {
                  var d = this.conditionStack.length - 1;
                  return d > 0 ? this.conditionStack.pop() : this.conditionStack[0];
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function() {
                  return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function(d) {
                  return d = this.conditionStack.length - 1 - Math.abs(d || 0), d >= 0 ? this.conditionStack[d] : "INITIAL";
                },
                // alias for begin(condition)
                pushState: function(d) {
                  this.begin(d);
                },
                // return the number of states currently on the stack
                stateStackSize: function() {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function(d, b, m, w) {
                  switch (m) {
                    case 0:
                      return 4;
                    case 1:
                      return 14;
                    case 2:
                      return 12;
                    case 3:
                      return 15;
                    case 4:
                      return 16;
                    case 5:
                      return 22;
                    case 6:
                      return 24;
                    case 7:
                      return 28;
                    case 8:
                      return 30;
                    case 9:
                      return 18;
                    case 10:
                      return b.yytext = b.yytext.substr(1, b.yyleng - 2), 32;
                    case 11:
                      return b.yytext = b.yytext.substr(1, b.yyleng - 2), 33;
                    case 12:
                      return 17;
                    case 13:
                      return 31;
                  }
                },
                rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
                conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
              };
              return h;
            }();
            a.lexer = c;
            function p() {
              this.yy = {};
            }
            return p.prototype = a, a.Parser = p, new p();
          }();
          typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
            return o.parse.apply(o, arguments);
          }, i.main = function(a) {
            a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
            var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
            return i.parser.parse(l);
          }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
        }).call(this, r("_process"));
      }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
        n.exports = {
          identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
          integer: "-?(?:0|[1-9][0-9]*)",
          qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
          q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
        };
      }, {}], 3: [function(r, n, i) {
        var s = r("./dict"), o = r("fs"), a = {
          lex: {
            macros: {
              esc: "\\\\",
              int: s.integer
            },
            rules: [
              ["\\$", "return 'DOLLAR'"],
              ["\\.\\.", "return 'DOT_DOT'"],
              ["\\.", "return 'DOT'"],
              ["\\*", "return 'STAR'"],
              [s.identifier, "return 'IDENTIFIER'"],
              ["\\[", "return '['"],
              ["\\]", "return ']'"],
              [",", "return ','"],
              ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
              ["{int}", "return 'INTEGER'"],
              [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
              [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
              ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
              ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
            ]
          },
          start: "JSON_PATH",
          bnf: {
            JSON_PATH: [
              ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
              ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
            ],
            PATH_COMPONENTS: [
              ["PATH_COMPONENT", ""],
              ["PATH_COMPONENTS PATH_COMPONENT", ""]
            ],
            PATH_COMPONENT: [
              ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
              ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
            ],
            MEMBER_COMPONENT: [
              ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_MEMBER_COMPONENT: [
              ["DOT MEMBER_EXPRESSION", ""]
            ],
            LEADING_CHILD_MEMBER_EXPRESSION: [
              ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
            ],
            DESCENDANT_MEMBER_COMPONENT: [
              ["DOT_DOT MEMBER_EXPRESSION", ""]
            ],
            MEMBER_EXPRESSION: [
              ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
              ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
              ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
              ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
              ["END", ""]
            ],
            SUBSCRIPT_COMPONENT: [
              ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_SUBSCRIPT_COMPONENT: [
              ["[ SUBSCRIPT ]", ""]
            ],
            DESCENDANT_SUBSCRIPT_COMPONENT: [
              ["DOT_DOT [ SUBSCRIPT ]", ""]
            ],
            SUBSCRIPT: [
              ["SUBSCRIPT_EXPRESSION", ""],
              ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
            ],
            SUBSCRIPT_EXPRESSION_LIST: [
              ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
              ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
            ],
            SUBSCRIPT_EXPRESSION_LISTABLE: [
              ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
              ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
              ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
            ],
            SUBSCRIPT_EXPRESSION: [
              ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
              ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
              ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
            ],
            STRING_LITERAL: [
              ["QQ_STRING", "$$ = $1"],
              ["Q_STRING", "$$ = $1"]
            ]
          }
        };
        o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
      }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
        var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
          return this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.traverse = b(!0), this.descend = b();
        }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
          var g = [x.operation, x.scope, x.expression.type].join("-"), v = this._fns[g];
          if (!v) throw new Error("couldn't resolve key: " + g);
          return v.bind(this);
        }, c.prototype.register = function(x, g) {
          if (!g instanceof Function)
            throw new Error("handler must be a function");
          this._fns[x] = g;
        }, c.prototype._fns = {
          "member-child-identifier": function(x, g) {
            var v = x.expression.value, k = g.value;
            if (k instanceof Object && v in k)
              return [{ value: k[v], path: g.path.concat(v) }];
          },
          "member-descendant-identifier": w(function(x, g, v) {
            return x == v;
          }),
          "subscript-child-numeric_literal": m(function(x, g, v) {
            return x === v;
          }),
          "member-child-numeric_literal": m(function(x, g, v) {
            return String(x) === String(v);
          }),
          "subscript-descendant-numeric_literal": w(function(x, g, v) {
            return x === v;
          }),
          "member-child-wildcard": m(function() {
            return !0;
          }),
          "member-descendant-wildcard": w(function() {
            return !0;
          }),
          "subscript-descendant-wildcard": w(function() {
            return !0;
          }),
          "subscript-child-wildcard": m(function() {
            return !0;
          }),
          "subscript-child-slice": function(x, g) {
            if (h(g.value)) {
              var v = x.expression.value.split(":").map(A), k = g.value.map(function(S, R) {
                return { value: S, path: g.path.concat(R) };
              });
              return o.apply(null, [k].concat(v));
            }
          },
          "subscript-child-union": function(x, g) {
            var v = [];
            return x.expression.value.forEach(function(k) {
              var S = { operation: "subscript", scope: "child", expression: k.expression }, R = this.resolve(S), L = R(S, g);
              L && (v = v.concat(L));
            }, this), E(v);
          },
          "subscript-descendant-union": function(x, g, v) {
            var k = r(".."), S = this, R = [], L = k.nodes(g, "$..*").slice(1);
            return L.forEach(function(F) {
              R.length >= v || x.expression.value.forEach(function(z) {
                var j = { operation: "subscript", scope: "child", expression: z.expression }, ee = S.resolve(j), X = ee(j, F);
                R = R.concat(X);
              });
            }), E(R);
          },
          "subscript-child-filter_expression": function(x, g, v) {
            var k = x.expression.value.slice(2, -1), S = s.parse(k).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.descend(g, null, R, v);
          },
          "subscript-descendant-filter_expression": function(x, g, v) {
            var k = x.expression.value.slice(2, -1), S = s.parse(k).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.traverse(g, null, R, v);
          },
          "subscript-child-script_expression": function(x, g) {
            var v = x.expression.value.slice(1, -1);
            return p(g, v, "$[{{value}}]");
          },
          "member-child-script_expression": function(x, g) {
            var v = x.expression.value.slice(1, -1);
            return p(g, v, "$.{{value}}");
          },
          "member-descendant-script_expression": function(x, g) {
            var v = x.expression.value.slice(1, -1);
            return p(g, v, "$..value");
          }
        }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
        function p(x, g, v) {
          var k = r("./index"), S = s.parse(g).body[0].expression, R = f(S, { "@": x.value }), L = v.replace(/\{\{\s*value\s*\}\}/g, R), F = k.nodes(x.value, L);
          return F.forEach(function(z) {
            z.path = x.path.concat(z.path.slice(1));
          }), F;
        }
        function h(x) {
          return Array.isArray(x);
        }
        function d(x) {
          return x && !(x instanceof Array) && x instanceof Object;
        }
        function b(x) {
          return function(g, v, k, S) {
            var R = g.value, L = g.path, F = [], z = (function(j, ee) {
              h(j) ? (j.forEach(function(X, ie) {
                F.length >= S || k(ie, X, v) && F.push({ path: ee.concat(ie), value: X });
              }), j.forEach(function(X, ie) {
                F.length >= S || x && z(X, ee.concat(ie));
              })) : d(j) && (this.keys(j).forEach(function(X) {
                F.length >= S || k(X, j[X], v) && F.push({ path: ee.concat(X), value: j[X] });
              }), this.keys(j).forEach(function(X) {
                F.length >= S || x && z(j[X], ee.concat(X));
              }));
            }).bind(this);
            return z(R, L), F;
          };
        }
        function m(x) {
          return function(g, v, k) {
            return this.descend(v, g.expression.value, x, k);
          };
        }
        function w(x) {
          return function(g, v, k) {
            return this.traverse(v, g.expression.value, x, k);
          };
        }
        function f() {
          try {
            return a.apply(this, arguments);
          } catch {
          }
        }
        function E(x) {
          return x = x.filter(function(g) {
            return g;
          }), l(
            x,
            function(g) {
              return g.path.map(function(v) {
                return String(v).replace("-", "--");
              }).join("-");
            }
          );
        }
        function A(x) {
          var g = String(x);
          return g.match(/^-?[0-9]+$/) ? parseInt(g) : null;
        }
        n.exports = c;
      }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
        var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
          this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.parser = new a(), this.handlers = new l();
        }, c.prototype.parse = function(d) {
          return s.ok(p(d), "we need a path"), this.parser.parse(d);
        }, c.prototype.parent = function(d, b) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
          var m = this.nodes(d, b)[0];
          return m.path.pop(), this.value(d, m.path);
        }, c.prototype.apply = function(d, b, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), s.equal(typeof m, "function", "fn needs to be function");
          var w = this.nodes(d, b).sort(function(f, E) {
            return E.path.length - f.path.length;
          });
          return w.forEach(function(f) {
            var E = f.path.pop(), A = this.value(d, this.stringify(f.path)), x = f.value = m.call(d, A[E]);
            A[E] = x;
          }, this), w;
        }, c.prototype.value = function(d, b, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), arguments.length >= 3) {
            var w = this.nodes(d, b).shift();
            if (!w) return this._vivify(d, b, m);
            var f = w.path.slice(-1).shift(), E = this.parent(d, this.stringify(w.path));
            E[f] = m;
          }
          return this.query(d, this.stringify(b), 1).shift();
        }, c.prototype._vivify = function(d, b, m) {
          var w = this;
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
          var f = this.parser.parse(b).map(function(A) {
            return A.expression.value;
          }), E = function(A, x) {
            var g = A.pop(), v = w.value(d, A);
            v || (E(A.concat(), typeof g == "string" ? {} : []), v = w.value(d, A)), v[g] = x;
          };
          return E(f, m), this.query(d, b)[0];
        }, c.prototype.query = function(d, b, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(p(b), "we need a path");
          var w = this.nodes(d, b, m).map(function(f) {
            return f.value;
          });
          return w;
        }, c.prototype.paths = function(d, b, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
          var w = this.nodes(d, b, m).map(function(f) {
            return f.path;
          });
          return w;
        }, c.prototype.nodes = function(d, b, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), m === 0) return [];
          var w = this.parser.parse(b), f = this.handlers, E = [{ path: ["$"], value: d }], A = [];
          return w.length && w[0].expression.type == "root" && w.shift(), w.length ? (w.forEach(function(x, g) {
            if (!(A.length >= m)) {
              var v = f.resolve(x), k = [];
              E.forEach(function(S) {
                if (!(A.length >= m)) {
                  var R = v(x, S, m);
                  g == w.length - 1 ? A = A.concat(R || []) : k = k.concat(R || []);
                }
              }), E = k;
            }
          }), m ? A.slice(0, m) : A) : E;
        }, c.prototype.stringify = function(d) {
          s.ok(d, "we need a path");
          var b = "$", m = {
            "descendant-member": "..{{value}}",
            "child-member": ".{{value}}",
            "descendant-subscript": "..[{{value}}]",
            "child-subscript": "[{{value}}]"
          };
          return d = this._normalize(d), d.forEach(function(w) {
            if (w.expression.type != "root") {
              var f = [w.scope, w.operation].join("-"), E = m[f], A;
              if (w.expression.type == "string_literal" ? A = JSON.stringify(w.expression.value) : A = w.expression.value, !E) throw new Error("couldn't find template " + f);
              b += E.replace(/{{value}}/, A);
            }
          }), b;
        }, c.prototype._normalize = function(d) {
          if (s.ok(d, "we need a path"), typeof d == "string")
            return this.parser.parse(d);
          if (Array.isArray(d) && typeof d[0] == "string") {
            var b = [{ expression: { type: "root", value: "$" } }];
            return d.forEach(function(m, w) {
              if (!(m == "$" && w === 0))
                if (typeof m == "string" && m.match("^" + o.identifier + "$"))
                  b.push({
                    operation: "member",
                    scope: "child",
                    expression: { value: m, type: "identifier" }
                  });
                else {
                  var f = typeof m == "number" ? "numeric_literal" : "string_literal";
                  b.push({
                    operation: "subscript",
                    scope: "child",
                    expression: { value: m, type: f }
                  });
                }
            }), b;
          } else if (Array.isArray(d) && typeof d[0] == "object")
            return d;
          throw new Error("couldn't understand path " + d);
        };
        function p(d) {
          return Object.prototype.toString.call(d) == "[object String]";
        }
        c.Handlers = l, c.Parser = a;
        var h = new c();
        h.JSONPath = c, n.exports = h;
      }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
        var s = r("./grammar"), o = r("../generated/parser"), a = function() {
          var l = new o.Parser(), c = l.parseError;
          return l.yy.parseError = function() {
            l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
          }, l;
        };
        a.grammar = s, n.exports = a;
      }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
        n.exports = function(o, a, l, c) {
          if (typeof a == "string") throw new Error("start cannot be a string");
          if (typeof l == "string") throw new Error("end cannot be a string");
          if (typeof c == "string") throw new Error("step cannot be a string");
          var p = o.length;
          if (c === 0) throw new Error("step cannot be zero");
          if (c = c ? s(c) : 1, a = a < 0 ? p + a : a, l = l < 0 ? p + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : p - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? p : -1)), a = c > 0 ? Math.max(0, a) : Math.min(p, a), l = c > 0 ? Math.min(l, p) : Math.max(-1, l), c > 0 && l <= a) return [];
          if (c < 0 && a <= l) return [];
          for (var h = [], d = a; d != l && !(c < 0 && d <= l || c > 0 && d >= l); d += c)
            h.push(o[d]);
          return h;
        };
        function s(o) {
          return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
        }
      }, {}], 8: [function(r, n, i) {
        var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = b;
        l.AssertionError = function(g) {
          this.name = "AssertionError", this.actual = g.actual, this.expected = g.expected, this.operator = g.operator, g.message ? (this.message = g.message, this.generatedMessage = !1) : (this.message = h(this), this.generatedMessage = !0);
          var v = g.stackStartFunction || d;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, v);
          else {
            var k = new Error();
            if (k.stack) {
              var S = k.stack, R = v.name, L = S.indexOf(`
` + R);
              if (L >= 0) {
                var F = S.indexOf(`
`, L + 1);
                S = S.substring(F + 1);
              }
              this.stack = S;
            }
          }
        }, s.inherits(l.AssertionError, Error);
        function c(g, v) {
          return s.isUndefined(v) ? "" + v : s.isNumber(v) && !isFinite(v) || s.isFunction(v) || s.isRegExp(v) ? v.toString() : v;
        }
        function p(g, v) {
          return s.isString(g) ? g.length < v ? g : g.slice(0, v) : g;
        }
        function h(g) {
          return p(JSON.stringify(g.actual, c), 128) + " " + g.operator + " " + p(JSON.stringify(g.expected, c), 128);
        }
        function d(g, v, k, S, R) {
          throw new l.AssertionError({
            message: k,
            actual: g,
            expected: v,
            operator: S,
            stackStartFunction: R
          });
        }
        l.fail = d;
        function b(g, v) {
          g || d(g, !0, v, "==", l.ok);
        }
        l.ok = b, l.equal = function(g, v, k) {
          g != v && d(g, v, k, "==", l.equal);
        }, l.notEqual = function(g, v, k) {
          g == v && d(g, v, k, "!=", l.notEqual);
        }, l.deepEqual = function(g, v, k) {
          m(g, v) || d(g, v, k, "deepEqual", l.deepEqual);
        };
        function m(g, v) {
          if (g === v)
            return !0;
          if (s.isBuffer(g) && s.isBuffer(v)) {
            if (g.length != v.length) return !1;
            for (var k = 0; k < g.length; k++)
              if (g[k] !== v[k]) return !1;
            return !0;
          } else return s.isDate(g) && s.isDate(v) ? g.getTime() === v.getTime() : s.isRegExp(g) && s.isRegExp(v) ? g.source === v.source && g.global === v.global && g.multiline === v.multiline && g.lastIndex === v.lastIndex && g.ignoreCase === v.ignoreCase : !s.isObject(g) && !s.isObject(v) ? g == v : f(g, v);
        }
        function w(g) {
          return Object.prototype.toString.call(g) == "[object Arguments]";
        }
        function f(g, v) {
          if (s.isNullOrUndefined(g) || s.isNullOrUndefined(v) || g.prototype !== v.prototype) return !1;
          if (s.isPrimitive(g) || s.isPrimitive(v))
            return g === v;
          var k = w(g), S = w(v);
          if (k && !S || !k && S)
            return !1;
          if (k)
            return g = o.call(g), v = o.call(v), m(g, v);
          var R = x(g), L = x(v), F, z;
          if (R.length != L.length)
            return !1;
          for (R.sort(), L.sort(), z = R.length - 1; z >= 0; z--)
            if (R[z] != L[z])
              return !1;
          for (z = R.length - 1; z >= 0; z--)
            if (F = R[z], !m(g[F], v[F])) return !1;
          return !0;
        }
        l.notDeepEqual = function(g, v, k) {
          m(g, v) && d(g, v, k, "notDeepEqual", l.notDeepEqual);
        }, l.strictEqual = function(g, v, k) {
          g !== v && d(g, v, k, "===", l.strictEqual);
        }, l.notStrictEqual = function(g, v, k) {
          g === v && d(g, v, k, "!==", l.notStrictEqual);
        };
        function E(g, v) {
          return !g || !v ? !1 : Object.prototype.toString.call(v) == "[object RegExp]" ? v.test(g) : g instanceof v ? !0 : v.call({}, g) === !0;
        }
        function A(g, v, k, S) {
          var R;
          s.isString(k) && (S = k, k = null);
          try {
            v();
          } catch (L) {
            R = L;
          }
          if (S = (k && k.name ? " (" + k.name + ")." : ".") + (S ? " " + S : "."), g && !R && d(R, k, "Missing expected exception" + S), !g && E(R, k) && d(R, k, "Got unwanted exception" + S), g && R && k && !E(R, k) || !g && R)
            throw R;
        }
        l.throws = function(g, v, k) {
          A.apply(this, [!0].concat(o.call(arguments)));
        }, l.doesNotThrow = function(g, v) {
          A.apply(this, [!1].concat(o.call(arguments)));
        }, l.ifError = function(g) {
          if (g)
            throw g;
        };
        var x = Object.keys || function(g) {
          var v = [];
          for (var k in g)
            a.call(g, k) && v.push(k);
          return v;
        };
      }, { "util/": 11 }], 9: [function(r, n, i) {
        typeof Object.create == "function" ? n.exports = function(s, o) {
          s.super_ = o, s.prototype = Object.create(o.prototype, {
            constructor: {
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : n.exports = function(s, o) {
          s.super_ = o;
          var a = function() {
          };
          a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
        };
      }, {}], 10: [function(r, n, i) {
        n.exports = function(s) {
          return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
        };
      }, {}], 11: [function(r, n, i) {
        (function(s, o) {
          var a = /%[sdj%]/g;
          i.format = function(O) {
            if (!L(O)) {
              for (var N = [], Z = 0; Z < arguments.length; Z++)
                N.push(p(arguments[Z]));
              return N.join(" ");
            }
            for (var Z = 1, re = arguments, le = re.length, te = String(O).replace(a, function(H) {
              if (H === "%%") return "%";
              if (Z >= le) return H;
              switch (H) {
                case "%s":
                  return String(re[Z++]);
                case "%d":
                  return Number(re[Z++]);
                case "%j":
                  try {
                    return JSON.stringify(re[Z++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return H;
              }
            }), oe = re[Z]; Z < le; oe = re[++Z])
              k(oe) || !ee(oe) ? te += " " + oe : te += " " + p(oe);
            return te;
          }, i.deprecate = function(O, N) {
            if (z(o.process))
              return function() {
                return i.deprecate(O, N).apply(this, arguments);
              };
            if (s.noDeprecation === !0)
              return O;
            var Z = !1;
            function re() {
              if (!Z) {
                if (s.throwDeprecation)
                  throw new Error(N);
                s.traceDeprecation ? console.trace(N) : console.error(N), Z = !0;
              }
              return O.apply(this, arguments);
            }
            return re;
          };
          var l = {}, c;
          i.debuglog = function(O) {
            if (z(c) && (c = s.env.NODE_DEBUG || ""), O = O.toUpperCase(), !l[O])
              if (new RegExp("\\b" + O + "\\b", "i").test(c)) {
                var N = s.pid;
                l[O] = function() {
                  var Z = i.format.apply(i, arguments);
                  console.error("%s %d: %s", O, N, Z);
                };
              } else
                l[O] = function() {
                };
            return l[O];
          };
          function p(O, N) {
            var Z = {
              seen: [],
              stylize: d
            };
            return arguments.length >= 3 && (Z.depth = arguments[2]), arguments.length >= 4 && (Z.colors = arguments[3]), v(N) ? Z.showHidden = N : N && i._extend(Z, N), z(Z.showHidden) && (Z.showHidden = !1), z(Z.depth) && (Z.depth = 2), z(Z.colors) && (Z.colors = !1), z(Z.customInspect) && (Z.customInspect = !0), Z.colors && (Z.stylize = h), m(Z, O, Z.depth);
          }
          i.inspect = p, p.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, p.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function h(O, N) {
            var Z = p.styles[N];
            return Z ? "\x1B[" + p.colors[Z][0] + "m" + O + "\x1B[" + p.colors[Z][1] + "m" : O;
          }
          function d(O, N) {
            return O;
          }
          function b(O) {
            var N = {};
            return O.forEach(function(Z, re) {
              N[Z] = !0;
            }), N;
          }
          function m(O, N, Z) {
            if (O.customInspect && N && ce(N.inspect) && // Filter out the util module, it's inspect function is special
            N.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
            !(N.constructor && N.constructor.prototype === N)) {
              var re = N.inspect(Z, O);
              return L(re) || (re = m(O, re, Z)), re;
            }
            var le = w(O, N);
            if (le)
              return le;
            var te = Object.keys(N), oe = b(te);
            if (O.showHidden && (te = Object.getOwnPropertyNames(N)), ie(N) && (te.indexOf("message") >= 0 || te.indexOf("description") >= 0))
              return f(N);
            if (te.length === 0) {
              if (ce(N)) {
                var fe = N.name ? ": " + N.name : "";
                return O.stylize("[Function" + fe + "]", "special");
              }
              if (j(N))
                return O.stylize(RegExp.prototype.toString.call(N), "regexp");
              if (X(N))
                return O.stylize(Date.prototype.toString.call(N), "date");
              if (ie(N))
                return f(N);
            }
            var H = "", J = !1, Se = ["{", "}"];
            if (g(N) && (J = !0, Se = ["[", "]"]), ce(N)) {
              var Re = N.name ? ": " + N.name : "";
              H = " [Function" + Re + "]";
            }
            if (j(N) && (H = " " + RegExp.prototype.toString.call(N)), X(N) && (H = " " + Date.prototype.toUTCString.call(N)), ie(N) && (H = " " + f(N)), te.length === 0 && (!J || N.length == 0))
              return Se[0] + H + Se[1];
            if (Z < 0)
              return j(N) ? O.stylize(RegExp.prototype.toString.call(N), "regexp") : O.stylize("[Object]", "special");
            O.seen.push(N);
            var Fe;
            return J ? Fe = E(O, N, Z, oe, te) : Fe = te.map(function(Le) {
              return A(O, N, Z, oe, Le, J);
            }), O.seen.pop(), x(Fe, H, Se);
          }
          function w(O, N) {
            if (z(N))
              return O.stylize("undefined", "undefined");
            if (L(N)) {
              var Z = "'" + JSON.stringify(N).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return O.stylize(Z, "string");
            }
            if (R(N))
              return O.stylize("" + N, "number");
            if (v(N))
              return O.stylize("" + N, "boolean");
            if (k(N))
              return O.stylize("null", "null");
          }
          function f(O) {
            return "[" + Error.prototype.toString.call(O) + "]";
          }
          function E(O, N, Z, re, le) {
            for (var te = [], oe = 0, fe = N.length; oe < fe; ++oe)
              ue(N, String(oe)) ? te.push(A(
                O,
                N,
                Z,
                re,
                String(oe),
                !0
              )) : te.push("");
            return le.forEach(function(H) {
              H.match(/^\d+$/) || te.push(A(
                O,
                N,
                Z,
                re,
                H,
                !0
              ));
            }), te;
          }
          function A(O, N, Z, re, le, te) {
            var oe, fe, H;
            if (H = Object.getOwnPropertyDescriptor(N, le) || { value: N[le] }, H.get ? H.set ? fe = O.stylize("[Getter/Setter]", "special") : fe = O.stylize("[Getter]", "special") : H.set && (fe = O.stylize("[Setter]", "special")), ue(re, le) || (oe = "[" + le + "]"), fe || (O.seen.indexOf(H.value) < 0 ? (k(Z) ? fe = m(O, H.value, null) : fe = m(O, H.value, Z - 1), fe.indexOf(`
`) > -1 && (te ? fe = fe.split(`
`).map(function(J) {
              return "  " + J;
            }).join(`
`).substr(2) : fe = `
` + fe.split(`
`).map(function(J) {
              return "   " + J;
            }).join(`
`))) : fe = O.stylize("[Circular]", "special")), z(oe)) {
              if (te && le.match(/^\d+$/))
                return fe;
              oe = JSON.stringify("" + le), oe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (oe = oe.substr(1, oe.length - 2), oe = O.stylize(oe, "name")) : (oe = oe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), oe = O.stylize(oe, "string"));
            }
            return oe + ": " + fe;
          }
          function x(O, N, Z) {
            var re = O.reduce(function(le, te) {
              return te.indexOf(`
`) >= 0, le + te.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return re > 60 ? Z[0] + (N === "" ? "" : N + `
 `) + " " + O.join(`,
  `) + " " + Z[1] : Z[0] + N + " " + O.join(", ") + " " + Z[1];
          }
          function g(O) {
            return Array.isArray(O);
          }
          i.isArray = g;
          function v(O) {
            return typeof O == "boolean";
          }
          i.isBoolean = v;
          function k(O) {
            return O === null;
          }
          i.isNull = k;
          function S(O) {
            return O == null;
          }
          i.isNullOrUndefined = S;
          function R(O) {
            return typeof O == "number";
          }
          i.isNumber = R;
          function L(O) {
            return typeof O == "string";
          }
          i.isString = L;
          function F(O) {
            return typeof O == "symbol";
          }
          i.isSymbol = F;
          function z(O) {
            return O === void 0;
          }
          i.isUndefined = z;
          function j(O) {
            return ee(O) && ye(O) === "[object RegExp]";
          }
          i.isRegExp = j;
          function ee(O) {
            return typeof O == "object" && O !== null;
          }
          i.isObject = ee;
          function X(O) {
            return ee(O) && ye(O) === "[object Date]";
          }
          i.isDate = X;
          function ie(O) {
            return ee(O) && (ye(O) === "[object Error]" || O instanceof Error);
          }
          i.isError = ie;
          function ce(O) {
            return typeof O == "function";
          }
          i.isFunction = ce;
          function ke(O) {
            return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || // ES6 symbol
            typeof O > "u";
          }
          i.isPrimitive = ke, i.isBuffer = r("./support/isBuffer");
          function ye(O) {
            return Object.prototype.toString.call(O);
          }
          function Ce(O) {
            return O < 10 ? "0" + O.toString(10) : O.toString(10);
          }
          var Ie = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function Te() {
            var O = /* @__PURE__ */ new Date(), N = [
              Ce(O.getHours()),
              Ce(O.getMinutes()),
              Ce(O.getSeconds())
            ].join(":");
            return [O.getDate(), Ie[O.getMonth()], N].join(" ");
          }
          i.log = function() {
            console.log("%s - %s", Te(), i.format.apply(i, arguments));
          }, i.inherits = r("inherits"), i._extend = function(O, N) {
            if (!N || !ee(N)) return O;
            for (var Z = Object.keys(N), re = Z.length; re--; )
              O[Z[re]] = N[Z[re]];
            return O;
          };
          function ue(O, N) {
            return Object.prototype.hasOwnProperty.call(O, N);
          }
        }).call(this, r("_process"), typeof U7 < "u" ? U7 : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
      }, {}], 13: [function(r, n, i) {
        (function(s) {
          function o(p, h) {
            for (var d = 0, b = p.length - 1; b >= 0; b--) {
              var m = p[b];
              m === "." ? p.splice(b, 1) : m === ".." ? (p.splice(b, 1), d++) : d && (p.splice(b, 1), d--);
            }
            if (h)
              for (; d--; d)
                p.unshift("..");
            return p;
          }
          i.resolve = function() {
            for (var p = "", h = !1, d = arguments.length - 1; d >= -1 && !h; d--) {
              var b = d >= 0 ? arguments[d] : s.cwd();
              if (typeof b != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              b && (p = b + "/" + p, h = b.charAt(0) === "/");
            }
            return p = o(l(p.split("/"), function(m) {
              return !!m;
            }), !h).join("/"), (h ? "/" : "") + p || ".";
          }, i.normalize = function(p) {
            var h = i.isAbsolute(p), d = c(p, -1) === "/";
            return p = o(l(p.split("/"), function(b) {
              return !!b;
            }), !h).join("/"), !p && !h && (p = "."), p && d && (p += "/"), (h ? "/" : "") + p;
          }, i.isAbsolute = function(p) {
            return p.charAt(0) === "/";
          }, i.join = function() {
            var p = Array.prototype.slice.call(arguments, 0);
            return i.normalize(l(p, function(h, d) {
              if (typeof h != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return h;
            }).join("/"));
          }, i.relative = function(p, h) {
            p = i.resolve(p).substr(1), h = i.resolve(h).substr(1);
            function d(x) {
              for (var g = 0; g < x.length && x[g] === ""; g++)
                ;
              for (var v = x.length - 1; v >= 0 && x[v] === ""; v--)
                ;
              return g > v ? [] : x.slice(g, v - g + 1);
            }
            for (var b = d(p.split("/")), m = d(h.split("/")), w = Math.min(b.length, m.length), f = w, E = 0; E < w; E++)
              if (b[E] !== m[E]) {
                f = E;
                break;
              }
            for (var A = [], E = f; E < b.length; E++)
              A.push("..");
            return A = A.concat(m.slice(f)), A.join("/");
          }, i.sep = "/", i.delimiter = ":", i.dirname = function(p) {
            if (typeof p != "string" && (p = p + ""), p.length === 0) return ".";
            for (var h = p.charCodeAt(0), d = h === 47, b = -1, m = !0, w = p.length - 1; w >= 1; --w)
              if (h = p.charCodeAt(w), h === 47) {
                if (!m) {
                  b = w;
                  break;
                }
              } else
                m = !1;
            return b === -1 ? d ? "/" : "." : d && b === 1 ? "/" : p.slice(0, b);
          };
          function a(p) {
            typeof p != "string" && (p = p + "");
            var h = 0, d = -1, b = !0, m;
            for (m = p.length - 1; m >= 0; --m)
              if (p.charCodeAt(m) === 47) {
                if (!b) {
                  h = m + 1;
                  break;
                }
              } else d === -1 && (b = !1, d = m + 1);
            return d === -1 ? "" : p.slice(h, d);
          }
          i.basename = function(p, h) {
            var d = a(p);
            return h && d.substr(-1 * h.length) === h && (d = d.substr(0, d.length - h.length)), d;
          }, i.extname = function(p) {
            typeof p != "string" && (p = p + "");
            for (var h = -1, d = 0, b = -1, m = !0, w = 0, f = p.length - 1; f >= 0; --f) {
              var E = p.charCodeAt(f);
              if (E === 47) {
                if (!m) {
                  d = f + 1;
                  break;
                }
                continue;
              }
              b === -1 && (m = !1, b = f + 1), E === 46 ? h === -1 ? h = f : w !== 1 && (w = 1) : h !== -1 && (w = -1);
            }
            return h === -1 || b === -1 || // We saw a non-dot character immediately before the dot
            w === 0 || // The (right-most) trimmed path component is exactly '..'
            w === 1 && h === b - 1 && h === d + 1 ? "" : p.slice(h, b);
          };
          function l(p, h) {
            if (p.filter) return p.filter(h);
            for (var d = [], b = 0; b < p.length; b++)
              h(p[b], b, p) && d.push(p[b]);
            return d;
          }
          var c = "ab".substr(-1) === "b" ? function(p, h, d) {
            return p.substr(h, d);
          } : function(p, h, d) {
            return h < 0 && (h = p.length + h), p.substr(h, d);
          };
        }).call(this, r("_process"));
      }, { _process: 14 }], 14: [function(r, n, i) {
        var s = n.exports = {}, o, a;
        function l() {
          throw new Error("setTimeout has not been defined");
        }
        function c() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? o = setTimeout : o = l;
          } catch {
            o = l;
          }
          try {
            typeof clearTimeout == "function" ? a = clearTimeout : a = c;
          } catch {
            a = c;
          }
        })();
        function p(g) {
          if (o === setTimeout)
            return setTimeout(g, 0);
          if ((o === l || !o) && setTimeout)
            return o = setTimeout, setTimeout(g, 0);
          try {
            return o(g, 0);
          } catch {
            try {
              return o.call(null, g, 0);
            } catch {
              return o.call(this, g, 0);
            }
          }
        }
        function h(g) {
          if (a === clearTimeout)
            return clearTimeout(g);
          if ((a === c || !a) && clearTimeout)
            return a = clearTimeout, clearTimeout(g);
          try {
            return a(g);
          } catch {
            try {
              return a.call(null, g);
            } catch {
              return a.call(this, g);
            }
          }
        }
        var d = [], b = !1, m, w = -1;
        function f() {
          !b || !m || (b = !1, m.length ? d = m.concat(d) : w = -1, d.length && E());
        }
        function E() {
          if (!b) {
            var g = p(f);
            b = !0;
            for (var v = d.length; v; ) {
              for (m = d, d = []; ++w < v; )
                m && m[w].run();
              w = -1, v = d.length;
            }
            m = null, b = !1, h(g);
          }
        }
        s.nextTick = function(g) {
          var v = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var k = 1; k < arguments.length; k++)
              v[k - 1] = arguments[k];
          d.push(new A(g, v)), d.length === 1 && !b && p(E);
        };
        function A(g, v) {
          this.fun = g, this.array = v;
        }
        A.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
        function x() {
        }
        s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(g) {
          return [];
        }, s.binding = function(g) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(g) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 15: [function(r, n, i) {
        var s = r("escodegen").generate;
        n.exports = function(o, a) {
          a || (a = {});
          var l = {}, c = function p(h, d) {
            if (h.type === "Literal")
              return h.value;
            if (h.type === "UnaryExpression") {
              var b = p(h.argument);
              return h.operator === "+" ? +b : h.operator === "-" ? -b : h.operator === "~" ? ~b : h.operator === "!" ? !b : l;
            } else if (h.type === "ArrayExpression") {
              for (var m = [], w = 0, f = h.elements.length; w < f; w++) {
                var E = p(h.elements[w]);
                if (E === l) return l;
                m.push(E);
              }
              return m;
            } else if (h.type === "ObjectExpression") {
              for (var A = {}, w = 0; w < h.properties.length; w++) {
                var x = h.properties[w], g = x.value === null ? x.value : p(x.value);
                if (g === l) return l;
                A[x.key.value || x.key.name] = g;
              }
              return A;
            } else if (h.type === "BinaryExpression" || h.type === "LogicalExpression") {
              var f = p(h.left);
              if (f === l) return l;
              var v = p(h.right);
              if (v === l) return l;
              var k = h.operator;
              return k === "==" ? f == v : k === "===" ? f === v : k === "!=" ? f != v : k === "!==" ? f !== v : k === "+" ? f + v : k === "-" ? f - v : k === "*" ? f * v : k === "/" ? f / v : k === "%" ? f % v : k === "<" ? f < v : k === "<=" ? f <= v : k === ">" ? f > v : k === ">=" ? f >= v : k === "|" ? f | v : k === "&" ? f & v : k === "^" ? f ^ v : k === "&&" ? f && v : k === "||" ? f || v : l;
            } else {
              if (h.type === "Identifier")
                return {}.hasOwnProperty.call(a, h.name) ? a[h.name] : l;
              if (h.type === "ThisExpression")
                return {}.hasOwnProperty.call(a, "this") ? a.this : l;
              if (h.type === "CallExpression") {
                var S = p(h.callee);
                if (S === l || typeof S != "function") return l;
                var R = h.callee.object ? p(h.callee.object) : l;
                R === l && (R = null);
                for (var L = [], w = 0, f = h.arguments.length; w < f; w++) {
                  var E = p(h.arguments[w]);
                  if (E === l) return l;
                  L.push(E);
                }
                return S.apply(R, L);
              } else if (h.type === "MemberExpression") {
                var A = p(h.object);
                if (A === l || typeof A == "function")
                  return l;
                if (h.property.type === "Identifier")
                  return A[h.property.name];
                var x = p(h.property);
                return x === l ? l : A[x];
              } else if (h.type === "ConditionalExpression") {
                var b = p(h.test);
                return b === l ? l : p(b ? h.consequent : h.alternate);
              } else if (h.type === "ExpressionStatement") {
                var b = p(h.expression);
                return b === l ? l : b;
              } else {
                if (h.type === "ReturnStatement")
                  return p(h.argument);
                if (h.type === "FunctionExpression") {
                  var F = h.body.body, z = {};
                  Object.keys(a).forEach(function(Ie) {
                    z[Ie] = a[Ie];
                  });
                  for (var w = 0; w < h.params.length; w++) {
                    var j = h.params[w];
                    if (j.type == "Identifier")
                      a[j.name] = null;
                    else return l;
                  }
                  for (var w in F)
                    if (p(F[w]) === l)
                      return l;
                  a = z;
                  var ee = Object.keys(a), X = ee.map(function(Ie) {
                    return a[Ie];
                  });
                  return Function(ee.join(", "), "return " + s(h)).apply(null, X);
                } else if (h.type === "TemplateLiteral") {
                  for (var ie = "", w = 0; w < h.expressions.length; w++)
                    ie += p(h.quasis[w]), ie += p(h.expressions[w]);
                  return ie += p(h.quasis[w]), ie;
                } else if (h.type === "TaggedTemplateExpression") {
                  var ce = p(h.tag), ke = h.quasi, ye = ke.quasis.map(p), Ce = ke.expressions.map(p);
                  return ce.apply(null, [ye].concat(Ce));
                } else return h.type === "TemplateElement" ? h.value.cooked : l;
              }
            }
          }(o);
          return c === l ? void 0 : c;
        };
      }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
        n.exports = r("./lib/index");
      }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
    });
  }(r_)), r_.exports;
}
Epe();
const Spe = "https://fizz.studio/schema/manifest.schema.json", Ape = {
  $id: Spe
};
Ape.$id;
function kpe(t) {
  const e = t.datasets[0];
  if (e.data.source !== "inline")
    throw new Error("only manifests with inline data can use this function.");
  const r = {};
  for (const n of e.series)
    r[n.key] = n.records;
  return r;
}
function Yn(t) {
  return t.replace(/\W+/g, "_").toLowerCase();
}
const s4 = {
  line: "line",
  stepline: "line",
  bar: "bar",
  column: "bar",
  lollipop: "bar",
  histogram: "histogram",
  scatter: "scatter",
  heatmap: "scatter",
  pie: "pastry",
  donut: "pastry",
  graph: "graph"
};
(() => {
  const t = {
    line: [],
    bar: [],
    pastry: [],
    scatter: [],
    histogram: [],
    graph: []
  };
  for (let e of Object.keys(s4))
    t[s4[e]].push(e);
  return t;
})();
function i_(t) {
  return s4[t] === "pastry";
}
var HD = (t) => {
  throw TypeError(t);
}, GD = (t, e, r) => e.has(t) || HD("Cannot " + r), s_ = (t, e, r) => (GD(t, e, "read from private field"), r ? r.call(t) : e.get(t)), o_ = (t, e, r) => e.has(t) ? HD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), a_ = (t, e, r, n) => (GD(t, e, "write to private field"), e.set(t, r), r);
const jy = "[a-fA-F0-9]", Ld = "[a-zA-Z0-9-._~]", ao = "[!$&'()*+,;=]", jh = `%${jy}${jy}`, jm = "(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])", Y5 = `${jm}\\.${jm}\\.${jm}\\.${jm}`, Mr = `${jy}{1,4}`, Eu = `(?:${Mr}:${Mr}|${Y5})`, _pe = `(?:(?:${Mr}:){6}${Eu}|::(?:${Mr}:){5}${Eu}|(?:${Mr})?::(?:${Mr}:){4}${Eu}|(?:(?:${Mr}:){0,1}${Mr})?::(?:${Mr}:){3}${Eu}|(?:(?:${Mr}:){0,2}${Mr})?::(?:${Mr}:){2}${Eu}|(?:(?:${Mr}:){0,3}${Mr})?::(?:${Mr}:){1}${Eu}|(?:(?:${Mr}:){0,4}${Mr})?::${Eu}|(?:(?:${Mr}:){0,5}${Mr})?::${Mr}|(?:(?:${Mr}:){0,6}${Mr})?::)`, Cpe = `v${jy}+\\.(?:${Ld}|${ao}|:)+`, WD = `\\[(?:${_pe}|${Cpe})\\]`, Md = "(?<scheme>[a-zA-Z][a-zA-Z0-9-+.]*)", qD = ":(?<port>\\d*)", Ipe = `(?:${Ld}|${jh}|${ao})*?`, Ppe = `(?<host>${WD}|${Y5}|${Ipe})`, Rpe = `(?<userinfo>(?:${Ld}|${jh}|${ao}|:)*)`, Z5 = `(?:${Ld}|${jh}|${ao}|:|@)`, QD = `${Z5}*?`, KD = `(?:/${QD})*`, J5 = `(?<authority>(?:${Rpe}@)?${Ppe}(?:${qD})?)`, X5 = `(?<path>${KD})`, eS = `(?<path2>${QD}${KD})`, tS = `(?:\\?(?<query>(?:${Z5}|/|\\?)*))?`, YD = `(?:#(?<fragment>(?:${Z5}|/|\\?)*))?`, Ope = `^${Md}:(?://${J5}${X5}|${eS})${tS}${YD}$`, Tpe = `^(?:${Md}:|)(?://${J5}${X5}|${eS})${tS}${YD}$`, Lpe = `^${Md}:(?://${J5}${X5}|${eS})${tS}$`, Dg = "[a-zA-Z0-9-._~\\00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF\\u10000-\\u1FFFD\\u20000-\\u2FFFD\\u30000-\\u3FFFD\\u40000-\\u4FFFD\\u50000-\\u5FFFD\\u60000-\\u6FFFD\\u70000-\\u7FFFD\\u80000-\\u8FFFD\\u90000-\\u9FFFD\\uA0000-\\uAFFFD\\uB0000-\\uBFFFD\\uC0000-\\uCFFFD\\uD0000-\\uDFFFD\\uE1000-\\uEFFFD]", Mpe = "[\\uE000-\\uF8FF\\uF0000-\\uFFFFD\\u100000-\\u10FFFD]", Npe = `(?:${Dg}|${jh}|${ao})*?`, Dpe = `(?<host>${WD}|${Y5}|${Npe})`, $pe = `(?<userinfo>(?:${Dg}|${jh}|${ao}|:)*)`, rS = `(?:${Dg}|${jh}|${ao}|:|@)`, ZD = `${rS}*?`, JD = `(?:/${ZD})*`, nS = `(?<authority>(?:${$pe}@)?${Dpe}(?:${qD})?)`, iS = `(?<path>${JD})`, sS = `(?<path2>${ZD}${JD})`, oS = `(?:\\?(?<query>(?:${rS}|${Mpe}|/|\\?)*))?`, XD = `(?:#(?<fragment>(?:${rS}|/|\\?)*))?`, e$ = `^${Md}:(?://${nS}${iS}|${sS})${oS}${XD}$`, t$ = `^(?:${Md}:|)(?://${nS}${iS}|${sS})${oS}${XD}$`, r$ = `^${Md}:(?://${nS}${iS}|${sS})${oS}$`, jpe = (t) => (e, r) => {
  const n = (
    /** @type IdentifierComponents */
    t.parseReference(e)
  );
  if (n.scheme === void 0) {
    const i = t.parseAbsolute(r);
    n.scheme = i.scheme, n.authority === void 0 && (n.authority = i.authority, n.path === "" ? (n.path = i.path, n.query === void 0 && (n.query = i.query)) : n.path.startsWith("/") || (n.path = Bpe(n.path, i)));
  }
  return n$(t, n);
}, Bpe = (t, e) => {
  if (e.authority && e.path === "")
    return "/" + t;
  {
    const r = e.path.lastIndexOf("/");
    return r === -1 ? t : e.path.slice(0, r + 1) + t;
  }
}, Fpe = /^\.?\.\/|^\.\.?$/, zpe = /^\/\.(?:\/|$)/, Vpe = /^\/\.\.(?:\/|$)/, Upe = (t) => {
  let e = "";
  for (; t.length > 0; )
    if (Fpe.test(t))
      t = l_(t);
    else if (zpe.test(t))
      t = c_(t);
    else if (Vpe.test(t))
      t = c_(t), e = Hpe(e);
    else {
      const r = Gpe(t);
      t = l_(t), e += r;
    }
  return e;
}, l_ = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "" : "/" + t.slice(e + 1);
}, c_ = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "/" : "/" + t.slice(e + 1);
}, Hpe = (t) => {
  const e = t.lastIndexOf("/");
  return e === -1 ? t : t.slice(0, e);
}, Gpe = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? t : t.slice(0, e);
}, n$ = (t, e) => {
  let r = e.scheme.toLowerCase() + ":";
  return r += e.authority === void 0 ? "" : "//" + e.authority.toLowerCase(), r += t.normalizePath(e.path), r += e.query === void 0 ? "" : "?" + t.normalizeQuery(e.query), r += e.fragment === void 0 ? "" : "#" + t.normalizeFragment(e.fragment), r;
}, i$ = new RegExp(jh, "g"), s$ = (t) => (e) => {
  const r = parseInt(e.slice(1), 16), n = String.fromCharCode(r);
  return t(n) ? n : e.toUpperCase();
};
RegExp.prototype.test.bind(new RegExp(`${Ld}|${ao}|[:@]`));
const Wpe = RegExp.prototype.test.bind(new RegExp(`${Dg}|${ao}|[:@]`)), qpe = (t) => (e) => Upe(e).replaceAll(i$, s$(t));
RegExp.prototype.test.bind(new RegExp(`${Ld}|${ao}|[:@/?]`));
const u_ = RegExp.prototype.test.bind(new RegExp(`${Dg}|${ao}|[:@/?]`)), h_ = (t) => (e) => e.replaceAll(i$, s$(t));
RegExp.prototype.test.bind(new RegExp(Ope));
RegExp.prototype.test.bind(new RegExp(Tpe));
RegExp.prototype.test.bind(new RegExp(Lpe));
RegExp.prototype.test.bind(new RegExp(e$));
RegExp.prototype.test.bind(new RegExp(t$));
RegExp.prototype.test.bind(new RegExp(r$));
const aS = (t, e) => (r) => {
  const n = t.exec(r);
  if (n === null)
    throw Error(`Invalid ${e}: ${r}`);
  const i = (
    /** @type Record<string, string> */
    n.groups
  );
  return i.authority === void 0 && (i.path = i.path2), delete i.path2, /** @type A */
  i;
}, lS = (
  /** @type Parser<IdentifierComponents> */
  aS(new RegExp(e$), "IRI")
), o$ = (
  /** @type Parser<RelativeIdentifierComponents> */
  aS(new RegExp(t$), "IRI-reference")
), Qpe = (
  /** @type Parser<AbsoluteIdentifierComponents> */
  aS(new RegExp(r$), "absolute-IRI")
), a$ = {
  iri: {
    parseAbsolute: Qpe,
    parseReference: o$,
    parse: lS,
    normalizePath: qpe(Wpe),
    normalizeQuery: h_(u_),
    normalizeFragment: h_(u_)
  }
}, Kpe = (t) => (e) => {
  const r = t.parse(e);
  return delete r.fragment, n$(t, r);
}, Yu = Kpe(a$.iri), O0 = jpe(a$.iri), Ype = "", o4 = function* (t) {
  if (t.length > 0 && t[0] !== "/")
    throw Error("Invalid JSON Pointer");
  let e = 1, r = 0;
  for (; r < t.length; ) {
    const n = t.indexOf("/", e);
    r = n === -1 ? t.length : n;
    const i = t.slice(e, r);
    e = r + 1, yield Xpe(i);
  }
}, Zpe = (t, e = void 0) => {
  if (e === void 0) {
    const r = [...o4(t)];
    return (n) => p_(r, n);
  } else
    return p_(o4(t), e);
}, p_ = (t, e) => {
  let r = Ype;
  for (const n of t)
    e = tde(e, n, r), r = yh(n, r);
  return e;
}, yh = (t, e) => e + "/" + Jpe(t), Jpe = (t) => t.toString().replace(/~/g, "~0").replace(/\//g, "~1"), Xpe = (t) => t.toString().replace(/~1/g, "/").replace(/~0/g, "~"), ede = (t, e) => Array.isArray(t) && e === "-" ? t.length : e, tde = (t, e, r = "") => {
  if (t === void 0)
    throw TypeError(`Value at '${r}' is undefined and does not have property '${e}'`);
  if (t === null)
    throw TypeError(`Value at '${r}' is null and does not have property '${e}'`);
  if (rde(t))
    throw TypeError(`Value at '${r}' is a ${typeof t} and does not have property '${e}'`);
  {
    const n = ede(t, e);
    return t[n];
  }
}, rde = (t) => t === null || typeof t != "object", l$ = (t) => {
  const e = typeof t;
  switch (e) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JSON compatible type: ${r}`);
    }
  }
}, c$ = (t) => {
  const e = t.indexOf("#"), r = e === -1 ? t.length : e;
  return t.slice(0, r);
}, u$ = (t) => decodeURIComponent(o$(t).fragment || ""), By = {}, Rb = (t) => {
  if (t.indexOf("#") !== -1) {
    const e = c$(t);
    return { ...By[e], id: t };
  }
  return By[t];
}, nde = (t, e) => {
  const r = ide(t, e);
  if (!r)
    throw Error(`Encountered unknown keyword '${t}'`);
  const n = Rb(r);
  if (!n)
    throw Error(`Encountered unsupported keyword ${t}. You can provide an implementation for the '${r}' keyword using the 'addKeyword' function.`);
  return n;
}, ct = (t) => {
  By[t.id] = t;
}, a4 = {}, Rc = (t, e) => {
  a4[t] = e;
}, Zf = {}, l4 = {}, Rw = {}, ide = (t, e) => {
  var r;
  return ((r = h$(e)) == null ? void 0 : r[t]) || (l4[e] || t.startsWith("x-")) && `https://json-schema.org/keyword/unknown#${t}`;
}, Xr = (t, e) => {
  const r = h$(t);
  for (const n in r)
    if (r[n] === e)
      return n;
}, h$ = (t) => {
  if (!(t in Zf))
    throw Error(`Encountered unknown dialect '${t}'`);
  return Zf[t];
}, p$ = (t, e, r = !1, n = !0) => {
  l4[t] = r, Rw[t] = Rw[t] || n, Zf[t] = {}, Object.entries(e).forEach(([i, s]) => {
    if (i in a4)
      Object.entries(a4[i]).forEach(([o, a]) => {
        !(a in By) && !s && (a = `https://json-schema.org/keyword/unknown#${o}`), Zf[t][o] = a;
      });
    else if (!r || s)
      throw delete Zf[t], delete l4[t], delete Rw[t], Error(`Unrecognized vocabulary: ${i}. You can define this vocabulary with the 'defineVocabulary' function.`);
  });
};
var d_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function d$(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Bm = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var f_;
function sde() {
  if (f_) return Bm;
  f_ = 1;
  var t = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, e = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, n = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  Bm.format = o, Bm.parse = a;
  function o(h) {
    if (!h || typeof h != "object")
      throw new TypeError("argument obj is required");
    var d = h.parameters, b = h.type;
    if (!b || !s.test(b))
      throw new TypeError("invalid type");
    var m = b;
    if (d && typeof d == "object")
      for (var w, f = Object.keys(d).sort(), E = 0; E < f.length; E++) {
        if (w = f[E], !r.test(w))
          throw new TypeError("invalid parameter name");
        m += "; " + w + "=" + c(d[w]);
      }
    return m;
  }
  function a(h) {
    if (!h)
      throw new TypeError("argument string is required");
    var d = typeof h == "object" ? l(h) : h;
    if (typeof d != "string")
      throw new TypeError("argument string is required to be a string");
    var b = d.indexOf(";"), m = b !== -1 ? d.slice(0, b).trim() : d.trim();
    if (!s.test(m))
      throw new TypeError("invalid media type");
    var w = new p(m.toLowerCase());
    if (b !== -1) {
      var f, E, A;
      for (t.lastIndex = b; E = t.exec(d); ) {
        if (E.index !== b)
          throw new TypeError("invalid parameter format");
        b += E[0].length, f = E[1].toLowerCase(), A = E[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(n, "$1"))), w.parameters[f] = A;
      }
      if (b !== d.length)
        throw new TypeError("invalid parameter format");
    }
    return w;
  }
  function l(h) {
    var d;
    if (typeof h.getHeader == "function" ? d = h.getHeader("content-type") : typeof h.headers == "object" && (d = h.headers && h.headers["content-type"]), typeof d != "string")
      throw new TypeError("content-type header is missing from object");
    return d;
  }
  function c(h) {
    var d = String(h);
    if (r.test(d))
      return d;
    if (d.length > 0 && !e.test(d))
      throw new TypeError("invalid parameter value");
    return '"' + d.replace(i, "\\$1") + '"';
  }
  function p(h) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = h;
  }
  return Bm;
}
var f$ = sde();
const ode = /* @__PURE__ */ d$(f$), T0 = {}, g$ = (t, e) => {
  T0[t] = e;
}, ade = (t) => {
  const e = t.headers.get("content-type");
  if (e === null)
    throw new dde("The media type of the response could not be determined. Make sure the response includes a 'Content-Type' header.", { cause: t });
  const r = f$.parse(e);
  for (const n in T0)
    if (ude(n, r.type))
      return T0[n].parse(t);
  throw new pde(r.type, `'${r.type}' is not supported. Use the 'addMediaTypePlugin' function to add support for this media type.`, {
    cause: t
  });
}, lde = "A-Za-z", Ow = `[!#$%&'*\\-_.^\`|~\\d${lde}]+`, cde = `(?<type>${Ow})/(?<subType>${Ow}(?:\\+(?<suffix>${Ow}))?)`, g_ = new RegExp(cde), ude = (t, e) => {
  var r, n;
  if (t === e)
    return !0;
  const i = (r = g_.exec(t)) == null ? void 0 : r.groups;
  if (!i)
    throw Error(`Unable to parse media-range: ${t}`);
  const s = (n = g_.exec(e)) == null ? void 0 : n.groups;
  if (!s)
    throw Error(`Unable to parse media-type: ${e}`);
  return (i.type === s.type || i.type === "*") && (i.subType === s.subType || i.subType === "*" || i.subType === s.suffix);
}, hde = () => {
  let t = "";
  for (const e in T0)
    t = m_(t, e, T0[e].quality);
  return m_(t, "*/*", "0.001");
}, m_ = (t, e, r) => (t.length > 0 && (t += ", "), t += e, r && (t += `; q=${r}`), t);
let pde = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.mediaType = e;
  }
}, dde = class extends Error {
  constructor(e = void 0) {
    super(e), this.name = this.constructor.name;
  }
};
const fde = (t, e = void 0) => JSON.parse(t, (r, n) => {
  const i = n !== null && typeof n.$ref == "string" ? new $u(n.$ref) : n;
  return e ? e(r, i) : i;
});
var A1, k1;
let $u = class {
  constructor(e, r = void 0) {
    o_(this, A1), o_(this, k1), a_(this, A1, e), a_(this, k1, r ?? { $ref: e });
  }
  get href() {
    return s_(this, A1);
  }
  toJSON() {
    return s_(this, k1);
  }
};
A1 = /* @__PURE__ */ new WeakMap(), k1 = /* @__PURE__ */ new WeakMap();
const m$ = (t) => {
  const e = typeof t;
  switch (e) {
    case "bigint":
      return "number";
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (t instanceof $u)
        return "reference";
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype || Object.getPrototypeOf(t) === null)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JRef compatible type: ${r}`);
    }
  }
}, gde = {
  parse: async (t) => ({
    baseUri: t.url,
    root: fde(await t.text()),
    anchorLocation: mde
  }),
  fileMatcher: (t) => /[^/]\.jref$/.test(t)
}, mde = (t) => decodeURI(t || ""), c4 = {}, y$ = (t, e) => {
  c4[t] = e;
}, yde = (t, e) => {
  t = O0(t, e);
  const { scheme: r } = lS(t);
  if (!(r in c4))
    throw new bde(r, `The '${r}:' URI scheme is not supported. Use the 'addUriSchemePlugin' function to add support for '${r}:' URIs.`);
  return c4[r].retrieve(t, e);
};
let bde = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.scheme = e;
  }
};
const vde = /* @__PURE__ */ new Set([200, 203]), wde = async (t) => {
  const e = await fetch(t, { headers: { Accept: hde() } });
  if (e.status >= 400)
    throw new y_(e, `Failed to retrieve '${t}'`);
  if (!vde.has(e.status))
    throw new y_(e, "Unsupported HTTP response status code");
  return e;
}, b$ = { retrieve: wde };
let y_ = class extends Error {
  constructor(e, r = void 0) {
    super(`${e.status} ${e.statusText}${r ? ` -- ${r}` : ""}`), this.name = this.constructor.name, this.response = e;
  }
};
var v$ = xde;
function xde(t, e) {
  return function r() {
    e == null && (e = t.length);
    var n = [].slice.call(arguments);
    return n.length >= e ? t.apply(this, n) : function() {
      return r.apply(this, n.concat([].slice.call(arguments)));
    };
  };
}
const Ede = () => {
  var t, e;
  return ((e = (t = globalThis.document) == null ? void 0 : t.location) == null ? void 0 : e.toString()) ?? "";
}, Ob = async (t, e = { _cache: {} }) => {
  var r, n, i;
  const s = ((r = e.document) == null ? void 0 : r.baseUri) ?? Ede();
  t = O0(t, s);
  const o = Yu(t), { fragment: a } = lS(t), l = e._cache[o] ?? ((i = (n = e.document) == null ? void 0 : n.embedded) == null ? void 0 : i[o]);
  if (l)
    e.document = l, e.uri = t, e.cursor = e.document.anchorLocation(a);
  else {
    try {
      const c = await yde(t, s);
      e.document = await ade(c), e.uri = c.url + (a === void 0 ? "" : `#${a}`), e.cursor = e.document.anchorLocation(a);
    } catch (c) {
      const p = e.uri ? ` Referenced from '${e.uri}'.` : "";
      throw new Ade(`Unable to load resource '${t}'.${p}`, c);
    }
    e._cache[o] = e.document;
  }
  return e._value = Zpe(e.cursor, e.document.root), w$(e);
}, w$ = (t) => m$(Pt(t)) === "reference" ? Ob(Pt(t).href, t) : t, Pt = (t) => t._value, Na = (t) => m$(t._value), x$ = (t, e) => t in e._value, E$ = (t) => t._value.length, Ks = v$((t, e) => w$({
  ...e,
  cursor: yh(`${t}`, e.cursor),
  _value: e._value[t]
})), Oc = async function* (t) {
  for (let e = 0; e < Pt(t).length; e++)
    yield Ks(e, t);
}, u4 = function* (t) {
  for (const e in Pt(t))
    yield e;
}, Sde = async function* (t) {
  for (const e in Pt(t))
    yield Ks(e, t);
}, bh = async function* (t) {
  for (const e in Pt(t))
    yield [e, await Ks(e, t)];
};
let Ade = class extends Error {
  constructor(e, r) {
    super(e, { cause: r }), this.name = this.constructor.name;
  }
};
g$("application/reference+json", gde);
y$("http", b$);
y$("https", b$);
const kde = {
  parse: async (t) => {
    const e = ode.parse(t.headers.get("content-type") ?? ""), r = e.parameters.schema ?? e.parameters.profile;
    return zy(await t.json(), t.url, r);
  },
  fileMatcher: async (t) => /(\.|\/)schema\.json$/.test(t)
}, Fy = {}, _de = async (t, e = void 0) => {
  e || (e = { _cache: {} });
  for (const n in Fy)
    n in e._cache || (e._cache[n] = Fy[n]);
  const r = await Ob(t, { ...e });
  if (typeof r.document.dialectId != "string")
    throw Error(`The document at ${r.document.baseUri} is not a schema.`);
  return r;
}, Ya = (t, e, r) => {
  t = structuredClone(t);
  const n = zy(t, e, r);
  if (n.baseUri in Fy)
    throw Error(`A schema has already been registered for '${n.baseUri}. You can use 'unregisterSchema' to remove the old schema before registering the new one.`);
  if (n.baseUri.startsWith("file:"))
    throw Error(`Registering a schema with a 'file:' URI scheme is not allowed: ${n.baseUri}`);
  Fy[n.baseUri] = n;
}, zy = (t, e, r, n = {}) => {
  if (typeof t.$schema == "string" && (r = t.$schema, delete t.$schema), !r)
    throw Error("Unable to determine a dialect for the schema. The dialect can be declared in a number of ways, but the recommended way is to use the '$schema' keyword in your schema.");
  r = Yu(r);
  const i = Xr(r, "https://json-schema.org/keyword/draft-04/id"), s = Xr(r, "https://json-schema.org/keyword/id") || i;
  if (!t[s] && !e)
    throw Error(`Unable to determine an identifier for the schema. Use the '${s}' keyword or pass a retrievalUri when loading the schema.`);
  const o = O0(t[s] ?? "", e ?? "");
  e = Yu(o), i && o.length > e.length ? t[s] = "#" + u$(o) : delete t[s];
  const a = Xr(r, "https://json-schema.org/keyword/vocabulary");
  if (l$(t[a]) === "object") {
    const h = t[a]["https://json-schema.org/draft/2019-09/vocab/core"] || t[a]["https://json-schema.org/draft/2020-12/vocab/core"];
    p$(e, t[a], h, !1), delete t[a];
  }
  const l = { "": "" }, c = {}, p = Xr(r, "https://json-schema.org/keyword/draft-2019-09/recursiveAnchor");
  return t[p] === !0 && (c[""] = `${e}#`), delete t[p], n[e] = {
    baseUri: e,
    dialectId: r,
    root: h4(t, e, r, "", n, l, c),
    anchorLocation: (h) => {
      if (h === void 0)
        return "";
      if (h = decodeURI(h), h[0] === "/")
        return h;
      if (h in l)
        return l[h];
      throw Error(`No such anchor '${e}#${encodeURI(h)}'`);
    },
    anchors: l,
    dynamicAnchors: c,
    embedded: n
  }, n[e];
}, h4 = (t, e, r, n, i, s, o) => {
  if (l$(t) === "object") {
    const a = typeof t.$schema == "string" ? Yu(t.$schema) : r, l = Xr(a, "https://json-schema.org/keyword/id");
    if (typeof t[l] == "string") {
      const m = Yu(O0(t[l], e));
      return t[l] = m, i[m] = zy(t, m, a, i), new $u(m, {});
    }
    const c = Xr(a, "https://json-schema.org/keyword/draft-04/id");
    if (typeof t[c] == "string")
      if (t[c][0] === "#") {
        const m = decodeURIComponent(t[c].slice(1));
        s[m] = n, delete t[c];
      } else {
        const m = Yu(O0(t[c], e));
        return t[c] = m, i[m] = zy(t, m, a, i), new $u(m, {});
      }
    const p = Xr(r, "https://json-schema.org/keyword/draft-04/ref");
    if (typeof t[p] == "string")
      return new $u(t[p], t);
    const h = Xr(r, "https://json-schema.org/keyword/anchor");
    typeof t[h] == "string" && (s[t[h]] = n, delete t[h]);
    const d = Xr(r, "https://json-schema.org/keyword/dynamicAnchor");
    typeof t[d] == "string" && (o[t[d]] = `${e}#${encodeURI(n)}`, delete t[d]);
    const b = Xr(r, "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor");
    typeof t[b] == "string" && (o[t[b]] = `${e}#${encodeURI(n)}`, s[t[b]] = n, delete t[b]);
    for (const m in t) {
      const w = Xr(r, "https://json-schema.org/keyword/ref");
      m === w && typeof t[m] == "string" ? t[m] = new $u(t[m], t[m]) : t[m] = h4(t[m], e, r, yh(m, n), i, s, o);
    }
  } else if (Array.isArray(t))
    for (let a = 0; a < t.length; a++)
      t[a] = h4(t[a], e, r, yh(a, n), i, s, o);
  return t;
}, Yp = (t) => `${t.document.baseUri}#${encodeURI(t.cursor)}`, Nd = (
  /** @type API.curry */
  (t) => (...e) => {
    const r = t.length === 1 ? (
      /** @type Extract<typeof fn, (a: any) => any> */
      t(e[0])
    ) : t(e[0], e[1]), n = (
      /** @type I */
      e[t.length]
    );
    return n === void 0 ? r : r(n);
  }
), S$ = Nd((t) => function* (e) {
  for (const r of e)
    yield t(r);
}), Zn = Nd((t) => async function* (e) {
  for await (const r of e)
    yield t(r);
}), A$ = Nd((t) => function* (e) {
  for (const r of e)
    t(r) && (yield r);
}), Cde = Nd((t) => function* (e) {
  let r = 0;
  for (const n of e)
    r++ >= t && (yield n);
}), Ide = (t) => {
  const e = C$(t).next();
  return e.done ? void 0 : e.value;
}, k$ = function* (t, e) {
  for (let r = t; e === void 0; r++)
    yield r;
}, b_ = function* () {
}, cS = function* (t, e) {
  const r = C$(e);
  for (const n of t)
    yield [n, r.next().value];
}, Pde = function* (...t) {
  for (const e of t)
    yield* e;
}, _$ = (
  /** @type API.reduce */
  Nd(
    // eslint-disable-next-line @stylistic/no-extra-parens
    /** @type API.reduce */
    (t, e) => (r) => {
      for (const n of r)
        e = t(
          e,
          /** @type any */
          n
        );
      return e;
    }
  )
), lo = async (t) => {
  const e = [];
  for await (const r of t)
    e.push(r);
  return e;
}, Rde = (t) => {
  const e = /* @__PURE__ */ new Set();
  for (const r of t)
    e.add(r);
  return e;
}, p4 = async (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  for await (const [r, n] of t)
    e[r] = n;
  return e;
}, Ode = Nd((t) => (e) => {
  let r = Ide(e) ?? "";
  for (const n of e)
    r += t + n;
  return r;
}), C$ = (t) => {
  if (typeof (t == null ? void 0 : t[Symbol.iterator]) == "function")
    return t[Symbol.iterator]();
  throw TypeError("`iter` is not iterable");
}, bn = (
  /** @type (acc: any, ...fns: ((a: any) => any)[]) => any */
  (t, ...e) => _$((r, n) => n(r), t, e)
), _1 = (t, e = "", r = "", n = void 0) => {
  const i = typeof t;
  switch (i) {
    case "number":
    case "string":
    case "boolean":
      return Ef(e, r, t, i, [], n);
    case "object":
      if (t === null)
        return Ef(e, r, t, "null", [], n);
      if (Array.isArray(t)) {
        const s = Ef(e, r, t, "array", [], n);
        return s.children = t.map((o, a) => _1(o, e, yh(a, r), s)), s;
      } else if (Object.getPrototypeOf(t) === Object.prototype) {
        const s = Ef(e, r, t, "object", [], n);
        return s.children = Object.entries(t).map((o) => {
          const a = yh(o[0], r), l = Ef(e, a, void 0, "property", [], s);
          return l.children = o.map((c) => _1(c, e, a, l)), l;
        }), s;
      } else if (t instanceof $u)
        return _1(t.toJSON(), e, r, n);
    default: {
      const s = i === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : i;
      throw Error(`Not a JSON compatible type: ${s}`);
    }
  }
}, Ef = (t, e, r, n, i, s) => {
  const o = {
    baseUri: t ? Yu(t) : "",
    pointer: e,
    value: r,
    type: n,
    children: i,
    parent: s,
    valid: !0,
    errors: {},
    annotations: {}
  };
  return o.root = (s == null ? void 0 : s.root) ?? o, o;
}, Tde = (t) => `${t.baseUri}#${encodeURI(t.pointer)}`, _r = (t) => t.value, Wt = (t) => t.type, Zp = (t, e) => t in e.value, Bh = function* (t) {
  t.type === "array" && (yield* t.children);
}, uS = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      yield e.children[0];
}, Lde = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children[1] && (yield e.children[1]);
}, Tc = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children.length === 2 && (yield e.children);
}, $g = (t) => {
  if (t.type === "array")
    return t.children.length;
}, d4 = function* (t) {
  switch (yield t, Wt(t)) {
    case "object":
      for (const e of Lde(t))
        yield* d4(e);
      break;
    case "array":
      for (const e of Bh(t))
        yield* d4(e);
      break;
  }
}, Np = {};
let Mde = 0;
const Nde = (t, e) => {
  t in Np || (Np[t] = {});
  const r = `pubsub_subscription_${Mde++}`;
  return Np[t][r] = e, r;
}, Dde = async (t, e) => {
  const r = [];
  for (const n in Np)
    if (n === t || t.startsWith(`${n}.`))
      for (const i in Np[n])
        r.push(Np[t][i](t, e));
  await Promise.all(r);
};
let I$;
const $de = () => I$, jde = (t) => {
  I$ = t;
};
let Bde = class extends Error {
  constructor(e) {
    super("Invalid Schema"), this.name = this.constructor.name, this.output = e;
  }
};
const P$ = "https://json-schema.org/evaluation/validate", Fde = async (t, e) => {
  await Dde("validate.metaValidate", t), t.document.baseUri in e.metaData || (e.metaData[t.document.baseUri] = {
    dynamicAnchors: t.document.dynamicAnchors
  });
  const r = Yp(t);
  if (!(r in e)) {
    e[r] = !1;
    const n = Pt(t);
    if (!["object", "boolean"].includes(typeof n))
      throw Error(`No schema found at '${r}'`);
    e[r] = typeof n == "boolean" ? n : await bn(
      bh(t),
      Zn(async ([i, s]) => {
        const o = nde(i, t.document.dialectId), a = await o.compile(s, e, t);
        return [o.id, yh(i, Yp(t)), a];
      }),
      lo
    );
  }
  return r;
}, zde = (t, e, r, n, i = !1) => {
  n = { ...r.metaData[c$(t)].dynamicAnchors, ...n };
  let s = !0;
  if (typeof r[t] == "boolean")
    s = r[t];
  else
    for (const [o, a, l] of r[t])
      e.valid = Rb(o).interpret(l, e, r, n, i, t), e.valid || (i || (e.errors[a] = o), s = !1);
  return s || (e.errors[t] = P$), e.valid = s, s;
}, Vde = /* @__PURE__ */ new Set(), Ude = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedProperties")
      continue;
    const l = Rb(o), c = "collectEvaluatedProperties" in l ? l.collectEvaluatedProperties(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && Vde;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, Hde = /* @__PURE__ */ new Set(), Gde = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedItems")
      continue;
    const l = Rb(o), c = "collectEvaluatedItems" in l ? l.collectEvaluatedItems(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && Hde;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, We = { id: P$, compile: Fde, interpret: zde, collectEvaluatedProperties: Ude, collectEvaluatedItems: Gde }, Vy = {}, Wde = (t, e) => {
  if (e in Vy)
    return Vy[e](t);
  throw Error(`The '${e}' error format is not supported`);
};
Vy.FLAG = (t) => ({ valid: t.valid });
Vy.BASIC = (t) => {
  const e = {
    valid: t.valid
  };
  if (!t.valid) {
    e.errors = [];
    for (const r of d4(t))
      for (const [n, i] of Object.entries(r.errors).reverse())
        i !== "https://json-schema.org/evaluation/validate" && !r.valid && e.errors.unshift({
          keyword: i,
          absoluteKeywordLocation: n,
          instanceLocation: Tde(r),
          valid: r.valid
        });
  }
  return e;
};
const R$ = "FLAG";
jde(R$);
const qde = async (t) => {
  const e = { metaData: {} }, r = await We.compile(t, e);
  return { ast: e, schemaUri: r };
}, Qde = v$(({ ast: t, schemaUri: e }, r, n = R$) => (We.interpret(e, r, t, {}), Wde(r, n))), Tw = {};
Nde("validate.metaValidate", async (t, e) => {
  if (!e.document.validated) {
    if (e.document.validated = !0, !(e.document.dialectId in Tw)) {
      const i = await _de(e.document.dialectId, e), s = await qde(i);
      Tw[e.document.dialectId] = Qde(s);
    }
    const r = _1(e.document.root, e.document.baseUri), n = Tw[e.document.dialectId](r, $de());
    if (!n.valid)
      throw new Bde(n);
  }
});
const Kde = "https://json-schema.org/keyword/additionalProperties", Yde = async (t, e, r) => {
  const n = Xr(t.document.dialectId, "https://json-schema.org/keyword/properties"), i = await Ks(n, r), s = Na(i) === "object" ? S$((p) => "^" + Zde(p) + "$", u4(i)) : b_(), o = Xr(t.document.dialectId, "https://json-schema.org/keyword/patternProperties"), a = await Ks(o, r), l = Na(a) === "object" ? u4(a) : b_(), c = bn(
    Pde(s, l),
    Ode("|")
  ) || "(?!)";
  return [new RegExp(c, "u"), await We.compile(t, e)];
}, Zde = (t) => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), Jde = ([t, e], r, n, i, s) => {
  if (Wt(r) !== "object")
    return !0;
  let o = !0;
  for (const [a, l] of Tc(r)) {
    const c = _r(a);
    !t.test(c) && !We.interpret(e, l, n, i, s) && (o = !1);
  }
  return o;
}, Xde = ([t, e], r, n, i) => {
  if (Wt(r) !== "object")
    return !0;
  const s = /* @__PURE__ */ new Set();
  for (const [o, a] of Tc(r)) {
    const l = _r(o);
    if (!t.test(l)) {
      if (!We.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, efe = { id: Kde, compile: Yde, interpret: Jde, collectEvaluatedProperties: Xde }, tfe = "https://json-schema.org/keyword/allOf", rfe = (t, e) => bn(
  Oc(t),
  Zn((r) => We.compile(r, e)),
  lo
), nfe = (t, e, r, n, i) => {
  let s = !0;
  for (const o of t)
    We.interpret(o, e, r, n, i) || (s = !1);
  return s;
}, ife = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = We.collectEvaluatedProperties(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, sfe = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = We.collectEvaluatedItems(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, ofe = { id: tfe, compile: rfe, interpret: nfe, collectEvaluatedProperties: ife, collectEvaluatedItems: sfe }, afe = { id: "https://json-schema.org/keyword/anchor" }, lfe = "https://json-schema.org/keyword/anyOf", cfe = (t, e) => bn(
  Oc(t),
  Zn((r) => We.compile(r, e)),
  lo
), ufe = (t, e, r, n, i) => t.filter((s) => We.interpret(s, e, r, n, i)).length > 0, hfe = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = We.collectEvaluatedProperties(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, pfe = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = We.collectEvaluatedItems(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, dfe = { id: lfe, compile: cfe, interpret: ufe, collectEvaluatedProperties: hfe, collectEvaluatedItems: pfe }, ffe = "https://json-schema.org/keyword/conditional", gfe = (t, e) => bn(
  Oc(t),
  O$,
  Zn((r) => We.compile(r, e)),
  lo
), mfe = (t, e, r, n, i) => {
  for (let s = 0; s < t.length; s += 2) {
    const o = We.interpret(t[s], e, r, n, i);
    if (s + 1 === t.length)
      return o;
    if (o)
      return We.interpret(t[s + 1], e, r, n, i);
  }
  return !0;
}, yfe = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = We.collectEvaluatedProperties(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return We.collectEvaluatedProperties(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, bfe = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = We.collectEvaluatedItems(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return We.collectEvaluatedItems(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, O$ = async function* (t, e = 1) {
  for await (const r of t)
    e > 0 && Na(r) === "array" ? yield* O$(Oc(r), e - 1) : yield r;
}, vfe = { id: ffe, compile: gfe, interpret: mfe, collectEvaluatedProperties: yfe, collectEvaluatedItems: bfe };
var v_, w_;
function wfe() {
  return w_ || (w_ = 1, v_ = {
    space: "",
    cycles: !1,
    replacer: (t, e) => e,
    stringify: JSON.stringify
  }), v_;
}
var x_, E_;
function Su() {
  return E_ || (E_ = 1, x_ = {
    isArray: Array.isArray,
    assign: Object.assign,
    isObject: (t) => typeof t == "object",
    isFunction: (t) => typeof t == "function",
    isBoolean: (t) => typeof t == "boolean",
    isRegex: (t) => t instanceof RegExp,
    keys: Object.keys
  }), x_;
}
var Lw, S_;
function xfe() {
  if (S_) return Lw;
  S_ = 1;
  const t = wfe(), e = Su().isFunction, r = Su().isBoolean, n = Su().isObject, i = Su().isArray, s = Su().isRegex, o = Su().assign, a = Su().keys;
  function l(p) {
    return p == null ? p : s(p) ? p.toString() : p.toJSON ? p.toJSON() : p;
  }
  function c(p, h) {
    h = h || o({}, t), e(h) && (h = { compare: h });
    const d = h.space || t.space, b = r(h.cycles) ? h.cycles : t.cycles, m = h.replacer || t.replacer, w = h.stringify || t.stringify, f = h.compare && /* @__PURE__ */ function(A) {
      return function(x) {
        return function(g, v) {
          const k = { key: g, value: x[g] }, S = { key: v, value: x[v] };
          return A(k, S);
        };
      };
    }(h.compare);
    b || w(p);
    const E = [];
    return function A(x, g, v, k) {
      const S = d ? `
` + new Array(k + 1).join(d) : "", R = d ? ": " : ":";
      if (v = l(v), v = m.call(x, g, v), v !== void 0) {
        if (!n(v) || v === null) return w(v);
        if (i(v)) {
          const L = [];
          for (let F = 0; F < v.length; F++) {
            const z = A(v, F, v[F], k + 1) || w(null);
            L.push(S + d + z);
          }
          return "[" + L.join(",") + S + "]";
        } else {
          if (b) {
            if (E.indexOf(v) !== -1)
              return w("[Circular]");
            E.push(v);
          }
          const L = a(v).sort(f && f(v)), F = [];
          for (let z = 0; z < L.length; z++) {
            const j = L[z], ee = A(v, j, v[j], k + 1);
            if (!ee) continue;
            const X = w(j) + R + ee;
            F.push(S + d + X);
          }
          return E.splice(E.indexOf(v), 1), "{" + F.join(",") + S + "}";
        }
      }
    }({ "": p }, "", p, 0);
  }
  return Lw = c, Lw;
}
var Efe = xfe();
const jg = /* @__PURE__ */ d$(Efe), Sfe = "https://json-schema.org/keyword/const", Afe = (t) => jg(Pt(t)), kfe = (t, e) => jg(_r(e)) === t, _fe = { id: Sfe, compile: Afe, interpret: kfe }, Cfe = "https://json-schema.org/keyword/contains", Ife = async (t, e, r) => {
  const n = await We.compile(t, e), i = Xr(t.document.dialectId, "https://json-schema.org/keyword/minContains"), s = await Ks(i, r), o = Na(s) === "number" ? Pt(s) : 1, a = Xr(t.document.dialectId, "https://json-schema.org/keyword/maxContains"), l = await Ks(a, r), c = Na(l) === "number" ? Pt(l) : Number.MAX_SAFE_INTEGER;
  return { contains: n, minContains: o, maxContains: c };
}, T$ = ({ contains: t, minContains: e, maxContains: r }, n, i, s, o) => {
  const a = Wt(n) !== "array" || bn(
    Bh(n),
    A$((l) => We.interpret(t, l, i, s, o)),
    _$((l) => l + 1, 0)
  );
  return a >= e && a <= r;
}, Pfe = (t, e, r, n) => T$(t, e, r, n, !0) && Wt(e) === "array" && bn(
  cS(Bh(e), k$(0)),
  A$(([i]) => We.interpret(t.contains, i, r, n, !0)),
  S$(([, i]) => i),
  Rde
), Rfe = { id: Cfe, compile: Ife, interpret: T$, collectEvaluatedItems: Pfe }, Ofe = "https://json-schema.org/keyword/comment", Tfe = () => {
}, Lfe = () => !0, Mfe = { id: Ofe, compile: Tfe, interpret: Lfe }, Is = (t, e, r, n) => {
  e in t.annotations || (t.annotations[e] = {}), t.annotations[e][r] = n;
}, L$ = "https://json-schema.org/keyword/contentEncoding", Nfe = (t) => Pt(t), Dfe = (t, e, r, n, i, s) => (Is(e, L$, s, t), !0), $fe = { id: L$, compile: Nfe, interpret: Dfe }, M$ = "https://json-schema.org/keyword/contentMediaType", jfe = (t) => Pt(t), Bfe = (t, e, r, n, i, s) => (Is(e, M$, s, t), !0), Ffe = { id: M$, compile: jfe, interpret: Bfe }, N$ = "https://json-schema.org/keyword/contentSchema", zfe = (t) => Yp(t), Vfe = (t, e, r, n, i, s) => (Is(e, N$, s, t), !0), Ufe = { id: N$, compile: zfe, interpret: Vfe }, D$ = "https://json-schema.org/keyword/default", Hfe = (t) => Pt(t), Gfe = (t, e, r, n, i, s) => (Is(e, D$, s, t), !0), Wfe = { id: D$, compile: Hfe, interpret: Gfe }, qfe = "https://json-schema.org/keyword/definitions", Qfe = (t, e) => bn(
  Sde(t),
  Zn((r) => We.compile(r, e)),
  lo
), Kfe = () => !0, Yfe = { id: qfe, compile: Qfe, interpret: Kfe }, Zfe = "https://json-schema.org/keyword/dependentRequired", Jfe = (t) => bn(
  bh(t),
  Zn(([e, r]) => [e, Pt(r)]),
  lo
), Xfe = (t, e) => {
  if (Wt(e) !== "object")
    return !0;
  let r = !0;
  for (const [n, i] of t)
    Zp(n, e) && !i.every((s) => Zp(s, e)) && (r = !1);
  return r;
}, e0e = { id: Zfe, compile: Jfe, interpret: Xfe }, t0e = "https://json-schema.org/keyword/dependentSchemas", r0e = (t, e) => bn(
  bh(t),
  Zn(async ([r, n]) => [r, await We.compile(n, e)]),
  lo
), n0e = (t, e, r, n, i) => {
  if (Wt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    Zp(o, e) && !We.interpret(a, e, r, n, i) && (s = !1);
  return s;
}, i0e = (t, e, r, n) => {
  if (Wt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    if (Zp(s, e)) {
      const a = We.collectEvaluatedProperties(o, e, r, n);
      if (a === !1)
        return !1;
      a.forEach(Set.prototype.add.bind(i));
    }
  return i;
}, s0e = { id: t0e, compile: r0e, interpret: n0e, collectEvaluatedProperties: i0e }, $$ = "https://json-schema.org/keyword/deprecated", o0e = (t) => Pt(t), a0e = (t, e, r, n, i, s) => (Is(e, $$, s, t), !0), l0e = { id: $$, compile: o0e, interpret: a0e }, j$ = "https://json-schema.org/keyword/description", c0e = (t) => Pt(t), u0e = (t, e, r, n, i, s) => (Is(e, j$, s, t), !0), h0e = { id: j$, compile: c0e, interpret: u0e }, p0e = { id: "https://json-schema.org/keyword/dynamicAnchor" }, d0e = "https://json-schema.org/keyword/dynamicRef", f0e = async (t, e) => {
  const r = Pt(t), n = await Ob(t.document.baseUri, t);
  return await We.compile(n, e), r;
}, hS = (t, e, r, n, i, s) => {
  if (!(e in i))
    throw Error(`No dynamic anchor found for "${e}"`);
  return t(i[e], r, n, i, s);
}, g0e = (...t) => hS(We.interpret, ...t), m0e = (...t) => hS(We.collectEvaluatedProperties, ...t), y0e = (...t) => hS(We.collectEvaluatedItems, ...t), b0e = { id: d0e, compile: f0e, interpret: g0e, collectEvaluatedProperties: m0e, collectEvaluatedItems: y0e }, v0e = "https://json-schema.org/keyword/else", w0e = async (t, e, r) => {
  const n = Xr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (x$(n, r)) {
    const i = await Ks(n, r);
    return [await We.compile(i, e), await We.compile(t, e)];
  } else
    return [];
}, x0e = ([t, e], r, n, i, s) => t === void 0 || We.interpret(t, r, n, i, !0) || We.interpret(e, r, n, i, s), E0e = ([t, e], r, n, i) => t === void 0 || We.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : We.collectEvaluatedProperties(e, r, n, i), S0e = ([t, e], r, n, i) => t === void 0 || We.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : We.collectEvaluatedItems(e, r, n, i), A0e = { id: v0e, compile: w0e, interpret: x0e, collectEvaluatedProperties: E0e, collectEvaluatedItems: S0e }, k0e = "https://json-schema.org/keyword/enum", _0e = (t) => bn(
  Oc(t),
  Zn(Pt),
  Zn(jg),
  lo
), C0e = (t, e) => {
  const r = jg(_r(e));
  return t.some((n) => r === n);
}, I0e = { id: k0e, compile: _0e, interpret: C0e }, B$ = "https://json-schema.org/keyword/examples", P0e = (t) => Pt(t), R0e = (t, e, r, n, i, s) => (Is(e, B$, s, t), !0), O0e = { id: B$, compile: P0e, interpret: R0e }, T0e = "https://json-schema.org/keyword/exclusiveMaximum", L0e = (t) => Pt(t), M0e = (t, e) => Wt(e) !== "number" || _r(e) < t, N0e = { id: T0e, compile: L0e, interpret: M0e }, D0e = "https://json-schema.org/keyword/exclusiveMinimum", $0e = (t) => Pt(t), j0e = (t, e) => Wt(e) !== "number" || _r(e) > t, B0e = { id: D0e, compile: $0e, interpret: j0e }, F$ = "https://json-schema.org/keyword/format", F0e = (t) => Pt(t), z0e = (t, e, r, n, i, s) => (Is(e, F$, s, t), !0), V0e = { id: F$, compile: F0e, interpret: z0e }, U0e = { id: "https://json-schema.org/keyword/id" }, H0e = "https://json-schema.org/keyword/if", G0e = (t, e) => We.compile(t, e), W0e = (t, e, r, n) => (We.interpret(t, e, r, n, !0), !0), q0e = (t, e, r, n) => We.collectEvaluatedProperties(t, e, r, n) || [], Q0e = (t, e, r, n) => We.collectEvaluatedItems(t, e, r, n) || /* @__PURE__ */ new Set(), K0e = { id: H0e, compile: G0e, interpret: W0e, collectEvaluatedProperties: q0e, collectEvaluatedItems: Q0e }, Y0e = () => {
  const t = gs(!1), e = gs(!0);
  return In(t, e), { start: t, end: e };
}, Z0e = (t) => {
  const e = gs(!1), r = gs(!0);
  return nge(e, r, t), { start: e, end: r };
}, J0e = (t, e) => t === void 0 ? e : (In(t.end, e.start), t.end.isEnd = !1, { start: t.start, end: e.end }), X0e = (t, e) => {
  const r = gs(!1);
  In(r, t.start), In(r, e.start);
  const n = gs(!0);
  return In(t.end, n), t.end.isEnd = !1, In(e.end, n), e.end.isEnd = !1, { start: r, end: n };
}, ege = (t) => {
  const e = gs(!1), r = gs(!0);
  return In(e, r), In(e, t.start), In(t.end, r), In(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, tge = (t) => {
  const e = gs(!1), r = gs(!0);
  return In(e, r), In(e, t.start), In(t.end, r), t.end.isEnd = !1, { start: e, end: r };
}, rge = (t) => {
  const e = gs(!1), r = gs(!0);
  return In(e, t.start), In(t.end, r), In(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, In = (t, e) => {
  t.epsilonTransitions.push(e);
}, nge = (t, e, r) => {
  t.transition[r] = e;
}, gs = (t) => ({
  isEnd: t,
  transition: {},
  epsilonTransitions: []
}), ige = "https://json-schema.org/keyword/itemPattern", z$ = async (t, e) => {
  const r = [[]];
  let n = r[0];
  for await (const i of Oc(t))
    if (Na(i) === "string") {
      const s = Pt(i);
      if (s === "*")
        n.push(ege(n.pop()));
      else if (s === "?")
        n.push(tge(n.pop()));
      else if (s === "+")
        n.push(rge(n.pop()));
      else if (s === "|")
        n = [], r.push(n);
      else
        throw Error(`Unsupported pattern syntax: ${s}`);
    } else {
      const s = Na(i) === "array" ? z$(i, e) : Z0e(await We.compile(i, e));
      n.push(await s);
    }
  return E$(t) === 0 ? Y0e() : r.map((i) => i.reduce(J0e)).reduce(X0e);
}, pS = (t) => (e, r, n, i, s) => {
  if (Wt(r) !== "array")
    return !0;
  let o = [];
  f4(e.start, o, []);
  for (const a of Bh(r)) {
    const l = [];
    for (const c of o) {
      const p = sge(t, c.transition, a, n, i, s);
      p && f4(p, l, []);
    }
    o = l;
  }
  return !!o.find((a) => a.isEnd);
}, f4 = (t, e, r) => {
  if (t.epsilonTransitions.length)
    for (const n of t.epsilonTransitions)
      r.find((i) => i === n) || (r.push(n), f4(n, e, r));
  else
    e.push(t);
}, sge = (t, e, r, n, i, s) => {
  for (const o in e)
    if (t(o, r, n, i, s))
      return e[o];
}, oge = pS(We.interpret), age = pS(We.collectEvaluatedProperties), lge = pS(We.collectEvaluatedItems), cge = { id: ige, compile: z$, interpret: oge, collectEvalatedProperties: age, collectEvalatedItems: lge }, uge = "https://json-schema.org/keyword/items", hge = async (t, e, r) => {
  const n = Xr(t.document.dialectId, "https://json-schema.org/keyword/prefixItems"), i = await Ks(n, r);
  return [Na(i) === "array" ? E$(i) : 0, await We.compile(t, e)];
}, V$ = ([t, e], r, n, i, s) => {
  if (Wt(r) !== "array")
    return !0;
  let o = !0;
  for (const a of Cde(t, Bh(r)))
    We.interpret(e, a, n, i, s) || (o = !1);
  return o;
}, pge = (t, e, r, n) => {
  if (!V$(t, e, r, n, !0))
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (let s = t[0]; s < $g(e); s++)
    i.add(s);
  return i;
}, dge = { id: uge, compile: hge, interpret: V$, collectEvaluatedItems: pge }, fge = "https://json-schema.org/keyword/maxContains", gge = (t) => Pt(t), mge = () => !0, yge = { id: fge, compile: gge, interpret: mge }, bge = "https://json-schema.org/keyword/maxItems", vge = (t) => Pt(t), wge = (t, e) => Wt(e) !== "array" || $g(e) <= t, xge = { id: bge, compile: vge, interpret: wge }, Ege = "https://json-schema.org/keyword/maxLength", Sge = (t) => Pt(t), Age = (t, e) => Wt(e) !== "string" || [..._r(e)].length <= t, kge = { id: Ege, compile: Sge, interpret: Age }, _ge = "https://json-schema.org/keyword/maxProperties", Cge = (t) => Pt(t), Ige = (t, e) => Wt(e) !== "object" || [...uS(e)].length <= t, Pge = { id: _ge, compile: Cge, interpret: Ige }, Rge = "https://json-schema.org/keyword/maximum", Oge = (t) => Pt(t), Tge = (t, e) => Wt(e) !== "number" || _r(e) <= t, Lge = { id: Rge, compile: Oge, interpret: Tge }, Mge = "https://json-schema.org/keyword/minContains", Nge = (t) => Pt(t), Dge = () => !0, $ge = { id: Mge, compile: Nge, interpret: Dge }, jge = "https://json-schema.org/keyword/minItems", Bge = (t) => Pt(t), Fge = (t, e) => Wt(e) !== "array" || $g(e) >= t, zge = { id: jge, compile: Bge, interpret: Fge }, Vge = "https://json-schema.org/keyword/minLength", Uge = (t) => Pt(t), Hge = (t, e) => Wt(e) !== "string" || [..._r(e)].length >= t, Gge = { id: Vge, compile: Uge, interpret: Hge }, Wge = "https://json-schema.org/keyword/minProperties", qge = (t) => Pt(t), Qge = (t, e) => Wt(e) !== "object" || [...uS(e)].length >= t, Kge = { id: Wge, compile: qge, interpret: Qge }, Yge = "https://json-schema.org/keyword/minimum", Zge = (t) => Pt(t), Jge = (t, e) => Wt(e) !== "number" || _r(e) >= t, Xge = { id: Yge, compile: Zge, interpret: Jge }, eme = "https://json-schema.org/keyword/multipleOf", tme = (t) => Pt(t), rme = (t, e) => {
  if (Wt(e) !== "number")
    return !0;
  const r = _r(e) % t;
  return A_(0, r) || A_(t, r);
}, A_ = (t, e) => Math.abs(t - e) < 11920929e-14, nme = { id: eme, compile: tme, interpret: rme }, ime = "https://json-schema.org/keyword/not", sme = (...t) => We.compile(...t), ome = (...t) => !We.interpret(...t), ame = { id: ime, compile: sme, interpret: ome }, lme = "https://json-schema.org/keyword/oneOf", cme = (t, e) => bn(
  Oc(t),
  Zn((r) => We.compile(r, e)),
  lo
), ume = (t, e, r, n, i) => {
  let s = 0;
  for (const o of t)
    We.interpret(o, e, r, n, i) && s++;
  return s === 1;
}, hme = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = We.collectEvaluatedProperties(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, pme = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = We.collectEvaluatedItems(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, dme = { id: lme, compile: cme, interpret: ume, collectEvaluatedProperties: hme, collectEvaluatedItems: pme }, fme = "https://json-schema.org/keyword/pattern", gme = (t) => new RegExp(Pt(t), "u"), mme = (t, e) => Wt(e) !== "string" || t.test(_r(e)), yme = { id: fme, compile: gme, interpret: mme }, bme = "https://json-schema.org/keyword/patternProperties", vme = (t, e) => bn(
  bh(t),
  Zn(async ([r, n]) => [
    new RegExp(r, "u"),
    await We.compile(n, e)
  ]),
  lo
), wme = (t, e, r, n, i) => {
  if (Wt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    for (const [l, c] of Tc(e)) {
      const p = _r(l);
      o.test(p) && !We.interpret(a, c, r, n, i) && (s = !1);
    }
  return s;
}, xme = (t, e, r, n) => {
  if (Wt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    for (const [a, l] of Tc(e)) {
      const c = _r(a);
      if (s.test(c)) {
        if (!We.interpret(o, l, r, n, !0))
          return !1;
        i.add(c);
      }
    }
  return i;
}, Eme = { id: bme, compile: vme, interpret: wme, collectEvaluatedProperties: xme }, Sme = "https://json-schema.org/keyword/prefixItems", Ame = (t, e) => bn(
  Oc(t),
  Zn((r) => We.compile(r, e)),
  lo
), U$ = (t, e, r, n, i) => {
  if (Wt(e) !== "array")
    return !0;
  let s = !0, o = 0;
  const a = $g(e);
  for (const [l, c] of cS(t, Bh(e))) {
    if (o >= a)
      break;
    We.interpret(l, c, r, n, i) || (s = !1), o++;
  }
  return s;
}, kme = (t, e, r, n) => U$(t, e, r, n, !0) && new Set(t.map((i, s) => s)), _me = { id: Sme, compile: Ame, interpret: U$, collectEvaluatedItems: kme }, Cme = "https://json-schema.org/keyword/properties", Ime = (t, e) => bn(
  bh(t),
  Zn(async ([r, n]) => [r, await We.compile(n, e)]),
  p4
), Pme = (t, e, r, n, i) => {
  if (Wt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of Tc(e)) {
    const l = _r(o);
    l in t && !We.interpret(t[l], a, r, n, i) && (s = !1);
  }
  return s;
}, Rme = (t, e, r, n) => {
  if (Wt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of Tc(e)) {
    const a = _r(s);
    if (a in t) {
      if (!We.interpret(t[a], o, r, n, !0))
        return !1;
      i.add(a);
    }
  }
  return i;
}, Ome = { id: Cme, compile: Ime, interpret: Pme, collectEvaluatedProperties: Rme }, Tme = "https://json-schema.org/keyword/propertyDependencies", Lme = (t, e) => bn(
  bh(t),
  Zn(async ([r, n]) => [r, await bn(
    bh(n),
    Zn(async ([i, s]) => [i, await We.compile(s, e)]),
    p4
  )]),
  p4
), Mme = (t, e, r, n, i) => {
  if (Wt(e) !== "object")
    return !0;
  let s = !0;
  const o = _r(e);
  for (const [a, l] of Object.entries(t)) {
    const c = o[a];
    Zp(a, e) && c in l && !We.interpret(l[c], e, r, n, i) && (s = !1);
  }
  return s;
}, Nme = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s in t) {
    const o = _r(e)[s], a = t[s];
    if (Zp(s, e) && o in a) {
      const l = We.collectEvaluatedProperties(a[o], e, r, n);
      if (!l)
        return !1;
      l.forEach(i.add, i);
    }
  }
  return i;
}, Dme = { id: Tme, compile: Lme, interpret: Mme, collectEvaluatedProperties: Nme }, $me = "https://json-schema.org/keyword/propertyNames", jme = (t, e) => We.compile(t, e), Bme = (t, e, r, n) => {
  if (Wt(e) !== "object")
    return !0;
  let i = !0;
  for (const s of uS(e))
    We.interpret(t, s, r, n, !0) || (i = !1);
  return i;
}, Fme = { id: $me, compile: jme, interpret: Bme }, H$ = "https://json-schema.org/keyword/readOnly", zme = (t) => Pt(t), Vme = (t, e, r, n, i, s) => (Is(e, H$, s, t), !0), Ume = { id: H$, compile: zme, interpret: Vme }, Hme = "https://json-schema.org/keyword/ref", Gme = (...t) => We.compile(...t), Wme = (...t) => We.interpret(...t), qme = (...t) => We.collectEvaluatedProperties(...t), Qme = (...t) => We.collectEvaluatedItems(...t), Kme = { id: Hme, compile: Gme, interpret: Wme, collectEvaluatedProperties: qme, collectEvaluatedItems: Qme }, Yme = "https://json-schema.org/keyword/requireAllExcept", Zme = async (t, e, r) => {
  const n = await Pt(t), i = Xr(t.document.dialectId, "https://json-schema.org/keyword/properties"), s = await Ks(i, r), o = Na(s) === "object" ? u4(s) : [], a = new Set(o);
  return n.forEach((l) => o.remove(l)), [...a];
}, Jme = (t, e) => Wt(e) !== "object" || t.every((r) => Object.hasOwn(_r(e), r)), Xme = { id: Yme, compile: Zme, interpret: Jme }, e1e = "https://json-schema.org/keyword/required", t1e = (t) => Pt(t), r1e = (t, e) => Wt(e) !== "object" || t.every((r) => Object.hasOwn(_r(e), r)), n1e = { id: e1e, compile: t1e, interpret: r1e }, G$ = "https://json-schema.org/keyword/title", i1e = (t) => Pt(t), s1e = (t, e, r, n, i, s) => (Is(e, G$, s, t), !0), o1e = { id: G$, compile: i1e, interpret: s1e }, a1e = "https://json-schema.org/keyword/then", l1e = async (t, e, r) => {
  const n = Xr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (x$(n, r)) {
    const i = await Ks(n, r);
    return [await We.compile(i, e), await We.compile(t, e)];
  } else
    return [];
}, c1e = ([t, e], r, n, i, s) => t === void 0 || !We.interpret(t, r, n, i, !0) || We.interpret(e, r, n, i, s), u1e = ([t, e], r, n, i) => t === void 0 || !We.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : We.collectEvaluatedProperties(e, r, n, i), h1e = ([t, e], r, n, i) => t === void 0 || !We.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : We.collectEvaluatedItems(e, r, n, i), p1e = { id: a1e, compile: l1e, interpret: c1e, collectEvaluatedProperties: u1e, collectEvaluatedItems: h1e }, d1e = "https://json-schema.org/keyword/type", f1e = (t) => Pt(t), g1e = (t, e) => typeof t == "string" ? k_(e)(t) : t.some(k_(e)), k_ = (t) => (e) => e === "integer" ? Wt(t) === "number" && Number.isInteger(_r(t)) : Wt(t) === e, m1e = { id: d1e, compile: f1e, interpret: g1e }, y1e = "https://json-schema.org/keyword/unevaluatedItems", b1e = async (t, e, r) => [Yp(r), await We.compile(t, e)], v1e = ([t, e], r, n, i, s) => {
  if (Wt(r) !== "array")
    return !0;
  const o = We.collectEvaluatedItems(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of cS(Bh(r), k$(0)))
    !o.has(c) && !We.interpret(e, l, n, i, s) && (a = !1);
  return a;
}, w1e = (t, e, r, n) => {
  const i = We.collectEvaluatedItems(t[0], e, r, n, !0);
  if (!i)
    return !1;
  const s = /* @__PURE__ */ new Set();
  for (let o = 0; o < $g(e); o++)
    i.has(o) || s.add(o);
  return s;
}, x1e = { id: y1e, compile: b1e, interpret: v1e, collectEvaluatedItems: w1e }, E1e = "https://json-schema.org/keyword/unevaluatedProperties", S1e = async (t, e, r) => [Yp(r), await We.compile(t, e)], A1e = ([t, e], r, n, i, s) => {
  if (Wt(r) !== "object")
    return !0;
  const o = We.collectEvaluatedProperties(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of Tc(r)) {
    const p = _r(l);
    !o.has(p) && !We.interpret(e, c, n, i, s) && (a = !1);
  }
  return a;
}, k1e = ([t, e], r, n, i) => {
  if (Wt(r) !== "object")
    return !0;
  const s = We.collectEvaluatedProperties(t, r, n, i, !0);
  if (!s)
    return !1;
  for (const [o, a] of Tc(r)) {
    const l = _r(o);
    if (!s.has(l)) {
      if (!We.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, _1e = { id: E1e, compile: S1e, interpret: A1e, collectEvaluatedProperties: k1e }, C1e = "https://json-schema.org/keyword/uniqueItems", I1e = (t) => Pt(t), P1e = (t, e) => {
  if (Wt(e) !== "array" || t === !1)
    return !0;
  const r = _r(e).map(jg);
  return new Set(r).size === r.length;
}, R1e = { id: C1e, compile: I1e, interpret: P1e }, W$ = "https://json-schema.org/keyword/unknown", O1e = (t) => [[...o4(t.cursor)].pop(), Pt(t)], T1e = ([t, e], r, n, i, s, o) => {
  const a = `${W$}#${t}`;
  return Is(r, a, o, e), !0;
}, L1e = { id: W$, compile: O1e, interpret: T1e }, M1e = { id: "https://json-schema.org/keyword/vocabulary" }, q$ = "https://json-schema.org/keyword/writeOnly", N1e = (t) => Pt(t), D1e = (t, e, r, n, i, s) => (Is(e, q$, s, t), !0), $1e = { id: q$, compile: N1e, interpret: D1e };
g$("application/schema+json", kde);
ct(efe);
ct(ofe);
ct(afe);
ct(dfe);
ct(vfe);
ct(_fe);
ct(Rfe);
ct(Mfe);
ct($fe);
ct(Ffe);
ct(Ufe);
ct(Wfe);
ct(Yfe);
ct(e0e);
ct(s0e);
ct(l0e);
ct(h0e);
ct(p0e);
ct(b0e);
ct(A0e);
ct(I0e);
ct(O0e);
ct(N0e);
ct(B0e);
ct(V0e);
ct(U0e);
ct(K0e);
ct(cge);
ct(dge);
ct(yge);
ct(xge);
ct(kge);
ct(Pge);
ct(Lge);
ct($ge);
ct(zge);
ct(Gge);
ct(Kge);
ct(Xge);
ct(nme);
ct(ame);
ct(dme);
ct(yme);
ct(Eme);
ct(_me);
ct(Ome);
ct(Dme);
ct(Fme);
ct(Ume);
ct(Kme);
ct(Xme);
ct(n1e);
ct(o1e);
ct(p1e);
ct(m1e);
ct(x1e);
ct(_1e);
ct(R1e);
ct(L1e);
ct(M1e);
ct($1e);
const j1e = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://json-schema.org/draft/2020-12/schema",
  $vocabulary: {
    "https://json-schema.org/draft/2020-12/vocab/core": !0,
    "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
    "https://json-schema.org/draft/2020-12/vocab/validation": !0,
    "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
    "https://json-schema.org/draft/2020-12/vocab/content": !0
  },
  $dynamicAnchor: "meta",
  title: "Core and Validation specifications meta-schema",
  allOf: [
    { $ref: "meta/core" },
    { $ref: "meta/applicator" },
    { $ref: "meta/unevaluated" },
    { $ref: "meta/validation" },
    { $ref: "meta/meta-data" },
    { $ref: "meta/format-annotation" },
    { $ref: "meta/content" }
  ],
  type: ["object", "boolean"],
  properties: {
    definitions: {
      $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    dependencies: {
      $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
      type: "object",
      additionalProperties: {
        anyOf: [
          { $dynamicRef: "#meta" },
          { $ref: "meta/validation#/$defs/stringArray" }
        ]
      }
    }
  }
}, B1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/core",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Core vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    $id: {
      type: "string",
      format: "uri-reference",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $anchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicRef: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicAnchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        type: "string",
        format: "uri"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    }
  }
}, F1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/applicator",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    prefixItems: { $ref: "#/$defs/schemaArray" },
    items: { $dynamicRef: "#meta" },
    contains: { $dynamicRef: "#meta" },
    additionalProperties: { $dynamicRef: "#meta" },
    properties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      propertyNames: { format: "regex" },
      default: {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      }
    },
    propertyNames: { $dynamicRef: "#meta" },
    if: { $dynamicRef: "#meta" },
    then: { $dynamicRef: "#meta" },
    else: { $dynamicRef: "#meta" },
    allOf: { $ref: "#/$defs/schemaArray" },
    anyOf: { $ref: "#/$defs/schemaArray" },
    oneOf: { $ref: "#/$defs/schemaArray" },
    not: { $dynamicRef: "#meta" }
  },
  $defs: {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: { $dynamicRef: "#meta" }
    }
  }
}, z1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/validation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Validation vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: { $ref: "#/$defs/nonNegativeInteger" },
    minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: { $ref: "#/$defs/nonNegativeInteger" },
    minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    uniqueItems: {
      type: "boolean",
      default: !1
    },
    maxContains: { $ref: "#/$defs/nonNegativeInteger" },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 1
    },
    maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
    minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    required: { $ref: "#/$defs/stringArray" },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    },
    const: !0,
    enum: {
      type: "array",
      items: !0
    },
    type: {
      anyOf: [
        { $ref: "#/$defs/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/$defs/simpleTypes" },
          minItems: 1,
          uniqueItems: !0
        }
      ]
    }
  },
  $defs: {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 0
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: []
    }
  }
}, V1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Meta-data vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    default: !0,
    deprecated: {
      type: "boolean",
      default: !1
    },
    readOnly: {
      type: "boolean",
      default: !1
    },
    writeOnly: {
      type: "boolean",
      default: !1
    },
    examples: {
      type: "array",
      items: !0
    }
  }
}, U1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for annotation results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, H1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-assertion",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for assertion results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, G1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/content",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Content vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    contentSchema: { $dynamicRef: "#meta" }
  }
}, W1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Unevaluated applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    unevaluatedItems: { $dynamicRef: "#meta" },
    unevaluatedProperties: { $dynamicRef: "#meta" }
  }
}, q1e = { id: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor" }, Q1e = "https://json-schema.org/keyword/draft-2020-12/dynamicRef", K1e = async (t, e) => {
  const r = u$(Pt(t)), n = await Ob(Pt(t), t);
  return await We.compile(n, e), [n.document.baseUri, r, Yp(n)];
}, dS = (t, [e, r, n], i, s, o, a) => r in s.metaData[e].dynamicAnchors ? (o = { ...s.metaData[e].dynamicAnchors, ...o }, t(o[r], i, s, o, a)) : t(n, i, s, o, a), Y1e = (...t) => dS(We.interpret, ...t), Z1e = (...t) => dS(We.collectEvaluatedProperties, ...t), J1e = (...t) => dS(We.collectEvaluatedItems, ...t), X1e = { id: Q1e, compile: K1e, interpret: Y1e, collectEvaluatedProperties: Z1e, collectEvaluatedItems: J1e };
ct(X1e);
ct(q1e);
Rc("https://json-schema.org/draft/2020-12/vocab/core", {
  $anchor: "https://json-schema.org/keyword/anchor",
  $comment: "https://json-schema.org/keyword/comment",
  $defs: "https://json-schema.org/keyword/definitions",
  $dynamicAnchor: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor",
  $dynamicRef: "https://json-schema.org/keyword/draft-2020-12/dynamicRef",
  $id: "https://json-schema.org/keyword/id",
  $ref: "https://json-schema.org/keyword/ref",
  $vocabulary: "https://json-schema.org/keyword/vocabulary"
});
Rc("https://json-schema.org/draft/2020-12/vocab/applicator", {
  additionalProperties: "https://json-schema.org/keyword/additionalProperties",
  allOf: "https://json-schema.org/keyword/allOf",
  anyOf: "https://json-schema.org/keyword/anyOf",
  contains: "https://json-schema.org/keyword/contains",
  dependentSchemas: "https://json-schema.org/keyword/dependentSchemas",
  if: "https://json-schema.org/keyword/if",
  then: "https://json-schema.org/keyword/then",
  else: "https://json-schema.org/keyword/else",
  items: "https://json-schema.org/keyword/items",
  not: "https://json-schema.org/keyword/not",
  oneOf: "https://json-schema.org/keyword/oneOf",
  patternProperties: "https://json-schema.org/keyword/patternProperties",
  prefixItems: "https://json-schema.org/keyword/prefixItems",
  properties: "https://json-schema.org/keyword/properties",
  propertyNames: "https://json-schema.org/keyword/propertyNames"
});
Rc("https://json-schema.org/draft/2020-12/vocab/validation", {
  const: "https://json-schema.org/keyword/const",
  dependentRequired: "https://json-schema.org/keyword/dependentRequired",
  enum: "https://json-schema.org/keyword/enum",
  exclusiveMaximum: "https://json-schema.org/keyword/exclusiveMaximum",
  exclusiveMinimum: "https://json-schema.org/keyword/exclusiveMinimum",
  maxContains: "https://json-schema.org/keyword/maxContains",
  maxItems: "https://json-schema.org/keyword/maxItems",
  maxLength: "https://json-schema.org/keyword/maxLength",
  maxProperties: "https://json-schema.org/keyword/maxProperties",
  maximum: "https://json-schema.org/keyword/maximum",
  minContains: "https://json-schema.org/keyword/minContains",
  minItems: "https://json-schema.org/keyword/minItems",
  minLength: "https://json-schema.org/keyword/minLength",
  minProperties: "https://json-schema.org/keyword/minProperties",
  minimum: "https://json-schema.org/keyword/minimum",
  multipleOf: "https://json-schema.org/keyword/multipleOf",
  pattern: "https://json-schema.org/keyword/pattern",
  required: "https://json-schema.org/keyword/required",
  type: "https://json-schema.org/keyword/type",
  uniqueItems: "https://json-schema.org/keyword/uniqueItems"
});
Rc("https://json-schema.org/draft/2020-12/vocab/meta-data", {
  default: "https://json-schema.org/keyword/default",
  deprecated: "https://json-schema.org/keyword/deprecated",
  description: "https://json-schema.org/keyword/description",
  examples: "https://json-schema.org/keyword/examples",
  readOnly: "https://json-schema.org/keyword/readOnly",
  title: "https://json-schema.org/keyword/title",
  writeOnly: "https://json-schema.org/keyword/writeOnly"
});
Rc("https://json-schema.org/draft/2020-12/vocab/format-annotation", {
  format: "https://json-schema.org/keyword/format"
});
Rc("https://json-schema.org/draft/2020-12/vocab/format-assertion", {
  format: "https://json-schema.org/keyword/format-assertion"
});
Rc("https://json-schema.org/draft/2020-12/vocab/content", {
  contentEncoding: "https://json-schema.org/keyword/contentEncoding",
  contentMediaType: "https://json-schema.org/keyword/contentMediaType",
  contentSchema: "https://json-schema.org/keyword/contentSchema"
});
Rc("https://json-schema.org/draft/2020-12/vocab/unevaluated", {
  unevaluatedItems: "https://json-schema.org/keyword/unevaluatedItems",
  unevaluatedProperties: "https://json-schema.org/keyword/unevaluatedProperties"
});
p$("https://json-schema.org/draft/2020-12/schema", {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, !0);
Ya(j1e);
Ya(B1e);
Ya(F1e);
Ya(z1e);
Ya(V1e);
Ya(U1e);
Ya(H1e);
Ya(G1e);
Ya(W1e);
function Fm(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var __ = { exports: {} };
/*! jsonpath 1.1.1 */
var C_;
function eye() {
  return C_ || (C_ = 1, function(t, e) {
    (function(r) {
      t.exports = r();
    })(function() {
      return function r(n, i, s) {
        function o(c, p) {
          if (!i[c]) {
            if (!n[c]) {
              var h = typeof Fm == "function" && Fm;
              if (!p && h) return h(c, !0);
              if (a) return a(c, !0);
              var d = new Error("Cannot find module '" + c + "'");
              throw d.code = "MODULE_NOT_FOUND", d;
            }
            var b = i[c] = { exports: {} };
            n[c][0].call(b.exports, function(m) {
              var w = n[c][1][m];
              return o(w || m);
            }, b, b.exports, r, n, i, s);
          }
          return i[c].exports;
        }
        for (var a = typeof Fm == "function" && Fm, l = 0; l < s.length; l++) o(s[l]);
        return o;
      }({ "./aesprim": [function(r, n, i) {
        (function(s, o) {
          o(typeof i < "u" ? i : s.esprima = {});
        })(this, function(s) {
          var o, a, l, c, p, h, d, b, m, w, f, E, A, x, g, v, k, S;
          o = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
          }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
            "(",
            "{",
            "[",
            "in",
            "typeof",
            "instanceof",
            "new",
            "return",
            "case",
            "delete",
            "throw",
            "void",
            // assignment operators
            "=",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "<<=",
            ">>=",
            ">>>=",
            "&=",
            "|=",
            "^=",
            ",",
            // binary/unary operators
            "+",
            "-",
            "*",
            "/",
            "%",
            "++",
            "--",
            "<<",
            ">>",
            ">>>",
            "&",
            "|",
            "^",
            "!",
            "~",
            "&&",
            "||",
            "?",
            ":",
            "===",
            "==",
            ">=",
            "<=",
            "<",
            ">",
            "!=",
            "!=="
          ], c = {
            AssignmentExpression: "AssignmentExpression",
            ArrayExpression: "ArrayExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            Program: "Program",
            Property: "Property",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SwitchStatement: "SwitchStatement",
            SwitchCase: "SwitchCase",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement"
          }, p = {
            Data: 1,
            Get: 2,
            Set: 4
          }, h = {
            UnexpectedToken: "Unexpected token %0",
            UnexpectedNumber: "Unexpected number",
            UnexpectedString: "Unexpected string",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedEOS: "Unexpected end of input",
            NewlineAfterThrow: "Illegal newline after throw",
            InvalidRegExp: "Invalid regular expression",
            UnterminatedRegExp: "Invalid regular expression: missing /",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NoCatchOrFinally: "Missing catch or finally after try",
            UnknownLabel: "Undefined label '%0'",
            Redeclaration: "%0 '%1' has already been declared",
            IllegalContinue: "Illegal continue statement",
            IllegalBreak: "Illegal break statement",
            IllegalReturn: "Illegal return statement",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
            AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
            AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode"
          }, d = {
            NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
            NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
          };
          function R(u, y) {
            if (!u)
              throw new Error("ASSERT: " + y);
          }
          function L(u) {
            return u >= 48 && u <= 57;
          }
          function F(u) {
            return "0123456789abcdefABCDEF".indexOf(u) >= 0;
          }
          function z(u) {
            return "01234567".indexOf(u) >= 0;
          }
          function j(u) {
            return u === 32 || u === 9 || u === 11 || u === 12 || u === 160 || u >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(u) >= 0;
          }
          function ee(u) {
            return u === 10 || u === 13 || u === 8232 || u === 8233;
          }
          function X(u) {
            return u == 64 || u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierStart.test(String.fromCharCode(u));
          }
          function ie(u) {
            return u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u >= 48 && u <= 57 || // 0..9
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierPart.test(String.fromCharCode(u));
          }
          function ce(u) {
            switch (u) {
              case "class":
              case "enum":
              case "export":
              case "extends":
              case "import":
              case "super":
                return !0;
              default:
                return !1;
            }
          }
          function ke(u) {
            switch (u) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return !0;
              default:
                return !1;
            }
          }
          function ye(u) {
            return u === "eval" || u === "arguments";
          }
          function Ce(u) {
            if (w && ke(u))
              return !0;
            switch (u.length) {
              case 2:
                return u === "if" || u === "in" || u === "do";
              case 3:
                return u === "var" || u === "for" || u === "new" || u === "try" || u === "let";
              case 4:
                return u === "this" || u === "else" || u === "case" || u === "void" || u === "with" || u === "enum";
              case 5:
                return u === "while" || u === "break" || u === "catch" || u === "throw" || u === "const" || u === "yield" || u === "class" || u === "super";
              case 6:
                return u === "return" || u === "typeof" || u === "delete" || u === "switch" || u === "export" || u === "import";
              case 7:
                return u === "default" || u === "finally" || u === "extends";
              case 8:
                return u === "function" || u === "continue" || u === "debugger";
              case 10:
                return u === "instanceof";
              default:
                return !1;
            }
          }
          function Ie(u, y, _, T, U) {
            var ne;
            R(typeof _ == "number", "Comment must have valid position"), !(k.lastCommentStart >= _) && (k.lastCommentStart = _, ne = {
              type: u,
              value: y
            }, S.range && (ne.range = [_, T]), S.loc && (ne.loc = U), S.comments.push(ne), S.attachComment && (S.leadingComments.push(ne), S.trailingComments.push(ne)));
          }
          function Te(u) {
            var y, _, T, U;
            for (y = f - u, _ = {
              start: {
                line: E,
                column: f - A - u
              }
            }; f < x; )
              if (T = m.charCodeAt(f), ++f, ee(T)) {
                S.comments && (U = m.slice(y + u, f - 1), _.end = {
                  line: E,
                  column: f - A - 1
                }, Ie("Line", U, y, f - 1, _)), T === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f;
                return;
              }
            S.comments && (U = m.slice(y + u, f), _.end = {
              line: E,
              column: f - A
            }, Ie("Line", U, y, f, _));
          }
          function ue() {
            var u, y, _, T;
            for (S.comments && (u = f - 2, y = {
              start: {
                line: E,
                column: f - A - 2
              }
            }); f < x; )
              if (_ = m.charCodeAt(f), ee(_))
                _ === 13 && m.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && ge({}, h.UnexpectedToken, "ILLEGAL");
              else if (_ === 42) {
                if (m.charCodeAt(f + 1) === 47) {
                  ++f, ++f, S.comments && (T = m.slice(u + 2, f - 2), y.end = {
                    line: E,
                    column: f - A
                  }, Ie("Block", T, u, f, y));
                  return;
                }
                ++f;
              } else
                ++f;
            ge({}, h.UnexpectedToken, "ILLEGAL");
          }
          function O() {
            var u, y;
            for (y = f === 0; f < x; )
              if (u = m.charCodeAt(f), j(u))
                ++f;
              else if (ee(u))
                ++f, u === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f, y = !0;
              else if (u === 47)
                if (u = m.charCodeAt(f + 1), u === 47)
                  ++f, ++f, Te(2), y = !0;
                else if (u === 42)
                  ++f, ++f, ue();
                else
                  break;
              else if (y && u === 45)
                if (m.charCodeAt(f + 1) === 45 && m.charCodeAt(f + 2) === 62)
                  f += 3, Te(3);
                else
                  break;
              else if (u === 60)
                if (m.slice(f + 1, f + 4) === "!--")
                  ++f, ++f, ++f, ++f, Te(4);
                else
                  break;
              else
                break;
          }
          function N(u) {
            var y, _, T, U = 0;
            for (_ = u === "u" ? 4 : 2, y = 0; y < _; ++y)
              if (f < x && F(m[f]))
                T = m[f++], U = U * 16 + "0123456789abcdef".indexOf(T.toLowerCase());
              else
                return "";
            return String.fromCharCode(U);
          }
          function Z() {
            var u, y;
            for (u = m.charCodeAt(f++), y = String.fromCharCode(u), u === 92 && (m.charCodeAt(f) !== 117 && ge({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !X(u.charCodeAt(0))) && ge({}, h.UnexpectedToken, "ILLEGAL"), y = u); f < x && (u = m.charCodeAt(f), !!ie(u)); )
              ++f, y += String.fromCharCode(u), u === 92 && (y = y.substr(0, y.length - 1), m.charCodeAt(f) !== 117 && ge({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !ie(u.charCodeAt(0))) && ge({}, h.UnexpectedToken, "ILLEGAL"), y += u);
            return y;
          }
          function re() {
            var u, y;
            for (u = f++; f < x; ) {
              if (y = m.charCodeAt(f), y === 92)
                return f = u, Z();
              if (ie(y))
                ++f;
              else
                break;
            }
            return m.slice(u, f);
          }
          function le() {
            var u, y, _;
            return u = f, y = m.charCodeAt(f) === 92 ? Z() : re(), y.length === 1 ? _ = o.Identifier : Ce(y) ? _ = o.Keyword : y === "null" ? _ = o.NullLiteral : y === "true" || y === "false" ? _ = o.BooleanLiteral : _ = o.Identifier, {
              type: _,
              value: y,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function te() {
            var u = f, y = m.charCodeAt(f), _, T = m[f], U, ne, _e;
            switch (y) {
              case 46:
              case 40:
              case 41:
              case 59:
              case 44:
              case 123:
              case 125:
              case 91:
              case 93:
              case 58:
              case 63:
              case 126:
                return ++f, S.tokenize && (y === 40 ? S.openParenToken = S.tokens.length : y === 123 && (S.openCurlyToken = S.tokens.length)), {
                  type: o.Punctuator,
                  value: String.fromCharCode(y),
                  lineNumber: E,
                  lineStart: A,
                  start: u,
                  end: f
                };
              default:
                if (_ = m.charCodeAt(f + 1), _ === 61)
                  switch (y) {
                    case 43:
                    case 45:
                    case 47:
                    case 60:
                    case 62:
                    case 94:
                    case 124:
                    case 37:
                    case 38:
                    case 42:
                      return f += 2, {
                        type: o.Punctuator,
                        value: String.fromCharCode(y) + String.fromCharCode(_),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                    case 33:
                    case 61:
                      return f += 2, m.charCodeAt(f) === 61 && ++f, {
                        type: o.Punctuator,
                        value: m.slice(u, f),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                  }
            }
            if (_e = m.substr(f, 4), _e === ">>>=")
              return f += 4, {
                type: o.Punctuator,
                value: _e,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (ne = _e.substr(0, 3), ne === ">>>" || ne === "<<=" || ne === ">>=")
              return f += 3, {
                type: o.Punctuator,
                value: ne,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (U = ne.substr(0, 2), T === U[1] && "+-<>&|".indexOf(T) >= 0 || U === "=>")
              return f += 2, {
                type: o.Punctuator,
                value: U,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if ("<>=!+-*%&|^/".indexOf(T) >= 0)
              return ++f, {
                type: o.Punctuator,
                value: T,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            ge({}, h.UnexpectedToken, "ILLEGAL");
          }
          function oe(u) {
            for (var y = ""; f < x && F(m[f]); )
              y += m[f++];
            return y.length === 0 && ge({}, h.UnexpectedToken, "ILLEGAL"), X(m.charCodeAt(f)) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt("0x" + y, 16),
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function fe(u) {
            for (var y = "0" + m[f++]; f < x && z(m[f]); )
              y += m[f++];
            return (X(m.charCodeAt(f)) || L(m.charCodeAt(f))) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt(y, 8),
              octal: !0,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function H() {
            var u, y, _;
            if (_ = m[f], R(
              L(_.charCodeAt(0)) || _ === ".",
              "Numeric literal must start with a decimal digit or a decimal point"
            ), y = f, u = "", _ !== ".") {
              if (u = m[f++], _ = m[f], u === "0") {
                if (_ === "x" || _ === "X")
                  return ++f, oe(y);
                if (z(_))
                  return fe(y);
                _ && L(_.charCodeAt(0)) && ge({}, h.UnexpectedToken, "ILLEGAL");
              }
              for (; L(m.charCodeAt(f)); )
                u += m[f++];
              _ = m[f];
            }
            if (_ === ".") {
              for (u += m[f++]; L(m.charCodeAt(f)); )
                u += m[f++];
              _ = m[f];
            }
            if (_ === "e" || _ === "E")
              if (u += m[f++], _ = m[f], (_ === "+" || _ === "-") && (u += m[f++]), L(m.charCodeAt(f)))
                for (; L(m.charCodeAt(f)); )
                  u += m[f++];
              else
                ge({}, h.UnexpectedToken, "ILLEGAL");
            return X(m.charCodeAt(f)) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseFloat(u),
              lineNumber: E,
              lineStart: A,
              start: y,
              end: f
            };
          }
          function J() {
            var u = "", y, _, T, U, ne, _e, Ne = !1, et, Xe;
            for (et = E, Xe = A, y = m[f], R(
              y === "'" || y === '"',
              "String literal must starts with a quote"
            ), _ = f, ++f; f < x; )
              if (T = m[f++], T === y) {
                y = "";
                break;
              } else if (T === "\\")
                if (T = m[f++], !T || !ee(T.charCodeAt(0)))
                  switch (T) {
                    case "u":
                    case "x":
                      _e = f, ne = N(T), ne ? u += ne : (f = _e, u += T);
                      break;
                    case "n":
                      u += `
`;
                      break;
                    case "r":
                      u += "\r";
                      break;
                    case "t":
                      u += "	";
                      break;
                    case "b":
                      u += "\b";
                      break;
                    case "f":
                      u += "\f";
                      break;
                    case "v":
                      u += "\v";
                      break;
                    default:
                      z(T) ? (U = "01234567".indexOf(T), U !== 0 && (Ne = !0), f < x && z(m[f]) && (Ne = !0, U = U * 8 + "01234567".indexOf(m[f++]), "0123".indexOf(T) >= 0 && f < x && z(m[f]) && (U = U * 8 + "01234567".indexOf(m[f++]))), u += String.fromCharCode(U)) : u += T;
                      break;
                  }
                else
                  ++E, T === "\r" && m[f] === `
` && ++f, A = f;
              else {
                if (ee(T.charCodeAt(0)))
                  break;
                u += T;
              }
            return y !== "" && ge({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.StringLiteral,
              value: u,
              octal: Ne,
              startLineNumber: et,
              startLineStart: Xe,
              lineNumber: E,
              lineStart: A,
              start: _,
              end: f
            };
          }
          function Se(u, y) {
            var _;
            try {
              _ = new RegExp(u, y);
            } catch {
              ge({}, h.InvalidRegExp);
            }
            return _;
          }
          function Re() {
            var u, y, _, T, U;
            for (u = m[f], R(u === "/", "Regular expression literal must start with a slash"), y = m[f++], _ = !1, T = !1; f < x; )
              if (u = m[f++], y += u, u === "\\")
                u = m[f++], ee(u.charCodeAt(0)) && ge({}, h.UnterminatedRegExp), y += u;
              else if (ee(u.charCodeAt(0)))
                ge({}, h.UnterminatedRegExp);
              else if (_)
                u === "]" && (_ = !1);
              else if (u === "/") {
                T = !0;
                break;
              } else u === "[" && (_ = !0);
            return T || ge({}, h.UnterminatedRegExp), U = y.substr(1, y.length - 2), {
              value: U,
              literal: y
            };
          }
          function Fe() {
            var u, y, _, T;
            for (y = "", _ = ""; f < x && (u = m[f], !!ie(u.charCodeAt(0))); )
              if (++f, u === "\\" && f < x)
                if (u = m[f], u === "u") {
                  if (++f, T = f, u = N("u"), u)
                    for (_ += u, y += "\\u"; T < f; ++T)
                      y += m[T];
                  else
                    f = T, _ += "u", y += "\\u";
                  be({}, h.UnexpectedToken, "ILLEGAL");
                } else
                  y += "\\", be({}, h.UnexpectedToken, "ILLEGAL");
              else
                _ += u, y += u;
            return {
              value: _,
              literal: y
            };
          }
          function Le() {
            var u, y, _, T;
            return v = null, O(), u = f, y = Re(), _ = Fe(), T = Se(y.value, _.value), S.tokenize ? {
              type: o.RegularExpression,
              value: T,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            } : {
              literal: y.literal + _.literal,
              value: T,
              start: u,
              end: f
            };
          }
          function ze() {
            var u, y, _, T;
            return O(), u = f, y = {
              start: {
                line: E,
                column: f - A
              }
            }, _ = Le(), y.end = {
              line: E,
              column: f - A
            }, S.tokenize || (S.tokens.length > 0 && (T = S.tokens[S.tokens.length - 1], T.range[0] === u && T.type === "Punctuator" && (T.value === "/" || T.value === "/=") && S.tokens.pop()), S.tokens.push({
              type: "RegularExpression",
              value: _.literal,
              range: [u, f],
              loc: y
            })), _;
          }
          function tt(u) {
            return u.type === o.Identifier || u.type === o.Keyword || u.type === o.BooleanLiteral || u.type === o.NullLiteral;
          }
          function Pe() {
            var u, y;
            if (u = S.tokens[S.tokens.length - 1], !u)
              return ze();
            if (u.type === "Punctuator") {
              if (u.value === "]")
                return te();
              if (u.value === ")")
                return y = S.tokens[S.openParenToken - 1], y && y.type === "Keyword" && (y.value === "if" || y.value === "while" || y.value === "for" || y.value === "with") ? ze() : te();
              if (u.value === "}") {
                if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 4], !y)
                    return te();
                } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 5], !y)
                    return ze();
                } else
                  return te();
                return l.indexOf(y.value) >= 0 ? te() : ze();
              }
              return ze();
            }
            return u.type === "Keyword" ? ze() : te();
          }
          function At() {
            var u;
            return O(), f >= x ? {
              type: o.EOF,
              lineNumber: E,
              lineStart: A,
              start: f,
              end: f
            } : (u = m.charCodeAt(f), X(u) ? le() : u === 40 || u === 41 || u === 59 ? te() : u === 39 || u === 34 ? J() : u === 46 ? L(m.charCodeAt(f + 1)) ? H() : te() : L(u) ? H() : S.tokenize && u === 47 ? Pe() : te());
          }
          function er() {
            var u, y, _;
            return O(), u = {
              start: {
                line: E,
                column: f - A
              }
            }, y = At(), u.end = {
              line: E,
              column: f - A
            }, y.type !== o.EOF && (_ = m.slice(y.start, y.end), S.tokens.push({
              type: a[y.type],
              value: _,
              range: [y.start, y.end],
              loc: u
            })), y;
          }
          function me() {
            var u;
            return u = v, f = u.end, E = u.lineNumber, A = u.lineStart, v = typeof S.tokens < "u" ? er() : At(), f = u.end, E = u.lineNumber, A = u.lineStart, u;
          }
          function ht() {
            var u, y, _;
            u = f, y = E, _ = A, v = typeof S.tokens < "u" ? er() : At(), f = u, E = y, A = _;
          }
          function it(u, y) {
            this.line = u, this.column = y;
          }
          function kt(u, y, _, T) {
            this.start = new it(u, y), this.end = new it(_, T);
          }
          b = {
            name: "SyntaxTree",
            processComment: function(u) {
              var y, _;
              if (!(u.type === c.Program && u.body.length > 0)) {
                for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= u.range[1] ? (_ = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= u.range[1] && (_ = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= u.range[0]; )
                  y = S.bottomRightStack.pop();
                y ? y.leadingComments && y.leadingComments[y.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = y.leadingComments, delete y.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = S.leadingComments, S.leadingComments = []), _ && (u.trailingComments = _), S.bottomRightStack.push(u);
              }
            },
            markEnd: function(u, y) {
              return S.range && (u.range = [y.start, f]), S.loc && (u.loc = new kt(
                y.startLineNumber === void 0 ? y.lineNumber : y.startLineNumber,
                y.start - (y.startLineStart === void 0 ? y.lineStart : y.startLineStart),
                E,
                f - A
              ), this.postProcess(u)), S.attachComment && this.processComment(u), u;
            },
            postProcess: function(u) {
              return S.source && (u.loc.source = S.source), u;
            },
            createArrayExpression: function(u) {
              return {
                type: c.ArrayExpression,
                elements: u
              };
            },
            createAssignmentExpression: function(u, y, _) {
              return {
                type: c.AssignmentExpression,
                operator: u,
                left: y,
                right: _
              };
            },
            createBinaryExpression: function(u, y, _) {
              var T = u === "||" || u === "&&" ? c.LogicalExpression : c.BinaryExpression;
              return {
                type: T,
                operator: u,
                left: y,
                right: _
              };
            },
            createBlockStatement: function(u) {
              return {
                type: c.BlockStatement,
                body: u
              };
            },
            createBreakStatement: function(u) {
              return {
                type: c.BreakStatement,
                label: u
              };
            },
            createCallExpression: function(u, y) {
              return {
                type: c.CallExpression,
                callee: u,
                arguments: y
              };
            },
            createCatchClause: function(u, y) {
              return {
                type: c.CatchClause,
                param: u,
                body: y
              };
            },
            createConditionalExpression: function(u, y, _) {
              return {
                type: c.ConditionalExpression,
                test: u,
                consequent: y,
                alternate: _
              };
            },
            createContinueStatement: function(u) {
              return {
                type: c.ContinueStatement,
                label: u
              };
            },
            createDebuggerStatement: function() {
              return {
                type: c.DebuggerStatement
              };
            },
            createDoWhileStatement: function(u, y) {
              return {
                type: c.DoWhileStatement,
                body: u,
                test: y
              };
            },
            createEmptyStatement: function() {
              return {
                type: c.EmptyStatement
              };
            },
            createExpressionStatement: function(u) {
              return {
                type: c.ExpressionStatement,
                expression: u
              };
            },
            createForStatement: function(u, y, _, T) {
              return {
                type: c.ForStatement,
                init: u,
                test: y,
                update: _,
                body: T
              };
            },
            createForInStatement: function(u, y, _) {
              return {
                type: c.ForInStatement,
                left: u,
                right: y,
                body: _,
                each: !1
              };
            },
            createFunctionDeclaration: function(u, y, _, T) {
              return {
                type: c.FunctionDeclaration,
                id: u,
                params: y,
                defaults: _,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createFunctionExpression: function(u, y, _, T) {
              return {
                type: c.FunctionExpression,
                id: u,
                params: y,
                defaults: _,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createIdentifier: function(u) {
              return {
                type: c.Identifier,
                name: u
              };
            },
            createIfStatement: function(u, y, _) {
              return {
                type: c.IfStatement,
                test: u,
                consequent: y,
                alternate: _
              };
            },
            createLabeledStatement: function(u, y) {
              return {
                type: c.LabeledStatement,
                label: u,
                body: y
              };
            },
            createLiteral: function(u) {
              return {
                type: c.Literal,
                value: u.value,
                raw: m.slice(u.start, u.end)
              };
            },
            createMemberExpression: function(u, y, _) {
              return {
                type: c.MemberExpression,
                computed: u === "[",
                object: y,
                property: _
              };
            },
            createNewExpression: function(u, y) {
              return {
                type: c.NewExpression,
                callee: u,
                arguments: y
              };
            },
            createObjectExpression: function(u) {
              return {
                type: c.ObjectExpression,
                properties: u
              };
            },
            createPostfixExpression: function(u, y) {
              return {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !1
              };
            },
            createProgram: function(u) {
              return {
                type: c.Program,
                body: u
              };
            },
            createProperty: function(u, y, _) {
              return {
                type: c.Property,
                key: y,
                value: _,
                kind: u
              };
            },
            createReturnStatement: function(u) {
              return {
                type: c.ReturnStatement,
                argument: u
              };
            },
            createSequenceExpression: function(u) {
              return {
                type: c.SequenceExpression,
                expressions: u
              };
            },
            createSwitchCase: function(u, y) {
              return {
                type: c.SwitchCase,
                test: u,
                consequent: y
              };
            },
            createSwitchStatement: function(u, y) {
              return {
                type: c.SwitchStatement,
                discriminant: u,
                cases: y
              };
            },
            createThisExpression: function() {
              return {
                type: c.ThisExpression
              };
            },
            createThrowStatement: function(u) {
              return {
                type: c.ThrowStatement,
                argument: u
              };
            },
            createTryStatement: function(u, y, _, T) {
              return {
                type: c.TryStatement,
                block: u,
                guardedHandlers: y,
                handlers: _,
                finalizer: T
              };
            },
            createUnaryExpression: function(u, y) {
              return u === "++" || u === "--" ? {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !0
              } : {
                type: c.UnaryExpression,
                operator: u,
                argument: y,
                prefix: !0
              };
            },
            createVariableDeclaration: function(u, y) {
              return {
                type: c.VariableDeclaration,
                declarations: u,
                kind: y
              };
            },
            createVariableDeclarator: function(u, y) {
              return {
                type: c.VariableDeclarator,
                id: u,
                init: y
              };
            },
            createWhileStatement: function(u, y) {
              return {
                type: c.WhileStatement,
                test: u,
                body: y
              };
            },
            createWithStatement: function(u, y) {
              return {
                type: c.WithStatement,
                object: u,
                body: y
              };
            }
          };
          function Ze() {
            var u, y, _, T;
            return u = f, y = E, _ = A, O(), T = E !== y, f = u, E = y, A = _, T;
          }
          function ge(u, y) {
            var _, T = Array.prototype.slice.call(arguments, 2), U = y.replace(
              /%(\d)/g,
              function(ne, _e) {
                return R(_e < T.length, "Message reference must be in range"), T[_e];
              }
            );
            throw typeof u.lineNumber == "number" ? (_ = new Error("Line " + u.lineNumber + ": " + U), _.index = u.start, _.lineNumber = u.lineNumber, _.column = u.start - A + 1) : (_ = new Error("Line " + E + ": " + U), _.index = f, _.lineNumber = E, _.column = f - A + 1), _.description = U, _;
          }
          function be() {
            try {
              ge.apply(null, arguments);
            } catch (u) {
              if (S.errors)
                S.errors.push(u);
              else
                throw u;
            }
          }
          function Je(u) {
            if (u.type === o.EOF && ge(u, h.UnexpectedEOS), u.type === o.NumericLiteral && ge(u, h.UnexpectedNumber), u.type === o.StringLiteral && ge(u, h.UnexpectedString), u.type === o.Identifier && ge(u, h.UnexpectedIdentifier), u.type === o.Keyword) {
              if (ce(u.value))
                ge(u, h.UnexpectedReserved);
              else if (w && ke(u.value)) {
                be(u, h.StrictReservedWord);
                return;
              }
              ge(u, h.UnexpectedToken, u.value);
            }
            ge(u, h.UnexpectedToken, u.value);
          }
          function C(u) {
            var y = me();
            (y.type !== o.Punctuator || y.value !== u) && Je(y);
          }
          function $(u) {
            var y = me();
            (y.type !== o.Keyword || y.value !== u) && Je(y);
          }
          function D(u) {
            return v.type === o.Punctuator && v.value === u;
          }
          function ae(u) {
            return v.type === o.Keyword && v.value === u;
          }
          function pe() {
            var u;
            return v.type !== o.Punctuator ? !1 : (u = v.value, u === "=" || u === "*=" || u === "/=" || u === "%=" || u === "+=" || u === "-=" || u === "<<=" || u === ">>=" || u === ">>>=" || u === "&=" || u === "^=" || u === "|=");
          }
          function Ee() {
            var u;
            if (m.charCodeAt(f) === 59 || D(";")) {
              me();
              return;
            }
            u = E, O(), E === u && v.type !== o.EOF && !D("}") && Je(v);
          }
          function Me(u) {
            return u.type === c.Identifier || u.type === c.MemberExpression;
          }
          function ot() {
            var u = [], y;
            for (y = v, C("["); !D("]"); )
              D(",") ? (me(), u.push(null)) : (u.push(W()), D("]") || C(","));
            return me(), g.markEnd(g.createArrayExpression(u), y);
          }
          function dt(u, y) {
            var _, T, U;
            return _ = w, U = v, T = Un(), y && w && ye(u[0].name) && be(y, h.StrictParamName), w = _, g.markEnd(g.createFunctionExpression(null, u, [], T), U);
          }
          function St() {
            var u, y;
            return y = v, u = me(), u.type === o.StringLiteral || u.type === o.NumericLiteral ? (w && u.octal && be(u, h.StrictOctalLiteral), g.markEnd(g.createLiteral(u), y)) : g.markEnd(g.createIdentifier(u.value), y);
          }
          function rt() {
            var u, y, _, T, U, ne;
            if (u = v, ne = v, u.type === o.Identifier)
              return _ = St(), u.value === "get" && !D(":") ? (y = St(), C("("), C(")"), T = dt([]), g.markEnd(g.createProperty("get", y, T), ne)) : u.value === "set" && !D(":") ? (y = St(), C("("), u = v, u.type !== o.Identifier ? (C(")"), be(u, h.UnexpectedToken, u.value), T = dt([])) : (U = [he()], C(")"), T = dt(U, u)), g.markEnd(g.createProperty("set", y, T), ne)) : (C(":"), T = W(), g.markEnd(g.createProperty("init", _, T), ne));
            if (u.type === o.EOF || u.type === o.Punctuator)
              Je(u);
            else
              return y = St(), C(":"), T = W(), g.markEnd(g.createProperty("init", y, T), ne);
          }
          function zt() {
            var u = [], y, _, T, U, ne = {}, _e = String, Ne;
            for (Ne = v, C("{"); !D("}"); )
              y = rt(), y.key.type === c.Identifier ? _ = y.key.name : _ = _e(y.key.value), U = y.kind === "init" ? p.Data : y.kind === "get" ? p.Get : p.Set, T = "$" + _, Object.prototype.hasOwnProperty.call(ne, T) ? (ne[T] === p.Data ? w && U === p.Data ? be({}, h.StrictDuplicateProperty) : U !== p.Data && be({}, h.AccessorDataProperty) : U === p.Data ? be({}, h.AccessorDataProperty) : ne[T] & U && be({}, h.AccessorGetSet), ne[T] |= U) : ne[T] = U, u.push(y), D("}") || C(",");
            return C("}"), g.markEnd(g.createObjectExpression(u), Ne);
          }
          function Xt() {
            var u;
            return C("("), u = G(), C(")"), u;
          }
          function tr() {
            var u, y, _, T;
            if (D("("))
              return Xt();
            if (D("["))
              return ot();
            if (D("{"))
              return zt();
            if (u = v.type, T = v, u === o.Identifier)
              _ = g.createIdentifier(me().value);
            else if (u === o.StringLiteral || u === o.NumericLiteral)
              w && v.octal && be(v, h.StrictOctalLiteral), _ = g.createLiteral(me());
            else if (u === o.Keyword) {
              if (ae("function"))
                return uu();
              ae("this") ? (me(), _ = g.createThisExpression()) : Je(me());
            } else u === o.BooleanLiteral ? (y = me(), y.value = y.value === "true", _ = g.createLiteral(y)) : u === o.NullLiteral ? (y = me(), y.value = null, _ = g.createLiteral(y)) : D("/") || D("/=") ? (typeof S.tokens < "u" ? _ = g.createLiteral(ze()) : _ = g.createLiteral(Le()), ht()) : Je(me());
            return g.markEnd(_, T);
          }
          function Nr() {
            var u = [];
            if (C("("), !D(")"))
              for (; f < x && (u.push(W()), !D(")")); )
                C(",");
            return C(")"), u;
          }
          function ki() {
            var u, y;
            return y = v, u = me(), tt(u) || Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function Zt() {
            return C("."), ki();
          }
          function Vn() {
            var u;
            return C("["), u = G(), C("]"), u;
          }
          function M() {
            var u, y, _;
            return _ = v, $("new"), u = q(), y = D("(") ? Nr() : [], g.markEnd(g.createNewExpression(u, y), _);
          }
          function V() {
            var u, y, _, T, U;
            for (U = v, u = k.allowIn, k.allowIn = !0, y = ae("new") ? M() : tr(), k.allowIn = u; ; ) {
              if (D("."))
                T = Zt(), y = g.createMemberExpression(".", y, T);
              else if (D("("))
                _ = Nr(), y = g.createCallExpression(y, _);
              else if (D("["))
                T = Vn(), y = g.createMemberExpression("[", y, T);
              else
                break;
              g.markEnd(y, U);
            }
            return y;
          }
          function q() {
            var u, y, _, T;
            for (T = v, u = k.allowIn, y = ae("new") ? M() : tr(), k.allowIn = u; D(".") || D("["); )
              D("[") ? (_ = Vn(), y = g.createMemberExpression("[", y, _)) : (_ = Zt(), y = g.createMemberExpression(".", y, _)), g.markEnd(y, T);
            return y;
          }
          function de() {
            var u, y, _ = v;
            return u = V(), v.type === o.Punctuator && (D("++") || D("--")) && !Ze() && (w && u.type === c.Identifier && ye(u.name) && be({}, h.StrictLHSPostfix), Me(u) || be({}, h.InvalidLHSInAssignment), y = me(), u = g.markEnd(g.createPostfixExpression(y.value, u), _)), u;
          }
          function ve() {
            var u, y, _;
            return v.type !== o.Punctuator && v.type !== o.Keyword ? y = de() : D("++") || D("--") ? (_ = v, u = me(), y = ve(), w && y.type === c.Identifier && ye(y.name) && be({}, h.StrictLHSPrefix), Me(y) || be({}, h.InvalidLHSInAssignment), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _)) : D("+") || D("-") || D("~") || D("!") ? (_ = v, u = me(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _)) : ae("delete") || ae("void") || ae("typeof") ? (_ = v, u = me(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _), w && y.operator === "delete" && y.argument.type === c.Identifier && be({}, h.StrictDelete)) : y = de(), y;
          }
          function Y(u, y) {
            var _ = 0;
            if (u.type !== o.Punctuator && u.type !== o.Keyword)
              return 0;
            switch (u.value) {
              case "||":
                _ = 1;
                break;
              case "&&":
                _ = 2;
                break;
              case "|":
                _ = 3;
                break;
              case "^":
                _ = 4;
                break;
              case "&":
                _ = 5;
                break;
              case "==":
              case "!=":
              case "===":
              case "!==":
                _ = 6;
                break;
              case "<":
              case ">":
              case "<=":
              case ">=":
              case "instanceof":
                _ = 7;
                break;
              case "in":
                _ = y ? 7 : 0;
                break;
              case "<<":
              case ">>":
              case ">>>":
                _ = 8;
                break;
              case "+":
              case "-":
                _ = 9;
                break;
              case "*":
              case "/":
              case "%":
                _ = 11;
                break;
            }
            return _;
          }
          function I() {
            var u, y, _, T, U, ne, _e, Ne, et, Xe;
            if (u = v, et = ve(), T = v, U = Y(T, k.allowIn), U === 0)
              return et;
            for (T.prec = U, me(), y = [u, v], _e = ve(), ne = [et, T, _e]; (U = Y(v, k.allowIn)) > 0; ) {
              for (; ne.length > 2 && U <= ne[ne.length - 2].prec; )
                _e = ne.pop(), Ne = ne.pop().value, et = ne.pop(), _ = g.createBinaryExpression(Ne, et, _e), y.pop(), u = y[y.length - 1], g.markEnd(_, u), ne.push(_);
              T = me(), T.prec = U, ne.push(T), y.push(v), _ = ve(), ne.push(_);
            }
            for (Xe = ne.length - 1, _ = ne[Xe], y.pop(); Xe > 1; )
              _ = g.createBinaryExpression(ne[Xe - 1].value, ne[Xe - 2], _), Xe -= 2, u = y.pop(), g.markEnd(_, u);
            return _;
          }
          function B() {
            var u, y, _, T, U;
            return U = v, u = I(), D("?") && (me(), y = k.allowIn, k.allowIn = !0, _ = W(), k.allowIn = y, C(":"), T = W(), u = g.createConditionalExpression(u, _, T), g.markEnd(u, U)), u;
          }
          function W() {
            var u, y, _, T, U;
            return u = v, U = v, T = y = B(), pe() && (Me(y) || be({}, h.InvalidLHSInAssignment), w && y.type === c.Identifier && ye(y.name) && be(u, h.StrictLHSAssignment), u = me(), _ = W(), T = g.markEnd(g.createAssignmentExpression(u.value, y, _), U)), T;
          }
          function G() {
            var u, y = v;
            if (u = W(), D(",")) {
              for (u = g.createSequenceExpression([u]); f < x && D(","); )
                me(), u.expressions.push(W());
              g.markEnd(u, y);
            }
            return u;
          }
          function K() {
            for (var u = [], y; f < x && !(D("}") || (y = Ir(), typeof y > "u")); )
              u.push(y);
            return u;
          }
          function se() {
            var u, y;
            return y = v, C("{"), u = K(), C("}"), g.markEnd(g.createBlockStatement(u), y);
          }
          function he() {
            var u, y;
            return y = v, u = me(), u.type !== o.Identifier && Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function we(u) {
            var y = null, _, T;
            return T = v, _ = he(), w && ye(_.name) && be({}, h.StrictVarName), u === "const" ? (C("="), y = W()) : D("=") && (me(), y = W()), g.markEnd(g.createVariableDeclarator(_, y), T);
          }
          function Ae(u) {
            var y = [];
            do {
              if (y.push(we(u)), !D(","))
                break;
              me();
            } while (f < x);
            return y;
          }
          function $e() {
            var u;
            return $("var"), u = Ae(), Ee(), g.createVariableDeclaration(u, "var");
          }
          function je(u) {
            var y, _;
            return _ = v, $(u), y = Ae(u), Ee(), g.markEnd(g.createVariableDeclaration(y, u), _);
          }
          function Qe() {
            return C(";"), g.createEmptyStatement();
          }
          function ut() {
            var u = G();
            return Ee(), g.createExpressionStatement(u);
          }
          function st() {
            var u, y, _;
            return $("if"), C("("), u = G(), C(")"), y = Ot(), ae("else") ? (me(), _ = Ot()) : _ = null, g.createIfStatement(u, y, _);
          }
          function Rt() {
            var u, y, _;
            return $("do"), _ = k.inIteration, k.inIteration = !0, u = Ot(), k.inIteration = _, $("while"), C("("), y = G(), C(")"), D(";") && me(), g.createDoWhileStatement(u, y);
          }
          function $t() {
            var u, y, _;
            return $("while"), C("("), u = G(), C(")"), _ = k.inIteration, k.inIteration = !0, y = Ot(), k.inIteration = _, g.createWhileStatement(u, y);
          }
          function Or() {
            var u, y, _;
            return _ = v, u = me(), y = Ae(), g.markEnd(g.createVariableDeclaration(y, u.value), _);
          }
          function an() {
            var u, y, _, T, U, ne, _e;
            return u = y = _ = null, $("for"), C("("), D(";") ? me() : (ae("var") || ae("let") ? (k.allowIn = !1, u = Or(), k.allowIn = !0, u.declarations.length === 1 && ae("in") && (me(), T = u, U = G(), u = null)) : (k.allowIn = !1, u = G(), k.allowIn = !0, ae("in") && (Me(u) || be({}, h.InvalidLHSInForIn), me(), T = u, U = G(), u = null)), typeof T > "u" && C(";")), typeof T > "u" && (D(";") || (y = G()), C(";"), D(")") || (_ = G())), C(")"), _e = k.inIteration, k.inIteration = !0, ne = Ot(), k.inIteration = _e, typeof T > "u" ? g.createForStatement(u, y, _, ne) : g.createForInStatement(T, U, ne);
          }
          function wo() {
            var u = null, y;
            return $("continue"), m.charCodeAt(f) === 59 ? (me(), k.inIteration || ge({}, h.IllegalContinue), g.createContinueStatement(null)) : Ze() ? (k.inIteration || ge({}, h.IllegalContinue), g.createContinueStatement(null)) : (v.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(k.labelSet, y) || ge({}, h.UnknownLabel, u.name)), Ee(), u === null && !k.inIteration && ge({}, h.IllegalContinue), g.createContinueStatement(u));
          }
          function xo() {
            var u = null, y;
            return $("break"), m.charCodeAt(f) === 59 ? (me(), k.inIteration || k.inSwitch || ge({}, h.IllegalBreak), g.createBreakStatement(null)) : Ze() ? (k.inIteration || k.inSwitch || ge({}, h.IllegalBreak), g.createBreakStatement(null)) : (v.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(k.labelSet, y) || ge({}, h.UnknownLabel, u.name)), Ee(), u === null && !(k.inIteration || k.inSwitch) && ge({}, h.IllegalBreak), g.createBreakStatement(u));
          }
          function ru() {
            var u = null;
            return $("return"), k.inFunctionBody || be({}, h.IllegalReturn), m.charCodeAt(f) === 32 && X(m.charCodeAt(f + 1)) ? (u = G(), Ee(), g.createReturnStatement(u)) : Ze() ? g.createReturnStatement(null) : (D(";") || !D("}") && v.type !== o.EOF && (u = G()), Ee(), g.createReturnStatement(u));
          }
          function nu() {
            var u, y;
            return w && (O(), be({}, h.StrictModeWith)), $("with"), C("("), u = G(), C(")"), y = Ot(), g.createWithStatement(u, y);
          }
          function iu() {
            var u, y = [], _, T;
            for (T = v, ae("default") ? (me(), u = null) : ($("case"), u = G()), C(":"); f < x && !(D("}") || ae("default") || ae("case")); )
              _ = Ot(), y.push(_);
            return g.markEnd(g.createSwitchCase(u, y), T);
          }
          function su() {
            var u, y, _, T, U;
            if ($("switch"), C("("), u = G(), C(")"), C("{"), y = [], D("}"))
              return me(), g.createSwitchStatement(u, y);
            for (T = k.inSwitch, k.inSwitch = !0, U = !1; f < x && !D("}"); )
              _ = iu(), _.test === null && (U && ge({}, h.MultipleDefaultsInSwitch), U = !0), y.push(_);
            return k.inSwitch = T, C("}"), g.createSwitchStatement(u, y);
          }
          function ou() {
            var u;
            return $("throw"), Ze() && ge({}, h.NewlineAfterThrow), u = G(), Ee(), g.createThrowStatement(u);
          }
          function au() {
            var u, y, _;
            return _ = v, $("catch"), C("("), D(")") && Je(v), u = he(), w && ye(u.name) && be({}, h.StrictCatchVariable), C(")"), y = se(), g.markEnd(g.createCatchClause(u, y), _);
          }
          function lu() {
            var u, y = [], _ = null;
            return $("try"), u = se(), ae("catch") && y.push(au()), ae("finally") && (me(), _ = se()), y.length === 0 && !_ && ge({}, h.NoCatchOrFinally), g.createTryStatement(u, [], y, _);
          }
          function cu() {
            return $("debugger"), Ee(), g.createDebuggerStatement();
          }
          function Ot() {
            var u = v.type, y, _, T, U;
            if (u === o.EOF && Je(v), u === o.Punctuator && v.value === "{")
              return se();
            if (U = v, u === o.Punctuator)
              switch (v.value) {
                case ";":
                  return g.markEnd(Qe(), U);
                case "(":
                  return g.markEnd(ut(), U);
              }
            if (u === o.Keyword)
              switch (v.value) {
                case "break":
                  return g.markEnd(xo(), U);
                case "continue":
                  return g.markEnd(wo(), U);
                case "debugger":
                  return g.markEnd(cu(), U);
                case "do":
                  return g.markEnd(Rt(), U);
                case "for":
                  return g.markEnd(an(), U);
                case "function":
                  return g.markEnd(Rs(), U);
                case "if":
                  return g.markEnd(st(), U);
                case "return":
                  return g.markEnd(ru(), U);
                case "switch":
                  return g.markEnd(su(), U);
                case "throw":
                  return g.markEnd(ou(), U);
                case "try":
                  return g.markEnd(lu(), U);
                case "var":
                  return g.markEnd($e(), U);
                case "while":
                  return g.markEnd($t(), U);
                case "with":
                  return g.markEnd(nu(), U);
              }
            return y = G(), y.type === c.Identifier && D(":") ? (me(), T = "$" + y.name, Object.prototype.hasOwnProperty.call(k.labelSet, T) && ge({}, h.Redeclaration, "Label", y.name), k.labelSet[T] = !0, _ = Ot(), delete k.labelSet[T], g.markEnd(g.createLabeledStatement(y, _), U)) : (Ee(), g.markEnd(g.createExpressionStatement(y), U));
          }
          function Un() {
            var u, y = [], _, T, U, ne, _e, Ne, et, Xe;
            for (Xe = v, C("{"); f < x && !(v.type !== o.StringLiteral || (_ = v, u = Ir(), y.push(u), u.expression.type !== c.Literal)); )
              T = m.slice(_.start + 1, _.end - 1), T === "use strict" ? (w = !0, U && be(U, h.StrictOctalLiteral)) : !U && _.octal && (U = _);
            for (ne = k.labelSet, _e = k.inIteration, Ne = k.inSwitch, et = k.inFunctionBody, k.labelSet = {}, k.inIteration = !1, k.inSwitch = !1, k.inFunctionBody = !0; f < x && !(D("}") || (u = Ir(), typeof u > "u")); )
              y.push(u);
            return C("}"), k.labelSet = ne, k.inIteration = _e, k.inSwitch = Ne, k.inFunctionBody = et, g.markEnd(g.createBlockStatement(y), Xe);
          }
          function Ps(u) {
            var y, _ = [], T, U, ne, _e, Ne;
            if (C("("), !D(")"))
              for (ne = {}; f < x && (T = v, y = he(), _e = "$" + T.value, w ? (ye(T.value) && (U = T, Ne = h.StrictParamName), Object.prototype.hasOwnProperty.call(ne, _e) && (U = T, Ne = h.StrictParamDupe)) : u || (ye(T.value) ? (u = T, Ne = h.StrictParamName) : ke(T.value) ? (u = T, Ne = h.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ne, _e) && (u = T, Ne = h.StrictParamDupe)), _.push(y), ne[_e] = !0, !D(")")); )
                C(",");
            return C(")"), {
              params: _,
              stricted: U,
              firstRestricted: u,
              message: Ne
            };
          }
          function Rs() {
            var u, y = [], _, T, U, ne, _e, Ne, et, Xe;
            return Xe = v, $("function"), T = v, u = he(), w ? ye(T.value) && be(T, h.StrictFunctionName) : ye(T.value) ? (_e = T, Ne = h.StrictFunctionName) : ke(T.value) && (_e = T, Ne = h.StrictReservedWord), ne = Ps(_e), y = ne.params, U = ne.stricted, _e = ne.firstRestricted, ne.message && (Ne = ne.message), et = w, _ = Un(), w && _e && ge(_e, Ne), w && U && be(U, Ne), w = et, g.markEnd(g.createFunctionDeclaration(u, y, [], _), Xe);
          }
          function uu() {
            var u, y = null, _, T, U, ne, _e = [], Ne, et, Xe;
            return Xe = v, $("function"), D("(") || (u = v, y = he(), w ? ye(u.value) && be(u, h.StrictFunctionName) : ye(u.value) ? (T = u, U = h.StrictFunctionName) : ke(u.value) && (T = u, U = h.StrictReservedWord)), ne = Ps(T), _e = ne.params, _ = ne.stricted, T = ne.firstRestricted, ne.message && (U = ne.message), et = w, Ne = Un(), w && T && ge(T, U), w && _ && be(_, U), w = et, g.markEnd(g.createFunctionExpression(y, _e, [], Ne), Xe);
          }
          function Ir() {
            if (v.type === o.Keyword)
              switch (v.value) {
                case "const":
                case "let":
                  return je(v.value);
                case "function":
                  return Rs();
                default:
                  return Ot();
              }
            if (v.type !== o.EOF)
              return Ot();
          }
          function hu() {
            for (var u, y = [], _, T, U; f < x && (_ = v, !(_.type !== o.StringLiteral || (u = Ir(), y.push(u), u.expression.type !== c.Literal))); )
              T = m.slice(_.start + 1, _.end - 1), T === "use strict" ? (w = !0, U && be(U, h.StrictOctalLiteral)) : !U && _.octal && (U = _);
            for (; f < x && (u = Ir(), !(typeof u > "u")); )
              y.push(u);
            return y;
          }
          function pu() {
            var u, y;
            return O(), ht(), y = v, w = !1, u = hu(), g.markEnd(g.createProgram(u), y);
          }
          function Os() {
            var u, y, _, T = [];
            for (u = 0; u < S.tokens.length; ++u)
              y = S.tokens[u], _ = {
                type: y.type,
                value: y.value
              }, S.range && (_.range = y.range), S.loc && (_.loc = y.loc), T.push(_);
            S.tokens = T;
          }
          function du(u, y) {
            var _, T, U;
            _ = String, typeof u != "string" && !(u instanceof String) && (u = _(u)), g = b, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, v = null, k = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, y = y || {}, y.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []);
            try {
              if (ht(), v.type === o.EOF)
                return S.tokens;
              for (T = me(); v.type !== o.EOF; )
                try {
                  T = me();
                } catch (ne) {
                  if (T = v, S.errors) {
                    S.errors.push(ne);
                    break;
                  } else
                    throw ne;
                }
              Os(), U = S.tokens, typeof S.comments < "u" && (U.comments = S.comments), typeof S.errors < "u" && (U.errors = S.errors);
            } catch (ne) {
              throw ne;
            } finally {
              S = {};
            }
            return U;
          }
          function fu(u, y) {
            var _, T;
            T = String, typeof u != "string" && !(u instanceof String) && (u = T(u)), g = b, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, v = null, k = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, typeof y < "u" && (S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, S.attachComment = typeof y.attachComment == "boolean" && y.attachComment, S.loc && y.source !== null && y.source !== void 0 && (S.source = T(y.source)), typeof y.tokens == "boolean" && y.tokens && (S.tokens = []), typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
            try {
              _ = pu(), typeof S.comments < "u" && (_.comments = S.comments), typeof S.tokens < "u" && (Os(), _.tokens = S.tokens), typeof S.errors < "u" && (_.errors = S.errors);
            } catch (U) {
              throw U;
            } finally {
              S = {};
            }
            return _;
          }
          s.version = "1.2.2", s.tokenize = du, s.parse = fu, s.Syntax = function() {
            var u, y = {};
            typeof Object.create == "function" && (y = /* @__PURE__ */ Object.create(null));
            for (u in c)
              c.hasOwnProperty(u) && (y[u] = c[u]);
            return typeof Object.freeze == "function" && Object.freeze(y), y;
          }();
        });
      }, {}], 1: [function(r, n, i) {
        (function(s) {
          var o = function() {
            var a = {
              trace: function() {
              },
              yy: {},
              symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
              terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
              productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
              performAction: function(h, d, b, m, w, f, E) {
                m.ast || (m.ast = l, l.initialize());
                var A = f.length - 1;
                switch (w) {
                  case 1:
                    return m.ast.set({ expression: { type: "root", value: f[A] } }), m.ast.unshift(), m.ast.yield();
                  case 2:
                    return m.ast.set({ expression: { type: "root", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 3:
                    return m.ast.unshift(), m.ast.yield();
                  case 4:
                    return m.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 5:
                    break;
                  case 6:
                    break;
                  case 7:
                    m.ast.set({ operation: "member" }), m.ast.push();
                    break;
                  case 8:
                    m.ast.set({ operation: "subscript" }), m.ast.push();
                    break;
                  case 9:
                    m.ast.set({ scope: "child" });
                    break;
                  case 10:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 11:
                    break;
                  case 12:
                    m.ast.set({ scope: "child", operation: "member" });
                    break;
                  case 13:
                    break;
                  case 14:
                    m.ast.set({ expression: { type: "wildcard", value: f[A] } });
                    break;
                  case 15:
                    m.ast.set({ expression: { type: "identifier", value: f[A] } });
                    break;
                  case 16:
                    m.ast.set({ expression: { type: "script_expression", value: f[A] } });
                    break;
                  case 17:
                    m.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                    break;
                  case 18:
                    break;
                  case 19:
                    m.ast.set({ scope: "child" });
                    break;
                  case 20:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 21:
                    break;
                  case 22:
                    break;
                  case 23:
                    break;
                  case 24:
                    f[A].length > 1 ? m.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                    break;
                  case 25:
                    this.$ = [f[A]];
                    break;
                  case 26:
                    this.$ = f[A - 2].concat(f[A]);
                    break;
                  case 27:
                    this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, m.ast.set(this.$);
                    break;
                  case 28:
                    this.$ = { expression: { type: "string_literal", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 29:
                    this.$ = { expression: { type: "slice", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 30:
                    this.$ = { expression: { type: "wildcard", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 31:
                    this.$ = { expression: { type: "script_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 32:
                    this.$ = { expression: { type: "filter_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 33:
                    this.$ = f[A];
                    break;
                  case 34:
                    this.$ = f[A];
                    break;
                }
              },
              table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
              defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
              parseError: function(h, d) {
                if (d.recoverable)
                  this.trace(h);
                else
                  throw new Error(h);
              },
              parse: function(h) {
                var d = this, b = [0], m = [null], w = [], f = this.table, E = "", A = 0, x = 0, g = 2, v = 1, k = w.slice.call(arguments, 1);
                this.lexer.setInput(h), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
                var S = this.lexer.yylloc;
                w.push(S);
                var R = this.lexer.options && this.lexer.options.ranges;
                typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
                function L() {
                  var Ie;
                  return Ie = d.lexer.lex() || v, typeof Ie != "number" && (Ie = d.symbols_[Ie] || Ie), Ie;
                }
                for (var F, z, j, ee, X = {}, ie, ce, ke, ye; ; ) {
                  if (z = b[b.length - 1], this.defaultActions[z] ? j = this.defaultActions[z] : ((F === null || typeof F > "u") && (F = L()), j = f[z] && f[z][F]), typeof j > "u" || !j.length || !j[0]) {
                    var Ce = "";
                    ye = [];
                    for (ie in f[z])
                      this.terminals_[ie] && ie > g && ye.push("'" + this.terminals_[ie] + "'");
                    this.lexer.showPosition ? Ce = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + ye.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : Ce = "Parse error on line " + (A + 1) + ": Unexpected " + (F == v ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(Ce, {
                      text: this.lexer.match,
                      token: this.terminals_[F] || F,
                      line: this.lexer.yylineno,
                      loc: S,
                      expected: ye
                    });
                  }
                  if (j[0] instanceof Array && j.length > 1)
                    throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + F);
                  switch (j[0]) {
                    case 1:
                      b.push(F), m.push(this.lexer.yytext), w.push(this.lexer.yylloc), b.push(j[1]), F = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                      break;
                    case 2:
                      if (ce = this.productions_[j[1]][1], X.$ = m[m.length - ce], X._$ = {
                        first_line: w[w.length - (ce || 1)].first_line,
                        last_line: w[w.length - 1].last_line,
                        first_column: w[w.length - (ce || 1)].first_column,
                        last_column: w[w.length - 1].last_column
                      }, R && (X._$.range = [
                        w[w.length - (ce || 1)].range[0],
                        w[w.length - 1].range[1]
                      ]), ee = this.performAction.apply(X, [
                        E,
                        x,
                        A,
                        this.yy,
                        j[1],
                        m,
                        w
                      ].concat(k)), typeof ee < "u")
                        return ee;
                      ce && (b = b.slice(0, -1 * ce * 2), m = m.slice(0, -1 * ce), w = w.slice(0, -1 * ce)), b.push(this.productions_[j[1]][0]), m.push(X.$), w.push(X._$), ke = f[b[b.length - 2]][b[b.length - 1]], b.push(ke);
                      break;
                    case 3:
                      return !0;
                  }
                }
                return !0;
              }
            }, l = {
              initialize: function() {
                this._nodes = [], this._node = {}, this._stash = [];
              },
              set: function(h) {
                for (var d in h) this._node[d] = h[d];
                return this._node;
              },
              node: function(h) {
                return arguments.length && (this._node = h), this._node;
              },
              push: function() {
                this._nodes.push(this._node), this._node = {};
              },
              unshift: function() {
                this._nodes.unshift(this._node), this._node = {};
              },
              yield: function() {
                var h = this._nodes;
                return this.initialize(), h;
              }
            }, c = /* @__PURE__ */ function() {
              var h = {
                EOF: 1,
                parseError: function(d, b) {
                  if (this.yy.parser)
                    this.yy.parser.parseError(d, b);
                  else
                    throw new Error(d);
                },
                // resets the lexer, sets new input
                setInput: function(d) {
                  return this._input = d, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                  }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
                },
                // consumes and returns one char from the input
                input: function() {
                  var d = this._input[0];
                  this.yytext += d, this.yyleng++, this.offset++, this.match += d, this.matched += d;
                  var b = d.match(/(?:\r\n?|\n).*/g);
                  return b ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), d;
                },
                // unshifts one char (or a string) into the input
                unput: function(d) {
                  var b = d.length, m = d.split(/(?:\r\n?|\n)/g);
                  this._input = d + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - b - 1), this.offset -= b;
                  var w = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
                  var f = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: m ? (m.length === w.length ? this.yylloc.first_column : 0) + w[w.length - m.length].length - m[0].length : this.yylloc.first_column - b
                  }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - b]), this.yyleng = this.yytext.length, this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function() {
                  return this._more = !0, this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function() {
                  if (this.options.backtrack_lexer)
                    this._backtrack = !0;
                  else
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                      text: "",
                      token: null,
                      line: this.yylineno
                    });
                  return this;
                },
                // retain first n characters of the match
                less: function(d) {
                  this.unput(this.match.slice(d));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function() {
                  var d = this.matched.substr(0, this.matched.length - this.match.length);
                  return (d.length > 20 ? "..." : "") + d.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function() {
                  var d = this.match;
                  return d.length < 20 && (d += this._input.substr(0, 20 - d.length)), (d.substr(0, 20) + (d.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function() {
                  var d = this.pastInput(), b = new Array(d.length + 1).join("-");
                  return d + this.upcomingInput() + `
` + b + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function(d, b) {
                  var m, w, f;
                  if (this.options.backtrack_lexer && (f = {
                    yylineno: this.yylineno,
                    yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                  }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), w = d[0].match(/(?:\r\n?|\n).*/g), w && (this.yylineno += w.length), this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: w ? w[w.length - 1].length - w[w.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + d[0].length
                  }, this.yytext += d[0], this.match += d[0], this.matches = d, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(d[0].length), this.matched += d[0], m = this.performAction.call(this, this.yy, this, b, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
                    return m;
                  if (this._backtrack) {
                    for (var E in f)
                      this[E] = f[E];
                    return !1;
                  }
                  return !1;
                },
                // return next match in input
                next: function() {
                  if (this.done)
                    return this.EOF;
                  this._input || (this.done = !0);
                  var d, b, m, w;
                  this._more || (this.yytext = "", this.match = "");
                  for (var f = this._currentRules(), E = 0; E < f.length; E++)
                    if (m = this._input.match(this.rules[f[E]]), m && (!b || m[0].length > b[0].length)) {
                      if (b = m, w = E, this.options.backtrack_lexer) {
                        if (d = this.test_match(m, f[E]), d !== !1)
                          return d;
                        if (this._backtrack) {
                          b = !1;
                          continue;
                        } else
                          return !1;
                      } else if (!this.options.flex)
                        break;
                    }
                  return b ? (d = this.test_match(b, f[w]), d !== !1 ? d : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                },
                // return next match that has a token
                lex: function() {
                  var d = this.next();
                  return d || this.lex();
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function(d) {
                  this.conditionStack.push(d);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function() {
                  var d = this.conditionStack.length - 1;
                  return d > 0 ? this.conditionStack.pop() : this.conditionStack[0];
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function() {
                  return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function(d) {
                  return d = this.conditionStack.length - 1 - Math.abs(d || 0), d >= 0 ? this.conditionStack[d] : "INITIAL";
                },
                // alias for begin(condition)
                pushState: function(d) {
                  this.begin(d);
                },
                // return the number of states currently on the stack
                stateStackSize: function() {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function(d, b, m, w) {
                  switch (m) {
                    case 0:
                      return 4;
                    case 1:
                      return 14;
                    case 2:
                      return 12;
                    case 3:
                      return 15;
                    case 4:
                      return 16;
                    case 5:
                      return 22;
                    case 6:
                      return 24;
                    case 7:
                      return 28;
                    case 8:
                      return 30;
                    case 9:
                      return 18;
                    case 10:
                      return b.yytext = b.yytext.substr(1, b.yyleng - 2), 32;
                    case 11:
                      return b.yytext = b.yytext.substr(1, b.yyleng - 2), 33;
                    case 12:
                      return 17;
                    case 13:
                      return 31;
                  }
                },
                rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
                conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
              };
              return h;
            }();
            a.lexer = c;
            function p() {
              this.yy = {};
            }
            return p.prototype = a, a.Parser = p, new p();
          }();
          typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
            return o.parse.apply(o, arguments);
          }, i.main = function(a) {
            a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
            var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
            return i.parser.parse(l);
          }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
        }).call(this, r("_process"));
      }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
        n.exports = {
          identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
          integer: "-?(?:0|[1-9][0-9]*)",
          qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
          q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
        };
      }, {}], 3: [function(r, n, i) {
        var s = r("./dict"), o = r("fs"), a = {
          lex: {
            macros: {
              esc: "\\\\",
              int: s.integer
            },
            rules: [
              ["\\$", "return 'DOLLAR'"],
              ["\\.\\.", "return 'DOT_DOT'"],
              ["\\.", "return 'DOT'"],
              ["\\*", "return 'STAR'"],
              [s.identifier, "return 'IDENTIFIER'"],
              ["\\[", "return '['"],
              ["\\]", "return ']'"],
              [",", "return ','"],
              ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
              ["{int}", "return 'INTEGER'"],
              [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
              [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
              ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
              ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
            ]
          },
          start: "JSON_PATH",
          bnf: {
            JSON_PATH: [
              ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
              ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
            ],
            PATH_COMPONENTS: [
              ["PATH_COMPONENT", ""],
              ["PATH_COMPONENTS PATH_COMPONENT", ""]
            ],
            PATH_COMPONENT: [
              ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
              ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
            ],
            MEMBER_COMPONENT: [
              ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_MEMBER_COMPONENT: [
              ["DOT MEMBER_EXPRESSION", ""]
            ],
            LEADING_CHILD_MEMBER_EXPRESSION: [
              ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
            ],
            DESCENDANT_MEMBER_COMPONENT: [
              ["DOT_DOT MEMBER_EXPRESSION", ""]
            ],
            MEMBER_EXPRESSION: [
              ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
              ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
              ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
              ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
              ["END", ""]
            ],
            SUBSCRIPT_COMPONENT: [
              ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_SUBSCRIPT_COMPONENT: [
              ["[ SUBSCRIPT ]", ""]
            ],
            DESCENDANT_SUBSCRIPT_COMPONENT: [
              ["DOT_DOT [ SUBSCRIPT ]", ""]
            ],
            SUBSCRIPT: [
              ["SUBSCRIPT_EXPRESSION", ""],
              ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
            ],
            SUBSCRIPT_EXPRESSION_LIST: [
              ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
              ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
            ],
            SUBSCRIPT_EXPRESSION_LISTABLE: [
              ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
              ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
              ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
            ],
            SUBSCRIPT_EXPRESSION: [
              ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
              ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
              ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
            ],
            STRING_LITERAL: [
              ["QQ_STRING", "$$ = $1"],
              ["Q_STRING", "$$ = $1"]
            ]
          }
        };
        o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
      }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
        var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
          return this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.traverse = b(!0), this.descend = b();
        }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
          var g = [x.operation, x.scope, x.expression.type].join("-"), v = this._fns[g];
          if (!v) throw new Error("couldn't resolve key: " + g);
          return v.bind(this);
        }, c.prototype.register = function(x, g) {
          if (!g instanceof Function)
            throw new Error("handler must be a function");
          this._fns[x] = g;
        }, c.prototype._fns = {
          "member-child-identifier": function(x, g) {
            var v = x.expression.value, k = g.value;
            if (k instanceof Object && v in k)
              return [{ value: k[v], path: g.path.concat(v) }];
          },
          "member-descendant-identifier": w(function(x, g, v) {
            return x == v;
          }),
          "subscript-child-numeric_literal": m(function(x, g, v) {
            return x === v;
          }),
          "member-child-numeric_literal": m(function(x, g, v) {
            return String(x) === String(v);
          }),
          "subscript-descendant-numeric_literal": w(function(x, g, v) {
            return x === v;
          }),
          "member-child-wildcard": m(function() {
            return !0;
          }),
          "member-descendant-wildcard": w(function() {
            return !0;
          }),
          "subscript-descendant-wildcard": w(function() {
            return !0;
          }),
          "subscript-child-wildcard": m(function() {
            return !0;
          }),
          "subscript-child-slice": function(x, g) {
            if (h(g.value)) {
              var v = x.expression.value.split(":").map(A), k = g.value.map(function(S, R) {
                return { value: S, path: g.path.concat(R) };
              });
              return o.apply(null, [k].concat(v));
            }
          },
          "subscript-child-union": function(x, g) {
            var v = [];
            return x.expression.value.forEach(function(k) {
              var S = { operation: "subscript", scope: "child", expression: k.expression }, R = this.resolve(S), L = R(S, g);
              L && (v = v.concat(L));
            }, this), E(v);
          },
          "subscript-descendant-union": function(x, g, v) {
            var k = r(".."), S = this, R = [], L = k.nodes(g, "$..*").slice(1);
            return L.forEach(function(F) {
              R.length >= v || x.expression.value.forEach(function(z) {
                var j = { operation: "subscript", scope: "child", expression: z.expression }, ee = S.resolve(j), X = ee(j, F);
                R = R.concat(X);
              });
            }), E(R);
          },
          "subscript-child-filter_expression": function(x, g, v) {
            var k = x.expression.value.slice(2, -1), S = s.parse(k).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.descend(g, null, R, v);
          },
          "subscript-descendant-filter_expression": function(x, g, v) {
            var k = x.expression.value.slice(2, -1), S = s.parse(k).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.traverse(g, null, R, v);
          },
          "subscript-child-script_expression": function(x, g) {
            var v = x.expression.value.slice(1, -1);
            return p(g, v, "$[{{value}}]");
          },
          "member-child-script_expression": function(x, g) {
            var v = x.expression.value.slice(1, -1);
            return p(g, v, "$.{{value}}");
          },
          "member-descendant-script_expression": function(x, g) {
            var v = x.expression.value.slice(1, -1);
            return p(g, v, "$..value");
          }
        }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
        function p(x, g, v) {
          var k = r("./index"), S = s.parse(g).body[0].expression, R = f(S, { "@": x.value }), L = v.replace(/\{\{\s*value\s*\}\}/g, R), F = k.nodes(x.value, L);
          return F.forEach(function(z) {
            z.path = x.path.concat(z.path.slice(1));
          }), F;
        }
        function h(x) {
          return Array.isArray(x);
        }
        function d(x) {
          return x && !(x instanceof Array) && x instanceof Object;
        }
        function b(x) {
          return function(g, v, k, S) {
            var R = g.value, L = g.path, F = [], z = (function(j, ee) {
              h(j) ? (j.forEach(function(X, ie) {
                F.length >= S || k(ie, X, v) && F.push({ path: ee.concat(ie), value: X });
              }), j.forEach(function(X, ie) {
                F.length >= S || x && z(X, ee.concat(ie));
              })) : d(j) && (this.keys(j).forEach(function(X) {
                F.length >= S || k(X, j[X], v) && F.push({ path: ee.concat(X), value: j[X] });
              }), this.keys(j).forEach(function(X) {
                F.length >= S || x && z(j[X], ee.concat(X));
              }));
            }).bind(this);
            return z(R, L), F;
          };
        }
        function m(x) {
          return function(g, v, k) {
            return this.descend(v, g.expression.value, x, k);
          };
        }
        function w(x) {
          return function(g, v, k) {
            return this.traverse(v, g.expression.value, x, k);
          };
        }
        function f() {
          try {
            return a.apply(this, arguments);
          } catch {
          }
        }
        function E(x) {
          return x = x.filter(function(g) {
            return g;
          }), l(
            x,
            function(g) {
              return g.path.map(function(v) {
                return String(v).replace("-", "--");
              }).join("-");
            }
          );
        }
        function A(x) {
          var g = String(x);
          return g.match(/^-?[0-9]+$/) ? parseInt(g) : null;
        }
        n.exports = c;
      }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
        var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
          this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.parser = new a(), this.handlers = new l();
        }, c.prototype.parse = function(d) {
          return s.ok(p(d), "we need a path"), this.parser.parse(d);
        }, c.prototype.parent = function(d, b) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
          var m = this.nodes(d, b)[0];
          return m.path.pop(), this.value(d, m.path);
        }, c.prototype.apply = function(d, b, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), s.equal(typeof m, "function", "fn needs to be function");
          var w = this.nodes(d, b).sort(function(f, E) {
            return E.path.length - f.path.length;
          });
          return w.forEach(function(f) {
            var E = f.path.pop(), A = this.value(d, this.stringify(f.path)), x = f.value = m.call(d, A[E]);
            A[E] = x;
          }, this), w;
        }, c.prototype.value = function(d, b, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), arguments.length >= 3) {
            var w = this.nodes(d, b).shift();
            if (!w) return this._vivify(d, b, m);
            var f = w.path.slice(-1).shift(), E = this.parent(d, this.stringify(w.path));
            E[f] = m;
          }
          return this.query(d, this.stringify(b), 1).shift();
        }, c.prototype._vivify = function(d, b, m) {
          var w = this;
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
          var f = this.parser.parse(b).map(function(A) {
            return A.expression.value;
          }), E = function(A, x) {
            var g = A.pop(), v = w.value(d, A);
            v || (E(A.concat(), typeof g == "string" ? {} : []), v = w.value(d, A)), v[g] = x;
          };
          return E(f, m), this.query(d, b)[0];
        }, c.prototype.query = function(d, b, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(p(b), "we need a path");
          var w = this.nodes(d, b, m).map(function(f) {
            return f.value;
          });
          return w;
        }, c.prototype.paths = function(d, b, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
          var w = this.nodes(d, b, m).map(function(f) {
            return f.path;
          });
          return w;
        }, c.prototype.nodes = function(d, b, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), m === 0) return [];
          var w = this.parser.parse(b), f = this.handlers, E = [{ path: ["$"], value: d }], A = [];
          return w.length && w[0].expression.type == "root" && w.shift(), w.length ? (w.forEach(function(x, g) {
            if (!(A.length >= m)) {
              var v = f.resolve(x), k = [];
              E.forEach(function(S) {
                if (!(A.length >= m)) {
                  var R = v(x, S, m);
                  g == w.length - 1 ? A = A.concat(R || []) : k = k.concat(R || []);
                }
              }), E = k;
            }
          }), m ? A.slice(0, m) : A) : E;
        }, c.prototype.stringify = function(d) {
          s.ok(d, "we need a path");
          var b = "$", m = {
            "descendant-member": "..{{value}}",
            "child-member": ".{{value}}",
            "descendant-subscript": "..[{{value}}]",
            "child-subscript": "[{{value}}]"
          };
          return d = this._normalize(d), d.forEach(function(w) {
            if (w.expression.type != "root") {
              var f = [w.scope, w.operation].join("-"), E = m[f], A;
              if (w.expression.type == "string_literal" ? A = JSON.stringify(w.expression.value) : A = w.expression.value, !E) throw new Error("couldn't find template " + f);
              b += E.replace(/{{value}}/, A);
            }
          }), b;
        }, c.prototype._normalize = function(d) {
          if (s.ok(d, "we need a path"), typeof d == "string")
            return this.parser.parse(d);
          if (Array.isArray(d) && typeof d[0] == "string") {
            var b = [{ expression: { type: "root", value: "$" } }];
            return d.forEach(function(m, w) {
              if (!(m == "$" && w === 0))
                if (typeof m == "string" && m.match("^" + o.identifier + "$"))
                  b.push({
                    operation: "member",
                    scope: "child",
                    expression: { value: m, type: "identifier" }
                  });
                else {
                  var f = typeof m == "number" ? "numeric_literal" : "string_literal";
                  b.push({
                    operation: "subscript",
                    scope: "child",
                    expression: { value: m, type: f }
                  });
                }
            }), b;
          } else if (Array.isArray(d) && typeof d[0] == "object")
            return d;
          throw new Error("couldn't understand path " + d);
        };
        function p(d) {
          return Object.prototype.toString.call(d) == "[object String]";
        }
        c.Handlers = l, c.Parser = a;
        var h = new c();
        h.JSONPath = c, n.exports = h;
      }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
        var s = r("./grammar"), o = r("../generated/parser"), a = function() {
          var l = new o.Parser(), c = l.parseError;
          return l.yy.parseError = function() {
            l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
          }, l;
        };
        a.grammar = s, n.exports = a;
      }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
        n.exports = function(o, a, l, c) {
          if (typeof a == "string") throw new Error("start cannot be a string");
          if (typeof l == "string") throw new Error("end cannot be a string");
          if (typeof c == "string") throw new Error("step cannot be a string");
          var p = o.length;
          if (c === 0) throw new Error("step cannot be zero");
          if (c = c ? s(c) : 1, a = a < 0 ? p + a : a, l = l < 0 ? p + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : p - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? p : -1)), a = c > 0 ? Math.max(0, a) : Math.min(p, a), l = c > 0 ? Math.min(l, p) : Math.max(-1, l), c > 0 && l <= a) return [];
          if (c < 0 && a <= l) return [];
          for (var h = [], d = a; d != l && !(c < 0 && d <= l || c > 0 && d >= l); d += c)
            h.push(o[d]);
          return h;
        };
        function s(o) {
          return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
        }
      }, {}], 8: [function(r, n, i) {
        var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = b;
        l.AssertionError = function(g) {
          this.name = "AssertionError", this.actual = g.actual, this.expected = g.expected, this.operator = g.operator, g.message ? (this.message = g.message, this.generatedMessage = !1) : (this.message = h(this), this.generatedMessage = !0);
          var v = g.stackStartFunction || d;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, v);
          else {
            var k = new Error();
            if (k.stack) {
              var S = k.stack, R = v.name, L = S.indexOf(`
` + R);
              if (L >= 0) {
                var F = S.indexOf(`
`, L + 1);
                S = S.substring(F + 1);
              }
              this.stack = S;
            }
          }
        }, s.inherits(l.AssertionError, Error);
        function c(g, v) {
          return s.isUndefined(v) ? "" + v : s.isNumber(v) && !isFinite(v) || s.isFunction(v) || s.isRegExp(v) ? v.toString() : v;
        }
        function p(g, v) {
          return s.isString(g) ? g.length < v ? g : g.slice(0, v) : g;
        }
        function h(g) {
          return p(JSON.stringify(g.actual, c), 128) + " " + g.operator + " " + p(JSON.stringify(g.expected, c), 128);
        }
        function d(g, v, k, S, R) {
          throw new l.AssertionError({
            message: k,
            actual: g,
            expected: v,
            operator: S,
            stackStartFunction: R
          });
        }
        l.fail = d;
        function b(g, v) {
          g || d(g, !0, v, "==", l.ok);
        }
        l.ok = b, l.equal = function(g, v, k) {
          g != v && d(g, v, k, "==", l.equal);
        }, l.notEqual = function(g, v, k) {
          g == v && d(g, v, k, "!=", l.notEqual);
        }, l.deepEqual = function(g, v, k) {
          m(g, v) || d(g, v, k, "deepEqual", l.deepEqual);
        };
        function m(g, v) {
          if (g === v)
            return !0;
          if (s.isBuffer(g) && s.isBuffer(v)) {
            if (g.length != v.length) return !1;
            for (var k = 0; k < g.length; k++)
              if (g[k] !== v[k]) return !1;
            return !0;
          } else return s.isDate(g) && s.isDate(v) ? g.getTime() === v.getTime() : s.isRegExp(g) && s.isRegExp(v) ? g.source === v.source && g.global === v.global && g.multiline === v.multiline && g.lastIndex === v.lastIndex && g.ignoreCase === v.ignoreCase : !s.isObject(g) && !s.isObject(v) ? g == v : f(g, v);
        }
        function w(g) {
          return Object.prototype.toString.call(g) == "[object Arguments]";
        }
        function f(g, v) {
          if (s.isNullOrUndefined(g) || s.isNullOrUndefined(v) || g.prototype !== v.prototype) return !1;
          if (s.isPrimitive(g) || s.isPrimitive(v))
            return g === v;
          var k = w(g), S = w(v);
          if (k && !S || !k && S)
            return !1;
          if (k)
            return g = o.call(g), v = o.call(v), m(g, v);
          var R = x(g), L = x(v), F, z;
          if (R.length != L.length)
            return !1;
          for (R.sort(), L.sort(), z = R.length - 1; z >= 0; z--)
            if (R[z] != L[z])
              return !1;
          for (z = R.length - 1; z >= 0; z--)
            if (F = R[z], !m(g[F], v[F])) return !1;
          return !0;
        }
        l.notDeepEqual = function(g, v, k) {
          m(g, v) && d(g, v, k, "notDeepEqual", l.notDeepEqual);
        }, l.strictEqual = function(g, v, k) {
          g !== v && d(g, v, k, "===", l.strictEqual);
        }, l.notStrictEqual = function(g, v, k) {
          g === v && d(g, v, k, "!==", l.notStrictEqual);
        };
        function E(g, v) {
          return !g || !v ? !1 : Object.prototype.toString.call(v) == "[object RegExp]" ? v.test(g) : g instanceof v ? !0 : v.call({}, g) === !0;
        }
        function A(g, v, k, S) {
          var R;
          s.isString(k) && (S = k, k = null);
          try {
            v();
          } catch (L) {
            R = L;
          }
          if (S = (k && k.name ? " (" + k.name + ")." : ".") + (S ? " " + S : "."), g && !R && d(R, k, "Missing expected exception" + S), !g && E(R, k) && d(R, k, "Got unwanted exception" + S), g && R && k && !E(R, k) || !g && R)
            throw R;
        }
        l.throws = function(g, v, k) {
          A.apply(this, [!0].concat(o.call(arguments)));
        }, l.doesNotThrow = function(g, v) {
          A.apply(this, [!1].concat(o.call(arguments)));
        }, l.ifError = function(g) {
          if (g)
            throw g;
        };
        var x = Object.keys || function(g) {
          var v = [];
          for (var k in g)
            a.call(g, k) && v.push(k);
          return v;
        };
      }, { "util/": 11 }], 9: [function(r, n, i) {
        typeof Object.create == "function" ? n.exports = function(s, o) {
          s.super_ = o, s.prototype = Object.create(o.prototype, {
            constructor: {
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : n.exports = function(s, o) {
          s.super_ = o;
          var a = function() {
          };
          a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
        };
      }, {}], 10: [function(r, n, i) {
        n.exports = function(s) {
          return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
        };
      }, {}], 11: [function(r, n, i) {
        (function(s, o) {
          var a = /%[sdj%]/g;
          i.format = function(O) {
            if (!L(O)) {
              for (var N = [], Z = 0; Z < arguments.length; Z++)
                N.push(p(arguments[Z]));
              return N.join(" ");
            }
            for (var Z = 1, re = arguments, le = re.length, te = String(O).replace(a, function(H) {
              if (H === "%%") return "%";
              if (Z >= le) return H;
              switch (H) {
                case "%s":
                  return String(re[Z++]);
                case "%d":
                  return Number(re[Z++]);
                case "%j":
                  try {
                    return JSON.stringify(re[Z++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return H;
              }
            }), oe = re[Z]; Z < le; oe = re[++Z])
              k(oe) || !ee(oe) ? te += " " + oe : te += " " + p(oe);
            return te;
          }, i.deprecate = function(O, N) {
            if (z(o.process))
              return function() {
                return i.deprecate(O, N).apply(this, arguments);
              };
            if (s.noDeprecation === !0)
              return O;
            var Z = !1;
            function re() {
              if (!Z) {
                if (s.throwDeprecation)
                  throw new Error(N);
                s.traceDeprecation ? console.trace(N) : console.error(N), Z = !0;
              }
              return O.apply(this, arguments);
            }
            return re;
          };
          var l = {}, c;
          i.debuglog = function(O) {
            if (z(c) && (c = s.env.NODE_DEBUG || ""), O = O.toUpperCase(), !l[O])
              if (new RegExp("\\b" + O + "\\b", "i").test(c)) {
                var N = s.pid;
                l[O] = function() {
                  var Z = i.format.apply(i, arguments);
                  console.error("%s %d: %s", O, N, Z);
                };
              } else
                l[O] = function() {
                };
            return l[O];
          };
          function p(O, N) {
            var Z = {
              seen: [],
              stylize: d
            };
            return arguments.length >= 3 && (Z.depth = arguments[2]), arguments.length >= 4 && (Z.colors = arguments[3]), v(N) ? Z.showHidden = N : N && i._extend(Z, N), z(Z.showHidden) && (Z.showHidden = !1), z(Z.depth) && (Z.depth = 2), z(Z.colors) && (Z.colors = !1), z(Z.customInspect) && (Z.customInspect = !0), Z.colors && (Z.stylize = h), m(Z, O, Z.depth);
          }
          i.inspect = p, p.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, p.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function h(O, N) {
            var Z = p.styles[N];
            return Z ? "\x1B[" + p.colors[Z][0] + "m" + O + "\x1B[" + p.colors[Z][1] + "m" : O;
          }
          function d(O, N) {
            return O;
          }
          function b(O) {
            var N = {};
            return O.forEach(function(Z, re) {
              N[Z] = !0;
            }), N;
          }
          function m(O, N, Z) {
            if (O.customInspect && N && ce(N.inspect) && // Filter out the util module, it's inspect function is special
            N.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
            !(N.constructor && N.constructor.prototype === N)) {
              var re = N.inspect(Z, O);
              return L(re) || (re = m(O, re, Z)), re;
            }
            var le = w(O, N);
            if (le)
              return le;
            var te = Object.keys(N), oe = b(te);
            if (O.showHidden && (te = Object.getOwnPropertyNames(N)), ie(N) && (te.indexOf("message") >= 0 || te.indexOf("description") >= 0))
              return f(N);
            if (te.length === 0) {
              if (ce(N)) {
                var fe = N.name ? ": " + N.name : "";
                return O.stylize("[Function" + fe + "]", "special");
              }
              if (j(N))
                return O.stylize(RegExp.prototype.toString.call(N), "regexp");
              if (X(N))
                return O.stylize(Date.prototype.toString.call(N), "date");
              if (ie(N))
                return f(N);
            }
            var H = "", J = !1, Se = ["{", "}"];
            if (g(N) && (J = !0, Se = ["[", "]"]), ce(N)) {
              var Re = N.name ? ": " + N.name : "";
              H = " [Function" + Re + "]";
            }
            if (j(N) && (H = " " + RegExp.prototype.toString.call(N)), X(N) && (H = " " + Date.prototype.toUTCString.call(N)), ie(N) && (H = " " + f(N)), te.length === 0 && (!J || N.length == 0))
              return Se[0] + H + Se[1];
            if (Z < 0)
              return j(N) ? O.stylize(RegExp.prototype.toString.call(N), "regexp") : O.stylize("[Object]", "special");
            O.seen.push(N);
            var Fe;
            return J ? Fe = E(O, N, Z, oe, te) : Fe = te.map(function(Le) {
              return A(O, N, Z, oe, Le, J);
            }), O.seen.pop(), x(Fe, H, Se);
          }
          function w(O, N) {
            if (z(N))
              return O.stylize("undefined", "undefined");
            if (L(N)) {
              var Z = "'" + JSON.stringify(N).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return O.stylize(Z, "string");
            }
            if (R(N))
              return O.stylize("" + N, "number");
            if (v(N))
              return O.stylize("" + N, "boolean");
            if (k(N))
              return O.stylize("null", "null");
          }
          function f(O) {
            return "[" + Error.prototype.toString.call(O) + "]";
          }
          function E(O, N, Z, re, le) {
            for (var te = [], oe = 0, fe = N.length; oe < fe; ++oe)
              ue(N, String(oe)) ? te.push(A(
                O,
                N,
                Z,
                re,
                String(oe),
                !0
              )) : te.push("");
            return le.forEach(function(H) {
              H.match(/^\d+$/) || te.push(A(
                O,
                N,
                Z,
                re,
                H,
                !0
              ));
            }), te;
          }
          function A(O, N, Z, re, le, te) {
            var oe, fe, H;
            if (H = Object.getOwnPropertyDescriptor(N, le) || { value: N[le] }, H.get ? H.set ? fe = O.stylize("[Getter/Setter]", "special") : fe = O.stylize("[Getter]", "special") : H.set && (fe = O.stylize("[Setter]", "special")), ue(re, le) || (oe = "[" + le + "]"), fe || (O.seen.indexOf(H.value) < 0 ? (k(Z) ? fe = m(O, H.value, null) : fe = m(O, H.value, Z - 1), fe.indexOf(`
`) > -1 && (te ? fe = fe.split(`
`).map(function(J) {
              return "  " + J;
            }).join(`
`).substr(2) : fe = `
` + fe.split(`
`).map(function(J) {
              return "   " + J;
            }).join(`
`))) : fe = O.stylize("[Circular]", "special")), z(oe)) {
              if (te && le.match(/^\d+$/))
                return fe;
              oe = JSON.stringify("" + le), oe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (oe = oe.substr(1, oe.length - 2), oe = O.stylize(oe, "name")) : (oe = oe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), oe = O.stylize(oe, "string"));
            }
            return oe + ": " + fe;
          }
          function x(O, N, Z) {
            var re = O.reduce(function(le, te) {
              return te.indexOf(`
`) >= 0, le + te.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return re > 60 ? Z[0] + (N === "" ? "" : N + `
 `) + " " + O.join(`,
  `) + " " + Z[1] : Z[0] + N + " " + O.join(", ") + " " + Z[1];
          }
          function g(O) {
            return Array.isArray(O);
          }
          i.isArray = g;
          function v(O) {
            return typeof O == "boolean";
          }
          i.isBoolean = v;
          function k(O) {
            return O === null;
          }
          i.isNull = k;
          function S(O) {
            return O == null;
          }
          i.isNullOrUndefined = S;
          function R(O) {
            return typeof O == "number";
          }
          i.isNumber = R;
          function L(O) {
            return typeof O == "string";
          }
          i.isString = L;
          function F(O) {
            return typeof O == "symbol";
          }
          i.isSymbol = F;
          function z(O) {
            return O === void 0;
          }
          i.isUndefined = z;
          function j(O) {
            return ee(O) && ye(O) === "[object RegExp]";
          }
          i.isRegExp = j;
          function ee(O) {
            return typeof O == "object" && O !== null;
          }
          i.isObject = ee;
          function X(O) {
            return ee(O) && ye(O) === "[object Date]";
          }
          i.isDate = X;
          function ie(O) {
            return ee(O) && (ye(O) === "[object Error]" || O instanceof Error);
          }
          i.isError = ie;
          function ce(O) {
            return typeof O == "function";
          }
          i.isFunction = ce;
          function ke(O) {
            return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || // ES6 symbol
            typeof O > "u";
          }
          i.isPrimitive = ke, i.isBuffer = r("./support/isBuffer");
          function ye(O) {
            return Object.prototype.toString.call(O);
          }
          function Ce(O) {
            return O < 10 ? "0" + O.toString(10) : O.toString(10);
          }
          var Ie = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function Te() {
            var O = /* @__PURE__ */ new Date(), N = [
              Ce(O.getHours()),
              Ce(O.getMinutes()),
              Ce(O.getSeconds())
            ].join(":");
            return [O.getDate(), Ie[O.getMonth()], N].join(" ");
          }
          i.log = function() {
            console.log("%s - %s", Te(), i.format.apply(i, arguments));
          }, i.inherits = r("inherits"), i._extend = function(O, N) {
            if (!N || !ee(N)) return O;
            for (var Z = Object.keys(N), re = Z.length; re--; )
              O[Z[re]] = N[Z[re]];
            return O;
          };
          function ue(O, N) {
            return Object.prototype.hasOwnProperty.call(O, N);
          }
        }).call(this, r("_process"), typeof d_ < "u" ? d_ : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
      }, {}], 13: [function(r, n, i) {
        (function(s) {
          function o(p, h) {
            for (var d = 0, b = p.length - 1; b >= 0; b--) {
              var m = p[b];
              m === "." ? p.splice(b, 1) : m === ".." ? (p.splice(b, 1), d++) : d && (p.splice(b, 1), d--);
            }
            if (h)
              for (; d--; d)
                p.unshift("..");
            return p;
          }
          i.resolve = function() {
            for (var p = "", h = !1, d = arguments.length - 1; d >= -1 && !h; d--) {
              var b = d >= 0 ? arguments[d] : s.cwd();
              if (typeof b != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              b && (p = b + "/" + p, h = b.charAt(0) === "/");
            }
            return p = o(l(p.split("/"), function(m) {
              return !!m;
            }), !h).join("/"), (h ? "/" : "") + p || ".";
          }, i.normalize = function(p) {
            var h = i.isAbsolute(p), d = c(p, -1) === "/";
            return p = o(l(p.split("/"), function(b) {
              return !!b;
            }), !h).join("/"), !p && !h && (p = "."), p && d && (p += "/"), (h ? "/" : "") + p;
          }, i.isAbsolute = function(p) {
            return p.charAt(0) === "/";
          }, i.join = function() {
            var p = Array.prototype.slice.call(arguments, 0);
            return i.normalize(l(p, function(h, d) {
              if (typeof h != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return h;
            }).join("/"));
          }, i.relative = function(p, h) {
            p = i.resolve(p).substr(1), h = i.resolve(h).substr(1);
            function d(x) {
              for (var g = 0; g < x.length && x[g] === ""; g++)
                ;
              for (var v = x.length - 1; v >= 0 && x[v] === ""; v--)
                ;
              return g > v ? [] : x.slice(g, v - g + 1);
            }
            for (var b = d(p.split("/")), m = d(h.split("/")), w = Math.min(b.length, m.length), f = w, E = 0; E < w; E++)
              if (b[E] !== m[E]) {
                f = E;
                break;
              }
            for (var A = [], E = f; E < b.length; E++)
              A.push("..");
            return A = A.concat(m.slice(f)), A.join("/");
          }, i.sep = "/", i.delimiter = ":", i.dirname = function(p) {
            if (typeof p != "string" && (p = p + ""), p.length === 0) return ".";
            for (var h = p.charCodeAt(0), d = h === 47, b = -1, m = !0, w = p.length - 1; w >= 1; --w)
              if (h = p.charCodeAt(w), h === 47) {
                if (!m) {
                  b = w;
                  break;
                }
              } else
                m = !1;
            return b === -1 ? d ? "/" : "." : d && b === 1 ? "/" : p.slice(0, b);
          };
          function a(p) {
            typeof p != "string" && (p = p + "");
            var h = 0, d = -1, b = !0, m;
            for (m = p.length - 1; m >= 0; --m)
              if (p.charCodeAt(m) === 47) {
                if (!b) {
                  h = m + 1;
                  break;
                }
              } else d === -1 && (b = !1, d = m + 1);
            return d === -1 ? "" : p.slice(h, d);
          }
          i.basename = function(p, h) {
            var d = a(p);
            return h && d.substr(-1 * h.length) === h && (d = d.substr(0, d.length - h.length)), d;
          }, i.extname = function(p) {
            typeof p != "string" && (p = p + "");
            for (var h = -1, d = 0, b = -1, m = !0, w = 0, f = p.length - 1; f >= 0; --f) {
              var E = p.charCodeAt(f);
              if (E === 47) {
                if (!m) {
                  d = f + 1;
                  break;
                }
                continue;
              }
              b === -1 && (m = !1, b = f + 1), E === 46 ? h === -1 ? h = f : w !== 1 && (w = 1) : h !== -1 && (w = -1);
            }
            return h === -1 || b === -1 || // We saw a non-dot character immediately before the dot
            w === 0 || // The (right-most) trimmed path component is exactly '..'
            w === 1 && h === b - 1 && h === d + 1 ? "" : p.slice(h, b);
          };
          function l(p, h) {
            if (p.filter) return p.filter(h);
            for (var d = [], b = 0; b < p.length; b++)
              h(p[b], b, p) && d.push(p[b]);
            return d;
          }
          var c = "ab".substr(-1) === "b" ? function(p, h, d) {
            return p.substr(h, d);
          } : function(p, h, d) {
            return h < 0 && (h = p.length + h), p.substr(h, d);
          };
        }).call(this, r("_process"));
      }, { _process: 14 }], 14: [function(r, n, i) {
        var s = n.exports = {}, o, a;
        function l() {
          throw new Error("setTimeout has not been defined");
        }
        function c() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? o = setTimeout : o = l;
          } catch {
            o = l;
          }
          try {
            typeof clearTimeout == "function" ? a = clearTimeout : a = c;
          } catch {
            a = c;
          }
        })();
        function p(g) {
          if (o === setTimeout)
            return setTimeout(g, 0);
          if ((o === l || !o) && setTimeout)
            return o = setTimeout, setTimeout(g, 0);
          try {
            return o(g, 0);
          } catch {
            try {
              return o.call(null, g, 0);
            } catch {
              return o.call(this, g, 0);
            }
          }
        }
        function h(g) {
          if (a === clearTimeout)
            return clearTimeout(g);
          if ((a === c || !a) && clearTimeout)
            return a = clearTimeout, clearTimeout(g);
          try {
            return a(g);
          } catch {
            try {
              return a.call(null, g);
            } catch {
              return a.call(this, g);
            }
          }
        }
        var d = [], b = !1, m, w = -1;
        function f() {
          !b || !m || (b = !1, m.length ? d = m.concat(d) : w = -1, d.length && E());
        }
        function E() {
          if (!b) {
            var g = p(f);
            b = !0;
            for (var v = d.length; v; ) {
              for (m = d, d = []; ++w < v; )
                m && m[w].run();
              w = -1, v = d.length;
            }
            m = null, b = !1, h(g);
          }
        }
        s.nextTick = function(g) {
          var v = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var k = 1; k < arguments.length; k++)
              v[k - 1] = arguments[k];
          d.push(new A(g, v)), d.length === 1 && !b && p(E);
        };
        function A(g, v) {
          this.fun = g, this.array = v;
        }
        A.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
        function x() {
        }
        s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(g) {
          return [];
        }, s.binding = function(g) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(g) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 15: [function(r, n, i) {
        var s = r("escodegen").generate;
        n.exports = function(o, a) {
          a || (a = {});
          var l = {}, c = function p(h, d) {
            if (h.type === "Literal")
              return h.value;
            if (h.type === "UnaryExpression") {
              var b = p(h.argument);
              return h.operator === "+" ? +b : h.operator === "-" ? -b : h.operator === "~" ? ~b : h.operator === "!" ? !b : l;
            } else if (h.type === "ArrayExpression") {
              for (var m = [], w = 0, f = h.elements.length; w < f; w++) {
                var E = p(h.elements[w]);
                if (E === l) return l;
                m.push(E);
              }
              return m;
            } else if (h.type === "ObjectExpression") {
              for (var A = {}, w = 0; w < h.properties.length; w++) {
                var x = h.properties[w], g = x.value === null ? x.value : p(x.value);
                if (g === l) return l;
                A[x.key.value || x.key.name] = g;
              }
              return A;
            } else if (h.type === "BinaryExpression" || h.type === "LogicalExpression") {
              var f = p(h.left);
              if (f === l) return l;
              var v = p(h.right);
              if (v === l) return l;
              var k = h.operator;
              return k === "==" ? f == v : k === "===" ? f === v : k === "!=" ? f != v : k === "!==" ? f !== v : k === "+" ? f + v : k === "-" ? f - v : k === "*" ? f * v : k === "/" ? f / v : k === "%" ? f % v : k === "<" ? f < v : k === "<=" ? f <= v : k === ">" ? f > v : k === ">=" ? f >= v : k === "|" ? f | v : k === "&" ? f & v : k === "^" ? f ^ v : k === "&&" ? f && v : k === "||" ? f || v : l;
            } else {
              if (h.type === "Identifier")
                return {}.hasOwnProperty.call(a, h.name) ? a[h.name] : l;
              if (h.type === "ThisExpression")
                return {}.hasOwnProperty.call(a, "this") ? a.this : l;
              if (h.type === "CallExpression") {
                var S = p(h.callee);
                if (S === l || typeof S != "function") return l;
                var R = h.callee.object ? p(h.callee.object) : l;
                R === l && (R = null);
                for (var L = [], w = 0, f = h.arguments.length; w < f; w++) {
                  var E = p(h.arguments[w]);
                  if (E === l) return l;
                  L.push(E);
                }
                return S.apply(R, L);
              } else if (h.type === "MemberExpression") {
                var A = p(h.object);
                if (A === l || typeof A == "function")
                  return l;
                if (h.property.type === "Identifier")
                  return A[h.property.name];
                var x = p(h.property);
                return x === l ? l : A[x];
              } else if (h.type === "ConditionalExpression") {
                var b = p(h.test);
                return b === l ? l : p(b ? h.consequent : h.alternate);
              } else if (h.type === "ExpressionStatement") {
                var b = p(h.expression);
                return b === l ? l : b;
              } else {
                if (h.type === "ReturnStatement")
                  return p(h.argument);
                if (h.type === "FunctionExpression") {
                  var F = h.body.body, z = {};
                  Object.keys(a).forEach(function(Ie) {
                    z[Ie] = a[Ie];
                  });
                  for (var w = 0; w < h.params.length; w++) {
                    var j = h.params[w];
                    if (j.type == "Identifier")
                      a[j.name] = null;
                    else return l;
                  }
                  for (var w in F)
                    if (p(F[w]) === l)
                      return l;
                  a = z;
                  var ee = Object.keys(a), X = ee.map(function(Ie) {
                    return a[Ie];
                  });
                  return Function(ee.join(", "), "return " + s(h)).apply(null, X);
                } else if (h.type === "TemplateLiteral") {
                  for (var ie = "", w = 0; w < h.expressions.length; w++)
                    ie += p(h.quasis[w]), ie += p(h.expressions[w]);
                  return ie += p(h.quasis[w]), ie;
                } else if (h.type === "TaggedTemplateExpression") {
                  var ce = p(h.tag), ke = h.quasi, ye = ke.quasis.map(p), Ce = ke.expressions.map(p);
                  return ce.apply(null, [ye].concat(Ce));
                } else return h.type === "TemplateElement" ? h.value.cooked : l;
              }
            }
          }(o);
          return c === l ? void 0 : c;
        };
      }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
        n.exports = r("./lib/index");
      }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
    });
  }(__)), __.exports;
}
eye();
const tye = "https://fizz.studio/schema/manifest.schema.json", rye = {
  $id: tye
};
rye.$id;
function nye(t) {
  const e = t.datasets[0];
  if (e.data.source !== "inline")
    throw new Error("only manifests with inline data can use this function.");
  const r = {};
  for (const n of e.series)
    r[n.key] = n.records;
  return r;
}
function Q$(t) {
  return new Set(...t.map((e) => e.x));
}
function iye(t, e) {
  return t.size === e.size && t.isSubsetOf(e);
}
function sye(t) {
  let e = null;
  for (const r in t) {
    const n = t[r], i = Q$(n);
    if (i.size !== n.length)
      return !1;
    if (e === null)
      e = i;
    else if (!iye(i, e))
      return !1;
  }
  return !0;
}
function Au(t) {
  return t.toLowerCase().replace(/\s+/g, "_").replace(/[^\w-]+/g, "_");
}
const I_ = {
  line: "line",
  stepline: "line",
  bar: "bar",
  column: "bar",
  lollipop: "bar",
  histogram: "histogram",
  scatter: "scatter",
  heatmap: "scatter",
  pie: "pastry",
  donut: "pastry",
  graph: "graph"
};
(() => {
  const t = {
    line: [],
    bar: [],
    pastry: [],
    scatter: [],
    histogram: [],
    graph: []
  };
  for (let e of Object.keys(I_))
    t[I_[e]].push(e);
  return t;
})();
const oye = {
  bar: "column",
  column: "column",
  lollipop: "column",
  histogram: "column",
  line: "line",
  stepline: "line",
  graph: "line",
  scatter: "other",
  heatmap: "other",
  pie: "other",
  donut: "other"
};
let Mw = class extends Error {
  constructor(e) {
    super(`[jimifier]: ${e}`);
  }
}, aye = class {
  constructor(e, r) {
    if (this._manifest = e, this._dataset = this._manifest.datasets[0], this._dataset.data.source === "inline")
      this._data = nye(this._manifest);
    else if (r)
      this._data = r;
    else
      throw new Mw("JIM cannot be created without external or inline chart data");
    this._seriesKeys = Object.keys(this._data);
  }
  get jim() {
    return this._jim;
  }
  _addSelectorsOrdered(e) {
    let r = 1;
    const n = Q$(this._data[this._seriesKeys[0]]);
    this._seriesKeys.forEach((i, s) => {
      n.forEach((o, a) => {
        e[`datapoint${r}`] = {
          dom: `#datapoint-${Au(o)}_${Au(i)}`,
          json: [
            `$.datasets[0].series[${s}].name`,
            `$.datasets[0].series[${s}].records[${a}].*`
          ]
        }, r++;
      });
    });
  }
  _addSelectorsUnordered(e) {
    let r = 1;
    Object.keys(this._data).forEach((n, i) => {
      this._data[n].forEach((s, o) => {
        const a = Au(s.x), l = Au(s.y);
        e[`datapoint${r}`] = {
          dom: `#datapoint-${a}_${l}_${Au(n)}`,
          json: [
            `$.datasets[0].series[${i}].name`,
            `$.datasets[0].series[${i}].records[${o}].*`
          ]
        }, r++;
      });
    });
  }
  _renderSelectors() {
    const e = {
      chartTitle: {
        dom: "#chart-title",
        json: "$.datasets[0].title"
      }
    };
    return sye(this._data) ? this._addSelectorsOrdered(e) : this._addSelectorsUnordered(e), e;
  }
  render() {
    const e = {
      title: this._dataset.title,
      facets: this._dataset.facets,
      series: []
    };
    e.series = this._dataset.series.map((i) => ({
      name: i.key,
      type: oye[this._dataset.type],
      records: this._data[i.key]
    }));
    const r = this._renderSelectors(), n = this._renderBehaviors();
    this._jim = {
      datasets: [e],
      selectors: r,
      behaviors: n,
      version: { jim: "0.4.0" }
    };
  }
  addSeriesSummary(e, r) {
    if (!this._jim)
      throw new Mw("JIM must be rendered before adding series summary");
    const n = this._seriesKeys.indexOf(e);
    if (n === -1)
      throw new Mw(`Series key "${e}" not found`);
    this._jim.datasets[0].series[n].description = r;
    const i = `seriesSummary_${Au(e)}`;
    this._jim.selectors[i] = {
      dom: `#series-${Au(e)}`,
      json: `$.datasets[0].series[${n}].description`
    };
  }
  _renderBehaviors() {
    const e = [];
    return this._seriesKeys.forEach((r, n) => {
      e.push({
        target: {
          selector: `$.selectors.seriesSummary_${r}`
        },
        enter: {
          haptic: {
            durations: [0, 125, 125, 125, 125, 125, 125, 125],
            repeatInterval: 125
          },
          audio: {
            earcon: "PewPew",
            repeat: "none"
          }
        },
        details: {
          announcement: {
            path: `$.datasets[0].series[${n}].description`
          }
        }
      });
    }), e;
  }
};
var Xl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, zm = {}, K$ = {}, Tb = {};
Tb.byteLength = uye;
Tb.toByteArray = pye;
Tb.fromByteArray = gye;
var Po = [], ns = [], lye = typeof Uint8Array < "u" ? Uint8Array : Array, Nw = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var sp = 0, cye = Nw.length; sp < cye; ++sp)
  Po[sp] = Nw[sp], ns[Nw.charCodeAt(sp)] = sp;
ns[45] = 62;
ns[95] = 63;
function Y$(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = t.indexOf("=");
  r === -1 && (r = e);
  var n = r === e ? 0 : 4 - r % 4;
  return [r, n];
}
function uye(t) {
  var e = Y$(t), r = e[0], n = e[1];
  return (r + n) * 3 / 4 - n;
}
function hye(t, e, r) {
  return (e + r) * 3 / 4 - r;
}
function pye(t) {
  var e, r = Y$(t), n = r[0], i = r[1], s = new lye(hye(t, n, i)), o = 0, a = i > 0 ? n - 4 : n, l;
  for (l = 0; l < a; l += 4)
    e = ns[t.charCodeAt(l)] << 18 | ns[t.charCodeAt(l + 1)] << 12 | ns[t.charCodeAt(l + 2)] << 6 | ns[t.charCodeAt(l + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
  return i === 2 && (e = ns[t.charCodeAt(l)] << 2 | ns[t.charCodeAt(l + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = ns[t.charCodeAt(l)] << 10 | ns[t.charCodeAt(l + 1)] << 4 | ns[t.charCodeAt(l + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
}
function dye(t) {
  return Po[t >> 18 & 63] + Po[t >> 12 & 63] + Po[t >> 6 & 63] + Po[t & 63];
}
function fye(t, e, r) {
  for (var n, i = [], s = e; s < r; s += 3)
    n = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (t[s + 2] & 255), i.push(dye(n));
  return i.join("");
}
function gye(t) {
  for (var e, r = t.length, n = r % 3, i = [], s = 16383, o = 0, a = r - n; o < a; o += s)
    i.push(fye(t, o, o + s > a ? a : o + s));
  return n === 1 ? (e = t[r - 1], i.push(
    Po[e >> 2] + Po[e << 4 & 63] + "=="
  )) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i.push(
    Po[e >> 10] + Po[e >> 4 & 63] + Po[e << 2 & 63] + "="
  )), i.join("");
}
var fS = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
fS.read = function(t, e, r, n, i) {
  var s, o, a = i * 8 - n - 1, l = (1 << a) - 1, c = l >> 1, p = -7, h = r ? i - 1 : 0, d = r ? -1 : 1, b = t[e + h];
  for (h += d, s = b & (1 << -p) - 1, b >>= -p, p += a; p > 0; s = s * 256 + t[e + h], h += d, p -= 8)
    ;
  for (o = s & (1 << -p) - 1, s >>= -p, p += n; p > 0; o = o * 256 + t[e + h], h += d, p -= 8)
    ;
  if (s === 0)
    s = 1 - c;
  else {
    if (s === l)
      return o ? NaN : (b ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, n), s = s - c;
  }
  return (b ? -1 : 1) * o * Math.pow(2, s - n);
};
fS.write = function(t, e, r, n, i, s) {
  var o, a, l, c = s * 8 - i - 1, p = (1 << c) - 1, h = p >> 1, d = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, b = n ? 0 : s - 1, m = n ? 1 : -1, w = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = p) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + h >= 1 ? e += d / l : e += d * Math.pow(2, 1 - h), e * l >= 2 && (o++, l /= 2), o + h >= p ? (a = 0, o = p) : o + h >= 1 ? (a = (e * l - 1) * Math.pow(2, i), o = o + h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i), o = 0)); i >= 8; t[r + b] = a & 255, b += m, a /= 256, i -= 8)
    ;
  for (o = o << i | a, c += i; c > 0; t[r + b] = o & 255, b += m, o /= 256, c -= 8)
    ;
  t[r + b - m] |= w * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  const e = Tb, r = fS, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = p, t.SlowBuffer = v, t.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  t.kMaxLength = i;
  const { Uint8Array: s, ArrayBuffer: o, SharedArrayBuffer: a } = globalThis;
  p.TYPED_ARRAY_SUPPORT = l(), !p.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function l() {
    try {
      const C = new s(1), $ = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf($, s.prototype), Object.setPrototypeOf(C, $), C.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(p.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (p.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(p.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (p.isBuffer(this))
        return this.byteOffset;
    }
  });
  function c(C) {
    if (C > i)
      throw new RangeError('The value "' + C + '" is invalid for option "size"');
    const $ = new s(C);
    return Object.setPrototypeOf($, p.prototype), $;
  }
  function p(C, $, D) {
    if (typeof C == "number") {
      if (typeof $ == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return m(C);
    }
    return h(C, $, D);
  }
  p.poolSize = 8192;
  function h(C, $, D) {
    if (typeof C == "string")
      return w(C, $);
    if (o.isView(C))
      return E(C);
    if (C == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C
      );
    if (kt(C, o) || C && kt(C.buffer, o) || typeof a < "u" && (kt(C, a) || C && kt(C.buffer, a)))
      return A(C, $, D);
    if (typeof C == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const ae = C.valueOf && C.valueOf();
    if (ae != null && ae !== C)
      return p.from(ae, $, D);
    const pe = x(C);
    if (pe) return pe;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof C[Symbol.toPrimitive] == "function")
      return p.from(C[Symbol.toPrimitive]("string"), $, D);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C
    );
  }
  p.from = function(C, $, D) {
    return h(C, $, D);
  }, Object.setPrototypeOf(p.prototype, s.prototype), Object.setPrototypeOf(p, s);
  function d(C) {
    if (typeof C != "number")
      throw new TypeError('"size" argument must be of type number');
    if (C < 0)
      throw new RangeError('The value "' + C + '" is invalid for option "size"');
  }
  function b(C, $, D) {
    return d(C), C <= 0 ? c(C) : $ !== void 0 ? typeof D == "string" ? c(C).fill($, D) : c(C).fill($) : c(C);
  }
  p.alloc = function(C, $, D) {
    return b(C, $, D);
  };
  function m(C) {
    return d(C), c(C < 0 ? 0 : g(C) | 0);
  }
  p.allocUnsafe = function(C) {
    return m(C);
  }, p.allocUnsafeSlow = function(C) {
    return m(C);
  };
  function w(C, $) {
    if ((typeof $ != "string" || $ === "") && ($ = "utf8"), !p.isEncoding($))
      throw new TypeError("Unknown encoding: " + $);
    const D = k(C, $) | 0;
    let ae = c(D);
    const pe = ae.write(C, $);
    return pe !== D && (ae = ae.slice(0, pe)), ae;
  }
  function f(C) {
    const $ = C.length < 0 ? 0 : g(C.length) | 0, D = c($);
    for (let ae = 0; ae < $; ae += 1)
      D[ae] = C[ae] & 255;
    return D;
  }
  function E(C) {
    if (kt(C, s)) {
      const $ = new s(C);
      return A($.buffer, $.byteOffset, $.byteLength);
    }
    return f(C);
  }
  function A(C, $, D) {
    if ($ < 0 || C.byteLength < $)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (C.byteLength < $ + (D || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let ae;
    return $ === void 0 && D === void 0 ? ae = new s(C) : D === void 0 ? ae = new s(C, $) : ae = new s(C, $, D), Object.setPrototypeOf(ae, p.prototype), ae;
  }
  function x(C) {
    if (p.isBuffer(C)) {
      const $ = g(C.length) | 0, D = c($);
      return D.length === 0 || C.copy(D, 0, 0, $), D;
    }
    if (C.length !== void 0)
      return typeof C.length != "number" || Ze(C.length) ? c(0) : f(C);
    if (C.type === "Buffer" && Array.isArray(C.data))
      return f(C.data);
  }
  function g(C) {
    if (C >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return C | 0;
  }
  function v(C) {
    return +C != C && (C = 0), p.alloc(+C);
  }
  p.isBuffer = function(C) {
    return C != null && C._isBuffer === !0 && C !== p.prototype;
  }, p.compare = function(C, $) {
    if (kt(C, s) && (C = p.from(C, C.offset, C.byteLength)), kt($, s) && ($ = p.from($, $.offset, $.byteLength)), !p.isBuffer(C) || !p.isBuffer($))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (C === $) return 0;
    let D = C.length, ae = $.length;
    for (let pe = 0, Ee = Math.min(D, ae); pe < Ee; ++pe)
      if (C[pe] !== $[pe]) {
        D = C[pe], ae = $[pe];
        break;
      }
    return D < ae ? -1 : ae < D ? 1 : 0;
  }, p.isEncoding = function(C) {
    switch (String(C).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, p.concat = function(C, $) {
    if (!Array.isArray(C))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (C.length === 0)
      return p.alloc(0);
    let D;
    if ($ === void 0)
      for ($ = 0, D = 0; D < C.length; ++D)
        $ += C[D].length;
    const ae = p.allocUnsafe($);
    let pe = 0;
    for (D = 0; D < C.length; ++D) {
      let Ee = C[D];
      if (kt(Ee, s))
        pe + Ee.length > ae.length ? (p.isBuffer(Ee) || (Ee = p.from(Ee)), Ee.copy(ae, pe)) : s.prototype.set.call(
          ae,
          Ee,
          pe
        );
      else if (p.isBuffer(Ee))
        Ee.copy(ae, pe);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      pe += Ee.length;
    }
    return ae;
  };
  function k(C, $) {
    if (p.isBuffer(C))
      return C.length;
    if (o.isView(C) || kt(C, o))
      return C.byteLength;
    if (typeof C != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof C
      );
    const D = C.length, ae = arguments.length > 2 && arguments[2] === !0;
    if (!ae && D === 0) return 0;
    let pe = !1;
    for (; ; )
      switch ($) {
        case "ascii":
        case "latin1":
        case "binary":
          return D;
        case "utf8":
        case "utf-8":
          return At(C).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return D * 2;
        case "hex":
          return D >>> 1;
        case "base64":
          return ht(C).length;
        default:
          if (pe)
            return ae ? -1 : At(C).length;
          $ = ("" + $).toLowerCase(), pe = !0;
      }
  }
  p.byteLength = k;
  function S(C, $, D) {
    let ae = !1;
    if (($ === void 0 || $ < 0) && ($ = 0), $ > this.length || ((D === void 0 || D > this.length) && (D = this.length), D <= 0) || (D >>>= 0, $ >>>= 0, D <= $))
      return "";
    for (C || (C = "utf8"); ; )
      switch (C) {
        case "hex":
          return ue(this, $, D);
        case "utf8":
        case "utf-8":
          return ke(this, $, D);
        case "ascii":
          return Ie(this, $, D);
        case "latin1":
        case "binary":
          return Te(this, $, D);
        case "base64":
          return ce(this, $, D);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return O(this, $, D);
        default:
          if (ae) throw new TypeError("Unknown encoding: " + C);
          C = (C + "").toLowerCase(), ae = !0;
      }
  }
  p.prototype._isBuffer = !0;
  function R(C, $, D) {
    const ae = C[$];
    C[$] = C[D], C[D] = ae;
  }
  p.prototype.swap16 = function() {
    const C = this.length;
    if (C % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let $ = 0; $ < C; $ += 2)
      R(this, $, $ + 1);
    return this;
  }, p.prototype.swap32 = function() {
    const C = this.length;
    if (C % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let $ = 0; $ < C; $ += 4)
      R(this, $, $ + 3), R(this, $ + 1, $ + 2);
    return this;
  }, p.prototype.swap64 = function() {
    const C = this.length;
    if (C % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let $ = 0; $ < C; $ += 8)
      R(this, $, $ + 7), R(this, $ + 1, $ + 6), R(this, $ + 2, $ + 5), R(this, $ + 3, $ + 4);
    return this;
  }, p.prototype.toString = function() {
    const C = this.length;
    return C === 0 ? "" : arguments.length === 0 ? ke(this, 0, C) : S.apply(this, arguments);
  }, p.prototype.toLocaleString = p.prototype.toString, p.prototype.equals = function(C) {
    if (!p.isBuffer(C)) throw new TypeError("Argument must be a Buffer");
    return this === C ? !0 : p.compare(this, C) === 0;
  }, p.prototype.inspect = function() {
    let C = "";
    const $ = t.INSPECT_MAX_BYTES;
    return C = this.toString("hex", 0, $).replace(/(.{2})/g, "$1 ").trim(), this.length > $ && (C += " ... "), "<Buffer " + C + ">";
  }, n && (p.prototype[n] = p.prototype.inspect), p.prototype.compare = function(C, $, D, ae, pe) {
    if (kt(C, s) && (C = p.from(C, C.offset, C.byteLength)), !p.isBuffer(C))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof C
      );
    if ($ === void 0 && ($ = 0), D === void 0 && (D = C ? C.length : 0), ae === void 0 && (ae = 0), pe === void 0 && (pe = this.length), $ < 0 || D > C.length || ae < 0 || pe > this.length)
      throw new RangeError("out of range index");
    if (ae >= pe && $ >= D)
      return 0;
    if (ae >= pe)
      return -1;
    if ($ >= D)
      return 1;
    if ($ >>>= 0, D >>>= 0, ae >>>= 0, pe >>>= 0, this === C) return 0;
    let Ee = pe - ae, Me = D - $;
    const ot = Math.min(Ee, Me), dt = this.slice(ae, pe), St = C.slice($, D);
    for (let rt = 0; rt < ot; ++rt)
      if (dt[rt] !== St[rt]) {
        Ee = dt[rt], Me = St[rt];
        break;
      }
    return Ee < Me ? -1 : Me < Ee ? 1 : 0;
  };
  function L(C, $, D, ae, pe) {
    if (C.length === 0) return -1;
    if (typeof D == "string" ? (ae = D, D = 0) : D > 2147483647 ? D = 2147483647 : D < -2147483648 && (D = -2147483648), D = +D, Ze(D) && (D = pe ? 0 : C.length - 1), D < 0 && (D = C.length + D), D >= C.length) {
      if (pe) return -1;
      D = C.length - 1;
    } else if (D < 0)
      if (pe) D = 0;
      else return -1;
    if (typeof $ == "string" && ($ = p.from($, ae)), p.isBuffer($))
      return $.length === 0 ? -1 : F(C, $, D, ae, pe);
    if (typeof $ == "number")
      return $ = $ & 255, typeof s.prototype.indexOf == "function" ? pe ? s.prototype.indexOf.call(C, $, D) : s.prototype.lastIndexOf.call(C, $, D) : F(C, [$], D, ae, pe);
    throw new TypeError("val must be string, number or Buffer");
  }
  function F(C, $, D, ae, pe) {
    let Ee = 1, Me = C.length, ot = $.length;
    if (ae !== void 0 && (ae = String(ae).toLowerCase(), ae === "ucs2" || ae === "ucs-2" || ae === "utf16le" || ae === "utf-16le")) {
      if (C.length < 2 || $.length < 2)
        return -1;
      Ee = 2, Me /= 2, ot /= 2, D /= 2;
    }
    function dt(rt, zt) {
      return Ee === 1 ? rt[zt] : rt.readUInt16BE(zt * Ee);
    }
    let St;
    if (pe) {
      let rt = -1;
      for (St = D; St < Me; St++)
        if (dt(C, St) === dt($, rt === -1 ? 0 : St - rt)) {
          if (rt === -1 && (rt = St), St - rt + 1 === ot) return rt * Ee;
        } else
          rt !== -1 && (St -= St - rt), rt = -1;
    } else
      for (D + ot > Me && (D = Me - ot), St = D; St >= 0; St--) {
        let rt = !0;
        for (let zt = 0; zt < ot; zt++)
          if (dt(C, St + zt) !== dt($, zt)) {
            rt = !1;
            break;
          }
        if (rt) return St;
      }
    return -1;
  }
  p.prototype.includes = function(C, $, D) {
    return this.indexOf(C, $, D) !== -1;
  }, p.prototype.indexOf = function(C, $, D) {
    return L(this, C, $, D, !0);
  }, p.prototype.lastIndexOf = function(C, $, D) {
    return L(this, C, $, D, !1);
  };
  function z(C, $, D, ae) {
    D = Number(D) || 0;
    const pe = C.length - D;
    ae ? (ae = Number(ae), ae > pe && (ae = pe)) : ae = pe;
    const Ee = $.length;
    ae > Ee / 2 && (ae = Ee / 2);
    let Me;
    for (Me = 0; Me < ae; ++Me) {
      const ot = parseInt($.substr(Me * 2, 2), 16);
      if (Ze(ot)) return Me;
      C[D + Me] = ot;
    }
    return Me;
  }
  function j(C, $, D, ae) {
    return it(At($, C.length - D), C, D, ae);
  }
  function ee(C, $, D, ae) {
    return it(er($), C, D, ae);
  }
  function X(C, $, D, ae) {
    return it(ht($), C, D, ae);
  }
  function ie(C, $, D, ae) {
    return it(me($, C.length - D), C, D, ae);
  }
  p.prototype.write = function(C, $, D, ae) {
    if ($ === void 0)
      ae = "utf8", D = this.length, $ = 0;
    else if (D === void 0 && typeof $ == "string")
      ae = $, D = this.length, $ = 0;
    else if (isFinite($))
      $ = $ >>> 0, isFinite(D) ? (D = D >>> 0, ae === void 0 && (ae = "utf8")) : (ae = D, D = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const pe = this.length - $;
    if ((D === void 0 || D > pe) && (D = pe), C.length > 0 && (D < 0 || $ < 0) || $ > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ae || (ae = "utf8");
    let Ee = !1;
    for (; ; )
      switch (ae) {
        case "hex":
          return z(this, C, $, D);
        case "utf8":
        case "utf-8":
          return j(this, C, $, D);
        case "ascii":
        case "latin1":
        case "binary":
          return ee(this, C, $, D);
        case "base64":
          return X(this, C, $, D);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ie(this, C, $, D);
        default:
          if (Ee) throw new TypeError("Unknown encoding: " + ae);
          ae = ("" + ae).toLowerCase(), Ee = !0;
      }
  }, p.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ce(C, $, D) {
    return $ === 0 && D === C.length ? e.fromByteArray(C) : e.fromByteArray(C.slice($, D));
  }
  function ke(C, $, D) {
    D = Math.min(C.length, D);
    const ae = [];
    let pe = $;
    for (; pe < D; ) {
      const Ee = C[pe];
      let Me = null, ot = Ee > 239 ? 4 : Ee > 223 ? 3 : Ee > 191 ? 2 : 1;
      if (pe + ot <= D) {
        let dt, St, rt, zt;
        switch (ot) {
          case 1:
            Ee < 128 && (Me = Ee);
            break;
          case 2:
            dt = C[pe + 1], (dt & 192) === 128 && (zt = (Ee & 31) << 6 | dt & 63, zt > 127 && (Me = zt));
            break;
          case 3:
            dt = C[pe + 1], St = C[pe + 2], (dt & 192) === 128 && (St & 192) === 128 && (zt = (Ee & 15) << 12 | (dt & 63) << 6 | St & 63, zt > 2047 && (zt < 55296 || zt > 57343) && (Me = zt));
            break;
          case 4:
            dt = C[pe + 1], St = C[pe + 2], rt = C[pe + 3], (dt & 192) === 128 && (St & 192) === 128 && (rt & 192) === 128 && (zt = (Ee & 15) << 18 | (dt & 63) << 12 | (St & 63) << 6 | rt & 63, zt > 65535 && zt < 1114112 && (Me = zt));
        }
      }
      Me === null ? (Me = 65533, ot = 1) : Me > 65535 && (Me -= 65536, ae.push(Me >>> 10 & 1023 | 55296), Me = 56320 | Me & 1023), ae.push(Me), pe += ot;
    }
    return Ce(ae);
  }
  const ye = 4096;
  function Ce(C) {
    const $ = C.length;
    if ($ <= ye)
      return String.fromCharCode.apply(String, C);
    let D = "", ae = 0;
    for (; ae < $; )
      D += String.fromCharCode.apply(
        String,
        C.slice(ae, ae += ye)
      );
    return D;
  }
  function Ie(C, $, D) {
    let ae = "";
    D = Math.min(C.length, D);
    for (let pe = $; pe < D; ++pe)
      ae += String.fromCharCode(C[pe] & 127);
    return ae;
  }
  function Te(C, $, D) {
    let ae = "";
    D = Math.min(C.length, D);
    for (let pe = $; pe < D; ++pe)
      ae += String.fromCharCode(C[pe]);
    return ae;
  }
  function ue(C, $, D) {
    const ae = C.length;
    (!$ || $ < 0) && ($ = 0), (!D || D < 0 || D > ae) && (D = ae);
    let pe = "";
    for (let Ee = $; Ee < D; ++Ee)
      pe += ge[C[Ee]];
    return pe;
  }
  function O(C, $, D) {
    const ae = C.slice($, D);
    let pe = "";
    for (let Ee = 0; Ee < ae.length - 1; Ee += 2)
      pe += String.fromCharCode(ae[Ee] + ae[Ee + 1] * 256);
    return pe;
  }
  p.prototype.slice = function(C, $) {
    const D = this.length;
    C = ~~C, $ = $ === void 0 ? D : ~~$, C < 0 ? (C += D, C < 0 && (C = 0)) : C > D && (C = D), $ < 0 ? ($ += D, $ < 0 && ($ = 0)) : $ > D && ($ = D), $ < C && ($ = C);
    const ae = this.subarray(C, $);
    return Object.setPrototypeOf(ae, p.prototype), ae;
  };
  function N(C, $, D) {
    if (C % 1 !== 0 || C < 0) throw new RangeError("offset is not uint");
    if (C + $ > D) throw new RangeError("Trying to access beyond buffer length");
  }
  p.prototype.readUintLE = p.prototype.readUIntLE = function(C, $, D) {
    C = C >>> 0, $ = $ >>> 0, D || N(C, $, this.length);
    let ae = this[C], pe = 1, Ee = 0;
    for (; ++Ee < $ && (pe *= 256); )
      ae += this[C + Ee] * pe;
    return ae;
  }, p.prototype.readUintBE = p.prototype.readUIntBE = function(C, $, D) {
    C = C >>> 0, $ = $ >>> 0, D || N(C, $, this.length);
    let ae = this[C + --$], pe = 1;
    for (; $ > 0 && (pe *= 256); )
      ae += this[C + --$] * pe;
    return ae;
  }, p.prototype.readUint8 = p.prototype.readUInt8 = function(C, $) {
    return C = C >>> 0, $ || N(C, 1, this.length), this[C];
  }, p.prototype.readUint16LE = p.prototype.readUInt16LE = function(C, $) {
    return C = C >>> 0, $ || N(C, 2, this.length), this[C] | this[C + 1] << 8;
  }, p.prototype.readUint16BE = p.prototype.readUInt16BE = function(C, $) {
    return C = C >>> 0, $ || N(C, 2, this.length), this[C] << 8 | this[C + 1];
  }, p.prototype.readUint32LE = p.prototype.readUInt32LE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), (this[C] | this[C + 1] << 8 | this[C + 2] << 16) + this[C + 3] * 16777216;
  }, p.prototype.readUint32BE = p.prototype.readUInt32BE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), this[C] * 16777216 + (this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3]);
  }, p.prototype.readBigUInt64LE = be(function(C) {
    C = C >>> 0, Le(C, "offset");
    const $ = this[C], D = this[C + 7];
    ($ === void 0 || D === void 0) && ze(C, this.length - 8);
    const ae = $ + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24, pe = this[++C] + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + D * 2 ** 24;
    return BigInt(ae) + (BigInt(pe) << BigInt(32));
  }), p.prototype.readBigUInt64BE = be(function(C) {
    C = C >>> 0, Le(C, "offset");
    const $ = this[C], D = this[C + 7];
    ($ === void 0 || D === void 0) && ze(C, this.length - 8);
    const ae = $ * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C], pe = this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + D;
    return (BigInt(ae) << BigInt(32)) + BigInt(pe);
  }), p.prototype.readIntLE = function(C, $, D) {
    C = C >>> 0, $ = $ >>> 0, D || N(C, $, this.length);
    let ae = this[C], pe = 1, Ee = 0;
    for (; ++Ee < $ && (pe *= 256); )
      ae += this[C + Ee] * pe;
    return pe *= 128, ae >= pe && (ae -= Math.pow(2, 8 * $)), ae;
  }, p.prototype.readIntBE = function(C, $, D) {
    C = C >>> 0, $ = $ >>> 0, D || N(C, $, this.length);
    let ae = $, pe = 1, Ee = this[C + --ae];
    for (; ae > 0 && (pe *= 256); )
      Ee += this[C + --ae] * pe;
    return pe *= 128, Ee >= pe && (Ee -= Math.pow(2, 8 * $)), Ee;
  }, p.prototype.readInt8 = function(C, $) {
    return C = C >>> 0, $ || N(C, 1, this.length), this[C] & 128 ? (255 - this[C] + 1) * -1 : this[C];
  }, p.prototype.readInt16LE = function(C, $) {
    C = C >>> 0, $ || N(C, 2, this.length);
    const D = this[C] | this[C + 1] << 8;
    return D & 32768 ? D | 4294901760 : D;
  }, p.prototype.readInt16BE = function(C, $) {
    C = C >>> 0, $ || N(C, 2, this.length);
    const D = this[C + 1] | this[C] << 8;
    return D & 32768 ? D | 4294901760 : D;
  }, p.prototype.readInt32LE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), this[C] | this[C + 1] << 8 | this[C + 2] << 16 | this[C + 3] << 24;
  }, p.prototype.readInt32BE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), this[C] << 24 | this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3];
  }, p.prototype.readBigInt64LE = be(function(C) {
    C = C >>> 0, Le(C, "offset");
    const $ = this[C], D = this[C + 7];
    ($ === void 0 || D === void 0) && ze(C, this.length - 8);
    const ae = this[C + 4] + this[C + 5] * 2 ** 8 + this[C + 6] * 2 ** 16 + (D << 24);
    return (BigInt(ae) << BigInt(32)) + BigInt($ + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24);
  }), p.prototype.readBigInt64BE = be(function(C) {
    C = C >>> 0, Le(C, "offset");
    const $ = this[C], D = this[C + 7];
    ($ === void 0 || D === void 0) && ze(C, this.length - 8);
    const ae = ($ << 24) + // Overflow
    this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C];
    return (BigInt(ae) << BigInt(32)) + BigInt(this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + D);
  }), p.prototype.readFloatLE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), r.read(this, C, !0, 23, 4);
  }, p.prototype.readFloatBE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), r.read(this, C, !1, 23, 4);
  }, p.prototype.readDoubleLE = function(C, $) {
    return C = C >>> 0, $ || N(C, 8, this.length), r.read(this, C, !0, 52, 8);
  }, p.prototype.readDoubleBE = function(C, $) {
    return C = C >>> 0, $ || N(C, 8, this.length), r.read(this, C, !1, 52, 8);
  };
  function Z(C, $, D, ae, pe, Ee) {
    if (!p.isBuffer(C)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if ($ > pe || $ < Ee) throw new RangeError('"value" argument is out of bounds');
    if (D + ae > C.length) throw new RangeError("Index out of range");
  }
  p.prototype.writeUintLE = p.prototype.writeUIntLE = function(C, $, D, ae) {
    if (C = +C, $ = $ >>> 0, D = D >>> 0, !ae) {
      const Me = Math.pow(2, 8 * D) - 1;
      Z(this, C, $, D, Me, 0);
    }
    let pe = 1, Ee = 0;
    for (this[$] = C & 255; ++Ee < D && (pe *= 256); )
      this[$ + Ee] = C / pe & 255;
    return $ + D;
  }, p.prototype.writeUintBE = p.prototype.writeUIntBE = function(C, $, D, ae) {
    if (C = +C, $ = $ >>> 0, D = D >>> 0, !ae) {
      const Me = Math.pow(2, 8 * D) - 1;
      Z(this, C, $, D, Me, 0);
    }
    let pe = D - 1, Ee = 1;
    for (this[$ + pe] = C & 255; --pe >= 0 && (Ee *= 256); )
      this[$ + pe] = C / Ee & 255;
    return $ + D;
  }, p.prototype.writeUint8 = p.prototype.writeUInt8 = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 1, 255, 0), this[$] = C & 255, $ + 1;
  }, p.prototype.writeUint16LE = p.prototype.writeUInt16LE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 2, 65535, 0), this[$] = C & 255, this[$ + 1] = C >>> 8, $ + 2;
  }, p.prototype.writeUint16BE = p.prototype.writeUInt16BE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 2, 65535, 0), this[$] = C >>> 8, this[$ + 1] = C & 255, $ + 2;
  }, p.prototype.writeUint32LE = p.prototype.writeUInt32LE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 4, 4294967295, 0), this[$ + 3] = C >>> 24, this[$ + 2] = C >>> 16, this[$ + 1] = C >>> 8, this[$] = C & 255, $ + 4;
  }, p.prototype.writeUint32BE = p.prototype.writeUInt32BE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 4, 4294967295, 0), this[$] = C >>> 24, this[$ + 1] = C >>> 16, this[$ + 2] = C >>> 8, this[$ + 3] = C & 255, $ + 4;
  };
  function re(C, $, D, ae, pe) {
    Fe($, ae, pe, C, D, 7);
    let Ee = Number($ & BigInt(4294967295));
    C[D++] = Ee, Ee = Ee >> 8, C[D++] = Ee, Ee = Ee >> 8, C[D++] = Ee, Ee = Ee >> 8, C[D++] = Ee;
    let Me = Number($ >> BigInt(32) & BigInt(4294967295));
    return C[D++] = Me, Me = Me >> 8, C[D++] = Me, Me = Me >> 8, C[D++] = Me, Me = Me >> 8, C[D++] = Me, D;
  }
  function le(C, $, D, ae, pe) {
    Fe($, ae, pe, C, D, 7);
    let Ee = Number($ & BigInt(4294967295));
    C[D + 7] = Ee, Ee = Ee >> 8, C[D + 6] = Ee, Ee = Ee >> 8, C[D + 5] = Ee, Ee = Ee >> 8, C[D + 4] = Ee;
    let Me = Number($ >> BigInt(32) & BigInt(4294967295));
    return C[D + 3] = Me, Me = Me >> 8, C[D + 2] = Me, Me = Me >> 8, C[D + 1] = Me, Me = Me >> 8, C[D] = Me, D + 8;
  }
  p.prototype.writeBigUInt64LE = be(function(C, $ = 0) {
    return re(this, C, $, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeBigUInt64BE = be(function(C, $ = 0) {
    return le(this, C, $, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeIntLE = function(C, $, D, ae) {
    if (C = +C, $ = $ >>> 0, !ae) {
      const ot = Math.pow(2, 8 * D - 1);
      Z(this, C, $, D, ot - 1, -ot);
    }
    let pe = 0, Ee = 1, Me = 0;
    for (this[$] = C & 255; ++pe < D && (Ee *= 256); )
      C < 0 && Me === 0 && this[$ + pe - 1] !== 0 && (Me = 1), this[$ + pe] = (C / Ee >> 0) - Me & 255;
    return $ + D;
  }, p.prototype.writeIntBE = function(C, $, D, ae) {
    if (C = +C, $ = $ >>> 0, !ae) {
      const ot = Math.pow(2, 8 * D - 1);
      Z(this, C, $, D, ot - 1, -ot);
    }
    let pe = D - 1, Ee = 1, Me = 0;
    for (this[$ + pe] = C & 255; --pe >= 0 && (Ee *= 256); )
      C < 0 && Me === 0 && this[$ + pe + 1] !== 0 && (Me = 1), this[$ + pe] = (C / Ee >> 0) - Me & 255;
    return $ + D;
  }, p.prototype.writeInt8 = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 1, 127, -128), C < 0 && (C = 255 + C + 1), this[$] = C & 255, $ + 1;
  }, p.prototype.writeInt16LE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 2, 32767, -32768), this[$] = C & 255, this[$ + 1] = C >>> 8, $ + 2;
  }, p.prototype.writeInt16BE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 2, 32767, -32768), this[$] = C >>> 8, this[$ + 1] = C & 255, $ + 2;
  }, p.prototype.writeInt32LE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 4, 2147483647, -2147483648), this[$] = C & 255, this[$ + 1] = C >>> 8, this[$ + 2] = C >>> 16, this[$ + 3] = C >>> 24, $ + 4;
  }, p.prototype.writeInt32BE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || Z(this, C, $, 4, 2147483647, -2147483648), C < 0 && (C = 4294967295 + C + 1), this[$] = C >>> 24, this[$ + 1] = C >>> 16, this[$ + 2] = C >>> 8, this[$ + 3] = C & 255, $ + 4;
  }, p.prototype.writeBigInt64LE = be(function(C, $ = 0) {
    return re(this, C, $, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), p.prototype.writeBigInt64BE = be(function(C, $ = 0) {
    return le(this, C, $, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function te(C, $, D, ae, pe, Ee) {
    if (D + ae > C.length) throw new RangeError("Index out of range");
    if (D < 0) throw new RangeError("Index out of range");
  }
  function oe(C, $, D, ae, pe) {
    return $ = +$, D = D >>> 0, pe || te(C, $, D, 4), r.write(C, $, D, ae, 23, 4), D + 4;
  }
  p.prototype.writeFloatLE = function(C, $, D) {
    return oe(this, C, $, !0, D);
  }, p.prototype.writeFloatBE = function(C, $, D) {
    return oe(this, C, $, !1, D);
  };
  function fe(C, $, D, ae, pe) {
    return $ = +$, D = D >>> 0, pe || te(C, $, D, 8), r.write(C, $, D, ae, 52, 8), D + 8;
  }
  p.prototype.writeDoubleLE = function(C, $, D) {
    return fe(this, C, $, !0, D);
  }, p.prototype.writeDoubleBE = function(C, $, D) {
    return fe(this, C, $, !1, D);
  }, p.prototype.copy = function(C, $, D, ae) {
    if (!p.isBuffer(C)) throw new TypeError("argument should be a Buffer");
    if (D || (D = 0), !ae && ae !== 0 && (ae = this.length), $ >= C.length && ($ = C.length), $ || ($ = 0), ae > 0 && ae < D && (ae = D), ae === D || C.length === 0 || this.length === 0) return 0;
    if ($ < 0)
      throw new RangeError("targetStart out of bounds");
    if (D < 0 || D >= this.length) throw new RangeError("Index out of range");
    if (ae < 0) throw new RangeError("sourceEnd out of bounds");
    ae > this.length && (ae = this.length), C.length - $ < ae - D && (ae = C.length - $ + D);
    const pe = ae - D;
    return this === C && typeof s.prototype.copyWithin == "function" ? this.copyWithin($, D, ae) : s.prototype.set.call(
      C,
      this.subarray(D, ae),
      $
    ), pe;
  }, p.prototype.fill = function(C, $, D, ae) {
    if (typeof C == "string") {
      if (typeof $ == "string" ? (ae = $, $ = 0, D = this.length) : typeof D == "string" && (ae = D, D = this.length), ae !== void 0 && typeof ae != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ae == "string" && !p.isEncoding(ae))
        throw new TypeError("Unknown encoding: " + ae);
      if (C.length === 1) {
        const Ee = C.charCodeAt(0);
        (ae === "utf8" && Ee < 128 || ae === "latin1") && (C = Ee);
      }
    } else typeof C == "number" ? C = C & 255 : typeof C == "boolean" && (C = Number(C));
    if ($ < 0 || this.length < $ || this.length < D)
      throw new RangeError("Out of range index");
    if (D <= $)
      return this;
    $ = $ >>> 0, D = D === void 0 ? this.length : D >>> 0, C || (C = 0);
    let pe;
    if (typeof C == "number")
      for (pe = $; pe < D; ++pe)
        this[pe] = C;
    else {
      const Ee = p.isBuffer(C) ? C : p.from(C, ae), Me = Ee.length;
      if (Me === 0)
        throw new TypeError('The value "' + C + '" is invalid for argument "value"');
      for (pe = 0; pe < D - $; ++pe)
        this[pe + $] = Ee[pe % Me];
    }
    return this;
  };
  const H = {};
  function J(C, $, D) {
    H[C] = class extends D {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: $.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${C}]`, this.stack, delete this.name;
      }
      get code() {
        return C;
      }
      set code(ae) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: ae,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${C}]: ${this.message}`;
      }
    };
  }
  J(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(C) {
      return C ? `${C} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), J(
    "ERR_INVALID_ARG_TYPE",
    function(C, $) {
      return `The "${C}" argument must be of type number. Received type ${typeof $}`;
    },
    TypeError
  ), J(
    "ERR_OUT_OF_RANGE",
    function(C, $, D) {
      let ae = `The value of "${C}" is out of range.`, pe = D;
      return Number.isInteger(D) && Math.abs(D) > 2 ** 32 ? pe = Se(String(D)) : typeof D == "bigint" && (pe = String(D), (D > BigInt(2) ** BigInt(32) || D < -(BigInt(2) ** BigInt(32))) && (pe = Se(pe)), pe += "n"), ae += ` It must be ${$}. Received ${pe}`, ae;
    },
    RangeError
  );
  function Se(C) {
    let $ = "", D = C.length;
    const ae = C[0] === "-" ? 1 : 0;
    for (; D >= ae + 4; D -= 3)
      $ = `_${C.slice(D - 3, D)}${$}`;
    return `${C.slice(0, D)}${$}`;
  }
  function Re(C, $, D) {
    Le($, "offset"), (C[$] === void 0 || C[$ + D] === void 0) && ze($, C.length - (D + 1));
  }
  function Fe(C, $, D, ae, pe, Ee) {
    if (C > D || C < $) {
      const Me = typeof $ == "bigint" ? "n" : "";
      let ot;
      throw $ === 0 || $ === BigInt(0) ? ot = `>= 0${Me} and < 2${Me} ** ${(Ee + 1) * 8}${Me}` : ot = `>= -(2${Me} ** ${(Ee + 1) * 8 - 1}${Me}) and < 2 ** ${(Ee + 1) * 8 - 1}${Me}`, new H.ERR_OUT_OF_RANGE("value", ot, C);
    }
    Re(ae, pe, Ee);
  }
  function Le(C, $) {
    if (typeof C != "number")
      throw new H.ERR_INVALID_ARG_TYPE($, "number", C);
  }
  function ze(C, $, D) {
    throw Math.floor(C) !== C ? (Le(C, D), new H.ERR_OUT_OF_RANGE("offset", "an integer", C)) : $ < 0 ? new H.ERR_BUFFER_OUT_OF_BOUNDS() : new H.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${$}`,
      C
    );
  }
  const tt = /[^+/0-9A-Za-z-_]/g;
  function Pe(C) {
    if (C = C.split("=")[0], C = C.trim().replace(tt, ""), C.length < 2) return "";
    for (; C.length % 4 !== 0; )
      C = C + "=";
    return C;
  }
  function At(C, $) {
    $ = $ || 1 / 0;
    let D;
    const ae = C.length;
    let pe = null;
    const Ee = [];
    for (let Me = 0; Me < ae; ++Me) {
      if (D = C.charCodeAt(Me), D > 55295 && D < 57344) {
        if (!pe) {
          if (D > 56319) {
            ($ -= 3) > -1 && Ee.push(239, 191, 189);
            continue;
          } else if (Me + 1 === ae) {
            ($ -= 3) > -1 && Ee.push(239, 191, 189);
            continue;
          }
          pe = D;
          continue;
        }
        if (D < 56320) {
          ($ -= 3) > -1 && Ee.push(239, 191, 189), pe = D;
          continue;
        }
        D = (pe - 55296 << 10 | D - 56320) + 65536;
      } else pe && ($ -= 3) > -1 && Ee.push(239, 191, 189);
      if (pe = null, D < 128) {
        if (($ -= 1) < 0) break;
        Ee.push(D);
      } else if (D < 2048) {
        if (($ -= 2) < 0) break;
        Ee.push(
          D >> 6 | 192,
          D & 63 | 128
        );
      } else if (D < 65536) {
        if (($ -= 3) < 0) break;
        Ee.push(
          D >> 12 | 224,
          D >> 6 & 63 | 128,
          D & 63 | 128
        );
      } else if (D < 1114112) {
        if (($ -= 4) < 0) break;
        Ee.push(
          D >> 18 | 240,
          D >> 12 & 63 | 128,
          D >> 6 & 63 | 128,
          D & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Ee;
  }
  function er(C) {
    const $ = [];
    for (let D = 0; D < C.length; ++D)
      $.push(C.charCodeAt(D) & 255);
    return $;
  }
  function me(C, $) {
    let D, ae, pe;
    const Ee = [];
    for (let Me = 0; Me < C.length && !(($ -= 2) < 0); ++Me)
      D = C.charCodeAt(Me), ae = D >> 8, pe = D % 256, Ee.push(pe), Ee.push(ae);
    return Ee;
  }
  function ht(C) {
    return e.toByteArray(Pe(C));
  }
  function it(C, $, D, ae) {
    let pe;
    for (pe = 0; pe < ae && !(pe + D >= $.length || pe >= C.length); ++pe)
      $[pe + D] = C[pe];
    return pe;
  }
  function kt(C, $) {
    return C instanceof $ || C != null && C.constructor != null && C.constructor.name != null && C.constructor.name === $.name;
  }
  function Ze(C) {
    return C !== C;
  }
  const ge = function() {
    const C = "0123456789abcdef", $ = new Array(256);
    for (let D = 0; D < 16; ++D) {
      const ae = D * 16;
      for (let pe = 0; pe < 16; ++pe)
        $[ae + pe] = C[D] + C[pe];
    }
    return $;
  }();
  function be(C) {
    return typeof BigInt > "u" ? Je : C;
  }
  function Je() {
    throw new Error("BigInt not supported");
  }
})(K$);
const ju = K$.Buffer;
var Dw, P_;
function Z$() {
  if (P_) return Dw;
  P_ = 1;
  const t = (o, a, l) => {
    const c = o.length, p = l.length, h = o.substring(0, a), d = o.substring(a + p, c);
    return [h, d];
  }, e = (o, a, l) => {
    const c = o.length, p = l.length, h = ju.alloc(a);
    o.copy(h, 0, 0, a);
    const d = ju.alloc(c - a - p);
    return o.copy(d, 0, a + p, c), [h, d];
  }, r = (o, a) => {
    const l = o.indexOf(a);
    let c = t;
    if (l < 0)
      return [o];
    ju.isBuffer(o) && (c = e);
    const [p, h] = c(o, l, a);
    let d = [];
    return p.length > 0 && (d = [p]), d = [...d, a], h.length > 0 && (d = [...d, h]), d;
  }, n = (o, a) => {
    const l = r(o, a);
    return l.length <= 1 ? l : l.length <= 2 ? [l[0], ...n(l[1], a)] : [l[0], l[1], ...n(l[2], a)];
  }, i = (o, a) => o.flatMap((l) => n(l, a)), s = (o, a) => {
    if (a.length <= 0)
      return o;
    const l = i(o, a[0]);
    return s(l, a.slice(1));
  };
  return Dw = (o, ...a) => s([o], a), Dw;
}
var Vm = { exports: {} }, R_;
function gS() {
  if (R_) return Vm.exports;
  R_ = 1;
  var t = typeof Reflect == "object" ? Reflect : null, e = t && typeof t.apply == "function" ? t.apply : function(g, v, k) {
    return Function.prototype.apply.call(g, v, k);
  }, r;
  t && typeof t.ownKeys == "function" ? r = t.ownKeys : Object.getOwnPropertySymbols ? r = function(g) {
    return Object.getOwnPropertyNames(g).concat(Object.getOwnPropertySymbols(g));
  } : r = function(g) {
    return Object.getOwnPropertyNames(g);
  };
  function n(g) {
    console && console.warn && console.warn(g);
  }
  var i = Number.isNaN || function(g) {
    return g !== g;
  };
  function s() {
    s.init.call(this);
  }
  Vm.exports = s, Vm.exports.once = E, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var o = 10;
  function a(g) {
    if (typeof g != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof g);
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return o;
    },
    set: function(g) {
      if (typeof g != "number" || g < 0 || i(g))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + g + ".");
      o = g;
    }
  }), s.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(g) {
    if (typeof g != "number" || g < 0 || i(g))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + g + ".");
    return this._maxListeners = g, this;
  };
  function l(g) {
    return g._maxListeners === void 0 ? s.defaultMaxListeners : g._maxListeners;
  }
  s.prototype.getMaxListeners = function() {
    return l(this);
  }, s.prototype.emit = function(g) {
    for (var v = [], k = 1; k < arguments.length; k++) v.push(arguments[k]);
    var S = g === "error", R = this._events;
    if (R !== void 0)
      S = S && R.error === void 0;
    else if (!S)
      return !1;
    if (S) {
      var L;
      if (v.length > 0 && (L = v[0]), L instanceof Error)
        throw L;
      var F = new Error("Unhandled error." + (L ? " (" + L.message + ")" : ""));
      throw F.context = L, F;
    }
    var z = R[g];
    if (z === void 0)
      return !1;
    if (typeof z == "function")
      e(z, this, v);
    else
      for (var j = z.length, ee = m(z, j), k = 0; k < j; ++k)
        e(ee[k], this, v);
    return !0;
  };
  function c(g, v, k, S) {
    var R, L, F;
    if (a(k), L = g._events, L === void 0 ? (L = g._events = /* @__PURE__ */ Object.create(null), g._eventsCount = 0) : (L.newListener !== void 0 && (g.emit(
      "newListener",
      v,
      k.listener ? k.listener : k
    ), L = g._events), F = L[v]), F === void 0)
      F = L[v] = k, ++g._eventsCount;
    else if (typeof F == "function" ? F = L[v] = S ? [k, F] : [F, k] : S ? F.unshift(k) : F.push(k), R = l(g), R > 0 && F.length > R && !F.warned) {
      F.warned = !0;
      var z = new Error("Possible EventEmitter memory leak detected. " + F.length + " " + String(v) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      z.name = "MaxListenersExceededWarning", z.emitter = g, z.type = v, z.count = F.length, n(z);
    }
    return g;
  }
  s.prototype.addListener = function(g, v) {
    return c(this, g, v, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(g, v) {
    return c(this, g, v, !0);
  };
  function p() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function h(g, v, k) {
    var S = { fired: !1, wrapFn: void 0, target: g, type: v, listener: k }, R = p.bind(S);
    return R.listener = k, S.wrapFn = R, R;
  }
  s.prototype.once = function(g, v) {
    return a(v), this.on(g, h(this, g, v)), this;
  }, s.prototype.prependOnceListener = function(g, v) {
    return a(v), this.prependListener(g, h(this, g, v)), this;
  }, s.prototype.removeListener = function(g, v) {
    var k, S, R, L, F;
    if (a(v), S = this._events, S === void 0)
      return this;
    if (k = S[g], k === void 0)
      return this;
    if (k === v || k.listener === v)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete S[g], S.removeListener && this.emit("removeListener", g, k.listener || v));
    else if (typeof k != "function") {
      for (R = -1, L = k.length - 1; L >= 0; L--)
        if (k[L] === v || k[L].listener === v) {
          F = k[L].listener, R = L;
          break;
        }
      if (R < 0)
        return this;
      R === 0 ? k.shift() : w(k, R), k.length === 1 && (S[g] = k[0]), S.removeListener !== void 0 && this.emit("removeListener", g, F || v);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(g) {
    var v, k, S;
    if (k = this._events, k === void 0)
      return this;
    if (k.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : k[g] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete k[g]), this;
    if (arguments.length === 0) {
      var R = Object.keys(k), L;
      for (S = 0; S < R.length; ++S)
        L = R[S], L !== "removeListener" && this.removeAllListeners(L);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (v = k[g], typeof v == "function")
      this.removeListener(g, v);
    else if (v !== void 0)
      for (S = v.length - 1; S >= 0; S--)
        this.removeListener(g, v[S]);
    return this;
  };
  function d(g, v, k) {
    var S = g._events;
    if (S === void 0)
      return [];
    var R = S[v];
    return R === void 0 ? [] : typeof R == "function" ? k ? [R.listener || R] : [R] : k ? f(R) : m(R, R.length);
  }
  s.prototype.listeners = function(g) {
    return d(this, g, !0);
  }, s.prototype.rawListeners = function(g) {
    return d(this, g, !1);
  }, s.listenerCount = function(g, v) {
    return typeof g.listenerCount == "function" ? g.listenerCount(v) : b.call(g, v);
  }, s.prototype.listenerCount = b;
  function b(g) {
    var v = this._events;
    if (v !== void 0) {
      var k = v[g];
      if (typeof k == "function")
        return 1;
      if (k !== void 0)
        return k.length;
    }
    return 0;
  }
  s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? r(this._events) : [];
  };
  function m(g, v) {
    for (var k = new Array(v), S = 0; S < v; ++S)
      k[S] = g[S];
    return k;
  }
  function w(g, v) {
    for (; v + 1 < g.length; v++)
      g[v] = g[v + 1];
    g.pop();
  }
  function f(g) {
    for (var v = new Array(g.length), k = 0; k < v.length; ++k)
      v[k] = g[k].listener || g[k];
    return v;
  }
  function E(g, v) {
    return new Promise(function(k, S) {
      function R(F) {
        g.removeListener(v, L), S(F);
      }
      function L() {
        typeof g.removeListener == "function" && g.removeListener("error", R), k([].slice.call(arguments));
      }
      x(g, v, L, { once: !0 }), v !== "error" && A(g, R, { once: !0 });
    });
  }
  function A(g, v, k) {
    typeof g.on == "function" && x(g, "error", v, k);
  }
  function x(g, v, k, S) {
    if (typeof g.on == "function")
      S.once ? g.once(v, k) : g.on(v, k);
    else if (typeof g.addEventListener == "function")
      g.addEventListener(v, function R(L) {
        S.once && g.removeEventListener(v, R), k(L);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof g);
  }
  return Vm.exports;
}
var $w = { exports: {} }, O_;
function Fh() {
  return O_ || (O_ = 1, typeof Object.create == "function" ? $w.exports = function(t, e) {
    e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : $w.exports = function(t, e) {
    if (e) {
      t.super_ = e;
      var r = function() {
      };
      r.prototype = e.prototype, t.prototype = new r(), t.prototype.constructor = t;
    }
  }), $w.exports;
}
function mye(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var J$ = { exports: {} }, Hr = J$.exports = {}, So, Ao;
function g4() {
  throw new Error("setTimeout has not been defined");
}
function m4() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? So = setTimeout : So = g4;
  } catch {
    So = g4;
  }
  try {
    typeof clearTimeout == "function" ? Ao = clearTimeout : Ao = m4;
  } catch {
    Ao = m4;
  }
})();
function X$(t) {
  if (So === setTimeout)
    return setTimeout(t, 0);
  if ((So === g4 || !So) && setTimeout)
    return So = setTimeout, setTimeout(t, 0);
  try {
    return So(t, 0);
  } catch {
    try {
      return So.call(null, t, 0);
    } catch {
      return So.call(this, t, 0);
    }
  }
}
function yye(t) {
  if (Ao === clearTimeout)
    return clearTimeout(t);
  if ((Ao === m4 || !Ao) && clearTimeout)
    return Ao = clearTimeout, clearTimeout(t);
  try {
    return Ao(t);
  } catch {
    try {
      return Ao.call(null, t);
    } catch {
      return Ao.call(this, t);
    }
  }
}
var da = [], Dp = !1, Bu, C1 = -1;
function bye() {
  !Dp || !Bu || (Dp = !1, Bu.length ? da = Bu.concat(da) : C1 = -1, da.length && ej());
}
function ej() {
  if (!Dp) {
    var t = X$(bye);
    Dp = !0;
    for (var e = da.length; e; ) {
      for (Bu = da, da = []; ++C1 < e; )
        Bu && Bu[C1].run();
      C1 = -1, e = da.length;
    }
    Bu = null, Dp = !1, yye(t);
  }
}
Hr.nextTick = function(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
  da.push(new tj(t, e)), da.length === 1 && !Dp && X$(ej);
};
function tj(t, e) {
  this.fun = t, this.array = e;
}
tj.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Hr.title = "browser";
Hr.browser = !0;
Hr.env = {};
Hr.argv = [];
Hr.version = "";
Hr.versions = {};
function Za() {
}
Hr.on = Za;
Hr.addListener = Za;
Hr.once = Za;
Hr.off = Za;
Hr.removeListener = Za;
Hr.removeAllListeners = Za;
Hr.emit = Za;
Hr.prependListener = Za;
Hr.prependOnceListener = Za;
Hr.listeners = function(t) {
  return [];
};
Hr.binding = function(t) {
  throw new Error("process.binding is not supported");
};
Hr.cwd = function() {
  return "/";
};
Hr.chdir = function(t) {
  throw new Error("process.chdir is not supported");
};
Hr.umask = function() {
  return 0;
};
var vye = J$.exports;
const Ut = /* @__PURE__ */ mye(vye);
var T_, L_;
function rj() {
  return L_ || (L_ = 1, T_ = gS().EventEmitter), T_;
}
var M_ = {}, N_;
function Lb() {
  return N_ || (N_ = 1, function(t) {
    Object.defineProperties(t, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
    var e = {}, r = {};
    r.byteLength = p, r.toByteArray = d, r.fromByteArray = w;
    for (var n = [], i = [], s = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, l = o.length; a < l; ++a)
      n[a] = o[a], i[o.charCodeAt(a)] = a;
    i[45] = 62, i[95] = 63;
    function c(A) {
      var x = A.length;
      if (x % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var g = A.indexOf("=");
      g === -1 && (g = x);
      var v = g === x ? 0 : 4 - g % 4;
      return [g, v];
    }
    function p(A) {
      var x = c(A), g = x[0], v = x[1];
      return (g + v) * 3 / 4 - v;
    }
    function h(A, x, g) {
      return (x + g) * 3 / 4 - g;
    }
    function d(A) {
      var x, g = c(A), v = g[0], k = g[1], S = new s(h(A, v, k)), R = 0, L = k > 0 ? v - 4 : v, F;
      for (F = 0; F < L; F += 4)
        x = i[A.charCodeAt(F)] << 18 | i[A.charCodeAt(F + 1)] << 12 | i[A.charCodeAt(F + 2)] << 6 | i[A.charCodeAt(F + 3)], S[R++] = x >> 16 & 255, S[R++] = x >> 8 & 255, S[R++] = x & 255;
      return k === 2 && (x = i[A.charCodeAt(F)] << 2 | i[A.charCodeAt(F + 1)] >> 4, S[R++] = x & 255), k === 1 && (x = i[A.charCodeAt(F)] << 10 | i[A.charCodeAt(F + 1)] << 4 | i[A.charCodeAt(F + 2)] >> 2, S[R++] = x >> 8 & 255, S[R++] = x & 255), S;
    }
    function b(A) {
      return n[A >> 18 & 63] + n[A >> 12 & 63] + n[A >> 6 & 63] + n[A & 63];
    }
    function m(A, x, g) {
      for (var v, k = [], S = x; S < g; S += 3)
        v = (A[S] << 16 & 16711680) + (A[S + 1] << 8 & 65280) + (A[S + 2] & 255), k.push(b(v));
      return k.join("");
    }
    function w(A) {
      for (var x, g = A.length, v = g % 3, k = [], S = 16383, R = 0, L = g - v; R < L; R += S)
        k.push(m(A, R, R + S > L ? L : R + S));
      return v === 1 ? (x = A[g - 1], k.push(
        n[x >> 2] + n[x << 4 & 63] + "=="
      )) : v === 2 && (x = (A[g - 2] << 8) + A[g - 1], k.push(
        n[x >> 10] + n[x >> 4 & 63] + n[x << 2 & 63] + "="
      )), k.join("");
    }
    var f = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    f.read = function(A, x, g, v, k) {
      var S, R, L = k * 8 - v - 1, F = (1 << L) - 1, z = F >> 1, j = -7, ee = g ? k - 1 : 0, X = g ? -1 : 1, ie = A[x + ee];
      for (ee += X, S = ie & (1 << -j) - 1, ie >>= -j, j += L; j > 0; S = S * 256 + A[x + ee], ee += X, j -= 8)
        ;
      for (R = S & (1 << -j) - 1, S >>= -j, j += v; j > 0; R = R * 256 + A[x + ee], ee += X, j -= 8)
        ;
      if (S === 0)
        S = 1 - z;
      else {
        if (S === F)
          return R ? NaN : (ie ? -1 : 1) * (1 / 0);
        R = R + Math.pow(2, v), S = S - z;
      }
      return (ie ? -1 : 1) * R * Math.pow(2, S - v);
    }, f.write = function(A, x, g, v, k, S) {
      var R, L, F, z = S * 8 - k - 1, j = (1 << z) - 1, ee = j >> 1, X = k === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ie = v ? 0 : S - 1, ce = v ? 1 : -1, ke = x < 0 || x === 0 && 1 / x < 0 ? 1 : 0;
      for (x = Math.abs(x), isNaN(x) || x === 1 / 0 ? (L = isNaN(x) ? 1 : 0, R = j) : (R = Math.floor(Math.log(x) / Math.LN2), x * (F = Math.pow(2, -R)) < 1 && (R--, F *= 2), R + ee >= 1 ? x += X / F : x += X * Math.pow(2, 1 - ee), x * F >= 2 && (R++, F /= 2), R + ee >= j ? (L = 0, R = j) : R + ee >= 1 ? (L = (x * F - 1) * Math.pow(2, k), R = R + ee) : (L = x * Math.pow(2, ee - 1) * Math.pow(2, k), R = 0)); k >= 8; A[g + ie] = L & 255, ie += ce, L /= 256, k -= 8)
        ;
      for (R = R << k | L, z += k; z > 0; A[g + ie] = R & 255, ie += ce, R /= 256, z -= 8)
        ;
      A[g + ie - ce] |= ke * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(A) {
      const x = r, g = f, v = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      A.Buffer = j, A.SlowBuffer = O, A.INSPECT_MAX_BYTES = 50;
      const k = 2147483647;
      A.kMaxLength = k;
      const { Uint8Array: S, ArrayBuffer: R, SharedArrayBuffer: L } = globalThis;
      j.TYPED_ARRAY_SUPPORT = F(), !j.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
      function F() {
        try {
          const M = new S(1), V = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(V, S.prototype), Object.setPrototypeOf(M, V), M.foo() === 42;
        } catch {
          return !1;
        }
      }
      Object.defineProperty(j.prototype, "parent", {
        enumerable: !0,
        get: function() {
          if (j.isBuffer(this))
            return this.buffer;
        }
      }), Object.defineProperty(j.prototype, "offset", {
        enumerable: !0,
        get: function() {
          if (j.isBuffer(this))
            return this.byteOffset;
        }
      });
      function z(M) {
        if (M > k)
          throw new RangeError('The value "' + M + '" is invalid for option "size"');
        const V = new S(M);
        return Object.setPrototypeOf(V, j.prototype), V;
      }
      function j(M, V, q) {
        if (typeof M == "number") {
          if (typeof V == "string")
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return ce(M);
        }
        return ee(M, V, q);
      }
      j.poolSize = 8192;
      function ee(M, V, q) {
        if (typeof M == "string")
          return ke(M, V);
        if (R.isView(M))
          return Ce(M);
        if (M == null)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M
          );
        if (tr(M, R) || M && tr(M.buffer, R) || typeof L < "u" && (tr(M, L) || M && tr(M.buffer, L)))
          return Ie(M, V, q);
        if (typeof M == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const de = M.valueOf && M.valueOf();
        if (de != null && de !== M)
          return j.from(de, V, q);
        const ve = Te(M);
        if (ve) return ve;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof M[Symbol.toPrimitive] == "function")
          return j.from(M[Symbol.toPrimitive]("string"), V, q);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M
        );
      }
      j.from = function(M, V, q) {
        return ee(M, V, q);
      }, Object.setPrototypeOf(j.prototype, S.prototype), Object.setPrototypeOf(j, S);
      function X(M) {
        if (typeof M != "number")
          throw new TypeError('"size" argument must be of type number');
        if (M < 0)
          throw new RangeError('The value "' + M + '" is invalid for option "size"');
      }
      function ie(M, V, q) {
        return X(M), M <= 0 ? z(M) : V !== void 0 ? typeof q == "string" ? z(M).fill(V, q) : z(M).fill(V) : z(M);
      }
      j.alloc = function(M, V, q) {
        return ie(M, V, q);
      };
      function ce(M) {
        return X(M), z(M < 0 ? 0 : ue(M) | 0);
      }
      j.allocUnsafe = function(M) {
        return ce(M);
      }, j.allocUnsafeSlow = function(M) {
        return ce(M);
      };
      function ke(M, V) {
        if ((typeof V != "string" || V === "") && (V = "utf8"), !j.isEncoding(V))
          throw new TypeError("Unknown encoding: " + V);
        const q = N(M, V) | 0;
        let de = z(q);
        const ve = de.write(M, V);
        return ve !== q && (de = de.slice(0, ve)), de;
      }
      function ye(M) {
        const V = M.length < 0 ? 0 : ue(M.length) | 0, q = z(V);
        for (let de = 0; de < V; de += 1)
          q[de] = M[de] & 255;
        return q;
      }
      function Ce(M) {
        if (tr(M, S)) {
          const V = new S(M);
          return Ie(V.buffer, V.byteOffset, V.byteLength);
        }
        return ye(M);
      }
      function Ie(M, V, q) {
        if (V < 0 || M.byteLength < V)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (M.byteLength < V + (q || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let de;
        return V === void 0 && q === void 0 ? de = new S(M) : q === void 0 ? de = new S(M, V) : de = new S(M, V, q), Object.setPrototypeOf(de, j.prototype), de;
      }
      function Te(M) {
        if (j.isBuffer(M)) {
          const V = ue(M.length) | 0, q = z(V);
          return q.length === 0 || M.copy(q, 0, 0, V), q;
        }
        if (M.length !== void 0)
          return typeof M.length != "number" || Nr(M.length) ? z(0) : ye(M);
        if (M.type === "Buffer" && Array.isArray(M.data))
          return ye(M.data);
      }
      function ue(M) {
        if (M >= k)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + k.toString(16) + " bytes");
        return M | 0;
      }
      function O(M) {
        return +M != M && (M = 0), j.alloc(+M);
      }
      j.isBuffer = function(M) {
        return M != null && M._isBuffer === !0 && M !== j.prototype;
      }, j.compare = function(M, V) {
        if (tr(M, S) && (M = j.from(M, M.offset, M.byteLength)), tr(V, S) && (V = j.from(V, V.offset, V.byteLength)), !j.isBuffer(M) || !j.isBuffer(V))
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (M === V) return 0;
        let q = M.length, de = V.length;
        for (let ve = 0, Y = Math.min(q, de); ve < Y; ++ve)
          if (M[ve] !== V[ve]) {
            q = M[ve], de = V[ve];
            break;
          }
        return q < de ? -1 : de < q ? 1 : 0;
      }, j.isEncoding = function(M) {
        switch (String(M).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, j.concat = function(M, V) {
        if (!Array.isArray(M))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (M.length === 0)
          return j.alloc(0);
        let q;
        if (V === void 0)
          for (V = 0, q = 0; q < M.length; ++q)
            V += M[q].length;
        const de = j.allocUnsafe(V);
        let ve = 0;
        for (q = 0; q < M.length; ++q) {
          let Y = M[q];
          if (tr(Y, S))
            ve + Y.length > de.length ? (j.isBuffer(Y) || (Y = j.from(Y)), Y.copy(de, ve)) : S.prototype.set.call(
              de,
              Y,
              ve
            );
          else if (j.isBuffer(Y))
            Y.copy(de, ve);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          ve += Y.length;
        }
        return de;
      };
      function N(M, V) {
        if (j.isBuffer(M))
          return M.length;
        if (R.isView(M) || tr(M, R))
          return M.byteLength;
        if (typeof M != "string")
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof M
          );
        const q = M.length, de = arguments.length > 2 && arguments[2] === !0;
        if (!de && q === 0) return 0;
        let ve = !1;
        for (; ; )
          switch (V) {
            case "ascii":
            case "latin1":
            case "binary":
              return q;
            case "utf8":
            case "utf-8":
              return dt(M).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return q * 2;
            case "hex":
              return q >>> 1;
            case "base64":
              return zt(M).length;
            default:
              if (ve)
                return de ? -1 : dt(M).length;
              V = ("" + V).toLowerCase(), ve = !0;
          }
      }
      j.byteLength = N;
      function Z(M, V, q) {
        let de = !1;
        if ((V === void 0 || V < 0) && (V = 0), V > this.length || ((q === void 0 || q > this.length) && (q = this.length), q <= 0) || (q >>>= 0, V >>>= 0, q <= V))
          return "";
        for (M || (M = "utf8"); ; )
          switch (M) {
            case "hex":
              return At(this, V, q);
            case "utf8":
            case "utf-8":
              return Fe(this, V, q);
            case "ascii":
              return tt(this, V, q);
            case "latin1":
            case "binary":
              return Pe(this, V, q);
            case "base64":
              return Re(this, V, q);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return er(this, V, q);
            default:
              if (de) throw new TypeError("Unknown encoding: " + M);
              M = (M + "").toLowerCase(), de = !0;
          }
      }
      j.prototype._isBuffer = !0;
      function re(M, V, q) {
        const de = M[V];
        M[V] = M[q], M[q] = de;
      }
      j.prototype.swap16 = function() {
        const M = this.length;
        if (M % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let V = 0; V < M; V += 2)
          re(this, V, V + 1);
        return this;
      }, j.prototype.swap32 = function() {
        const M = this.length;
        if (M % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let V = 0; V < M; V += 4)
          re(this, V, V + 3), re(this, V + 1, V + 2);
        return this;
      }, j.prototype.swap64 = function() {
        const M = this.length;
        if (M % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let V = 0; V < M; V += 8)
          re(this, V, V + 7), re(this, V + 1, V + 6), re(this, V + 2, V + 5), re(this, V + 3, V + 4);
        return this;
      }, j.prototype.toString = function() {
        const M = this.length;
        return M === 0 ? "" : arguments.length === 0 ? Fe(this, 0, M) : Z.apply(this, arguments);
      }, j.prototype.toLocaleString = j.prototype.toString, j.prototype.equals = function(M) {
        if (!j.isBuffer(M)) throw new TypeError("Argument must be a Buffer");
        return this === M ? !0 : j.compare(this, M) === 0;
      }, j.prototype.inspect = function() {
        let M = "";
        const V = A.INSPECT_MAX_BYTES;
        return M = this.toString("hex", 0, V).replace(/(.{2})/g, "$1 ").trim(), this.length > V && (M += " ... "), "<Buffer " + M + ">";
      }, v && (j.prototype[v] = j.prototype.inspect), j.prototype.compare = function(M, V, q, de, ve) {
        if (tr(M, S) && (M = j.from(M, M.offset, M.byteLength)), !j.isBuffer(M))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof M
          );
        if (V === void 0 && (V = 0), q === void 0 && (q = M ? M.length : 0), de === void 0 && (de = 0), ve === void 0 && (ve = this.length), V < 0 || q > M.length || de < 0 || ve > this.length)
          throw new RangeError("out of range index");
        if (de >= ve && V >= q)
          return 0;
        if (de >= ve)
          return -1;
        if (V >= q)
          return 1;
        if (V >>>= 0, q >>>= 0, de >>>= 0, ve >>>= 0, this === M) return 0;
        let Y = ve - de, I = q - V;
        const B = Math.min(Y, I), W = this.slice(de, ve), G = M.slice(V, q);
        for (let K = 0; K < B; ++K)
          if (W[K] !== G[K]) {
            Y = W[K], I = G[K];
            break;
          }
        return Y < I ? -1 : I < Y ? 1 : 0;
      };
      function le(M, V, q, de, ve) {
        if (M.length === 0) return -1;
        if (typeof q == "string" ? (de = q, q = 0) : q > 2147483647 ? q = 2147483647 : q < -2147483648 && (q = -2147483648), q = +q, Nr(q) && (q = ve ? 0 : M.length - 1), q < 0 && (q = M.length + q), q >= M.length) {
          if (ve) return -1;
          q = M.length - 1;
        } else if (q < 0)
          if (ve) q = 0;
          else return -1;
        if (typeof V == "string" && (V = j.from(V, de)), j.isBuffer(V))
          return V.length === 0 ? -1 : te(M, V, q, de, ve);
        if (typeof V == "number")
          return V = V & 255, typeof S.prototype.indexOf == "function" ? ve ? S.prototype.indexOf.call(M, V, q) : S.prototype.lastIndexOf.call(M, V, q) : te(M, [V], q, de, ve);
        throw new TypeError("val must be string, number or Buffer");
      }
      function te(M, V, q, de, ve) {
        let Y = 1, I = M.length, B = V.length;
        if (de !== void 0 && (de = String(de).toLowerCase(), de === "ucs2" || de === "ucs-2" || de === "utf16le" || de === "utf-16le")) {
          if (M.length < 2 || V.length < 2)
            return -1;
          Y = 2, I /= 2, B /= 2, q /= 2;
        }
        function W(K, se) {
          return Y === 1 ? K[se] : K.readUInt16BE(se * Y);
        }
        let G;
        if (ve) {
          let K = -1;
          for (G = q; G < I; G++)
            if (W(M, G) === W(V, K === -1 ? 0 : G - K)) {
              if (K === -1 && (K = G), G - K + 1 === B) return K * Y;
            } else
              K !== -1 && (G -= G - K), K = -1;
        } else
          for (q + B > I && (q = I - B), G = q; G >= 0; G--) {
            let K = !0;
            for (let se = 0; se < B; se++)
              if (W(M, G + se) !== W(V, se)) {
                K = !1;
                break;
              }
            if (K) return G;
          }
        return -1;
      }
      j.prototype.includes = function(M, V, q) {
        return this.indexOf(M, V, q) !== -1;
      }, j.prototype.indexOf = function(M, V, q) {
        return le(this, M, V, q, !0);
      }, j.prototype.lastIndexOf = function(M, V, q) {
        return le(this, M, V, q, !1);
      };
      function oe(M, V, q, de) {
        q = Number(q) || 0;
        const ve = M.length - q;
        de ? (de = Number(de), de > ve && (de = ve)) : de = ve;
        const Y = V.length;
        de > Y / 2 && (de = Y / 2);
        let I;
        for (I = 0; I < de; ++I) {
          const B = parseInt(V.substr(I * 2, 2), 16);
          if (Nr(B)) return I;
          M[q + I] = B;
        }
        return I;
      }
      function fe(M, V, q, de) {
        return Xt(dt(V, M.length - q), M, q, de);
      }
      function H(M, V, q, de) {
        return Xt(St(V), M, q, de);
      }
      function J(M, V, q, de) {
        return Xt(zt(V), M, q, de);
      }
      function Se(M, V, q, de) {
        return Xt(rt(V, M.length - q), M, q, de);
      }
      j.prototype.write = function(M, V, q, de) {
        if (V === void 0)
          de = "utf8", q = this.length, V = 0;
        else if (q === void 0 && typeof V == "string")
          de = V, q = this.length, V = 0;
        else if (isFinite(V))
          V = V >>> 0, isFinite(q) ? (q = q >>> 0, de === void 0 && (de = "utf8")) : (de = q, q = void 0);
        else
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        const ve = this.length - V;
        if ((q === void 0 || q > ve) && (q = ve), M.length > 0 && (q < 0 || V < 0) || V > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        de || (de = "utf8");
        let Y = !1;
        for (; ; )
          switch (de) {
            case "hex":
              return oe(this, M, V, q);
            case "utf8":
            case "utf-8":
              return fe(this, M, V, q);
            case "ascii":
            case "latin1":
            case "binary":
              return H(this, M, V, q);
            case "base64":
              return J(this, M, V, q);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Se(this, M, V, q);
            default:
              if (Y) throw new TypeError("Unknown encoding: " + de);
              de = ("" + de).toLowerCase(), Y = !0;
          }
      }, j.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function Re(M, V, q) {
        return V === 0 && q === M.length ? x.fromByteArray(M) : x.fromByteArray(M.slice(V, q));
      }
      function Fe(M, V, q) {
        q = Math.min(M.length, q);
        const de = [];
        let ve = V;
        for (; ve < q; ) {
          const Y = M[ve];
          let I = null, B = Y > 239 ? 4 : Y > 223 ? 3 : Y > 191 ? 2 : 1;
          if (ve + B <= q) {
            let W, G, K, se;
            switch (B) {
              case 1:
                Y < 128 && (I = Y);
                break;
              case 2:
                W = M[ve + 1], (W & 192) === 128 && (se = (Y & 31) << 6 | W & 63, se > 127 && (I = se));
                break;
              case 3:
                W = M[ve + 1], G = M[ve + 2], (W & 192) === 128 && (G & 192) === 128 && (se = (Y & 15) << 12 | (W & 63) << 6 | G & 63, se > 2047 && (se < 55296 || se > 57343) && (I = se));
                break;
              case 4:
                W = M[ve + 1], G = M[ve + 2], K = M[ve + 3], (W & 192) === 128 && (G & 192) === 128 && (K & 192) === 128 && (se = (Y & 15) << 18 | (W & 63) << 12 | (G & 63) << 6 | K & 63, se > 65535 && se < 1114112 && (I = se));
            }
          }
          I === null ? (I = 65533, B = 1) : I > 65535 && (I -= 65536, de.push(I >>> 10 & 1023 | 55296), I = 56320 | I & 1023), de.push(I), ve += B;
        }
        return ze(de);
      }
      const Le = 4096;
      function ze(M) {
        const V = M.length;
        if (V <= Le)
          return String.fromCharCode.apply(String, M);
        let q = "", de = 0;
        for (; de < V; )
          q += String.fromCharCode.apply(
            String,
            M.slice(de, de += Le)
          );
        return q;
      }
      function tt(M, V, q) {
        let de = "";
        q = Math.min(M.length, q);
        for (let ve = V; ve < q; ++ve)
          de += String.fromCharCode(M[ve] & 127);
        return de;
      }
      function Pe(M, V, q) {
        let de = "";
        q = Math.min(M.length, q);
        for (let ve = V; ve < q; ++ve)
          de += String.fromCharCode(M[ve]);
        return de;
      }
      function At(M, V, q) {
        const de = M.length;
        (!V || V < 0) && (V = 0), (!q || q < 0 || q > de) && (q = de);
        let ve = "";
        for (let Y = V; Y < q; ++Y)
          ve += ki[M[Y]];
        return ve;
      }
      function er(M, V, q) {
        const de = M.slice(V, q);
        let ve = "";
        for (let Y = 0; Y < de.length - 1; Y += 2)
          ve += String.fromCharCode(de[Y] + de[Y + 1] * 256);
        return ve;
      }
      j.prototype.slice = function(M, V) {
        const q = this.length;
        M = ~~M, V = V === void 0 ? q : ~~V, M < 0 ? (M += q, M < 0 && (M = 0)) : M > q && (M = q), V < 0 ? (V += q, V < 0 && (V = 0)) : V > q && (V = q), V < M && (V = M);
        const de = this.subarray(M, V);
        return Object.setPrototypeOf(de, j.prototype), de;
      };
      function me(M, V, q) {
        if (M % 1 !== 0 || M < 0) throw new RangeError("offset is not uint");
        if (M + V > q) throw new RangeError("Trying to access beyond buffer length");
      }
      j.prototype.readUintLE = j.prototype.readUIntLE = function(M, V, q) {
        M = M >>> 0, V = V >>> 0, q || me(M, V, this.length);
        let de = this[M], ve = 1, Y = 0;
        for (; ++Y < V && (ve *= 256); )
          de += this[M + Y] * ve;
        return de;
      }, j.prototype.readUintBE = j.prototype.readUIntBE = function(M, V, q) {
        M = M >>> 0, V = V >>> 0, q || me(M, V, this.length);
        let de = this[M + --V], ve = 1;
        for (; V > 0 && (ve *= 256); )
          de += this[M + --V] * ve;
        return de;
      }, j.prototype.readUint8 = j.prototype.readUInt8 = function(M, V) {
        return M = M >>> 0, V || me(M, 1, this.length), this[M];
      }, j.prototype.readUint16LE = j.prototype.readUInt16LE = function(M, V) {
        return M = M >>> 0, V || me(M, 2, this.length), this[M] | this[M + 1] << 8;
      }, j.prototype.readUint16BE = j.prototype.readUInt16BE = function(M, V) {
        return M = M >>> 0, V || me(M, 2, this.length), this[M] << 8 | this[M + 1];
      }, j.prototype.readUint32LE = j.prototype.readUInt32LE = function(M, V) {
        return M = M >>> 0, V || me(M, 4, this.length), (this[M] | this[M + 1] << 8 | this[M + 2] << 16) + this[M + 3] * 16777216;
      }, j.prototype.readUint32BE = j.prototype.readUInt32BE = function(M, V) {
        return M = M >>> 0, V || me(M, 4, this.length), this[M] * 16777216 + (this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3]);
      }, j.prototype.readBigUInt64LE = Zt(function(M) {
        M = M >>> 0, pe(M, "offset");
        const V = this[M], q = this[M + 7];
        (V === void 0 || q === void 0) && Ee(M, this.length - 8);
        const de = V + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + this[++M] * 2 ** 24, ve = this[++M] + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + q * 2 ** 24;
        return BigInt(de) + (BigInt(ve) << BigInt(32));
      }), j.prototype.readBigUInt64BE = Zt(function(M) {
        M = M >>> 0, pe(M, "offset");
        const V = this[M], q = this[M + 7];
        (V === void 0 || q === void 0) && Ee(M, this.length - 8);
        const de = V * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + this[++M], ve = this[++M] * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + q;
        return (BigInt(de) << BigInt(32)) + BigInt(ve);
      }), j.prototype.readIntLE = function(M, V, q) {
        M = M >>> 0, V = V >>> 0, q || me(M, V, this.length);
        let de = this[M], ve = 1, Y = 0;
        for (; ++Y < V && (ve *= 256); )
          de += this[M + Y] * ve;
        return ve *= 128, de >= ve && (de -= Math.pow(2, 8 * V)), de;
      }, j.prototype.readIntBE = function(M, V, q) {
        M = M >>> 0, V = V >>> 0, q || me(M, V, this.length);
        let de = V, ve = 1, Y = this[M + --de];
        for (; de > 0 && (ve *= 256); )
          Y += this[M + --de] * ve;
        return ve *= 128, Y >= ve && (Y -= Math.pow(2, 8 * V)), Y;
      }, j.prototype.readInt8 = function(M, V) {
        return M = M >>> 0, V || me(M, 1, this.length), this[M] & 128 ? (255 - this[M] + 1) * -1 : this[M];
      }, j.prototype.readInt16LE = function(M, V) {
        M = M >>> 0, V || me(M, 2, this.length);
        const q = this[M] | this[M + 1] << 8;
        return q & 32768 ? q | 4294901760 : q;
      }, j.prototype.readInt16BE = function(M, V) {
        M = M >>> 0, V || me(M, 2, this.length);
        const q = this[M + 1] | this[M] << 8;
        return q & 32768 ? q | 4294901760 : q;
      }, j.prototype.readInt32LE = function(M, V) {
        return M = M >>> 0, V || me(M, 4, this.length), this[M] | this[M + 1] << 8 | this[M + 2] << 16 | this[M + 3] << 24;
      }, j.prototype.readInt32BE = function(M, V) {
        return M = M >>> 0, V || me(M, 4, this.length), this[M] << 24 | this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3];
      }, j.prototype.readBigInt64LE = Zt(function(M) {
        M = M >>> 0, pe(M, "offset");
        const V = this[M], q = this[M + 7];
        (V === void 0 || q === void 0) && Ee(M, this.length - 8);
        const de = this[M + 4] + this[M + 5] * 2 ** 8 + this[M + 6] * 2 ** 16 + (q << 24);
        return (BigInt(de) << BigInt(32)) + BigInt(V + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + this[++M] * 2 ** 24);
      }), j.prototype.readBigInt64BE = Zt(function(M) {
        M = M >>> 0, pe(M, "offset");
        const V = this[M], q = this[M + 7];
        (V === void 0 || q === void 0) && Ee(M, this.length - 8);
        const de = (V << 24) + // Overflow
        this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + this[++M];
        return (BigInt(de) << BigInt(32)) + BigInt(this[++M] * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + q);
      }), j.prototype.readFloatLE = function(M, V) {
        return M = M >>> 0, V || me(M, 4, this.length), g.read(this, M, !0, 23, 4);
      }, j.prototype.readFloatBE = function(M, V) {
        return M = M >>> 0, V || me(M, 4, this.length), g.read(this, M, !1, 23, 4);
      }, j.prototype.readDoubleLE = function(M, V) {
        return M = M >>> 0, V || me(M, 8, this.length), g.read(this, M, !0, 52, 8);
      }, j.prototype.readDoubleBE = function(M, V) {
        return M = M >>> 0, V || me(M, 8, this.length), g.read(this, M, !1, 52, 8);
      };
      function ht(M, V, q, de, ve, Y) {
        if (!j.isBuffer(M)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (V > ve || V < Y) throw new RangeError('"value" argument is out of bounds');
        if (q + de > M.length) throw new RangeError("Index out of range");
      }
      j.prototype.writeUintLE = j.prototype.writeUIntLE = function(M, V, q, de) {
        if (M = +M, V = V >>> 0, q = q >>> 0, !de) {
          const I = Math.pow(2, 8 * q) - 1;
          ht(this, M, V, q, I, 0);
        }
        let ve = 1, Y = 0;
        for (this[V] = M & 255; ++Y < q && (ve *= 256); )
          this[V + Y] = M / ve & 255;
        return V + q;
      }, j.prototype.writeUintBE = j.prototype.writeUIntBE = function(M, V, q, de) {
        if (M = +M, V = V >>> 0, q = q >>> 0, !de) {
          const I = Math.pow(2, 8 * q) - 1;
          ht(this, M, V, q, I, 0);
        }
        let ve = q - 1, Y = 1;
        for (this[V + ve] = M & 255; --ve >= 0 && (Y *= 256); )
          this[V + ve] = M / Y & 255;
        return V + q;
      }, j.prototype.writeUint8 = j.prototype.writeUInt8 = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 1, 255, 0), this[V] = M & 255, V + 1;
      }, j.prototype.writeUint16LE = j.prototype.writeUInt16LE = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 2, 65535, 0), this[V] = M & 255, this[V + 1] = M >>> 8, V + 2;
      }, j.prototype.writeUint16BE = j.prototype.writeUInt16BE = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 2, 65535, 0), this[V] = M >>> 8, this[V + 1] = M & 255, V + 2;
      }, j.prototype.writeUint32LE = j.prototype.writeUInt32LE = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 4, 4294967295, 0), this[V + 3] = M >>> 24, this[V + 2] = M >>> 16, this[V + 1] = M >>> 8, this[V] = M & 255, V + 4;
      }, j.prototype.writeUint32BE = j.prototype.writeUInt32BE = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 4, 4294967295, 0), this[V] = M >>> 24, this[V + 1] = M >>> 16, this[V + 2] = M >>> 8, this[V + 3] = M & 255, V + 4;
      };
      function it(M, V, q, de, ve) {
        ae(V, de, ve, M, q, 7);
        let Y = Number(V & BigInt(4294967295));
        M[q++] = Y, Y = Y >> 8, M[q++] = Y, Y = Y >> 8, M[q++] = Y, Y = Y >> 8, M[q++] = Y;
        let I = Number(V >> BigInt(32) & BigInt(4294967295));
        return M[q++] = I, I = I >> 8, M[q++] = I, I = I >> 8, M[q++] = I, I = I >> 8, M[q++] = I, q;
      }
      function kt(M, V, q, de, ve) {
        ae(V, de, ve, M, q, 7);
        let Y = Number(V & BigInt(4294967295));
        M[q + 7] = Y, Y = Y >> 8, M[q + 6] = Y, Y = Y >> 8, M[q + 5] = Y, Y = Y >> 8, M[q + 4] = Y;
        let I = Number(V >> BigInt(32) & BigInt(4294967295));
        return M[q + 3] = I, I = I >> 8, M[q + 2] = I, I = I >> 8, M[q + 1] = I, I = I >> 8, M[q] = I, q + 8;
      }
      j.prototype.writeBigUInt64LE = Zt(function(M, V = 0) {
        return it(this, M, V, BigInt(0), BigInt("0xffffffffffffffff"));
      }), j.prototype.writeBigUInt64BE = Zt(function(M, V = 0) {
        return kt(this, M, V, BigInt(0), BigInt("0xffffffffffffffff"));
      }), j.prototype.writeIntLE = function(M, V, q, de) {
        if (M = +M, V = V >>> 0, !de) {
          const B = Math.pow(2, 8 * q - 1);
          ht(this, M, V, q, B - 1, -B);
        }
        let ve = 0, Y = 1, I = 0;
        for (this[V] = M & 255; ++ve < q && (Y *= 256); )
          M < 0 && I === 0 && this[V + ve - 1] !== 0 && (I = 1), this[V + ve] = (M / Y >> 0) - I & 255;
        return V + q;
      }, j.prototype.writeIntBE = function(M, V, q, de) {
        if (M = +M, V = V >>> 0, !de) {
          const B = Math.pow(2, 8 * q - 1);
          ht(this, M, V, q, B - 1, -B);
        }
        let ve = q - 1, Y = 1, I = 0;
        for (this[V + ve] = M & 255; --ve >= 0 && (Y *= 256); )
          M < 0 && I === 0 && this[V + ve + 1] !== 0 && (I = 1), this[V + ve] = (M / Y >> 0) - I & 255;
        return V + q;
      }, j.prototype.writeInt8 = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 1, 127, -128), M < 0 && (M = 255 + M + 1), this[V] = M & 255, V + 1;
      }, j.prototype.writeInt16LE = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 2, 32767, -32768), this[V] = M & 255, this[V + 1] = M >>> 8, V + 2;
      }, j.prototype.writeInt16BE = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 2, 32767, -32768), this[V] = M >>> 8, this[V + 1] = M & 255, V + 2;
      }, j.prototype.writeInt32LE = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 4, 2147483647, -2147483648), this[V] = M & 255, this[V + 1] = M >>> 8, this[V + 2] = M >>> 16, this[V + 3] = M >>> 24, V + 4;
      }, j.prototype.writeInt32BE = function(M, V, q) {
        return M = +M, V = V >>> 0, q || ht(this, M, V, 4, 2147483647, -2147483648), M < 0 && (M = 4294967295 + M + 1), this[V] = M >>> 24, this[V + 1] = M >>> 16, this[V + 2] = M >>> 8, this[V + 3] = M & 255, V + 4;
      }, j.prototype.writeBigInt64LE = Zt(function(M, V = 0) {
        return it(this, M, V, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), j.prototype.writeBigInt64BE = Zt(function(M, V = 0) {
        return kt(this, M, V, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function Ze(M, V, q, de, ve, Y) {
        if (q + de > M.length) throw new RangeError("Index out of range");
        if (q < 0) throw new RangeError("Index out of range");
      }
      function ge(M, V, q, de, ve) {
        return V = +V, q = q >>> 0, ve || Ze(M, V, q, 4), g.write(M, V, q, de, 23, 4), q + 4;
      }
      j.prototype.writeFloatLE = function(M, V, q) {
        return ge(this, M, V, !0, q);
      }, j.prototype.writeFloatBE = function(M, V, q) {
        return ge(this, M, V, !1, q);
      };
      function be(M, V, q, de, ve) {
        return V = +V, q = q >>> 0, ve || Ze(M, V, q, 8), g.write(M, V, q, de, 52, 8), q + 8;
      }
      j.prototype.writeDoubleLE = function(M, V, q) {
        return be(this, M, V, !0, q);
      }, j.prototype.writeDoubleBE = function(M, V, q) {
        return be(this, M, V, !1, q);
      }, j.prototype.copy = function(M, V, q, de) {
        if (!j.isBuffer(M)) throw new TypeError("argument should be a Buffer");
        if (q || (q = 0), !de && de !== 0 && (de = this.length), V >= M.length && (V = M.length), V || (V = 0), de > 0 && de < q && (de = q), de === q || M.length === 0 || this.length === 0) return 0;
        if (V < 0)
          throw new RangeError("targetStart out of bounds");
        if (q < 0 || q >= this.length) throw new RangeError("Index out of range");
        if (de < 0) throw new RangeError("sourceEnd out of bounds");
        de > this.length && (de = this.length), M.length - V < de - q && (de = M.length - V + q);
        const ve = de - q;
        return this === M && typeof S.prototype.copyWithin == "function" ? this.copyWithin(V, q, de) : S.prototype.set.call(
          M,
          this.subarray(q, de),
          V
        ), ve;
      }, j.prototype.fill = function(M, V, q, de) {
        if (typeof M == "string") {
          if (typeof V == "string" ? (de = V, V = 0, q = this.length) : typeof q == "string" && (de = q, q = this.length), de !== void 0 && typeof de != "string")
            throw new TypeError("encoding must be a string");
          if (typeof de == "string" && !j.isEncoding(de))
            throw new TypeError("Unknown encoding: " + de);
          if (M.length === 1) {
            const Y = M.charCodeAt(0);
            (de === "utf8" && Y < 128 || de === "latin1") && (M = Y);
          }
        } else typeof M == "number" ? M = M & 255 : typeof M == "boolean" && (M = Number(M));
        if (V < 0 || this.length < V || this.length < q)
          throw new RangeError("Out of range index");
        if (q <= V)
          return this;
        V = V >>> 0, q = q === void 0 ? this.length : q >>> 0, M || (M = 0);
        let ve;
        if (typeof M == "number")
          for (ve = V; ve < q; ++ve)
            this[ve] = M;
        else {
          const Y = j.isBuffer(M) ? M : j.from(M, de), I = Y.length;
          if (I === 0)
            throw new TypeError('The value "' + M + '" is invalid for argument "value"');
          for (ve = 0; ve < q - V; ++ve)
            this[ve + V] = Y[ve % I];
        }
        return this;
      };
      const Je = {};
      function C(M, V, q) {
        Je[M] = class extends q {
          constructor() {
            super(), Object.defineProperty(this, "message", {
              value: V.apply(this, arguments),
              writable: !0,
              configurable: !0
            }), this.name = `${this.name} [${M}]`, this.stack, delete this.name;
          }
          get code() {
            return M;
          }
          set code(de) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: de,
              writable: !0
            });
          }
          toString() {
            return `${this.name} [${M}]: ${this.message}`;
          }
        };
      }
      C(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(M) {
          return M ? `${M} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ), C(
        "ERR_INVALID_ARG_TYPE",
        function(M, V) {
          return `The "${M}" argument must be of type number. Received type ${typeof V}`;
        },
        TypeError
      ), C(
        "ERR_OUT_OF_RANGE",
        function(M, V, q) {
          let de = `The value of "${M}" is out of range.`, ve = q;
          return Number.isInteger(q) && Math.abs(q) > 2 ** 32 ? ve = $(String(q)) : typeof q == "bigint" && (ve = String(q), (q > BigInt(2) ** BigInt(32) || q < -(BigInt(2) ** BigInt(32))) && (ve = $(ve)), ve += "n"), de += ` It must be ${V}. Received ${ve}`, de;
        },
        RangeError
      );
      function $(M) {
        let V = "", q = M.length;
        const de = M[0] === "-" ? 1 : 0;
        for (; q >= de + 4; q -= 3)
          V = `_${M.slice(q - 3, q)}${V}`;
        return `${M.slice(0, q)}${V}`;
      }
      function D(M, V, q) {
        pe(V, "offset"), (M[V] === void 0 || M[V + q] === void 0) && Ee(V, M.length - (q + 1));
      }
      function ae(M, V, q, de, ve, Y) {
        if (M > q || M < V) {
          const I = typeof V == "bigint" ? "n" : "";
          let B;
          throw V === 0 || V === BigInt(0) ? B = `>= 0${I} and < 2${I} ** ${(Y + 1) * 8}${I}` : B = `>= -(2${I} ** ${(Y + 1) * 8 - 1}${I}) and < 2 ** ${(Y + 1) * 8 - 1}${I}`, new Je.ERR_OUT_OF_RANGE("value", B, M);
        }
        D(de, ve, Y);
      }
      function pe(M, V) {
        if (typeof M != "number")
          throw new Je.ERR_INVALID_ARG_TYPE(V, "number", M);
      }
      function Ee(M, V, q) {
        throw Math.floor(M) !== M ? (pe(M, q), new Je.ERR_OUT_OF_RANGE("offset", "an integer", M)) : V < 0 ? new Je.ERR_BUFFER_OUT_OF_BOUNDS() : new Je.ERR_OUT_OF_RANGE(
          "offset",
          `>= 0 and <= ${V}`,
          M
        );
      }
      const Me = /[^+/0-9A-Za-z-_]/g;
      function ot(M) {
        if (M = M.split("=")[0], M = M.trim().replace(Me, ""), M.length < 2) return "";
        for (; M.length % 4 !== 0; )
          M = M + "=";
        return M;
      }
      function dt(M, V) {
        V = V || 1 / 0;
        let q;
        const de = M.length;
        let ve = null;
        const Y = [];
        for (let I = 0; I < de; ++I) {
          if (q = M.charCodeAt(I), q > 55295 && q < 57344) {
            if (!ve) {
              if (q > 56319) {
                (V -= 3) > -1 && Y.push(239, 191, 189);
                continue;
              } else if (I + 1 === de) {
                (V -= 3) > -1 && Y.push(239, 191, 189);
                continue;
              }
              ve = q;
              continue;
            }
            if (q < 56320) {
              (V -= 3) > -1 && Y.push(239, 191, 189), ve = q;
              continue;
            }
            q = (ve - 55296 << 10 | q - 56320) + 65536;
          } else ve && (V -= 3) > -1 && Y.push(239, 191, 189);
          if (ve = null, q < 128) {
            if ((V -= 1) < 0) break;
            Y.push(q);
          } else if (q < 2048) {
            if ((V -= 2) < 0) break;
            Y.push(
              q >> 6 | 192,
              q & 63 | 128
            );
          } else if (q < 65536) {
            if ((V -= 3) < 0) break;
            Y.push(
              q >> 12 | 224,
              q >> 6 & 63 | 128,
              q & 63 | 128
            );
          } else if (q < 1114112) {
            if ((V -= 4) < 0) break;
            Y.push(
              q >> 18 | 240,
              q >> 12 & 63 | 128,
              q >> 6 & 63 | 128,
              q & 63 | 128
            );
          } else
            throw new Error("Invalid code point");
        }
        return Y;
      }
      function St(M) {
        const V = [];
        for (let q = 0; q < M.length; ++q)
          V.push(M.charCodeAt(q) & 255);
        return V;
      }
      function rt(M, V) {
        let q, de, ve;
        const Y = [];
        for (let I = 0; I < M.length && !((V -= 2) < 0); ++I)
          q = M.charCodeAt(I), de = q >> 8, ve = q % 256, Y.push(ve), Y.push(de);
        return Y;
      }
      function zt(M) {
        return x.toByteArray(ot(M));
      }
      function Xt(M, V, q, de) {
        let ve;
        for (ve = 0; ve < de && !(ve + q >= V.length || ve >= M.length); ++ve)
          V[ve + q] = M[ve];
        return ve;
      }
      function tr(M, V) {
        return M instanceof V || M != null && M.constructor != null && M.constructor.name != null && M.constructor.name === V.name;
      }
      function Nr(M) {
        return M !== M;
      }
      const ki = function() {
        const M = "0123456789abcdef", V = new Array(256);
        for (let q = 0; q < 16; ++q) {
          const de = q * 16;
          for (let ve = 0; ve < 16; ++ve)
            V[de + ve] = M[q] + M[ve];
        }
        return V;
      }();
      function Zt(M) {
        return typeof BigInt > "u" ? Vn : M;
      }
      function Vn() {
        throw new Error("BigInt not supported");
      }
    })(e);
    const E = e.Buffer;
    t.Blob = e.Blob, t.BlobOptions = e.BlobOptions, t.Buffer = e.Buffer, t.File = e.File, t.FileOptions = e.FileOptions, t.INSPECT_MAX_BYTES = e.INSPECT_MAX_BYTES, t.SlowBuffer = e.SlowBuffer, t.TranscodeEncoding = e.TranscodeEncoding, t.atob = e.atob, t.btoa = e.btoa, t.constants = e.constants, t.default = E, t.isAscii = e.isAscii, t.isUtf8 = e.isUtf8, t.kMaxLength = e.kMaxLength, t.kStringMaxLength = e.kStringMaxLength, t.resolveObjectURL = e.resolveObjectURL, t.transcode = e.transcode;
  }(M_)), M_;
}
var D_ = {}, $_ = {}, j_, B_;
function nj() {
  return B_ || (B_ = 1, j_ = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, e = Symbol("test"), r = Object(e);
    if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
      return !1;
    var n = 42;
    t[e] = n;
    for (var i in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var s = Object.getOwnPropertySymbols(t);
    if (s.length !== 1 || s[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, e)
      );
      if (o.value !== n || o.enumerable !== !0)
        return !1;
    }
    return !0;
  }), j_;
}
var jw, F_;
function Mb() {
  if (F_) return jw;
  F_ = 1;
  var t = nj();
  return jw = function() {
    return t() && !!Symbol.toStringTag;
  }, jw;
}
var z_, V_;
function ij() {
  return V_ || (V_ = 1, z_ = Object), z_;
}
var U_, H_;
function wye() {
  return H_ || (H_ = 1, U_ = Error), U_;
}
var G_, W_;
function xye() {
  return W_ || (W_ = 1, G_ = EvalError), G_;
}
var q_, Q_;
function Eye() {
  return Q_ || (Q_ = 1, q_ = RangeError), q_;
}
var K_, Y_;
function Sye() {
  return Y_ || (Y_ = 1, K_ = ReferenceError), K_;
}
var Z_, J_;
function sj() {
  return J_ || (J_ = 1, Z_ = SyntaxError), Z_;
}
var X_, eC;
function Bg() {
  return eC || (eC = 1, X_ = TypeError), X_;
}
var tC, rC;
function Aye() {
  return rC || (rC = 1, tC = URIError), tC;
}
var nC, iC;
function kye() {
  return iC || (iC = 1, nC = Math.abs), nC;
}
var sC, oC;
function _ye() {
  return oC || (oC = 1, sC = Math.floor), sC;
}
var aC, lC;
function Cye() {
  return lC || (lC = 1, aC = Math.max), aC;
}
var cC, uC;
function Iye() {
  return uC || (uC = 1, cC = Math.min), cC;
}
var hC, pC;
function Pye() {
  return pC || (pC = 1, hC = Math.pow), hC;
}
var dC, fC;
function Rye() {
  return fC || (fC = 1, dC = Math.round), dC;
}
var gC, mC;
function Oye() {
  return mC || (mC = 1, gC = Number.isNaN || function(t) {
    return t !== t;
  }), gC;
}
var Bw, yC;
function Tye() {
  if (yC) return Bw;
  yC = 1;
  var t = /* @__PURE__ */ Oye();
  return Bw = function(e) {
    return t(e) || e === 0 ? e : e < 0 ? -1 : 1;
  }, Bw;
}
var bC, vC;
function Lye() {
  return vC || (vC = 1, bC = Object.getOwnPropertyDescriptor), bC;
}
var Fw, wC;
function Dd() {
  if (wC) return Fw;
  wC = 1;
  var t = /* @__PURE__ */ Lye();
  if (t)
    try {
      t([], "length");
    } catch {
      t = null;
    }
  return Fw = t, Fw;
}
var zw, xC;
function Nb() {
  if (xC) return zw;
  xC = 1;
  var t = Object.defineProperty || !1;
  if (t)
    try {
      t({}, "a", { value: 1 });
    } catch {
      t = !1;
    }
  return zw = t, zw;
}
var Vw, EC;
function Mye() {
  if (EC) return Vw;
  EC = 1;
  var t = typeof Symbol < "u" && Symbol, e = nj();
  return Vw = function() {
    return typeof t != "function" || typeof Symbol != "function" || typeof t("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e();
  }, Vw;
}
var SC, AC;
function oj() {
  return AC || (AC = 1, SC = typeof Reflect < "u" && Reflect.getPrototypeOf || null), SC;
}
var Uw, kC;
function aj() {
  if (kC) return Uw;
  kC = 1;
  var t = /* @__PURE__ */ ij();
  return Uw = t.getPrototypeOf || null, Uw;
}
var Hw, _C;
function Nye() {
  if (_C) return Hw;
  _C = 1;
  var t = "Function.prototype.bind called on incompatible ", e = Object.prototype.toString, r = Math.max, n = "[object Function]", i = function(a, l) {
    for (var c = [], p = 0; p < a.length; p += 1)
      c[p] = a[p];
    for (var h = 0; h < l.length; h += 1)
      c[h + a.length] = l[h];
    return c;
  }, s = function(a, l) {
    for (var c = [], p = l, h = 0; p < a.length; p += 1, h += 1)
      c[h] = a[p];
    return c;
  }, o = function(a, l) {
    for (var c = "", p = 0; p < a.length; p += 1)
      c += a[p], p + 1 < a.length && (c += l);
    return c;
  };
  return Hw = function(a) {
    var l = this;
    if (typeof l != "function" || e.apply(l) !== n)
      throw new TypeError(t + l);
    for (var c = s(arguments, 1), p, h = function() {
      if (this instanceof p) {
        var f = l.apply(
          this,
          i(c, arguments)
        );
        return Object(f) === f ? f : this;
      }
      return l.apply(
        a,
        i(c, arguments)
      );
    }, d = r(0, l.length - c.length), b = [], m = 0; m < d; m++)
      b[m] = "$" + m;
    if (p = Function("binder", "return function (" + o(b, ",") + "){ return binder.apply(this,arguments); }")(h), l.prototype) {
      var w = function() {
      };
      w.prototype = l.prototype, p.prototype = new w(), w.prototype = null;
    }
    return p;
  }, Hw;
}
var Gw, CC;
function Fg() {
  if (CC) return Gw;
  CC = 1;
  var t = Nye();
  return Gw = Function.prototype.bind || t, Gw;
}
var IC, PC;
function mS() {
  return PC || (PC = 1, IC = Function.prototype.call), IC;
}
var RC, OC;
function yS() {
  return OC || (OC = 1, RC = Function.prototype.apply), RC;
}
var TC, LC;
function Dye() {
  return LC || (LC = 1, TC = typeof Reflect < "u" && Reflect && Reflect.apply), TC;
}
var Ww, MC;
function lj() {
  if (MC) return Ww;
  MC = 1;
  var t = Fg(), e = yS(), r = mS(), n = Dye();
  return Ww = n || t.call(r, e), Ww;
}
var qw, NC;
function bS() {
  if (NC) return qw;
  NC = 1;
  var t = Fg(), e = /* @__PURE__ */ Bg(), r = mS(), n = lj();
  return qw = function(i) {
    if (i.length < 1 || typeof i[0] != "function")
      throw new e("a function is required");
    return n(t, r, i);
  }, qw;
}
var Qw, DC;
function $ye() {
  if (DC) return Qw;
  DC = 1;
  var t = bS(), e = /* @__PURE__ */ Dd(), r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var n = !!r && e && e(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, s = i.getPrototypeOf;
  return Qw = n && typeof n.get == "function" ? t([n.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(o) {
      return s(o == null ? o : i(o));
    }
  ) : !1, Qw;
}
var Kw, $C;
function cj() {
  if ($C) return Kw;
  $C = 1;
  var t = oj(), e = aj(), r = /* @__PURE__ */ $ye();
  return Kw = t ? function(n) {
    return t(n);
  } : e ? function(n) {
    if (!n || typeof n != "object" && typeof n != "function")
      throw new TypeError("getProto: not an object");
    return e(n);
  } : r ? function(n) {
    return r(n);
  } : null, Kw;
}
var Yw, jC;
function uj() {
  if (jC) return Yw;
  jC = 1;
  var t = Function.prototype.call, e = Object.prototype.hasOwnProperty, r = Fg();
  return Yw = r.call(t, e), Yw;
}
var Zw, BC;
function hj() {
  if (BC) return Zw;
  BC = 1;
  var t, e = /* @__PURE__ */ ij(), r = /* @__PURE__ */ wye(), n = /* @__PURE__ */ xye(), i = /* @__PURE__ */ Eye(), s = /* @__PURE__ */ Sye(), o = /* @__PURE__ */ sj(), a = /* @__PURE__ */ Bg(), l = /* @__PURE__ */ Aye(), c = /* @__PURE__ */ kye(), p = /* @__PURE__ */ _ye(), h = /* @__PURE__ */ Cye(), d = /* @__PURE__ */ Iye(), b = /* @__PURE__ */ Pye(), m = /* @__PURE__ */ Rye(), w = /* @__PURE__ */ Tye(), f = Function, E = function(oe) {
    try {
      return f('"use strict"; return (' + oe + ").constructor;")();
    } catch {
    }
  }, A = /* @__PURE__ */ Dd(), x = /* @__PURE__ */ Nb(), g = function() {
    throw new a();
  }, v = A ? function() {
    try {
      return arguments.callee, g;
    } catch {
      try {
        return A(arguments, "callee").get;
      } catch {
        return g;
      }
    }
  }() : g, k = Mye()(), S = cj(), R = aj(), L = oj(), F = yS(), z = mS(), j = {}, ee = typeof Uint8Array > "u" || !S ? t : S(Uint8Array), X = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? t : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? t : ArrayBuffer,
    "%ArrayIteratorPrototype%": k && S ? S([][Symbol.iterator]()) : t,
    "%AsyncFromSyncIteratorPrototype%": t,
    "%AsyncFunction%": j,
    "%AsyncGenerator%": j,
    "%AsyncGeneratorFunction%": j,
    "%AsyncIteratorPrototype%": j,
    "%Atomics%": typeof Atomics > "u" ? t : Atomics,
    "%BigInt%": typeof BigInt > "u" ? t : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? t : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? t : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? t : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": r,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": n,
    "%Float32Array%": typeof Float32Array > "u" ? t : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? t : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? t : FinalizationRegistry,
    "%Function%": f,
    "%GeneratorFunction%": j,
    "%Int8Array%": typeof Int8Array > "u" ? t : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? t : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? t : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": k && S ? S(S([][Symbol.iterator]())) : t,
    "%JSON%": typeof JSON == "object" ? JSON : t,
    "%Map%": typeof Map > "u" ? t : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !k || !S ? t : S((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": e,
    "%Object.getOwnPropertyDescriptor%": A,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? t : Promise,
    "%Proxy%": typeof Proxy > "u" ? t : Proxy,
    "%RangeError%": i,
    "%ReferenceError%": s,
    "%Reflect%": typeof Reflect > "u" ? t : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? t : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !k || !S ? t : S((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? t : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": k && S ? S(""[Symbol.iterator]()) : t,
    "%Symbol%": k ? Symbol : t,
    "%SyntaxError%": o,
    "%ThrowTypeError%": v,
    "%TypedArray%": ee,
    "%TypeError%": a,
    "%Uint8Array%": typeof Uint8Array > "u" ? t : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? t : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? t : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? t : Uint32Array,
    "%URIError%": l,
    "%WeakMap%": typeof WeakMap > "u" ? t : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? t : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? t : WeakSet,
    "%Function.prototype.call%": z,
    "%Function.prototype.apply%": F,
    "%Object.defineProperty%": x,
    "%Object.getPrototypeOf%": R,
    "%Math.abs%": c,
    "%Math.floor%": p,
    "%Math.max%": h,
    "%Math.min%": d,
    "%Math.pow%": b,
    "%Math.round%": m,
    "%Math.sign%": w,
    "%Reflect.getPrototypeOf%": L
  };
  if (S)
    try {
      null.error;
    } catch (oe) {
      var ie = S(S(oe));
      X["%Error.prototype%"] = ie;
    }
  var ce = function oe(fe) {
    var H;
    if (fe === "%AsyncFunction%")
      H = E("async function () {}");
    else if (fe === "%GeneratorFunction%")
      H = E("function* () {}");
    else if (fe === "%AsyncGeneratorFunction%")
      H = E("async function* () {}");
    else if (fe === "%AsyncGenerator%") {
      var J = oe("%AsyncGeneratorFunction%");
      J && (H = J.prototype);
    } else if (fe === "%AsyncIteratorPrototype%") {
      var Se = oe("%AsyncGenerator%");
      Se && S && (H = S(Se.prototype));
    }
    return X[fe] = H, H;
  }, ke = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, ye = Fg(), Ce = /* @__PURE__ */ uj(), Ie = ye.call(z, Array.prototype.concat), Te = ye.call(F, Array.prototype.splice), ue = ye.call(z, String.prototype.replace), O = ye.call(z, String.prototype.slice), N = ye.call(z, RegExp.prototype.exec), Z = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, re = /\\(\\)?/g, le = function(oe) {
    var fe = O(oe, 0, 1), H = O(oe, -1);
    if (fe === "%" && H !== "%")
      throw new o("invalid intrinsic syntax, expected closing `%`");
    if (H === "%" && fe !== "%")
      throw new o("invalid intrinsic syntax, expected opening `%`");
    var J = [];
    return ue(oe, Z, function(Se, Re, Fe, Le) {
      J[J.length] = Fe ? ue(Le, re, "$1") : Re || Se;
    }), J;
  }, te = function(oe, fe) {
    var H = oe, J;
    if (Ce(ke, H) && (J = ke[H], H = "%" + J[0] + "%"), Ce(X, H)) {
      var Se = X[H];
      if (Se === j && (Se = ce(H)), typeof Se > "u" && !fe)
        throw new a("intrinsic " + oe + " exists, but is not available. Please file an issue!");
      return {
        alias: J,
        name: H,
        value: Se
      };
    }
    throw new o("intrinsic " + oe + " does not exist!");
  };
  return Zw = function(oe, fe) {
    if (typeof oe != "string" || oe.length === 0)
      throw new a("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof fe != "boolean")
      throw new a('"allowMissing" argument must be a boolean');
    if (N(/^%?[^%]*%?$/, oe) === null)
      throw new o("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var H = le(oe), J = H.length > 0 ? H[0] : "", Se = te("%" + J + "%", fe), Re = Se.name, Fe = Se.value, Le = !1, ze = Se.alias;
    ze && (J = ze[0], Te(H, Ie([0, 1], ze)));
    for (var tt = 1, Pe = !0; tt < H.length; tt += 1) {
      var At = H[tt], er = O(At, 0, 1), me = O(At, -1);
      if ((er === '"' || er === "'" || er === "`" || me === '"' || me === "'" || me === "`") && er !== me)
        throw new o("property names with quotes must have matching quotes");
      if ((At === "constructor" || !Pe) && (Le = !0), J += "." + At, Re = "%" + J + "%", Ce(X, Re))
        Fe = X[Re];
      else if (Fe != null) {
        if (!(At in Fe)) {
          if (!fe)
            throw new a("base intrinsic for " + oe + " exists, but the property is not available.");
          return;
        }
        if (A && tt + 1 >= H.length) {
          var ht = A(Fe, At);
          Pe = !!ht, Pe && "get" in ht && !("originalValue" in ht.get) ? Fe = ht.get : Fe = Fe[At];
        } else
          Pe = Ce(Fe, At), Fe = Fe[At];
        Pe && !Le && (X[Re] = Fe);
      }
    }
    return Fe;
  }, Zw;
}
var Jw, FC;
function zg() {
  if (FC) return Jw;
  FC = 1;
  var t = /* @__PURE__ */ hj(), e = bS(), r = e([t("%String.prototype.indexOf%")]);
  return Jw = function(n, i) {
    var s = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      t(n, !!i)
    );
    return typeof s == "function" && r(n, ".prototype.") > -1 ? e([s]) : s;
  }, Jw;
}
var Xw, zC;
function jye() {
  if (zC) return Xw;
  zC = 1;
  var t = Mb()(), e = /* @__PURE__ */ zg(), r = e("Object.prototype.toString"), n = function(o) {
    return t && o && typeof o == "object" && Symbol.toStringTag in o ? !1 : r(o) === "[object Arguments]";
  }, i = function(o) {
    return n(o) ? !0 : o !== null && typeof o == "object" && "length" in o && typeof o.length == "number" && o.length >= 0 && r(o) !== "[object Array]" && "callee" in o && r(o.callee) === "[object Function]";
  }, s = function() {
    return n(arguments);
  }();
  return n.isLegacyArguments = i, Xw = s ? n : i, Xw;
}
var e3, VC;
function Bye() {
  if (VC) return e3;
  VC = 1;
  var t = /* @__PURE__ */ zg(), e = Mb()(), r = /* @__PURE__ */ uj(), n = /* @__PURE__ */ Dd(), i;
  if (e) {
    var s = t("RegExp.prototype.exec"), o = {}, a = function() {
      throw o;
    }, l = {
      toString: a,
      valueOf: a
    };
    typeof Symbol.toPrimitive == "symbol" && (l[Symbol.toPrimitive] = a), i = function(h) {
      if (!h || typeof h != "object")
        return !1;
      var d = (
        /** @type {NonNullable<typeof gOPD>} */
        n(
          /** @type {{ lastIndex?: unknown }} */
          h,
          "lastIndex"
        )
      ), b = d && r(d, "value");
      if (!b)
        return !1;
      try {
        s(
          h,
          /** @type {string} */
          /** @type {unknown} */
          l
        );
      } catch (m) {
        return m === o;
      }
    };
  } else {
    var c = t("Object.prototype.toString"), p = "[object RegExp]";
    i = function(h) {
      return !h || typeof h != "object" && typeof h != "function" ? !1 : c(h) === p;
    };
  }
  return e3 = i, e3;
}
var t3, UC;
function Fye() {
  if (UC) return t3;
  UC = 1;
  var t = /* @__PURE__ */ zg(), e = Bye(), r = t("RegExp.prototype.exec"), n = /* @__PURE__ */ Bg();
  return t3 = function(i) {
    if (!e(i))
      throw new n("`regex` must be a RegExp");
    return function(s) {
      return r(i, s) !== null;
    };
  }, t3;
}
var r3, HC;
function zye() {
  if (HC) return r3;
  HC = 1;
  var t = /* @__PURE__ */ zg(), e = /* @__PURE__ */ Fye(), r = e(/^\s*(?:function)?\*/), n = Mb()(), i = cj(), s = t("Object.prototype.toString"), o = t("Function.prototype.toString"), a = function() {
    if (!n)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, l;
  return r3 = function(c) {
    if (typeof c != "function")
      return !1;
    if (r(o(c)))
      return !0;
    if (!n) {
      var p = s(c);
      return p === "[object GeneratorFunction]";
    }
    if (!i)
      return !1;
    if (typeof l > "u") {
      var h = a();
      l = h ? (
        /** @type {GeneratorFunctionConstructor} */
        i(h)
      ) : !1;
    }
    return i(c) === l;
  }, r3;
}
var n3, GC;
function Vye() {
  if (GC) return n3;
  GC = 1;
  var t = Function.prototype.toString, e = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, n;
  if (typeof e == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw n;
        }
      }), n = {}, e(function() {
        throw 42;
      }, null, r);
    } catch (A) {
      A !== n && (e = null);
    }
  else
    e = null;
  var i = /^\s*class\b/, s = function(A) {
    try {
      var x = t.call(A);
      return i.test(x);
    } catch {
      return !1;
    }
  }, o = function(A) {
    try {
      return s(A) ? !1 : (t.call(A), !0);
    } catch {
      return !1;
    }
  }, a = Object.prototype.toString, l = "[object Object]", c = "[object Function]", p = "[object GeneratorFunction]", h = "[object HTMLAllCollection]", d = "[object HTML document.all class]", b = "[object HTMLCollection]", m = typeof Symbol == "function" && !!Symbol.toStringTag, w = !(0 in [,]), f = function() {
    return !1;
  };
  if (typeof document == "object") {
    var E = document.all;
    a.call(E) === a.call(document.all) && (f = function(A) {
      if ((w || !A) && (typeof A > "u" || typeof A == "object"))
        try {
          var x = a.call(A);
          return (x === h || x === d || x === b || x === l) && A("") == null;
        } catch {
        }
      return !1;
    });
  }
  return n3 = e ? function(A) {
    if (f(A))
      return !0;
    if (!A || typeof A != "function" && typeof A != "object")
      return !1;
    try {
      e(A, null, r);
    } catch (x) {
      if (x !== n)
        return !1;
    }
    return !s(A) && o(A);
  } : function(A) {
    if (f(A))
      return !0;
    if (!A || typeof A != "function" && typeof A != "object")
      return !1;
    if (m)
      return o(A);
    if (s(A))
      return !1;
    var x = a.call(A);
    return x !== c && x !== p && !/^\[object HTML/.test(x) ? !1 : o(A);
  }, n3;
}
var i3, WC;
function Uye() {
  if (WC) return i3;
  WC = 1;
  var t = Vye(), e = Object.prototype.toString, r = Object.prototype.hasOwnProperty, n = function(a, l, c) {
    for (var p = 0, h = a.length; p < h; p++)
      r.call(a, p) && (c == null ? l(a[p], p, a) : l.call(c, a[p], p, a));
  }, i = function(a, l, c) {
    for (var p = 0, h = a.length; p < h; p++)
      c == null ? l(a.charAt(p), p, a) : l.call(c, a.charAt(p), p, a);
  }, s = function(a, l, c) {
    for (var p in a)
      r.call(a, p) && (c == null ? l(a[p], p, a) : l.call(c, a[p], p, a));
  }, o = function(a, l, c) {
    if (!t(l))
      throw new TypeError("iterator must be a function");
    var p;
    arguments.length >= 3 && (p = c), e.call(a) === "[object Array]" ? n(a, l, p) : typeof a == "string" ? i(a, l, p) : s(a, l, p);
  };
  return i3 = o, i3;
}
var qC, QC;
function Hye() {
  return QC || (QC = 1, qC = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), qC;
}
var s3, KC;
function Gye() {
  if (KC) return s3;
  KC = 1;
  var t = /* @__PURE__ */ Hye(), e = typeof globalThis > "u" ? Xl : globalThis;
  return s3 = function() {
    for (var r = [], n = 0; n < t.length; n++)
      typeof e[t[n]] == "function" && (r[r.length] = t[n]);
    return r;
  }, s3;
}
var YC = { exports: {} }, o3, ZC;
function Wye() {
  if (ZC) return o3;
  ZC = 1;
  var t = /* @__PURE__ */ Nb(), e = /* @__PURE__ */ sj(), r = /* @__PURE__ */ Bg(), n = /* @__PURE__ */ Dd();
  return o3 = function(i, s, o) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new r("`obj` must be an object or a function`");
    if (typeof s != "string" && typeof s != "symbol")
      throw new r("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new r("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new r("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new r("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new r("`loose`, if provided, must be a boolean");
    var a = arguments.length > 3 ? arguments[3] : null, l = arguments.length > 4 ? arguments[4] : null, c = arguments.length > 5 ? arguments[5] : null, p = arguments.length > 6 ? arguments[6] : !1, h = !!n && n(i, s);
    if (t)
      t(i, s, {
        configurable: c === null && h ? h.configurable : !c,
        enumerable: a === null && h ? h.enumerable : !a,
        value: o,
        writable: l === null && h ? h.writable : !l
      });
    else if (p || !a && !l && !c)
      i[s] = o;
    else
      throw new e("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, o3;
}
var a3, JC;
function qye() {
  if (JC) return a3;
  JC = 1;
  var t = /* @__PURE__ */ Nb(), e = function() {
    return !!t;
  };
  return e.hasArrayLengthDefineBug = function() {
    if (!t)
      return null;
    try {
      return t([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, a3 = e, a3;
}
var l3, XC;
function Qye() {
  if (XC) return l3;
  XC = 1;
  var t = /* @__PURE__ */ hj(), e = /* @__PURE__ */ Wye(), r = /* @__PURE__ */ qye()(), n = /* @__PURE__ */ Dd(), i = /* @__PURE__ */ Bg(), s = t("%Math.floor%");
  return l3 = function(o, a) {
    if (typeof o != "function")
      throw new i("`fn` is not a function");
    if (typeof a != "number" || a < 0 || a > 4294967295 || s(a) !== a)
      throw new i("`length` must be a positive 32-bit integer");
    var l = arguments.length > 2 && !!arguments[2], c = !0, p = !0;
    if ("length" in o && n) {
      var h = n(o, "length");
      h && !h.configurable && (c = !1), h && !h.writable && (p = !1);
    }
    return (c || p || !l) && (r ? e(
      /** @type {Parameters<define>[0]} */
      o,
      "length",
      a,
      !0,
      !0
    ) : e(
      /** @type {Parameters<define>[0]} */
      o,
      "length",
      a
    )), o;
  }, l3;
}
var c3, eI;
function Kye() {
  if (eI) return c3;
  eI = 1;
  var t = Fg(), e = yS(), r = lj();
  return c3 = function() {
    return r(t, e, arguments);
  }, c3;
}
var tI;
function Yye() {
  return tI || (tI = 1, function(t) {
    var e = /* @__PURE__ */ Qye(), r = /* @__PURE__ */ Nb(), n = bS(), i = Kye();
    t.exports = function(s) {
      var o = n(arguments), a = s.length - (arguments.length - 1);
      return e(
        o,
        1 + (a > 0 ? a : 0),
        !0
      );
    }, r ? r(t.exports, "apply", { value: i }) : t.exports.apply = i;
  }(YC)), YC.exports;
}
var u3, rI;
function pj() {
  if (rI) return u3;
  rI = 1;
  var t = Uye(), e = /* @__PURE__ */ Gye(), r = Yye(), n = /* @__PURE__ */ zg(), i = /* @__PURE__ */ Dd(), s = n("Object.prototype.toString"), o = Mb()(), a = typeof globalThis > "u" ? Xl : globalThis, l = e(), c = n("String.prototype.slice"), p = Object.getPrototypeOf, h = n("Array.prototype.indexOf", !0) || function(w, f) {
    for (var E = 0; E < w.length; E += 1)
      if (w[E] === f)
        return E;
    return -1;
  }, d = { __proto__: null };
  o && i && p ? t(l, function(w) {
    var f = new a[w]();
    if (Symbol.toStringTag in f) {
      var E = p(f), A = i(E, Symbol.toStringTag);
      if (!A) {
        var x = p(E);
        A = i(x, Symbol.toStringTag);
      }
      d["$" + w] = r(A.get);
    }
  }) : t(l, function(w) {
    var f = new a[w](), E = f.slice || f.set;
    E && (d["$" + w] = r(E));
  });
  var b = function(w) {
    var f = !1;
    return t(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      d,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, A) {
        if (!f)
          try {
            "$" + E(w) === A && (f = c(A, 1));
          } catch {
          }
      }
    ), f;
  }, m = function(w) {
    var f = !1;
    return t(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      d,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, A) {
        if (!f)
          try {
            E(w), f = c(A, 1);
          } catch {
          }
      }
    ), f;
  };
  return u3 = function(w) {
    if (!w || typeof w != "object")
      return !1;
    if (!o) {
      var f = c(s(w), 8, -1);
      return h(l, f) > -1 ? f : f !== "Object" ? !1 : m(w);
    }
    return i ? b(w) : null;
  }, u3;
}
var h3, nI;
function Zye() {
  if (nI) return h3;
  nI = 1;
  var t = /* @__PURE__ */ pj();
  return h3 = function(e) {
    return !!t(e);
  }, h3;
}
var iI;
function Jye() {
  return iI || (iI = 1, function(t) {
    var e = /* @__PURE__ */ jye(), r = zye(), n = /* @__PURE__ */ pj(), i = /* @__PURE__ */ Zye();
    function s(Pe) {
      return Pe.call.bind(Pe);
    }
    var o = typeof BigInt < "u", a = typeof Symbol < "u", l = s(Object.prototype.toString), c = s(Number.prototype.valueOf), p = s(String.prototype.valueOf), h = s(Boolean.prototype.valueOf);
    if (o)
      var d = s(BigInt.prototype.valueOf);
    if (a)
      var b = s(Symbol.prototype.valueOf);
    function m(Pe, At) {
      if (typeof Pe != "object")
        return !1;
      try {
        return At(Pe), !0;
      } catch {
        return !1;
      }
    }
    t.isArgumentsObject = e, t.isGeneratorFunction = r, t.isTypedArray = i;
    function w(Pe) {
      return typeof Promise < "u" && Pe instanceof Promise || Pe !== null && typeof Pe == "object" && typeof Pe.then == "function" && typeof Pe.catch == "function";
    }
    t.isPromise = w;
    function f(Pe) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Pe) : i(Pe) || O(Pe);
    }
    t.isArrayBufferView = f;
    function E(Pe) {
      return n(Pe) === "Uint8Array";
    }
    t.isUint8Array = E;
    function A(Pe) {
      return n(Pe) === "Uint8ClampedArray";
    }
    t.isUint8ClampedArray = A;
    function x(Pe) {
      return n(Pe) === "Uint16Array";
    }
    t.isUint16Array = x;
    function g(Pe) {
      return n(Pe) === "Uint32Array";
    }
    t.isUint32Array = g;
    function v(Pe) {
      return n(Pe) === "Int8Array";
    }
    t.isInt8Array = v;
    function k(Pe) {
      return n(Pe) === "Int16Array";
    }
    t.isInt16Array = k;
    function S(Pe) {
      return n(Pe) === "Int32Array";
    }
    t.isInt32Array = S;
    function R(Pe) {
      return n(Pe) === "Float32Array";
    }
    t.isFloat32Array = R;
    function L(Pe) {
      return n(Pe) === "Float64Array";
    }
    t.isFloat64Array = L;
    function F(Pe) {
      return n(Pe) === "BigInt64Array";
    }
    t.isBigInt64Array = F;
    function z(Pe) {
      return n(Pe) === "BigUint64Array";
    }
    t.isBigUint64Array = z;
    function j(Pe) {
      return l(Pe) === "[object Map]";
    }
    j.working = typeof Map < "u" && j(/* @__PURE__ */ new Map());
    function ee(Pe) {
      return typeof Map > "u" ? !1 : j.working ? j(Pe) : Pe instanceof Map;
    }
    t.isMap = ee;
    function X(Pe) {
      return l(Pe) === "[object Set]";
    }
    X.working = typeof Set < "u" && X(/* @__PURE__ */ new Set());
    function ie(Pe) {
      return typeof Set > "u" ? !1 : X.working ? X(Pe) : Pe instanceof Set;
    }
    t.isSet = ie;
    function ce(Pe) {
      return l(Pe) === "[object WeakMap]";
    }
    ce.working = typeof WeakMap < "u" && ce(/* @__PURE__ */ new WeakMap());
    function ke(Pe) {
      return typeof WeakMap > "u" ? !1 : ce.working ? ce(Pe) : Pe instanceof WeakMap;
    }
    t.isWeakMap = ke;
    function ye(Pe) {
      return l(Pe) === "[object WeakSet]";
    }
    ye.working = typeof WeakSet < "u" && ye(/* @__PURE__ */ new WeakSet());
    function Ce(Pe) {
      return ye(Pe);
    }
    t.isWeakSet = Ce;
    function Ie(Pe) {
      return l(Pe) === "[object ArrayBuffer]";
    }
    Ie.working = typeof ArrayBuffer < "u" && Ie(new ArrayBuffer());
    function Te(Pe) {
      return typeof ArrayBuffer > "u" ? !1 : Ie.working ? Ie(Pe) : Pe instanceof ArrayBuffer;
    }
    t.isArrayBuffer = Te;
    function ue(Pe) {
      return l(Pe) === "[object DataView]";
    }
    ue.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ue(new DataView(new ArrayBuffer(1), 0, 1));
    function O(Pe) {
      return typeof DataView > "u" ? !1 : ue.working ? ue(Pe) : Pe instanceof DataView;
    }
    t.isDataView = O;
    var N = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function Z(Pe) {
      return l(Pe) === "[object SharedArrayBuffer]";
    }
    function re(Pe) {
      return typeof N > "u" ? !1 : (typeof Z.working > "u" && (Z.working = Z(new N())), Z.working ? Z(Pe) : Pe instanceof N);
    }
    t.isSharedArrayBuffer = re;
    function le(Pe) {
      return l(Pe) === "[object AsyncFunction]";
    }
    t.isAsyncFunction = le;
    function te(Pe) {
      return l(Pe) === "[object Map Iterator]";
    }
    t.isMapIterator = te;
    function oe(Pe) {
      return l(Pe) === "[object Set Iterator]";
    }
    t.isSetIterator = oe;
    function fe(Pe) {
      return l(Pe) === "[object Generator]";
    }
    t.isGeneratorObject = fe;
    function H(Pe) {
      return l(Pe) === "[object WebAssembly.Module]";
    }
    t.isWebAssemblyCompiledModule = H;
    function J(Pe) {
      return m(Pe, c);
    }
    t.isNumberObject = J;
    function Se(Pe) {
      return m(Pe, p);
    }
    t.isStringObject = Se;
    function Re(Pe) {
      return m(Pe, h);
    }
    t.isBooleanObject = Re;
    function Fe(Pe) {
      return o && m(Pe, d);
    }
    t.isBigIntObject = Fe;
    function Le(Pe) {
      return a && m(Pe, b);
    }
    t.isSymbolObject = Le;
    function ze(Pe) {
      return J(Pe) || Se(Pe) || Re(Pe) || Fe(Pe) || Le(Pe);
    }
    t.isBoxedPrimitive = ze;
    function tt(Pe) {
      return typeof Uint8Array < "u" && (Te(Pe) || re(Pe));
    }
    t.isAnyArrayBuffer = tt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Pe) {
      Object.defineProperty(t, Pe, {
        enumerable: !1,
        value: function() {
          throw new Error(Pe + " is not supported in userland");
        }
      });
    });
  }($_)), $_;
}
var sI, oI;
function Xye() {
  return oI || (oI = 1, sI = function(t) {
    return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
  }), sI;
}
var aI;
function dj() {
  return aI || (aI = 1, function(t) {
    var e = Object.getOwnPropertyDescriptors || function(ue) {
      for (var O = Object.keys(ue), N = {}, Z = 0; Z < O.length; Z++)
        N[O[Z]] = Object.getOwnPropertyDescriptor(ue, O[Z]);
      return N;
    }, r = /%[sdj%]/g;
    t.format = function(ue) {
      if (!v(ue)) {
        for (var O = [], N = 0; N < arguments.length; N++)
          O.push(o(arguments[N]));
        return O.join(" ");
      }
      for (var N = 1, Z = arguments, re = Z.length, le = String(ue).replace(r, function(fe) {
        if (fe === "%%") return "%";
        if (N >= re) return fe;
        switch (fe) {
          case "%s":
            return String(Z[N++]);
          case "%d":
            return Number(Z[N++]);
          case "%j":
            try {
              return JSON.stringify(Z[N++]);
            } catch {
              return "[Circular]";
            }
          default:
            return fe;
        }
      }), te = Z[N]; N < re; te = Z[++N])
        A(te) || !L(te) ? le += " " + te : le += " " + o(te);
      return le;
    }, t.deprecate = function(ue, O) {
      if (typeof Ut < "u" && Ut.noDeprecation === !0)
        return ue;
      if (typeof Ut > "u")
        return function() {
          return t.deprecate(ue, O).apply(this, arguments);
        };
      var N = !1;
      function Z() {
        if (!N) {
          if (Ut.throwDeprecation)
            throw new Error(O);
          Ut.traceDeprecation ? console.trace(O) : console.error(O), N = !0;
        }
        return ue.apply(this, arguments);
      }
      return Z;
    };
    var n = {}, i = /^$/;
    if (Ut.env.NODE_DEBUG) {
      var s = Ut.env.NODE_DEBUG;
      s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + s + "$", "i");
    }
    t.debuglog = function(ue) {
      if (ue = ue.toUpperCase(), !n[ue])
        if (i.test(ue)) {
          var O = Ut.pid;
          n[ue] = function() {
            var N = t.format.apply(t, arguments);
            console.error("%s %d: %s", ue, O, N);
          };
        } else
          n[ue] = function() {
          };
      return n[ue];
    };
    function o(ue, O) {
      var N = {
        seen: [],
        stylize: l
      };
      return arguments.length >= 3 && (N.depth = arguments[2]), arguments.length >= 4 && (N.colors = arguments[3]), E(O) ? N.showHidden = O : O && t._extend(N, O), S(N.showHidden) && (N.showHidden = !1), S(N.depth) && (N.depth = 2), S(N.colors) && (N.colors = !1), S(N.customInspect) && (N.customInspect = !0), N.colors && (N.stylize = a), p(N, ue, N.depth);
    }
    t.inspect = o, o.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, o.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function a(ue, O) {
      var N = o.styles[O];
      return N ? "\x1B[" + o.colors[N][0] + "m" + ue + "\x1B[" + o.colors[N][1] + "m" : ue;
    }
    function l(ue, O) {
      return ue;
    }
    function c(ue) {
      var O = {};
      return ue.forEach(function(N, Z) {
        O[N] = !0;
      }), O;
    }
    function p(ue, O, N) {
      if (ue.customInspect && O && j(O.inspect) && // Filter out the util module, it's inspect function is special
      O.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.
      !(O.constructor && O.constructor.prototype === O)) {
        var Z = O.inspect(N, ue);
        return v(Z) || (Z = p(ue, Z, N)), Z;
      }
      var re = h(ue, O);
      if (re)
        return re;
      var le = Object.keys(O), te = c(le);
      if (ue.showHidden && (le = Object.getOwnPropertyNames(O)), z(O) && (le.indexOf("message") >= 0 || le.indexOf("description") >= 0))
        return d(O);
      if (le.length === 0) {
        if (j(O)) {
          var oe = O.name ? ": " + O.name : "";
          return ue.stylize("[Function" + oe + "]", "special");
        }
        if (R(O))
          return ue.stylize(RegExp.prototype.toString.call(O), "regexp");
        if (F(O))
          return ue.stylize(Date.prototype.toString.call(O), "date");
        if (z(O))
          return d(O);
      }
      var fe = "", H = !1, J = ["{", "}"];
      if (f(O) && (H = !0, J = ["[", "]"]), j(O)) {
        var Se = O.name ? ": " + O.name : "";
        fe = " [Function" + Se + "]";
      }
      if (R(O) && (fe = " " + RegExp.prototype.toString.call(O)), F(O) && (fe = " " + Date.prototype.toUTCString.call(O)), z(O) && (fe = " " + d(O)), le.length === 0 && (!H || O.length == 0))
        return J[0] + fe + J[1];
      if (N < 0)
        return R(O) ? ue.stylize(RegExp.prototype.toString.call(O), "regexp") : ue.stylize("[Object]", "special");
      ue.seen.push(O);
      var Re;
      return H ? Re = b(ue, O, N, te, le) : Re = le.map(function(Fe) {
        return m(ue, O, N, te, Fe, H);
      }), ue.seen.pop(), w(Re, fe, J);
    }
    function h(ue, O) {
      if (S(O))
        return ue.stylize("undefined", "undefined");
      if (v(O)) {
        var N = "'" + JSON.stringify(O).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ue.stylize(N, "string");
      }
      if (g(O))
        return ue.stylize("" + O, "number");
      if (E(O))
        return ue.stylize("" + O, "boolean");
      if (A(O))
        return ue.stylize("null", "null");
    }
    function d(ue) {
      return "[" + Error.prototype.toString.call(ue) + "]";
    }
    function b(ue, O, N, Z, re) {
      for (var le = [], te = 0, oe = O.length; te < oe; ++te)
        ye(O, String(te)) ? le.push(m(
          ue,
          O,
          N,
          Z,
          String(te),
          !0
        )) : le.push("");
      return re.forEach(function(fe) {
        fe.match(/^\d+$/) || le.push(m(
          ue,
          O,
          N,
          Z,
          fe,
          !0
        ));
      }), le;
    }
    function m(ue, O, N, Z, re, le) {
      var te, oe, fe;
      if (fe = Object.getOwnPropertyDescriptor(O, re) || { value: O[re] }, fe.get ? fe.set ? oe = ue.stylize("[Getter/Setter]", "special") : oe = ue.stylize("[Getter]", "special") : fe.set && (oe = ue.stylize("[Setter]", "special")), ye(Z, re) || (te = "[" + re + "]"), oe || (ue.seen.indexOf(fe.value) < 0 ? (A(N) ? oe = p(ue, fe.value, null) : oe = p(ue, fe.value, N - 1), oe.indexOf(`
`) > -1 && (le ? oe = oe.split(`
`).map(function(H) {
        return "  " + H;
      }).join(`
`).slice(2) : oe = `
` + oe.split(`
`).map(function(H) {
        return "   " + H;
      }).join(`
`))) : oe = ue.stylize("[Circular]", "special")), S(te)) {
        if (le && re.match(/^\d+$/))
          return oe;
        te = JSON.stringify("" + re), te.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (te = te.slice(1, -1), te = ue.stylize(te, "name")) : (te = te.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), te = ue.stylize(te, "string"));
      }
      return te + ": " + oe;
    }
    function w(ue, O, N) {
      var Z = ue.reduce(function(re, le) {
        return le.indexOf(`
`) >= 0, re + le.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return Z > 60 ? N[0] + (O === "" ? "" : O + `
 `) + " " + ue.join(`,
  `) + " " + N[1] : N[0] + O + " " + ue.join(", ") + " " + N[1];
    }
    t.types = Jye();
    function f(ue) {
      return Array.isArray(ue);
    }
    t.isArray = f;
    function E(ue) {
      return typeof ue == "boolean";
    }
    t.isBoolean = E;
    function A(ue) {
      return ue === null;
    }
    t.isNull = A;
    function x(ue) {
      return ue == null;
    }
    t.isNullOrUndefined = x;
    function g(ue) {
      return typeof ue == "number";
    }
    t.isNumber = g;
    function v(ue) {
      return typeof ue == "string";
    }
    t.isString = v;
    function k(ue) {
      return typeof ue == "symbol";
    }
    t.isSymbol = k;
    function S(ue) {
      return ue === void 0;
    }
    t.isUndefined = S;
    function R(ue) {
      return L(ue) && X(ue) === "[object RegExp]";
    }
    t.isRegExp = R, t.types.isRegExp = R;
    function L(ue) {
      return typeof ue == "object" && ue !== null;
    }
    t.isObject = L;
    function F(ue) {
      return L(ue) && X(ue) === "[object Date]";
    }
    t.isDate = F, t.types.isDate = F;
    function z(ue) {
      return L(ue) && (X(ue) === "[object Error]" || ue instanceof Error);
    }
    t.isError = z, t.types.isNativeError = z;
    function j(ue) {
      return typeof ue == "function";
    }
    t.isFunction = j;
    function ee(ue) {
      return ue === null || typeof ue == "boolean" || typeof ue == "number" || typeof ue == "string" || typeof ue == "symbol" || // ES6 symbol
      typeof ue > "u";
    }
    t.isPrimitive = ee, t.isBuffer = Xye();
    function X(ue) {
      return Object.prototype.toString.call(ue);
    }
    function ie(ue) {
      return ue < 10 ? "0" + ue.toString(10) : ue.toString(10);
    }
    var ce = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function ke() {
      var ue = /* @__PURE__ */ new Date(), O = [
        ie(ue.getHours()),
        ie(ue.getMinutes()),
        ie(ue.getSeconds())
      ].join(":");
      return [ue.getDate(), ce[ue.getMonth()], O].join(" ");
    }
    t.log = function() {
      console.log("%s - %s", ke(), t.format.apply(t, arguments));
    }, t.inherits = Fh(), t._extend = function(ue, O) {
      if (!O || !L(O)) return ue;
      for (var N = Object.keys(O), Z = N.length; Z--; )
        ue[N[Z]] = O[N[Z]];
      return ue;
    };
    function ye(ue, O) {
      return Object.prototype.hasOwnProperty.call(ue, O);
    }
    var Ce = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    t.promisify = function(ue) {
      if (typeof ue != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (Ce && ue[Ce]) {
        var O = ue[Ce];
        if (typeof O != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(O, Ce, {
          value: O,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), O;
      }
      function O() {
        for (var N, Z, re = new Promise(function(oe, fe) {
          N = oe, Z = fe;
        }), le = [], te = 0; te < arguments.length; te++)
          le.push(arguments[te]);
        le.push(function(oe, fe) {
          oe ? Z(oe) : N(fe);
        });
        try {
          ue.apply(this, le);
        } catch (oe) {
          Z(oe);
        }
        return re;
      }
      return Object.setPrototypeOf(O, Object.getPrototypeOf(ue)), Ce && Object.defineProperty(O, Ce, {
        value: O,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        O,
        e(ue)
      );
    }, t.promisify.custom = Ce;
    function Ie(ue, O) {
      if (!ue) {
        var N = new Error("Promise was rejected with a falsy value");
        N.reason = ue, ue = N;
      }
      return O(ue);
    }
    function Te(ue) {
      if (typeof ue != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function O() {
        for (var N = [], Z = 0; Z < arguments.length; Z++)
          N.push(arguments[Z]);
        var re = N.pop();
        if (typeof re != "function")
          throw new TypeError("The last argument must be of type Function");
        var le = this, te = function() {
          return re.apply(le, arguments);
        };
        ue.apply(this, N).then(
          function(oe) {
            Ut.nextTick(te.bind(null, null, oe));
          },
          function(oe) {
            Ut.nextTick(Ie.bind(null, oe, te));
          }
        );
      }
      return Object.setPrototypeOf(O, Object.getPrototypeOf(ue)), Object.defineProperties(
        O,
        e(ue)
      ), O;
    }
    t.callbackify = Te;
  }(D_)), D_;
}
var p3, lI;
function e2e() {
  if (lI) return p3;
  lI = 1;
  function t(m, w) {
    var f = Object.keys(m);
    if (Object.getOwnPropertySymbols) {
      var E = Object.getOwnPropertySymbols(m);
      w && (E = E.filter(function(A) {
        return Object.getOwnPropertyDescriptor(m, A).enumerable;
      })), f.push.apply(f, E);
    }
    return f;
  }
  function e(m) {
    for (var w = 1; w < arguments.length; w++) {
      var f = arguments[w] != null ? arguments[w] : {};
      w % 2 ? t(Object(f), !0).forEach(function(E) {
        r(m, E, f[E]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(f)) : t(Object(f)).forEach(function(E) {
        Object.defineProperty(m, E, Object.getOwnPropertyDescriptor(f, E));
      });
    }
    return m;
  }
  function r(m, w, f) {
    return w = o(w), w in m ? Object.defineProperty(m, w, { value: f, enumerable: !0, configurable: !0, writable: !0 }) : m[w] = f, m;
  }
  function n(m, w) {
    if (!(m instanceof w))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(m, w) {
    for (var f = 0; f < w.length; f++) {
      var E = w[f];
      E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(m, o(E.key), E);
    }
  }
  function s(m, w, f) {
    return w && i(m.prototype, w), Object.defineProperty(m, "prototype", { writable: !1 }), m;
  }
  function o(m) {
    var w = a(m, "string");
    return typeof w == "symbol" ? w : String(w);
  }
  function a(m, w) {
    if (typeof m != "object" || m === null) return m;
    var f = m[Symbol.toPrimitive];
    if (f !== void 0) {
      var E = f.call(m, w);
      if (typeof E != "object") return E;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(m);
  }
  var l = Lb(), c = l.Buffer, p = dj(), h = p.inspect, d = h && h.custom || "inspect";
  function b(m, w, f) {
    c.prototype.copy.call(m, w, f);
  }
  return p3 = /* @__PURE__ */ function() {
    function m() {
      n(this, m), this.head = null, this.tail = null, this.length = 0;
    }
    return s(m, [{
      key: "push",
      value: function(w) {
        var f = {
          data: w,
          next: null
        };
        this.length > 0 ? this.tail.next = f : this.head = f, this.tail = f, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(w) {
        var f = {
          data: w,
          next: this.head
        };
        this.length === 0 && (this.tail = f), this.head = f, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var w = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, w;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(w) {
        if (this.length === 0) return "";
        for (var f = this.head, E = "" + f.data; f = f.next; ) E += w + f.data;
        return E;
      }
    }, {
      key: "concat",
      value: function(w) {
        if (this.length === 0) return c.alloc(0);
        for (var f = c.allocUnsafe(w >>> 0), E = this.head, A = 0; E; )
          b(E.data, f, A), A += E.data.length, E = E.next;
        return f;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(w, f) {
        var E;
        return w < this.head.data.length ? (E = this.head.data.slice(0, w), this.head.data = this.head.data.slice(w)) : w === this.head.data.length ? E = this.shift() : E = f ? this._getString(w) : this._getBuffer(w), E;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(w) {
        var f = this.head, E = 1, A = f.data;
        for (w -= A.length; f = f.next; ) {
          var x = f.data, g = w > x.length ? x.length : w;
          if (g === x.length ? A += x : A += x.slice(0, w), w -= g, w === 0) {
            g === x.length ? (++E, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = x.slice(g));
            break;
          }
          ++E;
        }
        return this.length -= E, A;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(w) {
        var f = c.allocUnsafe(w), E = this.head, A = 1;
        for (E.data.copy(f), w -= E.data.length; E = E.next; ) {
          var x = E.data, g = w > x.length ? x.length : w;
          if (x.copy(f, f.length - w, 0, g), w -= g, w === 0) {
            g === x.length ? (++A, E.next ? this.head = E.next : this.head = this.tail = null) : (this.head = E, E.data = x.slice(g));
            break;
          }
          ++A;
        }
        return this.length -= A, f;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: d,
      value: function(w, f) {
        return h(this, e(e({}, f), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), m;
  }(), p3;
}
var d3, cI;
function fj() {
  if (cI) return d3;
  cI = 1;
  function t(o, a) {
    var l = this, c = this._readableState && this._readableState.destroyed, p = this._writableState && this._writableState.destroyed;
    return c || p ? (a ? a(o) : o && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ut.nextTick(i, this, o)) : Ut.nextTick(i, this, o)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(o || null, function(h) {
      !a && h ? l._writableState ? l._writableState.errorEmitted ? Ut.nextTick(r, l) : (l._writableState.errorEmitted = !0, Ut.nextTick(e, l, h)) : Ut.nextTick(e, l, h) : a ? (Ut.nextTick(r, l), a(h)) : Ut.nextTick(r, l);
    }), this);
  }
  function e(o, a) {
    i(o, a), r(o);
  }
  function r(o) {
    o._writableState && !o._writableState.emitClose || o._readableState && !o._readableState.emitClose || o.emit("close");
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function i(o, a) {
    o.emit("error", a);
  }
  function s(o, a) {
    var l = o._readableState, c = o._writableState;
    l && l.autoDestroy || c && c.autoDestroy ? o.destroy(a) : o.emit("error", a);
  }
  return d3 = {
    destroy: t,
    undestroy: n,
    errorOrDestroy: s
  }, d3;
}
var f3 = {}, uI;
function $d() {
  if (uI) return f3;
  uI = 1;
  function t(a, l) {
    a.prototype = Object.create(l.prototype), a.prototype.constructor = a, a.__proto__ = l;
  }
  var e = {};
  function r(a, l, c) {
    c || (c = Error);
    function p(d, b, m) {
      return typeof l == "string" ? l : l(d, b, m);
    }
    var h = /* @__PURE__ */ function(d) {
      t(b, d);
      function b(m, w, f) {
        return d.call(this, p(m, w, f)) || this;
      }
      return b;
    }(c);
    h.prototype.name = c.name, h.prototype.code = a, e[a] = h;
  }
  function n(a, l) {
    if (Array.isArray(a)) {
      var c = a.length;
      return a = a.map(function(p) {
        return String(p);
      }), c > 2 ? "one of ".concat(l, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(l, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(l, " ").concat(a[0]);
    } else
      return "of ".concat(l, " ").concat(String(a));
  }
  function i(a, l, c) {
    return a.substr(0, l.length) === l;
  }
  function s(a, l, c) {
    return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - l.length, c) === l;
  }
  function o(a, l, c) {
    return typeof c != "number" && (c = 0), c + l.length > a.length ? !1 : a.indexOf(l, c) !== -1;
  }
  return r("ERR_INVALID_OPT_VALUE", function(a, l) {
    return 'The value "' + l + '" is invalid for option "' + a + '"';
  }, TypeError), r("ERR_INVALID_ARG_TYPE", function(a, l, c) {
    var p;
    typeof l == "string" && i(l, "not ") ? (p = "must not be", l = l.replace(/^not /, "")) : p = "must be";
    var h;
    if (s(a, " argument"))
      h = "The ".concat(a, " ").concat(p, " ").concat(n(l, "type"));
    else {
      var d = o(a, ".") ? "property" : "argument";
      h = 'The "'.concat(a, '" ').concat(d, " ").concat(p, " ").concat(n(l, "type"));
    }
    return h += ". Received type ".concat(typeof c), h;
  }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
    return "The " + a + " method is not implemented";
  }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(a) {
    return "Cannot call " + a + " after a stream was destroyed";
  }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(a) {
    return "Unknown encoding: " + a;
  }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), f3.codes = e, f3;
}
var g3, hI;
function gj() {
  if (hI) return g3;
  hI = 1;
  var t = $d().codes.ERR_INVALID_OPT_VALUE;
  function e(n, i, s) {
    return n.highWaterMark != null ? n.highWaterMark : i ? n[s] : null;
  }
  function r(n, i, s, o) {
    var a = e(i, o, s);
    if (a != null) {
      if (!(isFinite(a) && Math.floor(a) === a) || a < 0) {
        var l = o ? s : "highWaterMark";
        throw new t(l, a);
      }
      return Math.floor(a);
    }
    return n.objectMode ? 16 : 16 * 1024;
  }
  return g3 = {
    getHighWaterMark: r
  }, g3;
}
var m3, pI;
function t2e() {
  if (pI) return m3;
  pI = 1, m3 = t;
  function t(r, n) {
    if (e("noDeprecation"))
      return r;
    var i = !1;
    function s() {
      if (!i) {
        if (e("throwDeprecation"))
          throw new Error(n);
        e("traceDeprecation") ? console.trace(n) : console.warn(n), i = !0;
      }
      return r.apply(this, arguments);
    }
    return s;
  }
  function e(r) {
    try {
      if (!Xl.localStorage) return !1;
    } catch {
      return !1;
    }
    var n = Xl.localStorage[r];
    return n == null ? !1 : String(n).toLowerCase() === "true";
  }
  return m3;
}
var y3, dI;
function mj() {
  if (dI) return y3;
  dI = 1, y3 = R;
  function t(re) {
    var le = this;
    this.next = null, this.entry = null, this.finish = function() {
      Z(le, re);
    };
  }
  var e;
  R.WritableState = k;
  var r = {
    deprecate: t2e()
  }, n = rj(), i = Lb().Buffer, s = (typeof Xl < "u" ? Xl : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(re) {
    return i.from(re);
  }
  function a(re) {
    return i.isBuffer(re) || re instanceof s;
  }
  var l = fj(), c = gj(), p = c.getHighWaterMark, h = $d().codes, d = h.ERR_INVALID_ARG_TYPE, b = h.ERR_METHOD_NOT_IMPLEMENTED, m = h.ERR_MULTIPLE_CALLBACK, w = h.ERR_STREAM_CANNOT_PIPE, f = h.ERR_STREAM_DESTROYED, E = h.ERR_STREAM_NULL_VALUES, A = h.ERR_STREAM_WRITE_AFTER_END, x = h.ERR_UNKNOWN_ENCODING, g = l.errorOrDestroy;
  Fh()(R, n);
  function v() {
  }
  function k(re, le, te) {
    e = e || Jp(), re = re || {}, typeof te != "boolean" && (te = le instanceof e), this.objectMode = !!re.objectMode, te && (this.objectMode = this.objectMode || !!re.writableObjectMode), this.highWaterMark = p(this, re, "writableHighWaterMark", te), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var oe = re.decodeStrings === !1;
    this.decodeStrings = !oe, this.defaultEncoding = re.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(fe) {
      ce(le, fe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = re.emitClose !== !1, this.autoDestroy = !!re.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  k.prototype.getBuffer = function() {
    for (var re = this.bufferedRequest, le = []; re; )
      le.push(re), re = re.next;
    return le;
  }, function() {
    try {
      Object.defineProperty(k.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var S;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (S = Function.prototype[Symbol.hasInstance], Object.defineProperty(R, Symbol.hasInstance, {
    value: function(re) {
      return S.call(this, re) ? !0 : this !== R ? !1 : re && re._writableState instanceof k;
    }
  })) : S = function(re) {
    return re instanceof this;
  };
  function R(re) {
    e = e || Jp();
    var le = this instanceof e;
    if (!le && !S.call(R, this)) return new R(re);
    this._writableState = new k(re, this, le), this.writable = !0, re && (typeof re.write == "function" && (this._write = re.write), typeof re.writev == "function" && (this._writev = re.writev), typeof re.destroy == "function" && (this._destroy = re.destroy), typeof re.final == "function" && (this._final = re.final)), n.call(this);
  }
  R.prototype.pipe = function() {
    g(this, new w());
  };
  function L(re, le) {
    var te = new A();
    g(re, te), Ut.nextTick(le, te);
  }
  function F(re, le, te, oe) {
    var fe;
    return te === null ? fe = new E() : typeof te != "string" && !le.objectMode && (fe = new d("chunk", ["string", "Buffer"], te)), fe ? (g(re, fe), Ut.nextTick(oe, fe), !1) : !0;
  }
  R.prototype.write = function(re, le, te) {
    var oe = this._writableState, fe = !1, H = !oe.objectMode && a(re);
    return H && !i.isBuffer(re) && (re = o(re)), typeof le == "function" && (te = le, le = null), H ? le = "buffer" : le || (le = oe.defaultEncoding), typeof te != "function" && (te = v), oe.ending ? L(this, te) : (H || F(this, oe, re, te)) && (oe.pendingcb++, fe = j(this, oe, H, re, le, te)), fe;
  }, R.prototype.cork = function() {
    this._writableState.corked++;
  }, R.prototype.uncork = function() {
    var re = this._writableState;
    re.corked && (re.corked--, !re.writing && !re.corked && !re.bufferProcessing && re.bufferedRequest && Ce(this, re));
  }, R.prototype.setDefaultEncoding = function(re) {
    if (typeof re == "string" && (re = re.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((re + "").toLowerCase()) > -1)) throw new x(re);
    return this._writableState.defaultEncoding = re, this;
  }, Object.defineProperty(R.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function z(re, le, te) {
    return !re.objectMode && re.decodeStrings !== !1 && typeof le == "string" && (le = i.from(le, te)), le;
  }
  Object.defineProperty(R.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function j(re, le, te, oe, fe, H) {
    if (!te) {
      var J = z(le, oe, fe);
      oe !== J && (te = !0, fe = "buffer", oe = J);
    }
    var Se = le.objectMode ? 1 : oe.length;
    le.length += Se;
    var Re = le.length < le.highWaterMark;
    if (Re || (le.needDrain = !0), le.writing || le.corked) {
      var Fe = le.lastBufferedRequest;
      le.lastBufferedRequest = {
        chunk: oe,
        encoding: fe,
        isBuf: te,
        callback: H,
        next: null
      }, Fe ? Fe.next = le.lastBufferedRequest : le.bufferedRequest = le.lastBufferedRequest, le.bufferedRequestCount += 1;
    } else
      ee(re, le, !1, Se, oe, fe, H);
    return Re;
  }
  function ee(re, le, te, oe, fe, H, J) {
    le.writelen = oe, le.writecb = J, le.writing = !0, le.sync = !0, le.destroyed ? le.onwrite(new f("write")) : te ? re._writev(fe, le.onwrite) : re._write(fe, H, le.onwrite), le.sync = !1;
  }
  function X(re, le, te, oe, fe) {
    --le.pendingcb, te ? (Ut.nextTick(fe, oe), Ut.nextTick(O, re, le), re._writableState.errorEmitted = !0, g(re, oe)) : (fe(oe), re._writableState.errorEmitted = !0, g(re, oe), O(re, le));
  }
  function ie(re) {
    re.writing = !1, re.writecb = null, re.length -= re.writelen, re.writelen = 0;
  }
  function ce(re, le) {
    var te = re._writableState, oe = te.sync, fe = te.writecb;
    if (typeof fe != "function") throw new m();
    if (ie(te), le) X(re, te, oe, le, fe);
    else {
      var H = Ie(te) || re.destroyed;
      !H && !te.corked && !te.bufferProcessing && te.bufferedRequest && Ce(re, te), oe ? Ut.nextTick(ke, re, te, H, fe) : ke(re, te, H, fe);
    }
  }
  function ke(re, le, te, oe) {
    te || ye(re, le), le.pendingcb--, oe(), O(re, le);
  }
  function ye(re, le) {
    le.length === 0 && le.needDrain && (le.needDrain = !1, re.emit("drain"));
  }
  function Ce(re, le) {
    le.bufferProcessing = !0;
    var te = le.bufferedRequest;
    if (re._writev && te && te.next) {
      var oe = le.bufferedRequestCount, fe = new Array(oe), H = le.corkedRequestsFree;
      H.entry = te;
      for (var J = 0, Se = !0; te; )
        fe[J] = te, te.isBuf || (Se = !1), te = te.next, J += 1;
      fe.allBuffers = Se, ee(re, le, !0, le.length, fe, "", H.finish), le.pendingcb++, le.lastBufferedRequest = null, H.next ? (le.corkedRequestsFree = H.next, H.next = null) : le.corkedRequestsFree = new t(le), le.bufferedRequestCount = 0;
    } else {
      for (; te; ) {
        var Re = te.chunk, Fe = te.encoding, Le = te.callback, ze = le.objectMode ? 1 : Re.length;
        if (ee(re, le, !1, ze, Re, Fe, Le), te = te.next, le.bufferedRequestCount--, le.writing)
          break;
      }
      te === null && (le.lastBufferedRequest = null);
    }
    le.bufferedRequest = te, le.bufferProcessing = !1;
  }
  R.prototype._write = function(re, le, te) {
    te(new b("_write()"));
  }, R.prototype._writev = null, R.prototype.end = function(re, le, te) {
    var oe = this._writableState;
    return typeof re == "function" ? (te = re, re = null, le = null) : typeof le == "function" && (te = le, le = null), re != null && this.write(re, le), oe.corked && (oe.corked = 1, this.uncork()), oe.ending || N(this, oe, te), this;
  }, Object.defineProperty(R.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Ie(re) {
    return re.ending && re.length === 0 && re.bufferedRequest === null && !re.finished && !re.writing;
  }
  function Te(re, le) {
    re._final(function(te) {
      le.pendingcb--, te && g(re, te), le.prefinished = !0, re.emit("prefinish"), O(re, le);
    });
  }
  function ue(re, le) {
    !le.prefinished && !le.finalCalled && (typeof re._final == "function" && !le.destroyed ? (le.pendingcb++, le.finalCalled = !0, Ut.nextTick(Te, re, le)) : (le.prefinished = !0, re.emit("prefinish")));
  }
  function O(re, le) {
    var te = Ie(le);
    if (te && (ue(re, le), le.pendingcb === 0 && (le.finished = !0, re.emit("finish"), le.autoDestroy))) {
      var oe = re._readableState;
      (!oe || oe.autoDestroy && oe.endEmitted) && re.destroy();
    }
    return te;
  }
  function N(re, le, te) {
    le.ending = !0, O(re, le), te && (le.finished ? Ut.nextTick(te) : re.once("finish", te)), le.ended = !0, re.writable = !1;
  }
  function Z(re, le, te) {
    var oe = re.entry;
    for (re.entry = null; oe; ) {
      var fe = oe.callback;
      le.pendingcb--, fe(te), oe = oe.next;
    }
    le.corkedRequestsFree.next = re;
  }
  return Object.defineProperty(R.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(re) {
      this._writableState && (this._writableState.destroyed = re);
    }
  }), R.prototype.destroy = l.destroy, R.prototype._undestroy = l.undestroy, R.prototype._destroy = function(re, le) {
    le(re);
  }, y3;
}
var b3, fI;
function Jp() {
  if (fI) return b3;
  fI = 1;
  var t = Object.keys || function(c) {
    var p = [];
    for (var h in c) p.push(h);
    return p;
  };
  b3 = o;
  var e = yj(), r = mj();
  Fh()(o, e);
  for (var n = t(r.prototype), i = 0; i < n.length; i++) {
    var s = n[i];
    o.prototype[s] || (o.prototype[s] = r.prototype[s]);
  }
  function o(c) {
    if (!(this instanceof o)) return new o(c);
    e.call(this, c), r.call(this, c), this.allowHalfOpen = !0, c && (c.readable === !1 && (this.readable = !1), c.writable === !1 && (this.writable = !1), c.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a)));
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(o.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(o.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function a() {
    this._writableState.ended || Ut.nextTick(l, this);
  }
  function l(c) {
    c.end();
  }
  return Object.defineProperty(o.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(c) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = c, this._writableState.destroyed = c);
    }
  }), b3;
}
var v3 = {}, w3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var gI;
function r2e() {
  return gI || (gI = 1, function(t, e) {
    var r = Lb(), n = r.Buffer;
    function i(o, a) {
      for (var l in o)
        a[l] = o[l];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (i(r, e), e.Buffer = s);
    function s(o, a, l) {
      return n(o, a, l);
    }
    s.prototype = Object.create(n.prototype), i(n, s), s.from = function(o, a, l) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return n(o, a, l);
    }, s.alloc = function(o, a, l) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var c = n(o);
      return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0), c;
    }, s.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return n(o);
    }, s.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(o);
    };
  }(w3, w3.exports)), w3.exports;
}
var mI;
function yI() {
  if (mI) return v3;
  mI = 1;
  var t = r2e().Buffer, e = t.isEncoding || function(E) {
    switch (E = "" + E, E && E.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(E) {
    if (!E) return "utf8";
    for (var A; ; )
      switch (E) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return E;
        default:
          if (A) return;
          E = ("" + E).toLowerCase(), A = !0;
      }
  }
  function n(E) {
    var A = r(E);
    if (typeof A != "string" && (t.isEncoding === e || !e(E))) throw new Error("Unknown encoding: " + E);
    return A || E;
  }
  v3.StringDecoder = i;
  function i(E) {
    this.encoding = n(E);
    var A;
    switch (this.encoding) {
      case "utf16le":
        this.text = h, this.end = d, A = 4;
        break;
      case "utf8":
        this.fillLast = l, A = 4;
        break;
      case "base64":
        this.text = b, this.end = m, A = 3;
        break;
      default:
        this.write = w, this.end = f;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(A);
  }
  i.prototype.write = function(E) {
    if (E.length === 0) return "";
    var A, x;
    if (this.lastNeed) {
      if (A = this.fillLast(E), A === void 0) return "";
      x = this.lastNeed, this.lastNeed = 0;
    } else
      x = 0;
    return x < E.length ? A ? A + this.text(E, x) : this.text(E, x) : A || "";
  }, i.prototype.end = p, i.prototype.text = c, i.prototype.fillLast = function(E) {
    if (this.lastNeed <= E.length)
      return E.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    E.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, E.length), this.lastNeed -= E.length;
  };
  function s(E) {
    return E <= 127 ? 0 : E >> 5 === 6 ? 2 : E >> 4 === 14 ? 3 : E >> 3 === 30 ? 4 : E >> 6 === 2 ? -1 : -2;
  }
  function o(E, A, x) {
    var g = A.length - 1;
    if (g < x) return 0;
    var v = s(A[g]);
    return v >= 0 ? (v > 0 && (E.lastNeed = v - 1), v) : --g < x || v === -2 ? 0 : (v = s(A[g]), v >= 0 ? (v > 0 && (E.lastNeed = v - 2), v) : --g < x || v === -2 ? 0 : (v = s(A[g]), v >= 0 ? (v > 0 && (v === 2 ? v = 0 : E.lastNeed = v - 3), v) : 0));
  }
  function a(E, A, x) {
    if ((A[0] & 192) !== 128)
      return E.lastNeed = 0, "";
    if (E.lastNeed > 1 && A.length > 1) {
      if ((A[1] & 192) !== 128)
        return E.lastNeed = 1, "";
      if (E.lastNeed > 2 && A.length > 2 && (A[2] & 192) !== 128)
        return E.lastNeed = 2, "";
    }
  }
  function l(E) {
    var A = this.lastTotal - this.lastNeed, x = a(this, E);
    if (x !== void 0) return x;
    if (this.lastNeed <= E.length)
      return E.copy(this.lastChar, A, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    E.copy(this.lastChar, A, 0, E.length), this.lastNeed -= E.length;
  }
  function c(E, A) {
    var x = o(this, E, A);
    if (!this.lastNeed) return E.toString("utf8", A);
    this.lastTotal = x;
    var g = E.length - (x - this.lastNeed);
    return E.copy(this.lastChar, 0, g), E.toString("utf8", A, g);
  }
  function p(E) {
    var A = E && E.length ? this.write(E) : "";
    return this.lastNeed ? A + "" : A;
  }
  function h(E, A) {
    if ((E.length - A) % 2 === 0) {
      var x = E.toString("utf16le", A);
      if (x) {
        var g = x.charCodeAt(x.length - 1);
        if (g >= 55296 && g <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = E[E.length - 2], this.lastChar[1] = E[E.length - 1], x.slice(0, -1);
      }
      return x;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = E[E.length - 1], E.toString("utf16le", A, E.length - 1);
  }
  function d(E) {
    var A = E && E.length ? this.write(E) : "";
    if (this.lastNeed) {
      var x = this.lastTotal - this.lastNeed;
      return A + this.lastChar.toString("utf16le", 0, x);
    }
    return A;
  }
  function b(E, A) {
    var x = (E.length - A) % 3;
    return x === 0 ? E.toString("base64", A) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = E[E.length - 1] : (this.lastChar[0] = E[E.length - 2], this.lastChar[1] = E[E.length - 1]), E.toString("base64", A, E.length - x));
  }
  function m(E) {
    var A = E && E.length ? this.write(E) : "";
    return this.lastNeed ? A + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : A;
  }
  function w(E) {
    return E.toString(this.encoding);
  }
  function f(E) {
    return E && E.length ? this.write(E) : "";
  }
  return v3;
}
var x3, bI;
function vS() {
  if (bI) return x3;
  bI = 1;
  var t = $d().codes.ERR_STREAM_PREMATURE_CLOSE;
  function e(s) {
    var o = !1;
    return function() {
      if (!o) {
        o = !0;
        for (var a = arguments.length, l = new Array(a), c = 0; c < a; c++)
          l[c] = arguments[c];
        s.apply(this, l);
      }
    };
  }
  function r() {
  }
  function n(s) {
    return s.setHeader && typeof s.abort == "function";
  }
  function i(s, o, a) {
    if (typeof o == "function") return i(s, null, o);
    o || (o = {}), a = e(a || r);
    var l = o.readable || o.readable !== !1 && s.readable, c = o.writable || o.writable !== !1 && s.writable, p = function() {
      s.writable || d();
    }, h = s._writableState && s._writableState.finished, d = function() {
      c = !1, h = !0, l || a.call(s);
    }, b = s._readableState && s._readableState.endEmitted, m = function() {
      l = !1, b = !0, c || a.call(s);
    }, w = function(A) {
      a.call(s, A);
    }, f = function() {
      var A;
      if (l && !b)
        return (!s._readableState || !s._readableState.ended) && (A = new t()), a.call(s, A);
      if (c && !h)
        return (!s._writableState || !s._writableState.ended) && (A = new t()), a.call(s, A);
    }, E = function() {
      s.req.on("finish", d);
    };
    return n(s) ? (s.on("complete", d), s.on("abort", f), s.req ? E() : s.on("request", E)) : c && !s._writableState && (s.on("end", p), s.on("close", p)), s.on("end", m), s.on("finish", d), o.error !== !1 && s.on("error", w), s.on("close", f), function() {
      s.removeListener("complete", d), s.removeListener("abort", f), s.removeListener("request", E), s.req && s.req.removeListener("finish", d), s.removeListener("end", p), s.removeListener("close", p), s.removeListener("finish", d), s.removeListener("end", m), s.removeListener("error", w), s.removeListener("close", f);
    };
  }
  return x3 = i, x3;
}
var E3, vI;
function n2e() {
  if (vI) return E3;
  vI = 1;
  var t;
  function e(x, g, v) {
    return g = r(g), g in x ? Object.defineProperty(x, g, { value: v, enumerable: !0, configurable: !0, writable: !0 }) : x[g] = v, x;
  }
  function r(x) {
    var g = n(x, "string");
    return typeof g == "symbol" ? g : String(g);
  }
  function n(x, g) {
    if (typeof x != "object" || x === null) return x;
    var v = x[Symbol.toPrimitive];
    if (v !== void 0) {
      var k = v.call(x, g);
      if (typeof k != "object") return k;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (g === "string" ? String : Number)(x);
  }
  var i = vS(), s = Symbol("lastResolve"), o = Symbol("lastReject"), a = Symbol("error"), l = Symbol("ended"), c = Symbol("lastPromise"), p = Symbol("handlePromise"), h = Symbol("stream");
  function d(x, g) {
    return {
      value: x,
      done: g
    };
  }
  function b(x) {
    var g = x[s];
    if (g !== null) {
      var v = x[h].read();
      v !== null && (x[c] = null, x[s] = null, x[o] = null, g(d(v, !1)));
    }
  }
  function m(x) {
    Ut.nextTick(b, x);
  }
  function w(x, g) {
    return function(v, k) {
      x.then(function() {
        if (g[l]) {
          v(d(void 0, !0));
          return;
        }
        g[p](v, k);
      }, k);
    };
  }
  var f = Object.getPrototypeOf(function() {
  }), E = Object.setPrototypeOf((t = {
    get stream() {
      return this[h];
    },
    next: function() {
      var x = this, g = this[a];
      if (g !== null)
        return Promise.reject(g);
      if (this[l])
        return Promise.resolve(d(void 0, !0));
      if (this[h].destroyed)
        return new Promise(function(R, L) {
          Ut.nextTick(function() {
            x[a] ? L(x[a]) : R(d(void 0, !0));
          });
        });
      var v = this[c], k;
      if (v)
        k = new Promise(w(v, this));
      else {
        var S = this[h].read();
        if (S !== null)
          return Promise.resolve(d(S, !1));
        k = new Promise(this[p]);
      }
      return this[c] = k, k;
    }
  }, e(t, Symbol.asyncIterator, function() {
    return this;
  }), e(t, "return", function() {
    var x = this;
    return new Promise(function(g, v) {
      x[h].destroy(null, function(k) {
        if (k) {
          v(k);
          return;
        }
        g(d(void 0, !0));
      });
    });
  }), t), f), A = function(x) {
    var g, v = Object.create(E, (g = {}, e(g, h, {
      value: x,
      writable: !0
    }), e(g, s, {
      value: null,
      writable: !0
    }), e(g, o, {
      value: null,
      writable: !0
    }), e(g, a, {
      value: null,
      writable: !0
    }), e(g, l, {
      value: x._readableState.endEmitted,
      writable: !0
    }), e(g, p, {
      value: function(k, S) {
        var R = v[h].read();
        R ? (v[c] = null, v[s] = null, v[o] = null, k(d(R, !1))) : (v[s] = k, v[o] = S);
      },
      writable: !0
    }), g));
    return v[c] = null, i(x, function(k) {
      if (k && k.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var S = v[o];
        S !== null && (v[c] = null, v[s] = null, v[o] = null, S(k)), v[a] = k;
        return;
      }
      var R = v[s];
      R !== null && (v[c] = null, v[s] = null, v[o] = null, R(d(void 0, !0))), v[l] = !0;
    }), x.on("readable", m.bind(null, v)), v;
  };
  return E3 = A, E3;
}
var wI, xI;
function i2e() {
  return xI || (xI = 1, wI = function() {
    throw new Error("Readable.from is not available in the browser");
  }), wI;
}
var S3, EI;
function yj() {
  if (EI) return S3;
  EI = 1, S3 = L;
  var t;
  L.ReadableState = R, gS().EventEmitter;
  var e = function(H, J) {
    return H.listeners(J).length;
  }, r = rj(), n = Lb().Buffer, i = (typeof Xl < "u" ? Xl : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(H) {
    return n.from(H);
  }
  function o(H) {
    return n.isBuffer(H) || H instanceof i;
  }
  var a = dj(), l;
  a && a.debuglog ? l = a.debuglog("stream") : l = function() {
  };
  var c = e2e(), p = fj(), h = gj(), d = h.getHighWaterMark, b = $d().codes, m = b.ERR_INVALID_ARG_TYPE, w = b.ERR_STREAM_PUSH_AFTER_EOF, f = b.ERR_METHOD_NOT_IMPLEMENTED, E = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, A, x, g;
  Fh()(L, r);
  var v = p.errorOrDestroy, k = ["error", "close", "destroy", "pause", "resume"];
  function S(H, J, Se) {
    if (typeof H.prependListener == "function") return H.prependListener(J, Se);
    !H._events || !H._events[J] ? H.on(J, Se) : Array.isArray(H._events[J]) ? H._events[J].unshift(Se) : H._events[J] = [Se, H._events[J]];
  }
  function R(H, J, Se) {
    t = t || Jp(), H = H || {}, typeof Se != "boolean" && (Se = J instanceof t), this.objectMode = !!H.objectMode, Se && (this.objectMode = this.objectMode || !!H.readableObjectMode), this.highWaterMark = d(this, H, "readableHighWaterMark", Se), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = H.emitClose !== !1, this.autoDestroy = !!H.autoDestroy, this.destroyed = !1, this.defaultEncoding = H.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, H.encoding && (A || (A = yI().StringDecoder), this.decoder = new A(H.encoding), this.encoding = H.encoding);
  }
  function L(H) {
    if (t = t || Jp(), !(this instanceof L)) return new L(H);
    var J = this instanceof t;
    this._readableState = new R(H, this, J), this.readable = !0, H && (typeof H.read == "function" && (this._read = H.read), typeof H.destroy == "function" && (this._destroy = H.destroy)), r.call(this);
  }
  Object.defineProperty(L.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(H) {
      this._readableState && (this._readableState.destroyed = H);
    }
  }), L.prototype.destroy = p.destroy, L.prototype._undestroy = p.undestroy, L.prototype._destroy = function(H, J) {
    J(H);
  }, L.prototype.push = function(H, J) {
    var Se = this._readableState, Re;
    return Se.objectMode ? Re = !0 : typeof H == "string" && (J = J || Se.defaultEncoding, J !== Se.encoding && (H = n.from(H, J), J = ""), Re = !0), F(this, H, J, !1, Re);
  }, L.prototype.unshift = function(H) {
    return F(this, H, null, !0, !1);
  };
  function F(H, J, Se, Re, Fe) {
    l("readableAddChunk", J);
    var Le = H._readableState;
    if (J === null)
      Le.reading = !1, ce(H, Le);
    else {
      var ze;
      if (Fe || (ze = j(Le, J)), ze)
        v(H, ze);
      else if (Le.objectMode || J && J.length > 0)
        if (typeof J != "string" && !Le.objectMode && Object.getPrototypeOf(J) !== n.prototype && (J = s(J)), Re)
          Le.endEmitted ? v(H, new E()) : z(H, Le, J, !0);
        else if (Le.ended)
          v(H, new w());
        else {
          if (Le.destroyed)
            return !1;
          Le.reading = !1, Le.decoder && !Se ? (J = Le.decoder.write(J), Le.objectMode || J.length !== 0 ? z(H, Le, J, !1) : Ce(H, Le)) : z(H, Le, J, !1);
        }
      else Re || (Le.reading = !1, Ce(H, Le));
    }
    return !Le.ended && (Le.length < Le.highWaterMark || Le.length === 0);
  }
  function z(H, J, Se, Re) {
    J.flowing && J.length === 0 && !J.sync ? (J.awaitDrain = 0, H.emit("data", Se)) : (J.length += J.objectMode ? 1 : Se.length, Re ? J.buffer.unshift(Se) : J.buffer.push(Se), J.needReadable && ke(H)), Ce(H, J);
  }
  function j(H, J) {
    var Se;
    return !o(J) && typeof J != "string" && J !== void 0 && !H.objectMode && (Se = new m("chunk", ["string", "Buffer", "Uint8Array"], J)), Se;
  }
  L.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, L.prototype.setEncoding = function(H) {
    A || (A = yI().StringDecoder);
    var J = new A(H);
    this._readableState.decoder = J, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Se = this._readableState.buffer.head, Re = ""; Se !== null; )
      Re += J.write(Se.data), Se = Se.next;
    return this._readableState.buffer.clear(), Re !== "" && this._readableState.buffer.push(Re), this._readableState.length = Re.length, this;
  };
  var ee = 1073741824;
  function X(H) {
    return H >= ee ? H = ee : (H--, H |= H >>> 1, H |= H >>> 2, H |= H >>> 4, H |= H >>> 8, H |= H >>> 16, H++), H;
  }
  function ie(H, J) {
    return H <= 0 || J.length === 0 && J.ended ? 0 : J.objectMode ? 1 : H !== H ? J.flowing && J.length ? J.buffer.head.data.length : J.length : (H > J.highWaterMark && (J.highWaterMark = X(H)), H <= J.length ? H : J.ended ? J.length : (J.needReadable = !0, 0));
  }
  L.prototype.read = function(H) {
    l("read", H), H = parseInt(H, 10);
    var J = this._readableState, Se = H;
    if (H !== 0 && (J.emittedReadable = !1), H === 0 && J.needReadable && ((J.highWaterMark !== 0 ? J.length >= J.highWaterMark : J.length > 0) || J.ended))
      return l("read: emitReadable", J.length, J.ended), J.length === 0 && J.ended ? te(this) : ke(this), null;
    if (H = ie(H, J), H === 0 && J.ended)
      return J.length === 0 && te(this), null;
    var Re = J.needReadable;
    l("need readable", Re), (J.length === 0 || J.length - H < J.highWaterMark) && (Re = !0, l("length less than watermark", Re)), J.ended || J.reading ? (Re = !1, l("reading or ended", Re)) : Re && (l("do read"), J.reading = !0, J.sync = !0, J.length === 0 && (J.needReadable = !0), this._read(J.highWaterMark), J.sync = !1, J.reading || (H = ie(Se, J)));
    var Fe;
    return H > 0 ? Fe = le(H, J) : Fe = null, Fe === null ? (J.needReadable = J.length <= J.highWaterMark, H = 0) : (J.length -= H, J.awaitDrain = 0), J.length === 0 && (J.ended || (J.needReadable = !0), Se !== H && J.ended && te(this)), Fe !== null && this.emit("data", Fe), Fe;
  };
  function ce(H, J) {
    if (l("onEofChunk"), !J.ended) {
      if (J.decoder) {
        var Se = J.decoder.end();
        Se && Se.length && (J.buffer.push(Se), J.length += J.objectMode ? 1 : Se.length);
      }
      J.ended = !0, J.sync ? ke(H) : (J.needReadable = !1, J.emittedReadable || (J.emittedReadable = !0, ye(H)));
    }
  }
  function ke(H) {
    var J = H._readableState;
    l("emitReadable", J.needReadable, J.emittedReadable), J.needReadable = !1, J.emittedReadable || (l("emitReadable", J.flowing), J.emittedReadable = !0, Ut.nextTick(ye, H));
  }
  function ye(H) {
    var J = H._readableState;
    l("emitReadable_", J.destroyed, J.length, J.ended), !J.destroyed && (J.length || J.ended) && (H.emit("readable"), J.emittedReadable = !1), J.needReadable = !J.flowing && !J.ended && J.length <= J.highWaterMark, re(H);
  }
  function Ce(H, J) {
    J.readingMore || (J.readingMore = !0, Ut.nextTick(Ie, H, J));
  }
  function Ie(H, J) {
    for (; !J.reading && !J.ended && (J.length < J.highWaterMark || J.flowing && J.length === 0); ) {
      var Se = J.length;
      if (l("maybeReadMore read 0"), H.read(0), Se === J.length)
        break;
    }
    J.readingMore = !1;
  }
  L.prototype._read = function(H) {
    v(this, new f("_read()"));
  }, L.prototype.pipe = function(H, J) {
    var Se = this, Re = this._readableState;
    switch (Re.pipesCount) {
      case 0:
        Re.pipes = H;
        break;
      case 1:
        Re.pipes = [Re.pipes, H];
        break;
      default:
        Re.pipes.push(H);
        break;
    }
    Re.pipesCount += 1, l("pipe count=%d opts=%j", Re.pipesCount, J);
    var Fe = (!J || J.end !== !1) && H !== Ut.stdout && H !== Ut.stderr, Le = Fe ? tt : Ze;
    Re.endEmitted ? Ut.nextTick(Le) : Se.once("end", Le), H.on("unpipe", ze);
    function ze(ge, be) {
      l("onunpipe"), ge === Se && be && be.hasUnpiped === !1 && (be.hasUnpiped = !0, er());
    }
    function tt() {
      l("onend"), H.end();
    }
    var Pe = Te(Se);
    H.on("drain", Pe);
    var At = !1;
    function er() {
      l("cleanup"), H.removeListener("close", it), H.removeListener("finish", kt), H.removeListener("drain", Pe), H.removeListener("error", ht), H.removeListener("unpipe", ze), Se.removeListener("end", tt), Se.removeListener("end", Ze), Se.removeListener("data", me), At = !0, Re.awaitDrain && (!H._writableState || H._writableState.needDrain) && Pe();
    }
    Se.on("data", me);
    function me(ge) {
      l("ondata");
      var be = H.write(ge);
      l("dest.write", be), be === !1 && ((Re.pipesCount === 1 && Re.pipes === H || Re.pipesCount > 1 && fe(Re.pipes, H) !== -1) && !At && (l("false write response, pause", Re.awaitDrain), Re.awaitDrain++), Se.pause());
    }
    function ht(ge) {
      l("onerror", ge), Ze(), H.removeListener("error", ht), e(H, "error") === 0 && v(H, ge);
    }
    S(H, "error", ht);
    function it() {
      H.removeListener("finish", kt), Ze();
    }
    H.once("close", it);
    function kt() {
      l("onfinish"), H.removeListener("close", it), Ze();
    }
    H.once("finish", kt);
    function Ze() {
      l("unpipe"), Se.unpipe(H);
    }
    return H.emit("pipe", Se), Re.flowing || (l("pipe resume"), Se.resume()), H;
  };
  function Te(H) {
    return function() {
      var J = H._readableState;
      l("pipeOnDrain", J.awaitDrain), J.awaitDrain && J.awaitDrain--, J.awaitDrain === 0 && e(H, "data") && (J.flowing = !0, re(H));
    };
  }
  L.prototype.unpipe = function(H) {
    var J = this._readableState, Se = {
      hasUnpiped: !1
    };
    if (J.pipesCount === 0) return this;
    if (J.pipesCount === 1)
      return H && H !== J.pipes ? this : (H || (H = J.pipes), J.pipes = null, J.pipesCount = 0, J.flowing = !1, H && H.emit("unpipe", this, Se), this);
    if (!H) {
      var Re = J.pipes, Fe = J.pipesCount;
      J.pipes = null, J.pipesCount = 0, J.flowing = !1;
      for (var Le = 0; Le < Fe; Le++) Re[Le].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ze = fe(J.pipes, H);
    return ze === -1 ? this : (J.pipes.splice(ze, 1), J.pipesCount -= 1, J.pipesCount === 1 && (J.pipes = J.pipes[0]), H.emit("unpipe", this, Se), this);
  }, L.prototype.on = function(H, J) {
    var Se = r.prototype.on.call(this, H, J), Re = this._readableState;
    return H === "data" ? (Re.readableListening = this.listenerCount("readable") > 0, Re.flowing !== !1 && this.resume()) : H === "readable" && !Re.endEmitted && !Re.readableListening && (Re.readableListening = Re.needReadable = !0, Re.flowing = !1, Re.emittedReadable = !1, l("on readable", Re.length, Re.reading), Re.length ? ke(this) : Re.reading || Ut.nextTick(O, this)), Se;
  }, L.prototype.addListener = L.prototype.on, L.prototype.removeListener = function(H, J) {
    var Se = r.prototype.removeListener.call(this, H, J);
    return H === "readable" && Ut.nextTick(ue, this), Se;
  }, L.prototype.removeAllListeners = function(H) {
    var J = r.prototype.removeAllListeners.apply(this, arguments);
    return (H === "readable" || H === void 0) && Ut.nextTick(ue, this), J;
  };
  function ue(H) {
    var J = H._readableState;
    J.readableListening = H.listenerCount("readable") > 0, J.resumeScheduled && !J.paused ? J.flowing = !0 : H.listenerCount("data") > 0 && H.resume();
  }
  function O(H) {
    l("readable nexttick read 0"), H.read(0);
  }
  L.prototype.resume = function() {
    var H = this._readableState;
    return H.flowing || (l("resume"), H.flowing = !H.readableListening, N(this, H)), H.paused = !1, this;
  };
  function N(H, J) {
    J.resumeScheduled || (J.resumeScheduled = !0, Ut.nextTick(Z, H, J));
  }
  function Z(H, J) {
    l("resume", J.reading), J.reading || H.read(0), J.resumeScheduled = !1, H.emit("resume"), re(H), J.flowing && !J.reading && H.read(0);
  }
  L.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function re(H) {
    var J = H._readableState;
    for (l("flow", J.flowing); J.flowing && H.read() !== null; ) ;
  }
  L.prototype.wrap = function(H) {
    var J = this, Se = this._readableState, Re = !1;
    H.on("end", function() {
      if (l("wrapped end"), Se.decoder && !Se.ended) {
        var ze = Se.decoder.end();
        ze && ze.length && J.push(ze);
      }
      J.push(null);
    }), H.on("data", function(ze) {
      if (l("wrapped data"), Se.decoder && (ze = Se.decoder.write(ze)), !(Se.objectMode && ze == null) && !(!Se.objectMode && (!ze || !ze.length))) {
        var tt = J.push(ze);
        tt || (Re = !0, H.pause());
      }
    });
    for (var Fe in H)
      this[Fe] === void 0 && typeof H[Fe] == "function" && (this[Fe] = /* @__PURE__ */ function(ze) {
        return function() {
          return H[ze].apply(H, arguments);
        };
      }(Fe));
    for (var Le = 0; Le < k.length; Le++)
      H.on(k[Le], this.emit.bind(this, k[Le]));
    return this._read = function(ze) {
      l("wrapped _read", ze), Re && (Re = !1, H.resume());
    }, this;
  }, typeof Symbol == "function" && (L.prototype[Symbol.asyncIterator] = function() {
    return x === void 0 && (x = n2e()), x(this);
  }), Object.defineProperty(L.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(L.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(L.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(H) {
      this._readableState && (this._readableState.flowing = H);
    }
  }), L._fromList = le, Object.defineProperty(L.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function le(H, J) {
    if (J.length === 0) return null;
    var Se;
    return J.objectMode ? Se = J.buffer.shift() : !H || H >= J.length ? (J.decoder ? Se = J.buffer.join("") : J.buffer.length === 1 ? Se = J.buffer.first() : Se = J.buffer.concat(J.length), J.buffer.clear()) : Se = J.buffer.consume(H, J.decoder), Se;
  }
  function te(H) {
    var J = H._readableState;
    l("endReadable", J.endEmitted), J.endEmitted || (J.ended = !0, Ut.nextTick(oe, J, H));
  }
  function oe(H, J) {
    if (l("endReadableNT", H.endEmitted, H.length), !H.endEmitted && H.length === 0 && (H.endEmitted = !0, J.readable = !1, J.emit("end"), H.autoDestroy)) {
      var Se = J._writableState;
      (!Se || Se.autoDestroy && Se.finished) && J.destroy();
    }
  }
  typeof Symbol == "function" && (L.from = function(H, J) {
    return g === void 0 && (g = i2e()), g(L, H, J);
  });
  function fe(H, J) {
    for (var Se = 0, Re = H.length; Se < Re; Se++)
      if (H[Se] === J) return Se;
    return -1;
  }
  return S3;
}
var A3, SI;
function bj() {
  if (SI) return A3;
  SI = 1, A3 = a;
  var t = $d().codes, e = t.ERR_METHOD_NOT_IMPLEMENTED, r = t.ERR_MULTIPLE_CALLBACK, n = t.ERR_TRANSFORM_ALREADY_TRANSFORMING, i = t.ERR_TRANSFORM_WITH_LENGTH_0, s = Jp();
  Fh()(a, s);
  function o(p, h) {
    var d = this._transformState;
    d.transforming = !1;
    var b = d.writecb;
    if (b === null)
      return this.emit("error", new r());
    d.writechunk = null, d.writecb = null, h != null && this.push(h), b(p);
    var m = this._readableState;
    m.reading = !1, (m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark);
  }
  function a(p) {
    if (!(this instanceof a)) return new a(p);
    s.call(this, p), this._transformState = {
      afterTransform: o.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, p && (typeof p.transform == "function" && (this._transform = p.transform), typeof p.flush == "function" && (this._flush = p.flush)), this.on("prefinish", l);
  }
  function l() {
    var p = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(h, d) {
      c(p, h, d);
    }) : c(this, null, null);
  }
  a.prototype.push = function(p, h) {
    return this._transformState.needTransform = !1, s.prototype.push.call(this, p, h);
  }, a.prototype._transform = function(p, h, d) {
    d(new e("_transform()"));
  }, a.prototype._write = function(p, h, d) {
    var b = this._transformState;
    if (b.writecb = d, b.writechunk = p, b.writeencoding = h, !b.transforming) {
      var m = this._readableState;
      (b.needTransform || m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark);
    }
  }, a.prototype._read = function(p) {
    var h = this._transformState;
    h.writechunk !== null && !h.transforming ? (h.transforming = !0, this._transform(h.writechunk, h.writeencoding, h.afterTransform)) : h.needTransform = !0;
  }, a.prototype._destroy = function(p, h) {
    s.prototype._destroy.call(this, p, function(d) {
      h(d);
    });
  };
  function c(p, h, d) {
    if (h) return p.emit("error", h);
    if (d != null && p.push(d), p._writableState.length) throw new i();
    if (p._transformState.transforming) throw new n();
    return p.push(null);
  }
  return A3;
}
var k3, AI;
function s2e() {
  if (AI) return k3;
  AI = 1, k3 = e;
  var t = bj();
  Fh()(e, t);
  function e(r) {
    if (!(this instanceof e)) return new e(r);
    t.call(this, r);
  }
  return e.prototype._transform = function(r, n, i) {
    i(null, r);
  }, k3;
}
var _3, kI;
function o2e() {
  if (kI) return _3;
  kI = 1;
  var t;
  function e(d) {
    var b = !1;
    return function() {
      b || (b = !0, d.apply(void 0, arguments));
    };
  }
  var r = $d().codes, n = r.ERR_MISSING_ARGS, i = r.ERR_STREAM_DESTROYED;
  function s(d) {
    if (d) throw d;
  }
  function o(d) {
    return d.setHeader && typeof d.abort == "function";
  }
  function a(d, b, m, w) {
    w = e(w);
    var f = !1;
    d.on("close", function() {
      f = !0;
    }), t === void 0 && (t = vS()), t(d, {
      readable: b,
      writable: m
    }, function(A) {
      if (A) return w(A);
      f = !0, w();
    });
    var E = !1;
    return function(A) {
      if (!f && !E) {
        if (E = !0, o(d)) return d.abort();
        if (typeof d.destroy == "function") return d.destroy();
        w(A || new i("pipe"));
      }
    };
  }
  function l(d) {
    d();
  }
  function c(d, b) {
    return d.pipe(b);
  }
  function p(d) {
    return !d.length || typeof d[d.length - 1] != "function" ? s : d.pop();
  }
  function h() {
    for (var d = arguments.length, b = new Array(d), m = 0; m < d; m++)
      b[m] = arguments[m];
    var w = p(b);
    if (Array.isArray(b[0]) && (b = b[0]), b.length < 2)
      throw new n("streams");
    var f, E = b.map(function(A, x) {
      var g = x < b.length - 1, v = x > 0;
      return a(A, g, v, function(k) {
        f || (f = k), k && E.forEach(l), !g && (E.forEach(l), w(f));
      });
    });
    return b.reduce(c);
  }
  return _3 = h, _3;
}
var C3, _I;
function a2e() {
  if (_I) return C3;
  _I = 1, C3 = r;
  var t = gS().EventEmitter, e = Fh();
  e(r, t), r.Readable = yj(), r.Writable = mj(), r.Duplex = Jp(), r.Transform = bj(), r.PassThrough = s2e(), r.finished = vS(), r.pipeline = o2e(), r.Stream = r;
  function r() {
    t.call(this);
  }
  return r.prototype.pipe = function(n, i) {
    var s = this;
    function o(b) {
      n.writable && n.write(b) === !1 && s.pause && s.pause();
    }
    s.on("data", o);
    function a() {
      s.readable && s.resume && s.resume();
    }
    n.on("drain", a), !n._isStdio && (!i || i.end !== !1) && (s.on("end", c), s.on("close", p));
    var l = !1;
    function c() {
      l || (l = !0, n.end());
    }
    function p() {
      l || (l = !0, typeof n.destroy == "function" && n.destroy());
    }
    function h(b) {
      if (d(), t.listenerCount(this, "error") === 0)
        throw b;
    }
    s.on("error", h), n.on("error", h);
    function d() {
      s.removeListener("data", o), n.removeListener("drain", a), s.removeListener("end", c), s.removeListener("close", p), s.removeListener("error", h), n.removeListener("error", h), s.removeListener("end", d), s.removeListener("close", d), n.removeListener("close", d);
    }
    return s.on("end", d), s.on("close", d), n.on("close", d), n.emit("pipe", s), n;
  }, C3;
}
var I3, CI;
function l2e() {
  if (CI) return I3;
  CI = 1;
  const t = (e, r) => {
    if (r.length <= 0 || e.length <= 0 || e.equals(r))
      return !1;
    for (let n = 1; n <= Math.min(e.length, r.length - 1); n++) {
      const i = e.subarray(e.length - n, e.length);
      if (r.compare(
        i,
        0,
        i.length,
        0,
        n
      ) === 0)
        return !0;
    }
    return !1;
  };
  return I3 = (e, ...r) => r.some((n) => t(e, n)), I3;
}
var P3, II;
function c2e() {
  if (II) return P3;
  II = 1;
  const t = a2e(), e = Z$(), r = l2e();
  let n = ju.alloc(0);
  return P3 = (...i) => (s = "utf-8") => {
    const o = i.map((a) => ju.from(a, s));
    return new t.Transform({
      transform(a, l, c) {
        n = ju.concat([n, a]), r(n, ...o) || (e(n, ...o).forEach((p) => this.push(p)), n = ju.alloc(0)), c();
      }
    });
  }, P3;
}
var PI;
function u2e() {
  if (PI) return zm;
  PI = 1;
  const t = Z$(), e = c2e();
  return zm.tokenator = t, zm.tokenatorStream = e, zm;
}
var h2e = u2e();
let p2e = class {
  constructor(e, r) {
    this.delimiterStart = e, this.delimiterEnd = r;
  }
  capitalize(e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
  }
  join(e, r) {
    if (e.length === 0)
      return "";
    const n = e.toReversed();
    let i = n.shift(), s = !1;
    for (const o of n)
      s ? i = ", " + i : (i = (n.length === 1 ? " and " : ", and ") + i, s = !0), i = o + i;
    return r && (i = this.capitalize(i)), i;
  }
  parseSlot(e) {
    if (!e)
      throw new Error("Empty Slot");
    const r = e.match(/:/g);
    if (!r || r.length !== 1)
      throw new Error("Type Error in Slot");
    const n = e.split(":"), i = n[0], s = n[1], o = s.match(/#/g);
    let a;
    if (o) {
      if (o.length !== 1)
        throw new Error("Format Error in Slot");
      a = s.split("#")[1];
    }
    return { type: "slot", text: i, format: a };
  }
  parse(e) {
    const r = [], n = h2e.tokenator(e, this.delimiterStart, this.delimiterEnd);
    let i = "ground", s = "";
    for (const o of n)
      o === this.delimiterStart ? i === "ground" ? (s && (r.push({ type: "ground", text: s }), s = ""), i = "slot") : s += o : o === this.delimiterEnd && i === "slot" ? (r.push(this.parseSlot(s)), s = "", i = "ground") : s += o;
    if (i === "slot")
      throw new Error("missing delimiter");
    return s && r.push({ type: "ground", text: s }), r;
  }
  resolve(e, r) {
    let n = "";
    for (const i of e)
      if (i.type === "ground")
        n += i.text;
      else {
        const s = r[i.text];
        let o;
        if (Array.isArray(s) ? o = this.join(s) : typeof s > "u" ? o = "" : o = s.toString(), i.format)
          if (i.format === "cap")
            o = o.charAt(0).toUpperCase() + o.slice(1);
          else if (/^\.\d+$/.test(i.format))
            if (typeof s == "number") {
              const a = parseInt(i.format.slice(1));
              o = s.toFixed(a);
            } else
              throw new Error("[templum]: Decimal place format specifier can only be applied to numbers.");
          else
            throw new Error(`[templum]: Unknown format specifier '${i.format}'`);
        n += o;
      }
    return n;
  }
  interpolate(e, r) {
    return this.resolve(this.parse(e), r);
  }
};
const Xp = new p2e("${", "}"), d2e = Xp.capitalize.bind(Xp), f2e = Xp.join.bind(Xp), qn = Xp.interpolate.bind(Xp);
var g2e = Object.defineProperty, m2e = (t, e, r) => e in t ? g2e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Vt = (t, e, r) => m2e(t, typeof e != "symbol" ? e + "" : e, r);
function Wr(t, e) {
  return e === "raw" || e === "statusBar" ? t.raw : e === "domId" ? Yn(t.raw) : t.value.toString();
}
function Zu(t, e) {
  return Wr(t.facetBox("x"), e);
}
function wS(t, e) {
  return Wr(t.facetBox("y"), e);
}
function xS(t, e) {
  const r = Zu(t, e), n = wS(t, e);
  return `${r}, ${n}`;
}
function y2e(t, e) {
  return [...t.entries()].map(([r, n]) => Wr(n, e)).join(", ");
}
var RI = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function b2e(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Um(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var vj = { exports: {} };
/*! jsonpath 1.1.1 */
(function(t, e) {
  (function(r) {
    t.exports = r();
  })(function() {
    return function r(n, i, s) {
      function o(c, p) {
        if (!i[c]) {
          if (!n[c]) {
            var h = typeof Um == "function" && Um;
            if (!p && h) return h(c, !0);
            if (a) return a(c, !0);
            var d = new Error("Cannot find module '" + c + "'");
            throw d.code = "MODULE_NOT_FOUND", d;
          }
          var b = i[c] = { exports: {} };
          n[c][0].call(b.exports, function(m) {
            var w = n[c][1][m];
            return o(w || m);
          }, b, b.exports, r, n, i, s);
        }
        return i[c].exports;
      }
      for (var a = typeof Um == "function" && Um, l = 0; l < s.length; l++) o(s[l]);
      return o;
    }({ "./aesprim": [function(r, n, i) {
      (function(s, o) {
        o(typeof i < "u" ? i : s.esprima = {});
      })(this, function(s) {
        var o, a, l, c, p, h, d, b, m, w, f, E, A, x, g, v, k, S;
        o = {
          BooleanLiteral: 1,
          EOF: 2,
          Identifier: 3,
          Keyword: 4,
          NullLiteral: 5,
          NumericLiteral: 6,
          Punctuator: 7,
          StringLiteral: 8,
          RegularExpression: 9
        }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
          "(",
          "{",
          "[",
          "in",
          "typeof",
          "instanceof",
          "new",
          "return",
          "case",
          "delete",
          "throw",
          "void",
          // assignment operators
          "=",
          "+=",
          "-=",
          "*=",
          "/=",
          "%=",
          "<<=",
          ">>=",
          ">>>=",
          "&=",
          "|=",
          "^=",
          ",",
          // binary/unary operators
          "+",
          "-",
          "*",
          "/",
          "%",
          "++",
          "--",
          "<<",
          ">>",
          ">>>",
          "&",
          "|",
          "^",
          "!",
          "~",
          "&&",
          "||",
          "?",
          ":",
          "===",
          "==",
          ">=",
          "<=",
          "<",
          ">",
          "!=",
          "!=="
        ], c = {
          AssignmentExpression: "AssignmentExpression",
          ArrayExpression: "ArrayExpression",
          BlockStatement: "BlockStatement",
          BinaryExpression: "BinaryExpression",
          BreakStatement: "BreakStatement",
          CallExpression: "CallExpression",
          CatchClause: "CatchClause",
          ConditionalExpression: "ConditionalExpression",
          ContinueStatement: "ContinueStatement",
          DoWhileStatement: "DoWhileStatement",
          DebuggerStatement: "DebuggerStatement",
          EmptyStatement: "EmptyStatement",
          ExpressionStatement: "ExpressionStatement",
          ForStatement: "ForStatement",
          ForInStatement: "ForInStatement",
          FunctionDeclaration: "FunctionDeclaration",
          FunctionExpression: "FunctionExpression",
          Identifier: "Identifier",
          IfStatement: "IfStatement",
          Literal: "Literal",
          LabeledStatement: "LabeledStatement",
          LogicalExpression: "LogicalExpression",
          MemberExpression: "MemberExpression",
          NewExpression: "NewExpression",
          ObjectExpression: "ObjectExpression",
          Program: "Program",
          Property: "Property",
          ReturnStatement: "ReturnStatement",
          SequenceExpression: "SequenceExpression",
          SwitchStatement: "SwitchStatement",
          SwitchCase: "SwitchCase",
          ThisExpression: "ThisExpression",
          ThrowStatement: "ThrowStatement",
          TryStatement: "TryStatement",
          UnaryExpression: "UnaryExpression",
          UpdateExpression: "UpdateExpression",
          VariableDeclaration: "VariableDeclaration",
          VariableDeclarator: "VariableDeclarator",
          WhileStatement: "WhileStatement",
          WithStatement: "WithStatement"
        }, p = {
          Data: 1,
          Get: 2,
          Set: 4
        }, h = {
          UnexpectedToken: "Unexpected token %0",
          UnexpectedNumber: "Unexpected number",
          UnexpectedString: "Unexpected string",
          UnexpectedIdentifier: "Unexpected identifier",
          UnexpectedReserved: "Unexpected reserved word",
          UnexpectedEOS: "Unexpected end of input",
          NewlineAfterThrow: "Illegal newline after throw",
          InvalidRegExp: "Invalid regular expression",
          UnterminatedRegExp: "Invalid regular expression: missing /",
          InvalidLHSInAssignment: "Invalid left-hand side in assignment",
          InvalidLHSInForIn: "Invalid left-hand side in for-in",
          MultipleDefaultsInSwitch: "More than one default clause in switch statement",
          NoCatchOrFinally: "Missing catch or finally after try",
          UnknownLabel: "Undefined label '%0'",
          Redeclaration: "%0 '%1' has already been declared",
          IllegalContinue: "Illegal continue statement",
          IllegalBreak: "Illegal break statement",
          IllegalReturn: "Illegal return statement",
          StrictModeWith: "Strict mode code may not include a with statement",
          StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
          StrictVarName: "Variable name may not be eval or arguments in strict mode",
          StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
          StrictParamDupe: "Strict mode function may not have duplicate parameter names",
          StrictFunctionName: "Function name may not be eval or arguments in strict mode",
          StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
          StrictDelete: "Delete of an unqualified identifier in strict mode.",
          StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
          AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
          AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
          StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
          StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
          StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
          StrictReservedWord: "Use of future reserved word in strict mode"
        }, d = {
          NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
          NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
        };
        function R(u, y) {
          if (!u)
            throw new Error("ASSERT: " + y);
        }
        function L(u) {
          return u >= 48 && u <= 57;
        }
        function F(u) {
          return "0123456789abcdefABCDEF".indexOf(u) >= 0;
        }
        function z(u) {
          return "01234567".indexOf(u) >= 0;
        }
        function j(u) {
          return u === 32 || u === 9 || u === 11 || u === 12 || u === 160 || u >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(u) >= 0;
        }
        function ee(u) {
          return u === 10 || u === 13 || u === 8232 || u === 8233;
        }
        function X(u) {
          return u == 64 || u === 36 || u === 95 || // $ (dollar) and _ (underscore)
          u >= 65 && u <= 90 || // A..Z
          u >= 97 && u <= 122 || // a..z
          u === 92 || // \ (backslash)
          u >= 128 && d.NonAsciiIdentifierStart.test(String.fromCharCode(u));
        }
        function ie(u) {
          return u === 36 || u === 95 || // $ (dollar) and _ (underscore)
          u >= 65 && u <= 90 || // A..Z
          u >= 97 && u <= 122 || // a..z
          u >= 48 && u <= 57 || // 0..9
          u === 92 || // \ (backslash)
          u >= 128 && d.NonAsciiIdentifierPart.test(String.fromCharCode(u));
        }
        function ce(u) {
          switch (u) {
            case "class":
            case "enum":
            case "export":
            case "extends":
            case "import":
            case "super":
              return !0;
            default:
              return !1;
          }
        }
        function ke(u) {
          switch (u) {
            case "implements":
            case "interface":
            case "package":
            case "private":
            case "protected":
            case "public":
            case "static":
            case "yield":
            case "let":
              return !0;
            default:
              return !1;
          }
        }
        function ye(u) {
          return u === "eval" || u === "arguments";
        }
        function Ce(u) {
          if (w && ke(u))
            return !0;
          switch (u.length) {
            case 2:
              return u === "if" || u === "in" || u === "do";
            case 3:
              return u === "var" || u === "for" || u === "new" || u === "try" || u === "let";
            case 4:
              return u === "this" || u === "else" || u === "case" || u === "void" || u === "with" || u === "enum";
            case 5:
              return u === "while" || u === "break" || u === "catch" || u === "throw" || u === "const" || u === "yield" || u === "class" || u === "super";
            case 6:
              return u === "return" || u === "typeof" || u === "delete" || u === "switch" || u === "export" || u === "import";
            case 7:
              return u === "default" || u === "finally" || u === "extends";
            case 8:
              return u === "function" || u === "continue" || u === "debugger";
            case 10:
              return u === "instanceof";
            default:
              return !1;
          }
        }
        function Ie(u, y, _, T, U) {
          var ne;
          R(typeof _ == "number", "Comment must have valid position"), !(k.lastCommentStart >= _) && (k.lastCommentStart = _, ne = {
            type: u,
            value: y
          }, S.range && (ne.range = [_, T]), S.loc && (ne.loc = U), S.comments.push(ne), S.attachComment && (S.leadingComments.push(ne), S.trailingComments.push(ne)));
        }
        function Te(u) {
          var y, _, T, U;
          for (y = f - u, _ = {
            start: {
              line: E,
              column: f - A - u
            }
          }; f < x; )
            if (T = m.charCodeAt(f), ++f, ee(T)) {
              S.comments && (U = m.slice(y + u, f - 1), _.end = {
                line: E,
                column: f - A - 1
              }, Ie("Line", U, y, f - 1, _)), T === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f;
              return;
            }
          S.comments && (U = m.slice(y + u, f), _.end = {
            line: E,
            column: f - A
          }, Ie("Line", U, y, f, _));
        }
        function ue() {
          var u, y, _, T;
          for (S.comments && (u = f - 2, y = {
            start: {
              line: E,
              column: f - A - 2
            }
          }); f < x; )
            if (_ = m.charCodeAt(f), ee(_))
              _ === 13 && m.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && ge({}, h.UnexpectedToken, "ILLEGAL");
            else if (_ === 42) {
              if (m.charCodeAt(f + 1) === 47) {
                ++f, ++f, S.comments && (T = m.slice(u + 2, f - 2), y.end = {
                  line: E,
                  column: f - A
                }, Ie("Block", T, u, f, y));
                return;
              }
              ++f;
            } else
              ++f;
          ge({}, h.UnexpectedToken, "ILLEGAL");
        }
        function O() {
          var u, y;
          for (y = f === 0; f < x; )
            if (u = m.charCodeAt(f), j(u))
              ++f;
            else if (ee(u))
              ++f, u === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f, y = !0;
            else if (u === 47)
              if (u = m.charCodeAt(f + 1), u === 47)
                ++f, ++f, Te(2), y = !0;
              else if (u === 42)
                ++f, ++f, ue();
              else
                break;
            else if (y && u === 45)
              if (m.charCodeAt(f + 1) === 45 && m.charCodeAt(f + 2) === 62)
                f += 3, Te(3);
              else
                break;
            else if (u === 60)
              if (m.slice(f + 1, f + 4) === "!--")
                ++f, ++f, ++f, ++f, Te(4);
              else
                break;
            else
              break;
        }
        function N(u) {
          var y, _, T, U = 0;
          for (_ = u === "u" ? 4 : 2, y = 0; y < _; ++y)
            if (f < x && F(m[f]))
              T = m[f++], U = U * 16 + "0123456789abcdef".indexOf(T.toLowerCase());
            else
              return "";
          return String.fromCharCode(U);
        }
        function Z() {
          var u, y;
          for (u = m.charCodeAt(f++), y = String.fromCharCode(u), u === 92 && (m.charCodeAt(f) !== 117 && ge({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !X(u.charCodeAt(0))) && ge({}, h.UnexpectedToken, "ILLEGAL"), y = u); f < x && (u = m.charCodeAt(f), !!ie(u)); )
            ++f, y += String.fromCharCode(u), u === 92 && (y = y.substr(0, y.length - 1), m.charCodeAt(f) !== 117 && ge({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !ie(u.charCodeAt(0))) && ge({}, h.UnexpectedToken, "ILLEGAL"), y += u);
          return y;
        }
        function re() {
          var u, y;
          for (u = f++; f < x; ) {
            if (y = m.charCodeAt(f), y === 92)
              return f = u, Z();
            if (ie(y))
              ++f;
            else
              break;
          }
          return m.slice(u, f);
        }
        function le() {
          var u, y, _;
          return u = f, y = m.charCodeAt(f) === 92 ? Z() : re(), y.length === 1 ? _ = o.Identifier : Ce(y) ? _ = o.Keyword : y === "null" ? _ = o.NullLiteral : y === "true" || y === "false" ? _ = o.BooleanLiteral : _ = o.Identifier, {
            type: _,
            value: y,
            lineNumber: E,
            lineStart: A,
            start: u,
            end: f
          };
        }
        function te() {
          var u = f, y = m.charCodeAt(f), _, T = m[f], U, ne, _e;
          switch (y) {
            case 46:
            case 40:
            case 41:
            case 59:
            case 44:
            case 123:
            case 125:
            case 91:
            case 93:
            case 58:
            case 63:
            case 126:
              return ++f, S.tokenize && (y === 40 ? S.openParenToken = S.tokens.length : y === 123 && (S.openCurlyToken = S.tokens.length)), {
                type: o.Punctuator,
                value: String.fromCharCode(y),
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            default:
              if (_ = m.charCodeAt(f + 1), _ === 61)
                switch (y) {
                  case 43:
                  case 45:
                  case 47:
                  case 60:
                  case 62:
                  case 94:
                  case 124:
                  case 37:
                  case 38:
                  case 42:
                    return f += 2, {
                      type: o.Punctuator,
                      value: String.fromCharCode(y) + String.fromCharCode(_),
                      lineNumber: E,
                      lineStart: A,
                      start: u,
                      end: f
                    };
                  case 33:
                  case 61:
                    return f += 2, m.charCodeAt(f) === 61 && ++f, {
                      type: o.Punctuator,
                      value: m.slice(u, f),
                      lineNumber: E,
                      lineStart: A,
                      start: u,
                      end: f
                    };
                }
          }
          if (_e = m.substr(f, 4), _e === ">>>=")
            return f += 4, {
              type: o.Punctuator,
              value: _e,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          if (ne = _e.substr(0, 3), ne === ">>>" || ne === "<<=" || ne === ">>=")
            return f += 3, {
              type: o.Punctuator,
              value: ne,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          if (U = ne.substr(0, 2), T === U[1] && "+-<>&|".indexOf(T) >= 0 || U === "=>")
            return f += 2, {
              type: o.Punctuator,
              value: U,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          if ("<>=!+-*%&|^/".indexOf(T) >= 0)
            return ++f, {
              type: o.Punctuator,
              value: T,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          ge({}, h.UnexpectedToken, "ILLEGAL");
        }
        function oe(u) {
          for (var y = ""; f < x && F(m[f]); )
            y += m[f++];
          return y.length === 0 && ge({}, h.UnexpectedToken, "ILLEGAL"), X(m.charCodeAt(f)) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
            type: o.NumericLiteral,
            value: parseInt("0x" + y, 16),
            lineNumber: E,
            lineStart: A,
            start: u,
            end: f
          };
        }
        function fe(u) {
          for (var y = "0" + m[f++]; f < x && z(m[f]); )
            y += m[f++];
          return (X(m.charCodeAt(f)) || L(m.charCodeAt(f))) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
            type: o.NumericLiteral,
            value: parseInt(y, 8),
            octal: !0,
            lineNumber: E,
            lineStart: A,
            start: u,
            end: f
          };
        }
        function H() {
          var u, y, _;
          if (_ = m[f], R(
            L(_.charCodeAt(0)) || _ === ".",
            "Numeric literal must start with a decimal digit or a decimal point"
          ), y = f, u = "", _ !== ".") {
            if (u = m[f++], _ = m[f], u === "0") {
              if (_ === "x" || _ === "X")
                return ++f, oe(y);
              if (z(_))
                return fe(y);
              _ && L(_.charCodeAt(0)) && ge({}, h.UnexpectedToken, "ILLEGAL");
            }
            for (; L(m.charCodeAt(f)); )
              u += m[f++];
            _ = m[f];
          }
          if (_ === ".") {
            for (u += m[f++]; L(m.charCodeAt(f)); )
              u += m[f++];
            _ = m[f];
          }
          if (_ === "e" || _ === "E")
            if (u += m[f++], _ = m[f], (_ === "+" || _ === "-") && (u += m[f++]), L(m.charCodeAt(f)))
              for (; L(m.charCodeAt(f)); )
                u += m[f++];
            else
              ge({}, h.UnexpectedToken, "ILLEGAL");
          return X(m.charCodeAt(f)) && ge({}, h.UnexpectedToken, "ILLEGAL"), {
            type: o.NumericLiteral,
            value: parseFloat(u),
            lineNumber: E,
            lineStart: A,
            start: y,
            end: f
          };
        }
        function J() {
          var u = "", y, _, T, U, ne, _e, Ne = !1, et, Xe;
          for (et = E, Xe = A, y = m[f], R(
            y === "'" || y === '"',
            "String literal must starts with a quote"
          ), _ = f, ++f; f < x; )
            if (T = m[f++], T === y) {
              y = "";
              break;
            } else if (T === "\\")
              if (T = m[f++], !T || !ee(T.charCodeAt(0)))
                switch (T) {
                  case "u":
                  case "x":
                    _e = f, ne = N(T), ne ? u += ne : (f = _e, u += T);
                    break;
                  case "n":
                    u += `
`;
                    break;
                  case "r":
                    u += "\r";
                    break;
                  case "t":
                    u += "	";
                    break;
                  case "b":
                    u += "\b";
                    break;
                  case "f":
                    u += "\f";
                    break;
                  case "v":
                    u += "\v";
                    break;
                  default:
                    z(T) ? (U = "01234567".indexOf(T), U !== 0 && (Ne = !0), f < x && z(m[f]) && (Ne = !0, U = U * 8 + "01234567".indexOf(m[f++]), "0123".indexOf(T) >= 0 && f < x && z(m[f]) && (U = U * 8 + "01234567".indexOf(m[f++]))), u += String.fromCharCode(U)) : u += T;
                    break;
                }
              else
                ++E, T === "\r" && m[f] === `
` && ++f, A = f;
            else {
              if (ee(T.charCodeAt(0)))
                break;
              u += T;
            }
          return y !== "" && ge({}, h.UnexpectedToken, "ILLEGAL"), {
            type: o.StringLiteral,
            value: u,
            octal: Ne,
            startLineNumber: et,
            startLineStart: Xe,
            lineNumber: E,
            lineStart: A,
            start: _,
            end: f
          };
        }
        function Se(u, y) {
          var _;
          try {
            _ = new RegExp(u, y);
          } catch {
            ge({}, h.InvalidRegExp);
          }
          return _;
        }
        function Re() {
          var u, y, _, T, U;
          for (u = m[f], R(u === "/", "Regular expression literal must start with a slash"), y = m[f++], _ = !1, T = !1; f < x; )
            if (u = m[f++], y += u, u === "\\")
              u = m[f++], ee(u.charCodeAt(0)) && ge({}, h.UnterminatedRegExp), y += u;
            else if (ee(u.charCodeAt(0)))
              ge({}, h.UnterminatedRegExp);
            else if (_)
              u === "]" && (_ = !1);
            else if (u === "/") {
              T = !0;
              break;
            } else u === "[" && (_ = !0);
          return T || ge({}, h.UnterminatedRegExp), U = y.substr(1, y.length - 2), {
            value: U,
            literal: y
          };
        }
        function Fe() {
          var u, y, _, T;
          for (y = "", _ = ""; f < x && (u = m[f], !!ie(u.charCodeAt(0))); )
            if (++f, u === "\\" && f < x)
              if (u = m[f], u === "u") {
                if (++f, T = f, u = N("u"), u)
                  for (_ += u, y += "\\u"; T < f; ++T)
                    y += m[T];
                else
                  f = T, _ += "u", y += "\\u";
                be({}, h.UnexpectedToken, "ILLEGAL");
              } else
                y += "\\", be({}, h.UnexpectedToken, "ILLEGAL");
            else
              _ += u, y += u;
          return {
            value: _,
            literal: y
          };
        }
        function Le() {
          var u, y, _, T;
          return v = null, O(), u = f, y = Re(), _ = Fe(), T = Se(y.value, _.value), S.tokenize ? {
            type: o.RegularExpression,
            value: T,
            lineNumber: E,
            lineStart: A,
            start: u,
            end: f
          } : {
            literal: y.literal + _.literal,
            value: T,
            start: u,
            end: f
          };
        }
        function ze() {
          var u, y, _, T;
          return O(), u = f, y = {
            start: {
              line: E,
              column: f - A
            }
          }, _ = Le(), y.end = {
            line: E,
            column: f - A
          }, S.tokenize || (S.tokens.length > 0 && (T = S.tokens[S.tokens.length - 1], T.range[0] === u && T.type === "Punctuator" && (T.value === "/" || T.value === "/=") && S.tokens.pop()), S.tokens.push({
            type: "RegularExpression",
            value: _.literal,
            range: [u, f],
            loc: y
          })), _;
        }
        function tt(u) {
          return u.type === o.Identifier || u.type === o.Keyword || u.type === o.BooleanLiteral || u.type === o.NullLiteral;
        }
        function Pe() {
          var u, y;
          if (u = S.tokens[S.tokens.length - 1], !u)
            return ze();
          if (u.type === "Punctuator") {
            if (u.value === "]")
              return te();
            if (u.value === ")")
              return y = S.tokens[S.openParenToken - 1], y && y.type === "Keyword" && (y.value === "if" || y.value === "while" || y.value === "for" || y.value === "with") ? ze() : te();
            if (u.value === "}") {
              if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                if (y = S.tokens[S.openCurlyToken - 4], !y)
                  return te();
              } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                if (y = S.tokens[S.openCurlyToken - 5], !y)
                  return ze();
              } else
                return te();
              return l.indexOf(y.value) >= 0 ? te() : ze();
            }
            return ze();
          }
          return u.type === "Keyword" ? ze() : te();
        }
        function At() {
          var u;
          return O(), f >= x ? {
            type: o.EOF,
            lineNumber: E,
            lineStart: A,
            start: f,
            end: f
          } : (u = m.charCodeAt(f), X(u) ? le() : u === 40 || u === 41 || u === 59 ? te() : u === 39 || u === 34 ? J() : u === 46 ? L(m.charCodeAt(f + 1)) ? H() : te() : L(u) ? H() : S.tokenize && u === 47 ? Pe() : te());
        }
        function er() {
          var u, y, _;
          return O(), u = {
            start: {
              line: E,
              column: f - A
            }
          }, y = At(), u.end = {
            line: E,
            column: f - A
          }, y.type !== o.EOF && (_ = m.slice(y.start, y.end), S.tokens.push({
            type: a[y.type],
            value: _,
            range: [y.start, y.end],
            loc: u
          })), y;
        }
        function me() {
          var u;
          return u = v, f = u.end, E = u.lineNumber, A = u.lineStart, v = typeof S.tokens < "u" ? er() : At(), f = u.end, E = u.lineNumber, A = u.lineStart, u;
        }
        function ht() {
          var u, y, _;
          u = f, y = E, _ = A, v = typeof S.tokens < "u" ? er() : At(), f = u, E = y, A = _;
        }
        function it(u, y) {
          this.line = u, this.column = y;
        }
        function kt(u, y, _, T) {
          this.start = new it(u, y), this.end = new it(_, T);
        }
        b = {
          name: "SyntaxTree",
          processComment: function(u) {
            var y, _;
            if (!(u.type === c.Program && u.body.length > 0)) {
              for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= u.range[1] ? (_ = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= u.range[1] && (_ = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= u.range[0]; )
                y = S.bottomRightStack.pop();
              y ? y.leadingComments && y.leadingComments[y.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = y.leadingComments, delete y.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = S.leadingComments, S.leadingComments = []), _ && (u.trailingComments = _), S.bottomRightStack.push(u);
            }
          },
          markEnd: function(u, y) {
            return S.range && (u.range = [y.start, f]), S.loc && (u.loc = new kt(
              y.startLineNumber === void 0 ? y.lineNumber : y.startLineNumber,
              y.start - (y.startLineStart === void 0 ? y.lineStart : y.startLineStart),
              E,
              f - A
            ), this.postProcess(u)), S.attachComment && this.processComment(u), u;
          },
          postProcess: function(u) {
            return S.source && (u.loc.source = S.source), u;
          },
          createArrayExpression: function(u) {
            return {
              type: c.ArrayExpression,
              elements: u
            };
          },
          createAssignmentExpression: function(u, y, _) {
            return {
              type: c.AssignmentExpression,
              operator: u,
              left: y,
              right: _
            };
          },
          createBinaryExpression: function(u, y, _) {
            var T = u === "||" || u === "&&" ? c.LogicalExpression : c.BinaryExpression;
            return {
              type: T,
              operator: u,
              left: y,
              right: _
            };
          },
          createBlockStatement: function(u) {
            return {
              type: c.BlockStatement,
              body: u
            };
          },
          createBreakStatement: function(u) {
            return {
              type: c.BreakStatement,
              label: u
            };
          },
          createCallExpression: function(u, y) {
            return {
              type: c.CallExpression,
              callee: u,
              arguments: y
            };
          },
          createCatchClause: function(u, y) {
            return {
              type: c.CatchClause,
              param: u,
              body: y
            };
          },
          createConditionalExpression: function(u, y, _) {
            return {
              type: c.ConditionalExpression,
              test: u,
              consequent: y,
              alternate: _
            };
          },
          createContinueStatement: function(u) {
            return {
              type: c.ContinueStatement,
              label: u
            };
          },
          createDebuggerStatement: function() {
            return {
              type: c.DebuggerStatement
            };
          },
          createDoWhileStatement: function(u, y) {
            return {
              type: c.DoWhileStatement,
              body: u,
              test: y
            };
          },
          createEmptyStatement: function() {
            return {
              type: c.EmptyStatement
            };
          },
          createExpressionStatement: function(u) {
            return {
              type: c.ExpressionStatement,
              expression: u
            };
          },
          createForStatement: function(u, y, _, T) {
            return {
              type: c.ForStatement,
              init: u,
              test: y,
              update: _,
              body: T
            };
          },
          createForInStatement: function(u, y, _) {
            return {
              type: c.ForInStatement,
              left: u,
              right: y,
              body: _,
              each: !1
            };
          },
          createFunctionDeclaration: function(u, y, _, T) {
            return {
              type: c.FunctionDeclaration,
              id: u,
              params: y,
              defaults: _,
              body: T,
              rest: null,
              generator: !1,
              expression: !1
            };
          },
          createFunctionExpression: function(u, y, _, T) {
            return {
              type: c.FunctionExpression,
              id: u,
              params: y,
              defaults: _,
              body: T,
              rest: null,
              generator: !1,
              expression: !1
            };
          },
          createIdentifier: function(u) {
            return {
              type: c.Identifier,
              name: u
            };
          },
          createIfStatement: function(u, y, _) {
            return {
              type: c.IfStatement,
              test: u,
              consequent: y,
              alternate: _
            };
          },
          createLabeledStatement: function(u, y) {
            return {
              type: c.LabeledStatement,
              label: u,
              body: y
            };
          },
          createLiteral: function(u) {
            return {
              type: c.Literal,
              value: u.value,
              raw: m.slice(u.start, u.end)
            };
          },
          createMemberExpression: function(u, y, _) {
            return {
              type: c.MemberExpression,
              computed: u === "[",
              object: y,
              property: _
            };
          },
          createNewExpression: function(u, y) {
            return {
              type: c.NewExpression,
              callee: u,
              arguments: y
            };
          },
          createObjectExpression: function(u) {
            return {
              type: c.ObjectExpression,
              properties: u
            };
          },
          createPostfixExpression: function(u, y) {
            return {
              type: c.UpdateExpression,
              operator: u,
              argument: y,
              prefix: !1
            };
          },
          createProgram: function(u) {
            return {
              type: c.Program,
              body: u
            };
          },
          createProperty: function(u, y, _) {
            return {
              type: c.Property,
              key: y,
              value: _,
              kind: u
            };
          },
          createReturnStatement: function(u) {
            return {
              type: c.ReturnStatement,
              argument: u
            };
          },
          createSequenceExpression: function(u) {
            return {
              type: c.SequenceExpression,
              expressions: u
            };
          },
          createSwitchCase: function(u, y) {
            return {
              type: c.SwitchCase,
              test: u,
              consequent: y
            };
          },
          createSwitchStatement: function(u, y) {
            return {
              type: c.SwitchStatement,
              discriminant: u,
              cases: y
            };
          },
          createThisExpression: function() {
            return {
              type: c.ThisExpression
            };
          },
          createThrowStatement: function(u) {
            return {
              type: c.ThrowStatement,
              argument: u
            };
          },
          createTryStatement: function(u, y, _, T) {
            return {
              type: c.TryStatement,
              block: u,
              guardedHandlers: y,
              handlers: _,
              finalizer: T
            };
          },
          createUnaryExpression: function(u, y) {
            return u === "++" || u === "--" ? {
              type: c.UpdateExpression,
              operator: u,
              argument: y,
              prefix: !0
            } : {
              type: c.UnaryExpression,
              operator: u,
              argument: y,
              prefix: !0
            };
          },
          createVariableDeclaration: function(u, y) {
            return {
              type: c.VariableDeclaration,
              declarations: u,
              kind: y
            };
          },
          createVariableDeclarator: function(u, y) {
            return {
              type: c.VariableDeclarator,
              id: u,
              init: y
            };
          },
          createWhileStatement: function(u, y) {
            return {
              type: c.WhileStatement,
              test: u,
              body: y
            };
          },
          createWithStatement: function(u, y) {
            return {
              type: c.WithStatement,
              object: u,
              body: y
            };
          }
        };
        function Ze() {
          var u, y, _, T;
          return u = f, y = E, _ = A, O(), T = E !== y, f = u, E = y, A = _, T;
        }
        function ge(u, y) {
          var _, T = Array.prototype.slice.call(arguments, 2), U = y.replace(
            /%(\d)/g,
            function(ne, _e) {
              return R(_e < T.length, "Message reference must be in range"), T[_e];
            }
          );
          throw typeof u.lineNumber == "number" ? (_ = new Error("Line " + u.lineNumber + ": " + U), _.index = u.start, _.lineNumber = u.lineNumber, _.column = u.start - A + 1) : (_ = new Error("Line " + E + ": " + U), _.index = f, _.lineNumber = E, _.column = f - A + 1), _.description = U, _;
        }
        function be() {
          try {
            ge.apply(null, arguments);
          } catch (u) {
            if (S.errors)
              S.errors.push(u);
            else
              throw u;
          }
        }
        function Je(u) {
          if (u.type === o.EOF && ge(u, h.UnexpectedEOS), u.type === o.NumericLiteral && ge(u, h.UnexpectedNumber), u.type === o.StringLiteral && ge(u, h.UnexpectedString), u.type === o.Identifier && ge(u, h.UnexpectedIdentifier), u.type === o.Keyword) {
            if (ce(u.value))
              ge(u, h.UnexpectedReserved);
            else if (w && ke(u.value)) {
              be(u, h.StrictReservedWord);
              return;
            }
            ge(u, h.UnexpectedToken, u.value);
          }
          ge(u, h.UnexpectedToken, u.value);
        }
        function C(u) {
          var y = me();
          (y.type !== o.Punctuator || y.value !== u) && Je(y);
        }
        function $(u) {
          var y = me();
          (y.type !== o.Keyword || y.value !== u) && Je(y);
        }
        function D(u) {
          return v.type === o.Punctuator && v.value === u;
        }
        function ae(u) {
          return v.type === o.Keyword && v.value === u;
        }
        function pe() {
          var u;
          return v.type !== o.Punctuator ? !1 : (u = v.value, u === "=" || u === "*=" || u === "/=" || u === "%=" || u === "+=" || u === "-=" || u === "<<=" || u === ">>=" || u === ">>>=" || u === "&=" || u === "^=" || u === "|=");
        }
        function Ee() {
          var u;
          if (m.charCodeAt(f) === 59 || D(";")) {
            me();
            return;
          }
          u = E, O(), E === u && v.type !== o.EOF && !D("}") && Je(v);
        }
        function Me(u) {
          return u.type === c.Identifier || u.type === c.MemberExpression;
        }
        function ot() {
          var u = [], y;
          for (y = v, C("["); !D("]"); )
            D(",") ? (me(), u.push(null)) : (u.push(W()), D("]") || C(","));
          return me(), g.markEnd(g.createArrayExpression(u), y);
        }
        function dt(u, y) {
          var _, T, U;
          return _ = w, U = v, T = Un(), y && w && ye(u[0].name) && be(y, h.StrictParamName), w = _, g.markEnd(g.createFunctionExpression(null, u, [], T), U);
        }
        function St() {
          var u, y;
          return y = v, u = me(), u.type === o.StringLiteral || u.type === o.NumericLiteral ? (w && u.octal && be(u, h.StrictOctalLiteral), g.markEnd(g.createLiteral(u), y)) : g.markEnd(g.createIdentifier(u.value), y);
        }
        function rt() {
          var u, y, _, T, U, ne;
          if (u = v, ne = v, u.type === o.Identifier)
            return _ = St(), u.value === "get" && !D(":") ? (y = St(), C("("), C(")"), T = dt([]), g.markEnd(g.createProperty("get", y, T), ne)) : u.value === "set" && !D(":") ? (y = St(), C("("), u = v, u.type !== o.Identifier ? (C(")"), be(u, h.UnexpectedToken, u.value), T = dt([])) : (U = [he()], C(")"), T = dt(U, u)), g.markEnd(g.createProperty("set", y, T), ne)) : (C(":"), T = W(), g.markEnd(g.createProperty("init", _, T), ne));
          if (u.type === o.EOF || u.type === o.Punctuator)
            Je(u);
          else
            return y = St(), C(":"), T = W(), g.markEnd(g.createProperty("init", y, T), ne);
        }
        function zt() {
          var u = [], y, _, T, U, ne = {}, _e = String, Ne;
          for (Ne = v, C("{"); !D("}"); )
            y = rt(), y.key.type === c.Identifier ? _ = y.key.name : _ = _e(y.key.value), U = y.kind === "init" ? p.Data : y.kind === "get" ? p.Get : p.Set, T = "$" + _, Object.prototype.hasOwnProperty.call(ne, T) ? (ne[T] === p.Data ? w && U === p.Data ? be({}, h.StrictDuplicateProperty) : U !== p.Data && be({}, h.AccessorDataProperty) : U === p.Data ? be({}, h.AccessorDataProperty) : ne[T] & U && be({}, h.AccessorGetSet), ne[T] |= U) : ne[T] = U, u.push(y), D("}") || C(",");
          return C("}"), g.markEnd(g.createObjectExpression(u), Ne);
        }
        function Xt() {
          var u;
          return C("("), u = G(), C(")"), u;
        }
        function tr() {
          var u, y, _, T;
          if (D("("))
            return Xt();
          if (D("["))
            return ot();
          if (D("{"))
            return zt();
          if (u = v.type, T = v, u === o.Identifier)
            _ = g.createIdentifier(me().value);
          else if (u === o.StringLiteral || u === o.NumericLiteral)
            w && v.octal && be(v, h.StrictOctalLiteral), _ = g.createLiteral(me());
          else if (u === o.Keyword) {
            if (ae("function"))
              return uu();
            ae("this") ? (me(), _ = g.createThisExpression()) : Je(me());
          } else u === o.BooleanLiteral ? (y = me(), y.value = y.value === "true", _ = g.createLiteral(y)) : u === o.NullLiteral ? (y = me(), y.value = null, _ = g.createLiteral(y)) : D("/") || D("/=") ? (typeof S.tokens < "u" ? _ = g.createLiteral(ze()) : _ = g.createLiteral(Le()), ht()) : Je(me());
          return g.markEnd(_, T);
        }
        function Nr() {
          var u = [];
          if (C("("), !D(")"))
            for (; f < x && (u.push(W()), !D(")")); )
              C(",");
          return C(")"), u;
        }
        function ki() {
          var u, y;
          return y = v, u = me(), tt(u) || Je(u), g.markEnd(g.createIdentifier(u.value), y);
        }
        function Zt() {
          return C("."), ki();
        }
        function Vn() {
          var u;
          return C("["), u = G(), C("]"), u;
        }
        function M() {
          var u, y, _;
          return _ = v, $("new"), u = q(), y = D("(") ? Nr() : [], g.markEnd(g.createNewExpression(u, y), _);
        }
        function V() {
          var u, y, _, T, U;
          for (U = v, u = k.allowIn, k.allowIn = !0, y = ae("new") ? M() : tr(), k.allowIn = u; ; ) {
            if (D("."))
              T = Zt(), y = g.createMemberExpression(".", y, T);
            else if (D("("))
              _ = Nr(), y = g.createCallExpression(y, _);
            else if (D("["))
              T = Vn(), y = g.createMemberExpression("[", y, T);
            else
              break;
            g.markEnd(y, U);
          }
          return y;
        }
        function q() {
          var u, y, _, T;
          for (T = v, u = k.allowIn, y = ae("new") ? M() : tr(), k.allowIn = u; D(".") || D("["); )
            D("[") ? (_ = Vn(), y = g.createMemberExpression("[", y, _)) : (_ = Zt(), y = g.createMemberExpression(".", y, _)), g.markEnd(y, T);
          return y;
        }
        function de() {
          var u, y, _ = v;
          return u = V(), v.type === o.Punctuator && (D("++") || D("--")) && !Ze() && (w && u.type === c.Identifier && ye(u.name) && be({}, h.StrictLHSPostfix), Me(u) || be({}, h.InvalidLHSInAssignment), y = me(), u = g.markEnd(g.createPostfixExpression(y.value, u), _)), u;
        }
        function ve() {
          var u, y, _;
          return v.type !== o.Punctuator && v.type !== o.Keyword ? y = de() : D("++") || D("--") ? (_ = v, u = me(), y = ve(), w && y.type === c.Identifier && ye(y.name) && be({}, h.StrictLHSPrefix), Me(y) || be({}, h.InvalidLHSInAssignment), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _)) : D("+") || D("-") || D("~") || D("!") ? (_ = v, u = me(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _)) : ae("delete") || ae("void") || ae("typeof") ? (_ = v, u = me(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, _), w && y.operator === "delete" && y.argument.type === c.Identifier && be({}, h.StrictDelete)) : y = de(), y;
        }
        function Y(u, y) {
          var _ = 0;
          if (u.type !== o.Punctuator && u.type !== o.Keyword)
            return 0;
          switch (u.value) {
            case "||":
              _ = 1;
              break;
            case "&&":
              _ = 2;
              break;
            case "|":
              _ = 3;
              break;
            case "^":
              _ = 4;
              break;
            case "&":
              _ = 5;
              break;
            case "==":
            case "!=":
            case "===":
            case "!==":
              _ = 6;
              break;
            case "<":
            case ">":
            case "<=":
            case ">=":
            case "instanceof":
              _ = 7;
              break;
            case "in":
              _ = y ? 7 : 0;
              break;
            case "<<":
            case ">>":
            case ">>>":
              _ = 8;
              break;
            case "+":
            case "-":
              _ = 9;
              break;
            case "*":
            case "/":
            case "%":
              _ = 11;
              break;
          }
          return _;
        }
        function I() {
          var u, y, _, T, U, ne, _e, Ne, et, Xe;
          if (u = v, et = ve(), T = v, U = Y(T, k.allowIn), U === 0)
            return et;
          for (T.prec = U, me(), y = [u, v], _e = ve(), ne = [et, T, _e]; (U = Y(v, k.allowIn)) > 0; ) {
            for (; ne.length > 2 && U <= ne[ne.length - 2].prec; )
              _e = ne.pop(), Ne = ne.pop().value, et = ne.pop(), _ = g.createBinaryExpression(Ne, et, _e), y.pop(), u = y[y.length - 1], g.markEnd(_, u), ne.push(_);
            T = me(), T.prec = U, ne.push(T), y.push(v), _ = ve(), ne.push(_);
          }
          for (Xe = ne.length - 1, _ = ne[Xe], y.pop(); Xe > 1; )
            _ = g.createBinaryExpression(ne[Xe - 1].value, ne[Xe - 2], _), Xe -= 2, u = y.pop(), g.markEnd(_, u);
          return _;
        }
        function B() {
          var u, y, _, T, U;
          return U = v, u = I(), D("?") && (me(), y = k.allowIn, k.allowIn = !0, _ = W(), k.allowIn = y, C(":"), T = W(), u = g.createConditionalExpression(u, _, T), g.markEnd(u, U)), u;
        }
        function W() {
          var u, y, _, T, U;
          return u = v, U = v, T = y = B(), pe() && (Me(y) || be({}, h.InvalidLHSInAssignment), w && y.type === c.Identifier && ye(y.name) && be(u, h.StrictLHSAssignment), u = me(), _ = W(), T = g.markEnd(g.createAssignmentExpression(u.value, y, _), U)), T;
        }
        function G() {
          var u, y = v;
          if (u = W(), D(",")) {
            for (u = g.createSequenceExpression([u]); f < x && D(","); )
              me(), u.expressions.push(W());
            g.markEnd(u, y);
          }
          return u;
        }
        function K() {
          for (var u = [], y; f < x && !(D("}") || (y = Ir(), typeof y > "u")); )
            u.push(y);
          return u;
        }
        function se() {
          var u, y;
          return y = v, C("{"), u = K(), C("}"), g.markEnd(g.createBlockStatement(u), y);
        }
        function he() {
          var u, y;
          return y = v, u = me(), u.type !== o.Identifier && Je(u), g.markEnd(g.createIdentifier(u.value), y);
        }
        function we(u) {
          var y = null, _, T;
          return T = v, _ = he(), w && ye(_.name) && be({}, h.StrictVarName), u === "const" ? (C("="), y = W()) : D("=") && (me(), y = W()), g.markEnd(g.createVariableDeclarator(_, y), T);
        }
        function Ae(u) {
          var y = [];
          do {
            if (y.push(we(u)), !D(","))
              break;
            me();
          } while (f < x);
          return y;
        }
        function $e() {
          var u;
          return $("var"), u = Ae(), Ee(), g.createVariableDeclaration(u, "var");
        }
        function je(u) {
          var y, _;
          return _ = v, $(u), y = Ae(u), Ee(), g.markEnd(g.createVariableDeclaration(y, u), _);
        }
        function Qe() {
          return C(";"), g.createEmptyStatement();
        }
        function ut() {
          var u = G();
          return Ee(), g.createExpressionStatement(u);
        }
        function st() {
          var u, y, _;
          return $("if"), C("("), u = G(), C(")"), y = Ot(), ae("else") ? (me(), _ = Ot()) : _ = null, g.createIfStatement(u, y, _);
        }
        function Rt() {
          var u, y, _;
          return $("do"), _ = k.inIteration, k.inIteration = !0, u = Ot(), k.inIteration = _, $("while"), C("("), y = G(), C(")"), D(";") && me(), g.createDoWhileStatement(u, y);
        }
        function $t() {
          var u, y, _;
          return $("while"), C("("), u = G(), C(")"), _ = k.inIteration, k.inIteration = !0, y = Ot(), k.inIteration = _, g.createWhileStatement(u, y);
        }
        function Or() {
          var u, y, _;
          return _ = v, u = me(), y = Ae(), g.markEnd(g.createVariableDeclaration(y, u.value), _);
        }
        function an() {
          var u, y, _, T, U, ne, _e;
          return u = y = _ = null, $("for"), C("("), D(";") ? me() : (ae("var") || ae("let") ? (k.allowIn = !1, u = Or(), k.allowIn = !0, u.declarations.length === 1 && ae("in") && (me(), T = u, U = G(), u = null)) : (k.allowIn = !1, u = G(), k.allowIn = !0, ae("in") && (Me(u) || be({}, h.InvalidLHSInForIn), me(), T = u, U = G(), u = null)), typeof T > "u" && C(";")), typeof T > "u" && (D(";") || (y = G()), C(";"), D(")") || (_ = G())), C(")"), _e = k.inIteration, k.inIteration = !0, ne = Ot(), k.inIteration = _e, typeof T > "u" ? g.createForStatement(u, y, _, ne) : g.createForInStatement(T, U, ne);
        }
        function wo() {
          var u = null, y;
          return $("continue"), m.charCodeAt(f) === 59 ? (me(), k.inIteration || ge({}, h.IllegalContinue), g.createContinueStatement(null)) : Ze() ? (k.inIteration || ge({}, h.IllegalContinue), g.createContinueStatement(null)) : (v.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(k.labelSet, y) || ge({}, h.UnknownLabel, u.name)), Ee(), u === null && !k.inIteration && ge({}, h.IllegalContinue), g.createContinueStatement(u));
        }
        function xo() {
          var u = null, y;
          return $("break"), m.charCodeAt(f) === 59 ? (me(), k.inIteration || k.inSwitch || ge({}, h.IllegalBreak), g.createBreakStatement(null)) : Ze() ? (k.inIteration || k.inSwitch || ge({}, h.IllegalBreak), g.createBreakStatement(null)) : (v.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(k.labelSet, y) || ge({}, h.UnknownLabel, u.name)), Ee(), u === null && !(k.inIteration || k.inSwitch) && ge({}, h.IllegalBreak), g.createBreakStatement(u));
        }
        function ru() {
          var u = null;
          return $("return"), k.inFunctionBody || be({}, h.IllegalReturn), m.charCodeAt(f) === 32 && X(m.charCodeAt(f + 1)) ? (u = G(), Ee(), g.createReturnStatement(u)) : Ze() ? g.createReturnStatement(null) : (D(";") || !D("}") && v.type !== o.EOF && (u = G()), Ee(), g.createReturnStatement(u));
        }
        function nu() {
          var u, y;
          return w && (O(), be({}, h.StrictModeWith)), $("with"), C("("), u = G(), C(")"), y = Ot(), g.createWithStatement(u, y);
        }
        function iu() {
          var u, y = [], _, T;
          for (T = v, ae("default") ? (me(), u = null) : ($("case"), u = G()), C(":"); f < x && !(D("}") || ae("default") || ae("case")); )
            _ = Ot(), y.push(_);
          return g.markEnd(g.createSwitchCase(u, y), T);
        }
        function su() {
          var u, y, _, T, U;
          if ($("switch"), C("("), u = G(), C(")"), C("{"), y = [], D("}"))
            return me(), g.createSwitchStatement(u, y);
          for (T = k.inSwitch, k.inSwitch = !0, U = !1; f < x && !D("}"); )
            _ = iu(), _.test === null && (U && ge({}, h.MultipleDefaultsInSwitch), U = !0), y.push(_);
          return k.inSwitch = T, C("}"), g.createSwitchStatement(u, y);
        }
        function ou() {
          var u;
          return $("throw"), Ze() && ge({}, h.NewlineAfterThrow), u = G(), Ee(), g.createThrowStatement(u);
        }
        function au() {
          var u, y, _;
          return _ = v, $("catch"), C("("), D(")") && Je(v), u = he(), w && ye(u.name) && be({}, h.StrictCatchVariable), C(")"), y = se(), g.markEnd(g.createCatchClause(u, y), _);
        }
        function lu() {
          var u, y = [], _ = null;
          return $("try"), u = se(), ae("catch") && y.push(au()), ae("finally") && (me(), _ = se()), y.length === 0 && !_ && ge({}, h.NoCatchOrFinally), g.createTryStatement(u, [], y, _);
        }
        function cu() {
          return $("debugger"), Ee(), g.createDebuggerStatement();
        }
        function Ot() {
          var u = v.type, y, _, T, U;
          if (u === o.EOF && Je(v), u === o.Punctuator && v.value === "{")
            return se();
          if (U = v, u === o.Punctuator)
            switch (v.value) {
              case ";":
                return g.markEnd(Qe(), U);
              case "(":
                return g.markEnd(ut(), U);
            }
          if (u === o.Keyword)
            switch (v.value) {
              case "break":
                return g.markEnd(xo(), U);
              case "continue":
                return g.markEnd(wo(), U);
              case "debugger":
                return g.markEnd(cu(), U);
              case "do":
                return g.markEnd(Rt(), U);
              case "for":
                return g.markEnd(an(), U);
              case "function":
                return g.markEnd(Rs(), U);
              case "if":
                return g.markEnd(st(), U);
              case "return":
                return g.markEnd(ru(), U);
              case "switch":
                return g.markEnd(su(), U);
              case "throw":
                return g.markEnd(ou(), U);
              case "try":
                return g.markEnd(lu(), U);
              case "var":
                return g.markEnd($e(), U);
              case "while":
                return g.markEnd($t(), U);
              case "with":
                return g.markEnd(nu(), U);
            }
          return y = G(), y.type === c.Identifier && D(":") ? (me(), T = "$" + y.name, Object.prototype.hasOwnProperty.call(k.labelSet, T) && ge({}, h.Redeclaration, "Label", y.name), k.labelSet[T] = !0, _ = Ot(), delete k.labelSet[T], g.markEnd(g.createLabeledStatement(y, _), U)) : (Ee(), g.markEnd(g.createExpressionStatement(y), U));
        }
        function Un() {
          var u, y = [], _, T, U, ne, _e, Ne, et, Xe;
          for (Xe = v, C("{"); f < x && !(v.type !== o.StringLiteral || (_ = v, u = Ir(), y.push(u), u.expression.type !== c.Literal)); )
            T = m.slice(_.start + 1, _.end - 1), T === "use strict" ? (w = !0, U && be(U, h.StrictOctalLiteral)) : !U && _.octal && (U = _);
          for (ne = k.labelSet, _e = k.inIteration, Ne = k.inSwitch, et = k.inFunctionBody, k.labelSet = {}, k.inIteration = !1, k.inSwitch = !1, k.inFunctionBody = !0; f < x && !(D("}") || (u = Ir(), typeof u > "u")); )
            y.push(u);
          return C("}"), k.labelSet = ne, k.inIteration = _e, k.inSwitch = Ne, k.inFunctionBody = et, g.markEnd(g.createBlockStatement(y), Xe);
        }
        function Ps(u) {
          var y, _ = [], T, U, ne, _e, Ne;
          if (C("("), !D(")"))
            for (ne = {}; f < x && (T = v, y = he(), _e = "$" + T.value, w ? (ye(T.value) && (U = T, Ne = h.StrictParamName), Object.prototype.hasOwnProperty.call(ne, _e) && (U = T, Ne = h.StrictParamDupe)) : u || (ye(T.value) ? (u = T, Ne = h.StrictParamName) : ke(T.value) ? (u = T, Ne = h.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ne, _e) && (u = T, Ne = h.StrictParamDupe)), _.push(y), ne[_e] = !0, !D(")")); )
              C(",");
          return C(")"), {
            params: _,
            stricted: U,
            firstRestricted: u,
            message: Ne
          };
        }
        function Rs() {
          var u, y = [], _, T, U, ne, _e, Ne, et, Xe;
          return Xe = v, $("function"), T = v, u = he(), w ? ye(T.value) && be(T, h.StrictFunctionName) : ye(T.value) ? (_e = T, Ne = h.StrictFunctionName) : ke(T.value) && (_e = T, Ne = h.StrictReservedWord), ne = Ps(_e), y = ne.params, U = ne.stricted, _e = ne.firstRestricted, ne.message && (Ne = ne.message), et = w, _ = Un(), w && _e && ge(_e, Ne), w && U && be(U, Ne), w = et, g.markEnd(g.createFunctionDeclaration(u, y, [], _), Xe);
        }
        function uu() {
          var u, y = null, _, T, U, ne, _e = [], Ne, et, Xe;
          return Xe = v, $("function"), D("(") || (u = v, y = he(), w ? ye(u.value) && be(u, h.StrictFunctionName) : ye(u.value) ? (T = u, U = h.StrictFunctionName) : ke(u.value) && (T = u, U = h.StrictReservedWord)), ne = Ps(T), _e = ne.params, _ = ne.stricted, T = ne.firstRestricted, ne.message && (U = ne.message), et = w, Ne = Un(), w && T && ge(T, U), w && _ && be(_, U), w = et, g.markEnd(g.createFunctionExpression(y, _e, [], Ne), Xe);
        }
        function Ir() {
          if (v.type === o.Keyword)
            switch (v.value) {
              case "const":
              case "let":
                return je(v.value);
              case "function":
                return Rs();
              default:
                return Ot();
            }
          if (v.type !== o.EOF)
            return Ot();
        }
        function hu() {
          for (var u, y = [], _, T, U; f < x && (_ = v, !(_.type !== o.StringLiteral || (u = Ir(), y.push(u), u.expression.type !== c.Literal))); )
            T = m.slice(_.start + 1, _.end - 1), T === "use strict" ? (w = !0, U && be(U, h.StrictOctalLiteral)) : !U && _.octal && (U = _);
          for (; f < x && (u = Ir(), !(typeof u > "u")); )
            y.push(u);
          return y;
        }
        function pu() {
          var u, y;
          return O(), ht(), y = v, w = !1, u = hu(), g.markEnd(g.createProgram(u), y);
        }
        function Os() {
          var u, y, _, T = [];
          for (u = 0; u < S.tokens.length; ++u)
            y = S.tokens[u], _ = {
              type: y.type,
              value: y.value
            }, S.range && (_.range = y.range), S.loc && (_.loc = y.loc), T.push(_);
          S.tokens = T;
        }
        function du(u, y) {
          var _, T, U;
          _ = String, typeof u != "string" && !(u instanceof String) && (u = _(u)), g = b, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, v = null, k = {
            allowIn: !0,
            labelSet: {},
            inFunctionBody: !1,
            inIteration: !1,
            inSwitch: !1,
            lastCommentStart: -1
          }, S = {}, y = y || {}, y.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []);
          try {
            if (ht(), v.type === o.EOF)
              return S.tokens;
            for (T = me(); v.type !== o.EOF; )
              try {
                T = me();
              } catch (ne) {
                if (T = v, S.errors) {
                  S.errors.push(ne);
                  break;
                } else
                  throw ne;
              }
            Os(), U = S.tokens, typeof S.comments < "u" && (U.comments = S.comments), typeof S.errors < "u" && (U.errors = S.errors);
          } catch (ne) {
            throw ne;
          } finally {
            S = {};
          }
          return U;
        }
        function fu(u, y) {
          var _, T;
          T = String, typeof u != "string" && !(u instanceof String) && (u = T(u)), g = b, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, v = null, k = {
            allowIn: !0,
            labelSet: {},
            inFunctionBody: !1,
            inIteration: !1,
            inSwitch: !1,
            lastCommentStart: -1
          }, S = {}, typeof y < "u" && (S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, S.attachComment = typeof y.attachComment == "boolean" && y.attachComment, S.loc && y.source !== null && y.source !== void 0 && (S.source = T(y.source)), typeof y.tokens == "boolean" && y.tokens && (S.tokens = []), typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
          try {
            _ = pu(), typeof S.comments < "u" && (_.comments = S.comments), typeof S.tokens < "u" && (Os(), _.tokens = S.tokens), typeof S.errors < "u" && (_.errors = S.errors);
          } catch (U) {
            throw U;
          } finally {
            S = {};
          }
          return _;
        }
        s.version = "1.2.2", s.tokenize = du, s.parse = fu, s.Syntax = function() {
          var u, y = {};
          typeof Object.create == "function" && (y = /* @__PURE__ */ Object.create(null));
          for (u in c)
            c.hasOwnProperty(u) && (y[u] = c[u]);
          return typeof Object.freeze == "function" && Object.freeze(y), y;
        }();
      });
    }, {}], 1: [function(r, n, i) {
      (function(s) {
        var o = function() {
          var a = {
            trace: function() {
            },
            yy: {},
            symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
            terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
            productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
            performAction: function(h, d, b, m, w, f, E) {
              m.ast || (m.ast = l, l.initialize());
              var A = f.length - 1;
              switch (w) {
                case 1:
                  return m.ast.set({ expression: { type: "root", value: f[A] } }), m.ast.unshift(), m.ast.yield();
                case 2:
                  return m.ast.set({ expression: { type: "root", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                case 3:
                  return m.ast.unshift(), m.ast.yield();
                case 4:
                  return m.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                case 5:
                  break;
                case 6:
                  break;
                case 7:
                  m.ast.set({ operation: "member" }), m.ast.push();
                  break;
                case 8:
                  m.ast.set({ operation: "subscript" }), m.ast.push();
                  break;
                case 9:
                  m.ast.set({ scope: "child" });
                  break;
                case 10:
                  m.ast.set({ scope: "descendant" });
                  break;
                case 11:
                  break;
                case 12:
                  m.ast.set({ scope: "child", operation: "member" });
                  break;
                case 13:
                  break;
                case 14:
                  m.ast.set({ expression: { type: "wildcard", value: f[A] } });
                  break;
                case 15:
                  m.ast.set({ expression: { type: "identifier", value: f[A] } });
                  break;
                case 16:
                  m.ast.set({ expression: { type: "script_expression", value: f[A] } });
                  break;
                case 17:
                  m.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                  break;
                case 18:
                  break;
                case 19:
                  m.ast.set({ scope: "child" });
                  break;
                case 20:
                  m.ast.set({ scope: "descendant" });
                  break;
                case 21:
                  break;
                case 22:
                  break;
                case 23:
                  break;
                case 24:
                  f[A].length > 1 ? m.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                  break;
                case 25:
                  this.$ = [f[A]];
                  break;
                case 26:
                  this.$ = f[A - 2].concat(f[A]);
                  break;
                case 27:
                  this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, m.ast.set(this.$);
                  break;
                case 28:
                  this.$ = { expression: { type: "string_literal", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 29:
                  this.$ = { expression: { type: "slice", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 30:
                  this.$ = { expression: { type: "wildcard", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 31:
                  this.$ = { expression: { type: "script_expression", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 32:
                  this.$ = { expression: { type: "filter_expression", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 33:
                  this.$ = f[A];
                  break;
                case 34:
                  this.$ = f[A];
                  break;
              }
            },
            table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
            defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
            parseError: function(h, d) {
              if (d.recoverable)
                this.trace(h);
              else
                throw new Error(h);
            },
            parse: function(h) {
              var d = this, b = [0], m = [null], w = [], f = this.table, E = "", A = 0, x = 0, g = 2, v = 1, k = w.slice.call(arguments, 1);
              this.lexer.setInput(h), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
              var S = this.lexer.yylloc;
              w.push(S);
              var R = this.lexer.options && this.lexer.options.ranges;
              typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
              function L() {
                var Ie;
                return Ie = d.lexer.lex() || v, typeof Ie != "number" && (Ie = d.symbols_[Ie] || Ie), Ie;
              }
              for (var F, z, j, ee, X = {}, ie, ce, ke, ye; ; ) {
                if (z = b[b.length - 1], this.defaultActions[z] ? j = this.defaultActions[z] : ((F === null || typeof F > "u") && (F = L()), j = f[z] && f[z][F]), typeof j > "u" || !j.length || !j[0]) {
                  var Ce = "";
                  ye = [];
                  for (ie in f[z])
                    this.terminals_[ie] && ie > g && ye.push("'" + this.terminals_[ie] + "'");
                  this.lexer.showPosition ? Ce = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + ye.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : Ce = "Parse error on line " + (A + 1) + ": Unexpected " + (F == v ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(Ce, {
                    text: this.lexer.match,
                    token: this.terminals_[F] || F,
                    line: this.lexer.yylineno,
                    loc: S,
                    expected: ye
                  });
                }
                if (j[0] instanceof Array && j.length > 1)
                  throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + F);
                switch (j[0]) {
                  case 1:
                    b.push(F), m.push(this.lexer.yytext), w.push(this.lexer.yylloc), b.push(j[1]), F = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                    break;
                  case 2:
                    if (ce = this.productions_[j[1]][1], X.$ = m[m.length - ce], X._$ = {
                      first_line: w[w.length - (ce || 1)].first_line,
                      last_line: w[w.length - 1].last_line,
                      first_column: w[w.length - (ce || 1)].first_column,
                      last_column: w[w.length - 1].last_column
                    }, R && (X._$.range = [
                      w[w.length - (ce || 1)].range[0],
                      w[w.length - 1].range[1]
                    ]), ee = this.performAction.apply(X, [
                      E,
                      x,
                      A,
                      this.yy,
                      j[1],
                      m,
                      w
                    ].concat(k)), typeof ee < "u")
                      return ee;
                    ce && (b = b.slice(0, -1 * ce * 2), m = m.slice(0, -1 * ce), w = w.slice(0, -1 * ce)), b.push(this.productions_[j[1]][0]), m.push(X.$), w.push(X._$), ke = f[b[b.length - 2]][b[b.length - 1]], b.push(ke);
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }
          }, l = {
            initialize: function() {
              this._nodes = [], this._node = {}, this._stash = [];
            },
            set: function(h) {
              for (var d in h) this._node[d] = h[d];
              return this._node;
            },
            node: function(h) {
              return arguments.length && (this._node = h), this._node;
            },
            push: function() {
              this._nodes.push(this._node), this._node = {};
            },
            unshift: function() {
              this._nodes.unshift(this._node), this._node = {};
            },
            yield: function() {
              var h = this._nodes;
              return this.initialize(), h;
            }
          }, c = /* @__PURE__ */ function() {
            var h = {
              EOF: 1,
              parseError: function(d, b) {
                if (this.yy.parser)
                  this.yy.parser.parseError(d, b);
                else
                  throw new Error(d);
              },
              // resets the lexer, sets new input
              setInput: function(d) {
                return this._input = d, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                  first_line: 1,
                  first_column: 0,
                  last_line: 1,
                  last_column: 0
                }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
              },
              // consumes and returns one char from the input
              input: function() {
                var d = this._input[0];
                this.yytext += d, this.yyleng++, this.offset++, this.match += d, this.matched += d;
                var b = d.match(/(?:\r\n?|\n).*/g);
                return b ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), d;
              },
              // unshifts one char (or a string) into the input
              unput: function(d) {
                var b = d.length, m = d.split(/(?:\r\n?|\n)/g);
                this._input = d + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - b - 1), this.offset -= b;
                var w = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
                var f = this.yylloc.range;
                return this.yylloc = {
                  first_line: this.yylloc.first_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.first_column,
                  last_column: m ? (m.length === w.length ? this.yylloc.first_column : 0) + w[w.length - m.length].length - m[0].length : this.yylloc.first_column - b
                }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - b]), this.yyleng = this.yytext.length, this;
              },
              // When called from action, caches matched text and appends it on next action
              more: function() {
                return this._more = !0, this;
              },
              // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
              reject: function() {
                if (this.options.backtrack_lexer)
                  this._backtrack = !0;
                else
                  return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                return this;
              },
              // retain first n characters of the match
              less: function(d) {
                this.unput(this.match.slice(d));
              },
              // displays already matched input, i.e. for error messages
              pastInput: function() {
                var d = this.matched.substr(0, this.matched.length - this.match.length);
                return (d.length > 20 ? "..." : "") + d.substr(-20).replace(/\n/g, "");
              },
              // displays upcoming input, i.e. for error messages
              upcomingInput: function() {
                var d = this.match;
                return d.length < 20 && (d += this._input.substr(0, 20 - d.length)), (d.substr(0, 20) + (d.length > 20 ? "..." : "")).replace(/\n/g, "");
              },
              // displays the character position where the lexing error occurred, i.e. for error messages
              showPosition: function() {
                var d = this.pastInput(), b = new Array(d.length + 1).join("-");
                return d + this.upcomingInput() + `
` + b + "^";
              },
              // test the lexed token: return FALSE when not a match, otherwise return token
              test_match: function(d, b) {
                var m, w, f;
                if (this.options.backtrack_lexer && (f = {
                  yylineno: this.yylineno,
                  yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
                }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), w = d[0].match(/(?:\r\n?|\n).*/g), w && (this.yylineno += w.length), this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: w ? w[w.length - 1].length - w[w.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + d[0].length
                }, this.yytext += d[0], this.match += d[0], this.matches = d, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(d[0].length), this.matched += d[0], m = this.performAction.call(this, this.yy, this, b, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
                  return m;
                if (this._backtrack) {
                  for (var E in f)
                    this[E] = f[E];
                  return !1;
                }
                return !1;
              },
              // return next match in input
              next: function() {
                if (this.done)
                  return this.EOF;
                this._input || (this.done = !0);
                var d, b, m, w;
                this._more || (this.yytext = "", this.match = "");
                for (var f = this._currentRules(), E = 0; E < f.length; E++)
                  if (m = this._input.match(this.rules[f[E]]), m && (!b || m[0].length > b[0].length)) {
                    if (b = m, w = E, this.options.backtrack_lexer) {
                      if (d = this.test_match(m, f[E]), d !== !1)
                        return d;
                      if (this._backtrack) {
                        b = !1;
                        continue;
                      } else
                        return !1;
                    } else if (!this.options.flex)
                      break;
                  }
                return b ? (d = this.test_match(b, f[w]), d !== !1 ? d : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              },
              // return next match that has a token
              lex: function() {
                var d = this.next();
                return d || this.lex();
              },
              // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
              begin: function(d) {
                this.conditionStack.push(d);
              },
              // pop the previously active lexer condition state off the condition stack
              popState: function() {
                var d = this.conditionStack.length - 1;
                return d > 0 ? this.conditionStack.pop() : this.conditionStack[0];
              },
              // produce the lexer rule set which is active for the currently active lexer condition state
              _currentRules: function() {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
              },
              // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
              topState: function(d) {
                return d = this.conditionStack.length - 1 - Math.abs(d || 0), d >= 0 ? this.conditionStack[d] : "INITIAL";
              },
              // alias for begin(condition)
              pushState: function(d) {
                this.begin(d);
              },
              // return the number of states currently on the stack
              stateStackSize: function() {
                return this.conditionStack.length;
              },
              options: {},
              performAction: function(d, b, m, w) {
                switch (m) {
                  case 0:
                    return 4;
                  case 1:
                    return 14;
                  case 2:
                    return 12;
                  case 3:
                    return 15;
                  case 4:
                    return 16;
                  case 5:
                    return 22;
                  case 6:
                    return 24;
                  case 7:
                    return 28;
                  case 8:
                    return 30;
                  case 9:
                    return 18;
                  case 10:
                    return b.yytext = b.yytext.substr(1, b.yyleng - 2), 32;
                  case 11:
                    return b.yytext = b.yytext.substr(1, b.yyleng - 2), 33;
                  case 12:
                    return 17;
                  case 13:
                    return 31;
                }
              },
              rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
              conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
            };
            return h;
          }();
          a.lexer = c;
          function p() {
            this.yy = {};
          }
          return p.prototype = a, a.Parser = p, new p();
        }();
        typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
          return o.parse.apply(o, arguments);
        }, i.main = function(a) {
          a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
          var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
          return i.parser.parse(l);
        }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
      }).call(this, r("_process"));
    }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
      n.exports = {
        identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
        integer: "-?(?:0|[1-9][0-9]*)",
        qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
        q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
      };
    }, {}], 3: [function(r, n, i) {
      var s = r("./dict"), o = r("fs"), a = {
        lex: {
          macros: {
            esc: "\\\\",
            int: s.integer
          },
          rules: [
            ["\\$", "return 'DOLLAR'"],
            ["\\.\\.", "return 'DOT_DOT'"],
            ["\\.", "return 'DOT'"],
            ["\\*", "return 'STAR'"],
            [s.identifier, "return 'IDENTIFIER'"],
            ["\\[", "return '['"],
            ["\\]", "return ']'"],
            [",", "return ','"],
            ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
            ["{int}", "return 'INTEGER'"],
            [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
            [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
            ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
            ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
          ]
        },
        start: "JSON_PATH",
        bnf: {
          JSON_PATH: [
            ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
            ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
            ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
            ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
          ],
          PATH_COMPONENTS: [
            ["PATH_COMPONENT", ""],
            ["PATH_COMPONENTS PATH_COMPONENT", ""]
          ],
          PATH_COMPONENT: [
            ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
            ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
          ],
          MEMBER_COMPONENT: [
            ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
            ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
          ],
          CHILD_MEMBER_COMPONENT: [
            ["DOT MEMBER_EXPRESSION", ""]
          ],
          LEADING_CHILD_MEMBER_EXPRESSION: [
            ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
          ],
          DESCENDANT_MEMBER_COMPONENT: [
            ["DOT_DOT MEMBER_EXPRESSION", ""]
          ],
          MEMBER_EXPRESSION: [
            ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
            ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
            ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
            ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
            ["END", ""]
          ],
          SUBSCRIPT_COMPONENT: [
            ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
            ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
          ],
          CHILD_SUBSCRIPT_COMPONENT: [
            ["[ SUBSCRIPT ]", ""]
          ],
          DESCENDANT_SUBSCRIPT_COMPONENT: [
            ["DOT_DOT [ SUBSCRIPT ]", ""]
          ],
          SUBSCRIPT: [
            ["SUBSCRIPT_EXPRESSION", ""],
            ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
          ],
          SUBSCRIPT_EXPRESSION_LIST: [
            ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
            ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
          ],
          SUBSCRIPT_EXPRESSION_LISTABLE: [
            ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
            ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
            ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
          ],
          SUBSCRIPT_EXPRESSION: [
            ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
            ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
            ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
          ],
          STRING_LITERAL: [
            ["QQ_STRING", "$$ = $1"],
            ["Q_STRING", "$$ = $1"]
          ]
        }
      };
      o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
    }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
      var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
        return this.initialize.apply(this, arguments);
      };
      c.prototype.initialize = function() {
        this.traverse = b(!0), this.descend = b();
      }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
        var g = [x.operation, x.scope, x.expression.type].join("-"), v = this._fns[g];
        if (!v) throw new Error("couldn't resolve key: " + g);
        return v.bind(this);
      }, c.prototype.register = function(x, g) {
        if (!g instanceof Function)
          throw new Error("handler must be a function");
        this._fns[x] = g;
      }, c.prototype._fns = {
        "member-child-identifier": function(x, g) {
          var v = x.expression.value, k = g.value;
          if (k instanceof Object && v in k)
            return [{ value: k[v], path: g.path.concat(v) }];
        },
        "member-descendant-identifier": w(function(x, g, v) {
          return x == v;
        }),
        "subscript-child-numeric_literal": m(function(x, g, v) {
          return x === v;
        }),
        "member-child-numeric_literal": m(function(x, g, v) {
          return String(x) === String(v);
        }),
        "subscript-descendant-numeric_literal": w(function(x, g, v) {
          return x === v;
        }),
        "member-child-wildcard": m(function() {
          return !0;
        }),
        "member-descendant-wildcard": w(function() {
          return !0;
        }),
        "subscript-descendant-wildcard": w(function() {
          return !0;
        }),
        "subscript-child-wildcard": m(function() {
          return !0;
        }),
        "subscript-child-slice": function(x, g) {
          if (h(g.value)) {
            var v = x.expression.value.split(":").map(A), k = g.value.map(function(S, R) {
              return { value: S, path: g.path.concat(R) };
            });
            return o.apply(null, [k].concat(v));
          }
        },
        "subscript-child-union": function(x, g) {
          var v = [];
          return x.expression.value.forEach(function(k) {
            var S = { operation: "subscript", scope: "child", expression: k.expression }, R = this.resolve(S), L = R(S, g);
            L && (v = v.concat(L));
          }, this), E(v);
        },
        "subscript-descendant-union": function(x, g, v) {
          var k = r(".."), S = this, R = [], L = k.nodes(g, "$..*").slice(1);
          return L.forEach(function(F) {
            R.length >= v || x.expression.value.forEach(function(z) {
              var j = { operation: "subscript", scope: "child", expression: z.expression }, ee = S.resolve(j), X = ee(j, F);
              R = R.concat(X);
            });
          }), E(R);
        },
        "subscript-child-filter_expression": function(x, g, v) {
          var k = x.expression.value.slice(2, -1), S = s.parse(k).body[0].expression, R = function(L, F) {
            return f(S, { "@": F });
          };
          return this.descend(g, null, R, v);
        },
        "subscript-descendant-filter_expression": function(x, g, v) {
          var k = x.expression.value.slice(2, -1), S = s.parse(k).body[0].expression, R = function(L, F) {
            return f(S, { "@": F });
          };
          return this.traverse(g, null, R, v);
        },
        "subscript-child-script_expression": function(x, g) {
          var v = x.expression.value.slice(1, -1);
          return p(g, v, "$[{{value}}]");
        },
        "member-child-script_expression": function(x, g) {
          var v = x.expression.value.slice(1, -1);
          return p(g, v, "$.{{value}}");
        },
        "member-descendant-script_expression": function(x, g) {
          var v = x.expression.value.slice(1, -1);
          return p(g, v, "$..value");
        }
      }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
      function p(x, g, v) {
        var k = r("./index"), S = s.parse(g).body[0].expression, R = f(S, { "@": x.value }), L = v.replace(/\{\{\s*value\s*\}\}/g, R), F = k.nodes(x.value, L);
        return F.forEach(function(z) {
          z.path = x.path.concat(z.path.slice(1));
        }), F;
      }
      function h(x) {
        return Array.isArray(x);
      }
      function d(x) {
        return x && !(x instanceof Array) && x instanceof Object;
      }
      function b(x) {
        return function(g, v, k, S) {
          var R = g.value, L = g.path, F = [], z = (function(j, ee) {
            h(j) ? (j.forEach(function(X, ie) {
              F.length >= S || k(ie, X, v) && F.push({ path: ee.concat(ie), value: X });
            }), j.forEach(function(X, ie) {
              F.length >= S || x && z(X, ee.concat(ie));
            })) : d(j) && (this.keys(j).forEach(function(X) {
              F.length >= S || k(X, j[X], v) && F.push({ path: ee.concat(X), value: j[X] });
            }), this.keys(j).forEach(function(X) {
              F.length >= S || x && z(j[X], ee.concat(X));
            }));
          }).bind(this);
          return z(R, L), F;
        };
      }
      function m(x) {
        return function(g, v, k) {
          return this.descend(v, g.expression.value, x, k);
        };
      }
      function w(x) {
        return function(g, v, k) {
          return this.traverse(v, g.expression.value, x, k);
        };
      }
      function f() {
        try {
          return a.apply(this, arguments);
        } catch {
        }
      }
      function E(x) {
        return x = x.filter(function(g) {
          return g;
        }), l(
          x,
          function(g) {
            return g.path.map(function(v) {
              return String(v).replace("-", "--");
            }).join("-");
          }
        );
      }
      function A(x) {
        var g = String(x);
        return g.match(/^-?[0-9]+$/) ? parseInt(g) : null;
      }
      n.exports = c;
    }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
      var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
        this.initialize.apply(this, arguments);
      };
      c.prototype.initialize = function() {
        this.parser = new a(), this.handlers = new l();
      }, c.prototype.parse = function(d) {
        return s.ok(p(d), "we need a path"), this.parser.parse(d);
      }, c.prototype.parent = function(d, b) {
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
        var m = this.nodes(d, b)[0];
        return m.path.pop(), this.value(d, m.path);
      }, c.prototype.apply = function(d, b, m) {
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), s.equal(typeof m, "function", "fn needs to be function");
        var w = this.nodes(d, b).sort(function(f, E) {
          return E.path.length - f.path.length;
        });
        return w.forEach(function(f) {
          var E = f.path.pop(), A = this.value(d, this.stringify(f.path)), x = f.value = m.call(d, A[E]);
          A[E] = x;
        }, this), w;
      }, c.prototype.value = function(d, b, m) {
        if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), arguments.length >= 3) {
          var w = this.nodes(d, b).shift();
          if (!w) return this._vivify(d, b, m);
          var f = w.path.slice(-1).shift(), E = this.parent(d, this.stringify(w.path));
          E[f] = m;
        }
        return this.query(d, this.stringify(b), 1).shift();
      }, c.prototype._vivify = function(d, b, m) {
        var w = this;
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
        var f = this.parser.parse(b).map(function(A) {
          return A.expression.value;
        }), E = function(A, x) {
          var g = A.pop(), v = w.value(d, A);
          v || (E(A.concat(), typeof g == "string" ? {} : []), v = w.value(d, A)), v[g] = x;
        };
        return E(f, m), this.query(d, b)[0];
      }, c.prototype.query = function(d, b, m) {
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(p(b), "we need a path");
        var w = this.nodes(d, b, m).map(function(f) {
          return f.value;
        });
        return w;
      }, c.prototype.paths = function(d, b, m) {
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path");
        var w = this.nodes(d, b, m).map(function(f) {
          return f.path;
        });
        return w;
      }, c.prototype.nodes = function(d, b, m) {
        if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(b, "we need a path"), m === 0) return [];
        var w = this.parser.parse(b), f = this.handlers, E = [{ path: ["$"], value: d }], A = [];
        return w.length && w[0].expression.type == "root" && w.shift(), w.length ? (w.forEach(function(x, g) {
          if (!(A.length >= m)) {
            var v = f.resolve(x), k = [];
            E.forEach(function(S) {
              if (!(A.length >= m)) {
                var R = v(x, S, m);
                g == w.length - 1 ? A = A.concat(R || []) : k = k.concat(R || []);
              }
            }), E = k;
          }
        }), m ? A.slice(0, m) : A) : E;
      }, c.prototype.stringify = function(d) {
        s.ok(d, "we need a path");
        var b = "$", m = {
          "descendant-member": "..{{value}}",
          "child-member": ".{{value}}",
          "descendant-subscript": "..[{{value}}]",
          "child-subscript": "[{{value}}]"
        };
        return d = this._normalize(d), d.forEach(function(w) {
          if (w.expression.type != "root") {
            var f = [w.scope, w.operation].join("-"), E = m[f], A;
            if (w.expression.type == "string_literal" ? A = JSON.stringify(w.expression.value) : A = w.expression.value, !E) throw new Error("couldn't find template " + f);
            b += E.replace(/{{value}}/, A);
          }
        }), b;
      }, c.prototype._normalize = function(d) {
        if (s.ok(d, "we need a path"), typeof d == "string")
          return this.parser.parse(d);
        if (Array.isArray(d) && typeof d[0] == "string") {
          var b = [{ expression: { type: "root", value: "$" } }];
          return d.forEach(function(m, w) {
            if (!(m == "$" && w === 0))
              if (typeof m == "string" && m.match("^" + o.identifier + "$"))
                b.push({
                  operation: "member",
                  scope: "child",
                  expression: { value: m, type: "identifier" }
                });
              else {
                var f = typeof m == "number" ? "numeric_literal" : "string_literal";
                b.push({
                  operation: "subscript",
                  scope: "child",
                  expression: { value: m, type: f }
                });
              }
          }), b;
        } else if (Array.isArray(d) && typeof d[0] == "object")
          return d;
        throw new Error("couldn't understand path " + d);
      };
      function p(d) {
        return Object.prototype.toString.call(d) == "[object String]";
      }
      c.Handlers = l, c.Parser = a;
      var h = new c();
      h.JSONPath = c, n.exports = h;
    }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
      var s = r("./grammar"), o = r("../generated/parser"), a = function() {
        var l = new o.Parser(), c = l.parseError;
        return l.yy.parseError = function() {
          l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
        }, l;
      };
      a.grammar = s, n.exports = a;
    }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
      n.exports = function(o, a, l, c) {
        if (typeof a == "string") throw new Error("start cannot be a string");
        if (typeof l == "string") throw new Error("end cannot be a string");
        if (typeof c == "string") throw new Error("step cannot be a string");
        var p = o.length;
        if (c === 0) throw new Error("step cannot be zero");
        if (c = c ? s(c) : 1, a = a < 0 ? p + a : a, l = l < 0 ? p + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : p - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? p : -1)), a = c > 0 ? Math.max(0, a) : Math.min(p, a), l = c > 0 ? Math.min(l, p) : Math.max(-1, l), c > 0 && l <= a) return [];
        if (c < 0 && a <= l) return [];
        for (var h = [], d = a; d != l && !(c < 0 && d <= l || c > 0 && d >= l); d += c)
          h.push(o[d]);
        return h;
      };
      function s(o) {
        return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
      }
    }, {}], 8: [function(r, n, i) {
      var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = b;
      l.AssertionError = function(g) {
        this.name = "AssertionError", this.actual = g.actual, this.expected = g.expected, this.operator = g.operator, g.message ? (this.message = g.message, this.generatedMessage = !1) : (this.message = h(this), this.generatedMessage = !0);
        var v = g.stackStartFunction || d;
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, v);
        else {
          var k = new Error();
          if (k.stack) {
            var S = k.stack, R = v.name, L = S.indexOf(`
` + R);
            if (L >= 0) {
              var F = S.indexOf(`
`, L + 1);
              S = S.substring(F + 1);
            }
            this.stack = S;
          }
        }
      }, s.inherits(l.AssertionError, Error);
      function c(g, v) {
        return s.isUndefined(v) ? "" + v : s.isNumber(v) && !isFinite(v) || s.isFunction(v) || s.isRegExp(v) ? v.toString() : v;
      }
      function p(g, v) {
        return s.isString(g) ? g.length < v ? g : g.slice(0, v) : g;
      }
      function h(g) {
        return p(JSON.stringify(g.actual, c), 128) + " " + g.operator + " " + p(JSON.stringify(g.expected, c), 128);
      }
      function d(g, v, k, S, R) {
        throw new l.AssertionError({
          message: k,
          actual: g,
          expected: v,
          operator: S,
          stackStartFunction: R
        });
      }
      l.fail = d;
      function b(g, v) {
        g || d(g, !0, v, "==", l.ok);
      }
      l.ok = b, l.equal = function(g, v, k) {
        g != v && d(g, v, k, "==", l.equal);
      }, l.notEqual = function(g, v, k) {
        g == v && d(g, v, k, "!=", l.notEqual);
      }, l.deepEqual = function(g, v, k) {
        m(g, v) || d(g, v, k, "deepEqual", l.deepEqual);
      };
      function m(g, v) {
        if (g === v)
          return !0;
        if (s.isBuffer(g) && s.isBuffer(v)) {
          if (g.length != v.length) return !1;
          for (var k = 0; k < g.length; k++)
            if (g[k] !== v[k]) return !1;
          return !0;
        } else return s.isDate(g) && s.isDate(v) ? g.getTime() === v.getTime() : s.isRegExp(g) && s.isRegExp(v) ? g.source === v.source && g.global === v.global && g.multiline === v.multiline && g.lastIndex === v.lastIndex && g.ignoreCase === v.ignoreCase : !s.isObject(g) && !s.isObject(v) ? g == v : f(g, v);
      }
      function w(g) {
        return Object.prototype.toString.call(g) == "[object Arguments]";
      }
      function f(g, v) {
        if (s.isNullOrUndefined(g) || s.isNullOrUndefined(v) || g.prototype !== v.prototype) return !1;
        if (s.isPrimitive(g) || s.isPrimitive(v))
          return g === v;
        var k = w(g), S = w(v);
        if (k && !S || !k && S)
          return !1;
        if (k)
          return g = o.call(g), v = o.call(v), m(g, v);
        var R = x(g), L = x(v), F, z;
        if (R.length != L.length)
          return !1;
        for (R.sort(), L.sort(), z = R.length - 1; z >= 0; z--)
          if (R[z] != L[z])
            return !1;
        for (z = R.length - 1; z >= 0; z--)
          if (F = R[z], !m(g[F], v[F])) return !1;
        return !0;
      }
      l.notDeepEqual = function(g, v, k) {
        m(g, v) && d(g, v, k, "notDeepEqual", l.notDeepEqual);
      }, l.strictEqual = function(g, v, k) {
        g !== v && d(g, v, k, "===", l.strictEqual);
      }, l.notStrictEqual = function(g, v, k) {
        g === v && d(g, v, k, "!==", l.notStrictEqual);
      };
      function E(g, v) {
        return !g || !v ? !1 : Object.prototype.toString.call(v) == "[object RegExp]" ? v.test(g) : g instanceof v ? !0 : v.call({}, g) === !0;
      }
      function A(g, v, k, S) {
        var R;
        s.isString(k) && (S = k, k = null);
        try {
          v();
        } catch (L) {
          R = L;
        }
        if (S = (k && k.name ? " (" + k.name + ")." : ".") + (S ? " " + S : "."), g && !R && d(R, k, "Missing expected exception" + S), !g && E(R, k) && d(R, k, "Got unwanted exception" + S), g && R && k && !E(R, k) || !g && R)
          throw R;
      }
      l.throws = function(g, v, k) {
        A.apply(this, [!0].concat(o.call(arguments)));
      }, l.doesNotThrow = function(g, v) {
        A.apply(this, [!1].concat(o.call(arguments)));
      }, l.ifError = function(g) {
        if (g)
          throw g;
      };
      var x = Object.keys || function(g) {
        var v = [];
        for (var k in g)
          a.call(g, k) && v.push(k);
        return v;
      };
    }, { "util/": 11 }], 9: [function(r, n, i) {
      typeof Object.create == "function" ? n.exports = function(s, o) {
        s.super_ = o, s.prototype = Object.create(o.prototype, {
          constructor: {
            value: s,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
      } : n.exports = function(s, o) {
        s.super_ = o;
        var a = function() {
        };
        a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
      };
    }, {}], 10: [function(r, n, i) {
      n.exports = function(s) {
        return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
      };
    }, {}], 11: [function(r, n, i) {
      (function(s, o) {
        var a = /%[sdj%]/g;
        i.format = function(O) {
          if (!L(O)) {
            for (var N = [], Z = 0; Z < arguments.length; Z++)
              N.push(p(arguments[Z]));
            return N.join(" ");
          }
          for (var Z = 1, re = arguments, le = re.length, te = String(O).replace(a, function(H) {
            if (H === "%%") return "%";
            if (Z >= le) return H;
            switch (H) {
              case "%s":
                return String(re[Z++]);
              case "%d":
                return Number(re[Z++]);
              case "%j":
                try {
                  return JSON.stringify(re[Z++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return H;
            }
          }), oe = re[Z]; Z < le; oe = re[++Z])
            k(oe) || !ee(oe) ? te += " " + oe : te += " " + p(oe);
          return te;
        }, i.deprecate = function(O, N) {
          if (z(o.process))
            return function() {
              return i.deprecate(O, N).apply(this, arguments);
            };
          if (s.noDeprecation === !0)
            return O;
          var Z = !1;
          function re() {
            if (!Z) {
              if (s.throwDeprecation)
                throw new Error(N);
              s.traceDeprecation ? console.trace(N) : console.error(N), Z = !0;
            }
            return O.apply(this, arguments);
          }
          return re;
        };
        var l = {}, c;
        i.debuglog = function(O) {
          if (z(c) && (c = s.env.NODE_DEBUG || ""), O = O.toUpperCase(), !l[O])
            if (new RegExp("\\b" + O + "\\b", "i").test(c)) {
              var N = s.pid;
              l[O] = function() {
                var Z = i.format.apply(i, arguments);
                console.error("%s %d: %s", O, N, Z);
              };
            } else
              l[O] = function() {
              };
          return l[O];
        };
        function p(O, N) {
          var Z = {
            seen: [],
            stylize: d
          };
          return arguments.length >= 3 && (Z.depth = arguments[2]), arguments.length >= 4 && (Z.colors = arguments[3]), v(N) ? Z.showHidden = N : N && i._extend(Z, N), z(Z.showHidden) && (Z.showHidden = !1), z(Z.depth) && (Z.depth = 2), z(Z.colors) && (Z.colors = !1), z(Z.customInspect) && (Z.customInspect = !0), Z.colors && (Z.stylize = h), m(Z, O, Z.depth);
        }
        i.inspect = p, p.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        }, p.styles = {
          special: "cyan",
          number: "yellow",
          boolean: "yellow",
          undefined: "grey",
          null: "bold",
          string: "green",
          date: "magenta",
          // "name": intentionally not styling
          regexp: "red"
        };
        function h(O, N) {
          var Z = p.styles[N];
          return Z ? "\x1B[" + p.colors[Z][0] + "m" + O + "\x1B[" + p.colors[Z][1] + "m" : O;
        }
        function d(O, N) {
          return O;
        }
        function b(O) {
          var N = {};
          return O.forEach(function(Z, re) {
            N[Z] = !0;
          }), N;
        }
        function m(O, N, Z) {
          if (O.customInspect && N && ce(N.inspect) && // Filter out the util module, it's inspect function is special
          N.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
          !(N.constructor && N.constructor.prototype === N)) {
            var re = N.inspect(Z, O);
            return L(re) || (re = m(O, re, Z)), re;
          }
          var le = w(O, N);
          if (le)
            return le;
          var te = Object.keys(N), oe = b(te);
          if (O.showHidden && (te = Object.getOwnPropertyNames(N)), ie(N) && (te.indexOf("message") >= 0 || te.indexOf("description") >= 0))
            return f(N);
          if (te.length === 0) {
            if (ce(N)) {
              var fe = N.name ? ": " + N.name : "";
              return O.stylize("[Function" + fe + "]", "special");
            }
            if (j(N))
              return O.stylize(RegExp.prototype.toString.call(N), "regexp");
            if (X(N))
              return O.stylize(Date.prototype.toString.call(N), "date");
            if (ie(N))
              return f(N);
          }
          var H = "", J = !1, Se = ["{", "}"];
          if (g(N) && (J = !0, Se = ["[", "]"]), ce(N)) {
            var Re = N.name ? ": " + N.name : "";
            H = " [Function" + Re + "]";
          }
          if (j(N) && (H = " " + RegExp.prototype.toString.call(N)), X(N) && (H = " " + Date.prototype.toUTCString.call(N)), ie(N) && (H = " " + f(N)), te.length === 0 && (!J || N.length == 0))
            return Se[0] + H + Se[1];
          if (Z < 0)
            return j(N) ? O.stylize(RegExp.prototype.toString.call(N), "regexp") : O.stylize("[Object]", "special");
          O.seen.push(N);
          var Fe;
          return J ? Fe = E(O, N, Z, oe, te) : Fe = te.map(function(Le) {
            return A(O, N, Z, oe, Le, J);
          }), O.seen.pop(), x(Fe, H, Se);
        }
        function w(O, N) {
          if (z(N))
            return O.stylize("undefined", "undefined");
          if (L(N)) {
            var Z = "'" + JSON.stringify(N).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return O.stylize(Z, "string");
          }
          if (R(N))
            return O.stylize("" + N, "number");
          if (v(N))
            return O.stylize("" + N, "boolean");
          if (k(N))
            return O.stylize("null", "null");
        }
        function f(O) {
          return "[" + Error.prototype.toString.call(O) + "]";
        }
        function E(O, N, Z, re, le) {
          for (var te = [], oe = 0, fe = N.length; oe < fe; ++oe)
            ue(N, String(oe)) ? te.push(A(
              O,
              N,
              Z,
              re,
              String(oe),
              !0
            )) : te.push("");
          return le.forEach(function(H) {
            H.match(/^\d+$/) || te.push(A(
              O,
              N,
              Z,
              re,
              H,
              !0
            ));
          }), te;
        }
        function A(O, N, Z, re, le, te) {
          var oe, fe, H;
          if (H = Object.getOwnPropertyDescriptor(N, le) || { value: N[le] }, H.get ? H.set ? fe = O.stylize("[Getter/Setter]", "special") : fe = O.stylize("[Getter]", "special") : H.set && (fe = O.stylize("[Setter]", "special")), ue(re, le) || (oe = "[" + le + "]"), fe || (O.seen.indexOf(H.value) < 0 ? (k(Z) ? fe = m(O, H.value, null) : fe = m(O, H.value, Z - 1), fe.indexOf(`
`) > -1 && (te ? fe = fe.split(`
`).map(function(J) {
            return "  " + J;
          }).join(`
`).substr(2) : fe = `
` + fe.split(`
`).map(function(J) {
            return "   " + J;
          }).join(`
`))) : fe = O.stylize("[Circular]", "special")), z(oe)) {
            if (te && le.match(/^\d+$/))
              return fe;
            oe = JSON.stringify("" + le), oe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (oe = oe.substr(1, oe.length - 2), oe = O.stylize(oe, "name")) : (oe = oe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), oe = O.stylize(oe, "string"));
          }
          return oe + ": " + fe;
        }
        function x(O, N, Z) {
          var re = O.reduce(function(le, te) {
            return te.indexOf(`
`) >= 0, le + te.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return re > 60 ? Z[0] + (N === "" ? "" : N + `
 `) + " " + O.join(`,
  `) + " " + Z[1] : Z[0] + N + " " + O.join(", ") + " " + Z[1];
        }
        function g(O) {
          return Array.isArray(O);
        }
        i.isArray = g;
        function v(O) {
          return typeof O == "boolean";
        }
        i.isBoolean = v;
        function k(O) {
          return O === null;
        }
        i.isNull = k;
        function S(O) {
          return O == null;
        }
        i.isNullOrUndefined = S;
        function R(O) {
          return typeof O == "number";
        }
        i.isNumber = R;
        function L(O) {
          return typeof O == "string";
        }
        i.isString = L;
        function F(O) {
          return typeof O == "symbol";
        }
        i.isSymbol = F;
        function z(O) {
          return O === void 0;
        }
        i.isUndefined = z;
        function j(O) {
          return ee(O) && ye(O) === "[object RegExp]";
        }
        i.isRegExp = j;
        function ee(O) {
          return typeof O == "object" && O !== null;
        }
        i.isObject = ee;
        function X(O) {
          return ee(O) && ye(O) === "[object Date]";
        }
        i.isDate = X;
        function ie(O) {
          return ee(O) && (ye(O) === "[object Error]" || O instanceof Error);
        }
        i.isError = ie;
        function ce(O) {
          return typeof O == "function";
        }
        i.isFunction = ce;
        function ke(O) {
          return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || // ES6 symbol
          typeof O > "u";
        }
        i.isPrimitive = ke, i.isBuffer = r("./support/isBuffer");
        function ye(O) {
          return Object.prototype.toString.call(O);
        }
        function Ce(O) {
          return O < 10 ? "0" + O.toString(10) : O.toString(10);
        }
        var Ie = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ];
        function Te() {
          var O = /* @__PURE__ */ new Date(), N = [
            Ce(O.getHours()),
            Ce(O.getMinutes()),
            Ce(O.getSeconds())
          ].join(":");
          return [O.getDate(), Ie[O.getMonth()], N].join(" ");
        }
        i.log = function() {
          console.log("%s - %s", Te(), i.format.apply(i, arguments));
        }, i.inherits = r("inherits"), i._extend = function(O, N) {
          if (!N || !ee(N)) return O;
          for (var Z = Object.keys(N), re = Z.length; re--; )
            O[Z[re]] = N[Z[re]];
          return O;
        };
        function ue(O, N) {
          return Object.prototype.hasOwnProperty.call(O, N);
        }
      }).call(this, r("_process"), typeof RI < "u" ? RI : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
    }, {}], 13: [function(r, n, i) {
      (function(s) {
        function o(p, h) {
          for (var d = 0, b = p.length - 1; b >= 0; b--) {
            var m = p[b];
            m === "." ? p.splice(b, 1) : m === ".." ? (p.splice(b, 1), d++) : d && (p.splice(b, 1), d--);
          }
          if (h)
            for (; d--; d)
              p.unshift("..");
          return p;
        }
        i.resolve = function() {
          for (var p = "", h = !1, d = arguments.length - 1; d >= -1 && !h; d--) {
            var b = d >= 0 ? arguments[d] : s.cwd();
            if (typeof b != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            b && (p = b + "/" + p, h = b.charAt(0) === "/");
          }
          return p = o(l(p.split("/"), function(m) {
            return !!m;
          }), !h).join("/"), (h ? "/" : "") + p || ".";
        }, i.normalize = function(p) {
          var h = i.isAbsolute(p), d = c(p, -1) === "/";
          return p = o(l(p.split("/"), function(b) {
            return !!b;
          }), !h).join("/"), !p && !h && (p = "."), p && d && (p += "/"), (h ? "/" : "") + p;
        }, i.isAbsolute = function(p) {
          return p.charAt(0) === "/";
        }, i.join = function() {
          var p = Array.prototype.slice.call(arguments, 0);
          return i.normalize(l(p, function(h, d) {
            if (typeof h != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return h;
          }).join("/"));
        }, i.relative = function(p, h) {
          p = i.resolve(p).substr(1), h = i.resolve(h).substr(1);
          function d(x) {
            for (var g = 0; g < x.length && x[g] === ""; g++)
              ;
            for (var v = x.length - 1; v >= 0 && x[v] === ""; v--)
              ;
            return g > v ? [] : x.slice(g, v - g + 1);
          }
          for (var b = d(p.split("/")), m = d(h.split("/")), w = Math.min(b.length, m.length), f = w, E = 0; E < w; E++)
            if (b[E] !== m[E]) {
              f = E;
              break;
            }
          for (var A = [], E = f; E < b.length; E++)
            A.push("..");
          return A = A.concat(m.slice(f)), A.join("/");
        }, i.sep = "/", i.delimiter = ":", i.dirname = function(p) {
          if (typeof p != "string" && (p = p + ""), p.length === 0) return ".";
          for (var h = p.charCodeAt(0), d = h === 47, b = -1, m = !0, w = p.length - 1; w >= 1; --w)
            if (h = p.charCodeAt(w), h === 47) {
              if (!m) {
                b = w;
                break;
              }
            } else
              m = !1;
          return b === -1 ? d ? "/" : "." : d && b === 1 ? "/" : p.slice(0, b);
        };
        function a(p) {
          typeof p != "string" && (p = p + "");
          var h = 0, d = -1, b = !0, m;
          for (m = p.length - 1; m >= 0; --m)
            if (p.charCodeAt(m) === 47) {
              if (!b) {
                h = m + 1;
                break;
              }
            } else d === -1 && (b = !1, d = m + 1);
          return d === -1 ? "" : p.slice(h, d);
        }
        i.basename = function(p, h) {
          var d = a(p);
          return h && d.substr(-1 * h.length) === h && (d = d.substr(0, d.length - h.length)), d;
        }, i.extname = function(p) {
          typeof p != "string" && (p = p + "");
          for (var h = -1, d = 0, b = -1, m = !0, w = 0, f = p.length - 1; f >= 0; --f) {
            var E = p.charCodeAt(f);
            if (E === 47) {
              if (!m) {
                d = f + 1;
                break;
              }
              continue;
            }
            b === -1 && (m = !1, b = f + 1), E === 46 ? h === -1 ? h = f : w !== 1 && (w = 1) : h !== -1 && (w = -1);
          }
          return h === -1 || b === -1 || // We saw a non-dot character immediately before the dot
          w === 0 || // The (right-most) trimmed path component is exactly '..'
          w === 1 && h === b - 1 && h === d + 1 ? "" : p.slice(h, b);
        };
        function l(p, h) {
          if (p.filter) return p.filter(h);
          for (var d = [], b = 0; b < p.length; b++)
            h(p[b], b, p) && d.push(p[b]);
          return d;
        }
        var c = "ab".substr(-1) === "b" ? function(p, h, d) {
          return p.substr(h, d);
        } : function(p, h, d) {
          return h < 0 && (h = p.length + h), p.substr(h, d);
        };
      }).call(this, r("_process"));
    }, { _process: 14 }], 14: [function(r, n, i) {
      var s = n.exports = {}, o, a;
      function l() {
        throw new Error("setTimeout has not been defined");
      }
      function c() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? o = setTimeout : o = l;
        } catch {
          o = l;
        }
        try {
          typeof clearTimeout == "function" ? a = clearTimeout : a = c;
        } catch {
          a = c;
        }
      })();
      function p(g) {
        if (o === setTimeout)
          return setTimeout(g, 0);
        if ((o === l || !o) && setTimeout)
          return o = setTimeout, setTimeout(g, 0);
        try {
          return o(g, 0);
        } catch {
          try {
            return o.call(null, g, 0);
          } catch {
            return o.call(this, g, 0);
          }
        }
      }
      function h(g) {
        if (a === clearTimeout)
          return clearTimeout(g);
        if ((a === c || !a) && clearTimeout)
          return a = clearTimeout, clearTimeout(g);
        try {
          return a(g);
        } catch {
          try {
            return a.call(null, g);
          } catch {
            return a.call(this, g);
          }
        }
      }
      var d = [], b = !1, m, w = -1;
      function f() {
        !b || !m || (b = !1, m.length ? d = m.concat(d) : w = -1, d.length && E());
      }
      function E() {
        if (!b) {
          var g = p(f);
          b = !0;
          for (var v = d.length; v; ) {
            for (m = d, d = []; ++w < v; )
              m && m[w].run();
            w = -1, v = d.length;
          }
          m = null, b = !1, h(g);
        }
      }
      s.nextTick = function(g) {
        var v = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var k = 1; k < arguments.length; k++)
            v[k - 1] = arguments[k];
        d.push(new A(g, v)), d.length === 1 && !b && p(E);
      };
      function A(g, v) {
        this.fun = g, this.array = v;
      }
      A.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
      function x() {
      }
      s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(g) {
        return [];
      }, s.binding = function(g) {
        throw new Error("process.binding is not supported");
      }, s.cwd = function() {
        return "/";
      }, s.chdir = function(g) {
        throw new Error("process.chdir is not supported");
      }, s.umask = function() {
        return 0;
      };
    }, {}], 15: [function(r, n, i) {
      var s = r("escodegen").generate;
      n.exports = function(o, a) {
        a || (a = {});
        var l = {}, c = function p(h, d) {
          if (h.type === "Literal")
            return h.value;
          if (h.type === "UnaryExpression") {
            var b = p(h.argument);
            return h.operator === "+" ? +b : h.operator === "-" ? -b : h.operator === "~" ? ~b : h.operator === "!" ? !b : l;
          } else if (h.type === "ArrayExpression") {
            for (var m = [], w = 0, f = h.elements.length; w < f; w++) {
              var E = p(h.elements[w]);
              if (E === l) return l;
              m.push(E);
            }
            return m;
          } else if (h.type === "ObjectExpression") {
            for (var A = {}, w = 0; w < h.properties.length; w++) {
              var x = h.properties[w], g = x.value === null ? x.value : p(x.value);
              if (g === l) return l;
              A[x.key.value || x.key.name] = g;
            }
            return A;
          } else if (h.type === "BinaryExpression" || h.type === "LogicalExpression") {
            var f = p(h.left);
            if (f === l) return l;
            var v = p(h.right);
            if (v === l) return l;
            var k = h.operator;
            return k === "==" ? f == v : k === "===" ? f === v : k === "!=" ? f != v : k === "!==" ? f !== v : k === "+" ? f + v : k === "-" ? f - v : k === "*" ? f * v : k === "/" ? f / v : k === "%" ? f % v : k === "<" ? f < v : k === "<=" ? f <= v : k === ">" ? f > v : k === ">=" ? f >= v : k === "|" ? f | v : k === "&" ? f & v : k === "^" ? f ^ v : k === "&&" ? f && v : k === "||" ? f || v : l;
          } else {
            if (h.type === "Identifier")
              return {}.hasOwnProperty.call(a, h.name) ? a[h.name] : l;
            if (h.type === "ThisExpression")
              return {}.hasOwnProperty.call(a, "this") ? a.this : l;
            if (h.type === "CallExpression") {
              var S = p(h.callee);
              if (S === l || typeof S != "function") return l;
              var R = h.callee.object ? p(h.callee.object) : l;
              R === l && (R = null);
              for (var L = [], w = 0, f = h.arguments.length; w < f; w++) {
                var E = p(h.arguments[w]);
                if (E === l) return l;
                L.push(E);
              }
              return S.apply(R, L);
            } else if (h.type === "MemberExpression") {
              var A = p(h.object);
              if (A === l || typeof A == "function")
                return l;
              if (h.property.type === "Identifier")
                return A[h.property.name];
              var x = p(h.property);
              return x === l ? l : A[x];
            } else if (h.type === "ConditionalExpression") {
              var b = p(h.test);
              return b === l ? l : p(b ? h.consequent : h.alternate);
            } else if (h.type === "ExpressionStatement") {
              var b = p(h.expression);
              return b === l ? l : b;
            } else {
              if (h.type === "ReturnStatement")
                return p(h.argument);
              if (h.type === "FunctionExpression") {
                var F = h.body.body, z = {};
                Object.keys(a).forEach(function(Ie) {
                  z[Ie] = a[Ie];
                });
                for (var w = 0; w < h.params.length; w++) {
                  var j = h.params[w];
                  if (j.type == "Identifier")
                    a[j.name] = null;
                  else return l;
                }
                for (var w in F)
                  if (p(F[w]) === l)
                    return l;
                a = z;
                var ee = Object.keys(a), X = ee.map(function(Ie) {
                  return a[Ie];
                });
                return Function(ee.join(", "), "return " + s(h)).apply(null, X);
              } else if (h.type === "TemplateLiteral") {
                for (var ie = "", w = 0; w < h.expressions.length; w++)
                  ie += p(h.quasis[w]), ie += p(h.expressions[w]);
                return ie += p(h.quasis[w]), ie;
              } else if (h.type === "TaggedTemplateExpression") {
                var ce = p(h.tag), ke = h.quasi, ye = ke.quasis.map(p), Ce = ke.expressions.map(p);
                return ce.apply(null, [ye].concat(Ce));
              } else return h.type === "TemplateElement" ? h.value.cooked : l;
            }
          }
        }(o);
        return c === l ? void 0 : c;
      };
    }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
      n.exports = r("./lib/index");
    }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
  });
})(vj);
var v2e = vj.exports;
const y4 = /* @__PURE__ */ b2e(v2e);
function jd(t) {
  let e, r, n;
  return e = t, (i, s, o) => {
    if (o.value != null)
      o.value = OI(o.value, e, r, n);
    else if (o.get != null)
      o.get = OI(o.get, e, r, n);
    else
      throw "Only put a Memoize() decorator on a method or get accessor.";
  };
}
const R3 = /* @__PURE__ */ new Map();
function OI(t, e, r = 0, n) {
  const i = Symbol("__memoized_map__");
  return function(...s) {
    let o;
    this.hasOwnProperty(i) || Object.defineProperty(this, i, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: /* @__PURE__ */ new Map()
    });
    let a = this[i];
    if (Array.isArray(n))
      for (const l of n)
        R3.has(l) ? R3.get(l).push(a) : R3.set(l, [a]);
    if (e || s.length > 0 || r > 0) {
      let l;
      e === !0 ? l = s.map((h) => h.toString()).join("!") : e ? l = e.apply(this, s) : l = s[0];
      const c = `${l}__timestamp`;
      let p = !1;
      if (r > 0)
        if (!a.has(c))
          p = !0;
        else {
          let h = a.get(c);
          p = Date.now() - h > r;
        }
      a.has(l) && !p ? o = a.get(l) : (o = t.apply(this, s), a.set(l, o), r > 0 && a.set(c, Date.now()));
    } else {
      const l = this;
      a.has(l) ? o = a.get(l) : (o = t.apply(this, s), a.set(l, o));
    }
    return o;
  };
}
var w2e = Object.defineProperty, x2e = (t, e, r) => e in t ? w2e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, _i = (t, e, r) => x2e(t, typeof e != "symbol" ? e + "" : e, r), E2e = Object.defineProperty, S2e = (t, e, r) => e in t ? E2e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Lo = (t, e, r) => (S2e(t, typeof e != "symbol" ? e + "" : e, r), r), wj = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(globalThis, () => (() => {
    var r, n = { d: (Y, I) => {
      for (var B in I)
        n.o(I, B) && !n.o(Y, B) && Object.defineProperty(Y, B, { enumerable: !0, get: I[B] });
    }, o: (Y, I) => Object.prototype.hasOwnProperty.call(Y, I), r: (Y) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(Y, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(Y, "__esModule", { value: !0 });
    } }, i = {};
    async function s(Y) {
      const I = new DecompressionStream("gzip"), B = Y.stream().pipeThrough(I);
      return await new Response(B).blob();
    }
    n.r(i), n.d(i, { A: () => kt, AP: () => St, Adv: () => Je, AdvP: () => zt, C: () => C, CP: () => tr, Constituent: () => v, D: () => ge, DT: () => D, Dependent: () => ue, Dependent_en: () => ki, N: () => it, NO: () => ae, NP: () => dt, P: () => $, PP: () => Xt, Phrase: () => Ie, Phrase_en: () => Ee, Pro: () => Ze, Q: () => pe, S: () => ot, SP: () => Nr, Terminal: () => ie, Terminal_en: () => me, V: () => be, VP: () => rt, addToLexicon: () => p, comp: () => de, coord: () => ve, dependent: () => Zt, det: () => V, exceptionOnWarning: () => tt, fromJSON: () => le, getElems: () => oe, getLanguage: () => d, getLemma: () => h, getLexicon: () => b, getRules: () => m, getSavedWarnings: () => er, isRunningUnderNode: () => Le, jsRealB_dateCreated: () => Fe, jsRealB_version: () => Re, load: () => fe, loadEn: () => c, mix: () => Se, mod: () => q, oneOf: () => J, phrase: () => Me, ppJSON: () => te, resetSavedWarnings: () => At, root: () => Vn, savedWarnings: () => ze, setExceptionOnWarning: () => Pe, setQuoteOOV: () => f, setReorderVPcomplements: () => A, subj: () => M, terminal: () => ht });
    const o = {}, a = {};
    let l = "en";
    async function c(Y = !1) {
      l = "en", await async function() {
        console.log("decompressing lexicon  and grammar rules");
        const I = await (await fetch("data:application/gzip;base64,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")).blob(), B = JSON.parse(await (await s(I)).text()), W = await (await fetch("data:application/gzip;base64,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")).blob(), G = JSON.parse(await (await s(W)).text());
        o.en = B, a.en = G;
      }(), Y && console.log("English lexicon and rules loaded");
    }
    function p(Y, I, B) {
      let W = b(B);
      if (I !== null)
        return I == null && (I = Object.values(Y)[0], Y = Object.keys(Y)[0]), W[Y] !== void 0 && I !== void 0 ? Object.assign(W[Y], I) : W[Y] = I, W[Y];
      W[Y] !== void 0 && delete W[Y];
    }
    function h(Y, I) {
      return b(I)[Y];
    }
    function d() {
      return l;
    }
    function b(Y) {
      return Y !== void 0 ? o[Y] : o[l];
    }
    function m(Y) {
      return Y !== void 0 ? a[Y] : a[l];
    }
    let w = !1;
    function f(Y) {
      w = Y;
    }
    let E = !1;
    function A(Y) {
      E = Y;
    }
    const x = ["root", "subj", "det", "mod", "comp", "coord"], g = class I1 {
      constructor(I) {
        this.parentConst = null, this.constType = I, this.props = {}, this.realization = null, this.optSource = "";
      }
      initProps() {
        if (this.isA("N", "A", "D", "V", "NO", "Pro", "Q", "DT")) {
          const I = this.defaultProps();
          this.peng = { pe: I.pe, n: I.n, g: I.g, pengNO: I1.pengNO++ }, this.isA("V") && (this.taux = { t: I.t, tauxNO: I1.tauxNO++ });
        }
      }
      clone() {
        return le(this.toJSON(), this.lang);
      }
      error(I) {
        throw `Internal error: this should never have happened, sorry!
` + this.me() + ":: " + I;
      }
      isA(I) {
        if (arguments.length == 1) {
          if (!Array.isArray(I))
            return I == this.constType;
        } else
          I = Array.from(arguments);
        return I.includes(this.constType);
      }
      getProp(I) {
        const B = this.props[I];
        return B !== void 0 ? B : I == "pe" || I == "n" || I == "g" ? this.peng === void 0 ? void 0 : this.peng[I] : I == "t" || I == "aux" ? this.taux === void 0 ? void 0 : this.taux[I] : void 0;
      }
      setProp(I, B, W) {
        I == "pe" || I == "n" || I == "g" ? this.peng !== void 0 && (this.peng[I] = B) : I != "t" && I != "aux" || this.taux !== void 0 && (this.taux[I] = B), ["pe", "n", "g", "t", "aux"].includes(I) && W !== void 0 || (this.props[I] = B);
      }
      getFromPath(I) {
        if (I.length == 0)
          return this;
        const B = I.shift(), W = this.getConst(B);
        return W === void 0 ? typeof B == "object" && B.includes("") && I.length > 0 ? this.getFromPath(I) : void 0 : W.getFromPath(I);
      }
      getTonicPro(I) {
        if (this.isA("Pro")) {
          if (this.props.tn || this.props.c)
            return I !== void 0 ? this.props.c = I : (this.props.tn = "", "c" in this.props && delete this.props.c), this;
          if (this.tonic_forms().includes(this.lemma)) {
            if (I !== void 0)
              return Ze(this.lemma, this.lang).c(I);
          } else if (I !== void 0)
            return Ze(this.realize(), this.lang).c(I);
          return this;
        }
        {
          let B = Ze(this.tonic_pe_1(), this.lang);
          const W = this.getProp("g");
          W !== void 0 && B.g(W);
          const G = this.getProp("n");
          G !== void 0 && B.n(G);
          const K = this.getProp("pe");
          return K !== void 0 && B.pe(K), I === void 0 ? Ze(B.realize(), this.lang).tn("") : Ze(B.realize(), this.lang).c(I);
        }
      }
      getParentLang() {
        return this.lang !== void 0 ? this.lang : this.parentConst === null ? d() : this.parentConst.getParentLang();
      }
      addOptSource(I, B) {
        this.optSource += "." + I + "(" + (B === void 0 ? "" : JSON.stringify(B)) + ")";
      }
      tag(I, B) {
        return B == null || Object.keys(B).length == 0 ? (this.addOptSource("tag", I), B = {}) : this.optSource += ".tag('" + I + "'," + JSON.stringify(B) + ")", this.props.tag === void 0 && (this.props.tag = []), this.props.tag.push([I, B]), this;
      }
      dOpt(I) {
        if (this.addOptSource("dOpt", I), typeof I != "object")
          return this.warn("bad application", ".dOpt", "object", typeof I);
        if (this.isA("DT")) {
          const B = ["year", "month", "date", "day", "hour", "minute", "second", "nat", "det", "rtime"], W = Object.keys(I);
          for (let G = 0; G < W.length; G++) {
            const K = W[G];
            if (!B.includes(K))
              return this.warn("ignored value for option", "DT.dOpt", K);
            {
              const se = I[K];
              if (K == "rtime")
                if (typeof se == "boolean")
                  this.props.dOpt.rtime = !!se && /* @__PURE__ */ new Date();
                else if (typeof se == "string")
                  this.props.dOpt.rtime = new Date(se);
                else {
                  if (!(se instanceof Date))
                    return this.warn("bad application", ".dOpt('rtime')", ["boolean", "string", "Date"], se);
                  this.props.dOpt.rtime = se;
                }
              else {
                if (typeof se != "boolean")
                  return this.warn("bad application", ".dOpt(" + K + ")", "boolean", se);
                this.props.dOpt[K] = se;
              }
            }
          }
        } else {
          if (!this.isA("NO"))
            return this.warn("bad application", ".dOpt", ["DT", "NO"], this.constType);
          {
            const B = ["mprecision", "raw", "nat", "ord", "rom"], W = Object.keys(I);
            for (let G = 0; G < W.length; G++) {
              const K = W[G];
              if (!B.includes(K))
                return this.warn("ignored value for option", "NO.dOpt", K);
              {
                const se = I[K];
                if (K == "mprecision") {
                  if (typeof se != "number")
                    return this.warn("bad application", "precision", "number", se);
                  this.props.dOpt.mprecision = se;
                } else {
                  if (typeof se != "boolean")
                    return this.warn("bad application", ".dOpt(" + K + ")", "boolean", se);
                  this.props.dOpt[K] = se;
                }
              }
            }
          }
        }
        return this;
      }
      nat(I) {
        if (this.addOptSource("nat", I), !this.isA("DT", "NO"))
          return this.warn("bad application", ".nat", ["DT", "NO"], this.constType);
        {
          const B = this.props.dOpt;
          if (I === void 0)
            B.nat = !0;
          else {
            if (typeof I != "boolean")
              return this.warn("bad application", ".nat", "boolean", I);
            B.nat = I;
          }
        }
        return this;
      }
      typ(I) {
        const B = { neg: [!1, !0], pas: [!1, !0], prog: [!1, !0], exc: [!1, !0], perf: [!1, !0], contr: [!1, !0], refl: [!1, !0], mod: [!1, "poss", "perm", "nece", "obli", "will"], int: [!1, "yon", "wos", "wod", "woi", "was", "wad", "wai", "whe", "why", "whn", "how", "muc", "tag"] };
        if (this.addOptSource("typ", I), this.isA("S", "SP", "VP") || this.isA(x))
          if (typeof I == "object") {
            for (let W in I) {
              const G = I[W], K = B[W];
              K === void 0 ? this.warn("unknown type", W, Object.keys(B)) : W == "neg" && this.validate_neg_option(G, I) || K.includes(G) || (this.warn("ignored value for option", ".typ(" + W + ")", G), delete I[W]);
            }
            this.props.typ = I;
          } else
            this.warn("ignored value for option", ".typ", typeof I + ":" + JSON.stringify(I));
        else
          this.warn("bad application", ".typ(" + JSON.stringify(I) + ")", ["S", "SP", "VP", "Dependent"], this.constType);
        return this;
      }
      doFormat(I) {
        const B = m(this.lang).punctuation, W = b(this.lang);
        function G(je) {
          const Qe = W[je];
          if (Qe !== void 0 && Qe.Pc !== void 0) {
            const ut = Qe.Pc.compl;
            if (ut !== void 0) {
              const st = je, Rt = ut, $t = Qe.Pc.tab, Or = $t[0], an = $t.length == 2 ? $t[1] : W[ut].Pc.tab[0], wo = B[Or], xo = B[an];
              return { b: wo.b + st + wo.a, a: xo.b + Rt + xo.a };
            }
            {
              const st = Qe.Pc.tab[0], Rt = B[st];
              je = Rt.b + je + Rt.a;
            }
          }
          return { b: je, a: je };
        }
        function K(je, Qe) {
          I[0].realization = je + I[0].realization, I[I.length - 1].realization += Qe;
        }
        (function(je) {
          for (let Qe = 0; Qe < je.length; )
            je[Qe].realization == "" && je.length > 1 ? je.splice(Qe, 1) : Qe++;
        })(I), (this.isA("VP") || this.isA(x) && this.terminal.isA("V")) && this.doPronounPlacement(I), this.doElision(I);
        const se = this.props.cap;
        if (se !== void 0 && se !== !1) {
          const je = I[0].realization;
          je.length > 0 && (I[0].realization = je.charAt(0).toUpperCase() + je.substring(1));
        }
        const he = this.props.tag;
        he !== void 0 && he.forEach(function(je) {
          const Qe = je[0];
          var ut;
          K((ut = je[1], "<" + Qe + Object.entries(ut).map(function(st) {
            return " " + st[0] + '="' + st[1] + '"';
          }).join("") + ">"), "</" + Qe + ">");
        });
        const we = this.props.a;
        we !== void 0 && we.forEach(function(je) {
          K("", G(je).b);
        });
        const Ae = this.props.b;
        Ae !== void 0 && Ae.forEach(function(je) {
          K(G(je).b, "");
        });
        const $e = this.props.en || this.props.ba;
        return $e !== void 0 && $e.forEach(function(je) {
          const Qe = G(je);
          K(Qe.b, Qe.a);
        }), I;
      }
      detokenize(I) {
        let B = "";
        const W = I.length - 1;
        if (W < 0)
          return B;
        for (let G = 0; G < W; G++) {
          const K = I[G];
          K.props.lier === !0 ? B += K.realization + "-" + this.check_for_t(I, G) : /[- ']$/.exec(K.realization) ? B += K.realization : K.realization.length > 0 && (B += K.realization + " ");
        }
        if (B += I[W].realization, this.parentConst == null && (this.isA("S", "root") || this.isA("coord") && this.dependents[0].isA("root")) && B.length > 0 && this.props.cap !== !1) {
          const G = this.sepWordRE().exec(B)[1].length;
          if (G < B.length && (B = B.substring(0, G) + B.charAt(G).toUpperCase() + B.substring(G + 1)), this.props.tag === void 0) {
            const K = /(.)( |(<[^>]+>))*$/.exec(B);
            K == null || "?!.:;/)]}".includes(K[1]) || (B += ". ");
          }
        }
        return B;
      }
      realize(I) {
        I !== void 0 && load(I);
        const B = this.real();
        return this.detokenize(B);
      }
      toString() {
        return I1.debug ? this.toSource() : this.realize();
      }
      indentSep(I, B) {
        return I >= 0 ? (I = I + this.constType.length + 1, B && this.peng !== void 0 && (this.peng.pengNO !== void 0 && (I += ("#" + this.peng.pengNO).length), this.taux && this.taux.tauxNO !== void 0 && (I += ("-" + this.taux.tauxNO).length)), [I, `,
` + " ".repeat(I)]) : [I, ","];
      }
      toSource() {
        return this.optSource;
      }
      toDebug() {
        return Object.keys(this.props).length > 0 ? JSON.stringify(this.props) : "";
      }
      warn(...I) {
        const B = this.warning(I);
        if (tt)
          throw B;
        return Array.isArray(ze) ? ze.push(B) : console.warn(B), this;
      }
    };
    Lo(g, "pengNO", 0), Lo(g, "tauxNO", 0), Lo(g, "debug", !1);
    let v = g;
    function k(Y, I, B, W) {
      v.prototype[Y] = function(G, K) {
        if (G === void 0 && I !== void 0 && !I.includes(""))
          return this.warn("no value for option", Y, I);
        if (W === void 0 && (W = Y), this.isA("CP") && !["cap", "lier", "pos"].includes(Y)) {
          K == null && this.addOptSource(W, G);
          for (let se = 0; se < this.elements.length; se++) {
            const he = this.elements[se];
            (B.length == 0 || he.isA(B)) && he[Y](G, !0);
          }
          return this;
        }
        if (this.isA("coord") && !["cap", "lier", "pos"].includes(Y)) {
          K == null && this.addOptSource(W, G);
          for (let se = 0; se < this.dependents.length; se++) {
            const he = this.dependents[se].terminal;
            (B.length == 0 || he.isA(B)) && he[Y](G, !0);
          }
          return this;
        }
        return B.length == 0 || this.isA(B) || this.isA(x) ? I === void 0 || I.includes(G) ? (I === void 0 && (G === void 0 ? G = !0 : G !== !0 && G !== !1 && (this.warn("ignored value for option", Y, G), G = !1)), this.setProp(W, G), K == null && this.addOptSource(Y, G ?? void 0), this) : this.warn("ignored value for option", Y, G) : w && this.isA("Q") ? this : this.warn("bad const for option", Y, this.constType, B);
      };
    }
    function S(Y) {
      v.prototype[Y] = function(I, B) {
        return this.props[Y] === void 0 && (this.props[Y] = []), this.props[Y].push(I), B == null && this.addOptSource(Y, I), this;
      };
    }
    function R(Y) {
      var I = ("" + Y).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
      return I ? Math.max(0, (I[1] ? I[1].length : 0) - (I[2] ? +I[2] : 0)) : 0;
    }
    function L(Y, I) {
      const B = I == "en", W = [{ sing: "mille", plur: "mille" }, { sing: "un million", plur: "millions" }, { sing: "un milliard", plur: "milliards" }, { sing: "un trillion", plur: "trillions" }, { sing: "un quatrillion", plur: "quatrillions" }, { sing: "un quintillion", plur: "quintillions" }], G = [{ sing: "one thousand", plur: "thousand" }, { sing: "one million", plur: "million" }, { sing: "one billion", plur: "billion" }, { sing: "one trillion", plur: "trillion" }, { sing: "one quatrillion", plur: "quatrillion" }, { sing: "one quintillion", plur: "quintillion" }];
      function K(Ae) {
        return Ae.length == 0 || Ae[0] == "000" && K(Ae.slice(1));
      }
      function se(Ae) {
        const $e = Ae[0], je = Ae[1];
        switch ($e) {
          case "0":
            return he(je);
          case "1":
            return (B ? ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"] : ["dix", "onze", "douze", "treize", "quatorze", "quinze", "seize", "dix-sept", "dix-huit", "dix-neuf"])[+je];
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
            var Qe = (B ? ["twenty", "thirty", "forty", "fifty", "sixty"] : ["vingt", "trente", "quarante", "cinquante", "soixante"])[$e - 2];
            return je == 0 ? Qe : Qe + (je == "1" ? B ? "-one" : " et un" : "-" + he(je));
          case "7":
            return je == 0 ? B ? "seventy" : "soixante-dix" : B ? "seventy-" + he(je) : "soixante" + (je == 1 ? " et " : "-") + se("1" + je);
          case "8":
            return je == 0 ? B ? "eighty" : "quatre-vingts" : (B ? "eighty-" : "quatre-vingt-") + he(je);
          case "9":
            return je == 0 ? B ? "ninety" : "quatre-vingt-dix" : B ? "ninety-" + he(je) : "quatre-vingt-" + se("1" + je);
        }
      }
      function he(Ae) {
        return (B ? ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"] : ["zro", "un", "deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf"])[+Ae];
      }
      if (typeof Y == "number" && (Y = "" + Y), !/^-?\d+$/.test(Y))
        throw "nombreChaineEnLettres ne traite que des chiffres:" + Y;
      let we = !1;
      if (Y[0] == "-" && (we = !0, Y = Y.slice(1)), Y.length > 21)
        throw "nombreChaineEnLettres ne traite que les nombres d'au plus 21 chiffres:" + Y;
      return (we ? B ? "minus " : "moins " : "") + function Ae($e) {
        const je = $e.length, Qe = $e[0];
        if (je == 1)
          return function(Rt) {
            if (Rt.length == 1)
              return he(Rt);
            if (Rt.length == 2)
              return se(Rt);
            const $t = Rt[0], Or = Rt.slice(1);
            if ($t == "0")
              return se(Or);
            const an = B ? "hundred" : "cent";
            return Or == "00" ? $t == "1" ? (B ? "one " : "") + an : he($t) + " " + an + (B ? "" : "s") : $t == "1" ? (B ? "one " : "") + an + " " + se(Or) : he($t) + " " + an + (B ? " and " : " ") + se(Or);
          }(Qe);
        const ut = $e.slice(1);
        if (Qe == "000")
          return Ae(ut);
        const st = B ? G : W;
        return (Qe == "001" ? st[je - 2].sing : Ae([Qe]) + " " + st[je - 2].plur) + " " + (K(ut) ? "" : Ae(ut));
      }(function Ae($e) {
        return $e.length > 3 ? Ae($e.slice(0, $e.length - 3)).concat([$e.slice($e.length - 3)]) : ($e.length == 1 ? $e = "00" + $e : $e.length == 2 && ($e = "0" + $e), [$e]);
      }(Y)).trim();
    }
    k("pe", [1, 2, 3, "1", "2", "3"], ["D", "Pro", "N", "NP", "A", "AP", "V", "VP", "S", "SP", "CP"]), k("n", ["s", "p", "x"], ["D", "Pro", "N", "NP", "A", "AP", "V", "VP", "S", "SP", "CP"]), k("g", ["m", "f", "n", "x"], ["D", "Pro", "N", "NP", "A", "AP", "V", "VP", "S", "SP", "CP"]), k("t", ["p", "i", "f", "ps", "c", "s", "si", "ip", "pr", "pp", "b", "b-to", "pc", "pq", "cp", "pa", "fa", "spa", "spq", "bp", "bp-to"], ["V", "VP", "S", "SP", "CP"]), k("aux", ["av", "t", "a"], ["V", "VP", "S", "SP", "CP"]), k("f", ["co", "su"], ["A", "Adv"]), k("tn", ["", "refl"], ["Pro"]), k("c", ["nom", "acc", "dat", "refl", "gen"], ["Pro"]), k("pos", ["post", "pre"], ["A", "Adv", ...x]), k("pro", void 0, ["NP", "PP"]), k("ow", ["s", "p", "x"], ["D", "Pro"], "own"), k("cap", void 0, []), k("lier", void 0, []), S("b"), S("a"), S("ba"), S("en");
    var F = { one: "first", two: "second", three: "third", five: "fifth", eight: "eighth", nine: "ninth", twelve: "twelfth" }, z = { un: "premier", une: "premire", cinq: "cinquime", neuf: "neuvime" };
    function j(Y) {
      function I(B, W, G, K) {
        switch (K) {
          case 0:
            return "";
          case 1:
            return B;
          case 2:
            return B + B;
          case 3:
            return B + B + B;
          case 4:
            return B + W;
          case 5:
            return W;
          case 6:
            return W + B;
          case 7:
            return W + B + B;
          case 8:
            return W + B + B + B;
          case 9:
            return B + G;
          case 10:
            return G;
        }
      }
      return Y < 0 ? "*too small*" : Y <= 10 ? I("I", "V", "X", Y) : Y <= 100 ? I("X", "L", "C", Math.floor(Y / 10)) + j(Y % 10) : Y <= 1e3 ? I("C", "D", "M", Math.floor(Y / 100)) + j(Y % 100) : Y < 4e3 ? "M".repeat(Math.floor(Y / 1e3)) + j(Y % 1e3) : "*too big*";
    }
    function ee(Y) {
      return typeof Y != "string" ? Y : Y.includes("'") ? Y.includes('"') ? '"' + Y.replace('"', '\\"') + '"' : '"' + Y + '"' : "'" + Y + "'";
    }
    const X = class b4 extends v {
      constructor(I, B) {
        if (super(B), I.length == 0 && B != "DT")
          return this.lang = lang || d(), this.setLemma("", B), void this.warn("bad number of parameters", B, 0);
        I.length == 1 ? (this.lang = d(), this.setLemma(I[0], B)) : I.length != 2 || I[1] != "en" && I[1] != "fr" ? (this.lang = d(), this.setLemma(I[0], B), B != "DT" && this.warn("bad number of parameters", B, I.length)) : (this.lang = I[1], this.setLemma(I[0], B));
      }
      me() {
        return this.constType + "(" + ee(this.lemma) + ")";
      }
      morphoError(I, B) {
        return this.warn("morphology error", I + ` :${this.me()} : ` + JSON.stringify(B)), this.realization = "[[" + this.lemma + "]]", this.constType = "Q", this;
      }
      add() {
        return this.warn("bad application", ".add", "Phrase", this.constType), this;
      }
      setLemma(I, B) {
        B == null && (B = this.constType), typeof I == "string" && (I = I.replace(//g, "oe").replace(//g, "ae")), this.lemma = I, this.peng === void 0 && this.initProps();
        var W = typeof I;
        switch (B) {
          case "DT":
            I == null ? this.date = /* @__PURE__ */ new Date() : W == "string" ? this.date = new Date(I) : I instanceof Date ? (this.date = I, this.lemma = I.toString()) : this.warn("bad parameter", "string, Date", W), this.props.dOpt = { year: !0, month: !0, date: !0, day: !0, hour: !0, minute: !0, second: !0, nat: !0, det: !0, rtime: !1 };
            break;
          case "NO":
            if (W != "string" && W != "number" && (this.warn("bad parameter", "string, number", W), this.lemma = this.value = I = 0), W == "string") {
              let se = b(this.lang)[I];
              if (se !== void 0 && se.value) {
                if (se.A) {
                  this.lemma = this.value = se.value, this.props.dOpt = { ord: !0 }, this.addOptSource("ord", !0);
                  break;
                }
                this.lemma = this.value = se.value, this.props.dOpt = { nat: !0 }, this.addOptSource("nat", !0);
                break;
              }
              /^[-+]?[0-9]+([., ][0-9]*)?([Ee][-+][0-9]+)?$/.test(I) ? (this.lemma = I = I.replace(this.thousand_seps(), ""), this.value = +I) : (this.warn("bad parameter", "number", W), this.lemma = this.value = 0);
            } else
              this.lemma = this.value = I;
            this.nbDecimals = R(I), this.props.dOpt = { mprecision: 2, raw: !1, nat: !1, ord: !1 };
            break;
          case "Q":
            this.lemma = typeof I == "string" ? I : JSON.stringify(I);
            break;
          case "N":
          case "A":
          case "Pro":
          case "D":
          case "V":
          case "Adv":
          case "C":
          case "P":
            if (W != "string")
              return this.tab = null, this.realization = `[[${I}]]`, this.warn("bad parameter", "string", W);
            let K = b(this.lang)[I];
            if (K == null)
              this.tab = null, this.realization = `[[${I}]]`, this.warn("not in lexicon", this.lang), w && (this.lemma = typeof I == "string" ? I : JSON.stringify(I), this.constType = "Q", this.realization = this.lemma);
            else if (K = K[B], K === void 0) {
              this.tab = null, this.realization = `[[${I}]]`;
              let se = Object.keys(b(this.lang)[I]), he = se.indexOf("basic");
              he >= 0 && se.splice(he, 1), this.warn("not in lexicon", this.lang, se), w && (this.lemma = typeof I == "string" ? I : JSON.stringify(I), this.constType = "Q", this.realization = this.lemma);
            } else {
              const se = Object.keys(K), he = m(this.lang);
              for (let we = 0; we < se.length; we++) {
                const Ae = se[we];
                if (Ae == "tab") {
                  var G;
                  if (this.tab = K.tab, B != "V") {
                    const $e = he.declension[this.tab];
                    if ($e !== void 0 && (G = $e.ending, B == "Pro")) {
                      const je = $e.declension, Qe = je[0].pe || 3;
                      if (Qe !== 3) {
                        let ut = 1;
                        for (; ut < je.length && je[ut].pe == Qe; )
                          ut++;
                        ut == je.length && this.setProp("pe", Qe);
                      }
                    }
                  } else {
                    const $e = he.conjugation[this.tab];
                    $e !== void 0 ? G = $e.ending : (G = "", this.warn("bad lexicon table", I, G));
                  }
                  I.endsWith(G) ? this.stem = I.substring(0, I.length - G.length) : (this.tab = null, this.isA("Adv", "C", "P") || this.warn("bad lexicon table", I, G));
                } else {
                  let $e = K[Ae];
                  this.setProp(Ae, $e, !0);
                }
              }
            }
            break;
          default:
            this.warn("not implemented", B);
        }
        return this;
      }
      grammaticalNumber() {
        return this.isA("NO") ? this.props.dOpt.ord == 1 ? "s" : null : this.warn("bad application", "grammaticalNumber", "NO", this.constType);
      }
      bestMatch(I, B, W) {
        let G = [];
        for (var K = 0; K < B.length; K++) {
          const he = B[K];
          let we = 0;
          for (let Ae in W)
            if (he[Ae] !== void 0) {
              const $e = W[Ae];
              if (Ae == "pe" && he[Ae] != $e) {
                we = 0;
                break;
              }
              he[Ae] == $e ? we += 2 : he[Ae] == "x" && (we += 1);
            }
          G.push([we, he.val]);
        }
        G.sort((he, we) => we[0] - he[0]);
        const se = G[0];
        return se[0] == 0 ? (this.morphoError(I, W), null) : se[1];
      }
      decline(I) {
        const B = m(this.lang);
        let W = B.declension[this.tab].declension, G = this.stem;
        if (this.isA("A", "Adv"))
          return this.decline_adj_adv(B, W, G);
        if (W.length == 1)
          this.realization = this.stem + W[0].val;
        else {
          let K = this.getProp("g");
          this.isA("D", "N") && K == null && (K = "m");
          let se = this.getProp("n");
          this.isA("D", "N") && se == null && (se = "s");
          let he = 3;
          if (I) {
            let Qe = this.getProp("pe");
            he = Qe === void 0 ? 3 : +Qe;
          }
          let we = I ? { pe: he, g: K, n: se } : { g: K, n: se };
          if (this.props.own !== void 0 && (we.own = this.props.own), this.isA("Pro")) {
            const Qe = this.props.c;
            Qe !== void 0 && (this.check_bad_pronoun_case(Qe) || (we.c = Qe));
            const ut = this.props.tn;
            if (ut !== void 0 && (Qe !== void 0 ? this.warn("both tonic and clitic") : we.tn = ut), Qe !== void 0 || ut !== void 0)
              if (this.lemma == this.tonic_pe_1())
                this.getProp("g") === void 0 && delete we.g, this.getProp("n") === void 0 && delete we.n, Qe != "nom" && ut != "" || this.getProp("pe") !== void 0 || (we.pe = 1, this.setProp("pe", 1));
              else {
                const st = W[0];
                this.should_set_person_number(Qe) && (this.setProp("g", st.g || K), this.setProp("n", st.n || se), this.setProp("pe", we.pe = st.pe || 3));
              }
            else
              this.lemma != "on" && (we.tn = "");
          }
          const Ae = this.declension_word(), $e = this.bestMatch(Ae, W, we);
          if ($e == null)
            return [this.morphoError(Ae, we)];
          const je = this.check_gender_lexicon(K, se);
          if (je != null)
            return je;
          this.realization = this.stem + $e;
        }
        return [this];
      }
      insertReal(I, B, W) {
        if (B instanceof b4)
          return B.parentConst = this.parentConst, B.realize(), W == null ? I.push(B) : I.splice(W, 0, B), I;
        this.warn("bad Constituent", ae(W + 1).dOpt({ ord: !0 }).realize(), typeof B);
      }
      isReflexive() {
        if (!this.isA("V"))
          return this.error("isReflexive() should be called only for a verb,  not a " + this.constType);
        const I = this.getProp("pat");
        if (I !== void 0 && I.length == 1 && I[0] == "rfl")
          return !0;
        let B = this.parentConst;
        for (; B != null; ) {
          if (B.isA("VP", "SP", "S") || B.isA(x) && B.terminal.isA("V")) {
            const W = B.props.typ;
            if (W !== void 0 && W.refl === !0)
              return !!I.includes("rfl") || (this.ignoreRefl = !0, b4.noIgnoredReflVerbs.has(this.lemma) || this.warn("ignored reflexive", I), !1);
            if (!B.isA("VP"))
              return !1;
          }
          B = B.parentConst;
        }
        return !1;
      }
      dateFormat(I, B) {
        const W = /(.*?)\[(.+?)\]|(.+$)/g, G = m(this.lang).date, K = G.format[B.nat ? "natural" : "non_natural"];
        function se(we) {
          if (we.length == 0)
            return "";
          let Ae = "", $e = K[we];
          B.det || ($e = $e.slice($e.indexOf("[")));
          for (const je of $e.matchAll(W))
            if (je[1] == null)
              Ae += je[3];
            else {
              const Qe = (ut) => (ut < 10 ? "0" : "") + ut;
              switch (Ae += je[1], je[2]) {
                case "Y":
                  Ae += I.getFullYear();
                  break;
                case "F":
                  Ae += G.text.month["" + (I.getMonth() + 1)];
                  break;
                case "M0":
                  Ae += Qe(I.getMonth() + 1);
                  break;
                case "M":
                  Ae += I.getMonth() + 1;
                  break;
                case "d0":
                  Ae += Qe(I.getDate());
                  break;
                case "d":
                  Ae += I.getDate();
                  break;
                case "l":
                  Ae += G.text.weekday["" + I.getDay()];
                  break;
                case "A":
                  Ae += G.text.meridiem[I.getHours() < 12 ? 0 : 1];
                  break;
                case "h":
                  Ae += I.getHours() % 12;
                  break;
                case "H0":
                  Ae += Qe(I.getHours());
                  break;
                case "H":
                  Ae += I.getHours();
                  break;
                case "m0":
                  Ae += Qe(I.getMinutes());
                  break;
                case "m":
                  Ae += I.getMinutes();
                  break;
                case "s0":
                  Ae += Qe(I.getSeconds());
                  break;
                case "s":
                  Ae += I.getSeconds();
                  break;
                default:
                  console.log("strange field:" + je[2]);
              }
            }
          return Ae;
        }
        let he;
        if (B.rtime) {
          const we = G.format.relative_time, Ae = B.rtime, $e = Math.ceil((I.getTime() - Ae.getTime()) / 864e5);
          Ae.setDate(Ae + $e), he = we["" + $e] !== void 0 ? we["" + $e].replace("[l]", G.text.weekday[I.getDay()]) : we[$e < 0 ? "-" : "+"].replace("[x]", Math.abs($e));
        } else
          he = se(["year", "month", "date", "day"].filter((we) => B[we] == 1).join("-"));
        return [he, se(["hour", "minute", "second"].filter((we) => B[we] == 1).join(":"))].filter((we) => we.length > 0).join(" ");
      }
      real() {
        switch (this.constType) {
          case "N":
          case "A":
            if (this.tab !== null)
              return this.doFormat(this.decline(!1));
            break;
          case "Adv":
            if (this.tab !== null)
              return this.doFormat(this.decline(!1));
            this.realization === null && (this.realization = this.lemma);
            break;
          case "C":
          case "P":
          case "Q":
            this.realization === null && (this.realization = this.lemma);
            break;
          case "D":
          case "Pro":
            if (this.tab !== null)
              return this.doFormat(this.decline(!0));
            break;
          case "V":
            return this.doFormat(this.conjugate());
          case "DT":
            this.realization = this.dateFormat(this.date, this.getProp("dOpt"));
            break;
          case "NO":
            this.setProp("n", this.grammaticalNumber());
            const I = this.getProp("dOpt");
            I.nat == 1 ? this.realization = this.numberToWord(this.value, this.lang, this.peng.g) : I.ord == 1 ? (this.setProp("n", "s"), this.realization = this.numberToOrdinal(this.value, this.lang, this.peng.g)) : I.rom == 1 ? this.realization = this.numberToRoman(this.value) : I.raw == 0 ? this.realization = function(B, W, G) {
              let K = G === void 0 ? 2 : G;
              const se = m(W).number;
              return K = R(B) > K ? K : R(B), function(he, we, Ae, $e) {
                he = (he + "").replace(/[^0-9+\-Ee.]/g, "");
                var je = isFinite(+he) ? +he : 0, Qe = isFinite(+we) ? Math.abs(we) : 0, ut = $e === void 0 ? "" : $e, st = Ae === void 0 ? "." : Ae, Rt = "";
                return (Rt = (Qe ? function($t, Or) {
                  var an = Math.pow(10, Or);
                  return "" + (Math.round($t * an) / an).toFixed(Or);
                }(je, Qe) : "" + Math.round(je)).split("."))[0].length > 3 && (Rt[0] = Rt[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, ut)), (Rt[1] || "").length < Qe && (Rt[1] = Rt[1] || "", Rt[1] += new Array(Qe - Rt[1].length + 1).join("0")), Rt.join(st);
              }(B, K, se.symbol.decimal, se.symbol.group);
            }(this.value, this.lang, I.mprecision) : this.realization = this.value + "";
            break;
          default:
            this.error("Terminal.real:" + this.constType + ": not implemented");
        }
        return this.doFormat([this]);
      }
      numberToWord(I, B, W) {
        return parseInt(I) !== I ? (this.warn("bad number in word", I), I + "") : this.numberOne(W, I) ?? L(I, B);
      }
      numberToOrdinal(I, B, W) {
        return parseInt(I) !== I || I <= 0 ? (this.warn("bad ordinal", I), `[[${I}]]`) : function(G, K, se) {
          const he = K == "en";
          if ((G = L(G, K)) == "zro" || G == "zero")
            return G;
          const we = /(.*?)(\w+)$/.exec(G), Ae = we[2];
          return he ? Ae in F ? we[1] + F[Ae] : G.charAt(G.length - 1) == "y" ? G.substring(0, G.length - 1) + "ieth" : G + "th" : G == "un" ? se == "f" ? "premire" : "premier" : G.endsWith("et un") ? G + "ime" : Ae in z ? we[1] + z[Ae] : G.charAt(G.length - 1) == "e" || G.endsWith("quatre-vingts") ? G.substring(0, G.length - 1) + "ime" : G + "ime";
        }(I, B, W);
      }
      numberToRoman(I) {
        return parseInt(I) !== I || I <= 0 || I >= 4e3 ? (this.warn("bad roman", I), `[[${I}]]`) : j(I);
      }
      toSource() {
        return this.constType + "(" + ee(this.lemma) + ")" + super.toSource();
      }
      toDebug() {
        let I = this.constType + "(" + ee(this.lemma) + ")";
        return this.peng !== void 0 && (this.peng.pengNO !== void 0 && (I += "#" + this.peng.pengNO), this.peng.tauxNO !== void 0 && (I += "-" + this.peng.tauxNO)), I + super.toDebug();
      }
    };
    Lo(X, "noIgnoredReflVerbs", /* @__PURE__ */ new Set(["avoir", "tre", "pouvoir", "devoir", "vouloir"]));
    let ie = X;
    const ce = (Y) => class extends Y {
      lang() {
        return "en";
      }
      isEn() {
        return !0;
      }
      isFr() {
        return !1;
      }
      defaultProps() {
        return { g: "n", n: "s", pe: 3, t: "p" };
      }
      tonic_forms() {
        return ["us", "her", "you", "him", "them", "it"];
      }
      tonic_pe_1() {
        return "me";
      }
      relative_pronouns() {
        return ["that", "who", "which"];
      }
      validate_neg_option(I, B) {
        return !1;
      }
      sepWordRE() {
        return /((?:[^<\w'-]*(?:<[^>]+>)?)*)([\w'-]+)?(.*)/;
      }
      doElision(I) {
        const B = /^(heir|herb|honest|honou?r(able)?|hour)/i, W = /^(uni.*|ub.*|use.*|usu.*|uv.*)/i, G = /^[A-Z]+$/, K = { "are+not": "aren't", "can+not": "can't", "did+not": "didn't", "do+not": "don't", "does+not": "doesn't", "had+not": "hadn't", "has+not": "hasn't", "have+not": "haven't", "is+not": "isn't", "must+not": "mustn't", "need+not": "needn't", "should+not": "shouldn't", "was+not": "wasn't", "were+not": "weren't", "will+not": "won't", "would+not": "wouldn't", "could+not": "couldn't", "let+us": "let's", "I+am": "I'm", "I+will": "I'll", "I+have": "I've", "I+had": "I'd", "I+would": "I'd", "she+will": "she'll", "he+is": "he's", "he+has": "he's", "she+had": "she'd", "she+would": "she'd", "he+will": "he'll", "she+is": "she's", "she+has": "she's", "he+would": "he'd", "he+had": "he'd", "you+are": "you're", "you+will": "you'll", "you+would": "you'd", "you+had": "you'd", "you+have": "you've", "we+are": "we're", "we+will": "we'll", "we+had": "we'd", "we+would": "we'd", "we+have": "we've", "they+will": "they'll", "they+are": "they're", "they+had": "they'd", "they+would": "they'd", "they+have": "they've", "it+is": "it's", "it+will": "it'll", "it+had": "it'd", "it+would": "it'd", "there+will": "there'll", "there+is": "there's", "there+has": "there's", "there+have": "there've", "that+is": "that's", "that+had": "that'd", "that+would": "that'd", "that+will": "that'll", "what+is": "what's" };
        var se = I.length - 1;
        if (se != 0)
          for (var he = 0; he < se; he++) {
            var we = this.sepWordRE().exec(I[he].realization);
            if (we !== void 0 && we[2] !== void 0) {
              var Ae = this.sepWordRE().exec(I[he + 1].realization);
              if (Ae !== void 0 && Ae[2] !== void 0) {
                var $e = we[2], je = Ae[2];
                if ($e != "a" && $e != "A" || !I[he].isA("D")) {
                  if (this.contraction !== void 0 && this.contraction === !0)
                    if ($e == "cannot")
                      I[he].realization = we[1] + "can't" + we[3];
                    else {
                      const Qe = K[$e + "+" + je];
                      Qe != null && (I[he].realization = we[1] + Qe + we[3], I[he + 1].realization = Ae[1] + Ae[3].trim(), he++);
                    }
                } else
                  (/^[ai]/i.exec(je) || /^e/i.exec(je) && !/^eu/i.exec(je) || /^o/i.exec(je) && !/^onc?e/.exec(je) || /^u/i.exec(je) && !W.exec(je) || B.exec(je) || G.exec(je)) && (I[he].realization = we[1] + $e + "n" + we[3], he++);
              }
            }
          }
      }
      check_for_t(I, B) {
        return "";
      }
      warning(I) {
        function B(K) {
          return Array.isArray(K) || (K = [K]), tr.apply(null, [C("or")].concat(K.map((se) => pe(se)))).realize();
        }
        const W = { "bad parameter": (K, se) => ot(dt(ge("the"), it("parameter")), rt(be("be").t("c"), pe(K).a(","), pe("not"), pe(se))).typ({ mod: "nece" }), "bad application": (K, se, he) => ot(pe(K), rt(be("apply").t("c"), Xt($("to"), B(se)).a(","), pe("not"), Xt($("to"), pe(he)))).typ({ mod: "nece", pas: !0 }), "bad position": (K, se) => ot(pe(K), rt(be("be").t("c"), kt("small").f("co"), C("than"), pe(se))).typ({ mod: "nece" }), "bad const for option": (K, se, he) => tr(C("but"), rt(be("apply"), dt(ge("the"), it("option"), pe(K)), Xt($("to"), pe(se))).typ({ pas: !0 }).a(","), Nr(rt(be("be").t("c"), Xt($("to"), B(he)))).typ({ mod: "nece" })), "ignored value for option": (K, se) => ot(pe(se).a(":"), rt(be("ignore"), dt(ge("this"), kt("bad").pos("pre"), it("value"), Xt($("for"), it("option"), pe(K)))).typ({ pas: !0 })), "unknown type": (K, se) => ot(dt(kt("illegal"), it("type"), pe(K).b(":")).a(","), rt(be("be").t("c"), B(se)).typ({ mod: "nece" })), "no value for option": (K, se) => ot(dt(ge("no"), it("value"), Xt($("for"), it("option"), pe(K))), rt(be("be"), Xt($("among"), pe(se)))).typ({ mod: "nece" }), "not found": (K, se) => ot(zt(ge("no"), pe(K)), rt(be("find").t("pp"), Xt($("in"), pe(se)))), "bad ordinal": (K) => ot(rt(be("realize"), pe(K), zt(Je("as"), ge("a"), it("ordinal")))).typ({ neg: !0, mod: "poss" }), "bad roman": (K) => ot(rt(be("realize"), pe(K), zt(Je("as"), dt(ge("a"), kt("Roman"), it("number"))))).typ({ neg: !0, mod: "poss" }), "bad number in word": (K) => ot(rt(be("realize"), pe(K), Xt($("in"), it("word").n("p")))).typ({ neg: !0, mod: "poss" }), "no French contraction": () => ot(rt(be("ignore"), dt(it("contraction")), Xt($("in"), it("French")))).typ({ pas: !0 }), "morphology error": (K) => ot(dt(it("error"), Xt($("within"), dt(ge("the"), it("morphology")))).a(":"), pe(K)), "not implemented": (K) => ot(pe(K), rt(be("implement"))).typ({ neg: !0, pas: !0 }), "not in lexicon": (K, se) => ot(Je("not"), be("find").t("pp"), Xt($("within"), ge("the"), kt(K == "en" ? "English" : "French"), it("lexicon")), se !== void 0 ? zt(Je("but"), be("exist"), Je("as"), B(se)) : pe("")), "no appropriate pronoun": () => ot(rt(be("find"), dt(ge("a"), kt("appropriate"), it("pronoun")))).typ({ neg: !0, pas: !0, mod: "poss" }), "both tonic and clitic": () => ot(tr(C("and"), pe("tn(..)"), pe("c(..)")), rt(be("use").n("p"), Je("together")).typ({ neg: !0, pas: !0, mod: "poss" }).a(","), pe("tn(..)"), rt(be("ignore")).typ({ pas: !0 })), "bad Constituent": (K, se) => ot(dt(ge("the"), it("parameter"), pe(K)), rt(be("be"), pe("Constituent"), Je("but"), pe(se))).typ({ neg: !0 }), "bad Dependent": (K, se) => ot(dt(ge("the"), it("parameter"), pe(K)), rt(be("be"), pe("Dependent"), Je("but"), pe(se))).typ({ neg: !0 }), "Dependent needs Terminal": (K) => ot(dt(ge("the"), ae(1).dOpt({ ord: !0 }), it("parameter"), Xt($("of"), pe("Dependent"))), rt(be("be"), pe("Terminal"), Je("but"), pe(K))).typ({ neg: !0 }), "bad number of parameters": (K, se) => ot(pe(K), rt(be("accept"), dt(ge("a"), kt("single"), it("parameter"))).a(","), Nr(C("but"), Ze("I"), rt(rt(be("have"), ae(se))))), "Dependent without params": () => ot(pe("Dependent"), Xt($("without"), it("parameter"))), "bad lexicon table": (K, se) => ot(dt(it("error"), Xt($("within"), dt(ge("the"), it("lexicon")))).a(":"), Nr(pe(K), rt(be("end"), Xt($("with"), pe(se)))).typ({ neg: !0 })), "bad language": (K) => ot(dt(it("language")), rt(be("be"), tr(C("or"), pe('"en"'), pe('"fr"')).a(","), pe("not"), pe(K).en('"'))).typ({ mod: "obli" }), "ignored reflexive": (K) => ot(rt(be("be"), kt("reflexive")).typ({ mod: "poss", neg: !0 }).a(","), K.length > 0 ? zt(Je("only"), B(K)) : void 0), "inconsistent dependents within a coord": (K, se) => ot(pe(K), rt(be("expect").t("pp"), Xt($("within"), dt(ge("this"), pe("coord")))), Nr(C("but"), pe(se), be("be").t("ps"), be("find").t("pp"))), "user-warning": (K) => ot(pe(typeof K == "string" ? K : K.realize())) }[I.shift()];
        let G = W.apply(null, I).cap(!1);
        return W === void 0 && this.error("warn called with an unknown error message:" + arguments[0]), this.me() + ":: " + G.realize();
      }
    }, ke = (Y) => class extends ce(Y) {
      thousand_seps() {
        return /,/g;
      }
      grammaticalNumber() {
        return super.grammaticalNumber() ?? (Math.abs(this.value) == 1 && this.nbDecimals == 0 ? "s" : "p");
      }
      decline_adj_adv(I, B, W) {
        this.realization = this.lemma;
        const G = this.getProp("f");
        if (G !== void 0 && G !== !1) {
          if (this.tab == "a1") {
            const K = Je(G == "co" ? "more" : "most");
            return K.realization = K.lemma, [K, this];
          }
          {
            if (this.tab == "b1") {
              const se = b(this.lang)[this.lemma].A;
              if (se === void 0)
                return [this];
              {
                B = I.declension[se.tab].declension;
                const he = I.declension[se.tab].ending;
                W = W.slice(0, W.length - he.length);
              }
            }
            const K = this.bestMatch("adjective declension", B, { f: G });
            return K == null ? [this.morphoError("decline [en]:A", { f: G })] : (this.realization = W + K, [this]);
          }
        }
        return [this];
      }
      check_bad_pronoun_case(I) {
        return I == "refl" && (this.warn("ignored value for option", "c", I), !0);
      }
      should_set_person_number(I) {
        return I != "gen";
      }
      tonic_forms() {
        return ["us", "her", "you", "him", "them", "it"];
      }
      declension_word() {
        return "declension";
      }
      check_gender_lexicon(I, B) {
        return null;
      }
      conjugate() {
        let I = +this.getProp("pe") || 3;
        const B = this.getProp("n"), W = (this.getProp("g"), this.getProp("t"));
        if (this.tab == null)
          return [this.morphoError("conjugate_en:tab", { pe: I, n: B, t: W })];
        const G = W == "s" ? "p" : W == "si" ? "ps" : W, K = m(this.lang).conjugation[this.tab].t[G];
        let se = [this];
        if (K !== void 0)
          switch (W) {
            case "p":
            case "ps":
            case "s":
            case "si":
              if (typeof K == "string")
                this.realization = this.stem + K;
              else {
                let he = K[I - 1 + (B == "p" ? 3 : 0)];
                if (he == null)
                  return [this.morphoError("conjugate_en:pe", { pe: I, n: B, t: W })];
                W == "s" && I == 3 && (he = K[0]), this.realization = this.stem + he;
              }
              break;
            case "b":
            case "pp":
            case "pr":
              this.realization = this.stem + K;
          }
        else if (W == "f")
          this.realization = this.lemma, this.insertReal(se, be("will"), 0);
        else if (W == "c")
          this.realization = this.lemma, this.insertReal(se, be("will").t("ps"), 0);
        else if (W == "bp" || W == "bp-to") {
          const he = m(this.lang).conjugation[this.tab].t.pp;
          this.realization = he !== void 0 ? this.stem + he : this.lemma, this.insertReal(se, be("have").t("b"), 0), W == "bp-to" && this.insertReal(se, P("to"), 0);
        } else if (W == "b-to")
          this.realization = this.lemma, this.insertReal(se, P("to"), 0);
        else {
          if (W != "ip")
            return [this.morphoError("conjugate_en: unrecognized tense", { pe: I, n: B, t: W })];
          this.realization = this.lemma, I == 1 && B == "p" && this.insertReal(se, Q("let's"), 0);
        }
        return se;
      }
      numberOne(I, B) {
        return null;
      }
    }, ye = { can: "cannot", may: "may not", shall: "shall not", will: "will not", must: "must not", could: "could not", might: "might not", should: "should not", would: "would not" }, Ce = (Y) => class extends Y {
      word_last() {
        return "last";
      }
      adj_def_pos() {
        return "pre";
      }
      passive_pronoun_subject(I) {
        return I.lemma == "I" ? Ze("me").tn("").g(I.getProp("g")).n(I.getProp("n")).pe(I.getProp("pe")) : I.getTonicPro();
      }
      passive_dummy_subject() {
        return "it";
      }
      passive_context() {
        return "passive context";
      }
      passive_should_link_subject() {
        return !0;
      }
      passive_prep(I) {
        return I ? "to" : "by";
      }
      passive_human_object(I, B) {
        return I == "wod" && B !== void 0 && ["m", "f"].includes(B.getProp("g"));
      }
      should_add_interrogative_prefix(I) {
        return I != "yon";
      }
      and_conj() {
        return "and";
      }
      prepositionsList() {
        return { all: /* @__PURE__ */ new Set(["about", "above", "across", "after", "against", "along", "alongside", "amid", "among", "amongst", "around", "as", "at", "back", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "by", "concerning", "considering", "despite", "down", "during", "except", "for", "from", "in", "inside", "into", "less", "like", "minus", "near", "next", "of", "off", "on", "onto", "outside", "over", "past", "per", "plus", "round", "since", "than", "through", "throughout", "till", "to", "toward", "towards", "under", "underneath", "unlike", "until", "up", "upon", "versus", "with", "within", "without"]), whe: /* @__PURE__ */ new Set(["above", "across", "along", "alongside", "amid", "around", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "in", "inside", "into", "near", "next", "onto", "outside", "over", "past", "toward", "towards", "under", "underneath", "until", "via", "within"]), whn: /* @__PURE__ */ new Set(["after", "before", "during", "since", "till"]) };
      }
      affixHopping(I, B, W, G) {
        const K = I.peng, se = G.neg === !0;
        let he = [], we = [], Ae = !1;
        B != "f" && B != "c" || (Ae = !0, B = B == "f" ? "p" : "ps");
        const $e = G.prog !== void 0 && G.prog !== !1, je = G.perf !== void 0 && G.perf !== !1, Qe = G.pas !== void 0 && G.pas !== !1, ut = G.int, st = G.mod;
        st !== void 0 && st !== !1 ? (he.push(W[st].aux), we.push("b")) : Ae && (he.push(W.future.aux), we.push("b")), je || $e || Qe ? (je && (he.push(W.perfect.aux), we.push(W.perfect.participle)), $e && (he.push(W.continuous.aux), we.push(W.continuous.participle)), Qe && (he.push(W.passive.aux), we.push(W.passive.participle))) : ut !== void 0 && ut !== !1 && he.length == 0 && I.lemma != "be" && I.lemma != "have" && ut != "wos" && ut != "was" && ut != "tag" && (["pp", "pr", "b-to"].includes(B) || (he.push("do"), we.push("b"))), he.push(I.lemma);
        const Rt = he.shift();
        let $t = [];
        if (se)
          ["pp", "pr", "b", "b-to", "bp", "bp-to"].includes(B) ? ($t.push(Je("not", "en")), B != "b" && B != "bp" || $t.push($("to", "en")), $t.push(be(Rt, "en").t(B))) : B == "ip" && K.pe == 1 && K.n == "p" ? ($t.push(pe("let's")), $t.push(Je("not", "en")), $t.push(be(Rt, "en").t("b"))) : Rt in ye ? Rt == "can" && B == "p" ? $t.push(pe("cannot")) : ($t.push(be(Rt, "en").t(B)), $t.push(Je("not", "en"))) : Rt == "be" || Rt == "have" && I.lemma != "have" ? ($t.push(be(Rt).t(B)), $t.push(Je("not", "en"))) : ($t.push(be("do", "en").t(B)), $t.push(Je("not", "en")), Rt != "do" && $t.push(be(Rt).t("b")));
        else {
          let Or = be(Rt).t(B);
          I.lemma in ye && Or.pe(1), $t.push(Or);
        }
        for ($t[0].peng = K; he.length > 0; ) {
          const Or = he.shift();
          $t.push(be(Or).t(we.shift()));
        }
        return G.refl === !0 && B != "pp" && $t.push(Ze("myself", "en").pe(I.getProp("pe")).n(I.getProp("n")).g(I.getProp("g"))), $t;
      }
      checkAdverbPos(I) {
        function B(we, Ae, $e) {
          I.splice($e, 0, ...I.splice(we, Ae));
        }
        const W = this.relative_pronouns();
        let G = I.length - 1;
        for (; G >= 0 && (!I[G].isA("Pro") || !W.includes(I[G].lemma)); )
          G--;
        G++;
        const K = I.map((we, Ae) => Ae >= G && we.isA("Adv") && we.lemma != "not" ? Ae : -1).filter((we) => we != -1);
        if (K.length == 0)
          return;
        const se = K[0], he = I[se];
        for (let we = 1; we < K.length; we++)
          K[we] != K[we - 1] + 1 && K.splice(we, K.length - we);
        se >= G + 2 && he.props.pos === void 0 && function(we) {
          for (let Ae = 0; Ae < se - 1; Ae++) {
            const $e = I[Ae];
            if ($e.isA("V") && we.includes($e.lemma)) {
              if (I[Ae + 1].isA("V")) {
                if (($e.lemma == "will" || $e.lemma == "shall") && $e.parentConst !== null && $e.parentConst.getProp("t") == "f")
                  continue;
                B(se, K.length, Ae + 1);
              } else
                I[Ae + 1].lemma == "not" && I[Ae + 2].isA("V") && B(se, K.length, Ae + 2);
              break;
            }
          }
        }(["have", "can", "will", "shall", "may", "must"]);
      }
      doPronounPlacement() {
      }
    };
    class Ie extends v {
      constructor(I, B, W) {
        if (super(B), this.lang = W || d(), I = oe(I), this.elements = [], this.elementsSource = [], I.length > 0) {
          const G = I.length - 1;
          for (let K = 0; K < G; K++) {
            let se = I[K];
            typeof se == "string" && (se = pe(se)), se instanceof ie || se instanceof Ie ? (this.addElement(se), this.elementsSource.push(se)) : this.warn("bad Constituent", ae(K + 1).dOpt({ ord: !0 }).realize(), typeof se + ":" + JSON.stringify(se));
          }
          this.add(I[G], void 0, !0);
        }
      }
      addElement(I, B) {
        return I instanceof ie || I instanceof Ie ? (I.parentConst = this, B == null ? this.elements.push(I) : typeof B == "number" && B <= this.elements.length && B >= 0 ? this.elements.splice(B, 0, I) : this.warn("bad position", B, this.elements.length)) : this.warn("bad Constituent", ae(B + 1).dOpt({ ord: !0 }).realize(), typeof I), this;
      }
      removeElement(I) {
        if (typeof I == "number" && I < this.elements.length && I >= 0) {
          const B = this.elements.splice(I, 1)[0];
          return B.parentConst = null, B;
        }
        return this.warn("bad position", I, this.elements.length);
      }
      add(I, B, W) {
        function G(K, se, he) {
          se > he && ([he, se] = [se, he]);
          for (var we = se; we <= he; we++)
            if (!K[we].isA("A", "N"))
              return !1;
          return !0;
        }
        if (I === null)
          return this;
        if (typeof I == "string" && (I = pe(I)), !(I instanceof v))
          return this.warn("bad Constituent", this.word_last(), typeof I + ":" + JSON.stringify(I));
        W === void 0 ? this.optSource += ".add(" + I.toSource() + (B === void 0 ? "" : "," + B) + ")" : this.elementsSource.push(I), this.addElement(I, B), this.linkProperties();
        for (let K = 0; K < this.elements.length; K++) {
          const se = this.elements[K];
          if (se.isA("A")) {
            const he = this.getIndex("N");
            if (he >= 0) {
              const we = se.props.pos || this.adj_def_pos();
              (we == "pre" && K > he || we == "post" && K < he) && G(this.elements, K, he) && this.addElement(this.removeElement(K), he);
            }
          } else if (se.isA("Adv") && se.props.pos !== void 0) {
            const he = this.getIndex("V");
            if (he >= 0) {
              const we = se.props.pos;
              (we == "pre" && K > he || we == "post" && K < he) && this.addElement(this.removeElement(K), he);
            }
          }
        }
        return this;
      }
      grammaticalNumber() {
        return this.error("grammaticalNumber must be called on a NO, not a " + this.constType);
      }
      getHeadIndex(I) {
        let B = I.substring(0, I.length - 1), W = this.getIndex([I, B]);
        return W < 0 && (W = 0), W;
      }
      linkProperties() {
        let I;
        if (this.elements.length == 0)
          return this;
        switch (this.constType) {
          case "NP":
            I = this.getHeadIndex("NP"), this.peng = this.elements[I].peng;
            for (let K = 0; K < this.elements.length; K++)
              if (K != I) {
                const se = this.elements[K];
                if (this.peng) {
                  if (se.isA("NO") && K < I)
                    this.peng.n = se.grammaticalNumber(), se.peng.g = this.peng.g;
                  else if (se.isA("D", "A", "V"))
                    this.link_DAV_properties(se);
                  else if (se.isA("CP")) {
                    const he = this;
                    se.elements.forEach(function(we) {
                      we.isA("A", "NO") && (we.peng = he.peng);
                    });
                  }
                }
              }
            const B = this.getFromPath([["S", "SP"], "Pro"]);
            if (B !== void 0) {
              const K = B.parentConst.getFromPath(["VP", "V"]);
              K != null && this.link_subj_obj_subordinate(B, K);
            }
            break;
          case "VP":
            I = this.getHeadIndex("VP"), this.peng = this.elements[I].peng, this.taux = this.elements[I].taux;
            break;
          case "AdvP":
          case "PP":
          case "AP":
            I = this.getHeadIndex(this.constType), this.peng = this.elements[I].peng;
            break;
          case "CP":
            this.peng = { pengNO: v.pengNO++ };
            break;
          case "S":
          case "SP":
            let W = this.getFromPath([["", "VP"], "V"]);
            if (W !== void 0 && (this.taux = W.taux, W.getProp("t") == "ip"))
              return this;
            let G = this.getIndex(["NP", "N", "CP", "Pro"]);
            if (G >= 0) {
              let K = this.elements[G];
              if (this.isA("SP") && K.isA("Pro") && ["que", "o", "that"].includes(K.lemma)) {
                const he = this.elements.slice(G + 1).findIndex((we) => we.isA("NP", "N", "CP", "Pro"));
                if (!(he >= 0))
                  return this;
                K = this.elements[G + 1 + he];
              }
              this.peng = K.peng;
              const se = this.linkPengWithSubject("VP", "V", K);
              se !== void 0 ? (this.taux = se.taux, this.linkAttributes(se, this.getFromPath([["VP"], ["CP"]]), K)) : (this.getFromPath(["CP", "VP"]) !== void 0 && this.getConst("CP").elements.forEach(function(he) {
                he instanceof Ie && he.linkPengWithSubject("VP", "V", K);
              }), this.check_coordinated_object());
            }
            break;
          default:
            this.error("linkProperties	,unimplemented type:" + this.constType);
        }
        return this;
      }
      linkPengWithSubject(I, B, W) {
        if (W.isA("Pro") && W.props.c == "gen")
          return;
        let G = this.getFromPath([I, B]);
        return G !== void 0 ? G.parentConst.peng = G.peng = W.peng : (G = this.getFromPath([B]), G !== void 0 && (G.peng = W.peng)), G;
      }
      me() {
        const I = this.elements.map(function(B) {
          return B.me();
        });
        return this.constType + "(" + I.join() + ")";
      }
      setLemma(I, B) {
        return this.error("***: should never happen: setLemma: called on a Phrase"), this;
      }
      getIndex(I) {
        return typeof I == "string" && (I = [I]), this.elements.findIndex((B) => B.isA(I), this);
      }
      getConst(I) {
        const B = this.getIndex(I);
        if (!(B < 0))
          return this.elements[B];
      }
      findGenderNumberPerson(I) {
        let B, W, G = 3, K = 0;
        for (let se = 0; se < this.elements.length; se++) {
          const he = this.elements[se];
          if (he.isA("NP", "N", "Pro", "Q", "NO")) {
            K += 1;
            const we = he.getProp("g");
            B === void 0 && we !== void 0 && (B = we), we == "m" && (B = "m"), he.getProp("n") == "p" && (W = "p");
            const Ae = he.getProp("pe");
            Ae !== void 0 && Ae < G && (G = Ae);
          }
        }
        return K > 1 && I && (W = "p"), { g: B, n: W, pe: G };
      }
      pronominalizeChildren() {
        for (let I of this.elements)
          I.props.pro !== !0 || I.isA("Pro") || I.pronominalize();
      }
      passivate() {
        let I, B, W;
        if (this.isA("VP"))
          I = null, B = this;
        else {
          if (B = this.getConst("VP"), B === void 0)
            return this.warn("not found", "VP", this.passive_context());
          this.elements.length > 0 && this.elements[0].isA("N", "NP", "Pro", "S") ? (I = this.removeElement(0), I.isA("Pro") && (I = this.passive_pronoun_subject(I))) : I = null;
        }
        if (B === void 0)
          return this.warn("not found", "VP", isFr() ? "contexte passif" : "passive context");
        {
          let G = B.getIndex(["NP", "Pro"]);
          if (G >= 0) {
            let K = B.removeElement(G);
            if (K.isA("Pro") ? (K = K.getTonicPro("nom"), G == 0 && (G = B.getIndex("V") + 1)) : K.isA("NP") && K.props.pro === !0 && (K = K.getTonicPro("nom")), W = K, this.addElement(W, 0), this.passive_should_link_subject() && this.linkPengWithSubject("VP", "V", W), I != null) {
              let se = this.passive_prep(I.isA("S"));
              B.addElement(Xt($(se, this.lang), I), G);
            }
          } else if (I != null) {
            W = Ze(this.passive_dummy_subject(), this.lang).c("nom"), this.addElement(W, 0), this.linkPengWithSubject("VP", "V", W), B.peng = W.peng;
            let K, se = B.getIndex("V"), he = this.passive_prep(I.isA("S"));
            K = I.isA("S") ? void 0 : se + 1, B.addElement(Xt($(he, this.lang), I), K);
          }
          this.passive_agree_auxiliary(B, W);
        }
      }
      processVP(I, B, W) {
        if (this.getFromPath(["CP", "VP"]) !== void 0)
          return void this.getConst("CP").elements.forEach(function(K) {
            K.isA("VP") && K.processVP(I, B, W);
          });
        const G = I[B];
        if (G !== void 0 && G !== !1) {
          let K;
          if (this.isA("VP"))
            K = this;
          else {
            const he = this.getIndex(["VP"]);
            if (!(he >= 0))
              return void this.warn("bad const for option", '.typ("' + B + ":" + G + '")', this.constType, ["VP"]);
            K = this.elements[he];
          }
          const se = K.getIndex("V");
          if (se >= 0) {
            const he = K.elements[se];
            W(K, se, he, G);
          }
        }
      }
      getIdxCtx(I, B) {
        if (this.isA(I)) {
          var W = this.getIndex(B);
          if (W >= 0)
            return [W, this.elements];
        } else if (this.isA("S", "SP")) {
          var G = this.getConst(I);
          if (G !== void 0)
            return G.getIdxCtx(I, B);
        }
        return [void 0, void 0];
      }
      moveAuxToFront() {
        if (this.isEn() && this.isA("S", "SP")) {
          let [I, B] = this.getIdxCtx("VP", "V");
          if (I !== void 0 && !["pp", "pr", "b-to"].includes(this.getProp("t"))) {
            const W = B[0].parentConst.removeElement(0);
            this.addElement(W, 0);
          }
        }
      }
      invertSubject() {
        const I = this.getIndex(["NP", "N", "Pro", "SP", "CP"]);
        if (I >= 0) {
          const B = this.elements[I];
          let W;
          if (B.isA("Pro")) {
            if (B.getProp("pe") == 1 && B.getProp("n") == "s")
              return void this.add(pe("est-ce que"), I);
            W = this.removeElement(I);
          } else
            B.isA("CP") ? (W = Ze("moi", "fr").c("nom").g("m").n("p").pe(3), B.pronoun = W) : W = Ze("moi", "fr").g(B.getProp("g")).n(B.getProp("n")).pe(3).c("nom");
          let [G, K] = this.getIdxCtx("VP", "V");
          if (G !== void 0) {
            let se = K[G];
            se.parentConst.addElement(W, G + 1), se.lier();
          }
        }
      }
      processInt(I) {
        const B = I.int, W = m(this.lang).sentence_type.int, G = W.prefix;
        let K, se;
        switch (B) {
          case "yon":
          case "how":
          case "why":
          case "muc":
            this.isEn() ? this.moveAuxToFront() : this.invertSubject(), K = G[B];
            break;
          case "wos":
          case "was":
            if (this.isA("S", "SP", "VP")) {
              const he = this.getIndex(["NP", "N", "Pro", "SP"]);
              if (he !== void 0) {
                const we = this.getIndex(["VP", "V"]);
                we !== void 0 && he < we && (this.elements[we].setProp("pe", 3), this.removeElement(he));
              }
            }
            K = G[B];
            break;
          case "wod":
          case "wad":
            if (this.isA("S", "SP", "VP")) {
              let he;
              const [we, Ae] = this.getIdxCtx("VP", ["NP", "N", "Pro", "SP"]);
              we !== void 0 && (he = Ae[0].parentConst.removeElement(we)[se] = this.passive_subject_par(he, se)), K = this.passive_human_object(he, se) ? "whom" : G[B], this.isEn() ? this.moveAuxToFront() : this.invertSubject();
            }
            break;
          case "woi":
          case "wai":
          case "whe":
          case "whn":
            if (this.isA("S", "SP", "VP")) {
              const [he, we] = this.getIdxCtx("VP", "PP");
              if (K = G[B], he !== void 0) {
                let Ae = we[he].elements[0];
                if (Ae.isA("P")) {
                  Ae = Ae.lemma;
                  const $e = this.prepositionsList();
                  B == "whe" ? $e.whe.has(Ae) && we[0].parentConst.removeElement(he) : B == "whn" ? $e.whn.has(Ae) && we[0].parentConst.removeElement(he) : $e.all.has(Ae) && (this.interrogative_pronoun_woi(int_), we[0].parentConst.removeElement(he));
                }
              }
              this.isEn() ? this.moveAuxToFront() : this.invertSubject();
            }
            break;
          case "tag":
            this.isA("S", "SP", "VP") && (this.tag_question(I), K = G[B]);
            break;
          default:
            this.warn("not implemented", "int:" + B);
        }
        this.should_add_interrogative_prefix(B) && this.addElement(pe(K), 0), this.a(W.punctuation, !0);
      }
      processTyp(I) {
        I.pas !== void 0 && I.pas !== !1 && this.passivate(), this.processTyp_verb(I), "int" in I && I.int !== !1 && this.processInt(I);
        const B = I.exc;
        return B !== void 0 && B === !0 && this.a(m(this.lang).sentence_type.exc.punctuation, !0), this;
      }
      cpReal() {
        var I = [];
        let B = this.getIndex("C");
        B < 0 && this.elements[0].isA("Q") && (B = 0);
        const W = this.elements.filter(function(we, Ae) {
          return Ae != B;
        });
        var G = W.length - 1;
        if (G == -1)
          return [];
        if (G == 0)
          return Array.prototype.push.apply(I, W[0].real()), this.setProp("g", W[0].getProp("g")), this.setProp("n", W[0].getProp("n")), this.setProp("pe", W[0].getProp("pe") || 3), this.doFormat(I);
        for (let we = 0; we < G; we++) {
          const Ae = W[we];
          (B < 0 || we < G - 1) && (Ae.props.a !== void 0 && Ae.props.a.includes(",") || (Ae.props.a = [","])), Array.prototype.push.apply(I, Ae.real());
        }
        let K;
        if (B >= 0 && Array.prototype.push.apply(I, this.elements[B].real()), Array.prototype.push.apply(I, W[G].real()), B >= 0) {
          K = this.elements[B];
          var se = this.and_conj(), he = this.findGenderNumberPerson(K.lemma == se);
          he.g !== void 0 && this.setProp("g", he.g), he.n !== void 0 && this.setProp("n", he.n), this.setProp("pe", he.pe), this.pronoun !== void 0 && (this.pronoun.peng = he, this.pronoun.props.g = he.g, this.pronoun.props.n = he.n, this.pronoun.props.pe = he.pe);
        }
        return this.doFormat(I);
      }
      vpReal() {
        var I = [];
        function B(he) {
          return he.map((we) => we.lemma.length).reduce((we, Ae) => we + Ae, 0) + he.length;
        }
        this.pronominalizeChildren();
        const W = this.elements.length - 1;
        for (var G = W; G >= 0 && !this.elements[G].isA("V"); )
          G--;
        (G < 0 || this.elements[G].getProp("t") == "pp" || ["tre", "be"].includes(this.elements[G].lemma)) && (G = W);
        let K = 0;
        for (; K <= G; )
          Array.prototype.push.apply(I, this.elements[K].real()), K++;
        if (K > W)
          return this.doFormat(I);
        let se = [];
        for (; K <= W; )
          se.push(this.elements[K].real()), K++;
        return se.sort(function(he, we) {
          const Ae = B(he), $e = B(we);
          return Math.min(Ae, $e) / Math.max(Ae, $e) > 0.75 ? 0 : Ae - $e;
        }), se.forEach((he) => Array.prototype.push.apply(I, he)), this.doFormat(I);
      }
      real() {
        let I = [];
        if (this.isA("CP"))
          return this.cpReal();
        {
          this.pronominalizeChildren();
          const W = this.props.typ;
          W !== void 0 && this.processTyp(W);
          const G = this.elements;
          for (let K of G) {
            var B;
            B = K.isA("CP") ? K.cpReal() : K.isA("VP") && E ? K.vpReal() : K.real(), Array.prototype.push.apply(I, B);
          }
          this.isA("VP") && I.length > 1 && this.checkAdverbPos(I);
        }
        return this.doFormat(I);
      }
      toSource(I) {
        I === void 0 && (I = -1);
        let [B, W] = this.indentSep(I), G = this.constType + "(" + this.elementsSource.map((K) => K.toSource(B)).join(W) + ")";
        return G += super.toSource(), G;
      }
      toDebug(I) {
        I === void 0 && (I = -1);
        let [B, W] = this.indentSep(I, !0), G = this.constType;
        return this.peng !== void 0 && (this.peng.pengNO !== void 0 && (G += "#" + this.peng.pengNO), this.taux && this.taux.tauxNO !== void 0 && (G += "-" + this.taux.tauxNO)), G += "(" + this.elements.map((K) => K.toDebug(B)).join(W) + ")", G += super.toSource(), G;
      }
    }
    const Te = (Y) => class extends ce(Y) {
      link_DAV_properties(I) {
        I.isA("D") && I.lemma == "no" ? this.peng.n = "p" : (this.isA("A") || I.isA("D") && I.getProp("own") === void 0) && (I.peng = this.peng);
      }
      link_subj_obj_subordinate(I, B) {
        ["who", "which", "that"].includes(I.lemma) && (B.peng = this.peng, this.linkAttributes(B, this.getFromPath([["VP"], ["CP"]]), this));
      }
      linkAttributes(I, B, W) {
      }
      check_coordinated_object() {
      }
      pronominalize() {
        if (!this.isA("NP"))
          return this.warn("bad application", ".pro", ["NP"], this.constType);
        const I = this.parentConst;
        let B;
        if (I !== null) {
          let W = this, G = I.elements.findIndex((K) => K == W, this);
          I.getIndex("V"), B = this.peng == I.peng || I.isA("SP") && I.elements[0].isA("Pro") ? this.getTonicPro("nom") : this.getTonicPro("acc"), B.peng = this.peng, Object.assign(B.props, this.props), this.peng == I.peng && (I.peng = B.peng), I.removeElement(G), I.addElement(B, G);
        } else
          B = this.getTonicPro("nom"), B.props = this.props, B.peng = this.peng, this.elements = [B];
        return B;
      }
      passive_agree_auxiliary(I, B) {
      }
      processTyp_verb(I) {
        let B;
        if (this.isA("VP"))
          B = this;
        else {
          const G = this.getIndex(["VP"]);
          if (!(G >= 0))
            return this.warn("bad const for option", ".typ(" + JSON.stringify(I) + ")", this.constType, ["VP"]);
          B = this.elements[G];
        }
        const W = B.getIndex("V");
        if (W >= 0) {
          I.contr !== void 0 && I.contr !== !1 && (B.contraction = !0, this.contraction = !0);
          const G = this.affixHopping(B.elements[W], B.getProp("t"), m(this.lang).compound, I);
          B.removeElement(W);
          for (let K = 0; K < G.length; K++)
            B.addElement(G[K], W + K);
        } else
          this.warn("not found", "V", "VP");
      }
      move_object(I) {
        if (this.isA("S", "SP")) {
          let [B, W] = this.getIdxCtx("VP", "V");
          if (B !== void 0 && !["pp", "pr", "b-to"].includes(this.getProp("t"))) {
            const G = W[0].parentConst.removeElement(0);
            this.addElement(G, 0);
          }
        }
      }
      passive_subject_par(I, B) {
        return [I, B];
      }
      interrogative_pronoun_woi(I) {
        return I == "woi" ? "whom" : "what";
      }
      tag_question(I) {
        let B;
        const W = this.getFromPath(["VP", "V"]);
        if (W !== void 0) {
          B = "mod" in I && I.mod !== !1 ? m(this.lang).compound[I.mod].aux : ["have", "be", "can", "will", "shall", "may", "must"].includes(W.lemma) ? W.lemma : "do";
          let G = "neg" in I && I.neg === !0, K = W.getProp("pe"), se = W.getProp("t"), he = W.getProp("n"), we = W.getProp("g"), Ae = Ze("I").pe(K).n(he).g(we);
          const $e = this.getIndex(["NP", "N", "Pro", "SP"]);
          if ($e >= 0) {
            const ut = this.getIndex(["VP", "V"]);
            if (ut >= 0 && $e < ut) {
              const st = this.elements[$e];
              st.isA("Pro") ? st.getProp("pe") != 1 || B != "be" || se != "p" || G ? ["this", "that", "nothing"].includes(st.lemma) ? Ae = Ze("I").g("n") : ["somebody", "anybody", "nobody", "everybody", "someone", "anyone", "everyone"].includes(st.lemma) ? (Ae = Ze("I").n("p"), st.lemma == "nobody" && (G = !0)) : Ae = st.clone() : K = 2 : (Ae = st.clone().pro(), Ae.g(st.getProp("g")).n(st.getProp("n")));
            }
          } else
            se == "ip" && (B == "do" && (B = "will"), Ae = Ze("I").pe(2).n(he).g(we));
          const je = W.parentConst.getConst("Adv");
          let Qe;
          je !== void 0 && ["hardly", "scarcely", "never", "seldom"].includes(je.lemma) && (G = !0), W.parentConst.a(","), Qe = B != "have" || G ? rt(be(B).t(se).pe(K).n(he), Ae).typ({ neg: !G, contr: !0 }) : rt(be("have").t(se).pe(K).n(he), Je("not"), Ae).typ({ contr: !0 }), Qe.peng = Ae.peng, this.addElement(Qe);
        }
      }
    };
    class ue extends v {
      constructor(I, B, W) {
        if (super(B), this.lang = W || d(), this.dependents = [], this.terminal = pe("*terminal*"), I.length == 0)
          return this.warn("Dependent without params"), null;
        if (typeof I[0] == "string" ? this.terminal = pe(I.shift()) : I[0] instanceof ie ? this.terminal = I.shift() : (this.warn("Dependent needs Terminal", I[0].constructor.name), I.shift()), this.terminal.parentConst = this, this.peng = this.terminal.peng, this.terminal.isA("V") && (this.taux = this.terminal.taux), I = oe(I), this.dependentsSource = [], I.length > 0) {
          const G = I.length - 1;
          for (let K = 0; K < G; K++) {
            let se = I[K];
            se instanceof ue ? (this.addDependent(se), this.dependentsSource.push(se)) : this.warn("bad Dependent", ae(K + 2).dOpt({ ord: !0 }).realize(), se.constructor.name + ":" + JSON.stringify(se));
          }
          this.add(I[G], void 0, !0);
        }
      }
      addDependent(I, B) {
        return I instanceof ue ? (I.parentConst = this, B == null ? this.dependents.push(I) : typeof B == "number" && B <= this.dependents.length && B >= 0 ? this.dependents.splice(B, 0, I) : this.warn("bad position", B, this.dependents.length)) : this.warn("bad Dependent", ae(B + 1).dOpt({ ord: !0 }).realize(), I.constructor.name), this;
      }
      removeDependent(I) {
        if (typeof I == "number" && I < this.dependents.length && I >= 0) {
          const B = this.dependents.splice(I, 1)[0];
          return B.parentConst = null, B;
        }
        return this.warn("bad position", I, this.dependents.length);
      }
      changeDeprel(I) {
        return this.isA("coord") ? this.dependents.forEach((B) => B.constType = I) : this.constType = I, this;
      }
      findIndex(I, B) {
        for (let W = B = B || 0; W < this.dependents.length; W++) {
          const G = this.dependents[W];
          if (G.isA("coord") && G.dependents.length > 0 && I(G.dependents[0]) || I(G))
            return W;
        }
        return -1;
      }
      add(I, B, W) {
        return I instanceof ue ? (W === void 0 ? this.optSource += ".add(" + I.toSource() + (B === void 0 ? "" : "," + B) + ")" : this.dependentsSource.push(I), this.addDependent(I, B), this.linkProperties(), this) : this.warn("bad Dependent", this.word_last(), I.constructor.name);
      }
      me() {
        let I = this.dependents.map(function(B) {
          return B.me();
        });
        return I.unshift(this.terminal.me()), this.constType + "(" + I.join() + ")";
      }
      setPengRecursive(I, B, W) {
        I.peng = W, I.terminal.peng && I.terminal.peng.pengNO == B && (I.terminal.peng = W);
        for (let G of I.dependents)
          this.setPengRecursive(G, B, W);
      }
      linkProperties() {
        if (this.dependents.length == 0)
          return this;
        const I = this.terminal;
        this.isA("coord") && (this.peng = { pengNO: v.pengNO++ }, I.peng = this.peng);
        for (const B of this.dependents) {
          const W = B.terminal;
          switch (B.constType) {
            case "subj":
              I.isA("V") && (I.peng = B.peng);
              break;
            case "det":
              W.isA("D") ? W.peng = this.peng : W.isA("NO") ? W.peng = I.peng : W.isA("P") && W.lemma == "de" && B.dependents.length == 1 && B.dependents[0].isA("mod") && B.dependents[0].terminal.isA("D") && (B.dependents[0].terminal.peng = this.peng);
              break;
            case "mod":
            case "comp":
              if (W.isA("A"))
                this.peng !== void 0 && (W.peng = this.peng), this.link_attributes(W, I);
              else if (W.isA("V")) {
                const G = B.findIndex((K) => K.isA("subj", "comp", "mod") && K.terminal.isA("Pro") && this.relative_pronouns().includes(K.terminal.lemma));
                G >= 0 && (B.dependents[G].constType == "subj" && (W.peng = this.peng), this.link_pp_before(B, I)), this.link_pp_with_head(W);
              } else if (W.isA("Pro") && this.relative_pronouns().includes(W.lemma)) {
                this.peng !== void 0 && (W.peng = this.peng);
                for (let G of B.dependents)
                  G.peng !== void 0 && this.setPengRecursive(G, G.peng.pengNO, this.peng);
              }
              break;
            case "root":
            case "*pre*":
            case "*post*":
              break;
            case "coord":
              if (B.dependents.length > 0) {
                const G = B.dependents[0];
                if (G.isA("subj"))
                  I.peng = B.peng;
                else if (G.isA("det"))
                  B.peng = I.peng;
                else if (G.isA("mod", "comp") && G.terminal.isA("V", "A")) {
                  B.peng = I.peng;
                  for (let K of B.dependents)
                    K.peng = I.peng, K.terminal.peng = I.peng;
                }
              }
              break;
            default:
              this.error("Strange dependent:" + B.constType);
          }
        }
      }
      setLemma(I, B) {
        return this.error("***: should never happen: setLemma: called on a Dependent"), this;
      }
      findGenderNumberPerson(I) {
        let B, W, G = 3, K = 0;
        for (let se = 0; se < this.dependents.length; se++) {
          const he = this.dependents[se].terminal;
          if (he.isA("N", "Pro", "Q", "NO")) {
            K += 1;
            const we = he.getProp("g");
            B === void 0 && we !== void 0 && (B = we), we == "m" && (B = "m"), he.getProp("n") == "p" && (W = "p");
            const Ae = he.getProp("pe");
            Ae !== void 0 && Ae < G && (G = Ae);
          }
        }
        return K > 1 && I && (W = "p"), { g: B, n: W, pe: G };
      }
      pronominalizeChildren() {
        for (let I of this.dependents)
          I.props.pro !== !0 || I.terminal.isA("Pro") || I.pronominalize();
      }
      passivate() {
        let I, B, W;
        if (!this.terminal.isA("V"))
          return this.warn("not found", "V", this.passive_context());
        {
          const G = this.findIndex((se) => se.isA("subj"));
          if (G >= 0) {
            I = this.dependents[G];
            let se = I.terminal;
            se.isA("Pro") && (se = this.passive_pronoun_subject(se));
          } else
            I = null;
          const K = this.findIndex((se) => se.isA("comp") && se.terminal.isA("N", "Pro"));
          K >= 0 ? (B = this.dependents[K], B.terminal.isA("Pro") ? B.terminal = B.terminal.getTonicPro("nom") : B.terminal.isA("N") && B.props.pro === !0 && (B = B.getTonicPro("nom")), B.changeDeprel("subj"), this.passive_should_link_subject() && (this.terminal.peng = B.peng), I != null && (I.changeDeprel("mod"), this.removeDependent(G), W = this.passive_prep(I.terminal.isA("V")), this.addDependent(de($(W, this.lang), I)))) : I != null && (B = Ze(this.passive_dummy_subject(), this.lang).c("nom"), I.changeDeprel("mod"), this.removeDependent(G), this.addPre(B), this.peng = B.peng, W = this.passive_prep(I.terminal.isA("V")), this.addDependent(de($(W, this.lang), I))), this.passive_agree_with_auxiliary(B);
        }
      }
      processV(I, B, W) {
        if (this.isA("coord"))
          this.dependents.forEach(function(G) {
            G.processV(I, W);
          });
        else if (this.terminal.isA("V")) {
          const G = I[B];
          G != null && G !== !1 && W(this, G);
        }
      }
      addPre(I, B) {
        I instanceof ie && (I = [I]);
        for (let W of I)
          this.addDependent(Zt("*pre*", [W]), B);
        return this;
      }
      addPost(I) {
        I instanceof ie && (I = [I]);
        for (let B of I.reverse())
          this.addDependent(Zt("*post*", [B]), 0);
        return this;
      }
      processTypInt(I) {
        const B = I.int, W = m(this.lang).sentence_type.int, G = W.prefix;
        let K, se, he = this.searchStart;
        switch (he === void 0 && (he = 0), B) {
          case "yon":
          case "how":
          case "why":
          case "muc":
            this.move_object(B), K = G[B];
            break;
          case "wos":
          case "was":
            let we = this.findIndex((je) => je.isA("subj"), he);
            we >= 0 && (this.terminal.setProp("n", "s"), this.terminal.setProp("pe", 3), this.removeDependent(we)), K = G[B];
            break;
          case "wod":
          case "wad":
            let Ae;
            for (let je = he; je < this.dependents.length; je++) {
              const Qe = this.dependents[je];
              if (Qe.isA("comp") && Qe.terminal.isA("N") && Qe.findIndex((ut) => ut.terminal.isA("P") && ut.getProp("pos") == "pre") < 0) {
                Ae = this.removeDependent(je);
                break;
              }
            }
            se = this.check_passive_subject_with_par(), K = this.passive_human_object(B, Ae) ? "whom" : G[B], this.move_object(B);
            break;
          case "woi":
          case "wai":
          case "whe":
          case "whn":
            let $e = !1;
            K = G[B];
            for (let je = he; je < this.dependents.length; je++) {
              const Qe = this.dependents[je];
              let ut;
              if (Qe.terminal.isA("P"))
                ut = Qe.terminal.lemma;
              else {
                const st = Qe.findIndex((Rt) => Rt.terminal.isA("P") && Rt.getProp("pos") == "pre");
                st >= 0 && (ut = Qe.dependents[st].terminal.lemma);
              }
              if (Qe.isA("comp", "mod") && ut !== void 0) {
                const st = this.preposition_list();
                if (B == "whe" && st.whe.has(ut) || B == "whn" && st.whn.has(ut) ? $e = !0 : st.all.has(ut) && (K = ut + " " + this.interrogative_pronoun_woi(int_), $e = !0), $e) {
                  this.removeDependent(je);
                  break;
                }
              }
            }
            this.move_object(B);
            break;
          case "tag":
            this.tag_question(I), K = G[B];
            break;
          default:
            this.warn("not implemented", "int:" + B);
        }
        this.should_add_interrogative_prefix(B) && this.addPre(pe(K), 0), se !== void 0 && (this.addPre(se, 0), B == "wad" && (this.dependents[1].terminal.lemma = "quoi")), this.a(W.punctuation, !0);
      }
      processTyp(I) {
        I.pas !== void 0 && I.pas !== !1 && this.passivate(), this.processTyp_verb(I), "int" in I && I.int !== !1 && this.processTypInt(I);
        const B = I.exc;
        return B !== void 0 && B === !0 && this.a(m(this.lang).sentence_type.exc.punctuation, !0), this;
      }
      coordReal() {
        let I = [];
        var B = this.dependents.length - 1;
        if (B == -1)
          return [];
        if (B == 0) {
          const we = this.dependents[0];
          return I = we.real(), this.setProp("g", we.getProp("g")), this.setProp("n", we.getProp("n")), this.setProp("pe", we.getProp("pe") || 3), this.doFormat(I);
        }
        const W = this.dependents[0].constType, G = this.terminal.lemma == "";
        for (let we = 0; we < B; we++) {
          const Ae = this.dependents[we];
          (G || we < B - 1) && (Ae.props.a !== void 0 && Ae.props.a.includes(",") || (Ae.props.a = [","])), Ae.isA("coord") ? I.push(...Ae.coordReal()) : Ae.isA(W) || W == "coord" ? I.push(...Ae.real()) : this.warn("inconsistent dependents within a coord", W, Ae.constType);
        }
        I.push(...this.terminal.real());
        const K = this.dependents[B];
        if (K.isA("coord"))
          return I.push(...K.coordReal()), this.doFormat(I);
        K.isA(W) || W == "coord" || this.warn("inconsistent dependents within a coord", W, K.constType), I.push(...K.real());
        const se = this.terminal;
        if (se.isA("C")) {
          const we = this.and_conj();
          var he = this.findGenderNumberPerson(se.lemma == we);
          he.g !== void 0 && this.setProp("g", he.g), he.n !== void 0 && this.setProp("n", he.n), this.setProp("pe", he.pe), se.pronoun !== void 0 && (se.pronoun.peng = he, se.pronoun.props.g = he.g, se.pronoun.props.n = he.n, se.pronoun.props.pe = he.pe);
        } else
          se.isA("Q") || this.warn("bad parameter", "C", se.constType);
        return this.doFormat(I);
      }
      depPosition() {
        let I = this.props.pos;
        return I !== void 0 || (I = "post", this.isA("subj", "det", "*pre*") ? I = "pre" : this.isA("mod") && this.terminal.isA("A") && this.parentConst.terminal.isA("N") ? I = this.terminal.props.pos || this.adj_def_pos() : this.isA("coord") && this.dependents.length > 0 && (I = this.dependents[0].depPosition())), I;
      }
      doFrenchPronounPlacement(I) {
        return doFrenchPronounPlacement(I);
      }
      real() {
        let I;
        if (this.isA("coord") && this.parentConst == null)
          I = this.coordReal();
        else {
          this.pronominalizeChildren();
          const B = this.props.typ;
          B !== void 0 && this.processTyp(B);
          const W = this.dependents;
          let G = 0;
          for (let K = 0; K < W.length; K++)
            W[K].depPosition() == "pre" && (G != K && W.splice(G, 0, W.splice(K, 1)[0]), G++);
          if (W.length == 0)
            I = this.terminal.real();
          else if (G == 0) {
            I = this.terminal.real();
            for (let K of W)
              I.push(...K.isA("coord") ? K.coordReal() : K.real());
          } else {
            I = [];
            for (let K = 0; K < W.length; K++) {
              const se = W[K];
              I.push(...se.isA("coord") ? se.coordReal() : se.real()), K == G - 1 && I.push(...this.terminal.real());
            }
          }
          this.terminal.isA("V") && this.checkAdverbPos(I);
        }
        return this.doFormat(I);
      }
      toSource(I) {
        I === void 0 && (I = -1);
        let [B, W] = this.indentSep(I), G = this.dependentsSource.map((se) => se.toSource(B));
        G.unshift(this.terminal.toSource());
        let K = this.constType + "(" + G.join(W) + ")";
        return K += v.prototype.toSource.call(this), K;
      }
      toDebug(I) {
        I === void 0 && (I = -1);
        let [B, W] = this.indentSep(I, !0), G = this.dependents.map((se) => se.toDebug(B));
        G.unshift(this.terminal.toDebug());
        let K = this.constType;
        return this.peng !== void 0 && (this.peng.pengNO !== void 0 && (K += "#" + this.peng.pengNO), this.taux && this.taux.tauxNO !== void 0 && (K += "-" + this.taux.tauxNO)), K += "(" + G.join(W) + ")", K += v.prototype.toDebug.call(this), K;
      }
    }
    Ie.prototype.toDependent = function(Y) {
      function I(W, G, K) {
        return W < G ? K.isA("comp") ? K.pos("pre") : !K.isA("mod") || K.isEn() && K.terminal.isA("A") || K.pos("pre") : K.isA("subj", "det") && K.pos("post"), K;
      }
      let B;
      switch (Y = Y || "root", this.constType) {
        case "NP":
        case "VP":
        case "AP":
        case "PP":
        case "AdvP":
          B = function(he, we) {
            let Ae;
            const $e = we.substr(0, we.length - 1), je = he.getHeadIndex(we);
            return he.elements[je].isA($e) ? (Ae = Zt(Y, [he.elements[je]]), he.elements.forEach(function(Qe, ut) {
              if (ut != je) {
                const st = Qe.toDependent(we == "VP" ? "comp" : "mod");
                Ae.add(I(ut, je, st), void 0, !0);
              }
            })) : console.log(`Phrase.toDependent:: ${we} without ${$e}`, he.toSource()), Ae;
          }(this, this.constType);
          break;
        case "CP":
          const W = this.getIndex("C");
          W >= 0 ? (B = Zt("coord", [this.elements[W]]), this.elements.forEach(function(he, we) {
            we != W && B.add(he.toDependent(Y), void 0, !0);
          })) : console.log("Phrase.toDependent:: CP without C", this.toSource());
          break;
        case "S":
        case "SP":
          let G = this.getIndex("VP");
          B = G >= 0 ? this.elements[G].toDependent(Y) : Zt(Y, [pe("")]);
          let K = -1;
          this.isA("SP") && this.isFr() && (K = this.getIndex(["Pro"]), K >= 0 && this.elements[K].lemma == "que" ? B.add(this.elements[K].toDependent("comp").pos("pre"), 0, !0) : K = -1);
          let se = this.getIndex(["NP", "N", "CP", "Pro"]);
          this.elements.forEach(function(he, we) {
            if (we != G && we != K) {
              const Ae = he.toDependent(we == se ? "subj" : "mod");
              B.add(I(we, G, Ae), void 0, !0);
            }
          });
          break;
        default:
          console.log(`Phrase.toDependent:: ${this.constType} not yet implemented`);
      }
      return B.props = this.props, B.optSource = function W(G) {
        let K = G.indexOf(".add(");
        if (K < 0)
          return G;
        const se = G.length;
        let he = 1, we = K + 5;
        for (; he > 0 && we < se; ) {
          const Ae = G.charAt(we);
          Ae == "(" ? he++ : Ae == ")" && he--, we++;
        }
        return G.substring(0, K) + W(G.substring(we));
      }(this.optSource), this.parentConst !== null || this.isA("S") || B.cap(!1), B;
    }, ie.prototype.toDependent = function(Y) {
      let I, B = this.parentConst === null;
      return I = this.isA("D", "NO") ? V(this) : Zt(Y || "root", [this]), B && I.cap(!1), I;
    };
    const O = (Y) => class extends ce(Y) {
      link_attributes(I, B) {
      }
      relative_pronouns() {
        return ["who", "that"];
      }
      link_pp_before(I, B) {
      }
      link_pp_with_head(I) {
      }
      passive_agree_with_auxiliary(I) {
      }
      check_passive_subject_with_par() {
      }
      pronominalize() {
        let I;
        this.props.pe = 3, I = this.parentConst === null || this.isA("subj") ? this.getTonicPro("nom") : this.getTonicPro("acc"), I.peng = this.peng, I.parentConst = this, this.terminal = I, this.dependents = [], this.dependentsSource = [];
      }
      processTyp_verb(I) {
        I.contr !== void 0 && I.contr !== !1 && (this.contraction = !0);
        const B = this.affixHopping(this.terminal, this.getProp("t"), m(this.lang).compound, I);
        let W = B.pop();
        W.isA("Pro") && W.lemma == "myself" && (this.addPost(W), W = B.pop()), this.terminal = W, this.addPre(B);
      }
      move_object(I) {
        let B = this.findIndex((W) => W.isA("*pre*"));
        if (B >= 0 && !["pp", "pr"].includes(this.getProp("t"))) {
          const W = this.dependents[B].terminal;
          this.removeDependent(B), this.addPre(W, 0);
        } else if (["be", "have"].includes(this.terminal.lemma)) {
          const W = this.findIndex((G) => G.isA("subj"));
          W >= 0 && this.dependents[W].pos("post");
        } else
          this.dependents.length == 0 && this.addDependent(de(be("do").pe(3).t("p")));
      }
      tag_question(I) {
        let B;
        const W = this.findIndex((st) => st.terminal.isA("V") && st.depPosition() == "pre"), G = W < 0 ? this.terminal : this.dependents[W].terminal;
        B = "mod" in I && I.mod !== !1 ? m(this.lang).compound[I.mod].aux : ["have", "be", "can", "will", "shall", "may", "must"].includes(G.lemma) ? G.lemma : "do";
        let K = "neg" in I && I.neg === !0, se = G.getProp("pe"), he = G.getProp("t"), we = G.getProp("n"), Ae = G.getProp("g"), $e = Ze("I").pe(se).n(we).g(Ae);
        const je = this.findIndex((st) => st.isA("mod") && st.terminal.isA("Adv"));
        je >= 0 && ["hardly", "scarcely", "never", "seldom"].includes(this.dependents[je].terminal.lemma) && (K = !0);
        let Qe = this.findIndex((st) => st.isA("subj"));
        if (Qe >= 0) {
          const st = this.dependents[Qe].terminal;
          st.isA("Pro") ? (st.getProp("pe") != 1 || B != "be" || he != "p" || K ? ["this", "that", "nothing"].includes(st.lemma) ? $e = Ze("I").g("n") : ["somebody", "anybody", "nobody", "everybody", "someone", "anyone", "everyone"].includes(st.lemma) ? ($e = Ze("I").n("p"), st.lemma == "nobody" && (K = !0)) : $e = st.clone() : se = 2, $e = M($e).pos("post")) : st.isA("N") ? ($e = this.dependents[Qe].clone().pro().pos("post"), $e.g(st.getProp("g")).n(st.getProp("n"))) : $e = M(Ze("it").c("nom")).pos("post");
        } else
          he == "ip" ? (B == "do" && (B = "will"), $e = Ze("I").pe(2).n(we).g(Ae)) : $e = Ze("it").c("nom"), $e = M($e).pos("post");
        let ut = this.dependents.length - 1;
        for (; ut >= 0 && this.dependents[ut].depPosition() != "post"; )
          ut--;
        ut < 0 ? G.a(",") : this.dependents[ut].a(","), B != "have" || K ? this.addDependent(de(be(B).t(he).pe(se).n(we), $e).typ({ neg: !K, contr: !0 })) : this.addDependent(de(be("have").t(he).pe(se).n(we), q(Je("not")), $e).typ({ contr: !0 }));
      }
    }, N = ["N", "A", "Pro", "D", "V", "Adv", "C", "P", "DT", "NO", "Q"], Z = ["S", "NP", "AP", "VP", "AdvP", "PP", "CP", "SP"], re = ["root", "det", "subj", "comp", "mod", "coord"];
    function le(Y, I) {
      if (typeof Y != "object" || Array.isArray(Y))
        console.log("fromJSON: object expected, but found " + typeof Y + ":" + JSON.stringify(Y));
      else if (Y.lang && (Y.lang == "en" ? I = "en" : Y.lang == "fr" ? I = "fr" : (console.log("FromJSON: lang should be 'en' or 'fr', not " + Y.lang + " 'en' will be used"), I = "en")), "phrase" in Y) {
        const B = Y.phrase;
        if (Z.includes(B))
          return Ie.fromJSON(B, Y, I);
        console.log("fromJSON: unknown Phrase type:" + B);
      } else if ("dependent" in Y) {
        const B = Y.dependent;
        if (re.includes(B))
          return ue.fromJSON(B, Y, I);
        console.log("fromJSON: unknown Phrase type:" + B);
      } else if ("terminal" in Y) {
        const B = Y.terminal;
        if (N.includes(B))
          return ie.fromJSON(B, Y, I);
        console.log("fromJSON: unknown Terminal type:" + B);
      }
    }
    function te(Y, I, B) {
      function W(se) {
        B += se;
      }
      function G(se) {
        se.includes("\\") && (se = se.replace(/\\/g, "\\\\")), se.includes('"') && (se = se.replace(/"/g, '\\"')), W('"' + se + '"');
      }
      switch (arguments.length) {
        case 1:
          return te(Y, 0, "");
        case 2:
          return te(Y, I, "");
        default:
          switch (typeof Y) {
            case "string":
              G(Y);
              break;
            case "object":
              if (Y === null)
                W("null");
              else if (Array.isArray(Y)) {
                W("[");
                const se = Y.length, he = Y.some((we) => typeof we == "object" && we !== null);
                for (var K = 1; K <= se; K++) {
                  const we = Y[K - 1];
                  he && K > 1 && W(`
` + " ".repeat(I + 1)), W(te(we, I + 1, "")), K < se && W(",");
                }
                W("]");
              } else {
                W("{");
                const se = Object.keys(Y), he = se.length;
                for (K = 1; K <= he; K++) {
                  const we = se[K - 1];
                  K > 1 && W(`
` + " ".repeat(I + 1)), G(we), W(":"), W(te(Y[we], I + 1 + we.length + 3, "")), K < he && W(",");
                }
                W("}");
              }
              break;
            default:
              W(Y);
          }
      }
      return B;
    }
    function oe(Y) {
      let I = [];
      for (const B of Y)
        B != null && (Array.isArray(B) ? Array.prototype.push.apply(I, oe(B)) : I.push(B));
      return I;
    }
    function fe(Y, I = !1) {
      Y == "en" ? c(I) : pe(Y).warn("bad language", Y);
    }
    v.prototype.setJSONprops = function(Y) {
      if ("props" in Y) {
        const I = Y.props;
        for (let B in I)
          B in this ? Array.isArray(I[B]) ? I[B].forEach((W) => Array.isArray(W) ? v.prototype[B].apply(this, W) : v.prototype[B].call(this, W)) : v.prototype[B].call(this, I[B]) : ["pat", "h"].includes(B) || console.log("Constituent.fromJSON: illegal prop:" + B);
      }
      return this;
    }, Ie.fromJSON = function(Y, I, B) {
      if ("elements" in I) {
        const W = I.elements;
        if (Array.isArray(W)) {
          const G = W.map((K) => le(K, B));
          return new Ee(G, Y, "en").setJSONprops(I);
        }
        console.log("Phrase.fromJSON: elements should be an array:" + JSON.stringify(I));
      } else
        console.log("Phrase.fromJSON: no elements found in " + JSON.stringify(I));
    }, ue.fromJSON = function(Y, I, B) {
      if ("terminal" in I)
        if ("dependents" in I) {
          const W = I.dependents;
          if (Array.isArray(W)) {
            let G = W.map((K) => le(K, B));
            return G.unshift(le(I.terminal, B)), new ki(G, Y, "en").setJSONprops(I);
          }
          console.log("Dependent.fromJSON: dependents should be an array:" + JSON.stringify(I));
        } else
          console.log("Dependent.fromJSON: no dependents found in " + JSON.stringify(I));
      else
        console.log("Dependent.fromJSON: no terminal found in Dependent:" + JSON.stringify(I));
    }, ie.fromJSON = function(Y, I, B) {
      if ("lemma" in I)
        return new me([I.lemma, "en"], Y).setJSONprops(I);
      console.log("Terminal.fromJSON: no lemma found in " + JSON.stringify(I));
    }, Ie.prototype.toJSON = function() {
      let Y = { phrase: this.constType, elements: this.elements.map((I) => I.toJSON()) };
      return Object.keys(this.props).length > 0 && (Y.props = this.props), this.parentConst != null && this.lang == this.parentConst.lang || (Y.lang = this.lang), Y;
    }, ue.prototype.toJSON = function() {
      let Y = { dependent: this.constType, terminal: this.terminal.toJSON() };
      return this.dependents && (Y.dependents = this.dependents.map((I) => I.toJSON())), Object.keys(this.props).length > 0 && (Y.props = this.props), this.parentConst != null && this.lang == this.parentConst.lang || (Y.lang = this.lang), Y;
    }, ie.prototype.toJSON = function() {
      let Y = { terminal: this.constType, lemma: this.lemma };
      return Object.keys(this.props).length > 0 && (Y.props = this.props), this.parentConst != null && this.lang == this.parentConst.lang || (Y.lang = this.lang), Y;
    };
    let H = /* @__PURE__ */ new Map();
    function J(Y) {
      Array.isArray(Y) || (Y = Array.from(arguments));
      const I = Y.length, B = Y.toString();
      let W, G;
      if (H.has(B)) {
        let se = H.get(B);
        if (se.length < I) {
          W = [];
          for (let he = 0; he < I; he++)
            se.indexOf(he) < 0 && W.push(he);
        } else {
          const he = se[se.length - 1];
          W = [...Array(I).keys()], W.splice(he, 1), se.splice(0);
        }
        G = W[Math.floor(Math.random() * W.length)], se.push(G);
      } else
        W = [...Array(I).keys()], G = W[Math.floor(Math.random() * W.length)], H.set(B, [G]);
      const K = Y[G];
      return typeof K == "function" ? K() : K;
    }
    function Se(Y) {
      for (let I = (Y = Array.isArray(Y) ? [...Y] : Array.from(arguments)).length - 1; I > 0; I--) {
        const B = Math.floor(Math.random() * (I + 1));
        [Y[I], Y[B]] = [Y[B], Y[I]];
      }
      return Y.map((I) => typeof I == "function" ? I() : I);
    }
    const Re = "5.0.1", Fe = "2025-09-04, 5:12:12 p.m.", Le = typeof process < "u" && ((r = process == null ? void 0 : process.versions) == null ? void 0 : r.node);
    let ze, tt = !1;
    function Pe(Y) {
      tt = Y;
    }
    function At() {
      ze = [];
    }
    function er() {
      return ze || [];
    }
    class me extends ke(ie) {
    }
    function ht(Y, I) {
      return I.length == 1 ? d() : I[1], new me(I, Y);
    }
    function it(...Y) {
      return ht("N", Y);
    }
    function kt(...Y) {
      return ht("A", Y);
    }
    function Ze(...Y) {
      return ht("Pro", Y);
    }
    function ge(...Y) {
      return ht("D", Y);
    }
    function be(...Y) {
      return ht("V", Y);
    }
    function Je(...Y) {
      return ht("Adv", Y);
    }
    function C(...Y) {
      return ht("C", Y);
    }
    function $(...Y) {
      return ht("P", Y);
    }
    function D(...Y) {
      return ht("DT", Y);
    }
    function ae(...Y) {
      return ht("NO", Y);
    }
    function pe(...Y) {
      return ht("Q", Y);
    }
    class Ee extends Te(Ce(Ie)) {
    }
    function Me(Y, I) {
      return new Ee(I, Y, "en");
    }
    function ot(...Y) {
      return Me("S", Y);
    }
    function dt(...Y) {
      return Me("NP", Y);
    }
    function St(...Y) {
      return Me("AP", Y);
    }
    function rt(...Y) {
      return Me("VP", Y);
    }
    function zt(...Y) {
      return Me("AdvP", Y);
    }
    function Xt(...Y) {
      return Me("PP", Y);
    }
    function tr(...Y) {
      return Me("CP", Y);
    }
    function Nr(...Y) {
      return Me("SP", Y);
    }
    class ki extends O(Ce(ue)) {
    }
    function Zt(Y, I) {
      return new ki(I, Y, "en");
    }
    function Vn(...Y) {
      return Zt("root", Y);
    }
    function M(...Y) {
      return Zt("subj", Y);
    }
    function V(...Y) {
      return Zt("det", Y);
    }
    function q(...Y) {
      return Zt("mod", Y);
    }
    function de(...Y) {
      return Zt("comp", Y);
    }
    function ve(...Y) {
      return Zt("coord", Y);
    }
    return i;
  })());
})(wj);
var Bl = wj.exports;
let A2e = class extends Error {
  constructor() {
    super("The first array in a zipped array must not be longer than the second.");
  }
};
function k2e(t, e) {
  if (t.length > e.length)
    throw new A2e();
  return t.map(function(r, n) {
    return [r, e[n]];
  });
}
var dr;
((t) => {
  class e extends Error {
  }
  class r extends Bl.Terminal_en {
    clone() {
      const j = new this.constructor(this.lemma);
      let ee = this.toJSON();
      return j.setJSONprops(ee), j;
    }
    after(j) {
      return this.a(j.lemma);
    }
    before(j) {
      return this.b(j.lemma);
    }
  }
  t.Terminal = r;
  class n extends r {
    /**
     * Constructs a noun object
     * @param {string} lemma - The base noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "N");
    }
  }
  t.Noun = n;
  class i extends n {
    /**
     * Constructs a proper noun object
     * @param {string} lemma - The base proper noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super(j), this.cap();
    }
  }
  t.ProperNoun = i;
  class s extends r {
    /**
     * Constructs a verb object
     * @param {string} lemma - The base verb to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "V");
    }
    t(j) {
      return j === "present" && (j = "p"), j === "past" && (j = "ps"), j === "future" && (j = "f"), j === "present-participle" && (j = "pr"), j === "past-participle" && (j = "pp"), r.prototype.t.call(this, j);
    }
    /**
     * Provides shorthand for past tense
     */
    past() {
      return this.t("past");
    }
    /**
     * Provides shorthand for present tense
     */
    present() {
      return this.t("present");
    }
    /**
     * Provides shorthand for future tense
     */
    future() {
      return this.t("future");
    }
  }
  t.Verb = s;
  class o extends r {
    /**
     * Constructs an adjective object
     * @param {string} lemma - The base adjective to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "A");
    }
  }
  t.Adjective = o;
  class a extends r {
    /**
     * Constructs a determiner object
     * @param {string} lemma - The base noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "D");
    }
  }
  t.Determiner = a;
  class l extends r {
    /**
     * Constructs a conjunction object
     * @param {string} lemma - The base conjunction to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "C");
    }
  }
  t.Conjunction = l;
  class c extends r {
    /**
     * Constructs a preposition object
     * @param {string} lemma - The base preposition to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "P");
    }
  }
  t.Preposition = c;
  class p extends r {
    /**
     * Constructs a pronoun object
     * @param {string} lemma - The base pronoun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "Pro");
    }
  }
  t.Pronoun = p;
  class h extends r {
    /**
     * Constructs an adverb object
     * @param {string} lemma - The base adverb to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "Adv");
    }
  }
  t.Adverb = h;
  class d extends r {
    /**
     * Constructs a noun object
     * @param {string | Date} lemma - The base date to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      j === void 0 ? super([], "DT") : super([j], "DT");
    }
  }
  t.DateNoun = d;
  class b extends r {
    /**
     * Constructs a noun object
     * @param {string} lemma - The base noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "NO");
    }
  }
  t.NumberNoun = b;
  class m extends r {
    /**
     * Constructs a quoted raw text object
     * @param {string} text - The base text to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "Q");
    }
  }
  t.Quote = m;
  class w extends Bl.Phrase_en {
    constructor(j, ee) {
      j = j.filter((X) => X != null), super(j, ee, "en");
    }
    clone() {
      const j = this.elements.map((ie) => ie.clone()), ee = new this.constructor(j);
      let X = this.toJSON();
      return ee.setJSONprops(X), ee;
    }
    after(j) {
      return this.a(j.lemma);
    }
    before(j) {
      return this.b(j.lemma);
    }
    realize(j) {
      return super.realize(j).replaceAll(" ,", ",");
    }
  }
  t.Phrase = w;
  class f extends w {
    /**
     * Constructs a noun phrase object
     * @param {MaybeConstituent[]} elements - The elements of the noun phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "NP");
    }
    /**
     * Finds the determiner of the NP, if it has one
     * NOTE: this method assumes that, if an NP has a determiner, then it has a single D element at
     * the top level
     * @returns {Determiner | null} The NP's determiner, if it has one, and null otherwise
     */
    getDeterminer() {
      for (const j of this.elements)
        if (j instanceof a)
          return j;
      return null;
    }
    /**
     * Finds the head noun of the NP
     * NOTE: as an NP object may contain NP objects as constituents, this method can recurse through
     * the constituent tree
     * @returns {Noun} The NP's head noun
     */
    getHeadNoun() {
      const j = this.elements[this.getHeadIndex("NP")];
      return j instanceof f ? j.getHeadNoun() : j;
    }
    /**
     * Given this NP, supposing it has a CP of NPs as its first element, repeatedly factorizes common
     * elements out of the CP, and returns a simplified NP. If simplification isn't possible, no change
     * is made.
     * @param {Boolean} oxford Whether the CP should use the Oxford comma.
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    factorize(j = !1) {
      if (!(this.elements[0] instanceof v))
        throw new e("only NPs of the form NP(CP(...), ...) can be simplified");
      let ee = this.elements[0];
      const X = [], ie = [];
      let ce = !1;
      for (; !ce; ) {
        const ke = ee.factorize();
        if (ke.length)
          ke[0] instanceof v ? (ee = ke[0], ie.unshift(ke[1])) : (X.push(ke[0]), ee = ke[1]);
        else {
          let ye = ee.clone();
          j && ye.oxfordify(), X.push(ye), ce = !0;
        }
      }
      return new f(...X, ...ie);
    }
  }
  t.NounPhrase = f;
  class E extends w {
    /**
     * Constructs an adjective phrase object
     * @param {MaybeConstituent[]} elements - The elements of the adjective phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "AP");
    }
  }
  t.AdjPhrase = E;
  class A extends w {
    /**
     * Constructs a verb phrase object
     * @param {MaybeConstituent[]} elements - The elements of the verb phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "VP");
    }
  }
  t.VerbPhrase = A;
  class x extends w {
    /**
     * Constructs a prepositional phrase object
     * @param {MaybeConstituent[]} elements - The elements of the prepositional phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "PP");
    }
  }
  t.PrepPhrase = x;
  class g extends w {
    /**
     * Constructs an adverbal phrase object
     * @param {MaybeConstituent[]} elements - The elements of the adverbal phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "AdvP");
    }
  }
  t.AdvPhrase = g;
  class v extends w {
    /**
     * Constructs a coordinated phrase object
     * @param {MaybeConstituent[]} elements - The elements of the coordinated phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "CP");
    }
    /**
     * Adds an Oxford Comma to this CP; does nothing if the phrase has < 3 constituents, an Oxford Comma
     * is already present, or this CP doesn't begin with a C or a Q.
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    oxfordify() {
      if (this.elements[0] instanceof l || this.elements[0] instanceof m) {
        const j = this.elements.slice(1);
        if (j.length > 2) {
          const ee = j[j.length - 2];
          (!ee.props.a || !ee.props.a.includes(",")) && ee.a(",");
        }
      }
      return this;
    }
    /**
     * Factorizes a common element out of this CP. Only possible when this CP is composed of NPs.
     * @returns {[AdjPhrase, CoordPhrase] | [CoordPhrase, Noun] | []}
     * Factorized sequence of common element + CP (in whichever order is appropriate), or the empty array if
     * no factorization was possible. Specifically:
     * 1: [factored-out common AP, remaining CP(conj, NP+)]
     * 2: [remaining CP(conj, N+), factored-out common head N]
     * 3: []
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    factorize() {
      let j = null, ee = null;
      if (this.elements[0] instanceof l || this.elements[0] instanceof m ? (j = this.elements[0], ee = this.elements.slice(1)) : ee = this.elements, !ee.every((X) => X instanceof f))
        throw new e("all CP elements must be NPs");
      if (ee = ee, ee.every((X) => X.elements[0] instanceof E && X.elements.slice(1).every((ie) => ie instanceof n))) {
        const X = ee[0].elements[0];
        if (ee.every((ie) => R(ie.elements[0], X))) {
          const ie = ee.map((ce) => new f(...ce.elements.slice(1)));
          return j && ie.unshift(j), [X.clone(), new v(...ie)];
        }
      } else if (ee.every((X) => X.elements.length > 1 && X.elements.every((ie) => ie instanceof n))) {
        const X = ee[0], ie = X.elements[X.elements.length - 1];
        if (ee.every(
          (ce) => R(ce.elements[ce.elements.length - 1], ie)
        )) {
          const ce = ee.map((ke) => new f(...ke.elements.slice(0, -1)));
          return j && ce.unshift(j), [new v(...ce), ie.clone()];
        }
      } else {
        if (ee.every((X) => X.elements.length === 1 && X.elements[0] instanceof n))
          return [];
        throw new e("unrecognized CP structure");
      }
      return [];
    }
  }
  t.CoordPhrase = v;
  class k extends w {
    /**
     * Constructs an subordinated phrase object.
     * NOTE: `restrictive` should be necessary, but is needed because `.b(',')` does
     *   not work properly in JSRealB. See: https://github.com/rali-udem/jsRealB/issues/54
     * @param {boolean} restrictive - Whether the subordinated phrase is restrictive
     * @param {MaybeConstituent[]} elements - The elements of the subordinated phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j, ...ee) {
      super(ee, "SP"), this.restrictive = j;
    }
  }
  t.SubordPhrase = k;
  class S extends w {
    /**
     * Constructs a sentence object
     * @param {MaybeConstituent[]} elements - The elements of the sentence
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "S");
    }
    // (@simonvarey): This override is necessary as a workaround for a JSRealB design decision. See
    //   rali-udem/jsRealB#56 and theseusaurus#57. Note that it will fail if the sentence has more 
    //   than one tag: see theseusaurus#58.
    realize(j) {
      let ee = super.realize(j);
      if ("tag" in this.props) {
        const X = `</${this.props.tag[0][0]}>`;
        ee = ee.slice(0, -X.length) + `.${X} `;
      }
      return ee;
    }
  }
  t.Sentence = S;
  function R(z, j) {
    return z.lang === j.lang && z.constType === j.constType ? z instanceof d ? (j = j, F(z.props.dOpt, j.props.dOpt) ? !1 : L(z, j)) : z instanceof w ? (j = j, z.elements.length !== j.elements.length || k2e(z.elements, j.elements).some((ee) => !R(ee[0], ee[1])) ? !1 : L(z, j)) : z.lemma === j.lemma && L(z, j) : !1;
  }
  t.compareNodes = R;
  function L(z, j) {
    for (const ee of Object.keys(z.props))
      if (ee !== "dOpt" && z.getProp(ee) !== j.getProp(ee))
        return !1;
    return !0;
  }
  function F(z, j) {
    if (j === void 0 || Object.keys(z).length !== Object.keys(j).length)
      return !1;
    for (const ee of Object.keys(z))
      if (z[ee] !== j[ee])
        return !1;
    return !0;
  }
})(dr || (dr = {}));
const Lf = class Ci {
  /*resetSavedWarnings: any;
  getSavedWarnings: any;*/
  /*ppJSON: any;
  jsRealB_version: any;
  jsRealB_dateCreated: any;
  lexiconEn: any;
  loadEn: any;
  lexiconFr: any;
  loadFr: any;*/
  /**
   * Proxies each function of jsRealB as a function of the Theseusaurus class, with options for extension.
   * @constructor
   */
  constructor() {
    Lo(this, "oneOf"), Lo(this, "setExceptionOnWarning"), this.oneOf = Bl.oneOf, this.setExceptionOnWarning = Bl.setExceptionOnWarning;
  }
  /**
   * Initializes the Theseusaurus object.
   * @private
   * @memberOf module:@fizz/theseusaurus
   */
  async init() {
    await Bl.loadEn(), this._updateLexicon();
  }
  // Helper Functions
  static _addDefToLexicon(e, r, n) {
    const i = {
      N: "n1",
      A: "a1",
      Adv: "b1",
      V: "",
      D: "",
      C: "",
      P: "",
      Pro: "",
      DT: "",
      NO: "",
      Q: ""
    }, s = Ci.getLemma(e, "en");
    let o;
    if (s !== void 0) {
      if (s[r] !== void 0) {
        const a = s[r].tab;
        a !== n && n !== "default" && console.warn(`[Theseusaurus]: a different definition of ${e} as a ${r} already exists in the lexicon. Old def: ${a}. New def: ${n}`);
        return;
      }
      n = n === "default" ? i[r] : n, o = { ...s, [r]: { tab: n } };
    } else
      n = n === "default" ? i[r] : n, o = { [r]: { tab: n } };
    Ci.addToLexicon(e, o, "en");
  }
  /**
   * Adds chart-specific words and grammar rules to default lexicon.
   * @private
   * @memberOf module:@fizz/theseusaurus
   * NOTE: Previously, 'rising' and 'falling' were added to the lexicon here as adjectives. However,
   *       they are available as the present participle (code: 'pr') forms of the verbs 'rise' and 'fall'.
   */
  _updateLexicon() {
    Ci._addDefToLexicon("high", "N", "n1"), Ci._addDefToLexicon("x-axis", "N", "n8"), Ci._addDefToLexicon("y-axis", "N", "n8"), Ci._addDefToLexicon("which", "Adv", "b1"), Ci._addDefToLexicon("whose", "Adv", "b1"), Ci._addDefToLexicon("what", "Adv", "b1"), Ci._addDefToLexicon("worldwide", "Adv", "b1");
  }
  /**
   * Composes a list of words from an array into a coordinated phrase.
   * TODO(?): Allow phrases to be members of the list
   * @param {string[]} wordArray An array of words.
   * @param {new (lemma:string): Terminal} partOfSpeech A terminal constructor for the words with their
   *  part of speech.
   * @param {string} [conjunction] An optional conjunction, such as 'and' (default), 'or', 'nor', 'and then',
   *  or ''; if the empty string, this will make a list without a conjunction.
   * @returns {CoordPhrase} A coordinated phrase. with the tagged words joined with commas and an optional
   *  conjunction.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  composeList(e, r, n = "and") {
    const i = e.slice().map((a) => r(a));
    let s;
    n.includes(" ") ? s = this.Q(n) : n ? s = this.C(n) : s = null;
    const o = this.CP(s, ...i);
    return o.oxfordify(), o;
  }
  // Constituents
  /**
   * Extends the N (noun) function with optional declension parameter
   * @param {string} lemma - The base noun to be processed
   * @param {GramNumber} number - The grammatical number of the noun (e.g. singular/plural). Default is 'singular' ('s').
   * @returns {Noun} - The noun object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  N(e, r = "s", n) {
    n && Ci._addDefToLexicon(e, "N", "default");
    const i = new dr.Noun(e);
    return i.n(r), i;
  }
  /**
   * Extends the PN (proper noun) function with optional declension parameter
   * @param {string} lemma - The base noun to be processed
   * @param {GramNumber} number - The grammatical number of the noun (e.g. singular/plural). Default is 'singular' ('s').
   * @returns {ProperNoun} - The noun object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  PN(e, r = "s") {
    Ci._addDefToLexicon(e, "N", "default");
    const n = new dr.ProperNoun(e);
    return n.n(r), n;
  }
  /**
   * Extends the V (verb) function with optional tense parameter
   * @param {string} lemma - The base verb to be processed
   * @param {Tense} tense - The tense of the verb. Default is 'present' ('p').
   * @param {GramNumber} number - The number of the verb. Default is 'singular' ('s'). In English, this is only
   *  relevant for 'is'/'are'.
   * @returns {Verb} - The verb function object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  V(e, r = "p", n = "s") {
    return new dr.Verb(e).t(r).n(n);
  }
  /**
   * Extends the A (adjective) function
   * @param {string} lemma - The base adjective to be processed
   * @param {boolean | undefined} addToLexicon - Optional parameter stating whether to add lemma
   *  to lexicon if it does not already exist.
   * @returns {Adjective} - The adjective function object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  A(e, r) {
    return r && Ci._addDefToLexicon(e, "A", "default"), new dr.Adjective(e);
  }
  /**
   * Extends the D (determiner) function
   * @param {string} lemma - The base determiner to be processed
   * @returns {Determiner} - The determiner object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  D(e) {
    return new dr.Determiner(e);
  }
  /**
   * Extends the C (conjunction) function
   * @param {string} lemma - The base conjunction to be processed
   * @returns {Conjunction} - The conjunction object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  C(e) {
    return new dr.Conjunction(e);
  }
  /**
   * Extends the P (preposition) function
   * @param {string} lemma - The base preposition to be processed
   * @returns {Preposition} - The preposition object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  P(e) {
    return new dr.Preposition(e);
  }
  /**
   * Extends the Adv (adverb) function
   * @param {string} lemma - The base adverb to be processed
   * @returns {Adverb} - The adverb object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  Adv(e) {
    return new dr.Adverb(e);
  }
  /**
   * Extends the Pro (pronoun) function
   * @param {string} lemma - The base pronoun to be processed
   * @returns {Pronoun} - The pronoun object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  Pro(e) {
    return new dr.Pronoun(e);
  }
  /**
   * Extends the Q (quote) function
   * @param {string} lemma - The raw text to be processed
   * @returns {Quote} - The quote object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  Q(e) {
    return new dr.Quote(e);
  }
  /**
   * Extends the NP (noun phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the noun phrase
   * @returns {NounPhrase} - The noun phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  NP(...e) {
    return new dr.NounPhrase(...e);
  }
  /**
   * Extends the VP (verb phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the verb phrase
   * @returns {VerbPhrase} - The verb phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  VP(...e) {
    return new dr.VerbPhrase(...e);
  }
  /**
   * Extends the AP (adjective phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the adjective phrase
   * @returns {AdjPhrase} - The adjective phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  AP(...e) {
    return new dr.AdjPhrase(...e);
  }
  /**
   * Extends the PP (prepositional phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the prepositional phrase
   * @returns {PrepPhrase} - The prepositional phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  PP(...e) {
    return new dr.PrepPhrase(...e);
  }
  /**
   * Extends the AdvP (adverbial phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the adverbial phrase
   * @returns {AdvPhrase} - The adverbial phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  AdvP(...e) {
    return new dr.AdvPhrase(...e);
  }
  /**
   * Extends the CP (coordinated phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the coordinated phrase
   * @returns {CoordPhrase} - The coordinated phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  CP(...e) {
    return new dr.CoordPhrase(...e);
  }
  /**
   * Extends the DT (date) function with year-only handling and optional preposition parameter
   * @param {string | number | Date} lemma - The base date to be processed
   * @param {string} opt - Options for formating. If 'p' is value, will add a preposition to a year-only lemma.
   * @returns {DateNoun} - The date object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  DT(e, r) {
    let n;
    if (e === void 0)
      n = new dr.DateNoun();
    else if (e instanceof Date)
      n = new dr.DateNoun(e);
    else {
      const s = e.toString();
      if (s.match(/^\d+$/)) {
        const o = `${s}/01/01`;
        n = new dr.DateNoun(o).dOpt({
          year: !0,
          month: !1,
          date: !1,
          day: !1,
          hour: !1,
          minute: !1,
          second: !1,
          rtime: !1
        });
      } else
        n = new dr.DateNoun(s);
    }
    let i = !1;
    return r === "p" && (i = !0), n.dOpt({ nat: i, det: i });
  }
  /**
   * Extends the NO (number) function
   * @param {number} number - The base number to be processed
   * @returns {NumberNoun} - The number object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  NO(e) {
    const r = e.toString();
    return new dr.NumberNoun(r).dOpt({ raw: !0 });
  }
  /**
   * Extends the SP (subordinated phrase) function
   * NOTE: `restrictive` should be necessary, but is needed because `.b(',')` does
   *   not work properly in JSRealB. See: https://github.com/rali-udem/jsRealB/issues/54
   * @param {boolean} restrictive - Whether the subordinated phrase is restrictive
   * @param {Constituent[]} constituents - The constituents of the subordinated phrase
   * @returns {SubordPhrase} - The subordinated phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  SP(e, ...r) {
    return new dr.SubordPhrase(e, ...r);
  }
  /**
   * Extends the S (sentence) function
   * @param {Constituent[]} constituents - The constituents of the sentence
   * @returns {Sentence} - The sentence object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  S(...e) {
    return new dr.Sentence(...e);
  }
};
Lo(Lf, "fromJSON", Bl.fromJSON), Lo(Lf, "addToLexicon", Bl.addToLexicon), Lo(Lf, "getLemma", Bl.getLemma), /**
* Compares two syntax tree nodes for equality.
* @param {Constituent} nodeA First node to check.
* @param {Constituent} nodeB Second node to check.
* @returns {boolean} Equality test result.
* @public
* @memberOf module:@fizz/theseusaurus
*/
Lo(Lf, "compareNodes", dr.compareNodes);
let _2e = Lf;
function Li(t, e, r, n, i) {
  return Da(e, ((s, o) => {
    const a = s[o];
    if (a === void 0)
      throw new TypeError(g8(o));
    return a;
  })(t, e), r, n, i);
}
function Da(t, e, r, n, i, s) {
  const o = M0(e, r, n);
  if (i && e !== o)
    throw new RangeError(MB(t, e, r, n, s));
  return o;
}
function vi(t) {
  return t !== null && /object|function/.test(typeof t);
}
function ms(t, e = Map) {
  const r = new e();
  return (n, ...i) => {
    if (r.has(n))
      return r.get(n);
    const s = t(n, ...i);
    return r.set(n, s), s;
  };
}
function L0(t) {
  return ed({
    name: t
  }, 1);
}
function ed(t, e) {
  return $a((r) => ({
    value: r,
    configurable: 1,
    writable: !e
  }), t);
}
function C2e(t) {
  return $a((e) => ({
    get: e,
    configurable: 1
  }), t);
}
function ES(t) {
  return {
    [Symbol.toStringTag]: {
      value: t,
      configurable: 1
    }
  };
}
function Bd(t, e) {
  const r = {};
  let n = t.length;
  for (const i of e)
    r[t[--n]] = i;
  return r;
}
function $a(t, e, r) {
  const n = {};
  for (const i in e)
    n[i] = t(e[i], i, r);
  return n;
}
function Db(t, e, r) {
  const n = {};
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    n[s] = t(s, i, r);
  }
  return n;
}
function xj(t, e, r) {
  const n = {};
  for (let i = 0; i < t.length; i++)
    n[e[i]] = r[t[i]];
  return n;
}
function co(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const n of t)
    r[n] = e[n];
  return r;
}
function TI(t, e) {
  for (const r of e)
    if (r in t)
      return 1;
  return 0;
}
function Ej(t, e, r) {
  for (const n of t)
    if (e[n] !== r[n])
      return 0;
  return 1;
}
function Sj(t, e, r) {
  const n = {
    ...r
  };
  for (let i = 0; i < e; i++)
    n[t[i]] = 0;
  return n;
}
function ir(t, ...e) {
  return (...r) => t(...e, ...r);
}
function LI(t) {
  return t[0].toUpperCase() + t.substring(1);
}
function Vg(t) {
  return t.slice().sort();
}
function Uy(t, e) {
  return String(e).padStart(t, "0");
}
function Fl(t, e) {
  return Math.sign(t - e);
}
function M0(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
function Ea(t, e) {
  return [Math.floor(t / e), Jf(t, e)];
}
function Jf(t, e) {
  return (t % e + e) % e;
}
function ec(t, e) {
  return [$b(t, e), SS(t, e)];
}
function $b(t, e) {
  return Math.trunc(t / e) || 0;
}
function SS(t, e) {
  return t % e || 0;
}
function Hm(t) {
  return Math.abs(t % 1) === 0.5;
}
function Aj(t, e, r) {
  let n = 0, i = 0;
  for (let a = 0; a <= e; a++) {
    const l = t[r[a]], c = Wo[a], p = Fr / c, [h, d] = ec(l, p);
    n += d * c, i += h;
  }
  const [s, o] = ec(n, Fr);
  return [i + s, o];
}
function jb(t, e, r) {
  const n = {};
  for (let i = e; i >= 0; i--) {
    const s = Wo[i];
    n[r[i]] = $b(t, s), t = SS(t, s);
  }
  return n;
}
function I2e(t) {
  if (t !== void 0)
    return Xn(t);
}
function P2e(t) {
  if (t !== void 0)
    return fa(t);
}
function kj(t) {
  if (t !== void 0)
    return AS(t);
}
function fa(t) {
  return Ij(AS(t));
}
function AS(t) {
  return Cj(Bve(t));
}
function _j(t, e) {
  if (e == null)
    throw new RangeError(g8(t));
  return e;
}
function Ug(t) {
  if (!vi(t))
    throw new TypeError(uve);
  return t;
}
function kS(t, e, r = t) {
  if (typeof e !== t)
    throw new TypeError(jc(r, e));
  return e;
}
function Cj(t, e = "number") {
  if (!Number.isInteger(t))
    throw new RangeError(ive(e, t));
  return t || 0;
}
function Ij(t, e = "number") {
  if (t <= 0)
    throw new RangeError(sve(e, t));
  return t;
}
function _S(t) {
  if (typeof t == "symbol")
    throw new TypeError(cve);
  return String(t);
}
function P1(t, e) {
  return vi(t) ? String(t) : Xn(t, e);
}
function CS(t) {
  if (typeof t == "string")
    return BigInt(t);
  if (typeof t != "bigint")
    throw new TypeError(lve(t));
  return t;
}
function Pj(t, e = "number") {
  if (typeof t == "bigint")
    throw new TypeError(ave(e));
  if (t = Number(t), !Number.isFinite(t))
    throw new RangeError(ove(e, t));
  return t;
}
function si(t, e) {
  return Math.trunc(Pj(t, e)) || 0;
}
function IS(t, e) {
  return Cj(Pj(t, e), e);
}
function MI(t, e) {
  return Ij(si(t, e), e);
}
function PS(t, e) {
  let [r, n] = ec(e, Fr), i = t + r;
  const s = Math.sign(i);
  return s && s === -Math.sign(n) && (i -= s, n += s * Fr), [i, n];
}
function td(t, e, r = 1) {
  return PS(t[0] + e[0] * r, t[1] + e[1] * r);
}
function vh(t, e) {
  return PS(t[0], t[1] + e);
}
function Ho(t, e) {
  return td(e, t, -1);
}
function ys(t, e) {
  return Fl(t[0], e[0]) || Fl(t[1], e[1]);
}
function Rj(t, e, r) {
  return ys(t, e) === -1 || ys(t, r) === 1;
}
function RS(t, e = 1) {
  const r = BigInt(Fr / e);
  return [Number(t / r), Number(t % r) * e];
}
function Hy(t, e = 1) {
  const r = Fr / e, [n, i] = ec(t, r);
  return [n, i * e];
}
function Go(t, e = 1, r) {
  const [n, i] = t, [s, o] = ec(i, e);
  return n * (Fr / e) + (s + (r ? o / e : 0));
}
function OS(t, e, r = Ea) {
  const [n, i] = t, [s, o] = r(i, e);
  return [n * (Fr / e) + s, o];
}
function TS(t) {
  return Li(t, "isoYear", F0, B0, 1), t.isoYear === F0 ? Li(t, "isoMonth", 4, 12, 1) : t.isoYear === B0 && Li(t, "isoMonth", 1, 9, 1), t;
}
function zs(t) {
  return Ki({
    ...t,
    ...Yi,
    isoHour: 12
  }), t;
}
function Ki(t) {
  const e = Li(t, "isoYear", F0, B0, 1), r = e === F0 ? 1 : e === B0 ? -1 : 0;
  return r && na(Rn({
    ...t,
    isoDay: t.isoDay + r,
    isoNanosecond: t.isoNanosecond - r
  })), t;
}
function na(t) {
  if (!t || Rj(t, qve, Wve))
    throw new RangeError(Bc);
  return t;
}
function tc(t) {
  return Aj(t, 5, po)[1];
}
function Bb(t) {
  const [e, r] = Ea(t, Fr);
  return [jb(r, 5, po), e];
}
function NI(t) {
  return OS(t, Do);
}
function ui(t) {
  return Fd(t.isoYear, t.isoMonth, t.isoDay, t.isoHour, t.isoMinute, t.isoSecond, t.isoMillisecond);
}
function Rn(t) {
  const e = ui(t);
  if (e !== void 0) {
    const [r, n] = ec(e, Fi);
    return [r, n * el + (t.isoMicrosecond || 0) * Yg + (t.isoNanosecond || 0)];
  }
}
function LS(t, e) {
  const [r, n] = Bb(tc(t) - e);
  return na(Rn({
    ...t,
    isoDay: t.isoDay + n,
    ...r
  }));
}
function Gy(...t) {
  return Fd(...t) / UB;
}
function Fd(...t) {
  const [e, r] = Oj(...t), n = e.valueOf();
  if (!isNaN(n))
    return n - r * Fi;
}
function Oj(t, e = 1, r = 1, n = 0, i = 0, s = 0, o = 0) {
  const a = t === F0 ? 1 : t === B0 ? -1 : 0, l = /* @__PURE__ */ new Date();
  return l.setUTCHours(n, i, s, o), l.setUTCFullYear(t, e - 1, r + a), [l, a];
}
function zd(t, e) {
  let [r, n] = vh(t, e);
  n < 0 && (n += Fr, r -= 1);
  const [i, s] = Ea(n, el), [o, a] = Ea(s, Yg);
  return Fb(r * Fi + i, o, a);
}
function Fb(t, e = 0, r = 0) {
  const n = Math.ceil(Math.max(0, Math.abs(t) - Gve) / Fi) * Math.sign(t), i = new Date(t - n * Fi);
  return Bd(av, [i.getUTCFullYear(), i.getUTCMonth() + 1, i.getUTCDate() + n, i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds(), e, r]);
}
function MS(t, e) {
  if (e < -864e13)
    throw new RangeError(Bc);
  const r = t.formatToParts(e), n = {};
  for (const i of r)
    n[i.type] = i.value;
  return n;
}
function NS(t) {
  return [t.isoYear, t.isoMonth, t.isoDay];
}
function Tj(t, e) {
  return [e, 0];
}
function Lj() {
  return gl;
}
function Mj(t, e) {
  switch (e) {
    case 2:
      return DS(t) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function Nj(t) {
  return DS(t) ? 366 : 365;
}
function DS(t) {
  return t % 4 == 0 && (t % 100 != 0 || t % 400 == 0);
}
function Dj(t) {
  const [e, r] = Oj(t.isoYear, t.isoMonth, t.isoDay);
  return Jf(e.getUTCDay() - r, 7) || 7;
}
function $j(t) {
  return this.id === Kd ? (({ isoYear: e }) => e < 1 ? ["gregory-inverse", 1 - e] : ["gregory", e])(t) : this.id === ic ? Yve(t) : [];
}
function R2e(t) {
  const e = ui(t);
  if (e < Kve) {
    const { isoYear: s } = t;
    return s < 1 ? ["japanese-inverse", 1 - s] : ["japanese", s];
  }
  const r = MS(N8(ic), e), { era: n, eraYear: i } = SB(r, ic);
  return [n, i];
}
function zb(t) {
  return zh(t), Vd(t, 1), t;
}
function zh(t) {
  return jj(t, 1), t;
}
function DI(t) {
  return Ej(A8, t, jj(t));
}
function jj(t, e) {
  const { isoYear: r } = t, n = Li(t, "isoMonth", 1, Lj(), e);
  return {
    isoYear: r,
    isoMonth: n,
    isoDay: Li(t, "isoDay", 1, Mj(r, n), e)
  };
}
function Vd(t, e) {
  return Bd(po, [Li(t, "isoHour", 0, 23, e), Li(t, "isoMinute", 0, 59, e), Li(t, "isoSecond", 0, 59, e), Li(t, "isoMillisecond", 0, 999, e), Li(t, "isoMicrosecond", 0, 999, e), Li(t, "isoNanosecond", 0, 999, e)]);
}
function mr(t) {
  return t === void 0 ? 0 : sF(Ug(t));
}
function Vb(t, e = 0) {
  t = ia(t);
  const r = oF(t), n = owe(t, e);
  return [sF(t), n, r];
}
function Ud(t, e, r, n = 9, i = 0, s = 4) {
  e = ia(e);
  let o = iF(e, n, i), a = BS(e), l = Xg(e, s);
  const c = Jg(e, n, i, 1);
  return o == null ? o = Math.max(r, c) : Vj(o, c), a = FS(a, c, 1), t && (l = ((p) => p < 4 ? (p + 2) % 4 : p)(l)), [o, c, a, l];
}
function Ub(t, e = 6, r) {
  let n = BS(t = Hb(t, Zy));
  const i = Xg(t, 7);
  let s = Jg(t, e);
  return s = _j(Zy, s), n = FS(n, s, void 0, r), [s, n, i];
}
function $S(t) {
  return _8(ia(t));
}
function Bj(t, e) {
  return jS(ia(t), e);
}
function O2e(t) {
  const e = Hb(t, j3), r = Lc(j3, iwe, e, 0);
  if (!r)
    throw new RangeError(jc(j3, r));
  return r;
}
function jS(t, e = 4) {
  const r = zj(t);
  return [Xg(t, 4), ...Fj(Jg(t, e), r)];
}
function Fj(t, e) {
  return t != null ? [Wo[t], t < 4 ? 9 - 3 * t : -1] : [e === void 0 ? 1 : 10 ** (9 - e), e];
}
function BS(t) {
  const e = t[Xf];
  return e === void 0 ? 1 : si(e, Xf);
}
function FS(t, e, r, n) {
  const i = n ? Fr : Wo[e + 1];
  if (i) {
    const s = Wo[e];
    if (i % ((t = Da(Xf, t, 1, i / s - (n ? 0 : 1), 1)) * s))
      throw new RangeError(jc(Xf, t));
  } else
    t = Da(Xf, t, 1, r ? 10 ** 9 : 1, 1);
  return t;
}
function zj(t) {
  let e = t[$3];
  if (e !== void 0) {
    if (typeof e != "number") {
      if (_S(e) === "auto")
        return;
      throw new RangeError(jc($3, e));
    }
    e = Da($3, Math.floor(e), 0, 9, 1);
  }
  return e;
}
function ia(t) {
  return t === void 0 ? {} : Ug(t);
}
function Hb(t, e) {
  return typeof t == "string" ? {
    [e]: t
  } : Ug(t);
}
function Gb(t) {
  return {
    overflow: Zve[t]
  };
}
function zS(t, e, r = 9, n = 0, i) {
  let s = e[t];
  if (s === void 0)
    return i ? n : void 0;
  if (s = _S(s), s === "auto")
    return i ? n : null;
  let o = E4[s];
  if (o === void 0 && (o = Vve[s]), o === void 0)
    throw new RangeError(DB(t, s, E4));
  return Da(t, o, n, r, 1, m8), o;
}
function Lc(t, e, r, n = 0) {
  const i = r[t];
  if (i === void 0)
    return n;
  const s = _S(i), o = e[s];
  if (o === void 0)
    throw new RangeError(DB(t, s, e));
  return o;
}
function Vj(t, e) {
  if (e > t)
    throw new RangeError(Ove);
}
function Ja(t) {
  return {
    branding: R8,
    epochNanoseconds: t
  };
}
function uo(t, e, r) {
  return {
    branding: Fc,
    calendar: r,
    timeZone: e,
    epochNanoseconds: t
  };
}
function ho(t, e = t.calendar) {
  return {
    branding: Yd,
    calendar: e,
    ...co(Uve, t)
  };
}
function Xa(t, e = t.calendar) {
  return {
    branding: em,
    calendar: e,
    ...co(k8, t)
  };
}
function N0(t, e = t.calendar) {
  return {
    branding: C8,
    calendar: e,
    ...co(k8, t)
  };
}
function Wy(t, e = t.calendar) {
  return {
    branding: I8,
    calendar: e,
    ...co(k8, t)
  };
}
function sa(t) {
  return {
    branding: P8,
    ...co(XB, t)
  };
}
function vn(t) {
  return {
    branding: O8,
    sign: Mc(t),
    ...co(x8, t)
  };
}
function VS(t) {
  return OS(t.epochNanoseconds, el)[0];
}
function T2e(t) {
  return ((e, r = 1) => {
    const [n, i] = e, s = Math.floor(i / r), o = Fr / r;
    return BigInt(n) * BigInt(o) + BigInt(s);
  })(t.epochNanoseconds);
}
function Uj(t) {
  return t.epochNanoseconds;
}
function L2e(t, e, r, n, i) {
  const s = wh(n), [o, a] = ((E, A) => {
    const x = A((E = Hb(E, k4))[rF]);
    let g = swe(E);
    return g = _j(k4, g), [g, x];
  })(i, t), l = Math.max(o, s);
  if (!a && $0(l, a))
    return $I(n, o);
  if (!a)
    throw new RangeError(iv);
  if (!n.sign)
    return 0;
  const [c, p, h] = Yb(e, r, a), d = ZS(h), b = Zb(h), m = JS(h), w = b(p, c, n);
  rd(a) || (Ki(c), Ki(w));
  const f = m(p, c, w, o);
  return $0(o, a) ? $I(f, o) : ((E, A, x, g, v, k, S) => {
    const R = Mc(E), [L, F] = US(g, S8(x, E), x, R, v, k, S), z = HS(A, L, F);
    return E[wr[x]] + z * R;
  })(f, d(w), o, p, c, d, b);
}
function $I(t, e) {
  return Go(Nn(t), Wo[e], 1);
}
function US(t, e, r, n, i, s, o) {
  const a = wr[r], l = {
    ...e,
    [a]: e[a] + n
  }, c = o(t, i, e), p = o(t, i, l);
  return [s(c), s(p)];
}
function HS(t, e, r) {
  const n = Go(Ho(e, r));
  if (!n)
    throw new RangeError(Qd);
  return Go(Ho(e, t)) / n;
}
function M2e(t, e) {
  const [r, n, i] = Ub(e, 5, 1);
  return Ja(qb(t.epochNanoseconds, r, n, i, 1));
}
function N2e(t, e, r) {
  let { epochNanoseconds: n, timeZone: i, calendar: s } = e;
  const [o, a, l] = Ub(r);
  if (o === 0 && a === 1)
    return e;
  const c = t(i);
  if (o === 6)
    n = ((p, h, d, b) => {
      const m = vs(d, h), [w, f] = p(m), E = d.epochNanoseconds, A = nc(h, w), x = nc(h, f);
      if (Rj(E, A, x))
        throw new RangeError(Qd);
      return Qj(HS(E, A, x), b) ? x : A;
    })(Wj, c, e, l);
  else {
    const p = c.R(n);
    n = Hd(c, Hj(zd(n, p), o, a, l), p, 2, 0, 1);
  }
  return uo(n, i, s);
}
function D2e(t, e) {
  return ho(Hj(t, ...Ub(e)), t.calendar);
}
function $2e(t, e) {
  const [r, n, i] = Ub(e, 5);
  var s;
  return sa((s = i, GS(t, Hg(r, n), s)[0]));
}
function j2e(t, e) {
  const r = t(e.timeZone), n = vs(e, r), [i, s] = Wj(n), o = Go(Ho(nc(r, i), nc(r, s)), ov, 1);
  if (o <= 0)
    throw new RangeError(Qd);
  return o;
}
function B2e(t, e) {
  const { timeZone: r, calendar: n } = e, i = ((s, o, a) => nc(o, s(vs(a, o))))(qj, t(r), e);
  return uo(i, r, n);
}
function Hj(t, e, r, n) {
  return Gj(t, Hg(e, r), n);
}
function Gj(t, e, r) {
  const [n, i] = GS(t, e, r);
  return Ki({
    ...Vh(t, i),
    ...n
  });
}
function GS(t, e, r) {
  return Bb(rc(tc(t), e, r));
}
function qy(t) {
  return rc(t, sv, 7);
}
function Hg(t, e) {
  return Wo[t] * e;
}
function Wj(t) {
  const e = qj(t);
  return [e, Vh(e, 1)];
}
function qj(t) {
  return Hve(6, t);
}
function F2e(t, e, r) {
  const n = Math.min(wh(t), 6);
  return Gd(Qb(Nn(t, n), e, r), n);
}
function Wb(t, e, r, n, i, s, o, a, l, c) {
  if (n === 0 && i === 1)
    return t;
  const p = $0(n, a) ? rd(a) && n < 6 && r >= 6 ? V2e : z2e : U2e;
  let [h, d, b] = p(t, e, r, n, i, s, o, a, l, c);
  return b && n !== 7 && (h = ((m, w, f, E, A, x, g, v) => {
    const k = Mc(m);
    for (let S = E + 1; S <= f; S++) {
      if (S === 7 && f !== 7)
        continue;
      const R = S8(S, m);
      R[wr[S]] += k;
      const L = Go(Ho(g(v(A, x, R)), w));
      if (L && Math.sign(L) !== k)
        break;
      m = R;
    }
    return m;
  })(h, d, r, Math.max(6, n), o, a, l, c)), h;
}
function qb(t, e, r, n, i) {
  if (e === 6) {
    const s = ((o) => o[0] + o[1] / Fr)(t);
    return [rc(s, r, n), 0];
  }
  return Qb(t, Hg(e, r), n, i);
}
function Qb(t, e, r, n) {
  let [i, s] = t;
  n && s < 0 && (s += Fr, i -= 1);
  const [o, a] = Ea(rc(s, e, r), Fr);
  return PS(i + o, a);
}
function rc(t, e, r) {
  return Qj(t / e, r) * e;
}
function Qj(t, e) {
  return cwe[e](t);
}
function z2e(t, e, r, n, i, s) {
  const o = Mc(t), a = Nn(t), l = qb(a, n, i, s), c = Ho(a, l), p = Math.sign(l[0] - a[0]) === o, h = Gd(l, Math.min(r, 6));
  return [{
    ...t,
    ...h
  }, td(e, c), p];
}
function V2e(t, e, r, n, i, s, o, a, l, c) {
  const p = Mc(t) || 1, h = Go(Nn(t, 5)), d = Hg(n, i);
  let b = rc(h, d, s);
  const [m, w] = US(o, {
    ...t,
    ...E8
  }, 6, p, a, l, c), f = b - Go(Ho(m, w));
  let E = 0;
  f && Math.sign(f) !== p ? e = vh(m, b) : (E += p, b = rc(f, d, s), e = vh(w, b));
  const A = Jb(b);
  return [{
    ...t,
    ...A,
    days: t.days + E
  }, e, !!E];
}
function U2e(t, e, r, n, i, s, o, a, l, c) {
  const p = Mc(t), h = wr[n], d = S8(n, t);
  n === 7 && (t = {
    ...t,
    weeks: t.weeks + Math.trunc(t.days / 7)
  });
  const b = $b(t[h], i) * i;
  d[h] = b;
  const [m, w] = US(o, d, n, i * p, a, l, c), f = b + HS(e, m, w) * p * i, E = rc(f, i, s), A = Math.sign(E - f) === p;
  return d[h] = E, [d, A ? w : m, A];
}
function jI(t, e, r, n) {
  const [i, s, o, a] = ((c) => {
    const p = jS(c = ia(c));
    return [c.timeZone, ...p];
  })(n), l = i !== void 0;
  return ((c, p, h, d, b, m) => {
    h = Qb(h, b, d, 1);
    const w = p.R(h);
    return WS(zd(h, w), m) + (c ? Gg(qy(w)) : "Z");
  })(l, e(l ? t(i) : Wh), r.epochNanoseconds, s, o, a);
}
function BI(t, e, r) {
  const [n, i, s, o, a, l] = ((c) => {
    c = ia(c);
    const p = _8(c), h = zj(c), d = lwe(c), b = Xg(c, 4), m = Jg(c, 4);
    return [p, awe(c), d, b, ...Fj(m, h)];
  })(r);
  return ((c, p, h, d, b, m, w, f, E, A) => {
    d = Qb(d, E, f, 1);
    const x = c(h).R(d);
    return WS(zd(d, x), A) + Gg(qy(x), w) + ((g, v) => v !== 1 ? "[" + (v === 2 ? "!" : "") + g + "]" : "")(h, m) + qS(p, b);
  })(t, e.calendar, e.timeZone, e.epochNanoseconds, n, i, s, o, a, l);
}
function FI(t, e) {
  const [r, n, i, s] = ((c) => (c = ia(c), [_8(c), ...jS(c)]))(e);
  return o = t.calendar, a = r, l = s, WS(Gj(t, i, n), l) + qS(o, a);
  var o, a, l;
}
function zI(t, e) {
  return r = t.calendar, n = t, i = $S(e), Qy(n) + qS(r, i);
  var r, n, i;
}
function VI(t, e) {
  return Kj(t.calendar, Yj, t, $S(e));
}
function UI(t, e) {
  return Kj(t.calendar, H2e, t, $S(e));
}
function HI(t, e) {
  const [r, n, i] = Bj(e);
  return s = i, Zj(GS(t, n, r)[0], s);
  var s;
}
function O3(t, e) {
  const [r, n, i] = Bj(e, 3);
  return n > 1 && Uh(t = {
    ...t,
    ...F2e(t, n, r)
  }), ((s, o) => {
    const { sign: a } = s, l = a === -1 ? wi(s) : s, { hours: c, minutes: p } = l, [h, d] = OS(Nn(l, 3), Do, ec);
    tB(h);
    const b = QS(d, o), m = o >= 0 || !a || b;
    return (a < 0 ? "-" : "") + "P" + GI({
      Y: ku(l.years),
      M: ku(l.months),
      W: ku(l.weeks),
      D: ku(l.days)
    }) + (c || p || h || m ? "T" + GI({
      H: ku(c),
      M: ku(p),
      S: ku(h, m) + b
    }) : "");
  })(t, i);
}
function Kj(t, e, r, n) {
  const i = n > 1 || n === 0 && t !== ur;
  return n === 1 ? t === ur ? e(r) : Qy(r) : i ? Qy(r) + Jj(t, n === 2) : e(r);
}
function GI(t) {
  const e = [];
  for (const r in t) {
    const n = t[r];
    n && e.push(n, r);
  }
  return e.join("");
}
function WS(t, e) {
  return Qy(t) + "T" + Zj(t, e);
}
function Qy(t) {
  return Yj(t) + "-" + Vs(t.isoDay);
}
function Yj(t) {
  const { isoYear: e } = t;
  return (e < 0 || e > 9999 ? Xj(e) + Uy(6, Math.abs(e)) : Uy(4, e)) + "-" + Vs(t.isoMonth);
}
function H2e(t) {
  return Vs(t.isoMonth) + "-" + Vs(t.isoDay);
}
function Zj(t, e) {
  const r = [Vs(t.isoHour), Vs(t.isoMinute)];
  return e !== -1 && r.push(Vs(t.isoSecond) + ((n, i, s, o) => QS(n * el + i * Yg + s, o))(t.isoMillisecond, t.isoMicrosecond, t.isoNanosecond, e)), r.join(":");
}
function Gg(t, e = 0) {
  if (e === 1)
    return "";
  const [r, n] = Ea(Math.abs(t), ov), [i, s] = Ea(n, sv), [o, a] = Ea(s, Do);
  return Xj(t) + Vs(r) + ":" + Vs(i) + (o || a ? ":" + Vs(o) + QS(a) : "");
}
function qS(t, e) {
  return e !== 1 && (e > 1 || e === 0 && t !== ur) ? Jj(t, e === 2) : "";
}
function Jj(t, e) {
  return "[" + (e ? "!" : "") + "u-ca=" + t + "]";
}
function QS(t, e) {
  let r = Uy(9, t);
  return r = e === void 0 ? r.replace(pwe, "") : r.slice(0, e), r ? "." + r : "";
}
function Xj(t) {
  return t < 0 ? "-" : "+";
}
function ku(t, e) {
  return t || e ? t.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function G2e(t, e) {
  const { epochNanoseconds: r } = t, n = (e.R ? e : e(t.timeZone)).R(r), i = zd(r, n);
  return {
    calendar: t.calendar,
    ...i,
    offsetNanoseconds: n
  };
}
function Hd(t, e, r, n = 0, i = 0, s, o) {
  if (r !== void 0 && n === 1 && (n === 1 || o))
    return LS(e, r);
  const a = t.I(e);
  if (r !== void 0 && n !== 3) {
    const l = ((c, p, h, d) => {
      const b = Rn(p);
      d && (h = qy(h));
      for (const m of c) {
        let w = Go(Ho(m, b));
        if (d && (w = qy(w)), w === h)
          return m;
      }
    })(a, e, r, s);
    if (l !== void 0)
      return l;
    if (n === 0)
      throw new RangeError(kve);
  }
  return o ? Rn(e) : Wg(t, e, i, a);
}
function Wg(t, e, r = 0, n = t.I(e)) {
  if (n.length === 1)
    return n[0];
  if (r === 1)
    throw new RangeError(_ve);
  if (n.length)
    return n[r === 3 ? 1 : 0];
  const i = Rn(e), s = ((a, l) => {
    const c = a.R(vh(l, -864e11));
    return ((p) => {
      if (p > Fr)
        throw new RangeError(Ave);
      return p;
    })(a.R(vh(l, Fr)) - c);
  })(t, i), o = s * (r === 2 ? -1 : 1);
  return (n = t.I(zd(i, o)))[r === 2 ? 0 : n.length - 1];
}
function nc(t, e) {
  const r = t.I(e);
  if (r.length)
    return r[0];
  const n = vh(Rn(e), -864e11);
  return t.O(n, 1);
}
function WI(t, e, r) {
  return Ja(na(td(e.epochNanoseconds, ((n) => {
    if (rB(n))
      throw new RangeError(Pve);
    return Nn(n, 5);
  })(t ? wi(r) : r))));
}
function qI(t, e, r, n, i, s = /* @__PURE__ */ Object.create(null)) {
  const o = e(n.timeZone), a = t(n.calendar);
  return {
    ...n,
    ...KS(o, a, n, r ? wi(i) : i, s)
  };
}
function QI(t, e, r, n, i = /* @__PURE__ */ Object.create(null)) {
  const { calendar: s } = r;
  return ho(YS(t(s), r, e ? wi(n) : n, i), s);
}
function KI(t, e, r, n, i) {
  const { calendar: s } = r;
  return Xa(Kb(t(s), r, e ? wi(n) : n, i), s);
}
function YI(t, e, r, n, i) {
  const s = r.calendar, o = t(s);
  let a = zs(D0(o, r));
  e && (n = XS(n)), n.sign < 0 && (a = o.P(a, {
    ...Dn,
    months: 1
  }), a = Vh(a, -1));
  const l = o.P(a, n, i);
  return N0(D0(o, l), s);
}
function ZI(t, e, r) {
  return sa(eB(e, t ? wi(r) : r)[0]);
}
function KS(t, e, r, n, i) {
  const s = Nn(n, 5);
  let o = r.epochNanoseconds;
  if (rB(n)) {
    const a = vs(r, t);
    o = td(Wg(t, {
      ...Kb(e, a, {
        ...n,
        ...E8
      }, i),
      ...co(po, a)
    }), s);
  } else
    o = td(o, s), mr(i);
  return {
    epochNanoseconds: na(o)
  };
}
function YS(t, e, r, n) {
  const [i, s] = eB(e, r);
  return Ki({
    ...Kb(t, e, {
      ...r,
      ...E8,
      days: r.days + s
    }, n),
    ...i
  });
}
function Kb(t, e, r, n) {
  if (r.years || r.months || r.weeks)
    return t.P(e, r, n);
  mr(n);
  const i = r.days + Nn(r, 5)[0];
  return i ? zs(Vh(e, i)) : e;
}
function D0(t, e, r = 1) {
  return Vh(e, r - t.day(e));
}
function eB(t, e) {
  const [r, n] = Nn(e, 5), [i, s] = Bb(tc(t) + n);
  return [i, r + s];
}
function Vh(t, e) {
  return e ? {
    ...t,
    ...Fb(ui(t) + e * Fi)
  } : t;
}
function Yb(t, e, r) {
  const n = t(r.calendar);
  return rd(r) ? [r, n, e(r.timeZone)] : [{
    ...r,
    ...Yi
  }, n];
}
function ZS(t) {
  return t ? Uj : Rn;
}
function Zb(t) {
  return t ? ir(KS, t) : YS;
}
function JS(t) {
  return t ? ir(gbe, t) : mbe;
}
function rd(t) {
  return t && t.epochNanoseconds;
}
function $0(t, e) {
  return t <= 6 - (rd(e) ? 1 : 0);
}
function JI(t, e, r, n, i, s, o) {
  const a = t(ia(o).relativeTo), l = Math.max(wh(i), wh(s));
  if ($0(l, a))
    return vn(Uh(((w, f, E, A) => {
      const x = td(Nn(w), Nn(f), A ? -1 : 1);
      if (!Number.isFinite(x[0]))
        throw new RangeError(Bc);
      return {
        ...Dn,
        ...Gd(x, E)
      };
    })(i, s, l, n)));
  if (!a)
    throw new RangeError(iv);
  n && (s = wi(s));
  const [c, p, h] = Yb(e, r, a), d = Zb(h), b = JS(h), m = d(p, c, i);
  return vn(b(p, c, d(p, m, s), l));
}
function W2e(t, e, r, n, i) {
  const s = wh(n), [o, a, l, c, p] = ((k, S, R) => {
    k = Hb(k, Zy);
    let L = iF(k);
    const F = R(k[rF]);
    let z = BS(k);
    const j = Xg(k, 7);
    let ee = Jg(k);
    if (L === void 0 && ee === void 0)
      throw new RangeError(Rve);
    if (ee == null && (ee = 0), L == null && (L = Math.max(ee, S)), Vj(L, ee), z = FS(z, ee, 1), z > 1 && ee > 5 && L !== ee)
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    return [L, ee, z, j, F];
  })(i, s, t), h = Math.max(s, o);
  if (!p && h <= 6)
    return vn(Uh(((k, S, R, L, F) => {
      const z = qb(Nn(k), R, L, F);
      return {
        ...Dn,
        ...Gd(z, S)
      };
    })(n, o, a, l, c)));
  if (!rd(p) && !n.sign)
    return n;
  if (!p)
    throw new RangeError(iv);
  const [d, b, m] = Yb(e, r, p), w = ZS(m), f = Zb(m), E = JS(m), A = f(b, d, n);
  rd(p) || (Ki(d), Ki(A));
  let x = E(b, d, A, o);
  const g = n.sign, v = Mc(x);
  if (g && v && g !== v)
    throw new RangeError(Qd);
  return x = Wb(x, w(A), o, a, l, c, b, d, w, f), vn(x);
}
function q2e(t) {
  return t.sign === -1 ? XS(t) : t;
}
function XS(t) {
  return vn(wi(t));
}
function wi(t) {
  const e = {};
  for (const r of wr)
    e[r] = -1 * t[r] || 0;
  return e;
}
function Q2e(t) {
  return !t.sign;
}
function Mc(t, e = wr) {
  let r = 0;
  for (const n of e) {
    const i = Math.sign(t[n]);
    if (i) {
      if (r && r !== i)
        throw new RangeError(Ive);
      r = i;
    }
  }
  return r;
}
function Uh(t) {
  for (const e of zve)
    Da(e, t[e], -4294967295, dwe, 1);
  return tB(Go(Nn(t), Do)), t;
}
function tB(t) {
  if (!Number.isSafeInteger(t))
    throw new RangeError(Cve);
}
function Nn(t, e = 6) {
  return Aj(t, e, wr);
}
function Gd(t, e = 6) {
  const [r, n] = t, i = jb(n, e, wr);
  if (i[wr[e]] += r * (Fr / Wo[e]), !Number.isFinite(i[wr[e]]))
    throw new RangeError(Bc);
  return i;
}
function Jb(t, e = 5) {
  return jb(t, e, wr);
}
function rB(t) {
  return !!Mc(t, JB);
}
function wh(t) {
  let e = 9;
  for (; e > 0 && !t[wr[e]]; e--)
    ;
  return e;
}
function K2e(t, e) {
  return [t, e];
}
function XI(t) {
  const e = Math.floor(t / O1) * O1;
  return [e, e + O1];
}
function Y2e(t) {
  const e = Nc(t = P1(t));
  if (!e)
    throw new RangeError(Di(t));
  let r;
  if (e.j)
    r = 0;
  else {
    if (!e.offset)
      throw new RangeError(Di(t));
    r = Hh(e.offset);
  }
  return e.timeZone && i8(e.timeZone, 1), Ja(LS(zb(e), r));
}
function Z2e(t) {
  const e = Nc(Xn(t));
  if (!e)
    throw new RangeError(Di(t));
  if (e.timeZone)
    return nB(e, e.offset ? Hh(e.offset) : void 0);
  if (e.j)
    throw new RangeError(Di(t));
  return sB(e);
}
function J2e(t, e) {
  const r = Nc(Xn(t));
  if (!r || !r.timeZone)
    throw new RangeError(Di(t));
  const { offset: n } = r, i = n ? Hh(n) : void 0, [, s, o] = Vb(e);
  return nB(r, i, s, o);
}
function Hh(t) {
  const e = i8(t);
  if (e === void 0)
    throw new RangeError(Di(t));
  return e;
}
function X2e(t) {
  const e = Nc(Xn(t));
  if (!e || e.j)
    throw new RangeError(Di(t));
  return ho(iB(e));
}
function e8(t, e, r) {
  let n = Nc(Xn(t));
  if (!n || n.j)
    throw new RangeError(Di(t));
  return e ? n.calendar === ur && (n = n.isoYear === -271821 && n.isoMonth === 4 ? {
    ...n,
    isoDay: 20,
    ...Yi
  } : {
    ...n,
    isoDay: 1,
    ...Yi
  }) : r && n.calendar === ur && (n = {
    ...n,
    isoYear: Aa
  }), Xa(n.C ? iB(n) : sB(n));
}
function ebe(t, e) {
  const r = r8(Xn(e));
  if (r)
    return t8(r), N0(TS(zh(r)));
  const n = e8(e, 1);
  return N0(D0(t(n.calendar), n));
}
function t8(t) {
  if (t.calendar !== ur)
    throw new RangeError(Sa(t.calendar));
}
function tbe(t, e) {
  const r = n8(Xn(e));
  if (r)
    return t8(r), Wy(zh(r));
  const n = e8(e, 0, 1), { calendar: i } = n, s = t(i), [o, a, l] = s.v(n), [c, p] = s.q(o, a), [h, d] = s.G(c, p, l);
  return Wy(zs(s.V(h, d, l)), i);
}
function rbe(t) {
  let e, r = ((n) => {
    const i = wwe.exec(n);
    return i ? (Xb(i[10]), lB(i)) : void 0;
  })(Xn(t));
  if (!r) {
    if (r = Nc(t), !r)
      throw new RangeError(Di(t));
    if (!r.C)
      throw new RangeError(Di(t));
    if (r.j)
      throw new RangeError(Sa("Z"));
    t8(r);
  }
  if ((e = r8(t)) && DI(e))
    throw new RangeError(Di(t));
  if ((e = n8(t)) && DI(e))
    throw new RangeError(Di(t));
  return sa(Vd(r, 1));
}
function nbe(t) {
  const e = ((r) => {
    const n = Swe.exec(r);
    return n ? ((i) => {
      function s(p, h, d) {
        let b = 0, m = 0;
        if (d && ([b, l] = Ea(l, Wo[d])), p !== void 0) {
          if (a)
            throw new RangeError(Sa(p));
          m = ((w) => {
            const f = parseInt(w);
            if (!Number.isFinite(f))
              throw new RangeError(Sa(w));
            return f;
          })(p), o = 1, h && (l = s8(h) * (Wo[d] / Do), a = 1);
        }
        return b + m;
      }
      let o = 0, a = 0, l = 0, c = {
        ...Bd(wr, [s(i[2]), s(i[3]), s(i[4]), s(i[5]), s(i[6], i[7], 5), s(i[8], i[9], 4), s(i[10], i[11], 3)]),
        ...jb(l, 2, wr)
      };
      if (!o)
        throw new RangeError(NB(wr));
      return o8(i[1]) < 0 && (c = wi(c)), c;
    })(n) : void 0;
  })(Xn(t));
  if (!e)
    throw new RangeError(Di(t));
  return vn(Uh(e));
}
function ibe(t) {
  const e = Nc(t) || r8(t) || n8(t);
  return e ? e.calendar : t;
}
function sbe(t) {
  const e = Nc(t);
  return e && (e.timeZone || e.j && Wh || e.offset) || t;
}
function nB(t, e, r = 0, n = 0) {
  const i = a8(t.timeZone), s = Kt(i);
  let o;
  return zb(t), o = t.C ? Hd(s, t, e, r, n, !s.$, t.j) : nc(s, t), uo(o, i, nv(t.calendar));
}
function iB(t) {
  return oB(Ki(zb(t)));
}
function sB(t) {
  return oB(zs(zh(t)));
}
function oB(t) {
  return {
    ...t,
    calendar: nv(t.calendar)
  };
}
function Nc(t) {
  const e = vwe.exec(t);
  return e ? ((r) => {
    const n = r[10], i = (n || "").toUpperCase() === "Z";
    return {
      isoYear: aB(r),
      isoMonth: parseInt(r[4]),
      isoDay: parseInt(r[5]),
      ...lB(r.slice(5)),
      ...Xb(r[16]),
      C: !!r[6],
      j: i,
      offset: i ? void 0 : n
    };
  })(e) : void 0;
}
function r8(t) {
  const e = ywe.exec(t);
  return e ? ((r) => ({
    isoYear: aB(r),
    isoMonth: parseInt(r[4]),
    isoDay: 1,
    ...Xb(r[5])
  }))(e) : void 0;
}
function n8(t) {
  const e = bwe.exec(t);
  return e ? ((r) => ({
    isoYear: Aa,
    isoMonth: parseInt(r[1]),
    isoDay: parseInt(r[2]),
    ...Xb(r[3])
  }))(e) : void 0;
}
function i8(t, e) {
  const r = xwe.exec(t);
  return r ? ((n, i) => {
    const s = n[4] || n[5];
    if (i && s)
      throw new RangeError(Sa(s));
    return ((o) => {
      if (Math.abs(o) >= Fr)
        throw new RangeError(Sve);
      return o;
    })(($p(n[2]) * ov + $p(n[3]) * sv + $p(n[4]) * Do + s8(n[5] || "")) * o8(n[1]));
  })(r, e) : void 0;
}
function aB(t) {
  const e = o8(t[1]), r = parseInt(t[2] || t[3]);
  if (e < 0 && !r)
    throw new RangeError(Sa(-0));
  return e * r;
}
function lB(t) {
  const e = $p(t[3]);
  return {
    ...Bb(s8(t[4] || ""))[0],
    isoHour: $p(t[1]),
    isoMinute: $p(t[2]),
    isoSecond: e === 60 ? 59 : e
  };
}
function Xb(t) {
  let e, r;
  const n = [];
  if (t.replace(Ewe, (i, s, o) => {
    const a = !!s, [l, c] = o.split("=").reverse();
    if (c) {
      if (c === "u-ca")
        n.push(l), e || (e = a);
      else if (a || /[A-Z]/.test(c))
        throw new RangeError(Sa(i));
    } else {
      if (r)
        throw new RangeError(Sa(i));
      r = l;
    }
    return "";
  }), n.length > 1 && e)
    throw new RangeError(Sa(t));
  return {
    timeZone: r,
    calendar: n[0] || ur
  };
}
function s8(t) {
  return parseInt(t.padEnd(9, "0"));
}
function Wd(t) {
  return new RegExp(`^${t}$`, "i");
}
function o8(t) {
  return t && t !== "+" ? -1 : 1;
}
function $p(t) {
  return t === void 0 ? 0 : parseInt(t);
}
function obe(t) {
  return a8(Xn(t));
}
function a8(t) {
  const e = l8(t);
  return typeof e == "number" ? Gg(e) : e ? ((r) => {
    if (_we.test(r))
      throw new RangeError(FB(r));
    if (kwe.test(r))
      throw new RangeError(Eve);
    return r.toLowerCase().split("/").map((n, i) => (n.length <= 3 || /\d/.test(n)) && !/etc|yap/.test(n) ? n.toUpperCase() : n.replace(/baja|dumont|[a-z]+/g, (s, o) => s.length <= 2 && !i || s === "in" || s === "chat" ? s.toUpperCase() : s.length > 2 || !o ? LI(s).replace(/island|noronha|murdo|rivadavia|urville/, LI) : s)).join("/");
  })(t) : Wh;
}
function eP(t) {
  const e = l8(t);
  return typeof e == "number" ? e : e ? e.resolvedOptions().timeZone : Wh;
}
function l8(t) {
  const e = i8(t = t.toUpperCase(), 1);
  return e !== void 0 ? e : t !== Wh ? Awe(t) : void 0;
}
function cB(t, e) {
  return ys(t.epochNanoseconds, e.epochNanoseconds);
}
function uB(t, e) {
  return ys(t.epochNanoseconds, e.epochNanoseconds);
}
function abe(t, e, r, n, i, s) {
  const o = t(ia(s).relativeTo), a = Math.max(wh(n), wh(i));
  if (Ej(wr, n, i))
    return 0;
  if ($0(a, o))
    return ys(Nn(n), Nn(i));
  if (!o)
    throw new RangeError(iv);
  const [l, c, p] = Yb(e, r, o), h = ZS(p), d = Zb(p);
  return ys(h(d(c, l, n)), h(d(c, l, i)));
}
function hB(t, e) {
  return qd(t, e) || c8(t, e);
}
function qd(t, e) {
  return Fl(ui(t), ui(e));
}
function c8(t, e) {
  return Fl(tc(t), tc(e));
}
function lbe(t, e) {
  return !cB(t, e);
}
function cbe(t, e) {
  return !uB(t, e) && !!pB(t.timeZone, e.timeZone) && t.calendar === e.calendar;
}
function ube(t, e) {
  return !hB(t, e) && t.calendar === e.calendar;
}
function hbe(t, e) {
  return !qd(t, e) && t.calendar === e.calendar;
}
function pbe(t, e) {
  return !qd(t, e) && t.calendar === e.calendar;
}
function dbe(t, e) {
  return !qd(t, e) && t.calendar === e.calendar;
}
function fbe(t, e) {
  return !c8(t, e);
}
function pB(t, e) {
  if (t === e)
    return 1;
  try {
    return eP(t) === eP(e);
  } catch {
  }
}
function tP(t, e, r, n) {
  const i = Ud(t, n, 3, 5), s = ev(e.epochNanoseconds, r.epochNanoseconds, ...i);
  return vn(t ? wi(s) : s);
}
function rP(t, e, r, n, i, s) {
  const o = rv(n.calendar, i.calendar), [a, l, c, p] = Ud(r, s, 5), h = n.epochNanoseconds, d = i.epochNanoseconds, b = ys(d, h);
  let m;
  if (b)
    if (a < 6)
      m = ev(h, d, a, l, c, p);
    else {
      const w = e(((E, A) => {
        if (!pB(E, A))
          throw new RangeError(zB);
        return E;
      })(n.timeZone, i.timeZone)), f = t(o);
      m = fB(f, w, n, i, b, a, s), m = Wb(m, d, a, l, c, p, f, n, Uj, ir(KS, w));
    }
  else
    m = Dn;
  return vn(r ? wi(m) : m);
}
function nP(t, e, r, n, i) {
  const s = rv(r.calendar, n.calendar), [o, a, l, c] = Ud(e, i, 6), p = Rn(r), h = Rn(n), d = ys(h, p);
  let b;
  if (d)
    if (o <= 6)
      b = ev(p, h, o, a, l, c);
    else {
      const m = t(s);
      b = gB(m, r, n, d, o, i), b = Wb(b, h, o, a, l, c, m, r, Rn, YS);
    }
  else
    b = Dn;
  return vn(e ? wi(b) : b);
}
function iP(t, e, r, n, i) {
  const s = rv(r.calendar, n.calendar);
  return dB(e, () => t(s), r, n, ...Ud(e, i, 6, 9, 6));
}
function sP(t, e, r, n, i) {
  const s = rv(r.calendar, n.calendar), o = Ud(e, i, 9, 9, 8), a = t(s), l = D0(a, r), c = D0(a, n);
  return l.isoYear === c.isoYear && l.isoMonth === c.isoMonth && l.isoDay === c.isoDay ? vn(Dn) : dB(e, () => a, zs(l), zs(c), ...o, 8);
}
function dB(t, e, r, n, i, s, o, a, l = 6) {
  const c = Rn(r), p = Rn(n);
  if (c === void 0 || p === void 0)
    throw new RangeError(Bc);
  let h;
  if (ys(p, c))
    if (i === 6)
      h = ev(c, p, i, s, o, a);
    else {
      const d = e();
      h = d.N(r, n, i), s === l && o === 1 || (h = Wb(h, p, i, s, o, a, d, r, Rn, Kb));
    }
  else
    h = Dn;
  return vn(t ? wi(h) : h);
}
function oP(t, e, r, n) {
  const [i, s, o, a] = Ud(t, n, 5, 5), l = rc(u8(e, r), Hg(s, o), a), c = {
    ...Dn,
    ...Jb(l, i)
  };
  return vn(t ? wi(c) : c);
}
function gbe(t, e, r, n, i, s) {
  const o = ys(n.epochNanoseconds, r.epochNanoseconds);
  return o ? i < 6 ? mB(r.epochNanoseconds, n.epochNanoseconds, i) : fB(e, t, r, n, o, i, s) : Dn;
}
function mbe(t, e, r, n, i) {
  const s = Rn(e), o = Rn(r), a = ys(o, s);
  return a ? n <= 6 ? mB(s, o, n) : gB(t, e, r, a, n, i) : Dn;
}
function fB(t, e, r, n, i, s, o) {
  const [a, l, c] = ((d, b, m, w) => {
    function f() {
      return S = {
        ...Vh(x, v++ * -w),
        ...A
      }, R = Wg(d, S), ys(g, R) === -w;
    }
    const E = vs(b, d), A = co(po, E), x = vs(m, d), g = m.epochNanoseconds;
    let v = 0;
    const k = u8(E, x);
    let S, R;
    if (Math.sign(k) === -w && v++, f() && (w === -1 || f()))
      throw new RangeError(Qd);
    const L = Go(Ho(R, g));
    return [E, S, L];
  })(e, r, n, i);
  var p, h;
  return {
    ...s === 6 ? (p = a, h = l, {
      ...Dn,
      days: yB(p, h)
    }) : t.N(a, l, s, o),
    ...Jb(c)
  };
}
function gB(t, e, r, n, i, s) {
  const [o, a, l] = ((c, p, h) => {
    let d = p, b = u8(c, p);
    return Math.sign(b) === -h && (d = Vh(p, -h), b += Fr * h), [c, d, b];
  })(e, r, n);
  return {
    ...t.N(o, a, i, s),
    ...Jb(l)
  };
}
function ev(t, e, r, n, i, s) {
  return {
    ...Dn,
    ...Gd(qb(Ho(t, e), n, i, s), r)
  };
}
function mB(t, e, r) {
  return {
    ...Dn,
    ...Gd(Ho(t, e), r)
  };
}
function yB(t, e) {
  return tv(ui(t), ui(e));
}
function tv(t, e) {
  return Math.trunc((e - t) / Fi);
}
function u8(t, e) {
  return tc(e) - tc(t);
}
function rv(t, e) {
  if (t !== e)
    throw new RangeError(BB);
  return t;
}
function bB(t) {
  return this.m(t)[0];
}
function vB(t) {
  return this.m(t)[1];
}
function h8(t) {
  const [e] = this.v(t);
  return tv(this.p(e), ui(t)) + 1;
}
function p8(t) {
  const e = Cwe.exec(t);
  if (!e)
    throw new RangeError(wve(t));
  return [parseInt(e[1]), !!e[2]];
}
function qg(t, e) {
  return "M" + Vs(t) + (e ? "L" : "");
}
function Ky(t, e, r) {
  return t + (e || r && t >= r ? 1 : 0);
}
function d8(t, e) {
  return t - (e && t >= e ? 1 : 0);
}
function wB(t, e) {
  return (e + t) * (Math.sign(e) || 1) || 0;
}
function v4(t) {
  return YB[EB(t)];
}
function xB(t) {
  return $ve[EB(t)];
}
function EB(t) {
  return xh(t.id || ur);
}
function ybe(t) {
  function e(i) {
    return ((s, o) => ({
      ...SB(s, o),
      o: s.month,
      day: parseInt(s.day)
    }))(MS(r, i), n);
  }
  const r = N8(t), n = xh(t);
  return {
    id: t,
    h: bbe(e),
    l: vbe(e)
  };
}
function bbe(t) {
  return ms((e) => {
    const r = ui(e);
    return t(r);
  }, WeakMap);
}
function vbe(t) {
  const e = t(0).year - Qve;
  return ms((r) => {
    let n, i = Fd(r - e), s = 0;
    const o = [], a = [];
    do
      i += 400 * Fi;
    while ((n = t(i)).year <= r);
    do
      if (i += (1 - n.day) * Fi, n.year === r && (o.push(i), a.push(n.o)), i -= Fi, ++s > 100 || i < -864e13)
        throw new RangeError(Qd);
    while ((n = t(i)).year >= r);
    return {
      i: o.reverse(),
      u: VB(a.reverse())
    };
  });
}
function SB(t, e) {
  let r, n, i = AB(t);
  if (t.era) {
    const s = YB[e], o = ZB[e] || {};
    s !== void 0 && (r = e === "islamic" ? "ah" : t.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), r === "bc" || r === "b" ? r = "bce" : r === "ad" || r === "a" ? r = "ce" : r === "beforeroc" && (r = "broc"), r = o[r] || r, n = i, i = wB(n, s[r] || 0));
  }
  return {
    era: r,
    eraYear: n,
    year: i
  };
}
function AB(t) {
  return parseInt(t.relatedYear || t.year);
}
function Yy(t) {
  const { year: e, o: r, day: n } = this.h(t), { u: i } = this.l(e);
  return [e, i[r] + 1, n];
}
function j0(t, e = 1, r = 1) {
  return this.l(t).i[e - 1] + (r - 1) * Fi;
}
function kB(t, e) {
  const r = R1.call(this, t);
  return [d8(e, r), r === e];
}
function R1(t) {
  const e = lP(this, t), r = lP(this, t - 1), n = e.length;
  if (n > r.length) {
    const i = xB(this);
    if (i < 0)
      return -i;
    for (let s = 0; s < n; s++)
      if (e[s] !== r[s])
        return s + 1;
  }
}
function Gm(t) {
  return tv(j0.call(this, t), j0.call(this, t + 1));
}
function aP(t, e) {
  const { i: r } = this.l(t);
  let n = e + 1, i = r;
  return n > r.length && (n = 1, i = this.l(t + 1).i), tv(r[e - 1], i[n - 1]);
}
function Wm(t) {
  return this.l(t).i.length;
}
function _B(t) {
  const e = this.h(t);
  return [e.era, e.eraYear];
}
function lP(t, e) {
  return Object.keys(t.l(e).u);
}
function Qg(t) {
  return nv(Xn(t));
}
function nv(t) {
  if ((t = t.toLowerCase()) !== ur && t !== Kd) {
    const e = N8(t).resolvedOptions().calendar;
    if (xh(t) !== xh(e))
      throw new RangeError(jB(t));
    return e;
  }
  return t;
}
function xh(t) {
  return t === "islamicc" && (t = "islamic"), t.split("-")[0];
}
function CB(t, e) {
  return (r) => r === ur ? t : r === Kd || r === ic ? Object.assign(Object.create(t), {
    id: r
  }) : Object.assign(Object.create(e), Iwe(r));
}
function wbe(t, e, r, n) {
  const i = Dc(r, n, rl, [], WB);
  if (i.timeZone !== void 0) {
    const s = r.F(i), o = Kg(i), a = t(i.timeZone);
    return {
      epochNanoseconds: Hd(e(a), {
        ...s,
        ...o
      }, i.offset !== void 0 ? Hh(i.offset) : void 0),
      timeZone: a
    };
  }
  return {
    ...r.F(i),
    ...Yi
  };
}
function xbe(t, e, r, n, i, s) {
  const o = Dc(r, i, rl, HB, WB), a = t(o.timeZone), [l, c, p] = Vb(s), h = r.F(o, Gb(l)), d = Kg(o, l);
  return uo(Hd(e(a), {
    ...h,
    ...d
  }, o.offset !== void 0 ? Hh(o.offset) : void 0, c, p), a, n);
}
function Ebe(t, e, r) {
  const n = Dc(t, e, rl, [], tl), i = mr(r);
  return ho(Ki({
    ...t.F(n, Gb(i)),
    ...Kg(n, i)
  }));
}
function Sbe(t, e, r, n = []) {
  const i = Dc(t, e, rl, n);
  return t.F(i, r);
}
function Abe(t, e, r, n) {
  const i = Dc(t, e, w8, n);
  return t.K(i, r);
}
function kbe(t, e, r, n) {
  const i = Dc(t, r, rl, Zg);
  return e && i.month !== void 0 && i.monthCode === void 0 && i.year === void 0 && (i.year = Aa), t._(i, n);
}
function _be(t, e) {
  return sa(Kg(bs(t, S4, [], 1), mr(e)));
}
function Cbe(t) {
  const e = bs(t, x8);
  return vn(Uh({
    ...Dn,
    ...e
  }));
}
function Dc(t, e, r, n = [], i = []) {
  return bs(e, [...t.fields(r), ...i].sort(), n);
}
function bs(t, e, r, n = !r) {
  const i = {};
  let s, o = 0;
  for (const a of e) {
    if (a === s)
      throw new RangeError(pve(a));
    if (a === "constructor" || a === "__proto__")
      throw new RangeError(hve(a));
    let l = t[a];
    if (l !== void 0)
      o = 1, cP[a] && (l = cP[a](l, a)), i[a] = l;
    else if (r) {
      if (r.includes(a))
        throw new TypeError(g8(a));
      i[a] = KB[a];
    }
    s = a;
  }
  if (n && !o)
    throw new TypeError(NB(e));
  return i;
}
function Kg(t, e) {
  return Vd(D8({
    ...KB,
    ...t
  }), e);
}
function Ibe(t, e, r, n, i) {
  const { calendar: s, timeZone: o } = r, a = t(s), l = e(o), c = [...a.fields(rl), ...GB].sort(), p = ((E) => {
    const A = vs(E, Kt), x = Gg(A.offsetNanoseconds), g = cv(E.calendar), [v, k, S] = g.v(A), [R, L] = g.q(v, k), F = qg(R, L);
    return {
      ...Dwe(A),
      year: v,
      monthCode: F,
      day: S,
      offset: x
    };
  })(r), h = bs(n, c), d = a.k(p, h), b = {
    ...p,
    ...h
  }, [m, w, f] = Vb(i, 2);
  return uo(Hd(l, {
    ...a.F(d, Gb(m)),
    ...Vd(D8(b), m)
  }, Hh(b.offset), w, f), o, s);
}
function Pbe(t, e, r, n) {
  const i = t(e.calendar), s = [...i.fields(rl), ...tl].sort(), o = {
    ...PB(a = e),
    hour: a.isoHour,
    minute: a.isoMinute,
    second: a.isoSecond,
    millisecond: a.isoMillisecond,
    microsecond: a.isoMicrosecond,
    nanosecond: a.isoNanosecond
  };
  var a;
  const l = bs(r, s), c = mr(n), p = i.k(o, l), h = {
    ...o,
    ...l
  };
  return ho(Ki({
    ...i.F(p, Gb(c)),
    ...Vd(D8(h), c)
  }));
}
function Rbe(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(rl).sort(), o = PB(e), a = bs(r, s), l = i.k(o, a);
  return i.F(l, n);
}
function Obe(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(w8).sort(), o = ((c) => {
    const p = cv(c.calendar), [h, d] = p.v(c), [b, m] = p.q(h, d);
    return {
      year: h,
      monthCode: qg(b, m)
    };
  })(e), a = bs(r, s), l = i.k(o, a);
  return i.K(l, n);
}
function Tbe(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(rl).sort(), o = ((c) => {
    const p = cv(c.calendar), [h, d, b] = p.v(c), [m, w] = p.q(h, d);
    return {
      monthCode: qg(m, w),
      day: b
    };
  })(e), a = bs(r, s), l = i.k(o, a);
  return i._(l, n);
}
function Lbe(t, e, r) {
  return sa(((n, i, s) => Kg({
    ...co(S4, n),
    ...bs(i, S4)
  }, mr(s)))(t, e, r));
}
function Mbe(t, e) {
  return vn((r = t, n = e, Uh({
    ...r,
    ...bs(n, x8)
  })));
  var r, n;
}
function IB(t, e, r, n, i) {
  e = co(r = t.fields(r), e), n = bs(n, i = t.fields(i), []);
  let s = t.k(e, n);
  return s = bs(s, [...r, ...i].sort(), []), t.F(s);
}
function T3(t, e) {
  const r = v4(t), n = ZB[t.id || ""] || {};
  let { era: i, eraYear: s, year: o } = e;
  if (i !== void 0 || s !== void 0) {
    if (i === void 0 || s === void 0)
      throw new TypeError(mve);
    if (!r)
      throw new RangeError(gve);
    const a = r[n[i] || i];
    if (a === void 0)
      throw new RangeError(bve(i));
    const l = wB(s, a);
    if (o !== void 0 && o !== l)
      throw new RangeError(yve);
    o = l;
  } else if (o === void 0)
    throw new TypeError(vve(r));
  return o;
}
function qm(t, e, r, n) {
  let { month: i, monthCode: s } = e;
  if (s !== void 0) {
    const o = ((a, l, c, p) => {
      const h = a.L(c), [d, b] = p8(l);
      let m = Ky(d, b, h);
      if (b) {
        const w = xB(a);
        if (w === void 0)
          throw new RangeError(Af);
        if (w > 0) {
          if (m > w)
            throw new RangeError(Af);
          if (h === void 0) {
            if (p === 1)
              throw new RangeError(Af);
            m--;
          }
        } else {
          if (m !== -w)
            throw new RangeError(Af);
          if (h === void 0 && p === 1)
            throw new RangeError(Af);
        }
      }
      return m;
    })(t, s, r, n);
    if (i !== void 0 && i !== o)
      throw new RangeError(xve);
    i = o, n = 1;
  } else if (i === void 0)
    throw new TypeError($B);
  return Da("month", i, 1, t.B(r), n);
}
function L3(t, e, r, n, i) {
  return Li(e, "day", 1, t.U(n, r), i);
}
function M3(t, e, r, n) {
  let i = 0;
  const s = [];
  for (const o of r)
    e[o] !== void 0 ? i = 1 : s.push(o);
  if (Object.assign(t, e), i)
    for (const o of n || s)
      delete t[o];
}
function PB(t) {
  const e = cv(t.calendar), [r, n, i] = e.v(t), [s, o] = e.q(r, n);
  return {
    year: r,
    monthCode: qg(s, o),
    day: i
  };
}
function Nbe(t) {
  return Ja(na(RS(CS(t))));
}
function Dbe(t, e, r, n, i = ur) {
  return uo(na(RS(CS(r))), e(n), t(i));
}
function $be(t, e, r, n, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, p = ur) {
  return ho(Ki(zb($a(si, Bd(av, [e, r, n, i, s, o, a, l, c])))), t(p));
}
function jbe(t, e, r, n, i = ur) {
  return Xa(zs(zh($a(si, {
    isoYear: e,
    isoMonth: r,
    isoDay: n
  }))), t(i));
}
function Bbe(t, e, r, n = ur, i = 1) {
  const s = si(e), o = si(r), a = t(n);
  return N0(TS(zh({
    isoYear: s,
    isoMonth: o,
    isoDay: si(i)
  })), a);
}
function Fbe(t, e, r, n = ur, i = Aa) {
  const s = si(e), o = si(r), a = t(n);
  return Wy(zs(zh({
    isoYear: si(i),
    isoMonth: s,
    isoDay: o
  })), a);
}
function zbe(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0) {
  return sa(Vd($a(si, Bd(po, [t, e, r, n, i, s])), 1));
}
function Vbe(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0) {
  return vn(Uh($a(IS, Bd(wr, [t, e, r, n, i, s, o, a, l, c]))));
}
function Ube(t, e, r = ur) {
  return uo(t.epochNanoseconds, e, r);
}
function Hbe(t) {
  return Ja(t.epochNanoseconds);
}
function RB(t, e) {
  return ho(vs(e, t));
}
function OB(t, e) {
  return Xa(vs(e, t));
}
function TB(t, e) {
  return sa(vs(e, t));
}
function Gbe(t, e, r, n) {
  const i = ((s, o, a, l) => {
    const c = ((p) => oF(ia(p)))(l);
    return Wg(s(o), a, c);
  })(t, r, e, n);
  return uo(na(i), r, e.calendar);
}
function Wbe(t, e, r, n, i) {
  const s = t(i.timeZone), o = i.plainTime, a = o !== void 0 ? e(o) : void 0, l = r(s);
  let c;
  return c = a ? Wg(l, {
    ...n,
    ...a
  }) : nc(l, {
    ...n,
    ...Yi
  }), uo(c, s, n.calendar);
}
function qbe(t, e = Yi) {
  return ho(Ki({
    ...t,
    ...e
  }));
}
function Qbe(t, e, r) {
  return ((n, i) => {
    const s = Dc(n, i, qB);
    return n.K(s, void 0);
  })(t(e.calendar), r);
}
function Kbe(t, e, r) {
  return ((n, i) => {
    const s = Dc(n, i, QB);
    return n._(s);
  })(t(e.calendar), r);
}
function Ybe(t, e, r, n) {
  return ((i, s, o) => IB(i, s, qB, Ug(o), Zg))(t(e.calendar), r, n);
}
function Zbe(t, e, r, n) {
  return ((i, s, o) => IB(i, s, QB, Ug(o), y8))(t(e.calendar), r, n);
}
function Jbe(t) {
  return Ja(na(Hy(IS(t), el)));
}
function Xbe(t) {
  return Ja(na(RS(CS(t))));
}
function Gh(t, e, r) {
  const n = new Set(r);
  return (i, s) => {
    const o = r && TI(i, r);
    if (!TI(i = ((a, l) => {
      const c = {};
      for (const p in l)
        a.has(p) || (c[p] = l[p]);
      return c;
    })(n, i), t)) {
      if (s && o)
        throw new TypeError("Invalid formatting options");
      i = {
        ...e,
        ...i
      };
    }
    return r && (i.timeZone = Wh, ["full", "long"].includes(i.J) && (i.J = "medium")), i;
  };
}
function $c(t, e = LB, r = 0) {
  const [n, , , i] = t;
  return (s, o = t3e, ...a) => {
    const l = e(i && i(...a), s, o, n, r), c = l.resolvedOptions();
    return [l, ...eve(t, c, a)];
  };
}
function LB(t, e, r, n, i) {
  if (r = n(r, i), t) {
    if (r.timeZone !== void 0)
      throw new TypeError(Lve);
    r.timeZone = t;
  }
  return new zl(e, r);
}
function eve(t, e, r) {
  const [, n, i] = t;
  return r.map((s) => (s.calendar && ((o, a, l) => {
    if ((l || o !== ur) && o !== a)
      throw new RangeError(BB);
  })(s.calendar, e.calendar, i), n(s, e)));
}
function tve(t, e, r) {
  const n = e.timeZone, i = t(n), s = {
    ...vs(e, i),
    ...r || Yi
  };
  let o;
  return o = r ? Hd(i, s, s.offsetNanoseconds, 2) : nc(i, s), uo(o, n, e.calendar);
}
function rve(t, e = Yi) {
  return ho(Ki({
    ...t,
    ...e
  }));
}
function f8(t, e) {
  return {
    ...t,
    calendar: e
  };
}
function nve(t, e) {
  return {
    ...t,
    timeZone: e
  };
}
function N3(t) {
  const e = w4();
  return zd(e, t.R(e));
}
function w4() {
  return Hy(Date.now(), el);
}
function Sf() {
  return uP || (uP = new zl().resolvedOptions().timeZone);
}
const ive = (t, e) => `Non-integer ${t}: ${e}`, sve = (t, e) => `Non-positive ${t}: ${e}`, ove = (t, e) => `Non-finite ${t}: ${e}`, ave = (t) => `Cannot convert bigint to ${t}`, lve = (t) => `Invalid bigint: ${t}`, cve = "Cannot convert Symbol to string", uve = "Invalid object", MB = (t, e, r, n, i) => i ? MB(t, i[e], i[r], i[n]) : jc(t, e) + `; must be between ${r}-${n}`, jc = (t, e) => `Invalid ${t}: ${e}`, g8 = (t) => `Missing ${t}`, hve = (t) => `Invalid field ${t}`, pve = (t) => `Duplicate field ${t}`, NB = (t) => "No valid fields: " + t.join(), dve = "Invalid bag", DB = (t, e, r) => jc(t, e) + "; must be " + Object.keys(r).join(), fve = "Cannot use valueOf", x4 = "Invalid calling context", gve = "Forbidden era/eraYear", mve = "Mismatching era/eraYear", yve = "Mismatching year/eraYear", bve = (t) => `Invalid era: ${t}`, vve = (t) => "Missing year" + (t ? "/era/eraYear" : ""), wve = (t) => `Invalid monthCode: ${t}`, xve = "Mismatching month/monthCode", $B = "Missing month/monthCode", Af = "Invalid leap month", Qd = "Invalid protocol results", jB = (t) => jc("Calendar", t), BB = "Mismatching Calendars", FB = (t) => jc("TimeZone", t), zB = "Mismatching TimeZones", Eve = "Forbidden ICU TimeZone", Sve = "Out-of-bounds offset", Ave = "Out-of-bounds TimeZone gap", kve = "Invalid TimeZone offset", _ve = "Ambiguous offset", Bc = "Out-of-bounds date", Cve = "Out-of-bounds duration", Ive = "Cannot mix duration signs", iv = "Missing relativeTo", Pve = "Cannot use large units", Rve = "Required smallestUnit or largestUnit", Ove = "smallestUnit > largestUnit", Di = (t) => `Cannot parse: ${t}`, Sa = (t) => `Invalid substring: ${t}`, Tve = (t) => `Cannot format ${t}`, D3 = "Mismatching types for formatting", Lve = "Cannot specify TimeZone", VB = /* @__PURE__ */ ir(Db, (t, e) => e), nd = /* @__PURE__ */ ir(Db, (t, e, r) => r), Vs = /* @__PURE__ */ ir(Uy, 2), E4 = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, m8 = /* @__PURE__ */ Object.keys(E4), Fi = 864e5, UB = 1e3, Yg = 1e3, el = 1e6, Do = 1e9, sv = 6e10, ov = 36e11, Fr = 864e11, Wo = [1, Yg, el, Do, sv, ov, Fr], tl = /* @__PURE__ */ m8.slice(0, 6), S4 = /* @__PURE__ */ Vg(tl), Mve = ["offset"], HB = ["timeZone"], GB = /* @__PURE__ */ tl.concat(Mve), WB = /* @__PURE__ */ GB.concat(HB), A4 = ["era", "eraYear"], Nve = /* @__PURE__ */ A4.concat(["year"]), y8 = ["year"], b8 = ["monthCode"], v8 = /* @__PURE__ */ ["month"].concat(b8), Zg = ["day"], w8 = /* @__PURE__ */ v8.concat(y8), qB = /* @__PURE__ */ b8.concat(y8), rl = /* @__PURE__ */ Zg.concat(w8), Dve = /* @__PURE__ */ Zg.concat(v8), QB = /* @__PURE__ */ Zg.concat(b8), KB = /* @__PURE__ */ nd(tl, 0), ur = "iso8601", Kd = "gregory", ic = "japanese", YB = {
  [Kd]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [ic]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, ZB = {
  [Kd]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [ic]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
}, $ve = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, Xn = /* @__PURE__ */ ir(kS, "string"), jve = /* @__PURE__ */ ir(kS, "boolean"), Bve = /* @__PURE__ */ ir(kS, "number"), wr = /* @__PURE__ */ m8.map((t) => t + "s"), x8 = /* @__PURE__ */ Vg(wr), Fve = /* @__PURE__ */ wr.slice(0, 6), JB = /* @__PURE__ */ wr.slice(6), zve = /* @__PURE__ */ JB.slice(1), Vve = /* @__PURE__ */ VB(wr), Dn = /* @__PURE__ */ nd(wr, 0), E8 = /* @__PURE__ */ nd(Fve, 0), S8 = /* @__PURE__ */ ir(Sj, wr), po = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"], A8 = ["isoDay", "isoMonth", "isoYear"], av = /* @__PURE__ */ po.concat(A8), k8 = /* @__PURE__ */ Vg(A8), XB = /* @__PURE__ */ Vg(po), Uve = /* @__PURE__ */ Vg(av), Yi = /* @__PURE__ */ nd(XB, 0), Hve = /* @__PURE__ */ ir(Sj, av), eF = 1e8, Gve = eF * Fi, Wve = [eF, 0], qve = [-1e8, 0], B0 = 275760, F0 = -271821, zl = Intl.DateTimeFormat, tF = "en-GB", Qve = 1970, Aa = 1972, gl = 12, Kve = /* @__PURE__ */ Fd(1868, 9, 8), Yve = /* @__PURE__ */ ms(R2e, WeakMap), Zy = "smallestUnit", k4 = "unit", Xf = "roundingIncrement", $3 = "fractionalSecondDigits", rF = "relativeTo", j3 = "direction", nF = {
  constrain: 0,
  reject: 1
}, Zve = /* @__PURE__ */ Object.keys(nF), Jve = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}, Xve = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}, ewe = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}, twe = {
  auto: 0,
  never: 1,
  critical: 2
}, rwe = {
  auto: 0,
  never: 1
}, nwe = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}, iwe = {
  previous: -1,
  next: 1
}, Jg = /* @__PURE__ */ ir(zS, Zy), iF = /* @__PURE__ */ ir(zS, "largestUnit"), swe = /* @__PURE__ */ ir(zS, k4), sF = /* @__PURE__ */ ir(Lc, "overflow", nF), oF = /* @__PURE__ */ ir(Lc, "disambiguation", Jve), owe = /* @__PURE__ */ ir(Lc, "offset", Xve), _8 = /* @__PURE__ */ ir(Lc, "calendarName", ewe), awe = /* @__PURE__ */ ir(Lc, "timeZoneName", twe), lwe = /* @__PURE__ */ ir(Lc, "offset", rwe), Xg = /* @__PURE__ */ ir(Lc, "roundingMode", nwe), C8 = "PlainYearMonth", I8 = "PlainMonthDay", em = "PlainDate", Yd = "PlainDateTime", P8 = "PlainTime", Fc = "ZonedDateTime", R8 = "Instant", O8 = "Duration", cwe = [Math.floor, (t) => Hm(t) ? Math.floor(t) : Math.round(t), Math.ceil, (t) => Hm(t) ? Math.ceil(t) : Math.round(t), Math.trunc, (t) => Hm(t) ? Math.trunc(t) || 0 : Math.round(t), (t) => t < 0 ? Math.floor(t) : Math.ceil(t), (t) => Math.sign(t) * Math.round(Math.abs(t)) || 0, (t) => Hm(t) ? (t = Math.trunc(t) || 0) + t % 2 : Math.round(t)], Wh = "UTC", O1 = 5184e3, uwe = /* @__PURE__ */ Gy(1847), hwe = /* @__PURE__ */ Gy(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10), pwe = /0+$/, vs = /* @__PURE__ */ ms(G2e, WeakMap), dwe = 2 ** 32 - 1, Kt = /* @__PURE__ */ ms((t) => {
  const e = l8(t);
  return typeof e == "object" ? new gwe(e) : new fwe(e || 0);
});
class fwe {
  constructor(e) {
    this.$ = e;
  }
  R() {
    return this.$;
  }
  I(e) {
    return ((r) => {
      const n = Rn({
        ...r,
        ...Yi
      });
      if (!n || Math.abs(n[0]) > 1e8)
        throw new RangeError(Bc);
    })(e), [LS(e, this.$)];
  }
  O() {
  }
}
class gwe {
  constructor(e) {
    this.nn = ((r) => {
      function n(c) {
        const p = M0(c, a, l), [h, d] = XI(p), b = s(h), m = s(d);
        return b === m ? b : i(o(h, d), b, m, c);
      }
      function i(c, p, h, d) {
        let b, m;
        for (; (d === void 0 || (b = d < c[0] ? p : d >= c[1] ? h : void 0) === void 0) && (m = c[1] - c[0]); ) {
          const w = c[0] + Math.floor(m / 2);
          r(w) === h ? c[1] = w : c[0] = w + 1;
        }
        return b;
      }
      const s = ms(r), o = ms(K2e);
      let a = uwe, l = hwe;
      return {
        tn(c) {
          const p = n(c - 86400), h = n(c + 86400), d = c - p, b = c - h;
          if (p === h)
            return [d];
          const m = n(d);
          return m === n(b) ? [c - m] : p > h ? [d, b] : [];
        },
        rn: n,
        O(c, p) {
          const h = M0(c, a, l);
          let [d, b] = XI(h);
          const m = O1 * p, w = p < 0 ? () => b > a || (a = h, 0) : () => d < l || (l = h, 0);
          for (; w(); ) {
            const f = s(d), E = s(b);
            if (f !== E) {
              const A = o(d, b);
              i(A, f, E);
              const x = A[0];
              if ((Fl(x, c) || 1) === p)
                return x;
            }
            d += m, b += m;
          }
        }
      };
    })(/* @__PURE__ */ ((r) => (n) => {
      const i = MS(r, n * UB);
      return Gy(AB(i), parseInt(i.month), parseInt(i.day), parseInt(i.hour), parseInt(i.minute), parseInt(i.second)) - n;
    })(e));
  }
  R(e) {
    return this.nn.rn(((r) => NI(r)[0])(e)) * Do;
  }
  I(e) {
    const [r, n] = [Gy((i = e).isoYear, i.isoMonth, i.isoDay, i.isoHour, i.isoMinute, i.isoSecond), i.isoMillisecond * el + i.isoMicrosecond * Yg + i.isoNanosecond];
    var i;
    return this.nn.tn(r).map((s) => na(vh(Hy(s, Do), n)));
  }
  O(e, r) {
    const [n, i] = NI(e), s = this.nn.O(n + (r > 0 || i ? 1 : 0), r);
    if (s !== void 0)
      return Hy(s, Do);
  }
}
const T8 = "([+-])", T1 = "(?:[.,](\\d{1,9}))?", aF = `(?:(?:${T8}(\\d{6}))|(\\d{4}))-?(\\d{2})`, L8 = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + T1 + ")?)?", M8 = T8 + L8, mwe = aF + "-?(\\d{2})(?:[T ]" + L8 + "(Z|" + M8 + ")?)?", lF = "\\[(!?)([^\\]]*)\\]", lv = `((?:${lF}){0,9})`, ywe = /* @__PURE__ */ Wd(aF + lv), bwe = /* @__PURE__ */ Wd("(?:--)?(\\d{2})-?(\\d{2})" + lv), vwe = /* @__PURE__ */ Wd(mwe + lv), wwe = /* @__PURE__ */ Wd("T?" + L8 + "(?:" + M8 + ")?" + lv), xwe = /* @__PURE__ */ Wd(M8), Ewe = /* @__PURE__ */ new RegExp(lF, "g"), Swe = /* @__PURE__ */ Wd(`${T8}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${T1}H)?(?:(\\d+)${T1}M)?(?:(\\d+)${T1}S)?)?`), Awe = /* @__PURE__ */ ms((t) => new zl(tF, {
  timeZone: t,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
})), kwe = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, _we = /[^\w\/:+-]+/, Cwe = /^M(\d{2})(L?)$/, Iwe = /* @__PURE__ */ ms(ybe), N8 = /* @__PURE__ */ ms((t) => new zl(tF, {
  calendar: t,
  timeZone: Wh,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
})), cF = {
  P(t, e, r) {
    const n = mr(r);
    let i, { years: s, months: o, weeks: a, days: l } = e;
    if (l += Nn(e, 5)[0], s || o)
      i = ((c, p, h, d, b) => {
        let [m, w, f] = c.v(p);
        if (h) {
          const [E, A] = c.q(m, w);
          m += h, w = Ky(E, A, c.L(m)), w = Da("month", w, 1, c.B(m), b);
        }
        return d && ([m, w] = c.un(m, w, d)), f = Da("day", f, 1, c.U(m, w), b), c.p(m, w, f);
      })(this, t, s, o, n);
    else {
      if (!a && !l)
        return t;
      i = ui(t);
    }
    if (i === void 0)
      throw new RangeError(Bc);
    return i += (7 * a + l) * Fi, zs(Fb(i));
  },
  N(t, e, r) {
    if (r <= 7) {
      let l = 0, c = yB({
        ...t,
        ...Yi
      }, {
        ...e,
        ...Yi
      });
      return r === 7 && ([l, c] = ec(c, 7)), {
        ...Dn,
        weeks: l,
        days: c
      };
    }
    const n = this.v(t), i = this.v(e);
    let [s, o, a] = ((l, c, p, h, d, b, m) => {
      let w = d - c, f = b - p, E = m - h;
      if (w || f) {
        const A = Math.sign(w || f);
        let x = l.U(d, b), g = 0;
        if (Math.sign(E) === -A) {
          const v = x;
          [d, b] = l.un(d, b, -A), w = d - c, f = b - p, x = l.U(d, b), g = A < 0 ? -v : x;
        }
        if (E = m - Math.min(h, x) + g, w) {
          const [v, k] = l.q(c, p), [S, R] = l.q(d, b);
          if (f = S - v || Number(R) - Number(k), Math.sign(f) === -A) {
            const L = A < 0 && -l.B(d);
            w = (d -= A) - c, f = b - Ky(v, k, l.L(d)) + (L || l.B(d));
          }
        }
      }
      return [w, f, E];
    })(this, ...n, ...i);
    return r === 8 && (o += this.cn(s, n[0]), s = 0), {
      ...Dn,
      years: s,
      months: o,
      days: a
    };
  },
  F(t, e) {
    const r = mr(e), n = T3(this, t), i = qm(this, t, n, r), s = L3(this, t, i, n, r);
    return Xa(zs(this.V(n, i, s)), this.id || ur);
  },
  K(t, e) {
    const r = mr(e), n = T3(this, t), i = qm(this, t, n, r);
    return N0(TS(this.V(n, i, 1)), this.id || ur);
  },
  _(t, e) {
    const r = mr(e);
    let n, i, s, o = t.eraYear !== void 0 || t.year !== void 0 ? T3(this, t) : void 0;
    const a = !this.id;
    if (o === void 0 && a && (o = Aa), o !== void 0) {
      const h = qm(this, t, o, r);
      n = L3(this, t, h, o, r);
      const d = this.L(o);
      i = d8(h, d), s = h === d;
    } else {
      if (t.monthCode === void 0)
        throw new TypeError($B);
      if ([i, s] = p8(t.monthCode), this.id && this.id !== Kd && this.id !== ic)
        if (this.id && xh(this.id) === "coptic" && r === 0) {
          const h = s || i !== 13 ? 30 : 6;
          n = t.day, n = M0(n, 1, h);
        } else if (this.id && xh(this.id) === "chinese" && r === 0) {
          const h = !s || i !== 1 && i !== 9 && i !== 10 && i !== 11 && i !== 12 ? 30 : 29;
          n = t.day, n = M0(n, 1, h);
        } else
          n = t.day;
      else
        n = L3(this, t, qm(this, t, Aa, r), Aa, r);
    }
    const l = this.G(i, s, n);
    if (!l)
      throw new RangeError("Cannot guess year");
    const [c, p] = l;
    return Wy(zs(this.V(c, p, n)), this.id || ur);
  },
  fields(t) {
    return v4(this) && t.includes("year") ? [...t, ...A4] : t;
  },
  k(t, e) {
    const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
    return M3(r, e, v8), v4(this) && (M3(r, e, Nve), this.id === ic && M3(r, e, Dve, A4)), r;
  },
  inLeapYear(t) {
    const [e] = this.v(t);
    return this.sn(e);
  },
  monthsInYear(t) {
    const [e] = this.v(t);
    return this.B(e);
  },
  daysInMonth(t) {
    const [e, r] = this.v(t);
    return this.U(e, r);
  },
  daysInYear(t) {
    const [e] = this.v(t);
    return this.fn(e);
  },
  dayOfYear: h8,
  era(t) {
    return this.hn(t)[0];
  },
  eraYear(t) {
    return this.hn(t)[1];
  },
  monthCode(t) {
    const [e, r] = this.v(t), [n, i] = this.q(e, r);
    return qg(n, i);
  },
  dayOfWeek: Dj,
  daysInWeek() {
    return 7;
  }
}, Pwe = {
  v: NS,
  hn: $j,
  q: Tj
}, Rwe = {
  dayOfYear: h8,
  v: NS,
  p: Fd
}, Owe = /* @__PURE__ */ Object.assign({}, Rwe, {
  weekOfYear: bB,
  yearOfWeek: vB,
  m(t) {
    function e(b) {
      return (7 - b < n ? 7 : 0) - b;
    }
    function r(b) {
      const m = Nj(d + b), w = b || 1, f = e(Jf(l + m * w, 7));
      return p = (m + (f - c) * w) / 7;
    }
    const n = this.id ? 1 : 4, i = Dj(t), s = this.dayOfYear(t), o = Jf(i - 1, 7), a = s - 1, l = Jf(o - a, 7), c = e(l);
    let p, h = Math.floor((a - c) / 7) + 1, d = t.isoYear;
    return h ? h > r(0) && (h = 1, d++) : (h = r(-1), d--), [h, d, p];
  }
}), Twe = /* @__PURE__ */ Object.assign({}, cF, Owe, {
  v: NS,
  hn: $j,
  q: Tj,
  G(t, e) {
    if (!e)
      return [Aa, t];
  },
  sn: DS,
  L() {
  },
  B: Lj,
  cn: (t) => t * gl,
  U: Mj,
  fn: Nj,
  V: (t, e, r) => ({
    isoYear: t,
    isoMonth: e,
    isoDay: r
  }),
  p: Fd,
  un: (t, e, r) => (t += $b(r, gl), (e += SS(r, gl)) < 1 ? (t--, e += gl) : e > gl && (t++, e -= gl), [t, e]),
  year(t) {
    return t.isoYear;
  },
  month(t) {
    return t.isoMonth;
  },
  day: (t) => t.isoDay
}), Lwe = {
  v: Yy,
  hn: _B,
  q: kB
}, Mwe = {
  dayOfYear: h8,
  v: Yy,
  p: j0,
  weekOfYear: bB,
  yearOfWeek: vB,
  m() {
    return [];
  }
}, Nwe = /* @__PURE__ */ Object.assign({}, cF, Mwe, {
  v: Yy,
  hn: _B,
  q: kB,
  G(t, e, r) {
    const n = this.id && xh(this.id) === "chinese" ? ((c, p, h) => {
      if (p)
        switch (c) {
          case 1:
            return 1651;
          case 2:
            return h < 30 ? 1947 : 1765;
          case 3:
            return h < 30 ? 1966 : 1955;
          case 4:
            return h < 30 ? 1963 : 1944;
          case 5:
            return h < 30 ? 1971 : 1952;
          case 6:
            return h < 30 ? 1960 : 1941;
          case 7:
            return h < 30 ? 1968 : 1938;
          case 8:
            return h < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      return 1972;
    })(t, e, r) : Aa;
    let [i, s, o] = Yy.call(this, {
      isoYear: n,
      isoMonth: gl,
      isoDay: 31
    });
    const a = R1.call(this, i), l = s === a;
    (Fl(t, d8(s, a)) || Fl(Number(e), Number(l)) || Fl(r, o)) === 1 && i--;
    for (let c = 0; c < 100; c++) {
      const p = i - c, h = R1.call(this, p), d = Ky(t, e, h);
      if (e === (d === h) && r <= aP.call(this, p, d))
        return [p, d];
    }
  },
  sn(t) {
    const e = Gm.call(this, t);
    return e > Gm.call(this, t - 1) && e > Gm.call(this, t + 1);
  },
  L: R1,
  B: Wm,
  cn(t, e) {
    const r = e + t, n = Math.sign(t), i = n < 0 ? -1 : 0;
    let s = 0;
    for (let o = e; o !== r; o += n)
      s += Wm.call(this, o + i);
    return s;
  },
  U: aP,
  fn: Gm,
  V(t, e, r) {
    return Fb(j0.call(this, t, e, r));
  },
  p: j0,
  un(t, e, r) {
    if (r) {
      if (e += r, !Number.isSafeInteger(e))
        throw new RangeError(Bc);
      if (r < 0)
        for (; e < 1; )
          e += Wm.call(this, --t);
      else {
        let n;
        for (; e > (n = Wm.call(this, t)); )
          e -= n, t++;
      }
    }
    return [t, e];
  },
  year(t) {
    return this.h(t).year;
  },
  month(t) {
    const { year: e, o: r } = this.h(t), { u: n } = this.l(e);
    return n[r] + 1;
  },
  day(t) {
    return this.h(t).day;
  }
}), cv = /* @__PURE__ */ CB(Pwe, Lwe), Bt = /* @__PURE__ */ CB(Twe, Nwe), cP = {
  era: P1,
  eraYear: si,
  year: si,
  month: MI,
  monthCode(t) {
    const e = P1(t);
    return p8(e), e;
  },
  day: MI,
  .../* @__PURE__ */ nd(tl, si),
  .../* @__PURE__ */ nd(wr, IS),
  offset(t) {
    const e = P1(t);
    return Hh(e), e;
  }
}, D8 = /* @__PURE__ */ ir(xj, tl, po), Dwe = /* @__PURE__ */ ir(xj, po, tl), Vl = "numeric", tm = ["timeZoneName"], uF = {
  month: Vl,
  day: Vl
}, $8 = {
  year: Vl,
  month: Vl
}, j8 = /* @__PURE__ */ Object.assign({}, $8, {
  day: Vl
}), B8 = {
  hour: Vl,
  minute: Vl,
  second: Vl
}, F8 = /* @__PURE__ */ Object.assign({}, j8, B8), $we = /* @__PURE__ */ Object.assign({}, F8, {
  timeZoneName: "short"
}), jwe = /* @__PURE__ */ Object.keys($8), Bwe = /* @__PURE__ */ Object.keys(uF), Fwe = /* @__PURE__ */ Object.keys(j8), zwe = /* @__PURE__ */ Object.keys(B8), z8 = ["dateStyle"], Vwe = /* @__PURE__ */ jwe.concat(z8), Uwe = /* @__PURE__ */ Bwe.concat(z8), V8 = /* @__PURE__ */ Fwe.concat(z8, ["weekday"]), rm = /* @__PURE__ */ zwe.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]), U8 = /* @__PURE__ */ V8.concat(rm), Hwe = /* @__PURE__ */ tm.concat(rm), Gwe = /* @__PURE__ */ tm.concat(V8), Wwe = /* @__PURE__ */ tm.concat(["day", "weekday"], rm), qwe = /* @__PURE__ */ tm.concat(["year", "weekday"], rm), Qwe = /* @__PURE__ */ Gh(U8, F8), Kwe = /* @__PURE__ */ Gh(U8, $we), Ywe = /* @__PURE__ */ Gh(U8, F8, tm), Zwe = /* @__PURE__ */ Gh(V8, j8, Hwe), Jwe = /* @__PURE__ */ Gh(rm, B8, Gwe), Xwe = /* @__PURE__ */ Gh(Vwe, $8, Wwe), e3e = /* @__PURE__ */ Gh(Uwe, uF, qwe), t3e = {}, hF = new zl(void 0, {
  calendar: ur
}).resolvedOptions().calendar === ur, pF = [Qwe, VS], r3e = [Kwe, VS, 0, (t, e) => {
  const r = t.timeZone;
  if (e && e.timeZone !== r)
    throw new RangeError(zB);
  return r;
}], dF = [Ywe, ui], fF = [Zwe, ui], gF = [Jwe, (t) => tc(t) / el], mF = [Xwe, ui, hF], yF = [e3e, ui, hF];
let uP;
function zc(t, e, r, n, i) {
  function s(...l) {
    if (!(this instanceof s))
      throw new TypeError(x4);
    dP(this, e(...l));
  }
  function o(l, c) {
    return Object.defineProperties(function(...p) {
      return l.call(this, a(this), ...p);
    }, L0(c));
  }
  function a(l) {
    const c = xi(l);
    if (!c || c.branding !== t)
      throw new TypeError(x4);
    return c;
  }
  return Object.defineProperties(s.prototype, {
    ...C2e($a(o, r)),
    ...ed($a(o, n)),
    ...ES("Temporal." + t)
  }), Object.defineProperties(s, {
    ...ed(i),
    ...L0(t)
  }), [s, (l) => {
    const c = Object.create(s.prototype);
    return dP(c, l), c;
  }, a];
}
function Zd(t) {
  if (xi(t) || t.calendar !== void 0 || t.timeZone !== void 0)
    throw new TypeError(dve);
  return t;
}
function nm(t) {
  return bF(t) || ur;
}
function bF(t) {
  const { calendar: e } = t;
  if (e !== void 0)
    return uv(e);
}
function uv(t) {
  if (vi(t)) {
    const { calendar: e } = xi(t) || {};
    if (!e)
      throw new TypeError(jB(t));
    return e;
  }
  return ((e) => nv(ibe(Xn(e))))(t);
}
function H8(t) {
  const e = {};
  for (const r in t)
    e[r] = (n) => {
      const { calendar: i } = n;
      return Bt(i)[r](n);
    };
  return e;
}
function Vc() {
  throw new TypeError(fve);
}
function os(t) {
  if (vi(t)) {
    const { timeZone: e } = xi(t) || {};
    if (!e)
      throw new TypeError(FB(t));
    return e;
  }
  return ((e) => a8(sbe(Xn(e))))(t);
}
function cn(t) {
  if (vi(t)) {
    const e = xi(t);
    return e && e.branding === O8 ? e : Cbe(t);
  }
  return nbe(t);
}
function kf(t) {
  if (t !== void 0) {
    if (vi(t)) {
      const e = xi(t) || {};
      switch (e.branding) {
        case Fc:
        case em:
          return e;
        case Yd:
          return Xa(e);
      }
      const r = nm(t);
      return {
        ...wbe(os, Kt, Bt(r), t),
        calendar: r
      };
    }
    return Z2e(t);
  }
}
function ml(t, e) {
  if (vi(t)) {
    const n = xi(t) || {};
    switch (n.branding) {
      case P8:
        return mr(e), n;
      case Yd:
        return mr(e), sa(n);
      case Fc:
        return mr(e), TB(Kt, n);
    }
    return _be(t, e);
  }
  const r = rbe(t);
  return mr(e), r;
}
function G8(t) {
  return t === void 0 ? void 0 : ml(t);
}
function op(t, e) {
  if (vi(t)) {
    const n = xi(t) || {};
    switch (n.branding) {
      case Yd:
        return mr(e), n;
      case em:
        return mr(e), ho({
          ...n,
          ...Yi
        });
      case Fc:
        return mr(e), RB(Kt, n);
    }
    return Ebe(Bt(nm(t)), t, e);
  }
  const r = X2e(t);
  return mr(e), r;
}
function hP(t, e) {
  if (vi(t)) {
    const n = xi(t);
    if (n && n.branding === I8)
      return mr(e), n;
    const i = bF(t);
    return kbe(Bt(i || ur), !i, t, e);
  }
  const r = tbe(Bt, t);
  return mr(e), r;
}
function ap(t, e) {
  if (vi(t)) {
    const n = xi(t);
    return n && n.branding === C8 ? (mr(e), n) : Abe(Bt(nm(t)), t, e);
  }
  const r = ebe(Bt, t);
  return mr(e), r;
}
function lp(t, e) {
  if (vi(t)) {
    const n = xi(t) || {};
    switch (n.branding) {
      case em:
        return mr(e), n;
      case Yd:
        return mr(e), Xa(n);
      case Fc:
        return mr(e), OB(Kt, n);
    }
    return Sbe(Bt(nm(t)), t, e);
  }
  const r = e8(t);
  return mr(e), r;
}
function cp(t, e) {
  if (vi(t)) {
    const r = xi(t);
    if (r && r.branding === Fc)
      return Vb(e), r;
    const n = nm(t);
    return xbe(os, Kt, Bt(n), n, t, e);
  }
  return J2e(t, e);
}
function pP(t) {
  return $a((e) => (r) => e(_4(r)), t);
}
function _4(t) {
  return vs(t, Kt);
}
function up(t) {
  if (vi(t)) {
    const e = xi(t);
    if (e)
      switch (e.branding) {
        case R8:
          return e;
        case Fc:
          return Ja(e.epochNanoseconds);
      }
  }
  return Y2e(t);
}
function n3e() {
  function t(s, o) {
    return new e(s, o);
  }
  function e(s, o = /* @__PURE__ */ Object.create(null)) {
    e2.set(this, ((a, l) => {
      const c = new zl(a, l), p = c.resolvedOptions(), h = p.locale, d = co(Object.keys(l), p), b = ms(o3e), m = (w, ...f) => {
        if (w) {
          if (f.length !== 2)
            throw new TypeError(D3);
          for (const g of f)
            if (g === void 0)
              throw new TypeError(D3);
        }
        w || f[0] !== void 0 || (f = []);
        const E = f.map((g) => xi(g) || Number(g));
        let A, x = 0;
        for (const g of E) {
          const v = typeof g == "object" ? g.branding : void 0;
          if (x++ && v !== A)
            throw new TypeError(D3);
          A = v;
        }
        return A ? b(A)(h, d, ...E) : [c, ...E];
      };
      return m.X = c, m;
    })(s, o));
  }
  const r = zl.prototype, n = Object.getOwnPropertyDescriptors(r), i = Object.getOwnPropertyDescriptors(zl);
  for (const s in n) {
    const o = n[s], a = s.startsWith("format") && i3e(s);
    typeof o.value == "function" ? o.value = s === "constructor" ? t : a || s3e(s) : a && (o.get = function() {
      if (!e2.has(this))
        throw new TypeError(x4);
      return (...l) => a.apply(this, l);
    }, Object.defineProperties(o.get, L0(`get ${s}`)));
  }
  return i.prototype.value = e.prototype = Object.create({}, n), Object.defineProperties(t, i), t;
}
function i3e(t) {
  return Object.defineProperties(function(...e) {
    const r = e2.get(this), [n, ...i] = r(t.includes("Range"), ...e);
    return n[t](...i);
  }, L0(t));
}
function s3e(t) {
  return Object.defineProperties(function(...e) {
    return e2.get(this).X[t](...e);
  }, L0(t));
}
function o3e(t) {
  const e = p3e[t];
  if (!e)
    throw new TypeError(Tve(t));
  return $c(e, ms(LB), 1);
}
const Jy = /* @__PURE__ */ new WeakMap(), xi = /* @__PURE__ */ Jy.get.bind(Jy), dP = /* @__PURE__ */ Jy.set.bind(Jy), vF = {
  era: I2e,
  eraYear: kj,
  year: AS,
  month: fa,
  daysInMonth: fa,
  daysInYear: fa,
  inLeapYear: jve,
  monthsInYear: fa
}, W8 = {
  monthCode: Xn
}, wF = {
  day: fa
}, a3e = {
  dayOfWeek: fa,
  dayOfYear: fa,
  weekOfYear: P2e,
  yearOfWeek: kj,
  daysInWeek: fa
}, q8 = /* @__PURE__ */ H8(/* @__PURE__ */ Object.assign({}, vF, W8, wF, a3e)), l3e = /* @__PURE__ */ H8({
  ...vF,
  ...W8
}), c3e = /* @__PURE__ */ H8({
  ...W8,
  ...wF
}), im = {
  calendarId: (t) => t.calendar
}, u3e = /* @__PURE__ */ Db((t) => (e) => e[t], wr.concat("sign")), Q8 = /* @__PURE__ */ Db((t, e) => (r) => r[po[e]], tl), xF = {
  epochMilliseconds: VS,
  epochNanoseconds: T2e
}, [h3e, en, jIe] = zc(O8, Vbe, {
  ...u3e,
  blank: Q2e
}, {
  with: (t, e) => en(Mbe(t, e)),
  negated: (t) => en(XS(t)),
  abs: (t) => en(q2e(t)),
  add: (t, e, r) => en(JI(kf, Bt, Kt, 0, t, cn(e), r)),
  subtract: (t, e, r) => en(JI(kf, Bt, Kt, 1, t, cn(e), r)),
  round: (t, e) => en(W2e(kf, Bt, Kt, t, e)),
  total: (t, e) => L2e(kf, Bt, Kt, t, e),
  toLocaleString(t, e, r) {
    return Intl.DurationFormat ? new Intl.DurationFormat(e, r).format(this) : O3(t);
  },
  toString: O3,
  toJSON: (t) => O3(t),
  valueOf: Vc
}, {
  from: (t) => en(cn(t)),
  compare: (t, e, r) => abe(kf, Bt, Kt, cn(t), cn(e), r)
}), p3e = {
  Instant: pF,
  PlainDateTime: dF,
  PlainDate: fF,
  PlainTime: gF,
  PlainYearMonth: mF,
  PlainMonthDay: yF
}, d3e = /* @__PURE__ */ $c(pF), f3e = /* @__PURE__ */ $c(r3e), g3e = /* @__PURE__ */ $c(dF), m3e = /* @__PURE__ */ $c(fF), y3e = /* @__PURE__ */ $c(gF), b3e = /* @__PURE__ */ $c(mF), v3e = /* @__PURE__ */ $c(yF), [w3e, _l] = zc(P8, zbe, Q8, {
  with(t, e, r) {
    return _l(Lbe(this, Zd(e), r));
  },
  add: (t, e) => _l(ZI(0, t, cn(e))),
  subtract: (t, e) => _l(ZI(1, t, cn(e))),
  until: (t, e, r) => en(oP(0, t, ml(e), r)),
  since: (t, e, r) => en(oP(1, t, ml(e), r)),
  round: (t, e) => _l($2e(t, e)),
  equals: (t, e) => fbe(t, ml(e)),
  toLocaleString(t, e, r) {
    const [n, i] = y3e(e, r, t);
    return n.format(i);
  },
  toString: HI,
  toJSON: (t) => HI(t),
  valueOf: Vc
}, {
  from: (t, e) => _l(ml(t, e)),
  compare: (t, e) => c8(ml(t), ml(e))
}), [x3e, ko] = zc(Yd, ir($be, Qg), {
  ...im,
  ...q8,
  ...Q8
}, {
  with: (t, e, r) => ko(Pbe(Bt, t, Zd(e), r)),
  withCalendar: (t, e) => ko(f8(t, uv(e))),
  withPlainTime: (t, e) => ko(rve(t, G8(e))),
  add: (t, e, r) => ko(QI(Bt, 0, t, cn(e), r)),
  subtract: (t, e, r) => ko(QI(Bt, 1, t, cn(e), r)),
  until: (t, e, r) => en(nP(Bt, 0, t, op(e), r)),
  since: (t, e, r) => en(nP(Bt, 1, t, op(e), r)),
  round: (t, e) => ko(D2e(t, e)),
  equals: (t, e) => ube(t, op(e)),
  toZonedDateTime: (t, e, r) => ri(Gbe(Kt, t, os(e), r)),
  toPlainDate: (t) => Ro(Xa(t)),
  toPlainTime: (t) => _l(sa(t)),
  toLocaleString(t, e, r) {
    const [n, i] = g3e(e, r, t);
    return n.format(i);
  },
  toString: FI,
  toJSON: (t) => FI(t),
  valueOf: Vc
}, {
  from: (t, e) => ko(op(t, e)),
  compare: (t, e) => hB(op(t), op(e))
}), [E3e, C4, BIe] = zc(I8, ir(Fbe, Qg), {
  ...im,
  ...c3e
}, {
  with: (t, e, r) => C4(Tbe(Bt, t, Zd(e), r)),
  equals: (t, e) => dbe(t, hP(e)),
  toPlainDate(t, e) {
    return Ro(Zbe(Bt, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = v3e(e, r, t);
    return n.format(i);
  },
  toString: UI,
  toJSON: (t) => UI(t),
  valueOf: Vc
}, {
  from: (t, e) => C4(hP(t, e))
}), [S3e, Mf, FIe] = zc(C8, ir(Bbe, Qg), {
  ...im,
  ...l3e
}, {
  with: (t, e, r) => Mf(Obe(Bt, t, Zd(e), r)),
  add: (t, e, r) => Mf(YI(Bt, 0, t, cn(e), r)),
  subtract: (t, e, r) => Mf(YI(Bt, 1, t, cn(e), r)),
  until: (t, e, r) => en(sP(Bt, 0, t, ap(e), r)),
  since: (t, e, r) => en(sP(Bt, 1, t, ap(e), r)),
  equals: (t, e) => pbe(t, ap(e)),
  toPlainDate(t, e) {
    return Ro(Ybe(Bt, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = b3e(e, r, t);
    return n.format(i);
  },
  toString: VI,
  toJSON: (t) => VI(t),
  valueOf: Vc
}, {
  from: (t, e) => Mf(ap(t, e)),
  compare: (t, e) => qd(ap(t), ap(e))
}), [A3e, Ro, zIe] = zc(em, ir(jbe, Qg), {
  ...im,
  ...q8
}, {
  with: (t, e, r) => Ro(Rbe(Bt, t, Zd(e), r)),
  withCalendar: (t, e) => Ro(f8(t, uv(e))),
  add: (t, e, r) => Ro(KI(Bt, 0, t, cn(e), r)),
  subtract: (t, e, r) => Ro(KI(Bt, 1, t, cn(e), r)),
  until: (t, e, r) => en(iP(Bt, 0, t, lp(e), r)),
  since: (t, e, r) => en(iP(Bt, 1, t, lp(e), r)),
  equals: (t, e) => hbe(t, lp(e)),
  toZonedDateTime(t, e) {
    const r = vi(e) ? e : {
      timeZone: e
    };
    return ri(Wbe(os, ml, Kt, t, r));
  },
  toPlainDateTime: (t, e) => ko(qbe(t, G8(e))),
  toPlainYearMonth(t) {
    return Mf(Qbe(Bt, t, this));
  },
  toPlainMonthDay(t) {
    return C4(Kbe(Bt, t, this));
  },
  toLocaleString(t, e, r) {
    const [n, i] = m3e(e, r, t);
    return n.format(i);
  },
  toString: zI,
  toJSON: (t) => zI(t),
  valueOf: Vc
}, {
  from: (t, e) => Ro(lp(t, e)),
  compare: (t, e) => qd(lp(t), lp(e))
}), [k3e, ri] = zc(Fc, ir(Dbe, Qg, obe), {
  ...xF,
  ...im,
  ...pP(q8),
  ...pP(Q8),
  offset: (t) => Gg(_4(t).offsetNanoseconds),
  offsetNanoseconds: (t) => _4(t).offsetNanoseconds,
  timeZoneId: (t) => t.timeZone,
  hoursInDay: (t) => j2e(Kt, t)
}, {
  with: (t, e, r) => ri(Ibe(Bt, Kt, t, Zd(e), r)),
  withCalendar: (t, e) => ri(f8(t, uv(e))),
  withTimeZone: (t, e) => ri(nve(t, os(e))),
  withPlainTime: (t, e) => ri(tve(Kt, t, G8(e))),
  add: (t, e, r) => ri(qI(Bt, Kt, 0, t, cn(e), r)),
  subtract: (t, e, r) => ri(qI(Bt, Kt, 1, t, cn(e), r)),
  until: (t, e, r) => en(vn(rP(Bt, Kt, 0, t, cp(e), r))),
  since: (t, e, r) => en(vn(rP(Bt, Kt, 1, t, cp(e), r))),
  round: (t, e) => ri(N2e(Kt, t, e)),
  startOfDay: (t) => ri(B2e(Kt, t)),
  equals: (t, e) => cbe(t, cp(e)),
  toInstant: (t) => yl(Hbe(t)),
  toPlainDateTime: (t) => ko(RB(Kt, t)),
  toPlainDate: (t) => Ro(OB(Kt, t)),
  toPlainTime: (t) => _l(TB(Kt, t)),
  toLocaleString(t, e, r = {}) {
    const [n, i] = f3e(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => BI(Kt, t, e),
  toJSON: (t) => BI(Kt, t),
  valueOf: Vc,
  getTimeZoneTransition(t, e) {
    const { timeZone: r, epochNanoseconds: n } = t, i = O2e(e), s = Kt(r).O(n, i);
    return s ? ri({
      ...t,
      epochNanoseconds: s
    }) : null;
  }
}, {
  from: (t, e) => ri(cp(t, e)),
  compare: (t, e) => uB(cp(t), cp(e))
}), [_3e, yl, VIe] = zc(R8, Nbe, xF, {
  add: (t, e) => yl(WI(0, t, cn(e))),
  subtract: (t, e) => yl(WI(1, t, cn(e))),
  until: (t, e, r) => en(tP(0, t, up(e), r)),
  since: (t, e, r) => en(tP(1, t, up(e), r)),
  round: (t, e) => yl(M2e(t, e)),
  equals: (t, e) => lbe(t, up(e)),
  toZonedDateTimeISO: (t, e) => ri(Ube(t, os(e))),
  toLocaleString(t, e, r) {
    const [n, i] = d3e(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => jI(os, Kt, t, e),
  toJSON: (t) => jI(os, Kt, t),
  valueOf: Vc
}, {
  from: (t) => yl(up(t)),
  fromEpochMilliseconds: (t) => yl(Jbe(t)),
  fromEpochNanoseconds: (t) => yl(Xbe(t)),
  compare: (t, e) => cB(up(t), up(e))
}), C3e = /* @__PURE__ */ Object.defineProperties({}, {
  ...ES("Temporal.Now"),
  ...ed({
    timeZoneId: () => Sf(),
    instant: () => yl(Ja(w4())),
    zonedDateTimeISO: (t = Sf()) => ri(uo(w4(), os(t), ur)),
    plainDateTimeISO: (t = Sf()) => ko(ho(N3(Kt(os(t))), ur)),
    plainDateISO: (t = Sf()) => Ro(Xa(N3(Kt(os(t))), ur)),
    plainTimeISO: (t = Sf()) => _l(sa(N3(Kt(os(t)))))
  })
}), Xy = /* @__PURE__ */ Object.defineProperties({}, {
  ...ES("Temporal"),
  ...ed({
    PlainYearMonth: S3e,
    PlainMonthDay: E3e,
    PlainDate: A3e,
    PlainTime: w3e,
    PlainDateTime: x3e,
    ZonedDateTime: k3e,
    Instant: _3e,
    Duration: h3e,
    Now: C3e
  })
}), I3e = /* @__PURE__ */ n3e(), e2 = /* @__PURE__ */ new WeakMap();
ed({
  DateTimeFormat: I3e
});
function hv(t) {
  Object.freeze(t);
  for (const e in t)
    typeof t == "object" && hv(t[e]);
}
function P3e(t) {
  return Object.keys(t).length === 0;
}
function Sp(t) {
  return { type: "connective", real: Er(t) };
}
function L1(t, e, r) {
  return {
    type: "simple-category",
    subtype: "currency",
    noun: Er(t),
    symbol: e,
    pos: r
  };
}
function Ri(t, e) {
  return e ? { type: "direction", direction: Er(t), aux: e } : { type: "direction", direction: Er(t) };
}
function Er(t) {
  return { en: t };
}
const Ap = function(t, e) {
  const r = { type: "simple-category" };
  if (P3e(t))
    throw new Error("[grammatize-information]: The category helper function must be called with at least one lemma.");
  for (const n in t) {
    const i = n;
    r[i] = Er(t[i]);
  }
  return e && (r.quasiname = !0), r;
};
function Dr(t) {
  return { type: "simple-category", noun: Er(t) };
}
function kp(t, e) {
  return { type: "simple-category", adj: Er(t), inessential: e ?? !1 };
}
function EF(t) {
  return { type: "simple-category", pastParticiple: Er(t) };
}
function Gn(t, e) {
  return e ? { type: "predicate", pred: Er(t), aux: Er(e) } : { type: "predicate", pred: Er(t) };
}
function M1(t) {
  return { type: "simple-category", subtype: "unit", noun: Er(t) };
}
function Ou(t) {
  return { type: "simple-category", subtype: "scale", noun: Er(t) };
}
function _p(t, e) {
  return { type: "quantifier", quantifier: Er(t), aux: e ? Er(e) : void 0 };
}
const fP = Ri("back"), gP = Ri("up"), Oe = {
  // Predicates
  SHOW: Gn("show"),
  PEAK: Gn("peak"),
  BOTTOM_OUT: Gn("bottom", "out"),
  COMPARE: Gn("compare"),
  COPULA: Gn("be"),
  START: Gn("start"),
  END: Gn("end"),
  HAS: Gn("have"),
  REBOUND: Gn("rebound"),
  FALL_pred: Gn("fall"),
  RISE_pred: Gn("rise"),
  CLUSTER: Gn("cluster"),
  TRACK: Gn("track"),
  INTERSECT: Gn("intersect"),
  //TODO: combine with INTERSECTION
  // Categories
  LINE: Dr("line"),
  CHART: Dr("chart"),
  PRICE: Dr("price"),
  PERIOD: Dr("period"),
  RATE: Dr("rate"),
  INFLATION: Dr("inflation"),
  INTERSECTION: Dr("intersection"),
  NUMBER: Ou("number"),
  TREND: Dr("trend"),
  JUMP: Dr("jump"),
  DISTRIBUTION: Dr("distribution"),
  OUTLIER: Dr("outlier"),
  RECORD: Dr("record"),
  XAXIS: Dr("x-axis"),
  YAXIS: Dr("y-axis"),
  PERCENT: Ou("percent"),
  PERCENTAGE: Dr("percentage"),
  BAR: Dr("bar"),
  SLICE: Dr("slice"),
  PIE: Dr("pie"),
  GROUP: Dr("group"),
  TIME: Dr("time"),
  THOUSAND: Ou("thousand"),
  MILLION: Ou("million"),
  BILLION: Ou("billion"),
  TRILLION: Ou("trillion"),
  OVERALL: kp("overall"),
  LARGE: kp("large"),
  DIFFERENT: kp("different"),
  ENTIRE: kp("entire"),
  STEPPED: kp("stepped"),
  FOLLOWED: EF("follow"),
  HIGH: Ap({ noun: "high", adj: "high" }),
  LOW: Ap({ noun: "low", adj: "low" }),
  STABLE: Ap({ noun: "stable", adj: "stable" }),
  RISE: Ap({ noun: "rise", participle: "rise" }),
  FALL: Ap({ noun: "fall", participle: "fall" }),
  // Units
  POINT: M1("point"),
  YEAR: M1("year"),
  QUARTER: M1("quarter"),
  // Directions
  OVER: Ri("over"),
  IN: Ri("in"),
  AT: Ri("at"),
  ON: Ri("on"),
  BACK: fP,
  UP: gP,
  BACK_UP: { ...fP, aux: gP },
  BY: Ri("by"),
  FROM: Ri("from"),
  TO: Ri("to"),
  BETWEEN: Ri("between"),
  EXCEPT: Ri("except"),
  ALONG: Ri("along"),
  // Connectives
  AND: Sp("and"),
  FOLLOWED_BY: Sp("followed by"),
  AND_THEN: Sp("and then"),
  BEFORE: Sp("before"),
  WHILE: Sp("while"),
  // Manners & Modes
  TOGETHER: { type: "manner", manner: Er("together") },
  TEMPORARILY: { type: "manner", manner: Er("temporarily") },
  AGAIN: { type: "manner", manner: Er("again") },
  WORLDWIDE: { type: "manner", manner: Er("worldwide") },
  POSSIBLY: { type: "mode", mode: Er("possibly") },
  // Quantifiers
  ALL: _p("all"),
  AROUND: { ..._p("around"), adverb: !0 },
  ALMOST: { ..._p("almost"), adverb: !0 },
  MORE_THAN: _p("more", "than"),
  EACH: _p("each"),
  // Pronouns
  EACH_OTHER: { type: "pronoun-entity", determiner: Er("each"), number: "plural", pronoun: Er("other") }
};
hv(Oe);
const N1 = {
  DOLLAR: L1("dollar", "$", "prefix"),
  US_DOLLAR: L1("U.S. dollar", "$", "prefix"),
  SK_WON: L1("South Korean won", "", "prefix")
};
hv(N1);
const Ol = {
  "0.01": Oe.PERCENT,
  1: Oe.NUMBER,
  1e3: Oe.THOUSAND,
  1e6: Oe.MILLION,
  1e9: Oe.BILLION,
  1e12: Oe.TRILLION
};
hv(Ol);
const Ii = class Pi {
  static participle(e) {
    return { type: "simple-category", participle: Er(e) };
  }
  // * Entities *
  // Helpers for Entities Helpers
  static _num(e) {
    let r;
    return e === "s" ? r = "singular" : e === "p" ? r = "plural" : r = e, r;
  }
  static _entityHelperBuilder(e, r, n, i) {
    return {
      type: "simple-entity",
      detType: e,
      number: Pi._num(r),
      category: n,
      mods: i
    };
  }
  // Simple Entities
  static the(e, r, n) {
    return Pi._entityHelperBuilder("definite", e, r, n ?? []);
  }
  static a(e, r, n) {
    return Pi._entityHelperBuilder("indefinite", e, r, n ?? []);
  }
  static this_(e, r, n) {
    return Pi._entityHelperBuilder("proximal", e, r, n ?? []);
  }
  static that(e, r, n) {
    return Pi._entityHelperBuilder("distal", e, r, n ?? []);
  }
  static proper(e, r) {
    return Pi._entityHelperBuilder("proper", "singular", e, r ?? []);
  }
  // Number Entities
  static numberEntity(e, r, n) {
    return {
      type: "number-entity",
      number: e,
      scale: r,
      mods: n
    };
  }
  // Money Values
  static moneyValue(e, r, n, i) {
    return {
      type: "simple-entity",
      subtype: "money-value",
      detType: "bare",
      number: e,
      scale: r,
      category: n,
      mods: i
    };
  }
  // Quantity Values
  static quantValue(e, r, n, i) {
    return {
      type: "simple-entity",
      subtype: "quant-value",
      detType: "indefinite",
      number: e,
      scale: r,
      category: n,
      mods: i
    };
  }
  // Plain Date Points
  static year(e) {
    const r = e.toString().padStart(4, "0");
    return {
      type: "plain-date-time",
      datetime: Xy.PlainDateTime.from(`${r}0101`),
      unit: "year"
    };
  }
  static quarter(e, r) {
    const n = e.toString().padStart(4, "0");
    if (![1, 2, 3, 4].includes(r))
      throw new Error(`[Grammatize-Information]: quarter number must be 1, 2, 3, or 4, not ${r}`);
    const i = ((r - 1) * 3 + 1).toString().padStart(2, "0");
    return {
      type: "plain-date-time",
      datetime: Xy.PlainDateTime.from(`${n}${i}01`),
      unit: "quarter"
    };
  }
  // * Modifiers *
  // Misc Modifiers
  static of(e) {
    return { type: "possession", possessor: e };
  }
  static for_(e) {
    return { type: "purpose", subtype: "for", purpose: e };
  }
  static with(e) {
    return { type: "purpose", subtype: "with", purpose: e };
  }
  static as(e) {
    return { type: "purpose", subtype: "as", purpose: e };
  }
  static ordinal(e) {
    return { type: "ordinal", ordinal: e };
  }
  static _pointLocationHelperBuilder(e, r) {
    return { type: "point-location", direction: e, point: r };
  }
  static over(e) {
    return Pi._pointLocationHelperBuilder(Oe.OVER, e);
  }
  static on(e) {
    return Pi._pointLocationHelperBuilder(Oe.ON, e);
  }
  static at(e) {
    return Pi._pointLocationHelperBuilder(Oe.AT, e);
  }
  static in_(e) {
    return Pi._pointLocationHelperBuilder(Oe.IN, e);
  }
  static by(e) {
    return Pi._pointLocationHelperBuilder(Oe.BY, e);
  }
  static path(e, r) {
    return { type: "path-location", start: e, end: r };
  }
  // * Statements *
  static svo(e, r, n, ...i) {
    return {
      type: "simple-statement",
      subject: e,
      clause: {
        type: "simple-clause",
        pred: r,
        object: n
      },
      mods: i
    };
  }
  // Coordinated Phrases
  static coord(e, ...r) {
    return { type: "coordinated-phrase", conn: e, coords: r };
  }
  static and(...e) {
    return Pi.coord(Oe.AND, ...e);
  }
  // * Tags *
  static tag(e, r, n) {
    return e.tag = { name: r, attributes: n }, e;
  }
};
_i(Ii, "en", Er), // * Categories *
// Simple Categories
_i(Ii, "category", Ap), _i(Ii, "noun", Dr), _i(Ii, "adj", kp), _i(Ii, "pastParticiple", EF), // Units
_i(Ii, "unit", M1), // Scales
_i(Ii, "scale", Ou), // Currencies
_i(Ii, "currency", L1), _i(Ii, "quantifier", _p), // Locations
_i(Ii, "dir", Ri), // * Predicates *
_i(Ii, "pred", Gn), // * Coordination *
// Connectives
_i(Ii, "conn", Sp);
let xe = Ii;
var bt;
((t) => {
  function e(N) {
    return n(N) || h(N) || ie(N) || g(N) || c(N) || ce(N) || ye(N) || ue(N) || Te(N) || O(N, e);
  }
  t.isComponent = e;
  function r(N) {
    return typeof N == "object" && !!N && "type" in N && e(N);
  }
  t.isComponentGuard = r;
  function n(N) {
    return i(N) || s(N) || o(N) || a(N) || l(N) || O(N, n);
  }
  t.isCategory = n;
  function i(N) {
    return N.type === "simple-category";
  }
  t.isSimpleCategory = i;
  function s(N) {
    return i(N) && "noun" in N && N.subtype === "unit";
  }
  t.isUnit = s;
  function o(N) {
    return i(N) && "noun" in N && N.subtype === "currency";
  }
  t.isCurrency = o;
  function a(N) {
    return i(N) && "noun" in N && N.subtype === "scale";
  }
  t.isScale = a;
  function l(N) {
    return N.type === "ordinal";
  }
  t.isOrdinal = l;
  function c(N) {
    return N.type === "quantifier";
  }
  t.isQuantifier = c;
  function p(N) {
    return typeof N == "number" ? N === 1 ? "s" : "p" : N === "singular" ? "s" : N === "plural" ? "p" : N;
  }
  t.normalizeNumber = p;
  function h(N) {
    return b(N) || m(N) || w(N) || x(N) || A(N) || O(N, h);
  }
  t.DET = {
    proper: { en: null },
    definite: { en: "the" },
    indefinite: { en: "a" },
    proximal: { en: "this" },
    distal: { en: "that" },
    bare: { en: null }
  };
  function d(N) {
    if (b(N) || m(N) || A(N))
      return p(N.number);
    if (x(N))
      return "s";
    if (O(N, h))
      return "p";
  }
  t.entityNumber = d;
  function b(N) {
    return N.type === "simple-entity";
  }
  t.isSimpleEntity = b;
  function m(N) {
    return N.type === "pronoun-entity";
  }
  t.isPronounEntity = m;
  function w(N) {
    return E(N) || f(N);
  }
  function f(N) {
    return b(N) && N.subtype === "quant-value";
  }
  t.isQuantValue = f;
  function E(N) {
    return b(N) && N.subtype === "money-value";
  }
  t.isMoneyValue = E;
  function A(N) {
    return N.type === "number-entity";
  }
  t.isNumberEntity = A;
  function x(N) {
    return N.type === "plain-date-time";
  }
  t.isPlainDateTime = x;
  function g(N) {
    return n(N) || k(N) || S(N) || R(N) || z(N) || L(N) || Te(N) || O(N, g);
  }
  function v(N) {
    if (n(N))
      return "prepend";
    if (k(N) || S(N) || R(N) || z(N))
      return "postpend";
    if (L(N))
      return N.prepend ? "prepend" : "postpend";
    if (F(N))
      return "prepend";
    if (Te(N))
      return "postpend";
    if (O(N, g))
      return v(N.coords[0]);
  }
  t.modPosition = v;
  function k(N) {
    return N.type === "possession";
  }
  t.isPossession = k, t.POSS_AUX = {
    en: "of"
  }, t.REL = {
    zero: { en: null },
    which: { en: "which" },
    that: { en: "that" },
    while: { en: "while" }
  };
  function S(N) {
    return N.type === "relative-clause";
  }
  t.isRelative = S;
  function R(N) {
    return N.type === "purpose";
  }
  t.isPurpose = R, t.PURPOSE_AUX = {
    for: xe.en("for"),
    as: xe.en("as"),
    with: xe.en("with")
  };
  function L(N) {
    return N.type === "manner";
  }
  t.isManner = L;
  function F(N) {
    return N.type === "mode";
  }
  t.isMode = F;
  function z(N) {
    return j(N) || ee(N) || X(N);
  }
  t.isLocation = z;
  function j(N) {
    return N.type === "direction";
  }
  t.isDirection = j;
  function ee(N) {
    return N.type === "point-location";
  }
  t.isPointLocation = ee;
  function X(N) {
    return N.type === "path-location";
  }
  t.isPathLocation = X;
  function ie(N) {
    return N.type === "predicate";
  }
  t.isPredicate = ie;
  function ce(N) {
    return ke(N) || O(N, ce);
  }
  function ke(N) {
    return N.type === "simple-clause";
  }
  t.isSimpleClause = ke;
  function ye(N) {
    return Ce(N) || Ie(N) || O(N, Ce);
  }
  t.isStatement = ye;
  function Ce(N) {
    return N.type === "simple-statement";
  }
  t.isSimpleStatement = Ce;
  function Ie(N) {
    return N.type === "label";
  }
  t.isLabel = Ie;
  function Te(N) {
    return N.type === "quote";
  }
  t.isQuote = Te;
  function ue(N) {
    return N.type === "connective";
  }
  t.isConnective = ue;
  function O(N, Z) {
    return N.type === "coordinated-phrase" && Z(N.coords[0]);
  }
  t.isCoordinated = O;
})(bt || (bt = {}));
const R3e = [
  { cat: { noun: "Canada", adj: "Canadian" } },
  { cat: { noun: "nation", adj: "national" } },
  { cat: { noun: "Indonesia", adj: "Indonesian" } },
  { cat: { noun: "region", adj: "regional" } },
  { cat: { noun: "U.S.", adj: "U.S." }, quasiname: !0, synonyms: ["US", "United States"] },
  { cat: { noun: "Vietnam", adj: "Vietnamese" } },
  { cat: { noun: "world", adj: "global" }, quasiname: !0 }
];
function O3e(t) {
  const e = {};
  for (const r of t) {
    const n = xe.category(r.cat, r.quasiname);
    e[r.cat.noun] = n, e[r.cat.adj] = n;
    for (const i of r.synonyms ?? [])
      e[i] = n;
  }
  return e;
}
O3e(R3e);
const qr = new _2e(), mP = qr.N, T3e = qr.A, L3e = qr.Pro, Qm = qr.D, B3 = qr.V, hp = qr.Adv, pp = qr.P, M3e = qr.C, _u = qr.Q, F3 = qr.S, N3e = qr.SP, D3e = qr.CP, z3 = qr.VP, Ts = qr.NP, $3e = qr.AP, dp = qr.PP, yP = qr.AdvP, bP = qr.DT, ll = qr.NO;
function j3e(t, e) {
  const r = [], n = [];
  for (const i of t)
    e(i) ? r.push(i) : n.push(i);
  return [r, n];
}
function t2(t) {
  if (Array.isArray(t))
    return t.map((e) => t2(e));
  if (t instanceof Xy.PlainDateTime || Object.prototype.toString.call(t) === "[object Temporal.PlainDateTime]")
    return Xy.PlainDateTime.from(t);
  if (typeof t == "object") {
    const e = {};
    for (const r in t)
      e[r] = t2(t[r]);
    return e;
  }
  return t;
}
function I4(t) {
  const e = t2(t);
  for (const r in t)
    ["tag", "detTag", "auxTag", "startTag", "endTag"].includes(r) ? delete e[r] : bt.isComponentGuard(t[r]) && (e[r] = I4(t[r]));
  return e;
}
function Nf(t, e) {
  const r = I4(t), n = I4(e);
  return JSON.stringify(r) === JSON.stringify(n);
}
function B3e(t, e) {
  return t.some((r) => Nf(r, e));
}
async function F3e() {
  await qr.init();
}
class z3e {
  // Dispatch
  grammatizeMultiple(e, r) {
    return e.map((n) => this.grammatize(n, r));
  }
  grammatize(e, r, n) {
    let i = this.grammatizeDispatch(e, r, n);
    return "tag" in e && i.tag(e.tag.name, e.tag.attributes), i;
  }
  grammatizeDispatch(e, r, n) {
    if (bt.isCategory(e))
      return this.grammatizeCategory(e, r, n);
    if (bt.isQuantValue(e))
      return this.grammatizeQuantValue(e, r);
    if (bt.isMoneyValue(e))
      return this.grammatizeMoneyValue(e, r);
    if (bt.isSimpleEntity(e))
      return this.grammatizeSimpleEntity(e, r);
    if (bt.isPronounEntity(e))
      return this.grammatizePronounEntity(e, r);
    if (bt.isNumberEntity(e))
      return this.grammatizeNumberEntity(e, r);
    if (bt.isPlainDateTime(e))
      return this.grammatizePlainDateTime(e, r);
    if (bt.isPossession(e))
      return this.grammatizePoss(e, r);
    if (bt.isRelative(e))
      return this.grammatizeRelative(e, r);
    if (bt.isPurpose(e))
      return this.grammatizePurpose(e, r);
    if (bt.isManner(e))
      return this.grammatizeManner(e, r);
    if (bt.isMode(e))
      return this.grammatizeMode(e, r);
    if (bt.isDirection(e))
      return this.grammatizeDir(e, r);
    if (bt.isPointLocation(e))
      return this.grammatizeLoc(e, r);
    if (bt.isPathLocation(e))
      return this.grammatizePath(e, r);
    if (bt.isPredicate(e))
      return this.grammatizePredicate(e, r, n);
    if (bt.isSimpleClause(e))
      return this.grammatizeSimpleClause(e, r, n);
    if (bt.isSimpleStatement(e))
      return this.grammatizeSimpleStatement(e, r);
    if (bt.isQuantifier(e))
      return this.grammatizeQuantifier(e, r);
    if (bt.isLabel(e))
      return this.grammatizeLabel(e, r);
    if (bt.isQuote(e))
      return this.grammatizeQuote(e, r);
    if (bt.isConnective(e))
      return this.grammatizeConnective(e, r);
    if (bt.isCoordinated(e, bt.isComponent))
      return this.grammatizeCoord(e, r);
  }
  // Helpers
  _grammatizeAdj(e, r) {
    console.assert("adj" in e);
    const n = e.adj[r], i = T3e(n, !0);
    return (e.comparative === "comparative" || e.comparative === "superlative") && i.f(e.comparative === "comparative" ? "co" : "su"), i;
  }
  // Categories
  grammatizeCategory(e, r, n = "s") {
    return bt.isSimpleCategory(e) ? this.grammatizeSimpleCategory(e, r, n) : bt.isOrdinal(e) ? this.grammatizeOrdinal(e, r) : bt.isUnit(e) ? this.grammatizeUnit(e, r) : bt.isCurrency(e) ? this.grammatizeCurrencySymbol(e, r) : bt.isScale(e) ? this.grammatizeScale(e, r) : bt.isCoordinated(e, bt.isCategory) ? this.grammatizeCoord(e, r, n) : e;
  }
  grammatizeSimpleCategory(e, r, n) {
    console.assert("adj" in e || "noun" in e || "participle" in e || "pastParticiple" in e);
    let i;
    "force" in e && e.force !== void 0 ? (console.assert(e.force in e), i = e.force) : "adj" in e && "comparative" in e ? i = "adj" : "noun" in e ? i = "noun" : "adj" in e ? i = "adj" : "participle" in e ? i = "participle" : i = "pastParticiple";
    let s;
    return i === "noun" ? s = Ts(mP(e.noun[r], n, !0)) : i === "participle" ? s = z3(B3(e.participle[r], "present-participle")) : i === "pastParticiple" ? s = z3(B3(e.pastParticiple[r], "past-participle")) : s = $3e(this._grammatizeAdj(e, r)), this.grammatizeMods(s, r, e.mods), s;
  }
  // This should return a (Number)Adjective. See https://github.com/fizzstudio/theseusaurus/issues/54
  grammatizeOrdinal(e, r) {
    return ll(e.ordinal).dOpt({ ord: !0 });
  }
  grammatizeUnit(e, r) {
    const n = {
      ...e,
      noun: e.noun
    };
    return this.grammatizeCategory(n, r);
  }
  grammatizeCurrencySymbol(e, r) {
    return _u(e.symbol);
  }
  grammatizeScale(e, r) {
    const n = {
      ...e,
      noun: e.noun
    };
    return this.grammatizeCategory(n, r);
  }
  // Entities
  grammatizeSimpleEntity(e, r) {
    if (e.detType === "proper" && e.number !== "singular")
      throw new Error("Proper nouns can only be singular");
    const n = e.quantifier ? this.grammatize(e.quantifier, r) : null, i = e.number === "singular" || e.number === 1 ? "s" : "p";
    let s;
    e.number === "plural" && e.detType === "indefinite" || e.detType === "proper" || e.detType === "bare" || typeof e.number == "number" && e.detType === "indefinite" ? s = null : (console.assert(bt.DET[e.detType][r] !== null, "nullish determiner"), s = Qm(bt.DET[e.detType][r]), e.detTag && s.tag(e.detTag.name, e.detTag.attributes));
    const o = e.number === "singular" || e.number === "plural" ? null : ll(e.number), a = this.grammatize(e.category, r, i), l = e.scale && !Nf(e.scale, Ol[1]) ? this.grammatize(e.scale, r) : null;
    return this.grammatizeEntityMods(n, s, o, a, l, r, e.mods);
  }
  grammatizePronounEntity(e, r) {
    const n = L3e(e.pronoun[r]);
    return e.determiner ? Ts(Qm(e.determiner[r]), n) : Ts(n);
  }
  grammatizeQuantValue(e, r) {
    const n = {
      ...e,
      type: "simple-entity",
      detType: "indefinite"
    };
    return this.grammatizeSimpleEntity(n, r);
  }
  grammatizeNumberEntity(e, r) {
    const n = e.quantifier ? this.grammatize(e.quantifier, r) : null;
    let i;
    return Nf(e.scale, Ol[1]) ? i = Ts(n, ll(e.number)) : Nf(e.scale, Ol[0.01]) ? i = Ts(n, ll(e.number).after(_u("%"))) : i = Ts(n, ll(e.number), this.grammatize(e.scale, r)), this.grammatizeMods(i, r, e.mods), i;
  }
  grammatizeMoneyValue(e, r) {
    const n = e.category.pos === "prefix" ? ll(e.number).before(this.grammatizeCurrencySymbol(e.category, r)) : ll(e.number).after(this.grammatizeCurrencySymbol(e.category, r));
    let i;
    return "scale" in e && e.scale !== void 0 && !Nf(e.scale, Ol[1]) ? i = Ts(n, this.grammatize(e.scale, r)) : i = Ts(n), this.grammatizeMods(i, r, e.mods), i;
  }
  grammatizePlainDateTime(e, r) {
    if (e.unit === "year")
      return bP(`${e.datetime.year}`);
    if (e.unit === "quarter") {
      const n = (e.datetime.month - 1) / 3 + 1;
      if (![1, 2, 3, 4].includes(n))
        throw new Error(`[Grammatize-Information]: PlainDateTime ${e.datetime} does not represent a quarter.`);
      return Ts(Qm("the"), ll(n).dOpt({ ord: !0 }), mP("quarter"), dp(pp("of"), bP(`${e.datetime.year}`)));
    }
    e.unit;
  }
  grammatizeMods(e, r, n) {
    const i = n ?? [], s = i.filter((a) => bt.modPosition(a) === "prepend"), o = i.filter((a) => bt.modPosition(a) === "postpend");
    for (const a of s.reverse())
      e.add(this.grammatize(a, r), 0);
    for (const a of o)
      e.add(this.grammatize(a, r));
  }
  grammatizeEntityMods(e, r, n, i, s, o, a) {
    const [l, c] = j3e(
      a ?? [],
      (h) => bt.modPosition(h) === "prepend"
    );
    this.grammatizeMods(i, o, l);
    const p = Ts(e, r, n, s, i);
    return this.grammatizeMods(p, o, c), p;
  }
  grammatizePoss(e, r) {
    const n = pp(bt.POSS_AUX[r]);
    return "auxTag" in e && n.tag(e.auxTag.name, e.auxTag.attributes), dp(n, this.grammatize(e.possessor, r));
  }
  grammatizeRelative(e, r) {
    const n = bt.REL[e.relativizer][r], i = n ? hp(n) : null;
    "auxTag" in e && i && i.tag(e.auxTag.name, e.auxTag.attributes);
    const s = N3e(e.restrictive, i, this.grammatize(e.clause, r));
    return e.restrictive || s.before(_u(",")), s;
  }
  grammatizePurpose(e, r) {
    const n = pp(bt.PURPOSE_AUX[e.subtype][r]);
    return "auxTag" in e && n.tag(e.auxTag.name, e.auxTag.attributes), dp(n, this.grammatize(e.purpose, r));
  }
  grammatizeManner(e, r) {
    const n = hp(e.manner[r]);
    return e.aux ? yP(n, pp(e.aux[r])) : n;
  }
  grammatizeQuantifier(e, r) {
    const n = e.quantifier[r], i = e.adverb ? hp(n) : Qm(n);
    return e.aux ? yP(i, pp(e.aux[r])) : i;
  }
  grammatizeMode(e, r) {
    return hp(e.mode[r]);
  }
  grammatizeDir(e, r) {
    const n = e.aux ? this.grammatize(e.aux, r) : null;
    return dp(pp(e.direction[r]), n);
  }
  grammatizeLoc(e, r) {
    return dp(this.grammatize(e.direction, r), this.grammatize(e.point, r));
  }
  grammatizePath(e, r) {
    const n = this.grammatize(Oe.FROM, r);
    e.startTag && n.tag(e.startTag.name, e.startTag.attributes);
    const i = this.grammatize(Oe.TO, r);
    return e.endTag && i.tag(e.endTag.name, e.endTag.attributes), dp(
      n,
      this.grammatize(e.start, r),
      i,
      this.grammatize(e.end, r)
    );
  }
  grammatizePredicate(e, r, n = "s") {
    return e.forceNumber && (n = bt.normalizeNumber(e.forceNumber)), B3(e.pred[r], e.tense, n);
  }
  grammatizeSimpleClause(e, r, n = "s") {
    var i;
    const s = e.pred ? this.grammatize(e.pred, r, n) : void 0, o = (i = e.pred) != null && i.aux ? hp(e.pred.aux[r]) : void 0, a = e.object ? this.grammatize(e.object, r) : void 0, l = z3(s, o, a);
    return this.grammatizeMods(l, r, e.mods), l;
  }
  grammatizeSimpleStatement(e, r) {
    const n = e.subject ? this.grammatize(e.subject, r) : hp("there"), i = e.subject ? bt.entityNumber(e.subject) : "p", s = F3(n, this.grammatize(e.clause, r, i));
    return this.grammatizeMods(s, r, e.mods), s;
  }
  grammatizeLabel(e, r) {
    return F3(_u(e.text).a(":"));
  }
  grammatizeQuote(e, r) {
    return _u(e.text);
  }
  grammatizeConnective(e, r) {
    const n = e.real[r];
    return n.includes(" ") ? _u(n) : M3e(n);
  }
  /*if (this.abbrevs.includes('DROP-COMMON-SUBJ') &&
    this.lhs instanceof SimpleStatement &&
    this.rhs instanceof SimpleStatement &&
    this.lhs.subjectEquals(this.rhs) &&
    this.rhs.clause.object !== null
  ) {
    return S(this.lhs.grammatize(lang), this.conn.grammatize(lang), this.rhs.grammatizeVP(lang));
  }*/
  grammatizeCoord(e, r, n) {
    const i = e.coords.map((a) => this.grammatize(a, r, n)), s = this.grammatize(e.conn, r);
    e.firstComma && i.length === 2 && i[0].after(_u(","));
    const o = D3e(s, ...i).oxfordify();
    return bt.isSimpleStatement(e.coords[0]) ? F3(o) : bt.isCategory(e.coords[0]) ? Ts(o) : o;
  }
}
class V3e extends z3e {
  constructor() {
    super(...arguments), _i(this, "mentioned", []);
  }
  words(e) {
    return e.trim().split(" ");
  }
  allSame(e) {
    const r = e[0];
    return r === void 0 ? !1 : e.every((n) => n === r);
  }
  getMiddle(e) {
    return this.words(e).slice(1, -1).join(" ");
  }
  grammatizeSimpleEntity(e, r) {
    if (B3e(this.mentioned, e)) {
      if (!e.mods || e.mods.length === 0)
        return super.grammatizeSimpleEntity(e, r);
      const n = t2(e);
      return n.mods = n.mods.filter(
        (i) => !bt.isPossession(i) && !(bt.isSimpleCategory(i) && i.inessential) && !(bt.isLocation(i) && i.inessential)
      ), super.grammatizeSimpleEntity(n, r);
    }
    return this.mentioned.push(e), super.grammatizeSimpleEntity(e, r);
  }
  grammatizeCoord(e, r, n) {
    if (bt.isSimpleEntity(e.coords[0])) {
      const i = e.coords;
      if (i.some((l) => !bt.isSimpleCategory(l.category)))
        return super.grammatizeCoord(e, r, n);
      const s = i.map((l) => l.category.noun[r]), o = s.map((l) => this.words(l).at(0)), a = s.map((l) => this.words(l).at(-1));
      if (this.allSame(o) && this.allSame(a) && o[0] !== a[0]) {
        const l = o[0], c = a[0], p = s.map((b) => this.getMiddle(b)).map((b) => xe.noun(b)), h = xe.and(...p), d = {
          type: "simple-entity",
          detType: "indefinite",
          //FIXME: is this always the wanted determiner?
          number: "plural",
          category: xe.noun(c),
          mods: [xe.adj(l), h]
        };
        return this.grammatize(d, r, n);
      }
    }
    return super.grammatizeCoord(e, r, n);
  }
  grammatizeMultiple(e, r) {
    const n = e.map((i) => this.grammatize(i, r));
    return this.mentioned = [], n;
  }
}
class U3e extends Error {
}
class Tu extends Error {
  constructor(e) {
    super(`[ParaSummary]: Problem processesing summary request.
` + e);
  }
}
const SF = Symbol.for("filter-series"), AF = Symbol.for("filter-datapoint"), H3e = Symbol.for("filter-series-datapoint"), kF = Symbol.for("filter-series-intersection"), vP = {
  [SF]: { name: "series", pattern: /^\?\(@.key === '(.+)'\)$/ },
  [AF]: { name: "datapoint", pattern: /^\?\(@.label === '(.+)' && @.value === '(.+)'\)$/ },
  [H3e]: { name: "series-datapoint", pattern: /^\?\(@.label === '(.+)'\)$/ },
  [kF]: { name: "series-intersection", pattern: /^\?\(@.series.includes\('(.+)'\)\)$/ }
};
function G3e(t, e) {
  const r = e.pattern.exec(t);
  if (r === null)
    throw new Tu(
      `Filter expression '${t}' in request did not match pattern for ${e.name}`
    );
  return r.slice(1);
}
const r2 = Symbol.for("number"), Fu = Symbol.for("end-of-request"), W3e = {
  "*": "allSeries",
  [SF]: {
    trend: "seriesTrend",
    stats: {
      max: "seriesMax",
      min: "seriesMin",
      extremes: "seriesExtremes"
    },
    datapoints: {
      [r2]: "seriesDatapoint"
    },
    record_count: "seriesRecordCount",
    ranking: "seriesRanking",
    [Fu]: "specificSeries"
  }
}, q3e = {
  $: {
    datasets: {
      0: {
        series: W3e,
        datapoints: {
          [AF]: "datapoint"
        },
        axes: {
          dependent: {
            [Fu]: "dependentAxis",
            __label: "dependentAxisLabel"
          },
          independent: {
            [Fu]: "independentAxis"
          }
        },
        intersections: {
          "*": "allIntersection",
          [r2]: "intersection",
          [kF]: {
            [Fu]: "seriesIntersections"
          }
        },
        clusters: {
          "*": "allCluster"
        },
        trackingGroups: {
          "*": "allTrackingGroup"
        },
        theme: "chartTheme",
        labels: "chartLabels",
        stats: {
          max: "chartMax",
          min: "chartMin",
          extremes: "chartExtremes"
        },
        trend: "onlySeriesTrend",
        highestRanking: "highestRanking",
        [Fu]: "chart"
      }
    }
  }
};
class Q3e {
  constructor(e, r) {
    Vt(this, "cursor", 0), Vt(this, "tree", q3e), Vt(this, "args", []), this.request = e, this.parsedRequest = r;
  }
  get remainingRequest() {
    return this.parsedRequest.slice(this.cursor);
  }
  dispatch() {
    for (; ; ) {
      const e = this.processSegment();
      if (typeof e == "string")
        return [e, this.args];
      this.tree = e, this.cursor++;
    }
  }
  processSegment() {
    if (this.remainingRequest.length === 0)
      return this.endOfRequest();
    const e = this.remainingRequest[0].expression;
    if (e.type === "root")
      return this.root();
    if (e.type === "wildcard")
      return this.wildcard();
    if (e.type === "identifier") {
      const r = this.trySpecificIdentifier(e.value);
      if (r !== null)
        return r;
      throw new n2(`identifier: ${e.value}`);
    }
    if (e.type === "numeric_literal") {
      const r = e.value, n = this.trySpecificNumber(r);
      return n !== null ? n : this.anyNumber(r);
    }
    if (e.type === "filter_expression")
      return this.filter();
    throw new n2("other segment");
  }
  endOfRequest() {
    if (Fu in this.tree)
      return this.tree[Fu];
    throw new Tu("Request ended too early. Expected one of: " + Object.keys(this.tree));
  }
  root() {
    if ("$" in this.tree)
      return this.tree.$;
    throw new Tu(`The root segment "$" is not allowed at segment ${this.cursor}`);
  }
  wildcard() {
    if ("*" in this.tree)
      return this.tree["*"];
    throw new Tu(`The wildcard segment "*" is not allowed at segment ${this.cursor}`);
  }
  trySpecificIdentifier(e) {
    return e in this.tree ? this.tree[e] : null;
  }
  trySpecificNumber(e) {
    return e in this.tree ? this.tree[e] : null;
  }
  anyNumber(e) {
    if (r2 in this.tree)
      return this.args.push(String(e)), this.tree[r2];
    throw new Tu(`The numeric index "${e}" is not allowed at segment ${this.cursor}`);
  }
  filter() {
    const e = this.remainingRequest[0].expression.value, r = Object.getOwnPropertySymbols(vP).filter(
      (s) => s in this.tree
    );
    if (r.length === 0)
      throw new Tu(`The filter expression "${e}" is not allowed at segment ${this.cursor}`);
    if (r.length > 1)
      throw new Tu(`Unreachable: multiple filter expression should not exist in a tree (segment ${this.cursor})`);
    const n = r[0], i = G3e(e, vP[n]);
    return this.args.push(...i), this.tree[n];
  }
}
function z0(t) {
  return {
    name: "span",
    attributes: {
      "data-navcode": t
    }
  };
}
function Jt(t, e) {
  return xe.tag({ ...t }, "span", { "data-navcode": e });
}
const _F = new DOMParser();
function K3e(t, e) {
  const r = t.querySelector("parsererror");
  if (r)
    throw new Error(`[ParaSummary Internal]: Error in highlight parsing. 
 Error: ${r.textContent} 
 Text: ${e}`);
}
function Y3e(t, e) {
  let r = _F.parseFromString(`<p>${t}</p>`, "text/xml");
  if (K3e(r, t), r.documentElement.childNodes.length < 2)
    return t;
  let n = null, i = null, s = "";
  for (const o of r.documentElement.childNodes)
    if (n === null)
      n = o, i = n.getAttribute("data-navcode");
    else {
      const a = o.getAttribute("data-navcode");
      if (i !== null && a !== null && i === a || o.textContent === " " || o.textContent === ", " || o.textContent === ". " || o.textContent === ".  ") {
        n.textContent = n.textContent + o.textContent;
        const l = o.getAttribute("data-phrasecode"), c = e.findIndex((d) => d.phrasecode === l), p = n.getAttribute("data-phrasecode"), h = e.find((d) => d.phrasecode === p);
        h.end = e[c].end, e.splice(c, 1);
      } else
        s += n.outerHTML, n = o, i = n.getAttribute("data-navcode");
    }
  return s += n.outerHTML, s;
}
function P4(t) {
  let e = _F.parseFromString(`<p>${t}</p>`, "text/xml");
  const r = e.querySelector("parsererror");
  if (r)
    throw new Error(`[ParaSummary Internal]: Error in highlight parsing. 
 Error: ${r.textContent} 
 Text: ${t}`);
  let n = "", i = "";
  const s = [];
  let o = 0;
  for (const a of e.documentElement.childNodes) {
    const l = n.length;
    n += a.textContent;
    const c = n.length, p = o;
    if (o++, a.nodeName === "#text")
      i += `<span data-phrasecode="${p}">${a.textContent}</span>`, s.push({ start: l, end: c, phrasecode: `${p}` });
    else {
      const h = a.getAttribute("data-navcode");
      a.setAttribute("data-phrasecode", `${p}`), i += a.outerHTML, s.push({ start: l, end: c, phrasecode: `${p}`, navcode: h });
    }
  }
  return i = Y3e(i, s), { text: n, html: i, highlights: s };
}
var Z3e = Object.defineProperty, J3e = Object.getOwnPropertyDescriptor, CF = (t, e, r, n) => {
  for (var i = J3e(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && Z3e(e, r, i), i;
};
class n2 extends Error {
  constructor(e) {
    super(`Not implemented yet: ${e}`);
  }
}
let Qr = class extends Error {
  constructor(e) {
    super("[ParaSummary]: " + e);
  }
};
function on(t) {
  return console.warn(`[ParaSummary]: ${t}`), [];
}
function V3(t) {
  return console.warn(`[ParaSummary]: ${t}`), { text: "", html: "" };
}
const Cu = {
  seriesChartMin: "Series low and chart low",
  seriesMin: "Series low",
  seriesChartMax: "Series high and chart high",
  seriesMax: "Series high",
  firstDatapoint: "First datapoint in ${seriesLabel:string}",
  lastDatapoint: "Last datapoint in ${seriesLabel:string}",
  intersection: "Intersection between ${intersectLabels:string[]} at this point"
};
async function X3e() {
  await F3e();
}
class pv {
  constructor(e) {
    Vt(this, "grammatizator", new V3e()), this._model = e;
  }
  /**
   * Determines whether an y-value is the highest/lowest value on a series/the chart. Note: a chart
   * max/min must also be a series max/min
   * @param value The y-value
   * @param seriesKey The series being considered
   * @returns Whether the  y-value is the highest/lowest value on a series/the chart
   */
  getDatapointMinMax(e, r) {
    const n = [], i = this._model.atKey(r).getFacetStats("y").min.value, s = this._model.getFacetStats("y").min.value, o = this._model.atKey(r).getFacetStats("y").max.value, a = this._model.getFacetStats("y").max.value;
    return e === s ? n.push(Cu.seriesChartMin) : e === i && n.push(Cu.seriesMin), e === a ? n.push(Cu.seriesChartMax) : e === o && n.push(Cu.seriesMax), n;
  }
  intersectionKeys(e) {
    const r = /* @__PURE__ */ new Set();
    if (!this._model.isPlaneModel())
      return r;
    for (const n of this._model.intersections)
      n.record.labelValue !== null && n.record.labelValue === e.facetValueAsNumber("x") && n.value === e.facetValueAsNumber("y") && (r.add(n.series[0]), r.add(n.series[1]));
    return r;
  }
  getDatapointSummary(e, r) {
    const n = [], i = e.seriesKey;
    n.push(y2e(e, r));
    const s = e.facetValueAsNumber("y"), o = this.getDatapointMinMax(s, i);
    o.length && n.push(...o);
    const a = this._model.atKey(i).getLabel();
    e.datapointIndex === 0 ? n.push(qn(Cu.firstDatapoint, { seriesLabel: a })) : e.datapointIndex === this._model.atKey(i).length - 1 && n.push(qn(Cu.lastDatapoint, { seriesLabel: a }));
    const l = Array.from(this.intersectionKeys(e)).map((c) => this._model.atKey(c).getLabel());
    return l.length > 0 && n.push(qn(Cu.intersection, { intersectLabels: l })), n.join(". ") + ".";
  }
  getDatapointSummaryAllPoints(e, r) {
    return `${this._model.atKey(e.seriesKey).getLabel()}, ${e.datapointIndex}, all points`;
  }
  parseRequest(e) {
    let r;
    try {
      r = y4.parse(e);
    } catch (n) {
      throw n instanceof Error && (n.message.startsWith("Parse error") || n.message.startsWith("Lexical error")) ? new U3e(`[ParaSummary]: Summary request is not a valid JSONPath
` + n.message) : n;
    }
    return r;
  }
  dispatchRequest(e, r) {
    return new Q3e(e, r).dispatch();
  }
  async requestSummary(e) {
    const r = this.parseRequest(e), [n, i] = this.dispatchRequest(e, r), s = this.getSummarizer()[n].call(this.getSummarizer(), ...i);
    return Promise.resolve(s);
  }
  async requestSummaries(e) {
    const r = e.map((n) => this.requestSummary(n));
    return Promise.all(r).then((n) => n.flat());
  }
  grammatizeComponents(e) {
    return this.grammatizator.grammatizeMultiple(e, "en").map((r) => r.toString()).join(" ").trim();
  }
  highlightComponents(e) {
    const r = this.grammatizeComponents(e);
    return P4(r);
  }
  async grammatizeSummaries(e) {
    const r = await this.requestSummaries(e);
    return this.grammatizeComponents(r);
  }
  async highlightSummaries(e) {
    const r = await this.grammatizeSummaries(e);
    return P4(r);
  }
}
CF([
  jd()
], pv.prototype, "getDatapointSummary");
CF([
  jd()
], pv.prototype, "getDatapointSummaryAllPoints");
function exe(t) {
  if (t.length === 0)
    return 0;
  var e = t[0], r = 0, n;
  if (typeof e != "number")
    return Number.NaN;
  for (var i = 1; i < t.length; i++) {
    if (typeof t[i] != "number")
      return Number.NaN;
    n = e + t[i], Math.abs(e) >= Math.abs(t[i]) ? r += e - n + t[i] : r += t[i] - n + e, e = n;
  }
  return e + r;
}
function txe(t) {
  if (t.length === 0)
    throw new Error("mean requires at least one data point");
  return exe(t) / t.length;
}
function rxe(t, e) {
  const r = [];
  for (let n = 0; n < t; n++)
    r.push(e(n));
  return r;
}
function Mi(t, e, r, n, i) {
  return ja(e, ((s, o) => {
    const a = s[o];
    if (a === void 0)
      throw new TypeError(VA(o));
    return a;
  })(t, e), r, n, i);
}
function ja(t, e, r, n, i, s) {
  const o = U0(e, r, n);
  if (i && e !== o)
    throw new RangeError(zz(t, e, r, n, s));
  return o;
}
function Ei(t) {
  return t !== null && /object|function/.test(typeof t);
}
function ws(t, e = Map) {
  const r = new e();
  return (n, ...i) => {
    if (r.has(n))
      return r.get(n);
    const s = t(n, ...i);
    return r.set(n, s), s;
  };
}
function V0(t) {
  return id({
    name: t
  }, 1);
}
function id(t, e) {
  return Ba((r) => ({
    value: r,
    configurable: 1,
    writable: !e
  }), t);
}
function nxe(t) {
  return Ba((e) => ({
    get: e,
    configurable: 1
  }), t);
}
function K8(t) {
  return {
    [Symbol.toStringTag]: {
      value: t,
      configurable: 1
    }
  };
}
function Jd(t, e) {
  const r = {};
  let n = t.length;
  for (const i of e)
    r[t[--n]] = i;
  return r;
}
function Ba(t, e, r) {
  const n = {};
  for (const i in e)
    n[i] = t(e[i], i, r);
  return n;
}
function dv(t, e, r) {
  const n = {};
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    n[s] = t(s, i, r);
  }
  return n;
}
function IF(t, e, r) {
  const n = {};
  for (let i = 0; i < t.length; i++)
    n[e[i]] = r[t[i]];
  return n;
}
function fo(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const n of t)
    r[n] = e[n];
  return r;
}
function wP(t, e) {
  for (const r of e)
    if (r in t)
      return 1;
  return 0;
}
function PF(t, e, r) {
  for (const n of t)
    if (e[n] !== r[n])
      return 0;
  return 1;
}
function RF(t, e, r) {
  const n = {
    ...r
  };
  for (let i = 0; i < e; i++)
    n[t[i]] = 0;
  return n;
}
function sr(t, ...e) {
  return (...r) => t(...e, ...r);
}
function xP(t) {
  return t[0].toUpperCase() + t.substring(1);
}
function sm(t) {
  return t.slice().sort();
}
function i2(t, e) {
  return String(e).padStart(t, "0");
}
function Ul(t, e) {
  return Math.sign(t - e);
}
function U0(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
function ka(t, e) {
  return [Math.floor(t / e), e0(t, e)];
}
function e0(t, e) {
  return (t % e + e) % e;
}
function sc(t, e) {
  return [fv(t, e), Y8(t, e)];
}
function fv(t, e) {
  return Math.trunc(t / e) || 0;
}
function Y8(t, e) {
  return t % e || 0;
}
function Km(t) {
  return Math.abs(t % 1) === 0.5;
}
function OF(t, e, r) {
  let n = 0, i = 0;
  for (let a = 0; a <= e; a++) {
    const l = t[r[a]], c = Ko[a], p = zr / c, [h, d] = sc(l, p);
    n += d * c, i += h;
  }
  const [s, o] = sc(n, zr);
  return [i + s, o];
}
function gv(t, e, r) {
  const n = {};
  for (let i = e; i >= 0; i--) {
    const s = Ko[i];
    n[r[i]] = fv(t, s), t = Y8(t, s);
  }
  return n;
}
function ixe(t) {
  if (t !== void 0)
    return ei(t);
}
function sxe(t) {
  if (t !== void 0)
    return ga(t);
}
function TF(t) {
  if (t !== void 0)
    return Z8(t);
}
function ga(t) {
  return NF(Z8(t));
}
function Z8(t) {
  return MF(gEe(t));
}
function LF(t, e) {
  if (e == null)
    throw new RangeError(VA(t));
  return e;
}
function om(t) {
  if (!Ei(t))
    throw new TypeError(F4e);
  return t;
}
function J8(t, e, r = t) {
  if (typeof e !== t)
    throw new TypeError(Qc(r, e));
  return e;
}
function MF(t, e = "number") {
  if (!Number.isInteger(t))
    throw new RangeError(M4e(e, t));
  return t || 0;
}
function NF(t, e = "number") {
  if (t <= 0)
    throw new RangeError(N4e(e, t));
  return t;
}
function X8(t) {
  if (typeof t == "symbol")
    throw new TypeError(B4e);
  return String(t);
}
function D1(t, e) {
  return Ei(t) ? String(t) : ei(t, e);
}
function eA(t) {
  if (typeof t == "string")
    return BigInt(t);
  if (typeof t != "bigint")
    throw new TypeError(j4e(t));
  return t;
}
function DF(t, e = "number") {
  if (typeof t == "bigint")
    throw new TypeError($4e(e));
  if (t = Number(t), !Number.isFinite(t))
    throw new RangeError(D4e(e, t));
  return t;
}
function oi(t, e) {
  return Math.trunc(DF(t, e)) || 0;
}
function tA(t, e) {
  return MF(DF(t, e), e);
}
function EP(t, e) {
  return NF(oi(t, e), e);
}
function rA(t, e) {
  let [r, n] = sc(e, zr), i = t + r;
  const s = Math.sign(i);
  return s && s === -Math.sign(n) && (i -= s, n += s * zr), [i, n];
}
function sd(t, e, r = 1) {
  return rA(t[0] + e[0] * r, t[1] + e[1] * r);
}
function Eh(t, e) {
  return rA(t[0], t[1] + e);
}
function qo(t, e) {
  return sd(e, t, -1);
}
function xs(t, e) {
  return Ul(t[0], e[0]) || Ul(t[1], e[1]);
}
function $F(t, e, r) {
  return xs(t, e) === -1 || xs(t, r) === 1;
}
function nA(t, e = 1) {
  const r = BigInt(zr / e);
  return [Number(t / r), Number(t % r) * e];
}
function s2(t, e = 1) {
  const r = zr / e, [n, i] = sc(t, r);
  return [n, i * e];
}
function Qo(t, e = 1, r) {
  const [n, i] = t, [s, o] = sc(i, e);
  return n * (zr / e) + (s + (r ? o / e : 0));
}
function iA(t, e, r = ka) {
  const [n, i] = t, [s, o] = r(i, e);
  return [n * (zr / e) + s, o];
}
function sA(t) {
  return Mi(t, "isoYear", K0, Q0, 1), t.isoYear === K0 ? Mi(t, "isoMonth", 4, 12, 1) : t.isoYear === Q0 && Mi(t, "isoMonth", 1, 9, 1), t;
}
function Us(t) {
  return Zi({
    ...t,
    ...Ji,
    isoHour: 12
  }), t;
}
function Zi(t) {
  const e = Mi(t, "isoYear", K0, Q0, 1), r = e === K0 ? 1 : e === Q0 ? -1 : 0;
  return r && oa(On({
    ...t,
    isoDay: t.isoDay + r,
    isoNanosecond: t.isoNanosecond - r
  })), t;
}
function oa(t) {
  if (!t || $F(t, SEe, EEe))
    throw new RangeError(Kc);
  return t;
}
function oc(t) {
  return OF(t, 5, yo)[1];
}
function mv(t) {
  const [e, r] = ka(t, zr);
  return [gv(r, 5, yo), e];
}
function SP(t) {
  return iA(t, $o);
}
function hi(t) {
  return Xd(t.isoYear, t.isoMonth, t.isoDay, t.isoHour, t.isoMinute, t.isoSecond, t.isoMillisecond);
}
function On(t) {
  const e = hi(t);
  if (e !== void 0) {
    const [r, n] = sc(e, zi);
    return [r, n * sl + (t.isoMicrosecond || 0) * dm + (t.isoNanosecond || 0)];
  }
}
function oA(t, e) {
  const [r, n] = mv(oc(t) - e);
  return oa(On({
    ...t,
    isoDay: t.isoDay + n,
    ...r
  }));
}
function o2(...t) {
  return Xd(...t) / Yz;
}
function Xd(...t) {
  const [e, r] = jF(...t), n = e.valueOf();
  if (!isNaN(n))
    return n - r * zi;
}
function jF(t, e = 1, r = 1, n = 0, i = 0, s = 0, o = 0) {
  const a = t === K0 ? 1 : t === Q0 ? -1 : 0, l = /* @__PURE__ */ new Date();
  return l.setUTCHours(n, i, s, o), l.setUTCFullYear(t, e - 1, r + a), [l, a];
}
function ef(t, e) {
  let [r, n] = Eh(t, e);
  n < 0 && (n += zr, r -= 1);
  const [i, s] = ka(n, sl), [o, a] = ka(s, dm);
  return yv(r * zi + i, o, a);
}
function yv(t, e = 0, r = 0) {
  const n = Math.ceil(Math.max(0, Math.abs(t) - xEe) / zi) * Math.sign(t), i = new Date(t - n * zi);
  return Jd(jv, [i.getUTCFullYear(), i.getUTCMonth() + 1, i.getUTCDate() + n, i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds(), e, r]);
}
function aA(t, e) {
  if (e < -864e13)
    throw new RangeError(Kc);
  const r = t.formatToParts(e), n = {};
  for (const i of r)
    n[i.type] = i.value;
  return n;
}
function lA(t) {
  return [t.isoYear, t.isoMonth, t.isoDay];
}
function BF(t, e) {
  return [e, 0];
}
function FF() {
  return bl;
}
function zF(t, e) {
  switch (e) {
    case 2:
      return cA(t) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function VF(t) {
  return cA(t) ? 366 : 365;
}
function cA(t) {
  return t % 4 == 0 && (t % 100 != 0 || t % 400 == 0);
}
function UF(t) {
  const [e, r] = jF(t.isoYear, t.isoMonth, t.isoDay);
  return e0(e.getUTCDay() - r, 7) || 7;
}
function HF(t) {
  return this.id === cf ? (({ isoYear: e }) => e < 1 ? ["gregory-inverse", 1 - e] : ["gregory", e])(t) : this.id === cc ? _Ee(t) : [];
}
function oxe(t) {
  const e = hi(t);
  if (e < kEe) {
    const { isoYear: s } = t;
    return s < 1 ? ["japanese-inverse", 1 - s] : ["japanese", s];
  }
  const r = aA(l9(cc), e), { era: n, eraYear: i } = Rz(r, cc);
  return [n, i];
}
function bv(t) {
  return qh(t), tf(t, 1), t;
}
function qh(t) {
  return GF(t, 1), t;
}
function AP(t) {
  return PF(ZA, t, GF(t));
}
function GF(t, e) {
  const { isoYear: r } = t, n = Mi(t, "isoMonth", 1, FF(), e);
  return {
    isoYear: r,
    isoMonth: n,
    isoDay: Mi(t, "isoDay", 1, zF(r, n), e)
  };
}
function tf(t, e) {
  return Jd(yo, [Mi(t, "isoHour", 0, 23, e), Mi(t, "isoMinute", 0, 59, e), Mi(t, "isoSecond", 0, 59, e), Mi(t, "isoMillisecond", 0, 999, e), Mi(t, "isoMicrosecond", 0, 999, e), Mi(t, "isoNanosecond", 0, 999, e)]);
}
function yr(t) {
  return t === void 0 ? 0 : pV(om(t));
}
function vv(t, e = 0) {
  t = aa(t);
  const r = dV(t), n = DEe(t, e);
  return [pV(t), n, r];
}
function rf(t, e, r, n = 9, i = 0, s = 4) {
  e = aa(e);
  let o = hV(e, n, i), a = pA(e), l = mm(e, s);
  const c = gm(e, n, i, 1);
  return o == null ? o = Math.max(r, c) : KF(o, c), a = dA(a, c, 1), t && (l = ((p) => p < 4 ? (p + 2) % 4 : p)(l)), [o, c, a, l];
}
function wv(t, e = 6, r) {
  let n = pA(t = xv(t, p2));
  const i = mm(t, 7);
  let s = gm(t, e);
  return s = LF(p2, s), n = dA(n, s, void 0, r), [s, n, i];
}
function uA(t) {
  return XA(aa(t));
}
function WF(t, e) {
  return hA(aa(t), e);
}
function axe(t) {
  const e = xv(t, Y3), r = Uc(Y3, MEe, e, 0);
  if (!r)
    throw new RangeError(Qc(Y3, r));
  return r;
}
function hA(t, e = 4) {
  const r = QF(t);
  return [mm(t, 4), ...qF(gm(t, e), r)];
}
function qF(t, e) {
  return t != null ? [Ko[t], t < 4 ? 9 - 3 * t : -1] : [e === void 0 ? 1 : 10 ** (9 - e), e];
}
function pA(t) {
  const e = t[t0];
  return e === void 0 ? 1 : oi(e, t0);
}
function dA(t, e, r, n) {
  const i = n ? zr : Ko[e + 1];
  if (i) {
    const s = Ko[e];
    if (i % ((t = ja(t0, t, 1, i / s - (n ? 0 : 1), 1)) * s))
      throw new RangeError(Qc(t0, t));
  } else
    t = ja(t0, t, 1, r ? 10 ** 9 : 1, 1);
  return t;
}
function QF(t) {
  let e = t[K3];
  if (e !== void 0) {
    if (typeof e != "number") {
      if (X8(e) === "auto")
        return;
      throw new RangeError(Qc(K3, e));
    }
    e = ja(K3, Math.floor(e), 0, 9, 1);
  }
  return e;
}
function aa(t) {
  return t === void 0 ? {} : om(t);
}
function xv(t, e) {
  return typeof t == "string" ? {
    [e]: t
  } : om(t);
}
function Ev(t) {
  return {
    overflow: CEe[t]
  };
}
function fA(t, e, r = 9, n = 0, i) {
  let s = e[t];
  if (s === void 0)
    return i ? n : void 0;
  if (s = X8(s), s === "auto")
    return i ? n : null;
  let o = L4[s];
  if (o === void 0 && (o = bEe[s]), o === void 0)
    throw new RangeError(Uz(t, s, L4));
  return ja(t, o, n, r, 1, UA), o;
}
function Uc(t, e, r, n = 0) {
  const i = r[t];
  if (i === void 0)
    return n;
  const s = X8(i), o = e[s];
  if (o === void 0)
    throw new RangeError(Uz(t, s, e));
  return o;
}
function KF(t, e) {
  if (e > t)
    throw new RangeError(aEe);
}
function nl(t) {
  return {
    branding: n9,
    epochNanoseconds: t
  };
}
function go(t, e, r) {
  return {
    branding: Yc,
    calendar: r,
    timeZone: e,
    epochNanoseconds: t
  };
}
function mo(t, e = t.calendar) {
  return {
    branding: uf,
    calendar: e,
    ...fo(vEe, t)
  };
}
function il(t, e = t.calendar) {
  return {
    branding: ym,
    calendar: e,
    ...fo(JA, t)
  };
}
function H0(t, e = t.calendar) {
  return {
    branding: e9,
    calendar: e,
    ...fo(JA, t)
  };
}
function a2(t, e = t.calendar) {
  return {
    branding: t9,
    calendar: e,
    ...fo(JA, t)
  };
}
function la(t) {
  return {
    branding: r9,
    ...fo(oV, t)
  };
}
function wn(t) {
  return {
    branding: i9,
    sign: Hc(t),
    ...fo(QA, t)
  };
}
function gA(t) {
  return iA(t.epochNanoseconds, sl)[0];
}
function lxe(t) {
  return ((e, r = 1) => {
    const [n, i] = e, s = Math.floor(i / r), o = zr / r;
    return BigInt(n) * BigInt(o) + BigInt(s);
  })(t.epochNanoseconds);
}
function YF(t) {
  return t.epochNanoseconds;
}
function cxe(t, e, r, n, i) {
  const s = Sh(n), [o, a] = ((E, A) => {
    const x = A((E = xv(E, D4))[cV]);
    let g = NEe(E);
    return g = LF(D4, g), [g, x];
  })(i, t), l = Math.max(o, s);
  if (!a && W0(l, a))
    return kP(n, o);
  if (!a)
    throw new RangeError(Nv);
  if (!n.sign)
    return 0;
  const [c, p, h] = Cv(e, r, a), d = AA(h), b = Iv(h), m = kA(h), w = b(p, c, n);
  od(a) || (Zi(c), Zi(w));
  const f = m(p, c, w, o);
  return W0(o, a) ? kP(f, o) : ((E, A, x, g, v, k, S) => {
    const R = Hc(E), [L, F] = mA(g, YA(x, E), x, R, v, k, S), z = yA(A, L, F);
    return E[xr[x]] + z * R;
  })(f, d(w), o, p, c, d, b);
}
function kP(t, e) {
  return Qo($n(t), Ko[e], 1);
}
function mA(t, e, r, n, i, s, o) {
  const a = xr[r], l = {
    ...e,
    [a]: e[a] + n
  }, c = o(t, i, e), p = o(t, i, l);
  return [s(c), s(p)];
}
function yA(t, e, r) {
  const n = Qo(qo(e, r));
  if (!n)
    throw new RangeError(lf);
  return Qo(qo(e, t)) / n;
}
function uxe(t, e) {
  const [r, n, i] = wv(e, 5, 1);
  return nl(Av(t.epochNanoseconds, r, n, i, 1));
}
function hxe(t, e, r) {
  let { epochNanoseconds: n, timeZone: i, calendar: s } = e;
  const [o, a, l] = wv(r);
  if (o === 0 && a === 1)
    return e;
  const c = t(i);
  if (o === 6)
    n = ((p, h, d, b) => {
      const m = Ss(d, h), [w, f] = p(m), E = d.epochNanoseconds, A = lc(h, w), x = lc(h, f);
      if ($F(E, A, x))
        throw new RangeError(lf);
      return tz(yA(E, A, x), b) ? x : A;
    })(XF, c, e, l);
  else {
    const p = c.R(n);
    n = nf(c, ZF(ef(n, p), o, a, l), p, 2, 0, 1);
  }
  return go(n, i, s);
}
function pxe(t, e) {
  return mo(ZF(t, ...wv(e)), t.calendar);
}
function dxe(t, e) {
  const [r, n, i] = wv(e, 5);
  var s;
  return la((s = i, bA(t, am(r, n), s)[0]));
}
function fxe(t, e) {
  const r = t(e.timeZone), n = Ss(e, r), [i, s] = XF(n), o = Qo(qo(lc(r, i), lc(r, s)), $v, 1);
  if (o <= 0)
    throw new RangeError(lf);
  return o;
}
function gxe(t, e) {
  const { timeZone: r, calendar: n } = e, i = ((s, o, a) => lc(o, s(Ss(a, o))))(ez, t(r), e);
  return go(i, r, n);
}
function ZF(t, e, r, n) {
  return JF(t, am(e, r), n);
}
function JF(t, e, r) {
  const [n, i] = bA(t, e, r);
  return Zi({
    ...Qh(t, i),
    ...n
  });
}
function bA(t, e, r) {
  return mv(ac(oc(t), e, r));
}
function l2(t) {
  return ac(t, Dv, 7);
}
function am(t, e) {
  return Ko[t] * e;
}
function XF(t) {
  const e = ez(t);
  return [e, Qh(e, 1)];
}
function ez(t) {
  return wEe(6, t);
}
function mxe(t, e, r) {
  const n = Math.min(Sh(t), 6);
  return sf(kv($n(t, n), e, r), n);
}
function Sv(t, e, r, n, i, s, o, a, l, c) {
  if (n === 0 && i === 1)
    return t;
  const p = W0(n, a) ? od(a) && n < 6 && r >= 6 ? bxe : yxe : vxe;
  let [h, d, b] = p(t, e, r, n, i, s, o, a, l, c);
  return b && n !== 7 && (h = ((m, w, f, E, A, x, g, v) => {
    const k = Hc(m);
    for (let S = E + 1; S <= f; S++) {
      if (S === 7 && f !== 7)
        continue;
      const R = YA(S, m);
      R[xr[S]] += k;
      const L = Qo(qo(g(v(A, x, R)), w));
      if (L && Math.sign(L) !== k)
        break;
      m = R;
    }
    return m;
  })(h, d, r, Math.max(6, n), o, a, l, c)), h;
}
function Av(t, e, r, n, i) {
  if (e === 6) {
    const s = ((o) => o[0] + o[1] / zr)(t);
    return [ac(s, r, n), 0];
  }
  return kv(t, am(e, r), n, i);
}
function kv(t, e, r, n) {
  let [i, s] = t;
  n && s < 0 && (s += zr, i -= 1);
  const [o, a] = ka(ac(s, e, r), zr);
  return rA(i + o, a);
}
function ac(t, e, r) {
  return tz(t / e, r) * e;
}
function tz(t, e) {
  return BEe[e](t);
}
function yxe(t, e, r, n, i, s) {
  const o = Hc(t), a = $n(t), l = Av(a, n, i, s), c = qo(a, l), p = Math.sign(l[0] - a[0]) === o, h = sf(l, Math.min(r, 6));
  return [{
    ...t,
    ...h
  }, sd(e, c), p];
}
function bxe(t, e, r, n, i, s, o, a, l, c) {
  const p = Hc(t) || 1, h = Qo($n(t, 5)), d = am(n, i);
  let b = ac(h, d, s);
  const [m, w] = mA(o, {
    ...t,
    ...KA
  }, 6, p, a, l, c), f = b - Qo(qo(m, w));
  let E = 0;
  f && Math.sign(f) !== p ? e = Eh(m, b) : (E += p, b = ac(f, d, s), e = Eh(w, b));
  const A = Pv(b);
  return [{
    ...t,
    ...A,
    days: t.days + E
  }, e, !!E];
}
function vxe(t, e, r, n, i, s, o, a, l, c) {
  const p = Hc(t), h = xr[n], d = YA(n, t);
  n === 7 && (t = {
    ...t,
    weeks: t.weeks + Math.trunc(t.days / 7)
  });
  const b = fv(t[h], i) * i;
  d[h] = b;
  const [m, w] = mA(o, d, n, i * p, a, l, c), f = b + yA(e, m, w) * p * i, E = ac(f, i, s), A = Math.sign(E - f) === p;
  return d[h] = E, [d, A ? w : m, A];
}
function _P(t, e, r, n) {
  const [i, s, o, a] = ((c) => {
    const p = hA(c = aa(c));
    return [c.timeZone, ...p];
  })(n), l = i !== void 0;
  return ((c, p, h, d, b, m) => {
    h = kv(h, b, d, 1);
    const w = p.R(h);
    return vA(ef(h, w), m) + (c ? lm(l2(w)) : "Z");
  })(l, e(l ? t(i) : Jh), r.epochNanoseconds, s, o, a);
}
function CP(t, e, r) {
  const [n, i, s, o, a, l] = ((c) => {
    c = aa(c);
    const p = XA(c), h = QF(c), d = jEe(c), b = mm(c, 4), m = gm(c, 4);
    return [p, $Ee(c), d, b, ...qF(m, h)];
  })(r);
  return ((c, p, h, d, b, m, w, f, E, A) => {
    d = kv(d, E, f, 1);
    const x = c(h).R(d);
    return vA(ef(d, x), A) + lm(l2(x), w) + ((g, v) => v !== 1 ? "[" + (v === 2 ? "!" : "") + g + "]" : "")(h, m) + wA(p, b);
  })(t, e.calendar, e.timeZone, e.epochNanoseconds, n, i, s, o, a, l);
}
function IP(t, e) {
  const [r, n, i, s] = ((c) => (c = aa(c), [XA(c), ...hA(c)]))(e);
  return o = t.calendar, a = r, l = s, vA(JF(t, i, n), l) + wA(o, a);
  var o, a, l;
}
function PP(t, e) {
  return r = t.calendar, n = t, i = uA(e), c2(n) + wA(r, i);
  var r, n, i;
}
function RP(t, e) {
  return rz(t.calendar, nz, t, uA(e));
}
function OP(t, e) {
  return rz(t.calendar, wxe, t, uA(e));
}
function TP(t, e) {
  const [r, n, i] = WF(e);
  return s = i, iz(bA(t, n, r)[0], s);
  var s;
}
function U3(t, e) {
  const [r, n, i] = WF(e, 3);
  return n > 1 && Kh(t = {
    ...t,
    ...mxe(t, n, r)
  }), ((s, o) => {
    const { sign: a } = s, l = a === -1 ? Si(s) : s, { hours: c, minutes: p } = l, [h, d] = iA($n(l, 3), $o, sc);
    lz(h);
    const b = xA(d, o), m = o >= 0 || !a || b;
    return (a < 0 ? "-" : "") + "P" + LP({
      Y: Iu(l.years),
      M: Iu(l.months),
      W: Iu(l.weeks),
      D: Iu(l.days)
    }) + (c || p || h || m ? "T" + LP({
      H: Iu(c),
      M: Iu(p),
      S: Iu(h, m) + b
    }) : "");
  })(t, i);
}
function rz(t, e, r, n) {
  const i = n > 1 || n === 0 && t !== hr;
  return n === 1 ? t === hr ? e(r) : c2(r) : i ? c2(r) + sz(t, n === 2) : e(r);
}
function LP(t) {
  const e = [];
  for (const r in t) {
    const n = t[r];
    n && e.push(n, r);
  }
  return e.join("");
}
function vA(t, e) {
  return c2(t) + "T" + iz(t, e);
}
function c2(t) {
  return nz(t) + "-" + Hs(t.isoDay);
}
function nz(t) {
  const { isoYear: e } = t;
  return (e < 0 || e > 9999 ? oz(e) + i2(6, Math.abs(e)) : i2(4, e)) + "-" + Hs(t.isoMonth);
}
function wxe(t) {
  return Hs(t.isoMonth) + "-" + Hs(t.isoDay);
}
function iz(t, e) {
  const r = [Hs(t.isoHour), Hs(t.isoMinute)];
  return e !== -1 && r.push(Hs(t.isoSecond) + ((n, i, s, o) => xA(n * sl + i * dm + s, o))(t.isoMillisecond, t.isoMicrosecond, t.isoNanosecond, e)), r.join(":");
}
function lm(t, e = 0) {
  if (e === 1)
    return "";
  const [r, n] = ka(Math.abs(t), $v), [i, s] = ka(n, Dv), [o, a] = ka(s, $o);
  return oz(t) + Hs(r) + ":" + Hs(i) + (o || a ? ":" + Hs(o) + xA(a) : "");
}
function wA(t, e) {
  return e !== 1 && (e > 1 || e === 0 && t !== hr) ? sz(t, e === 2) : "";
}
function sz(t, e) {
  return "[" + (e ? "!" : "") + "u-ca=" + t + "]";
}
function xA(t, e) {
  let r = i2(9, t);
  return r = e === void 0 ? r.replace(VEe, "") : r.slice(0, e), r ? "." + r : "";
}
function oz(t) {
  return t < 0 ? "-" : "+";
}
function Iu(t, e) {
  return t || e ? t.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function xxe(t, e) {
  const { epochNanoseconds: r } = t, n = (e.R ? e : e(t.timeZone)).R(r), i = ef(r, n);
  return {
    calendar: t.calendar,
    ...i,
    offsetNanoseconds: n
  };
}
function nf(t, e, r, n = 0, i = 0, s, o) {
  if (r !== void 0 && n === 1 && (n === 1 || o))
    return oA(e, r);
  const a = t.I(e);
  if (r !== void 0 && n !== 3) {
    const l = ((c, p, h, d) => {
      const b = On(p);
      d && (h = l2(h));
      for (const m of c) {
        let w = Qo(qo(m, b));
        if (d && (w = l2(w)), w === h)
          return m;
      }
    })(a, e, r, s);
    if (l !== void 0)
      return l;
    if (n === 0)
      throw new RangeError(tEe);
  }
  return o ? On(e) : cm(t, e, i, a);
}
function cm(t, e, r = 0, n = t.I(e)) {
  if (n.length === 1)
    return n[0];
  if (r === 1)
    throw new RangeError(rEe);
  if (n.length)
    return n[r === 3 ? 1 : 0];
  const i = On(e), s = ((a, l) => {
    const c = a.R(Eh(l, -864e11));
    return ((p) => {
      if (p > zr)
        throw new RangeError(eEe);
      return p;
    })(a.R(Eh(l, zr)) - c);
  })(t, i), o = s * (r === 2 ? -1 : 1);
  return (n = t.I(ef(i, o)))[r === 2 ? 0 : n.length - 1];
}
function lc(t, e) {
  const r = t.I(e);
  if (r.length)
    return r[0];
  const n = Eh(On(e), -864e11);
  return t.O(n, 1);
}
function MP(t, e, r) {
  return nl(oa(sd(e.epochNanoseconds, ((n) => {
    if (cz(n))
      throw new RangeError(sEe);
    return $n(n, 5);
  })(t ? Si(r) : r))));
}
function NP(t, e, r, n, i, s = /* @__PURE__ */ Object.create(null)) {
  const o = e(n.timeZone), a = t(n.calendar);
  return {
    ...n,
    ...EA(o, a, n, r ? Si(i) : i, s)
  };
}
function DP(t, e, r, n, i = /* @__PURE__ */ Object.create(null)) {
  const { calendar: s } = r;
  return mo(SA(t(s), r, e ? Si(n) : n, i), s);
}
function $P(t, e, r, n, i) {
  const { calendar: s } = r;
  return il(_v(t(s), r, e ? Si(n) : n, i), s);
}
function jP(t, e, r, n, i) {
  const s = r.calendar, o = t(s);
  let a = Us(G0(o, r));
  e && (n = _A(n)), n.sign < 0 && (a = o.P(a, {
    ...jn,
    months: 1
  }), a = Qh(a, -1));
  const l = o.P(a, n, i);
  return H0(G0(o, l), s);
}
function BP(t, e, r) {
  return la(az(e, t ? Si(r) : r)[0]);
}
function EA(t, e, r, n, i) {
  const s = $n(n, 5);
  let o = r.epochNanoseconds;
  if (cz(n)) {
    const a = Ss(r, t);
    o = sd(cm(t, {
      ..._v(e, a, {
        ...n,
        ...KA
      }, i),
      ...fo(yo, a)
    }), s);
  } else
    o = sd(o, s), yr(i);
  return {
    epochNanoseconds: oa(o)
  };
}
function SA(t, e, r, n) {
  const [i, s] = az(e, r);
  return Zi({
    ..._v(t, e, {
      ...r,
      ...KA,
      days: r.days + s
    }, n),
    ...i
  });
}
function _v(t, e, r, n) {
  if (r.years || r.months || r.weeks)
    return t.P(e, r, n);
  yr(n);
  const i = r.days + $n(r, 5)[0];
  return i ? Us(Qh(e, i)) : e;
}
function G0(t, e, r = 1) {
  return Qh(e, r - t.day(e));
}
function az(t, e) {
  const [r, n] = $n(e, 5), [i, s] = mv(oc(t) + n);
  return [i, r + s];
}
function Qh(t, e) {
  return e ? {
    ...t,
    ...yv(hi(t) + e * zi)
  } : t;
}
function Cv(t, e, r) {
  const n = t(r.calendar);
  return od(r) ? [r, n, e(r.timeZone)] : [{
    ...r,
    ...Ji
  }, n];
}
function AA(t) {
  return t ? YF : On;
}
function Iv(t) {
  return t ? sr(EA, t) : SA;
}
function kA(t) {
  return t ? sr(Gxe, t) : Wxe;
}
function od(t) {
  return t && t.epochNanoseconds;
}
function W0(t, e) {
  return t <= 6 - (od(e) ? 1 : 0);
}
function FP(t, e, r, n, i, s, o) {
  const a = t(aa(o).relativeTo), l = Math.max(Sh(i), Sh(s));
  if (W0(l, a))
    return wn(Kh(((w, f, E, A) => {
      const x = sd($n(w), $n(f), A ? -1 : 1);
      if (!Number.isFinite(x[0]))
        throw new RangeError(Kc);
      return {
        ...jn,
        ...sf(x, E)
      };
    })(i, s, l, n)));
  if (!a)
    throw new RangeError(Nv);
  n && (s = Si(s));
  const [c, p, h] = Cv(e, r, a), d = Iv(h), b = kA(h), m = d(p, c, i);
  return wn(b(p, c, d(p, m, s), l));
}
function Exe(t, e, r, n, i) {
  const s = Sh(n), [o, a, l, c, p] = ((k, S, R) => {
    k = xv(k, p2);
    let L = hV(k);
    const F = R(k[cV]);
    let z = pA(k);
    const j = mm(k, 7);
    let ee = gm(k);
    if (L === void 0 && ee === void 0)
      throw new RangeError(oEe);
    if (ee == null && (ee = 0), L == null && (L = Math.max(ee, S)), KF(L, ee), z = dA(z, ee, 1), z > 1 && ee > 5 && L !== ee)
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    return [L, ee, z, j, F];
  })(i, s, t), h = Math.max(s, o);
  if (!p && h <= 6)
    return wn(Kh(((k, S, R, L, F) => {
      const z = Av($n(k), R, L, F);
      return {
        ...jn,
        ...sf(z, S)
      };
    })(n, o, a, l, c)));
  if (!od(p) && !n.sign)
    return n;
  if (!p)
    throw new RangeError(Nv);
  const [d, b, m] = Cv(e, r, p), w = AA(m), f = Iv(m), E = kA(m), A = f(b, d, n);
  od(p) || (Zi(d), Zi(A));
  let x = E(b, d, A, o);
  const g = n.sign, v = Hc(x);
  if (g && v && g !== v)
    throw new RangeError(lf);
  return x = Sv(x, w(A), o, a, l, c, b, d, w, f), wn(x);
}
function Sxe(t) {
  return t.sign === -1 ? _A(t) : t;
}
function _A(t) {
  return wn(Si(t));
}
function Si(t) {
  const e = {};
  for (const r of xr)
    e[r] = -1 * t[r] || 0;
  return e;
}
function Axe(t) {
  return !t.sign;
}
function Hc(t, e = xr) {
  let r = 0;
  for (const n of e) {
    const i = Math.sign(t[n]);
    if (i) {
      if (r && r !== i)
        throw new RangeError(iEe);
      r = i;
    }
  }
  return r;
}
function Kh(t) {
  for (const e of yEe)
    ja(e, t[e], -4294967295, UEe, 1);
  return lz(Qo($n(t), $o)), t;
}
function lz(t) {
  if (!Number.isSafeInteger(t))
    throw new RangeError(nEe);
}
function $n(t, e = 6) {
  return OF(t, e, xr);
}
function sf(t, e = 6) {
  const [r, n] = t, i = gv(n, e, xr);
  if (i[xr[e]] += r * (zr / Ko[e]), !Number.isFinite(i[xr[e]]))
    throw new RangeError(Kc);
  return i;
}
function Pv(t, e = 5) {
  return gv(t, e, xr);
}
function cz(t) {
  return !!Hc(t, sV);
}
function Sh(t) {
  let e = 9;
  for (; e > 0 && !t[xr[e]]; e--)
    ;
  return e;
}
function kxe(t, e) {
  return [t, e];
}
function zP(t) {
  const e = Math.floor(t / j1) * j1;
  return [e, e + j1];
}
function _xe(t) {
  const e = Gc(t = D1(t));
  if (!e)
    throw new RangeError($i(t));
  let r;
  if (e.j)
    r = 0;
  else {
    if (!e.offset)
      throw new RangeError($i(t));
    r = Yh(e.offset);
  }
  return e.timeZone && OA(e.timeZone, 1), nl(oA(bv(e), r));
}
function Cxe(t) {
  const e = Gc(ei(t));
  if (!e)
    throw new RangeError($i(t));
  if (e.timeZone)
    return uz(e, e.offset ? Yh(e.offset) : void 0);
  if (e.j)
    throw new RangeError($i(t));
  return pz(e);
}
function Ixe(t, e) {
  const r = Gc(ei(t));
  if (!r || !r.timeZone)
    throw new RangeError($i(t));
  const { offset: n } = r, i = n ? Yh(n) : void 0, [, s, o] = vv(e);
  return uz(r, i, s, o);
}
function Yh(t) {
  const e = OA(t);
  if (e === void 0)
    throw new RangeError($i(t));
  return e;
}
function Pxe(t) {
  const e = Gc(ei(t));
  if (!e || e.j)
    throw new RangeError($i(t));
  return mo(hz(e));
}
function CA(t, e, r) {
  let n = Gc(ei(t));
  if (!n || n.j)
    throw new RangeError($i(t));
  return e ? n.calendar === hr && (n = n.isoYear === -271821 && n.isoMonth === 4 ? {
    ...n,
    isoDay: 20,
    ...Ji
  } : {
    ...n,
    isoDay: 1,
    ...Ji
  }) : r && n.calendar === hr && (n = {
    ...n,
    isoYear: Ca
  }), il(n.C ? hz(n) : pz(n));
}
function Rxe(t, e) {
  const r = PA(ei(e));
  if (r)
    return IA(r), H0(sA(qh(r)));
  const n = CA(e, 1);
  return H0(G0(t(n.calendar), n));
}
function IA(t) {
  if (t.calendar !== hr)
    throw new RangeError(_a(t.calendar));
}
function Oxe(t, e) {
  const r = RA(ei(e));
  if (r)
    return IA(r), a2(qh(r));
  const n = CA(e, 0, 1), { calendar: i } = n, s = t(i), [o, a, l] = s.v(n), [c, p] = s.q(o, a), [h, d] = s.G(c, p, l);
  return a2(Us(s.V(h, d, l)), i);
}
function Txe(t) {
  let e, r = ((n) => {
    const i = YEe.exec(n);
    return i ? (Rv(i[10]), gz(i)) : void 0;
  })(ei(t));
  if (!r) {
    if (r = Gc(t), !r)
      throw new RangeError($i(t));
    if (!r.C)
      throw new RangeError($i(t));
    if (r.j)
      throw new RangeError(_a("Z"));
    IA(r);
  }
  if ((e = PA(t)) && AP(e))
    throw new RangeError($i(t));
  if ((e = RA(t)) && AP(e))
    throw new RangeError($i(t));
  return la(tf(r, 1));
}
function Lxe(t) {
  const e = ((r) => {
    const n = XEe.exec(r);
    return n ? ((i) => {
      function s(p, h, d) {
        let b = 0, m = 0;
        if (d && ([b, l] = ka(l, Ko[d])), p !== void 0) {
          if (a)
            throw new RangeError(_a(p));
          m = ((w) => {
            const f = parseInt(w);
            if (!Number.isFinite(f))
              throw new RangeError(_a(w));
            return f;
          })(p), o = 1, h && (l = TA(h) * (Ko[d] / $o), a = 1);
        }
        return b + m;
      }
      let o = 0, a = 0, l = 0, c = {
        ...Jd(xr, [s(i[2]), s(i[3]), s(i[4]), s(i[5]), s(i[6], i[7], 5), s(i[8], i[9], 4), s(i[10], i[11], 3)]),
        ...gv(l, 2, xr)
      };
      if (!o)
        throw new RangeError(Vz(xr));
      return LA(i[1]) < 0 && (c = Si(c)), c;
    })(n) : void 0;
  })(ei(t));
  if (!e)
    throw new RangeError($i(t));
  return wn(Kh(e));
}
function Mxe(t) {
  const e = Gc(t) || PA(t) || RA(t);
  return e ? e.calendar : t;
}
function Nxe(t) {
  const e = Gc(t);
  return e && (e.timeZone || e.j && Jh || e.offset) || t;
}
function uz(t, e, r = 0, n = 0) {
  const i = MA(t.timeZone), s = Yt(i);
  let o;
  return bv(t), o = t.C ? nf(s, t, e, r, n, !s.$, t.j) : lc(s, t), go(o, i, Mv(t.calendar));
}
function hz(t) {
  return dz(Zi(bv(t)));
}
function pz(t) {
  return dz(Us(qh(t)));
}
function dz(t) {
  return {
    ...t,
    calendar: Mv(t.calendar)
  };
}
function Gc(t) {
  const e = KEe.exec(t);
  return e ? ((r) => {
    const n = r[10], i = (n || "").toUpperCase() === "Z";
    return {
      isoYear: fz(r),
      isoMonth: parseInt(r[4]),
      isoDay: parseInt(r[5]),
      ...gz(r.slice(5)),
      ...Rv(r[16]),
      C: !!r[6],
      j: i,
      offset: i ? void 0 : n
    };
  })(e) : void 0;
}
function PA(t) {
  const e = qEe.exec(t);
  return e ? ((r) => ({
    isoYear: fz(r),
    isoMonth: parseInt(r[4]),
    isoDay: 1,
    ...Rv(r[5])
  }))(e) : void 0;
}
function RA(t) {
  const e = QEe.exec(t);
  return e ? ((r) => ({
    isoYear: Ca,
    isoMonth: parseInt(r[1]),
    isoDay: parseInt(r[2]),
    ...Rv(r[3])
  }))(e) : void 0;
}
function OA(t, e) {
  const r = ZEe.exec(t);
  return r ? ((n, i) => {
    const s = n[4] || n[5];
    if (i && s)
      throw new RangeError(_a(s));
    return ((o) => {
      if (Math.abs(o) >= zr)
        throw new RangeError(X4e);
      return o;
    })((jp(n[2]) * $v + jp(n[3]) * Dv + jp(n[4]) * $o + TA(n[5] || "")) * LA(n[1]));
  })(r, e) : void 0;
}
function fz(t) {
  const e = LA(t[1]), r = parseInt(t[2] || t[3]);
  if (e < 0 && !r)
    throw new RangeError(_a(-0));
  return e * r;
}
function gz(t) {
  const e = jp(t[3]);
  return {
    ...mv(TA(t[4] || ""))[0],
    isoHour: jp(t[1]),
    isoMinute: jp(t[2]),
    isoSecond: e === 60 ? 59 : e
  };
}
function Rv(t) {
  let e, r;
  const n = [];
  if (t.replace(JEe, (i, s, o) => {
    const a = !!s, [l, c] = o.split("=").reverse();
    if (c) {
      if (c === "u-ca")
        n.push(l), e || (e = a);
      else if (a || /[A-Z]/.test(c))
        throw new RangeError(_a(i));
    } else {
      if (r)
        throw new RangeError(_a(i));
      r = l;
    }
    return "";
  }), n.length > 1 && e)
    throw new RangeError(_a(t));
  return {
    timeZone: r,
    calendar: n[0] || hr
  };
}
function TA(t) {
  return parseInt(t.padEnd(9, "0"));
}
function of(t) {
  return new RegExp(`^${t}$`, "i");
}
function LA(t) {
  return t && t !== "+" ? -1 : 1;
}
function jp(t) {
  return t === void 0 ? 0 : parseInt(t);
}
function Dxe(t) {
  return MA(ei(t));
}
function MA(t) {
  const e = NA(t);
  return typeof e == "number" ? lm(e) : e ? ((r) => {
    if (r6e.test(r))
      throw new RangeError(qz(r));
    if (t6e.test(r))
      throw new RangeError(J4e);
    return r.toLowerCase().split("/").map((n, i) => (n.length <= 3 || /\d/.test(n)) && !/etc|yap/.test(n) ? n.toUpperCase() : n.replace(/baja|dumont|[a-z]+/g, (s, o) => s.length <= 2 && !i || s === "in" || s === "chat" ? s.toUpperCase() : s.length > 2 || !o ? xP(s).replace(/island|noronha|murdo|rivadavia|urville/, xP) : s)).join("/");
  })(t) : Jh;
}
function VP(t) {
  const e = NA(t);
  return typeof e == "number" ? e : e ? e.resolvedOptions().timeZone : Jh;
}
function NA(t) {
  const e = OA(t = t.toUpperCase(), 1);
  return e !== void 0 ? e : t !== Jh ? e6e(t) : void 0;
}
function mz(t, e) {
  return xs(t.epochNanoseconds, e.epochNanoseconds);
}
function yz(t, e) {
  return xs(t.epochNanoseconds, e.epochNanoseconds);
}
function $xe(t, e, r, n, i, s) {
  const o = t(aa(s).relativeTo), a = Math.max(Sh(n), Sh(i));
  if (PF(xr, n, i))
    return 0;
  if (W0(a, o))
    return xs($n(n), $n(i));
  if (!o)
    throw new RangeError(Nv);
  const [l, c, p] = Cv(e, r, o), h = AA(p), d = Iv(p);
  return xs(h(d(c, l, n)), h(d(c, l, i)));
}
function bz(t, e) {
  return af(t, e) || DA(t, e);
}
function af(t, e) {
  return Ul(hi(t), hi(e));
}
function DA(t, e) {
  return Ul(oc(t), oc(e));
}
function jxe(t, e) {
  return !mz(t, e);
}
function Bxe(t, e) {
  return !yz(t, e) && !!vz(t.timeZone, e.timeZone) && t.calendar === e.calendar;
}
function Fxe(t, e) {
  return !bz(t, e) && t.calendar === e.calendar;
}
function zxe(t, e) {
  return !af(t, e) && t.calendar === e.calendar;
}
function Vxe(t, e) {
  return !af(t, e) && t.calendar === e.calendar;
}
function Uxe(t, e) {
  return !af(t, e) && t.calendar === e.calendar;
}
function Hxe(t, e) {
  return !DA(t, e);
}
function vz(t, e) {
  if (t === e)
    return 1;
  try {
    return VP(t) === VP(e);
  } catch {
  }
}
function UP(t, e, r, n) {
  const i = rf(t, n, 3, 5), s = Ov(e.epochNanoseconds, r.epochNanoseconds, ...i);
  return wn(t ? Si(s) : s);
}
function HP(t, e, r, n, i, s) {
  const o = Lv(n.calendar, i.calendar), [a, l, c, p] = rf(r, s, 5), h = n.epochNanoseconds, d = i.epochNanoseconds, b = xs(d, h);
  let m;
  if (b)
    if (a < 6)
      m = Ov(h, d, a, l, c, p);
    else {
      const w = e(((E, A) => {
        if (!vz(E, A))
          throw new RangeError(Qz);
        return E;
      })(n.timeZone, i.timeZone)), f = t(o);
      m = xz(f, w, n, i, b, a, s), m = Sv(m, d, a, l, c, p, f, n, YF, sr(EA, w));
    }
  else
    m = jn;
  return wn(r ? Si(m) : m);
}
function GP(t, e, r, n, i) {
  const s = Lv(r.calendar, n.calendar), [o, a, l, c] = rf(e, i, 6), p = On(r), h = On(n), d = xs(h, p);
  let b;
  if (d)
    if (o <= 6)
      b = Ov(p, h, o, a, l, c);
    else {
      const m = t(s);
      b = Ez(m, r, n, d, o, i), b = Sv(b, h, o, a, l, c, m, r, On, SA);
    }
  else
    b = jn;
  return wn(e ? Si(b) : b);
}
function WP(t, e, r, n, i) {
  const s = Lv(r.calendar, n.calendar);
  return wz(e, () => t(s), r, n, ...rf(e, i, 6, 9, 6));
}
function qP(t, e, r, n, i) {
  const s = Lv(r.calendar, n.calendar), o = rf(e, i, 9, 9, 8), a = t(s), l = G0(a, r), c = G0(a, n);
  return l.isoYear === c.isoYear && l.isoMonth === c.isoMonth && l.isoDay === c.isoDay ? wn(jn) : wz(e, () => a, Us(l), Us(c), ...o, 8);
}
function wz(t, e, r, n, i, s, o, a, l = 6) {
  const c = On(r), p = On(n);
  if (c === void 0 || p === void 0)
    throw new RangeError(Kc);
  let h;
  if (xs(p, c))
    if (i === 6)
      h = Ov(c, p, i, s, o, a);
    else {
      const d = e();
      h = d.N(r, n, i), s === l && o === 1 || (h = Sv(h, p, i, s, o, a, d, r, On, _v));
    }
  else
    h = jn;
  return wn(t ? Si(h) : h);
}
function QP(t, e, r, n) {
  const [i, s, o, a] = rf(t, n, 5, 5), l = ac($A(e, r), am(s, o), a), c = {
    ...jn,
    ...Pv(l, i)
  };
  return wn(t ? Si(c) : c);
}
function Gxe(t, e, r, n, i, s) {
  const o = xs(n.epochNanoseconds, r.epochNanoseconds);
  return o ? i < 6 ? Sz(r.epochNanoseconds, n.epochNanoseconds, i) : xz(e, t, r, n, o, i, s) : jn;
}
function Wxe(t, e, r, n, i) {
  const s = On(e), o = On(r), a = xs(o, s);
  return a ? n <= 6 ? Sz(s, o, n) : Ez(t, e, r, a, n, i) : jn;
}
function xz(t, e, r, n, i, s, o) {
  const [a, l, c] = ((d, b, m, w) => {
    function f() {
      return S = {
        ...Qh(x, v++ * -w),
        ...A
      }, R = cm(d, S), xs(g, R) === -w;
    }
    const E = Ss(b, d), A = fo(yo, E), x = Ss(m, d), g = m.epochNanoseconds;
    let v = 0;
    const k = $A(E, x);
    let S, R;
    if (Math.sign(k) === -w && v++, f() && (w === -1 || f()))
      throw new RangeError(lf);
    const L = Qo(qo(R, g));
    return [E, S, L];
  })(e, r, n, i);
  var p, h;
  return {
    ...s === 6 ? (p = a, h = l, {
      ...jn,
      days: Az(p, h)
    }) : t.N(a, l, s, o),
    ...Pv(c)
  };
}
function Ez(t, e, r, n, i, s) {
  const [o, a, l] = ((c, p, h) => {
    let d = p, b = $A(c, p);
    return Math.sign(b) === -h && (d = Qh(p, -h), b += zr * h), [c, d, b];
  })(e, r, n);
  return {
    ...t.N(o, a, i, s),
    ...Pv(l)
  };
}
function Ov(t, e, r, n, i, s) {
  return {
    ...jn,
    ...sf(Av(qo(t, e), n, i, s), r)
  };
}
function Sz(t, e, r) {
  return {
    ...jn,
    ...sf(qo(t, e), r)
  };
}
function Az(t, e) {
  return Tv(hi(t), hi(e));
}
function Tv(t, e) {
  return Math.trunc((e - t) / zi);
}
function $A(t, e) {
  return oc(e) - oc(t);
}
function Lv(t, e) {
  if (t !== e)
    throw new RangeError(Wz);
  return t;
}
function kz(t) {
  return this.m(t)[0];
}
function _z(t) {
  return this.m(t)[1];
}
function jA(t) {
  const [e] = this.v(t);
  return Tv(this.p(e), hi(t)) + 1;
}
function BA(t) {
  const e = n6e.exec(t);
  if (!e)
    throw new RangeError(Y4e(t));
  return [parseInt(e[1]), !!e[2]];
}
function um(t, e) {
  return "M" + Hs(t) + (e ? "L" : "");
}
function u2(t, e, r) {
  return t + (e || r && t >= r ? 1 : 0);
}
function FA(t, e) {
  return t - (e && t >= e ? 1 : 0);
}
function Cz(t, e) {
  return (e + t) * (Math.sign(e) || 1) || 0;
}
function R4(t) {
  return nV[Pz(t)];
}
function Iz(t) {
  return dEe[Pz(t)];
}
function Pz(t) {
  return Ah(t.id || hr);
}
function qxe(t) {
  function e(i) {
    return ((s, o) => ({
      ...Rz(s, o),
      o: s.month,
      day: parseInt(s.day)
    }))(aA(r, i), n);
  }
  const r = l9(t), n = Ah(t);
  return {
    id: t,
    h: Qxe(e),
    l: Kxe(e)
  };
}
function Qxe(t) {
  return ws((e) => {
    const r = hi(e);
    return t(r);
  }, WeakMap);
}
function Kxe(t) {
  const e = t(0).year - AEe;
  return ws((r) => {
    let n, i = Xd(r - e), s = 0;
    const o = [], a = [];
    do
      i += 400 * zi;
    while ((n = t(i)).year <= r);
    do
      if (i += (1 - n.day) * zi, n.year === r && (o.push(i), a.push(n.o)), i -= zi, ++s > 100 || i < -864e13)
        throw new RangeError(lf);
    while ((n = t(i)).year >= r);
    return {
      i: o.reverse(),
      u: Kz(a.reverse())
    };
  });
}
function Rz(t, e) {
  let r, n, i = Oz(t);
  if (t.era) {
    const s = nV[e], o = iV[e] || {};
    s !== void 0 && (r = e === "islamic" ? "ah" : t.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), r === "bc" || r === "b" ? r = "bce" : r === "ad" || r === "a" ? r = "ce" : r === "beforeroc" && (r = "broc"), r = o[r] || r, n = i, i = Cz(n, s[r] || 0));
  }
  return {
    era: r,
    eraYear: n,
    year: i
  };
}
function Oz(t) {
  return parseInt(t.relatedYear || t.year);
}
function h2(t) {
  const { year: e, o: r, day: n } = this.h(t), { u: i } = this.l(e);
  return [e, i[r] + 1, n];
}
function q0(t, e = 1, r = 1) {
  return this.l(t).i[e - 1] + (r - 1) * zi;
}
function Tz(t, e) {
  const r = $1.call(this, t);
  return [FA(e, r), r === e];
}
function $1(t) {
  const e = YP(this, t), r = YP(this, t - 1), n = e.length;
  if (n > r.length) {
    const i = Iz(this);
    if (i < 0)
      return -i;
    for (let s = 0; s < n; s++)
      if (e[s] !== r[s])
        return s + 1;
  }
}
function Ym(t) {
  return Tv(q0.call(this, t), q0.call(this, t + 1));
}
function KP(t, e) {
  const { i: r } = this.l(t);
  let n = e + 1, i = r;
  return n > r.length && (n = 1, i = this.l(t + 1).i), Tv(r[e - 1], i[n - 1]);
}
function Zm(t) {
  return this.l(t).i.length;
}
function Lz(t) {
  const e = this.h(t);
  return [e.era, e.eraYear];
}
function YP(t, e) {
  return Object.keys(t.l(e).u);
}
function hm(t) {
  return Mv(ei(t));
}
function Mv(t) {
  if ((t = t.toLowerCase()) !== hr && t !== cf) {
    const e = l9(t).resolvedOptions().calendar;
    if (Ah(t) !== Ah(e))
      throw new RangeError(Gz(t));
    return e;
  }
  return t;
}
function Ah(t) {
  return t === "islamicc" && (t = "islamic"), t.split("-")[0];
}
function Mz(t, e) {
  return (r) => r === hr ? t : r === cf || r === cc ? Object.assign(Object.create(t), {
    id: r
  }) : Object.assign(Object.create(e), i6e(r));
}
function Yxe(t, e, r, n) {
  const i = Wc(r, n, al, [], Xz);
  if (i.timeZone !== void 0) {
    const s = r.F(i), o = pm(i), a = t(i.timeZone);
    return {
      epochNanoseconds: nf(e(a), {
        ...s,
        ...o
      }, i.offset !== void 0 ? Yh(i.offset) : void 0),
      timeZone: a
    };
  }
  return {
    ...r.F(i),
    ...Ji
  };
}
function Zxe(t, e, r, n, i, s) {
  const o = Wc(r, i, al, Zz, Xz), a = t(o.timeZone), [l, c, p] = vv(s), h = r.F(o, Ev(l)), d = pm(o, l);
  return go(nf(e(a), {
    ...h,
    ...d
  }, o.offset !== void 0 ? Yh(o.offset) : void 0, c, p), a, n);
}
function Jxe(t, e, r) {
  const n = Wc(t, e, al, [], ol), i = yr(r);
  return mo(Zi({
    ...t.F(n, Ev(i)),
    ...pm(n, i)
  }));
}
function Xxe(t, e, r, n = []) {
  const i = Wc(t, e, al, n);
  return t.F(i, r);
}
function e4e(t, e, r, n) {
  const i = Wc(t, e, qA, n);
  return t.K(i, r);
}
function t4e(t, e, r, n) {
  const i = Wc(t, r, al, fm);
  return e && i.month !== void 0 && i.monthCode === void 0 && i.year === void 0 && (i.year = Ca), t._(i, n);
}
function r4e(t, e) {
  return la(pm(Es(t, M4, [], 1), yr(e)));
}
function n4e(t) {
  const e = Es(t, QA);
  return wn(Kh({
    ...jn,
    ...e
  }));
}
function Wc(t, e, r, n = [], i = []) {
  return Es(e, [...t.fields(r), ...i].sort(), n);
}
function Es(t, e, r, n = !r) {
  const i = {};
  let s, o = 0;
  for (const a of e) {
    if (a === s)
      throw new RangeError(V4e(a));
    if (a === "constructor" || a === "__proto__")
      throw new RangeError(z4e(a));
    let l = t[a];
    if (l !== void 0)
      o = 1, ZP[a] && (l = ZP[a](l, a)), i[a] = l;
    else if (r) {
      if (r.includes(a))
        throw new TypeError(VA(a));
      i[a] = rV[a];
    }
    s = a;
  }
  if (n && !o)
    throw new TypeError(Vz(e));
  return i;
}
function pm(t, e) {
  return tf(c9({
    ...rV,
    ...t
  }), e);
}
function i4e(t, e, r, n, i) {
  const { calendar: s, timeZone: o } = r, a = t(s), l = e(o), c = [...a.fields(al), ...Jz].sort(), p = ((E) => {
    const A = Ss(E, Yt), x = lm(A.offsetNanoseconds), g = Fv(E.calendar), [v, k, S] = g.v(A), [R, L] = g.q(v, k), F = um(R, L);
    return {
      ...p6e(A),
      year: v,
      monthCode: F,
      day: S,
      offset: x
    };
  })(r), h = Es(n, c), d = a.k(p, h), b = {
    ...p,
    ...h
  }, [m, w, f] = vv(i, 2);
  return go(nf(l, {
    ...a.F(d, Ev(m)),
    ...tf(c9(b), m)
  }, Yh(b.offset), w, f), o, s);
}
function s4e(t, e, r, n) {
  const i = t(e.calendar), s = [...i.fields(al), ...ol].sort(), o = {
    ...Dz(a = e),
    hour: a.isoHour,
    minute: a.isoMinute,
    second: a.isoSecond,
    millisecond: a.isoMillisecond,
    microsecond: a.isoMicrosecond,
    nanosecond: a.isoNanosecond
  };
  var a;
  const l = Es(r, s), c = yr(n), p = i.k(o, l), h = {
    ...o,
    ...l
  };
  return mo(Zi({
    ...i.F(p, Ev(c)),
    ...tf(c9(h), c)
  }));
}
function o4e(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(al).sort(), o = Dz(e), a = Es(r, s), l = i.k(o, a);
  return i.F(l, n);
}
function a4e(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(qA).sort(), o = ((c) => {
    const p = Fv(c.calendar), [h, d] = p.v(c), [b, m] = p.q(h, d);
    return {
      year: h,
      monthCode: um(b, m)
    };
  })(e), a = Es(r, s), l = i.k(o, a);
  return i.K(l, n);
}
function l4e(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(al).sort(), o = ((c) => {
    const p = Fv(c.calendar), [h, d, b] = p.v(c), [m, w] = p.q(h, d);
    return {
      monthCode: um(m, w),
      day: b
    };
  })(e), a = Es(r, s), l = i.k(o, a);
  return i._(l, n);
}
function c4e(t, e, r) {
  return la(((n, i, s) => pm({
    ...fo(M4, n),
    ...Es(i, M4)
  }, yr(s)))(t, e, r));
}
function u4e(t, e) {
  return wn((r = t, n = e, Kh({
    ...r,
    ...Es(n, QA)
  })));
  var r, n;
}
function Nz(t, e, r, n, i) {
  e = fo(r = t.fields(r), e), n = Es(n, i = t.fields(i), []);
  let s = t.k(e, n);
  return s = Es(s, [...r, ...i].sort(), []), t.F(s);
}
function H3(t, e) {
  const r = R4(t), n = iV[t.id || ""] || {};
  let { era: i, eraYear: s, year: o } = e;
  if (i !== void 0 || s !== void 0) {
    if (i === void 0 || s === void 0)
      throw new TypeError(W4e);
    if (!r)
      throw new RangeError(G4e);
    const a = r[n[i] || i];
    if (a === void 0)
      throw new RangeError(Q4e(i));
    const l = Cz(s, a);
    if (o !== void 0 && o !== l)
      throw new RangeError(q4e);
    o = l;
  } else if (o === void 0)
    throw new TypeError(K4e(r));
  return o;
}
function Jm(t, e, r, n) {
  let { month: i, monthCode: s } = e;
  if (s !== void 0) {
    const o = ((a, l, c, p) => {
      const h = a.L(c), [d, b] = BA(l);
      let m = u2(d, b, h);
      if (b) {
        const w = Iz(a);
        if (w === void 0)
          throw new RangeError(Cf);
        if (w > 0) {
          if (m > w)
            throw new RangeError(Cf);
          if (h === void 0) {
            if (p === 1)
              throw new RangeError(Cf);
            m--;
          }
        } else {
          if (m !== -w)
            throw new RangeError(Cf);
          if (h === void 0 && p === 1)
            throw new RangeError(Cf);
        }
      }
      return m;
    })(t, s, r, n);
    if (i !== void 0 && i !== o)
      throw new RangeError(Z4e);
    i = o, n = 1;
  } else if (i === void 0)
    throw new TypeError(Hz);
  return ja("month", i, 1, t.B(r), n);
}
function G3(t, e, r, n, i) {
  return Mi(e, "day", 1, t.U(n, r), i);
}
function W3(t, e, r, n) {
  let i = 0;
  const s = [];
  for (const o of r)
    e[o] !== void 0 ? i = 1 : s.push(o);
  if (Object.assign(t, e), i)
    for (const o of n || s)
      delete t[o];
}
function Dz(t) {
  const e = Fv(t.calendar), [r, n, i] = e.v(t), [s, o] = e.q(r, n);
  return {
    year: r,
    monthCode: um(s, o),
    day: i
  };
}
function h4e(t) {
  return nl(oa(nA(eA(t))));
}
function p4e(t, e, r, n, i = hr) {
  return go(oa(nA(eA(r))), e(n), t(i));
}
function d4e(t, e, r, n, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, p = hr) {
  return mo(Zi(bv(Ba(oi, Jd(jv, [e, r, n, i, s, o, a, l, c])))), t(p));
}
function f4e(t, e, r, n, i = hr) {
  return il(Us(qh(Ba(oi, {
    isoYear: e,
    isoMonth: r,
    isoDay: n
  }))), t(i));
}
function g4e(t, e, r, n = hr, i = 1) {
  const s = oi(e), o = oi(r), a = t(n);
  return H0(sA(qh({
    isoYear: s,
    isoMonth: o,
    isoDay: oi(i)
  })), a);
}
function m4e(t, e, r, n = hr, i = Ca) {
  const s = oi(e), o = oi(r), a = t(n);
  return a2(Us(qh({
    isoYear: oi(i),
    isoMonth: s,
    isoDay: o
  })), a);
}
function y4e(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0) {
  return la(tf(Ba(oi, Jd(yo, [t, e, r, n, i, s])), 1));
}
function b4e(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0) {
  return wn(Kh(Ba(tA, Jd(xr, [t, e, r, n, i, s, o, a, l, c]))));
}
function v4e(t, e, r = hr) {
  return go(t.epochNanoseconds, e, r);
}
function w4e(t) {
  return nl(t.epochNanoseconds);
}
function $z(t, e) {
  return mo(Ss(e, t));
}
function jz(t, e) {
  return il(Ss(e, t));
}
function Bz(t, e) {
  return la(Ss(e, t));
}
function x4e(t, e, r, n) {
  const i = ((s, o, a, l) => {
    const c = ((p) => dV(aa(p)))(l);
    return cm(s(o), a, c);
  })(t, r, e, n);
  return go(oa(i), r, e.calendar);
}
function E4e(t, e, r, n, i) {
  const s = t(i.timeZone), o = i.plainTime, a = o !== void 0 ? e(o) : void 0, l = r(s);
  let c;
  return c = a ? cm(l, {
    ...n,
    ...a
  }) : lc(l, {
    ...n,
    ...Ji
  }), go(c, s, n.calendar);
}
function S4e(t, e = Ji) {
  return mo(Zi({
    ...t,
    ...e
  }));
}
function A4e(t, e, r) {
  return ((n, i) => {
    const s = Wc(n, i, eV);
    return n.K(s, void 0);
  })(t(e.calendar), r);
}
function k4e(t, e, r) {
  return ((n, i) => {
    const s = Wc(n, i, tV);
    return n._(s);
  })(t(e.calendar), r);
}
function _4e(t, e, r, n) {
  return ((i, s, o) => Nz(i, s, eV, om(o), fm))(t(e.calendar), r, n);
}
function C4e(t, e, r, n) {
  return ((i, s, o) => Nz(i, s, tV, om(o), HA))(t(e.calendar), r, n);
}
function I4e(t) {
  return nl(oa(s2(tA(t), sl)));
}
function P4e(t) {
  return nl(oa(nA(eA(t))));
}
function Zh(t, e, r) {
  const n = new Set(r);
  return (i, s) => {
    const o = r && wP(i, r);
    if (!wP(i = ((a, l) => {
      const c = {};
      for (const p in l)
        a.has(p) || (c[p] = l[p]);
      return c;
    })(n, i), t)) {
      if (s && o)
        throw new TypeError("Invalid formatting options");
      i = {
        ...e,
        ...i
      };
    }
    return r && (i.timeZone = Jh, ["full", "long"].includes(i.J) && (i.J = "medium")), i;
  };
}
function qc(t, e = Fz, r = 0) {
  const [n, , , i] = t;
  return (s, o = O6e, ...a) => {
    const l = e(i && i(...a), s, o, n, r), c = l.resolvedOptions();
    return [l, ...R4e(t, c, a)];
  };
}
function Fz(t, e, r, n, i) {
  if (r = n(r, i), t) {
    if (r.timeZone !== void 0)
      throw new TypeError(cEe);
    r.timeZone = t;
  }
  return new Hl(e, r);
}
function R4e(t, e, r) {
  const [, n, i] = t;
  return r.map((s) => (s.calendar && ((o, a, l) => {
    if ((l || o !== hr) && o !== a)
      throw new RangeError(Wz);
  })(s.calendar, e.calendar, i), n(s, e)));
}
function O4e(t, e, r) {
  const n = e.timeZone, i = t(n), s = {
    ...Ss(e, i),
    ...r || Ji
  };
  let o;
  return o = r ? nf(i, s, s.offsetNanoseconds, 2) : lc(i, s), go(o, n, e.calendar);
}
function T4e(t, e = Ji) {
  return mo(Zi({
    ...t,
    ...e
  }));
}
function zA(t, e) {
  return {
    ...t,
    calendar: e
  };
}
function L4e(t, e) {
  return {
    ...t,
    timeZone: e
  };
}
function q3(t) {
  const e = O4();
  return ef(e, t.R(e));
}
function O4() {
  return s2(Date.now(), sl);
}
function _f() {
  return JP || (JP = new Hl().resolvedOptions().timeZone);
}
const M4e = (t, e) => `Non-integer ${t}: ${e}`, N4e = (t, e) => `Non-positive ${t}: ${e}`, D4e = (t, e) => `Non-finite ${t}: ${e}`, $4e = (t) => `Cannot convert bigint to ${t}`, j4e = (t) => `Invalid bigint: ${t}`, B4e = "Cannot convert Symbol to string", F4e = "Invalid object", zz = (t, e, r, n, i) => i ? zz(t, i[e], i[r], i[n]) : Qc(t, e) + `; must be between ${r}-${n}`, Qc = (t, e) => `Invalid ${t}: ${e}`, VA = (t) => `Missing ${t}`, z4e = (t) => `Invalid field ${t}`, V4e = (t) => `Duplicate field ${t}`, Vz = (t) => "No valid fields: " + t.join(), U4e = "Invalid bag", Uz = (t, e, r) => Qc(t, e) + "; must be " + Object.keys(r).join(), H4e = "Cannot use valueOf", T4 = "Invalid calling context", G4e = "Forbidden era/eraYear", W4e = "Mismatching era/eraYear", q4e = "Mismatching year/eraYear", Q4e = (t) => `Invalid era: ${t}`, K4e = (t) => "Missing year" + (t ? "/era/eraYear" : ""), Y4e = (t) => `Invalid monthCode: ${t}`, Z4e = "Mismatching month/monthCode", Hz = "Missing month/monthCode", Cf = "Invalid leap month", lf = "Invalid protocol results", Gz = (t) => Qc("Calendar", t), Wz = "Mismatching Calendars", qz = (t) => Qc("TimeZone", t), Qz = "Mismatching TimeZones", J4e = "Forbidden ICU TimeZone", X4e = "Out-of-bounds offset", eEe = "Out-of-bounds TimeZone gap", tEe = "Invalid TimeZone offset", rEe = "Ambiguous offset", Kc = "Out-of-bounds date", nEe = "Out-of-bounds duration", iEe = "Cannot mix duration signs", Nv = "Missing relativeTo", sEe = "Cannot use large units", oEe = "Required smallestUnit or largestUnit", aEe = "smallestUnit > largestUnit", $i = (t) => `Cannot parse: ${t}`, _a = (t) => `Invalid substring: ${t}`, lEe = (t) => `Cannot format ${t}`, Q3 = "Mismatching types for formatting", cEe = "Cannot specify TimeZone", Kz = /* @__PURE__ */ sr(dv, (t, e) => e), ad = /* @__PURE__ */ sr(dv, (t, e, r) => r), Hs = /* @__PURE__ */ sr(i2, 2), L4 = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, UA = /* @__PURE__ */ Object.keys(L4), zi = 864e5, Yz = 1e3, dm = 1e3, sl = 1e6, $o = 1e9, Dv = 6e10, $v = 36e11, zr = 864e11, Ko = [1, dm, sl, $o, Dv, $v, zr], ol = /* @__PURE__ */ UA.slice(0, 6), M4 = /* @__PURE__ */ sm(ol), uEe = ["offset"], Zz = ["timeZone"], Jz = /* @__PURE__ */ ol.concat(uEe), Xz = /* @__PURE__ */ Jz.concat(Zz), N4 = ["era", "eraYear"], hEe = /* @__PURE__ */ N4.concat(["year"]), HA = ["year"], GA = ["monthCode"], WA = /* @__PURE__ */ ["month"].concat(GA), fm = ["day"], qA = /* @__PURE__ */ WA.concat(HA), eV = /* @__PURE__ */ GA.concat(HA), al = /* @__PURE__ */ fm.concat(qA), pEe = /* @__PURE__ */ fm.concat(WA), tV = /* @__PURE__ */ fm.concat(GA), rV = /* @__PURE__ */ ad(ol, 0), hr = "iso8601", cf = "gregory", cc = "japanese", nV = {
  [cf]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [cc]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, iV = {
  [cf]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [cc]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
}, dEe = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, ei = /* @__PURE__ */ sr(J8, "string"), fEe = /* @__PURE__ */ sr(J8, "boolean"), gEe = /* @__PURE__ */ sr(J8, "number"), xr = /* @__PURE__ */ UA.map((t) => t + "s"), QA = /* @__PURE__ */ sm(xr), mEe = /* @__PURE__ */ xr.slice(0, 6), sV = /* @__PURE__ */ xr.slice(6), yEe = /* @__PURE__ */ sV.slice(1), bEe = /* @__PURE__ */ Kz(xr), jn = /* @__PURE__ */ ad(xr, 0), KA = /* @__PURE__ */ ad(mEe, 0), YA = /* @__PURE__ */ sr(RF, xr), yo = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"], ZA = ["isoDay", "isoMonth", "isoYear"], jv = /* @__PURE__ */ yo.concat(ZA), JA = /* @__PURE__ */ sm(ZA), oV = /* @__PURE__ */ sm(yo), vEe = /* @__PURE__ */ sm(jv), Ji = /* @__PURE__ */ ad(oV, 0), wEe = /* @__PURE__ */ sr(RF, jv), aV = 1e8, xEe = aV * zi, EEe = [aV, 0], SEe = [-1e8, 0], Q0 = 275760, K0 = -271821, Hl = Intl.DateTimeFormat, lV = "en-GB", AEe = 1970, Ca = 1972, bl = 12, kEe = /* @__PURE__ */ Xd(1868, 9, 8), _Ee = /* @__PURE__ */ ws(oxe, WeakMap), p2 = "smallestUnit", D4 = "unit", t0 = "roundingIncrement", K3 = "fractionalSecondDigits", cV = "relativeTo", Y3 = "direction", uV = {
  constrain: 0,
  reject: 1
}, CEe = /* @__PURE__ */ Object.keys(uV), IEe = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}, PEe = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}, REe = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}, OEe = {
  auto: 0,
  never: 1,
  critical: 2
}, TEe = {
  auto: 0,
  never: 1
}, LEe = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}, MEe = {
  previous: -1,
  next: 1
}, gm = /* @__PURE__ */ sr(fA, p2), hV = /* @__PURE__ */ sr(fA, "largestUnit"), NEe = /* @__PURE__ */ sr(fA, D4), pV = /* @__PURE__ */ sr(Uc, "overflow", uV), dV = /* @__PURE__ */ sr(Uc, "disambiguation", IEe), DEe = /* @__PURE__ */ sr(Uc, "offset", PEe), XA = /* @__PURE__ */ sr(Uc, "calendarName", REe), $Ee = /* @__PURE__ */ sr(Uc, "timeZoneName", OEe), jEe = /* @__PURE__ */ sr(Uc, "offset", TEe), mm = /* @__PURE__ */ sr(Uc, "roundingMode", LEe), e9 = "PlainYearMonth", t9 = "PlainMonthDay", ym = "PlainDate", uf = "PlainDateTime", r9 = "PlainTime", Yc = "ZonedDateTime", n9 = "Instant", i9 = "Duration", BEe = [Math.floor, (t) => Km(t) ? Math.floor(t) : Math.round(t), Math.ceil, (t) => Km(t) ? Math.ceil(t) : Math.round(t), Math.trunc, (t) => Km(t) ? Math.trunc(t) || 0 : Math.round(t), (t) => t < 0 ? Math.floor(t) : Math.ceil(t), (t) => Math.sign(t) * Math.round(Math.abs(t)) || 0, (t) => Km(t) ? (t = Math.trunc(t) || 0) + t % 2 : Math.round(t)], Jh = "UTC", j1 = 5184e3, FEe = /* @__PURE__ */ o2(1847), zEe = /* @__PURE__ */ o2(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10), VEe = /0+$/, Ss = /* @__PURE__ */ ws(xxe, WeakMap), UEe = 2 ** 32 - 1, Yt = /* @__PURE__ */ ws((t) => {
  const e = NA(t);
  return typeof e == "object" ? new GEe(e) : new HEe(e || 0);
});
class HEe {
  constructor(e) {
    this.$ = e;
  }
  R() {
    return this.$;
  }
  I(e) {
    return ((r) => {
      const n = On({
        ...r,
        ...Ji
      });
      if (!n || Math.abs(n[0]) > 1e8)
        throw new RangeError(Kc);
    })(e), [oA(e, this.$)];
  }
  O() {
  }
}
class GEe {
  constructor(e) {
    this.nn = ((r) => {
      function n(c) {
        const p = U0(c, a, l), [h, d] = zP(p), b = s(h), m = s(d);
        return b === m ? b : i(o(h, d), b, m, c);
      }
      function i(c, p, h, d) {
        let b, m;
        for (; (d === void 0 || (b = d < c[0] ? p : d >= c[1] ? h : void 0) === void 0) && (m = c[1] - c[0]); ) {
          const w = c[0] + Math.floor(m / 2);
          r(w) === h ? c[1] = w : c[0] = w + 1;
        }
        return b;
      }
      const s = ws(r), o = ws(kxe);
      let a = FEe, l = zEe;
      return {
        tn(c) {
          const p = n(c - 86400), h = n(c + 86400), d = c - p, b = c - h;
          if (p === h)
            return [d];
          const m = n(d);
          return m === n(b) ? [c - m] : p > h ? [d, b] : [];
        },
        rn: n,
        O(c, p) {
          const h = U0(c, a, l);
          let [d, b] = zP(h);
          const m = j1 * p, w = p < 0 ? () => b > a || (a = h, 0) : () => d < l || (l = h, 0);
          for (; w(); ) {
            const f = s(d), E = s(b);
            if (f !== E) {
              const A = o(d, b);
              i(A, f, E);
              const x = A[0];
              if ((Ul(x, c) || 1) === p)
                return x;
            }
            d += m, b += m;
          }
        }
      };
    })(/* @__PURE__ */ ((r) => (n) => {
      const i = aA(r, n * Yz);
      return o2(Oz(i), parseInt(i.month), parseInt(i.day), parseInt(i.hour), parseInt(i.minute), parseInt(i.second)) - n;
    })(e));
  }
  R(e) {
    return this.nn.rn(((r) => SP(r)[0])(e)) * $o;
  }
  I(e) {
    const [r, n] = [o2((i = e).isoYear, i.isoMonth, i.isoDay, i.isoHour, i.isoMinute, i.isoSecond), i.isoMillisecond * sl + i.isoMicrosecond * dm + i.isoNanosecond];
    var i;
    return this.nn.tn(r).map((s) => oa(Eh(s2(s, $o), n)));
  }
  O(e, r) {
    const [n, i] = SP(e), s = this.nn.O(n + (r > 0 || i ? 1 : 0), r);
    if (s !== void 0)
      return s2(s, $o);
  }
}
const s9 = "([+-])", B1 = "(?:[.,](\\d{1,9}))?", fV = `(?:(?:${s9}(\\d{6}))|(\\d{4}))-?(\\d{2})`, o9 = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + B1 + ")?)?", a9 = s9 + o9, WEe = fV + "-?(\\d{2})(?:[T ]" + o9 + "(Z|" + a9 + ")?)?", gV = "\\[(!?)([^\\]]*)\\]", Bv = `((?:${gV}){0,9})`, qEe = /* @__PURE__ */ of(fV + Bv), QEe = /* @__PURE__ */ of("(?:--)?(\\d{2})-?(\\d{2})" + Bv), KEe = /* @__PURE__ */ of(WEe + Bv), YEe = /* @__PURE__ */ of("T?" + o9 + "(?:" + a9 + ")?" + Bv), ZEe = /* @__PURE__ */ of(a9), JEe = /* @__PURE__ */ new RegExp(gV, "g"), XEe = /* @__PURE__ */ of(`${s9}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${B1}H)?(?:(\\d+)${B1}M)?(?:(\\d+)${B1}S)?)?`), e6e = /* @__PURE__ */ ws((t) => new Hl(lV, {
  timeZone: t,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
})), t6e = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, r6e = /[^\w\/:+-]+/, n6e = /^M(\d{2})(L?)$/, i6e = /* @__PURE__ */ ws(qxe), l9 = /* @__PURE__ */ ws((t) => new Hl(lV, {
  calendar: t,
  timeZone: Jh,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
})), mV = {
  P(t, e, r) {
    const n = yr(r);
    let i, { years: s, months: o, weeks: a, days: l } = e;
    if (l += $n(e, 5)[0], s || o)
      i = ((c, p, h, d, b) => {
        let [m, w, f] = c.v(p);
        if (h) {
          const [E, A] = c.q(m, w);
          m += h, w = u2(E, A, c.L(m)), w = ja("month", w, 1, c.B(m), b);
        }
        return d && ([m, w] = c.un(m, w, d)), f = ja("day", f, 1, c.U(m, w), b), c.p(m, w, f);
      })(this, t, s, o, n);
    else {
      if (!a && !l)
        return t;
      i = hi(t);
    }
    if (i === void 0)
      throw new RangeError(Kc);
    return i += (7 * a + l) * zi, Us(yv(i));
  },
  N(t, e, r) {
    if (r <= 7) {
      let l = 0, c = Az({
        ...t,
        ...Ji
      }, {
        ...e,
        ...Ji
      });
      return r === 7 && ([l, c] = sc(c, 7)), {
        ...jn,
        weeks: l,
        days: c
      };
    }
    const n = this.v(t), i = this.v(e);
    let [s, o, a] = ((l, c, p, h, d, b, m) => {
      let w = d - c, f = b - p, E = m - h;
      if (w || f) {
        const A = Math.sign(w || f);
        let x = l.U(d, b), g = 0;
        if (Math.sign(E) === -A) {
          const v = x;
          [d, b] = l.un(d, b, -A), w = d - c, f = b - p, x = l.U(d, b), g = A < 0 ? -v : x;
        }
        if (E = m - Math.min(h, x) + g, w) {
          const [v, k] = l.q(c, p), [S, R] = l.q(d, b);
          if (f = S - v || Number(R) - Number(k), Math.sign(f) === -A) {
            const L = A < 0 && -l.B(d);
            w = (d -= A) - c, f = b - u2(v, k, l.L(d)) + (L || l.B(d));
          }
        }
      }
      return [w, f, E];
    })(this, ...n, ...i);
    return r === 8 && (o += this.cn(s, n[0]), s = 0), {
      ...jn,
      years: s,
      months: o,
      days: a
    };
  },
  F(t, e) {
    const r = yr(e), n = H3(this, t), i = Jm(this, t, n, r), s = G3(this, t, i, n, r);
    return il(Us(this.V(n, i, s)), this.id || hr);
  },
  K(t, e) {
    const r = yr(e), n = H3(this, t), i = Jm(this, t, n, r);
    return H0(sA(this.V(n, i, 1)), this.id || hr);
  },
  _(t, e) {
    const r = yr(e);
    let n, i, s, o = t.eraYear !== void 0 || t.year !== void 0 ? H3(this, t) : void 0;
    const a = !this.id;
    if (o === void 0 && a && (o = Ca), o !== void 0) {
      const h = Jm(this, t, o, r);
      n = G3(this, t, h, o, r);
      const d = this.L(o);
      i = FA(h, d), s = h === d;
    } else {
      if (t.monthCode === void 0)
        throw new TypeError(Hz);
      if ([i, s] = BA(t.monthCode), this.id && this.id !== cf && this.id !== cc)
        if (this.id && Ah(this.id) === "coptic" && r === 0) {
          const h = s || i !== 13 ? 30 : 6;
          n = t.day, n = U0(n, 1, h);
        } else if (this.id && Ah(this.id) === "chinese" && r === 0) {
          const h = !s || i !== 1 && i !== 9 && i !== 10 && i !== 11 && i !== 12 ? 30 : 29;
          n = t.day, n = U0(n, 1, h);
        } else
          n = t.day;
      else
        n = G3(this, t, Jm(this, t, Ca, r), Ca, r);
    }
    const l = this.G(i, s, n);
    if (!l)
      throw new RangeError("Cannot guess year");
    const [c, p] = l;
    return a2(Us(this.V(c, p, n)), this.id || hr);
  },
  fields(t) {
    return R4(this) && t.includes("year") ? [...t, ...N4] : t;
  },
  k(t, e) {
    const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
    return W3(r, e, WA), R4(this) && (W3(r, e, hEe), this.id === cc && W3(r, e, pEe, N4)), r;
  },
  inLeapYear(t) {
    const [e] = this.v(t);
    return this.sn(e);
  },
  monthsInYear(t) {
    const [e] = this.v(t);
    return this.B(e);
  },
  daysInMonth(t) {
    const [e, r] = this.v(t);
    return this.U(e, r);
  },
  daysInYear(t) {
    const [e] = this.v(t);
    return this.fn(e);
  },
  dayOfYear: jA,
  era(t) {
    return this.hn(t)[0];
  },
  eraYear(t) {
    return this.hn(t)[1];
  },
  monthCode(t) {
    const [e, r] = this.v(t), [n, i] = this.q(e, r);
    return um(n, i);
  },
  dayOfWeek: UF,
  daysInWeek() {
    return 7;
  }
}, s6e = {
  v: lA,
  hn: HF,
  q: BF
}, o6e = {
  dayOfYear: jA,
  v: lA,
  p: Xd
}, a6e = /* @__PURE__ */ Object.assign({}, o6e, {
  weekOfYear: kz,
  yearOfWeek: _z,
  m(t) {
    function e(b) {
      return (7 - b < n ? 7 : 0) - b;
    }
    function r(b) {
      const m = VF(d + b), w = b || 1, f = e(e0(l + m * w, 7));
      return p = (m + (f - c) * w) / 7;
    }
    const n = this.id ? 1 : 4, i = UF(t), s = this.dayOfYear(t), o = e0(i - 1, 7), a = s - 1, l = e0(o - a, 7), c = e(l);
    let p, h = Math.floor((a - c) / 7) + 1, d = t.isoYear;
    return h ? h > r(0) && (h = 1, d++) : (h = r(-1), d--), [h, d, p];
  }
}), l6e = /* @__PURE__ */ Object.assign({}, mV, a6e, {
  v: lA,
  hn: HF,
  q: BF,
  G(t, e) {
    if (!e)
      return [Ca, t];
  },
  sn: cA,
  L() {
  },
  B: FF,
  cn: (t) => t * bl,
  U: zF,
  fn: VF,
  V: (t, e, r) => ({
    isoYear: t,
    isoMonth: e,
    isoDay: r
  }),
  p: Xd,
  un: (t, e, r) => (t += fv(r, bl), (e += Y8(r, bl)) < 1 ? (t--, e += bl) : e > bl && (t++, e -= bl), [t, e]),
  year(t) {
    return t.isoYear;
  },
  month(t) {
    return t.isoMonth;
  },
  day: (t) => t.isoDay
}), c6e = {
  v: h2,
  hn: Lz,
  q: Tz
}, u6e = {
  dayOfYear: jA,
  v: h2,
  p: q0,
  weekOfYear: kz,
  yearOfWeek: _z,
  m() {
    return [];
  }
}, h6e = /* @__PURE__ */ Object.assign({}, mV, u6e, {
  v: h2,
  hn: Lz,
  q: Tz,
  G(t, e, r) {
    const n = this.id && Ah(this.id) === "chinese" ? ((c, p, h) => {
      if (p)
        switch (c) {
          case 1:
            return 1651;
          case 2:
            return h < 30 ? 1947 : 1765;
          case 3:
            return h < 30 ? 1966 : 1955;
          case 4:
            return h < 30 ? 1963 : 1944;
          case 5:
            return h < 30 ? 1971 : 1952;
          case 6:
            return h < 30 ? 1960 : 1941;
          case 7:
            return h < 30 ? 1968 : 1938;
          case 8:
            return h < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      return 1972;
    })(t, e, r) : Ca;
    let [i, s, o] = h2.call(this, {
      isoYear: n,
      isoMonth: bl,
      isoDay: 31
    });
    const a = $1.call(this, i), l = s === a;
    (Ul(t, FA(s, a)) || Ul(Number(e), Number(l)) || Ul(r, o)) === 1 && i--;
    for (let c = 0; c < 100; c++) {
      const p = i - c, h = $1.call(this, p), d = u2(t, e, h);
      if (e === (d === h) && r <= KP.call(this, p, d))
        return [p, d];
    }
  },
  sn(t) {
    const e = Ym.call(this, t);
    return e > Ym.call(this, t - 1) && e > Ym.call(this, t + 1);
  },
  L: $1,
  B: Zm,
  cn(t, e) {
    const r = e + t, n = Math.sign(t), i = n < 0 ? -1 : 0;
    let s = 0;
    for (let o = e; o !== r; o += n)
      s += Zm.call(this, o + i);
    return s;
  },
  U: KP,
  fn: Ym,
  V(t, e, r) {
    return yv(q0.call(this, t, e, r));
  },
  p: q0,
  un(t, e, r) {
    if (r) {
      if (e += r, !Number.isSafeInteger(e))
        throw new RangeError(Kc);
      if (r < 0)
        for (; e < 1; )
          e += Zm.call(this, --t);
      else {
        let n;
        for (; e > (n = Zm.call(this, t)); )
          e -= n, t++;
      }
    }
    return [t, e];
  },
  year(t) {
    return this.h(t).year;
  },
  month(t) {
    const { year: e, o: r } = this.h(t), { u: n } = this.l(e);
    return n[r] + 1;
  },
  day(t) {
    return this.h(t).day;
  }
}), Fv = /* @__PURE__ */ Mz(s6e, c6e), Ft = /* @__PURE__ */ Mz(l6e, h6e), ZP = {
  era: D1,
  eraYear: oi,
  year: oi,
  month: EP,
  monthCode(t) {
    const e = D1(t);
    return BA(e), e;
  },
  day: EP,
  .../* @__PURE__ */ ad(ol, oi),
  .../* @__PURE__ */ ad(xr, tA),
  offset(t) {
    const e = D1(t);
    return Yh(e), e;
  }
}, c9 = /* @__PURE__ */ sr(IF, ol, yo), p6e = /* @__PURE__ */ sr(IF, yo, ol), Gl = "numeric", bm = ["timeZoneName"], yV = {
  month: Gl,
  day: Gl
}, u9 = {
  year: Gl,
  month: Gl
}, h9 = /* @__PURE__ */ Object.assign({}, u9, {
  day: Gl
}), p9 = {
  hour: Gl,
  minute: Gl,
  second: Gl
}, d9 = /* @__PURE__ */ Object.assign({}, h9, p9), d6e = /* @__PURE__ */ Object.assign({}, d9, {
  timeZoneName: "short"
}), f6e = /* @__PURE__ */ Object.keys(u9), g6e = /* @__PURE__ */ Object.keys(yV), m6e = /* @__PURE__ */ Object.keys(h9), y6e = /* @__PURE__ */ Object.keys(p9), f9 = ["dateStyle"], b6e = /* @__PURE__ */ f6e.concat(f9), v6e = /* @__PURE__ */ g6e.concat(f9), g9 = /* @__PURE__ */ m6e.concat(f9, ["weekday"]), vm = /* @__PURE__ */ y6e.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]), m9 = /* @__PURE__ */ g9.concat(vm), w6e = /* @__PURE__ */ bm.concat(vm), x6e = /* @__PURE__ */ bm.concat(g9), E6e = /* @__PURE__ */ bm.concat(["day", "weekday"], vm), S6e = /* @__PURE__ */ bm.concat(["year", "weekday"], vm), A6e = /* @__PURE__ */ Zh(m9, d9), k6e = /* @__PURE__ */ Zh(m9, d6e), _6e = /* @__PURE__ */ Zh(m9, d9, bm), C6e = /* @__PURE__ */ Zh(g9, h9, w6e), I6e = /* @__PURE__ */ Zh(vm, p9, x6e), P6e = /* @__PURE__ */ Zh(b6e, u9, E6e), R6e = /* @__PURE__ */ Zh(v6e, yV, S6e), O6e = {}, bV = new Hl(void 0, {
  calendar: hr
}).resolvedOptions().calendar === hr, vV = [A6e, gA], T6e = [k6e, gA, 0, (t, e) => {
  const r = t.timeZone;
  if (e && e.timeZone !== r)
    throw new RangeError(Qz);
  return r;
}], wV = [_6e, hi], xV = [C6e, hi], EV = [I6e, (t) => oc(t) / sl], SV = [P6e, hi, bV], AV = [R6e, hi, bV];
let JP;
function Zc(t, e, r, n, i) {
  function s(...l) {
    if (!(this instanceof s))
      throw new TypeError(T4);
    tR(this, e(...l));
  }
  function o(l, c) {
    return Object.defineProperties(function(...p) {
      return l.call(this, a(this), ...p);
    }, V0(c));
  }
  function a(l) {
    const c = Ai(l);
    if (!c || c.branding !== t)
      throw new TypeError(T4);
    return c;
  }
  return Object.defineProperties(s.prototype, {
    ...nxe(Ba(o, r)),
    ...id(Ba(o, n)),
    ...K8("Temporal." + t)
  }), Object.defineProperties(s, {
    ...id(i),
    ...V0(t)
  }), [s, (l) => {
    const c = Object.create(s.prototype);
    return tR(c, l), c;
  }, a];
}
function hf(t) {
  if (Ai(t) || t.calendar !== void 0 || t.timeZone !== void 0)
    throw new TypeError(U4e);
  return t;
}
function wm(t) {
  return kV(t) || hr;
}
function kV(t) {
  const { calendar: e } = t;
  if (e !== void 0)
    return zv(e);
}
function zv(t) {
  if (Ei(t)) {
    const { calendar: e } = Ai(t) || {};
    if (!e)
      throw new TypeError(Gz(t));
    return e;
  }
  return ((e) => Mv(Mxe(ei(e))))(t);
}
function y9(t) {
  const e = {};
  for (const r in t)
    e[r] = (n) => {
      const { calendar: i } = n;
      return Ft(i)[r](n);
    };
  return e;
}
function Jc() {
  throw new TypeError(H4e);
}
function as(t) {
  if (Ei(t)) {
    const { timeZone: e } = Ai(t) || {};
    if (!e)
      throw new TypeError(qz(t));
    return e;
  }
  return ((e) => MA(Nxe(ei(e))))(t);
}
function un(t) {
  if (Ei(t)) {
    const e = Ai(t);
    return e && e.branding === i9 ? e : n4e(t);
  }
  return Lxe(t);
}
function If(t) {
  if (t !== void 0) {
    if (Ei(t)) {
      const e = Ai(t) || {};
      switch (e.branding) {
        case Yc:
        case ym:
          return e;
        case uf:
          return il(e);
      }
      const r = wm(t);
      return {
        ...Yxe(as, Yt, Ft(r), t),
        calendar: r
      };
    }
    return Cxe(t);
  }
}
function vl(t, e) {
  if (Ei(t)) {
    const n = Ai(t) || {};
    switch (n.branding) {
      case r9:
        return yr(e), n;
      case uf:
        return yr(e), la(n);
      case Yc:
        return yr(e), Bz(Yt, n);
    }
    return r4e(t, e);
  }
  const r = Txe(t);
  return yr(e), r;
}
function b9(t) {
  return t === void 0 ? void 0 : vl(t);
}
function fp(t, e) {
  if (Ei(t)) {
    const n = Ai(t) || {};
    switch (n.branding) {
      case uf:
        return yr(e), n;
      case ym:
        return yr(e), mo({
          ...n,
          ...Ji
        });
      case Yc:
        return yr(e), $z(Yt, n);
    }
    return Jxe(Ft(wm(t)), t, e);
  }
  const r = Pxe(t);
  return yr(e), r;
}
function XP(t, e) {
  if (Ei(t)) {
    const n = Ai(t);
    if (n && n.branding === t9)
      return yr(e), n;
    const i = kV(t);
    return t4e(Ft(i || hr), !i, t, e);
  }
  const r = Oxe(Ft, t);
  return yr(e), r;
}
function gp(t, e) {
  if (Ei(t)) {
    const n = Ai(t);
    return n && n.branding === e9 ? (yr(e), n) : e4e(Ft(wm(t)), t, e);
  }
  const r = Rxe(Ft, t);
  return yr(e), r;
}
function mp(t, e) {
  if (Ei(t)) {
    const n = Ai(t) || {};
    switch (n.branding) {
      case ym:
        return yr(e), n;
      case uf:
        return yr(e), il(n);
      case Yc:
        return yr(e), jz(Yt, n);
    }
    return Xxe(Ft(wm(t)), t, e);
  }
  const r = CA(t);
  return yr(e), r;
}
function yp(t, e) {
  if (Ei(t)) {
    const r = Ai(t);
    if (r && r.branding === Yc)
      return vv(e), r;
    const n = wm(t);
    return Zxe(as, Yt, Ft(n), n, t, e);
  }
  return Ixe(t, e);
}
function eR(t) {
  return Ba((e) => (r) => e($4(r)), t);
}
function $4(t) {
  return Ss(t, Yt);
}
function bp(t) {
  if (Ei(t)) {
    const e = Ai(t);
    if (e)
      switch (e.branding) {
        case n9:
          return e;
        case Yc:
          return nl(e.epochNanoseconds);
      }
  }
  return _xe(t);
}
function L6e() {
  function t(s, o) {
    return new e(s, o);
  }
  function e(s, o = /* @__PURE__ */ Object.create(null)) {
    f2.set(this, ((a, l) => {
      const c = new Hl(a, l), p = c.resolvedOptions(), h = p.locale, d = fo(Object.keys(l), p), b = ws(D6e), m = (w, ...f) => {
        if (w) {
          if (f.length !== 2)
            throw new TypeError(Q3);
          for (const g of f)
            if (g === void 0)
              throw new TypeError(Q3);
        }
        w || f[0] !== void 0 || (f = []);
        const E = f.map((g) => Ai(g) || Number(g));
        let A, x = 0;
        for (const g of E) {
          const v = typeof g == "object" ? g.branding : void 0;
          if (x++ && v !== A)
            throw new TypeError(Q3);
          A = v;
        }
        return A ? b(A)(h, d, ...E) : [c, ...E];
      };
      return m.X = c, m;
    })(s, o));
  }
  const r = Hl.prototype, n = Object.getOwnPropertyDescriptors(r), i = Object.getOwnPropertyDescriptors(Hl);
  for (const s in n) {
    const o = n[s], a = s.startsWith("format") && M6e(s);
    typeof o.value == "function" ? o.value = s === "constructor" ? t : a || N6e(s) : a && (o.get = function() {
      if (!f2.has(this))
        throw new TypeError(T4);
      return (...l) => a.apply(this, l);
    }, Object.defineProperties(o.get, V0(`get ${s}`)));
  }
  return i.prototype.value = e.prototype = Object.create({}, n), Object.defineProperties(t, i), t;
}
function M6e(t) {
  return Object.defineProperties(function(...e) {
    const r = f2.get(this), [n, ...i] = r(t.includes("Range"), ...e);
    return n[t](...i);
  }, V0(t));
}
function N6e(t) {
  return Object.defineProperties(function(...e) {
    return f2.get(this).X[t](...e);
  }, V0(t));
}
function D6e(t) {
  const e = V6e[t];
  if (!e)
    throw new TypeError(lEe(t));
  return qc(e, ws(Fz), 1);
}
const d2 = /* @__PURE__ */ new WeakMap(), Ai = /* @__PURE__ */ d2.get.bind(d2), tR = /* @__PURE__ */ d2.set.bind(d2), _V = {
  era: ixe,
  eraYear: TF,
  year: Z8,
  month: ga,
  daysInMonth: ga,
  daysInYear: ga,
  inLeapYear: fEe,
  monthsInYear: ga
}, v9 = {
  monthCode: ei
}, CV = {
  day: ga
}, $6e = {
  dayOfWeek: ga,
  dayOfYear: ga,
  weekOfYear: sxe,
  yearOfWeek: TF,
  daysInWeek: ga
}, w9 = /* @__PURE__ */ y9(/* @__PURE__ */ Object.assign({}, _V, v9, CV, $6e)), j6e = /* @__PURE__ */ y9({
  ..._V,
  ...v9
}), B6e = /* @__PURE__ */ y9({
  ...v9,
  ...CV
}), xm = {
  calendarId: (t) => t.calendar
}, F6e = /* @__PURE__ */ dv((t) => (e) => e[t], xr.concat("sign")), x9 = /* @__PURE__ */ dv((t, e) => (r) => r[yo[e]], ol), IV = {
  epochMilliseconds: gA,
  epochNanoseconds: lxe
}, [z6e, tn, HIe] = Zc(i9, b4e, {
  ...F6e,
  blank: Axe
}, {
  with: (t, e) => tn(u4e(t, e)),
  negated: (t) => tn(_A(t)),
  abs: (t) => tn(Sxe(t)),
  add: (t, e, r) => tn(FP(If, Ft, Yt, 0, t, un(e), r)),
  subtract: (t, e, r) => tn(FP(If, Ft, Yt, 1, t, un(e), r)),
  round: (t, e) => tn(Exe(If, Ft, Yt, t, e)),
  total: (t, e) => cxe(If, Ft, Yt, t, e),
  toLocaleString(t, e, r) {
    return Intl.DurationFormat ? new Intl.DurationFormat(e, r).format(this) : U3(t);
  },
  toString: U3,
  toJSON: (t) => U3(t),
  valueOf: Jc
}, {
  from: (t) => tn(un(t)),
  compare: (t, e, r) => $xe(If, Ft, Yt, un(t), un(e), r)
}), V6e = {
  Instant: vV,
  PlainDateTime: wV,
  PlainDate: xV,
  PlainTime: EV,
  PlainYearMonth: SV,
  PlainMonthDay: AV
}, U6e = /* @__PURE__ */ qc(vV), H6e = /* @__PURE__ */ qc(T6e), G6e = /* @__PURE__ */ qc(wV), W6e = /* @__PURE__ */ qc(xV), q6e = /* @__PURE__ */ qc(EV), Q6e = /* @__PURE__ */ qc(SV), K6e = /* @__PURE__ */ qc(AV), [Y6e, Cl] = Zc(r9, y4e, x9, {
  with(t, e, r) {
    return Cl(c4e(this, hf(e), r));
  },
  add: (t, e) => Cl(BP(0, t, un(e))),
  subtract: (t, e) => Cl(BP(1, t, un(e))),
  until: (t, e, r) => tn(QP(0, t, vl(e), r)),
  since: (t, e, r) => tn(QP(1, t, vl(e), r)),
  round: (t, e) => Cl(dxe(t, e)),
  equals: (t, e) => Hxe(t, vl(e)),
  toLocaleString(t, e, r) {
    const [n, i] = q6e(e, r, t);
    return n.format(i);
  },
  toString: TP,
  toJSON: (t) => TP(t),
  valueOf: Jc
}, {
  from: (t, e) => Cl(vl(t, e)),
  compare: (t, e) => DA(vl(t), vl(e))
}), [Z6e, _o] = Zc(uf, sr(d4e, hm), {
  ...xm,
  ...w9,
  ...x9
}, {
  with: (t, e, r) => _o(s4e(Ft, t, hf(e), r)),
  withCalendar: (t, e) => _o(zA(t, zv(e))),
  withPlainTime: (t, e) => _o(T4e(t, b9(e))),
  add: (t, e, r) => _o(DP(Ft, 0, t, un(e), r)),
  subtract: (t, e, r) => _o(DP(Ft, 1, t, un(e), r)),
  until: (t, e, r) => tn(GP(Ft, 0, t, fp(e), r)),
  since: (t, e, r) => tn(GP(Ft, 1, t, fp(e), r)),
  round: (t, e) => _o(pxe(t, e)),
  equals: (t, e) => Fxe(t, fp(e)),
  toZonedDateTime: (t, e, r) => ni(x4e(Yt, t, as(e), r)),
  toPlainDate: (t) => Oo(il(t)),
  toPlainTime: (t) => Cl(la(t)),
  toLocaleString(t, e, r) {
    const [n, i] = G6e(e, r, t);
    return n.format(i);
  },
  toString: IP,
  toJSON: (t) => IP(t),
  valueOf: Jc
}, {
  from: (t, e) => _o(fp(t, e)),
  compare: (t, e) => bz(fp(t), fp(e))
}), [J6e, j4, GIe] = Zc(t9, sr(m4e, hm), {
  ...xm,
  ...B6e
}, {
  with: (t, e, r) => j4(l4e(Ft, t, hf(e), r)),
  equals: (t, e) => Uxe(t, XP(e)),
  toPlainDate(t, e) {
    return Oo(C4e(Ft, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = K6e(e, r, t);
    return n.format(i);
  },
  toString: OP,
  toJSON: (t) => OP(t),
  valueOf: Jc
}, {
  from: (t, e) => j4(XP(t, e))
}), [X6e, Df, WIe] = Zc(e9, sr(g4e, hm), {
  ...xm,
  ...j6e
}, {
  with: (t, e, r) => Df(a4e(Ft, t, hf(e), r)),
  add: (t, e, r) => Df(jP(Ft, 0, t, un(e), r)),
  subtract: (t, e, r) => Df(jP(Ft, 1, t, un(e), r)),
  until: (t, e, r) => tn(qP(Ft, 0, t, gp(e), r)),
  since: (t, e, r) => tn(qP(Ft, 1, t, gp(e), r)),
  equals: (t, e) => Vxe(t, gp(e)),
  toPlainDate(t, e) {
    return Oo(_4e(Ft, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = Q6e(e, r, t);
    return n.format(i);
  },
  toString: RP,
  toJSON: (t) => RP(t),
  valueOf: Jc
}, {
  from: (t, e) => Df(gp(t, e)),
  compare: (t, e) => af(gp(t), gp(e))
}), [e5e, Oo, qIe] = Zc(ym, sr(f4e, hm), {
  ...xm,
  ...w9
}, {
  with: (t, e, r) => Oo(o4e(Ft, t, hf(e), r)),
  withCalendar: (t, e) => Oo(zA(t, zv(e))),
  add: (t, e, r) => Oo($P(Ft, 0, t, un(e), r)),
  subtract: (t, e, r) => Oo($P(Ft, 1, t, un(e), r)),
  until: (t, e, r) => tn(WP(Ft, 0, t, mp(e), r)),
  since: (t, e, r) => tn(WP(Ft, 1, t, mp(e), r)),
  equals: (t, e) => zxe(t, mp(e)),
  toZonedDateTime(t, e) {
    const r = Ei(e) ? e : {
      timeZone: e
    };
    return ni(E4e(as, vl, Yt, t, r));
  },
  toPlainDateTime: (t, e) => _o(S4e(t, b9(e))),
  toPlainYearMonth(t) {
    return Df(A4e(Ft, t, this));
  },
  toPlainMonthDay(t) {
    return j4(k4e(Ft, t, this));
  },
  toLocaleString(t, e, r) {
    const [n, i] = W6e(e, r, t);
    return n.format(i);
  },
  toString: PP,
  toJSON: (t) => PP(t),
  valueOf: Jc
}, {
  from: (t, e) => Oo(mp(t, e)),
  compare: (t, e) => af(mp(t), mp(e))
}), [t5e, ni] = Zc(Yc, sr(p4e, hm, Dxe), {
  ...IV,
  ...xm,
  ...eR(w9),
  ...eR(x9),
  offset: (t) => lm($4(t).offsetNanoseconds),
  offsetNanoseconds: (t) => $4(t).offsetNanoseconds,
  timeZoneId: (t) => t.timeZone,
  hoursInDay: (t) => fxe(Yt, t)
}, {
  with: (t, e, r) => ni(i4e(Ft, Yt, t, hf(e), r)),
  withCalendar: (t, e) => ni(zA(t, zv(e))),
  withTimeZone: (t, e) => ni(L4e(t, as(e))),
  withPlainTime: (t, e) => ni(O4e(Yt, t, b9(e))),
  add: (t, e, r) => ni(NP(Ft, Yt, 0, t, un(e), r)),
  subtract: (t, e, r) => ni(NP(Ft, Yt, 1, t, un(e), r)),
  until: (t, e, r) => tn(wn(HP(Ft, Yt, 0, t, yp(e), r))),
  since: (t, e, r) => tn(wn(HP(Ft, Yt, 1, t, yp(e), r))),
  round: (t, e) => ni(hxe(Yt, t, e)),
  startOfDay: (t) => ni(gxe(Yt, t)),
  equals: (t, e) => Bxe(t, yp(e)),
  toInstant: (t) => wl(w4e(t)),
  toPlainDateTime: (t) => _o($z(Yt, t)),
  toPlainDate: (t) => Oo(jz(Yt, t)),
  toPlainTime: (t) => Cl(Bz(Yt, t)),
  toLocaleString(t, e, r = {}) {
    const [n, i] = H6e(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => CP(Yt, t, e),
  toJSON: (t) => CP(Yt, t),
  valueOf: Jc,
  getTimeZoneTransition(t, e) {
    const { timeZone: r, epochNanoseconds: n } = t, i = axe(e), s = Yt(r).O(n, i);
    return s ? ni({
      ...t,
      epochNanoseconds: s
    }) : null;
  }
}, {
  from: (t, e) => ni(yp(t, e)),
  compare: (t, e) => yz(yp(t), yp(e))
}), [r5e, wl, QIe] = Zc(n9, h4e, IV, {
  add: (t, e) => wl(MP(0, t, un(e))),
  subtract: (t, e) => wl(MP(1, t, un(e))),
  until: (t, e, r) => tn(UP(0, t, bp(e), r)),
  since: (t, e, r) => tn(UP(1, t, bp(e), r)),
  round: (t, e) => wl(uxe(t, e)),
  equals: (t, e) => jxe(t, bp(e)),
  toZonedDateTimeISO: (t, e) => ni(v4e(t, as(e))),
  toLocaleString(t, e, r) {
    const [n, i] = U6e(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => _P(as, Yt, t, e),
  toJSON: (t) => _P(as, Yt, t),
  valueOf: Jc
}, {
  from: (t) => wl(bp(t)),
  fromEpochMilliseconds: (t) => wl(I4e(t)),
  fromEpochNanoseconds: (t) => wl(P4e(t)),
  compare: (t, e) => mz(bp(t), bp(e))
}), n5e = /* @__PURE__ */ Object.defineProperties({}, {
  ...K8("Temporal.Now"),
  ...id({
    timeZoneId: () => _f(),
    instant: () => wl(nl(O4())),
    zonedDateTimeISO: (t = _f()) => ni(go(O4(), as(t), hr)),
    plainDateTimeISO: (t = _f()) => _o(mo(q3(Yt(as(t))), hr)),
    plainDateISO: (t = _f()) => Oo(il(q3(Yt(as(t))), hr)),
    plainTimeISO: (t = _f()) => Cl(la(q3(Yt(as(t)))))
  })
}), Xm = /* @__PURE__ */ Object.defineProperties({}, {
  ...K8("Temporal"),
  ...id({
    PlainYearMonth: X6e,
    PlainMonthDay: J6e,
    PlainDate: e5e,
    PlainTime: Y6e,
    PlainDateTime: Z6e,
    ZonedDateTime: t5e,
    Instant: r5e,
    Duration: z6e,
    Now: n5e
  })
}), i5e = /* @__PURE__ */ L6e(), f2 = /* @__PURE__ */ new WeakMap();
id({
  DateTimeFormat: i5e
});
var B4 = 9e15, Xc = 1e9, F4 = "0123456789abcdef", g2 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", m2 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", z4 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -9e15,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: B4,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, PV, ma, Mt = !0, Vv = "[DecimalError] ", kh = Vv + "Invalid argument: ", RV = Vv + "Precision limit exceeded", OV = Vv + "crypto unavailable", Bn = Math.floor, An = Math.pow, s5e = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, o5e = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, a5e = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, l5e = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Gs = 1e7, wt = 7, c5e = 9007199254740991, u5e = g2.length - 1, V4 = m2.length - 1, Ue = { name: "[object Decimal]" };
Ue.absoluteValue = Ue.abs = function() {
  var t = new this.constructor(this);
  return t.s < 0 && (t.s = 1), mt(t);
};
Ue.ceil = function() {
  return mt(new this.constructor(this), this.e + 1, 2);
};
Ue.comparedTo = Ue.cmp = function(t) {
  var e, r, n, i, s = this, o = s.d, a = (t = new s.constructor(t)).d, l = s.s, c = t.s;
  if (!o || !a)
    return !l || !c ? NaN : l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? l : a[0] ? -c : 0;
  if (l !== c) return l;
  if (s.e !== t.e) return s.e > t.e ^ l < 0 ? 1 : -1;
  for (n = o.length, i = a.length, e = 0, r = n < i ? n : i; e < r; ++e)
    if (o[e] !== a[e]) return o[e] > a[e] ^ l < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
};
Ue.cosine = Ue.cos = function() {
  var t, e, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + wt, n.rounding = 1, r = h5e(n, DV(n, r)), n.precision = t, n.rounding = e, mt(ma == 2 || ma == 3 ? r.neg() : r, t, e, !0)) : new n(1) : new n(NaN);
};
Ue.cubeRoot = Ue.cbrt = function() {
  var t, e, r, n, i, s, o, a, l, c, p = this, h = p.constructor;
  if (!p.isFinite() || p.isZero()) return new h(p);
  for (Mt = !1, s = p.s * Math.pow(p.s * p, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = pn(p.d), t = p.e, (s = (t - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Math.pow(r, 1 / 3), t = Bn((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + t : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + t), n = new h(r), n.s = p.s) : n = new h(s.toString()), o = (t = h.precision) + 3; ; )
    if (a = n, l = a.times(a).times(a), c = l.plus(p), n = ar(c.plus(p).times(a), c.plus(l), o + 2, 1), pn(a.d).slice(0, o) === (r = pn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (mt(a, t + 1, 0), a.times(a).times(a).eq(p))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (mt(n, t + 1, 1), e = !n.times(n).times(n).eq(p));
        break;
      }
  return Mt = !0, mt(n, t, h.rounding, e);
};
Ue.decimalPlaces = Ue.dp = function() {
  var t, e = this.d, r = NaN;
  if (e) {
    if (t = e.length - 1, r = (t - Bn(this.e / wt)) * wt, t = e[t], t) for (; t % 10 == 0; t /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
Ue.dividedBy = Ue.div = function(t) {
  return ar(this, new this.constructor(t));
};
Ue.dividedToIntegerBy = Ue.divToInt = function(t) {
  var e = this, r = e.constructor;
  return mt(ar(e, new r(t), 0, 1, 1), r.precision, r.rounding);
};
Ue.equals = Ue.eq = function(t) {
  return this.cmp(t) === 0;
};
Ue.floor = function() {
  return mt(new this.constructor(this), this.e + 1, 3);
};
Ue.greaterThan = Ue.gt = function(t) {
  return this.cmp(t) > 0;
};
Ue.greaterThanOrEqualTo = Ue.gte = function(t) {
  var e = this.cmp(t);
  return e == 1 || e === 0;
};
Ue.hyperbolicCosine = Ue.cosh = function() {
  var t, e, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (t = Math.ceil(i / 3), e = Math.pow(4, -t).toString()) : (t = 16, e = "2.3283064365386962890625e-10"), s = ld(o, 1, s.times(e), new o(1), !0);
  for (var l, c = t, p = new o(8); c--; )
    l = s.times(s), s = a.minus(l.times(p.minus(l.times(p))));
  return mt(s, o.precision = r, o.rounding = n, !0);
};
Ue.hyperbolicSine = Ue.sinh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero()) return new s(i);
  if (e = s.precision, r = s.rounding, s.precision = e + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = ld(s, 2, i, i, !0);
  else {
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, i = i.times(Math.pow(5, -t)), i = ld(s, 2, i, i, !0);
    for (var o, a = new s(5), l = new s(16), c = new s(20); t--; )
      o = i.times(i), i = i.times(a.plus(o.times(l.times(o).plus(c))));
  }
  return s.precision = e, s.rounding = r, mt(i, e, r, !0);
};
Ue.hyperbolicTangent = Ue.tanh = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 7, n.rounding = 1, ar(r.sinh(), r.cosh(), n.precision = t, n.rounding = e)) : new n(r.s);
};
Ue.inverseCosine = Ue.acos = function() {
  var t, e = this, r = e.constructor, n = e.abs().cmp(1), i = r.precision, s = r.rounding;
  return n !== -1 ? n === 0 ? e.isNeg() ? Ns(r, i, s) : new r(0) : new r(NaN) : e.isZero() ? Ns(r, i + 4, s).times(0.5) : (r.precision = i + 6, r.rounding = 1, e = e.asin(), t = Ns(r, i + 4, s).times(0.5), r.precision = i, r.rounding = s, t.minus(e));
};
Ue.inverseHyperbolicCosine = Ue.acosh = function() {
  var t, e, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, Mt = !1, r = r.times(r).minus(1).sqrt().plus(r), Mt = !0, n.precision = t, n.rounding = e, r.ln()) : new n(r);
};
Ue.inverseHyperbolicSine = Ue.asinh = function() {
  var t, e, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, Mt = !1, r = r.times(r).plus(1).sqrt().plus(r), Mt = !0, n.precision = t, n.rounding = e, r.ln());
};
Ue.inverseHyperbolicTangent = Ue.atanh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (t = s.precision, e = s.rounding, n = i.sd(), Math.max(n, t) < 2 * -i.e - 1 ? mt(new s(i), t, e, !0) : (s.precision = r = n - i.e, i = ar(i.plus(1), new s(1).minus(i), r + t, 1), s.precision = t + 4, s.rounding = 1, i = i.ln(), s.precision = t, s.rounding = e, i.times(0.5))) : new s(NaN);
};
Ue.inverseSine = Ue.asin = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (e = i.abs().cmp(1), r = s.precision, n = s.rounding, e !== -1 ? e === 0 ? (t = Ns(s, r + 4, n).times(0.5), t.s = i.s, t) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
Ue.inverseTangent = Ue.atan = function() {
  var t, e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new p(c);
    if (c.abs().eq(1) && h + 4 <= V4)
      return o = Ns(p, h + 4, d).times(0.25), o.s = c.s, o;
  } else {
    if (!c.s) return new p(NaN);
    if (h + 4 <= V4)
      return o = Ns(p, h + 4, d).times(0.5), o.s = c.s, o;
  }
  for (p.precision = a = h + 10, p.rounding = 1, r = Math.min(28, a / wt + 2 | 0), t = r; t; --t) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (Mt = !1, e = Math.ceil(a / wt), n = 1, l = c.times(c), o = new p(c), i = c; t !== -1; )
    if (i = i.times(l), s = o.minus(i.div(n += 2)), i = i.times(l), o = s.plus(i.div(n += 2)), o.d[e] !== void 0) for (t = e; o.d[t] === s.d[t] && t--; ) ;
  return r && (o = o.times(2 << r - 1)), Mt = !0, mt(o, p.precision = h, p.rounding = d, !0);
};
Ue.isFinite = function() {
  return !!this.d;
};
Ue.isInteger = Ue.isInt = function() {
  return !!this.d && Bn(this.e / wt) > this.d.length - 2;
};
Ue.isNaN = function() {
  return !this.s;
};
Ue.isNegative = Ue.isNeg = function() {
  return this.s < 0;
};
Ue.isPositive = Ue.isPos = function() {
  return this.s > 0;
};
Ue.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
Ue.lessThan = Ue.lt = function(t) {
  return this.cmp(t) < 0;
};
Ue.lessThanOrEqualTo = Ue.lte = function(t) {
  return this.cmp(t) < 1;
};
Ue.logarithm = Ue.log = function(t) {
  var e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding, b = 5;
  if (t == null)
    t = new p(10), e = !0;
  else {
    if (t = new p(t), r = t.d, t.s < 0 || !r || !r[0] || t.eq(1)) return new p(NaN);
    e = t.eq(10);
  }
  if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1))
    return new p(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (e)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      s = i !== 1;
    }
  if (Mt = !1, a = h + b, o = Tl(c, a), n = e ? y2(p, a + 10) : Tl(t, a), l = ar(o, n, a, 1), Y0(l.d, i = h, d))
    do
      if (a += 10, o = Tl(c, a), n = e ? y2(p, a + 10) : Tl(t, a), l = ar(o, n, a, 1), !s) {
        +pn(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = mt(l, h + 1, 0));
        break;
      }
    while (Y0(l.d, i += 10, d));
  return Mt = !0, mt(l, h, d);
};
Ue.minus = Ue.sub = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, b = this, m = b.constructor;
  if (t = new m(t), !b.d || !t.d)
    return !b.s || !t.s ? t = new m(NaN) : b.d ? t.s = -t.s : t = new m(t.d || b.s !== t.s ? b : NaN), t;
  if (b.s != t.s)
    return t.s = -t.s, b.plus(t);
  if (c = b.d, d = t.d, a = m.precision, l = m.rounding, !c[0] || !d[0]) {
    if (d[0]) t.s = -t.s;
    else if (c[0]) t = new m(b);
    else return new m(l === 3 ? -0 : 0);
    return Mt ? mt(t, a, l) : t;
  }
  if (r = Bn(t.e / wt), p = Bn(b.e / wt), c = c.slice(), s = p - r, s) {
    for (h = s < 0, h ? (e = c, s = -s, o = d.length) : (e = d, r = p, o = c.length), n = Math.max(Math.ceil(a / wt), o) + 2, s > n && (s = n, e.length = 1), e.reverse(), n = s; n--; ) e.push(0);
    e.reverse();
  } else {
    for (n = c.length, o = d.length, h = n < o, h && (o = n), n = 0; n < o; n++)
      if (c[n] != d[n]) {
        h = c[n] < d[n];
        break;
      }
    s = 0;
  }
  for (h && (e = c, c = d, d = e, t.s = -t.s), o = c.length, n = d.length - o; n > 0; --n) c[o++] = 0;
  for (n = d.length; n > s; ) {
    if (c[--n] < d[n]) {
      for (i = n; i && c[--i] === 0; ) c[i] = Gs - 1;
      --c[i], c[n] += Gs;
    }
    c[n] -= d[n];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --r;
  return c[0] ? (t.d = c, t.e = Uv(c, r), Mt ? mt(t, a, l) : t) : new m(l === 3 ? -0 : 0);
};
Ue.modulo = Ue.mod = function(t) {
  var e, r = this, n = r.constructor;
  return t = new n(t), !r.d || !t.s || t.d && !t.d[0] ? new n(NaN) : !t.d || r.d && !r.d[0] ? mt(new n(r), n.precision, n.rounding) : (Mt = !1, n.modulo == 9 ? (e = ar(r, t.abs(), 0, 3, 1), e.s *= t.s) : e = ar(r, t, 0, n.modulo, 1), e = e.times(t), Mt = !0, r.minus(e));
};
Ue.naturalExponential = Ue.exp = function() {
  return U4(this);
};
Ue.naturalLogarithm = Ue.ln = function() {
  return Tl(this);
};
Ue.negated = Ue.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s, mt(t);
};
Ue.plus = Ue.add = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h = this, d = h.constructor;
  if (t = new d(t), !h.d || !t.d)
    return !h.s || !t.s ? t = new d(NaN) : h.d || (t = new d(t.d || h.s === t.s ? h : NaN)), t;
  if (h.s != t.s)
    return t.s = -t.s, h.minus(t);
  if (c = h.d, p = t.d, a = d.precision, l = d.rounding, !c[0] || !p[0])
    return p[0] || (t = new d(h)), Mt ? mt(t, a, l) : t;
  if (s = Bn(h.e / wt), n = Bn(t.e / wt), c = c.slice(), i = s - n, i) {
    for (i < 0 ? (r = c, i = -i, o = p.length) : (r = p, n = s, o = c.length), s = Math.ceil(a / wt), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = c.length, i = p.length, o - i < 0 && (i = o, r = p, p = c, c = r), e = 0; i; )
    e = (c[--i] = c[i] + p[i] + e) / Gs | 0, c[i] %= Gs;
  for (e && (c.unshift(e), ++n), o = c.length; c[--o] == 0; ) c.pop();
  return t.d = c, t.e = Uv(c, n), Mt ? mt(t, a, l) : t;
};
Ue.precision = Ue.sd = function(t) {
  var e, r = this;
  if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(kh + t);
  return r.d ? (e = TV(r.d), t && r.e + 1 > e && (e = r.e + 1)) : e = NaN, e;
};
Ue.round = function() {
  var t = this, e = t.constructor;
  return mt(new e(t), t.e + 1, e.rounding);
};
Ue.sine = Ue.sin = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + wt, n.rounding = 1, r = d5e(n, DV(n, r)), n.precision = t, n.rounding = e, mt(ma > 2 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Ue.squareRoot = Ue.sqrt = function() {
  var t, e, r, n, i, s, o = this, a = o.d, l = o.e, c = o.s, p = o.constructor;
  if (c !== 1 || !a || !a[0])
    return new p(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (Mt = !1, c = Math.sqrt(+o), c == 0 || c == 1 / 0 ? (e = pn(a), (e.length + l) % 2 == 0 && (e += "0"), c = Math.sqrt(e), l = Bn((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? e = "1e" + l : (e = c.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + l), n = new p(e)) : n = new p(c.toString()), r = (l = p.precision) + 3; ; )
    if (s = n, n = s.plus(ar(o, s, r + 2, 1)).times(0.5), pn(s.d).slice(0, r) === (e = pn(n.d)).slice(0, r))
      if (e = e.slice(r - 3, r + 1), e == "9999" || !i && e == "4999") {
        if (!i && (mt(s, l + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (mt(n, l + 1, 1), t = !n.times(n).eq(o));
        break;
      }
  return Mt = !0, mt(n, l, p.rounding, t);
};
Ue.tangent = Ue.tan = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = ar(r, new n(1).minus(r.times(r)).sqrt(), t + 10, 0), n.precision = t, n.rounding = e, mt(ma == 2 || ma == 4 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Ue.times = Ue.mul = function(t) {
  var e, r, n, i, s, o, a, l, c, p = this, h = p.constructor, d = p.d, b = (t = new h(t)).d;
  if (t.s *= p.s, !d || !d[0] || !b || !b[0])
    return new h(!t.s || d && !d[0] && !b || b && !b[0] && !d ? NaN : !d || !b ? t.s / 0 : t.s * 0);
  for (r = Bn(p.e / wt) + Bn(t.e / wt), l = d.length, c = b.length, l < c && (s = d, d = b, b = s, o = l, l = c, c = o), s = [], o = l + c, n = o; n--; ) s.push(0);
  for (n = c; --n >= 0; ) {
    for (e = 0, i = l + n; i > n; )
      a = s[i] + b[n] * d[i - n - 1] + e, s[i--] = a % Gs | 0, e = a / Gs | 0;
    s[i] = (s[i] + e) % Gs | 0;
  }
  for (; !s[--o]; ) s.pop();
  return e ? ++r : s.shift(), t.d = s, t.e = Uv(s, r), Mt ? mt(t, h.precision, h.rounding) : t;
};
Ue.toBinary = function(t, e) {
  return E9(this, 2, t, e);
};
Ue.toDecimalPlaces = Ue.toDP = function(t, e) {
  var r = this, n = r.constructor;
  return r = new n(r), t === void 0 ? r : (pi(t, 0, Xc), e === void 0 ? e = n.rounding : pi(e, 0, 8), mt(r, t + r.e + 1, e));
};
Ue.toExponential = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Yo(n, !0) : (pi(t, 0, Xc), e === void 0 ? e = i.rounding : pi(e, 0, 8), n = mt(new i(n), t + 1, e), r = Yo(n, !0, t + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ue.toFixed = function(t, e) {
  var r, n, i = this, s = i.constructor;
  return t === void 0 ? r = Yo(i) : (pi(t, 0, Xc), e === void 0 ? e = s.rounding : pi(e, 0, 8), n = mt(new s(i), t + i.e + 1, e), r = Yo(n, !1, t + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
Ue.toFraction = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, b = this, m = b.d, w = b.constructor;
  if (!m) return new w(b);
  if (c = r = new w(1), n = l = new w(0), e = new w(n), s = e.e = TV(m) - b.e - 1, o = s % wt, e.d[0] = An(10, o < 0 ? wt + o : o), t == null)
    t = s > 0 ? e : c;
  else {
    if (a = new w(t), !a.isInt() || a.lt(c)) throw Error(kh + a);
    t = a.gt(e) ? s > 0 ? e : c : a;
  }
  for (Mt = !1, a = new w(pn(m)), p = w.precision, w.precision = s = m.length * wt * 2; h = ar(a, e, 0, 1, 1), i = r.plus(h.times(n)), i.cmp(t) != 1; )
    r = n, n = i, i = c, c = l.plus(h.times(i)), l = i, i = e, e = a.minus(h.times(i)), a = i;
  return i = ar(t.minus(r), n, 0, 1, 1), l = l.plus(i.times(c)), r = r.plus(i.times(n)), l.s = c.s = b.s, d = ar(c, n, s, 1).minus(b).abs().cmp(ar(l, r, s, 1).minus(b).abs()) < 1 ? [c, n] : [l, r], w.precision = p, Mt = !0, d;
};
Ue.toHexadecimal = Ue.toHex = function(t, e) {
  return E9(this, 16, t, e);
};
Ue.toNearest = function(t, e) {
  var r = this, n = r.constructor;
  if (r = new n(r), t == null) {
    if (!r.d) return r;
    t = new n(1), e = n.rounding;
  } else {
    if (t = new n(t), e === void 0 ? e = n.rounding : pi(e, 0, 8), !r.d) return t.s ? r : t;
    if (!t.d)
      return t.s && (t.s = r.s), t;
  }
  return t.d[0] ? (Mt = !1, r = ar(r, t, 0, e, 1).times(t), Mt = !0, mt(r)) : (t.s = r.s, r = t), r;
};
Ue.toNumber = function() {
  return +this;
};
Ue.toOctal = function(t, e) {
  return E9(this, 8, t, e);
};
Ue.toPower = Ue.pow = function(t) {
  var e, r, n, i, s, o, a = this, l = a.constructor, c = +(t = new l(t));
  if (!a.d || !t.d || !a.d[0] || !t.d[0]) return new l(An(+a, c));
  if (a = new l(a), a.eq(1)) return a;
  if (n = l.precision, s = l.rounding, t.eq(1)) return mt(a, n, s);
  if (e = Bn(t.e / wt), e >= t.d.length - 1 && (r = c < 0 ? -c : c) <= c5e)
    return i = LV(l, a, r, n), t.s < 0 ? new l(1).div(i) : mt(i, n, s);
  if (o = a.s, o < 0) {
    if (e < t.d.length - 1) return new l(NaN);
    if (!(t.d[e] & 1) && (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = An(+a, c), e = r == 0 || !isFinite(r) ? Bn(c * (Math.log("0." + pn(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, e > l.maxE + 1 || e < l.minE - 1 ? new l(e > 0 ? o / 0 : 0) : (Mt = !1, l.rounding = a.s = 1, r = Math.min(12, (e + "").length), i = U4(t.times(Tl(a, n + r)), n), i.d && (i = mt(i, n + 5, 1), Y0(i.d, n, s) && (e = n + 10, i = mt(U4(t.times(Tl(a, e + r)), e), e + 5, 1), +pn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = mt(i, n + 1, 0)))), i.s = o, Mt = !0, l.rounding = s, mt(i, n, s));
};
Ue.toPrecision = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Yo(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (pi(t, 1, Xc), e === void 0 ? e = i.rounding : pi(e, 0, 8), n = mt(new i(n), t, e), r = Yo(n, t <= n.e || n.e <= i.toExpNeg, t)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ue.toSignificantDigits = Ue.toSD = function(t, e) {
  var r = this, n = r.constructor;
  return t === void 0 ? (t = n.precision, e = n.rounding) : (pi(t, 1, Xc), e === void 0 ? e = n.rounding : pi(e, 0, 8)), mt(new n(r), t, e);
};
Ue.toString = function() {
  var t = this, e = t.constructor, r = Yo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() && !t.isZero() ? "-" + r : r;
};
Ue.truncated = Ue.trunc = function() {
  return mt(new this.constructor(this), this.e + 1, 1);
};
Ue.valueOf = Ue.toJSON = function() {
  var t = this, e = t.constructor, r = Yo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() ? "-" + r : r;
};
function pn(t) {
  var e, r, n, i = t.length - 1, s = "", o = t[0];
  if (i > 0) {
    for (s += o, e = 1; e < i; e++)
      n = t[e] + "", r = wt - n.length, r && (s += xl(r)), s += n;
    o = t[e], n = o + "", r = wt - n.length, r && (s += xl(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function pi(t, e, r) {
  if (t !== ~~t || t < e || t > r)
    throw Error(kh + t);
}
function Y0(t, e, r, n) {
  var i, s, o, a;
  for (s = t[0]; s >= 10; s /= 10) --e;
  return --e < 0 ? (e += wt, i = 0) : (i = Math.ceil((e + 1) / wt), e %= wt), s = An(10, wt - e), a = t[i] % s | 0, n == null ? e < 3 ? (e == 0 ? a = a / 100 | 0 : e == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 100 | 0) == An(10, e - 2) - 1 || (a == s / 2 || a == 0) && (t[i + 1] / s / 100 | 0) == 0 : e < 4 ? (e == 0 ? a = a / 1e3 | 0 : e == 1 ? a = a / 100 | 0 : e == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 1e3 | 0) == An(10, e - 3) - 1, o;
}
function F1(t, e, r) {
  for (var n, i = [0], s, o = 0, a = t.length; o < a; ) {
    for (s = i.length; s--; ) i[s] *= e;
    for (i[0] += F4.indexOf(t.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function h5e(t, e) {
  var r, n, i = e.d.length;
  i < 32 ? (r = Math.ceil(i / 3), n = Math.pow(4, -r).toString()) : (r = 16, n = "2.3283064365386962890625e-10"), t.precision += r, e = ld(t, 1, e.times(n), new t(1));
  for (var s = r; s--; ) {
    var o = e.times(e);
    e = o.times(o).minus(o).times(8).plus(1);
  }
  return t.precision -= r, e;
}
var ar = /* @__PURE__ */ function() {
  function t(n, i, s) {
    var o, a = 0, l = n.length;
    for (n = n.slice(); l--; )
      o = n[l] * i + a, n[l] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function e(n, i, s, o) {
    var a, l;
    if (s != o)
      l = s > o ? 1 : -1;
    else
      for (a = l = 0; a < s; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, o, a, l) {
    var c, p, h, d, b, m, w, f, E, A, x, g, v, k, S, R, L, F, z, j, ee = n.constructor, X = n.s == i.s ? 1 : -1, ie = n.d, ce = i.d;
    if (!ie || !ie[0] || !ce || !ce[0])
      return new ee(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (ie ? ce && ie[0] == ce[0] : !ce) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          ie && ie[0] == 0 || !ce ? X * 0 : X / 0
        )
      );
    for (l ? (b = 1, p = n.e - i.e) : (l = Gs, b = wt, p = Bn(n.e / b) - Bn(i.e / b)), z = ce.length, L = ie.length, E = new ee(X), A = E.d = [], h = 0; ce[h] == (ie[h] || 0); h++) ;
    if (ce[h] > (ie[h] || 0) && p--, s == null ? (k = s = ee.precision, o = ee.rounding) : a ? k = s + (n.e - i.e) + 1 : k = s, k < 0)
      A.push(1), m = !0;
    else {
      if (k = k / b + 2 | 0, h = 0, z == 1) {
        for (d = 0, ce = ce[0], k++; (h < L || d) && k--; h++)
          S = d * l + (ie[h] || 0), A[h] = S / ce | 0, d = S % ce | 0;
        m = d || h < L;
      } else {
        for (d = l / (ce[0] + 1) | 0, d > 1 && (ce = t(ce, d, l), ie = t(ie, d, l), z = ce.length, L = ie.length), R = z, x = ie.slice(0, z), g = x.length; g < z; ) x[g++] = 0;
        j = ce.slice(), j.unshift(0), F = ce[0], ce[1] >= l / 2 && ++F;
        do
          d = 0, c = e(ce, x, z, g), c < 0 ? (v = x[0], z != g && (v = v * l + (x[1] || 0)), d = v / F | 0, d > 1 ? (d >= l && (d = l - 1), w = t(ce, d, l), f = w.length, g = x.length, c = e(w, x, f, g), c == 1 && (d--, r(w, z < f ? j : ce, f, l))) : (d == 0 && (c = d = 1), w = ce.slice()), f = w.length, f < g && w.unshift(0), r(x, w, g, l), c == -1 && (g = x.length, c = e(ce, x, z, g), c < 1 && (d++, r(x, z < g ? j : ce, g, l))), g = x.length) : c === 0 && (d++, x = [0]), A[h++] = d, c && x[0] ? x[g++] = ie[R] || 0 : (x = [ie[R]], g = 1);
        while ((R++ < L || x[0] !== void 0) && k--);
        m = x[0] !== void 0;
      }
      A[0] || A.shift();
    }
    if (b == 1)
      E.e = p, PV = m;
    else {
      for (h = 1, d = A[0]; d >= 10; d /= 10) h++;
      E.e = h + p * b - 1, mt(E, a ? s + E.e + 1 : s, o, m);
    }
    return E;
  };
}();
function mt(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, b = t.constructor;
  e: if (e != null) {
    if (h = t.d, !h) return t;
    for (i = 1, a = h[0]; a >= 10; a /= 10) i++;
    if (s = e - i, s < 0)
      s += wt, o = e, p = h[d = 0], l = p / An(10, i - o - 1) % 10 | 0;
    else if (d = Math.ceil((s + 1) / wt), a = h.length, d >= a)
      if (n) {
        for (; a++ <= d; ) h.push(0);
        p = l = 0, i = 1, s %= wt, o = s - wt + 1;
      } else
        break e;
    else {
      for (p = a = h[d], i = 1; a >= 10; a /= 10) i++;
      s %= wt, o = s - wt + i, l = o < 0 ? 0 : p / An(10, i - o - 1) % 10 | 0;
    }
    if (n = n || e < 0 || h[d + 1] !== void 0 || (o < 0 ? p : p % An(10, i - o - 1)), c = r < 4 ? (l || n) && (r == 0 || r == (t.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? p / An(10, i - o) : 0 : h[d - 1]) % 10 & 1 || r == (t.s < 0 ? 8 : 7)), e < 1 || !h[0])
      return h.length = 0, c ? (e -= t.e + 1, h[0] = An(10, (wt - e % wt) % wt), t.e = -e || 0) : h[0] = t.e = 0, t;
    if (s == 0 ? (h.length = d, a = 1, d--) : (h.length = d + 1, a = An(10, wt - s), h[d] = o > 0 ? (p / An(10, i - o) % An(10, o) | 0) * a : 0), c)
      for (; ; )
        if (d == 0) {
          for (s = 1, o = h[0]; o >= 10; o /= 10) s++;
          for (o = h[0] += a, a = 1; o >= 10; o /= 10) a++;
          s != a && (t.e++, h[0] == Gs && (h[0] = 1));
          break;
        } else {
          if (h[d] += a, h[d] != Gs) break;
          h[d--] = 0, a = 1;
        }
    for (s = h.length; h[--s] === 0; ) h.pop();
  }
  return Mt && (t.e > b.maxE ? (t.d = null, t.e = NaN) : t.e < b.minE && (t.e = 0, t.d = [0])), t;
}
function Yo(t, e, r) {
  if (!t.isFinite()) return NV(t);
  var n, i = t.e, s = pn(t.d), o = s.length;
  return e ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + xl(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (t.e < 0 ? "e" : "e+") + t.e) : i < 0 ? (s = "0." + xl(-i - 1) + s, r && (n = r - o) > 0 && (s += xl(n))) : i >= o ? (s += xl(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + xl(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += xl(n))), s;
}
function Uv(t, e) {
  var r = t[0];
  for (e *= wt; r >= 10; r /= 10) e++;
  return e;
}
function y2(t, e, r) {
  if (e > u5e)
    throw Mt = !0, r && (t.precision = r), Error(RV);
  return mt(new t(g2), e, 1, !0);
}
function Ns(t, e, r) {
  if (e > V4) throw Error(RV);
  return mt(new t(m2), e, r, !0);
}
function TV(t) {
  var e = t.length - 1, r = e * wt + 1;
  if (e = t[e], e) {
    for (; e % 10 == 0; e /= 10) r--;
    for (e = t[0]; e >= 10; e /= 10) r++;
  }
  return r;
}
function xl(t) {
  for (var e = ""; t--; ) e += "0";
  return e;
}
function LV(t, e, r, n) {
  var i, s = new t(1), o = Math.ceil(n / wt + 4);
  for (Mt = !1; ; ) {
    if (r % 2 && (s = s.times(e), iR(s.d, o) && (i = !0)), r = Bn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    e = e.times(e), iR(e.d, o);
  }
  return Mt = !0, s;
}
function rR(t) {
  return t.d[t.d.length - 1] & 1;
}
function MV(t, e, r) {
  for (var n, i = new t(e[0]), s = 0; ++s < e.length; )
    if (n = new t(e[s]), n.s)
      i[r](n) && (i = n);
    else {
      i = n;
      break;
    }
  return i;
}
function U4(t, e) {
  var r, n, i, s, o, a, l, c = 0, p = 0, h = 0, d = t.constructor, b = d.rounding, m = d.precision;
  if (!t.d || !t.d[0] || t.e > 17)
    return new d(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
  for (e == null ? (Mt = !1, l = m) : l = e, a = new d(0.03125); t.e > -2; )
    t = t.times(a), h += 5;
  for (n = Math.log(An(2, h)) / Math.LN10 * 2 + 5 | 0, l += n, r = s = o = new d(1), d.precision = l; ; ) {
    if (s = mt(s.times(t), l, 1), r = r.times(++p), a = o.plus(ar(s, r, l, 1)), pn(a.d).slice(0, l) === pn(o.d).slice(0, l)) {
      for (i = h; i--; ) o = mt(o.times(o), l, 1);
      if (e == null)
        if (c < 3 && Y0(o.d, l - n, b, c))
          d.precision = l += 10, r = s = a = new d(1), p = 0, c++;
        else
          return mt(o, d.precision = m, b, Mt = !0);
      else
        return d.precision = m, o;
    }
    o = a;
  }
}
function Tl(t, e) {
  var r, n, i, s, o, a, l, c, p, h, d, b = 1, m = 10, w = t, f = w.d, E = w.constructor, A = E.rounding, x = E.precision;
  if (w.s < 0 || !f || !f[0] || !w.e && f[0] == 1 && f.length == 1)
    return new E(f && !f[0] ? -1 / 0 : w.s != 1 ? NaN : f ? 0 : w);
  if (e == null ? (Mt = !1, p = x) : p = e, E.precision = p += m, r = pn(f), n = r.charAt(0), Math.abs(s = w.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      w = w.times(t), r = pn(w.d), n = r.charAt(0), b++;
    s = w.e, n > 1 ? (w = new E("0." + r), s++) : w = new E(n + "." + r.slice(1));
  } else
    return c = y2(E, p + 2, x).times(s + ""), w = Tl(new E(n + "." + r.slice(1)), p - m).plus(c), E.precision = x, e == null ? mt(w, x, A, Mt = !0) : w;
  for (h = w, l = o = w = ar(w.minus(1), w.plus(1), p, 1), d = mt(w.times(w), p, 1), i = 3; ; ) {
    if (o = mt(o.times(d), p, 1), c = l.plus(ar(o, new E(i), p, 1)), pn(c.d).slice(0, p) === pn(l.d).slice(0, p))
      if (l = l.times(2), s !== 0 && (l = l.plus(y2(E, p + 2, x).times(s + ""))), l = ar(l, new E(b), p, 1), e == null)
        if (Y0(l.d, p - m, A, a))
          E.precision = p += m, c = o = w = ar(h.minus(1), h.plus(1), p, 1), d = mt(w.times(w), p, 1), i = a = 1;
        else
          return mt(l, E.precision = x, A, Mt = !0);
      else
        return E.precision = x, l;
    l = c, i += 2;
  }
}
function NV(t) {
  return String(t.s * t.s / 0);
}
function nR(t, e) {
  var r, n, i;
  for ((r = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (r = e.length), n = 0; e.charCodeAt(n) === 48; n++) ;
  for (i = e.length; e.charCodeAt(i - 1) === 48; --i) ;
  if (e = e.slice(n, i), e) {
    if (i -= n, t.e = r = r - n - 1, t.d = [], n = (r + 1) % wt, r < 0 && (n += wt), n < i) {
      for (n && t.d.push(+e.slice(0, n)), i -= wt; n < i; ) t.d.push(+e.slice(n, n += wt));
      e = e.slice(n), n = wt - e.length;
    } else
      n -= i;
    for (; n--; ) e += "0";
    t.d.push(+e), Mt && (t.e > t.constructor.maxE ? (t.d = null, t.e = NaN) : t.e < t.constructor.minE && (t.e = 0, t.d = [0]));
  } else
    t.e = 0, t.d = [0];
  return t;
}
function p5e(t, e) {
  var r, n, i, s, o, a, l, c, p;
  if (e === "Infinity" || e === "NaN")
    return +e || (t.s = NaN), t.e = NaN, t.d = null, t;
  if (o5e.test(e))
    r = 16, e = e.toLowerCase();
  else if (s5e.test(e))
    r = 2;
  else if (a5e.test(e))
    r = 8;
  else
    throw Error(kh + e);
  for (s = e.search(/p/i), s > 0 ? (l = +e.slice(s + 1), e = e.substring(2, s)) : e = e.slice(2), s = e.indexOf("."), o = s >= 0, n = t.constructor, o && (e = e.replace(".", ""), a = e.length, s = a - s, i = LV(n, new n(r), s, s * 2)), c = F1(e, r, Gs), p = c.length - 1, s = p; c[s] === 0; --s) c.pop();
  return s < 0 ? new n(t.s * 0) : (t.e = Uv(c, p), t.d = c, Mt = !1, o && (t = ar(t, i, a * 4)), l && (t = t.times(Math.abs(l) < 54 ? Math.pow(2, l) : Hv.pow(2, l))), Mt = !0, t);
}
function d5e(t, e) {
  var r, n = e.d.length;
  if (n < 3) return ld(t, 2, e, e);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, e = e.times(Math.pow(5, -r)), e = ld(t, 2, e, e);
  for (var i, s = new t(5), o = new t(16), a = new t(20); r--; )
    i = e.times(e), e = e.times(s.plus(i.times(o.times(i).minus(a))));
  return e;
}
function ld(t, e, r, n, i) {
  var s, o, a, l, c = t.precision, p = Math.ceil(c / wt);
  for (Mt = !1, l = r.times(r), a = new t(n); ; ) {
    if (o = ar(a.times(l), new t(e++ * e++), c, 1), a = i ? n.plus(o) : n.minus(o), n = ar(o.times(l), new t(e++ * e++), c, 1), o = a.plus(n), o.d[p] !== void 0) {
      for (s = p; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = n, n = o, o = s;
  }
  return Mt = !0, o.d.length = p + 1, o;
}
function DV(t, e) {
  var r, n = e.s < 0, i = Ns(t, t.precision, 1), s = i.times(0.5);
  if (e = e.abs(), e.lte(s))
    return ma = n ? 4 : 1, e;
  if (r = e.divToInt(i), r.isZero())
    ma = n ? 3 : 2;
  else {
    if (e = e.minus(r.times(i)), e.lte(s))
      return ma = rR(r) ? n ? 2 : 3 : n ? 4 : 1, e;
    ma = rR(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return e.minus(i).abs();
}
function E9(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, b = t.constructor, m = r !== void 0;
  if (m ? (pi(r, 1, Xc), n === void 0 ? n = b.rounding : pi(n, 0, 8)) : (r = b.precision, n = b.rounding), !t.isFinite())
    p = NV(t);
  else {
    for (p = Yo(t), o = p.indexOf("."), m ? (i = 2, e == 16 ? r = r * 4 - 3 : e == 8 && (r = r * 3 - 2)) : i = e, o >= 0 && (p = p.replace(".", ""), d = new b(1), d.e = p.length - o, d.d = F1(Yo(d), 10, i), d.e = d.d.length), h = F1(p, 10, i), s = l = h.length; h[--l] == 0; ) h.pop();
    if (!h[0])
      p = m ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (t = new b(t), t.d = h, t.e = s, t = ar(t, d, r, n, 0, i), h = t.d, s = t.e, c = PV), o = h[r], a = i / 2, c = c || h[r + 1] !== void 0, c = n < 4 ? (o !== void 0 || c) && (n === 0 || n === (t.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || c || n === 6 && h[r - 1] & 1 || n === (t.s < 0 ? 8 : 7)), h.length = r, c)
        for (; ++h[--r] > i - 1; )
          h[r] = 0, r || (++s, h.unshift(1));
      for (l = h.length; !h[l - 1]; --l) ;
      for (o = 0, p = ""; o < l; o++) p += F4.charAt(h[o]);
      if (m) {
        if (l > 1)
          if (e == 16 || e == 8) {
            for (o = e == 16 ? 4 : 3, --l; l % o; l++) p += "0";
            for (h = F1(p, i, e), l = h.length; !h[l - 1]; --l) ;
            for (o = 1, p = "1."; o < l; o++) p += F4.charAt(h[o]);
          } else
            p = p.charAt(0) + "." + p.slice(1);
        p = p + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) p = "0" + p;
        p = "0." + p;
      } else if (++s > l) for (s -= l; s--; ) p += "0";
      else s < l && (p = p.slice(0, s) + "." + p.slice(s));
    }
    p = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + p;
  }
  return t.s < 0 ? "-" + p : p;
}
function iR(t, e) {
  if (t.length > e)
    return t.length = e, !0;
}
function f5e(t) {
  return new this(t).abs();
}
function g5e(t) {
  return new this(t).acos();
}
function m5e(t) {
  return new this(t).acosh();
}
function y5e(t, e) {
  return new this(t).plus(e);
}
function b5e(t) {
  return new this(t).asin();
}
function v5e(t) {
  return new this(t).asinh();
}
function w5e(t) {
  return new this(t).atan();
}
function x5e(t) {
  return new this(t).atanh();
}
function E5e(t, e) {
  t = new this(t), e = new this(e);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !t.s || !e.s ? r = new this(NaN) : !t.d && !e.d ? (r = Ns(this, s, 1).times(e.s > 0 ? 0.25 : 0.75), r.s = t.s) : !e.d || t.isZero() ? (r = e.s < 0 ? Ns(this, n, i) : new this(0), r.s = t.s) : !t.d || e.isZero() ? (r = Ns(this, s, 1).times(0.5), r.s = t.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(ar(t, e, s, 1)), e = Ns(this, s, 1), this.precision = n, this.rounding = i, r = t.s < 0 ? r.minus(e) : r.plus(e)) : r = this.atan(ar(t, e, s, 1)), r;
}
function S5e(t) {
  return new this(t).cbrt();
}
function A5e(t) {
  return mt(t = new this(t), t.e + 1, 2);
}
function k5e(t) {
  if (!t || typeof t != "object") throw Error(Vv + "Object expected");
  var e, r, n, i = t.defaults === !0, s = [
    "precision",
    1,
    Xc,
    "rounding",
    0,
    8,
    "toExpNeg",
    -9e15,
    0,
    "toExpPos",
    0,
    B4,
    "maxE",
    0,
    B4,
    "minE",
    -9e15,
    0,
    "modulo",
    0,
    9
  ];
  for (e = 0; e < s.length; e += 3)
    if (r = s[e], i && (this[r] = z4[r]), (n = t[r]) !== void 0)
      if (Bn(n) === n && n >= s[e + 1] && n <= s[e + 2]) this[r] = n;
      else throw Error(kh + r + ": " + n);
  if (r = "crypto", i && (this[r] = z4[r]), (n = t[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(OV);
      else
        this[r] = !1;
    else
      throw Error(kh + r + ": " + n);
  return this;
}
function _5e(t) {
  return new this(t).cos();
}
function C5e(t) {
  return new this(t).cosh();
}
function $V(t) {
  var e, r, n;
  function i(s) {
    var o, a, l, c = this;
    if (!(c instanceof i)) return new i(s);
    if (c.constructor = i, s instanceof i) {
      c.s = s.s, c.e = s.e, c.d = (s = s.d) ? s.slice() : s;
      return;
    }
    if (l = typeof s, l === "number") {
      if (s === 0) {
        c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        c.e = o, c.d = [s];
        return;
      } else if (s * 0 !== 0) {
        s || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return nR(c, s.toString());
    } else if (l !== "string")
      throw Error(kh + s);
    return s.charCodeAt(0) === 45 ? (s = s.slice(1), c.s = -1) : c.s = 1, l5e.test(s) ? nR(c, s) : p5e(c, s);
  }
  if (i.prototype = Ue, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = k5e, i.clone = $V, i.isDecimal = T5e, i.abs = f5e, i.acos = g5e, i.acosh = m5e, i.add = y5e, i.asin = b5e, i.asinh = v5e, i.atan = w5e, i.atanh = x5e, i.atan2 = E5e, i.cbrt = S5e, i.ceil = A5e, i.cos = _5e, i.cosh = C5e, i.div = I5e, i.exp = P5e, i.floor = R5e, i.hypot = O5e, i.ln = L5e, i.log = M5e, i.log10 = D5e, i.log2 = N5e, i.max = $5e, i.min = j5e, i.mod = B5e, i.mul = F5e, i.pow = z5e, i.random = V5e, i.round = U5e, i.sign = H5e, i.sin = G5e, i.sinh = W5e, i.sqrt = q5e, i.sub = Q5e, i.tan = K5e, i.tanh = Y5e, i.trunc = Z5e, t === void 0 && (t = {}), t && t.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; ) t.hasOwnProperty(r = n[e++]) || (t[r] = this[r]);
  return i.config(t), i;
}
function I5e(t, e) {
  return new this(t).div(e);
}
function P5e(t) {
  return new this(t).exp();
}
function R5e(t) {
  return mt(t = new this(t), t.e + 1, 3);
}
function O5e() {
  var t, e, r = new this(0);
  for (Mt = !1, t = 0; t < arguments.length; )
    if (e = new this(arguments[t++]), e.d)
      r.d && (r = r.plus(e.times(e)));
    else {
      if (e.s)
        return Mt = !0, new this(1 / 0);
      r = e;
    }
  return Mt = !0, r.sqrt();
}
function T5e(t) {
  return t instanceof Hv || t && t.name === "[object Decimal]" || !1;
}
function L5e(t) {
  return new this(t).ln();
}
function M5e(t, e) {
  return new this(t).log(e);
}
function N5e(t) {
  return new this(t).log(2);
}
function D5e(t) {
  return new this(t).log(10);
}
function $5e() {
  return MV(this, arguments, "lt");
}
function j5e() {
  return MV(this, arguments, "gt");
}
function B5e(t, e) {
  return new this(t).mod(e);
}
function F5e(t, e) {
  return new this(t).mul(e);
}
function z5e(t, e) {
  return new this(t).pow(e);
}
function V5e(t) {
  var e, r, n, i, s = 0, o = new this(1), a = [];
  if (t === void 0 ? t = this.precision : pi(t, 1, Xc), n = Math.ceil(t / wt), this.crypto)
    if (crypto.getRandomValues)
      for (e = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = e[s], i >= 429e7 ? e[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (e = crypto.randomBytes(n *= 4); s < n; )
        i = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((e[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(OV);
  else for (; s < n; ) a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], t %= wt, n && t && (i = An(10, wt - t), a[s] = (n / i | 0) * i); a[s] === 0; s--) a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= wt) a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
    n < wt && (r -= wt - n);
  }
  return o.e = r, o.d = a, o;
}
function U5e(t) {
  return mt(t = new this(t), t.e + 1, this.rounding);
}
function H5e(t) {
  return t = new this(t), t.d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN;
}
function G5e(t) {
  return new this(t).sin();
}
function W5e(t) {
  return new this(t).sinh();
}
function q5e(t) {
  return new this(t).sqrt();
}
function Q5e(t, e) {
  return new this(t).sub(e);
}
function K5e(t) {
  return new this(t).tan();
}
function Y5e(t) {
  return new this(t).tanh();
}
function Z5e(t) {
  return mt(t = new this(t), t.e + 1, 1);
}
var Hv = $V(z4);
g2 = new Hv(g2);
m2 = new Hv(m2);
var H4 = /* @__PURE__ */ ((t) => (t[t.UP = 1] = "UP", t[t.NONE = 0] = "NONE", t[t.DOWN = -1] = "DOWN", t))(H4 || {});
const G4 = {
  dollar: N1.DOLLAR,
  "U.S. dollar": N1.US_DOLLAR,
  "South Korean won": N1.SK_WON
}, b2 = {
  year: { ...xe.noun("year"), subtype: "unit" },
  quarter: { ...xe.noun("quarter"), subtype: "unit" }
}, W4 = {
  "0.01": { type: "simple-category", subtype: "scale", noun: xe.en("percent") },
  1: { type: "simple-category", subtype: "scale", noun: xe.en("number") },
  1e3: { type: "simple-category", subtype: "scale", noun: xe.en("thousand") },
  1e6: { type: "simple-category", subtype: "scale", noun: xe.en("million") },
  1e9: { type: "simple-category", subtype: "scale", noun: xe.en("billion") },
  1e12: { type: "simple-category", subtype: "scale", noun: xe.en("trillion") }
};
function ya(t, e) {
  if (e in b2)
    return {
      type: "plain-date-time",
      datetime: t,
      unit: e
    };
  if (e === "point")
    return xe.quantValue(t, Ol[1], xe.unit("point"));
  throw new Error(`Undefined X unit ${e}`);
}
class Gv {
  constructor(e, r, n, i) {
    this.start = e, this.end = r, this.unit = n, this.approx = i;
  }
  path() {
    return this.approx ? {
      type: "point-location",
      direction: Oe.BETWEEN,
      point: xe.and(ya(this.start, this.unit), ya(this.end, this.unit))
    } : xe.path(
      ya(this.start, this.unit),
      ya(this.end, this.unit)
    );
  }
}
function S9(t, e) {
  return t instanceof Gv ? t.path() : xe.in_(ya(t, e));
}
function J5e(t, e, r) {
  const n = t.indepBox.value, i = e.indepBox.value;
  return n.equals(i.subtract(r));
}
function X5e(t, e, r) {
  return Sre(
    t,
    (n, i) => J5e(n, i, e)
  ).map((n) => {
    if (n instanceof Lx) {
      if (n.points.length < 2)
        throw new Qr("Internal: Ranges must have 2 or more points.");
      return new jV(n.points, r);
    }
    return n;
  });
}
class jV {
  constructor(e, r, n) {
    Vt(this, "start"), Vt(this, "end"), Vt(this, "startTime"), Vt(this, "endTime"), this.points = e, this.unit = r, this.approx = n, this.start = this.points[0], this.end = this.points.at(-1), this.startTime = this.start.indepBox.value, this.endTime = this.end.indepBox.value;
  }
  path() {
    return this.toTimeRange().path();
  }
  toTimeRange() {
    return new Gv(this.startTime, this.endTime, this.unit, this.approx);
  }
  getNavcode() {
    return this.points.reduce((e, r) => e + `-${r.datapointIndex}`, `datapoint-${this.start.seriesKey}`);
  }
}
class eSe {
  constructor(e, r, n, i, s, o) {
    this.startPoint = e, this.endPoint = r, this.timeUnit = n, this.startValue = i, this.endValue = s, this.depUnits = o;
  }
  path() {
    const e = this.startPoint.indepBox.value, r = this.endPoint.indepBox.value, n = Jt(
      v2(e, this.timeUnit, this.startValue, this.depUnits),
      this.startPoint.getNavcode()
    ), i = Jt(
      v2(r, this.timeUnit, this.endValue, this.depUnits),
      this.endPoint.getNavcode()
    );
    return {
      type: "path-location",
      start: n,
      end: i,
      startTag: z0(this.startPoint.getNavcode()),
      endTag: z0(this.endPoint.getNavcode())
    };
  }
}
function BV(t, e) {
  let r = null, n = null;
  if (e !== "number") {
    if (e !== void 0 && e in G4)
      n = G4[e];
    else if (e !== void 0 && e in b2)
      r = b2[e];
    else if (e === "point")
      r = Oe.POINT;
    else if (e !== void 0) throw new Error(`[ParaSummary]: Undefined dependent unit ${e}`);
  }
  let i = xe.numberEntity(
    t.number,
    W4[t.scale]
  );
  return t.roundingDirection === H4.UP && (i.quantifier = Oe.ALMOST), t.roundingDirection === H4.DOWN && (i.quantifier = Oe.MORE_THAN), n !== null ? i = {
    ...i,
    type: "simple-entity",
    subtype: "money-value",
    detType: "bare",
    category: n
  } : r !== null && (i = {
    ...i,
    type: "simple-entity",
    subtype: "quant-value",
    detType: "indefinite",
    category: r
  }), i;
}
function v2(t, e, r, n) {
  const i = S9(t, e), s = BV(r, n);
  return s.mods = [i], s;
}
function FV(t, e) {
  return t.record.labelValue === null ? new Gv(
    qf(t.record.beforeValue),
    qf(t.record.afterValue),
    e,
    !0
  ) : qf(t.record.labelValue);
}
function tSe(t, e) {
  return S9(FV(t, e), e);
}
function rSe(t, e, r, n) {
  return xe.at(v2(
    FV(t, e),
    e,
    r,
    n.units
  ));
}
function is(t, e) {
  const r = t.messageSeqs[e].start, n = t.messageSeqs[e].end;
  return `sequence-${t.seriesKey}-${r}-${n}`;
}
const $f = Oe.FALL, e1 = Oe.RISE, t1 = { ...Oe.PERIOD, mods: [Oe.STABLE] };
function nSe(t) {
  return t === "Rise" || t === "Fall" || t === "Stable";
}
function iSe(t) {
  return t === "BigJump" || t === "BigFall";
}
function sSe(t) {
  return t === "ReversalToRise" || t === "ReversalToFall";
}
function oSe(t) {
  return t === "PossibleReversalToRise" || t === "PossibleReversalToFall";
}
function aSe(t) {
  return t === "EmergingRise" || t === "EmergingFall";
}
function lSe(t) {
  return t === "PossibleEmergingRise" || t === "PossibleEmergingFall";
}
function cSe(t) {
  return t === "RiseToStable" || t === "FallToStable";
}
function uSe(t) {
  return t === "PossibleRiseToStable" || t === "PossibleFallToStable";
}
function hSe(t) {
  return sSe(t) || aSe(t) || cSe(t);
}
function pSe(t) {
  return oSe(t) || lSe(t) || uSe(t);
}
function dSe(t) {
  return t === "Rebound" || t === "TemporaryJump";
}
function fSe(t) {
  return t === "PossibleRebound" || t === "PossibleTemporaryJump";
}
const gSe = {
  Rise: { ...Oe.RISE, force: "participle" },
  Fall: { ...Oe.FALL, force: "participle" },
  Stable: Oe.STABLE
};
function mSe(t, e, r) {
  const n = { ...Oe.TREND, mods: [Oe.OVERALL, gSe[t]] };
  let i = xe.a("singular", n);
  return r && (i = Jt(i, is(e, 0))), i;
}
const ySe = {
  BigJump: Oe.JUMP,
  BigFall: $f
};
function bSe(t, e, r) {
  const n = {
    ...ySe[t],
    mods: [Oe.LARGE]
  };
  let i = xe.a("singular", n);
  return r && (i = Jt(i, is(e, 0))), i;
}
const vSe = {
  ReversalToRise: [$f, e1],
  ReversalToFall: [e1, $f],
  EmergingRise: [t1, e1],
  EmergingFall: [t1, $f],
  RiseToStable: [e1, t1],
  FallToStable: [$f, t1]
};
function sR(t, e, r, n) {
  const [i, s] = vSe[t], o = [xe.by(xe.a("singular", s))];
  n && o.unshift(Oe.POSSIBLY);
  let a = {
    type: "relative-clause",
    relativizer: "zero",
    clause: {
      type: "simple-clause",
      pred: null,
      object: { ...Oe.FOLLOWED, mods: o }
    },
    restrictive: !1
  }, l = Oe.HAS, c = xe.a("singular", i);
  return r && (a = Jt(a, is(e, 1)), l = Jt(l, is(e, 0)), c = Jt(c, is(e, 0))), {
    type: "simple-clause",
    pred: l,
    object: c,
    mods: [a]
  };
}
const jf = {
  Rebound: {
    first: { ...Oe.RISE, force: "participle" },
    second: {
      type: "simple-clause",
      pred: { ...Oe.FALL_pred, tense: "present-participle" },
      object: null
    },
    third: {
      type: "simple-clause",
      pred: { ...Oe.REBOUND, tense: "present-participle" },
      object: null,
      mods: [Oe.BACK_UP]
    }
  },
  TemporaryJump: {
    first: { ...Oe.FALL, force: "participle" },
    second: {
      type: "simple-clause",
      pred: { ...Oe.RISE_pred, tense: "present-participle" },
      object: null,
      mods: [Oe.TEMPORARILY]
    },
    third: {
      type: "simple-clause",
      pred: { ...Oe.FALL_pred, tense: "present-participle" },
      object: null,
      mods: [Oe.AGAIN]
    }
  }
}, wSe = {
  Rebound: {
    ...jf.Rebound,
    third: {
      ...jf.Rebound.third,
      mods: [Oe.POSSIBLY, Oe.BACK_UP]
    }
  },
  TemporaryJump: {
    ...jf.TemporaryJump,
    third: {
      ...jf.TemporaryJump.third,
      mods: [Oe.POSSIBLY, Oe.AGAIN]
    }
  }
};
function oR(t, e, r, n) {
  const i = n ? wSe[t] : jf[t];
  let s = {
    type: "simple-clause",
    pred: Oe.HAS,
    object: xe.a("singular", { ...Oe.TREND, mods: [i.first] })
  };
  r && (s = Jt(s, is(e, 0)));
  const o = r ? Jt(Oe.BEFORE, is(e, 1)) : Oe.BEFORE, a = r ? Jt(i.second, is(e, 1)) : i.second, l = {
    ...xe.coord(o, s, a),
    firstComma: !0
  }, c = r ? Jt(Oe.AND_THEN, is(e, 2)) : Oe.AND_THEN, p = r ? Jt(i.third, is(e, 2)) : i.third;
  return xe.coord(c, l, p);
}
function aR(t, e = !0) {
  const r = t.message;
  if (dSe(r))
    return oR(r, t, e);
  if (fSe(r))
    return oR(r.substring(8), t, e, !0);
  if (hSe(r))
    return sR(r, t, e);
  if (pSe(r))
    return sR(r.substring(8), t, e, !0);
  let n;
  return nSe(r) ? n = mSe(r, t, e) : iSe(r) && (n = bSe(r, t, e)), {
    type: "simple-clause",
    pred: e ? Jt(Oe.HAS, is(t, 0)) : Oe.HAS,
    object: n
  };
}
const zV = ["entity", "items", "locale"], xSe = {
  entity: "genus",
  items: "genus",
  locale: "genus"
};
function Z3(t, e) {
  const r = new Set(
    t.series.map((n) => t.getSeriesTheme(n.key)[e]).filter((n) => n !== void 0)
  );
  return r.size === 1 ? "genus" : r.size === t.numSeries ? "differentia" : "neither";
}
function VV(t) {
  const e = {
    entity: Z3(t, "entity"),
    items: Z3(t, "items"),
    locale: Z3(t, "locale")
  };
  for (const r in e) {
    const n = t.getChartTheme();
    n && r in n && e[r] === "neither" && (e[r] = "genus");
  }
  return e;
}
function Em(t) {
  return Array.isArray(t) ? xe.and(...t.map(xe.noun)) : xe.noun(t);
}
function ESe(t, e, r) {
  if (t[e] === void 0 || r === "neither")
    return null;
  const n = r === "differentia", i = {
    type: "simple-entity",
    detType: {
      entity: n ? "indefinite" : "proper",
      items: "indefinite",
      locale: n ? "indefinite" : "proper"
    }[e],
    number: n || e === "items" ? "plural" : "singular",
    category: Em(t[e])
  };
  return n && (i.mods = [Oe.DIFFERENT]), i;
}
function SSe(t, e, r) {
  if (r !== "differentia")
    return null;
  const n = t.series.map((s) => {
    const o = t.getSeriesTheme(s.key)[e];
    return Jt(
      Em(o),
      `series-${s.key}`
    );
  });
  let i;
  return Array.isArray(n) ? (i = xe.and(...n), i.conn = Jt(i.conn, `series-${t.series.at(-1).key}`)) : i = n, {
    type: "simple-entity",
    detType: "bare",
    number: e === "items" ? "plural" : "singular",
    category: i
  };
}
function ASe(t, e, r) {
  let n = xSe;
  r && (n = VV(r));
  const i = zV.flatMap((s) => {
    const o = ESe(e, s, n[s]);
    return o === null ? [] : [s === "locale" ? { ...xe.in_(o), inessential: !0 } : xe.of(o)];
  });
  t.mods.push(...i);
}
function kSe(t, e) {
  var r;
  const n = VV(e), i = zV.flatMap((o) => {
    const a = SSe(e, o, n[o]);
    if (a === null)
      return [];
    const l = [];
    if (o === "locale") {
      const c = xe.in_(a);
      c.direction = Jt(c.direction, `series-${e[0].key}`), l.push(c);
    } else {
      const c = xe.of(a);
      c.auxTag = z0(`series-${e[0].key}`), l.push(c);
    }
    return l;
  });
  t.mods.push(...i);
  const s = (r = e.getChartTheme()) == null ? void 0 : r.aggregate;
  if (s) {
    const o = Array.isArray(s) ? s : [s];
    t.mods.push(...o.map((a) => xe.adj(a)));
  }
}
function _Se(t, e) {
  return {
    type: "simple-entity",
    detType: "definite",
    number: e ? "plural" : "singular",
    category: Em(t.baseQuantity),
    mods: []
  };
}
function CSe(t, e) {
  const r = Em(t.baseQuantity);
  return {
    type: "simple-entity",
    detType: "definite",
    number: e || Array.isArray(t.baseQuantity) ? "plural" : "singular",
    category: Oe.RATE,
    mods: [r]
  };
}
function ISe(t, e) {
  return {
    type: "simple-entity",
    detType: "definite",
    number: e || Array.isArray(t.baseQuantity) ? "plural" : "singular",
    category: Ol[1]
  };
}
function PSe(t, e) {
  let r;
  return Array.isArray(t.baseQuantity) ? r = xe.and(...t.baseQuantity.map((n) => xe.a("plural", xe.noun(n)))) : r = xe.a("plural", xe.noun(t.baseQuantity)), { ...ISe(t, e), mods: [xe.of(r)] };
}
function RSe(t, e) {
  const r = Em(t.baseQuantity);
  return {
    type: "simple-entity",
    detType: "definite",
    number: "singular",
    category: Oe.DISTRIBUTION,
    mods: [xe.of(xe.the("singular", r))]
  };
}
function A9(t, e) {
  switch (t.baseKind) {
    case "dimensioned":
      return _Se(t, e);
    case "rate":
      return CSe(t, e);
    case "number":
      return PSe(t, e);
    case "proportion":
      return RSe(t);
  }
}
function OSe(t) {
  return t.baseKind === "proportion" ? {
    type: "simple-entity",
    detType: "definite",
    //'bare',
    number: "singular",
    category: Oe.DISTRIBUTION
    //D.PERCENTAGE
  } : {
    ...A9(t, !1)
    /*detType: 'bare'*/
  };
}
function k9(t, e) {
  const r = A9(t, e !== void 0);
  if (ASe(r, t, e), t.aggregate !== void 0) {
    const n = Array.isArray(t.aggregate) ? t.aggregate : [t.aggregate];
    r.mods.push(...n.map((i) => xe.adj(i)));
  }
  return r;
}
function q4(t) {
  return k9(t.getChartTheme(), t);
}
function UV(t) {
  return k9(t);
}
function HV(t, e, r) {
  const n = k9(t, e);
  return n.mods.push({ type: "quote", text: r }), n;
}
const GV = xe.over({
  type: "simple-entity",
  detType: "bare",
  number: "singular",
  category: Oe.TIME
}), J3 = { ...Oe.HIGH, comparative: "superlative" }, WV = {
  type: "point-location",
  direction: xe.dir("across"),
  point: xe.the("singular", Oe.CHART, [xe.adj("whole")])
}, qV = {
  line: xe.this_("singular", { ...Oe.CHART, mods: [Oe.LINE] }),
  stepline: xe.this_("singular", { ...Oe.CHART, mods: [xe.adj("stepped"), Oe.LINE] }),
  bar: xe.this_("singular", { ...Oe.CHART, mods: [xe.noun("bar")] }),
  column: xe.this_("singular", { ...Oe.CHART, mods: [xe.noun("bar")] }),
  lollipop: xe.this_("singular", { ...Oe.CHART, mods: [xe.noun("bar")] }),
  histogram: xe.this_("singular", xe.noun("histogram"))
  // FIXME: add scatter
}, TSe = {
  line: xe.this_("singular", Oe.LINE),
  stepline: xe.this_("singular", Oe.LINE, [xe.adj("stepped")]),
  bar: xe.this_("plural", xe.noun("bar")),
  //H.this_('plural', H.noun('segment'), [H.adj('bar')]);
  lollipop: xe.this_("plural", xe.noun("bar")),
  //H.this_('plural', H.noun('segment'), [H.adj('bar')]);
  column: xe.this_("plural", xe.noun("bar")),
  //H.this_('plural', H.noun('segment'), [H.adj('bar')]);
  histogram: xe.this_("plural", xe.noun("bar"))
  // FIXME: add scatter
};
class LSe {
  constructor(e, r, n, i, s, o, a, l, c, p, h, d, b) {
    Vt(this, "seriesTheme"), Vt(this, "isTimeSeries"), Vt(this, "seriesLabel"), this.key = e, this.seriesMetadata = r, this.model = n, this.values = i, this.statsValues = s, this.indepUnit = o, this.firstPoint = a, this.lastPoint = l, this.depFacet = c, this.depFacetKey = p, this.indepFacet = h, this.indepFacetKey = d, this.intersectionValues = b, this.seriesTheme = UV(this.model.getSeriesTheme(e)), this.isTimeSeries = this.indepFacet.datatype === "date", this.seriesLabel = this.seriesMetadata.getLabel();
  }
  // Data Helpers
  /*private _getSubSeriesMetadata<T extends object>(request: string): T {
    const requestResult = jp.query(this.fullMetadata, request);
    if (requestResult.length === 0) {
      throw new ChartDataError(`The series key "${this.key}" does not exist in this graph`);
    }
    if (requestResult.length > 1) {
      throw new ChartDataError(`Request matches multiple series in this graph`);
    }
    return requestResult[0];
  }*/
  _getEarliestTime(e) {
    const r = e.map((n) => n.indepBox.value);
    return r.sort(Xm.PlainDateTime.compare), r[0];
  }
  _determineFirstExtremeDirection() {
    const e = this.seriesMetadata.getFacetStats(this.depFacetKey).min, r = this.seriesMetadata.getFacetStats(this.depFacetKey).max, n = this._getEarliestTime(e.datapoints), i = this._getEarliestTime(r.datapoints);
    return Xm.PlainDateTime.compare(n, i) === -1 ? "min" : "max";
  }
  // Subsentential
  _fromTo(e, r) {
    return new eSe(
      this.firstPoint,
      this.lastPoint,
      this.indepUnit,
      e,
      r,
      this.depFacet.units
    ).path();
  }
  // Sentences
  // Overall Series Summary Sentence
  summarizeSeries(e = !1) {
    const r = e ? qV[this.model.type] : TSe[this.model.type];
    if (!r)
      return console.error(`[ParaSummary]: series summaries are not implemented for ${this.model.type} charts yet`), [];
    let n = [];
    return this.isTimeSeries ? n = [GV, this._fromTo(this.statsValues.start, this.statsValues.end)] : n = [xe.over({
      type: "simple-entity",
      detType: "bare",
      number: "singular",
      category: xe.noun(this.indepFacet.description),
      mods: [xe.adj("several")]
    })], [{
      type: "simple-statement",
      subject: r,
      clause: {
        type: "simple-clause",
        pred: Oe.SHOW,
        object: this.seriesTheme,
        mods: n
      }
    }];
  }
  _extremeTimeSeriesClause(e) {
    const r = this.seriesMetadata.getFacetStats(this.depFacetKey)[e];
    let n = !1;
    const i = this.indepUnit === "year" ? Xm.Duration.from({ years: 1 }) : Xm.Duration.from({ months: 3 }), s = X5e(
      r.datapoints,
      i,
      this.indepUnit
    ).map((h) => h instanceof jV ? (n = !0, h.toTimeRange()) : h.indepBox.value).map((h) => S9(
      h,
      this.indepUnit
    ));
    let o;
    if (s.length === 1)
      o = s[0];
    else if (n)
      o = xe.and(...s);
    else {
      const h = s.map(
        (d) => d.point
      );
      o = xe.in_(xe.and(...h));
    }
    const a = this.statsValues[e], l = BV(a, this.depFacet.units);
    l.mods = [o];
    const c = {
      type: "simple-clause",
      pred: e === "min" ? Oe.BOTTOM_OUT : Oe.PEAK,
      object: xe.at(l)
    }, p = r.datapoints.map((h) => h.datapointIndex);
    return Jt(c, `datapoint-${this.key}-${p.join("-")}`);
  }
  _extremeTimeBoth() {
    const e = this._determineFirstExtremeDirection(), r = e === "min" ? "max" : "min", n = this._extremeTimeSeriesClause(e), i = this._extremeTimeSeriesClause(r);
    return {
      type: "simple-statement",
      subject: {
        ...this.seriesTheme,
        tag: n.tag
      },
      clause: {
        type: "coordinated-phrase",
        conn: { ...Oe.AND, tag: i.tag },
        coords: [n, i]
      }
    };
  }
  // "The {theme} {"bottoms out"/"peaks"} at {value} {"in" {time}}*. "
  _extremeTimeSeries(e) {
    if (e === "both")
      return this._extremeTimeBoth();
    const r = this._extremeTimeSeriesClause(e), n = {
      type: "simple-statement",
      subject: this.seriesTheme,
      clause: r
    };
    return n.tag = r.tag, n;
  }
  // TODO: Add back rating comparisons: https://github.com/fizzstudio/ParaSummary/issues/9
  _extremeNonTimeSeries(e) {
    if (e === "both") {
      const l = this._determineFirstExtremeDirection(), c = l === "min" ? "max" : "min", p = this._extremeNonTimeSeries(l), h = this._extremeNonTimeSeries(c);
      return xe.and(p, h);
    }
    const r = e === "min" ? { ...Oe.LOW, comparative: "superlative" } : { ...Oe.HIGH, comparative: "superlative" }, n = xe.noun(this.indepFacet.label.toLocaleLowerCase()), i = xe.the("singular", n, [r]), s = this.seriesMetadata.getFacetStats(this.depFacetKey)[e], o = s.datapoints[0].facetValue(this.indepFacetKey), a = s.value;
    return xe.svo(
      i,
      Oe.COPULA,
      xe.proper(xe.noun(o)),
      xe.at({
        type: "simple-entity",
        subtype: "quant-value",
        detType: "indefinite",
        number: a,
        category: xe.unit("point")
      })
      //{ type: 'quote', text: `, where ${closestPoint} is ${closestRating}.` }
    );
  }
  extreme(e) {
    return this.isTimeSeries ? [this._extremeTimeSeries(e)] : [this._extremeNonTimeSeries(e)];
  }
  datapoint(e) {
    if (e >= this.values.length)
      throw new Qr(`The datapoint index ${e} is too large`);
    const r = { type: "label", text: this.seriesMetadata.getLabel() }, n = this.seriesMetadata.datapoints[e].facetValue("x"), i = this.values[e], s = v2(n, this.indepUnit, i, this.depFacet.units);
    return [r, s];
  }
  intersections() {
    const e = y4.query(this.model, `$.intersections[?(@.series.includes('${this.key}'))]`);
    return [{
      type: "simple-statement",
      subject: xe.this_("singular", Oe.LINE),
      clause: {
        type: "simple-clause",
        pred: Oe.HAS,
        object: {
          type: "simple-entity",
          detType: "indefinite",
          number: e.length,
          category: Oe.INTERSECTION
        }
      }
    }];
  }
  recordCount() {
    return this.model.family === "line" ? this._recordCountLine() : this.model.family === "bar" ? this._recordCountBar() : (console.error(`[ParaSummary]: record count summaries are not implemented for ${this.model.type} charts yet`), []);
  }
  _recordCountLine() {
    return [{
      type: "simple-statement",
      subject: xe.this_("singular", Oe.LINE),
      clause: {
        type: "simple-clause",
        pred: Oe.HAS,
        object: {
          type: "simple-entity",
          detType: "indefinite",
          number: this.seriesMetadata.length,
          category: Oe.RECORD
        }
      }
    }];
  }
  // There are _ bars for this category
  _recordCountBar() {
    const e = (
      /*this.fullMetadata.series.length === 1 
      ?*/
      xe.noun("bar")
    );
    return [{
      type: "simple-statement",
      subject: null,
      clause: {
        type: "simple-clause",
        pred: { ...Oe.COPULA },
        //number: 'plural'
        object: {
          type: "simple-entity",
          detType: "indefinite",
          number: this.seriesMetadata.length,
          category: e,
          mods: [xe.for_(xe.this_("singular", xe.noun("category")))]
        }
      }
    }];
  }
  async trend() {
    if (this.model.family === "scatter")
      return on("Trend summaries are not implemented for these chart families");
    const e = await this.model.getSeriesAnalysis(this.key);
    if (e === null)
      return on(`The series "${this.key}" does not have an analysis`);
    const r = e.message;
    if (r === null)
      return on(`The series "${this.key}" does not convey a trend message`);
    const n = e.messageSeqs.map(
      (a) => e.sequences[a]
    ), i = {
      seriesKey: this.key,
      message: r,
      messageSeqs: n
    }, s = aR(i), o = this.seriesTheme;
    return [{
      type: "simple-statement",
      subject: Jt(o, is(i, 0)),
      clause: s
    }];
  }
  _rankingOrdinal(e) {
    return e === 1 ? [] : [xe.ordinal(e)];
  }
  // Full: "{this-label} starts as the {Nth} highest line, (intersects with {label} {at time})*, 
  //   and ends as the {Mth} highest line." For series summaries
  // Abbrev: "{this-label} starts as the {Nth} highest line, ({"crosses over"/"touches"} {label})*, 
  //   and ends as the {Mth} highest line." For whole chart summaries
  // Special case (highest throughout chart): "{this-label} is the highest across the whole chart"
  ranking(e) {
    const r = xe.proper(xe.noun(this.seriesLabel)), n = this.model.getChordAt(
      this.indepFacetKey,
      this.seriesMetadata.datapoints[0].facetBox(this.indepFacetKey)
    );
    n.sort(
      (d, b) => b.facetValueNumericized(this.depFacetKey) - d.facetValueNumericized(this.depFacetKey)
    );
    const i = n.findIndex((d) => d.seriesKey === this.key) + 1, s = y4.query(this.model, `$.intersections[?(@.series.includes('${this.key}'))]`);
    s.sort((d, b) => d.value - b.value);
    const o = this.model.getChordAt(
      this.indepFacetKey,
      this.seriesMetadata.datapoints.at(-1).facetBox(this.indepFacetKey)
    );
    o.sort(
      (d, b) => b.facetValueNumericized(this.depFacetKey) - d.facetValueNumericized(this.depFacetKey)
    );
    const a = o.findIndex((d) => d.seriesKey === this.key) + 1;
    if (i === 1 && a === 1 && s.length === 0)
      return [Jt(xe.svo(r, Oe.COPULA, J3, WV), `series-${this.key}`)];
    const l = Jt({
      type: "simple-clause",
      pred: Oe.START,
      object: {
        type: "purpose",
        subtype: "as",
        purpose: xe.the(
          "singular",
          { ...Oe.LINE, mods: [J3] },
          this._rankingOrdinal(i)
        )
      }
    }, `datapoint-${this.key}-0`), c = [];
    for (const [d, b] of Wn(s)) {
      const m = d.series.filter((A) => A !== this.key)[0], w = this.model.atKey(m).getLabel();
      let f;
      e ? f = {
        type: "simple-clause",
        pred: d.transversality.kind === "touch" ? xe.pred("touch") : xe.pred("cross", "over"),
        object: xe.proper(xe.noun(w))
      } : f = {
        type: "simple-clause",
        pred: Oe.INTERSECT,
        object: xe.with(
          xe.proper(xe.noun(w))
        ),
        mods: [tSe(d, this.indepUnit)]
      };
      let E = `intersection-${this.key}-${b}`;
      if (d.record.labelValue !== null) {
        const A = this.seriesMetadata.datapoints.findIndex(
          (x) => x.indepBox.asNumber() === d.record.labelValue
        );
        `${this.key}${A}`;
      }
      c.push(Jt(f, E));
    }
    const p = Jt({
      type: "simple-clause",
      pred: Oe.END,
      object: {
        type: "purpose",
        subtype: "as",
        purpose: xe.the(
          "singular",
          { ...Oe.LINE, mods: [J3] },
          this._rankingOrdinal(a)
        )
      }
    }, `datapoint-${this.key}-${this.seriesMetadata.length - 1}`), h = xe.and(l, ...c, p);
    return [{
      type: "simple-statement",
      subject: r,
      clause: h
    }];
  }
  // "The {Nth} {"and final"}? sequence goes from {start-time} to {end-time} and has a {trend-direction} trend."
  async sequence(e, r) {
    const n = this.seriesMetadata.datapoints[e].facetValue(this.indepFacetKey), i = this.seriesMetadata.datapoints[r - 1].facetValue(this.indepFacetKey), s = await this.model.getSeriesAnalysis(this.key), o = s.sequences.findIndex(
      (b) => b.start === e && b.end === r
    );
    if (o < 0)
      throw new Qr(`sequence in ${this.key} could not be found at start point ${e} and end point ${r}`);
    const a = s.sequences[o];
    let l = null;
    a.message !== null && (l = {
      seriesKey: this.key,
      message: a.message,
      messageSeqs: [a]
    });
    const c = o === s.sequences.length - 1 ? xe.and(xe.ordinal(o + 1), xe.adj("final")) : xe.ordinal(o + 1), p = xe.the("singular", xe.noun("sequence"), [c]), h = {
      type: "simple-clause",
      pred: xe.pred("go"),
      object: xe.path(
        ya(n, this.indepUnit),
        ya(i, this.indepUnit)
      )
    }, d = l === null ? [] : [aR(l, !1)];
    return {
      type: "simple-statement",
      subject: p,
      clause: xe.and(
        h,
        ...d
      )
    };
  }
}
var MSe = Object.defineProperty, NSe = Object.getOwnPropertyDescriptor, QV = (t, e, r, n) => {
  for (var i = NSe(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && MSe(e, r, i), i;
};
const DSe = xe.the("plural", Oe.LINE), lR = {
  type: "simple-entity",
  quantifier: Oe.ALL,
  detType: "definite",
  number: "plural",
  category: Oe.LINE
}, $Se = [
  "$.datasets[0]",
  "$.datasets[0].trend",
  "$.datasets[0].stats.extremes",
  "$.datasets[0].axes.dependent",
  "$.datasets[0].axes.independent",
  "$.datasets[0].labels"
], jSe = [
  "$.datasets[0]",
  "$.datasets[0].series.*",
  "$.datasets[0].axes.dependent",
  "$.datasets[0].axes.independent",
  "$.datasets[0].labels"
  //'$.datasets[0].series.highestAverage',
], BSe = [
  "$.datasets[0]",
  "$.datasets[0].series.*",
  "$.datasets[0].clusters.*",
  "$.datasets[0].trackingGroups.*",
  "$.datasets[0].highestRanking"
  //'$.datasets[0].axes.dependent',
  //'$.datasets[0].axes.independent',
  //'$.datasets[0].labels',
  //'$.datasets[0].series.highestAverage',
], FSe = [
  "$.datasets[0].series[?(@.key === '${seriesKey}')]",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].trend",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.extremes",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].record_count"
], zSe = [
  "$.datasets[0].series[?(@.key === '${seriesKey}')]",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].trend",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.extremes"
  //"$.datasets[0].intersections[?(@.series.includes('${seriesKey}'))]",
  //"$.datasets[0].series[?(@.key === '${seriesKey}')].record_count",
], VSe = [
  "$.datasets[0].series[?(@.key === '${seriesKey}')]",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].trend",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.max",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.min",
  //"$.datasets[0].intersections[?(@.series.includes('${seriesKey}'))]",
  //"$.datasets[0].series[?(@.key === '${seriesKey}')].record_count",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].ranking"
];
class _9 extends pv {
  /**
   * @param model - The data model for the chart
   */
  constructor(e) {
    super(e), Vt(this, "summarizer"), this.summarizer = new USe(e);
  }
  getSummarizer() {
    return this.summarizer;
  }
  async getChartSummary() {
    if (this._model.description)
      return { text: this._model.description, html: this._model.description };
    let e;
    return this._model.multi ? this._model.family === "line" ? e = BSe : e = jSe : e = $Se, this.highlightSummaries(e);
  }
  async getSeriesSummary(e) {
    let r;
    this._model.multi ? this._model.family === "line" ? r = VSe : r = zSe : r = FSe;
    const n = r.map((s) => s.replaceAll("${seriesKey}", e)), i = this._model.atKey(e).getLabel();
    return this.grammatizeSummaries(n).then((s) => `${i}: ${s}`).then((s) => P4(s));
  }
  async getSequenceSummary(e) {
    if (!this._model.seriesKeys.includes(e.seriesKey))
      throw new Qr(`No series with the key ${e.seriesKey} exists in this chart.`);
    const r = await this.summarizer.sequence(e.seriesKey, `${e.start}`, `${e.end}`);
    return this.highlightComponents(r);
  }
}
QV([
  jd()
], _9.prototype, "getChartSummary");
QV([
  jd()
], _9.prototype, "getSeriesSummary");
class USe {
  //private spanIndex = -1;
  // * Initialization *
  constructor(e) {
    Vt(this, "multi"), Vt(this, "indepFacetKey"), Vt(this, "indepFacet"), Vt(this, "indepUnit"), Vt(this, "firstPoint"), Vt(this, "lastPoint"), Vt(this, "indepAxisOrient"), Vt(this, "depFacetKey"), Vt(this, "depFacet"), Vt(this, "seriesKeys"), Vt(this, "seriesValues"), Vt(this, "seriesStatsValues"), Vt(this, "seriesMetadata"), Vt(this, "seriesSummarizers"), Vt(this, "intersectionValues"), Vt(this, "isTimeSeries"), this.model = e, this.indepFacetKey = this.model.independentFacetKeys[0], this.indepFacet = this.model.getFacet(this.indepFacetKey), this.indepUnit = this.indepFacet.units ?? "NO-UNIT", this.isTimeSeries = this.indepFacet.datatype === "date", this.firstPoint = this.model[0][0], this.lastPoint = this.model[0][this.model[0].length - 1];
    const r = this.model.getAxisFacet("horiz") ?? this.indepFacet;
    this.indepAxisOrient = r.label === this.indepFacet.label ? "horiz" : "vert", this.depFacetKey = this.model.dependentFacetKeys[0], this.depFacet = this.model.getFacet(this.depFacetKey), this.multi = this.model.multi, this.seriesKeys = this.model.seriesKeys, this.seriesSummarizers = {}, this.seriesMetadata = {}, this.seriesValues = this.model.seriesScaledValues ?? this.makeEmptyMap(), this.seriesStatsValues = this.model.seriesStatsScaledValues ?? this.makeEmptyMap(), this.intersectionValues = this.model.intersectionScaledValues ?? [];
    for (const n of this.seriesKeys)
      this.seriesMetadata[n] = this.model.atKey(n), this.seriesSummarizers[n] = new LSe(
        n,
        this.seriesMetadata[n],
        this.model,
        this.seriesValues[n],
        this.seriesStatsValues[n],
        this.indepUnit,
        this.firstPoint,
        this.lastPoint,
        this.depFacet,
        this.depFacetKey,
        this.indepFacet,
        this.indepFacetKey,
        this.intersectionValues
      );
  }
  makeEmptyMap() {
    const e = {};
    for (const r of this.seriesKeys)
      e[r] = null;
    return e;
  }
  // @simonvarey: This can be deleted when we feel that we won't need span indexes set in summarizers, instead of in `convertToHighlighted`
  /*private newSpanIndex(): number {
    this.spanIndex += 1;
    return this.spanIndex;
  }*/
  // * Data Helpers *
  _getOnlySeriesSummarizer() {
    if (this.multi)
      throw new Qr("Cannot call `_getOnlySeriesSummarizer` on multi series chart.");
    return this.seriesSummarizers[this.seriesKeys[0]];
  }
  // * Summary Helpers *
  // Substatement
  // "___, _____, and _________" (main case) 
  // OR "the lines" (if group.length === series.length === 2)
  // OR "all the lines" (if group.length === series.length > 2)
  // @simonvarey: `tag` was originally added for `allCluster` sentences, but then I decided I didn't
  //   need it there, but I have kept it in this method in case it is useful in the future
  _seriesGroupLine(e, r) {
    if (e.length < 2)
      throw new Qr("Cannot call `_seriesGroupLine` with fewer than 2 keys.");
    const n = `series-${e.join("-")}`;
    if (e.length === this.model.numSeries) {
      const o = e.length === 2 ? DSe : lR;
      return r ? Jt(o, n) : o;
    }
    const i = e.map((o) => {
      const a = this.model.atKey(o).getLabel();
      return xe.proper(xe.noun(a));
    }), s = xe.and(...i);
    return r ? Jt(s, n) : s;
  }
  _allSeriesSubjectsBar() {
    return this.model.grouped ? {
      ...Oe.BAR,
      mods: [xe.of({
        type: "simple-entity",
        quantifier: Oe.EACH,
        detType: "bare",
        number: "singular",
        category: Oe.GROUP
      })]
    } : {
      type: "simple-category",
      noun: xe.en("segment"),
      mods: [xe.of({
        type: "simple-entity",
        quantifier: Oe.EACH,
        detType: "bare",
        number: "singular",
        category: Oe.BAR
      })]
    };
  }
  _allSeriesSubjects() {
    return this.model.family === "line" ? Oe.LINE : this.model.family === "bar" ? this._allSeriesSubjectsBar() : null;
  }
  // Statement
  // Overall Chart Summary Sentence
  // 'This {chart type} chart compares the {quantity type}s of different {topic}s over time from {start x} to {end x}.'
  _chartMultiTimeSeries(e) {
    return {
      type: "simple-statement",
      subject: e,
      clause: {
        type: "simple-clause",
        pred: Oe.COMPARE,
        object: q4(
          this.model
          /*, this.differentia!*/
        ),
        mods: [GV, xe.path(
          ya(this.firstPoint.indepBox.value, this.indepUnit),
          ya(this.lastPoint.indepBox.value, this.indepUnit)
        )]
      }
      //tag: makeSpan(`nochart-${this.newSpanIndex()}`)
    };
  }
  _chartMultiNonTimeSeries(e) {
    return {
      type: "simple-statement",
      subject: e,
      clause: {
        type: "simple-clause",
        pred: Oe.COMPARE,
        object: HV(
          this.model.getChartTheme(),
          this.model,
          `of ${this.model.getChartTheme().entity}`
        )
      }
    };
  }
  _chartMultiSeries() {
    const e = qV[this.model.type];
    return e ? this.isTimeSeries ? [this._chartMultiTimeSeries(e)] : [this._chartMultiNonTimeSeries(e)] : (console.error(`[ParaSummary]: whole chart summaries are not implemented for ${this.model.type} charts yet`), []);
  }
  _extreme(e) {
    throw new n2("extreme");
  }
  _intersectionAtIndex(e) {
    const r = this.model.intersections[e], n = xe.and(xe.proper(xe.noun(r.series[0])), xe.proper(xe.noun(r.series[1]))), i = this.intersectionValues[e];
    return xe.svo(
      n,
      { ...Oe.INTERSECT },
      rSe(r, this.indepUnit, i, this.depFacet)
    );
  }
  // ___, _____, and ______ track each other from ________ to ______
  _trackingGroup(e) {
    const r = e.valueInterval[0], n = this.model.series[0].datapoints[0].facetValueAsNumber(this.indepFacetKey), i = e.valueInterval[1], s = this.model.series[0].datapoints.at(-1).facetValueAsNumber(this.indepFacetKey);
    let o;
    if (r === n && i === s)
      o = WV;
    else {
      const l = qf(r), c = qf(i);
      o = new Gv(
        l,
        c,
        this.indepUnit
      ).path();
    }
    const a = this._seriesGroupLine(e.keys);
    return Jt(xe.svo(
      a,
      Oe.TRACK,
      //number: 'p'
      Oe.EACH_OTHER,
      o
    ), `series-${e.keys.join("-")}`);
  }
  // * Summary Generation *
  // All Chart
  chart() {
    return this.multi ? this._chartMultiSeries() : this._getOnlySeriesSummarizer().summarizeSeries(!0);
  }
  // Series Topics Sentence
  //The {number of series} {lines/segments of each bar/bars of each group} show the {quantity type}s of {series 1 topic}, {series 2 topic} ... 
  allSeries() {
    var e;
    const r = this._allSeriesSubjects();
    if (!r)
      return on(`[ParaSummary]: all series summaries are not implemented for ${this.model.type} charts yet`);
    const n = `series-${this.model[0].key}`, i = A9(this.model.getChartTheme(), !0);
    i.detTag = z0(n), i.category = Jt(i.category, n), i.mods = (e = i.mods) == null ? void 0 : e.map((o) => Jt(o, n)), kSe(i, this.model);
    const s = {
      type: "simple-clause",
      pred: Jt(Oe.SHOW, n),
      object: i
    };
    return [{
      type: "simple-statement",
      subject: Jt(xe.the(this.model.numSeries, r), n),
      clause: s
    }];
  }
  chartMin() {
    return this.multi ? this._extreme("min") : this._getOnlySeriesSummarizer().extreme("min");
  }
  chartMax() {
    return this.multi ? this._extreme("max") : this._getOnlySeriesSummarizer().extreme("max");
  }
  chartExtremes() {
    return this.multi ? this._extreme("both") : this._getOnlySeriesSummarizer().extreme("both");
  }
  onlySeriesTrend() {
    if (this.multi)
      throw new Qr("`onlySeriesTrend` cannot be called on charts with multiple series.");
    return this._getOnlySeriesSummarizer().trend();
  }
  // Series
  specificSeries(e) {
    return this.seriesSummarizers[e].summarizeSeries();
  }
  seriesTrend(e) {
    return this.seriesSummarizers[e].trend();
  }
  seriesMax(e) {
    return this.seriesSummarizers[e].extreme("max");
  }
  seriesMin(e) {
    return this.seriesSummarizers[e].extreme("min");
  }
  seriesExtremes(e) {
    return this.seriesSummarizers[e].extreme("both");
  }
  seriesDatapoint(e, r) {
    const n = this.seriesSummarizers[e], i = parseInt(r);
    return n.datapoint(i);
  }
  seriesIntersections(e) {
    if (!this.multi)
      throw new Qr("Series-Intersection can not be requested in single-series charts.");
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].intersections(
      /*this.differentia!*/
    );
  }
  seriesRecordCount(e) {
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].recordCount(
      /*this.differentia!*/
    );
  }
  seriesRanking(e) {
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].ranking(!1);
  }
  // Other
  dependentAxis() {
    if (this.model.type === "pie")
      return [];
    const e = this.indepAxisOrient === "horiz" ? Oe.YAXIS : Oe.XAXIS;
    return [xe.svo(
      xe.the("singular", e),
      Oe.SHOW,
      this.dependentAxisLabel()[0]
    )];
  }
  independentAxis() {
    if (this.model.type === "pie")
      return [];
    const e = this.indepAxisOrient === "horiz" ? Oe.XAXIS : Oe.YAXIS;
    let r;
    return this.isTimeSeries ? r = {
      type: "simple-entity",
      detType: "definite",
      number: "singular",
      category: xe.noun("time"),
      mods: [xe.in_(xe.a("plural", xe.noun(this.indepUnit)))]
    } : r = {
      type: "simple-entity",
      detType: "definite",
      number: "singular",
      category: xe.noun(this.indepFacet.label.toLocaleLowerCase())
    }, [xe.svo(
      xe.the("singular", e),
      Oe.SHOW,
      r
    )];
  }
  intersection(e) {
    if (!this.multi)
      throw new Qr("No intersections on single series charts.");
    const r = parseInt(e);
    if (r < 0 || r > this.model.intersections.length)
      throw new Qr(`No intersection with the index ${r} exists on this chart.`);
    return [this._intersectionAtIndex(r)];
  }
  allIntersection() {
    if (!this.multi)
      throw new Qr("No intersections on single series charts.");
    return rxe(this.model.intersections.length, this._intersectionAtIndex.bind(this));
  }
  //The lines for {series topic}, {series topic} ... cluster together while the line for {series topic} is an outlier.
  // OR All the lines except {series topic} cluster together.
  allCluster() {
    if (!this.multi)
      return on("No clusters on single series charts.");
    if (this.model.clusters.length !== 1)
      return on("All cluster when there are more than 1 cluster are not implemented.");
    const e = this.model.clusters[0], r = e.map((h) => this.seriesMetadata[h].facetAverage(this.depFacetKey)), n = txe(r), i = this.model.clusterOutliers.length === 1, s = {
      type: "simple-clause",
      pred: Oe.CLUSTER,
      object: null,
      mods: [Oe.TOGETHER]
    }, o = `series-${e.join("-")}`;
    let a, l, c;
    if (i) {
      a = this.model.clusterOutliers[0];
      const h = this.seriesMetadata[a];
      l = xe.proper(xe.noun(h.getLabel())), c = h.facetAverage(this.depFacetKey) > n ? xe.dir("above") : xe.dir("below");
    }
    if (i && e.length + 1 === this.model.series.length && e.length > 2) {
      const h = {
        ...lR,
        mods: [{
          type: "point-location",
          direction: Oe.EXCEPT,
          point: l
        }]
      }, d = Jt({
        type: "simple-statement",
        subject: h,
        clause: s
      }, o), b = Jt(xe.svo(l, xe.pred("lie"), c), `series-${a}`), m = xe.coord(Oe.WHILE, d, b);
      return m.conn = Jt(m.conn, `series-${a}`), [m];
    }
    let p = Jt({
      type: "simple-statement",
      subject: this._seriesGroupLine(e),
      clause: s
    }, o);
    if (this.model.clusterOutliers.length === 1) {
      const h = `series-${this.model.clusterOutliers[0]}`, d = Jt(xe.svo(
        l,
        Oe.COPULA,
        xe.a("singular", Oe.OUTLIER),
        c
      ), h);
      p = xe.coord({ ...Oe.WHILE, tag: z0(h) }, p, d);
    }
    return [p];
  }
  allTrackingGroup() {
    return this.multi ? this.model.trackingGroups.map((e) => this._trackingGroup(e)) : on("No tracking groups on single series charts.");
  }
  datapoint(e, r) {
    const n = this.model.allPoints.filter((i) => i.facetValue("x") === e && i.facetValue("y") === r).map((i) => i.seriesKey).map((i) => this.model.atKey(i).getLabel());
    return [{
      type: "label",
      text: `X: ${e}, Y: ${r}, Series: ${n.join(", ")}`
    }];
  }
  async sequence(e, r, n) {
    return [await this.seriesSummarizers[e].sequence(parseInt(r), parseInt(n))];
  }
  chartLabels() {
    const e = this.indepAxisOrient === "horiz" ? Oe.XAXIS : Oe.YAXIS;
    let r;
    return this.model.type === "pie" ? r = {
      type: "simple-entity",
      detType: "indefinite",
      number: this.model[0].length,
      category: xe.noun("slice")
    } : r = {
      type: "simple-entity",
      detType: "indefinite",
      number: this.model[0].length,
      category: Oe.RECORD,
      mods: [{ type: "point-location", direction: Oe.ALONG, point: xe.the("singular", e) }]
    }, [{
      type: "simple-statement",
      subject: xe.the("singular", Oe.CHART),
      clause: {
        type: "simple-clause",
        pred: Oe.HAS,
        object: r
      }
    }];
  }
  highestRanking() {
    const e = this.model.series.toSorted((r, n) => n.facetAverage(this.depFacetKey) - r.facetAverage(this.depFacetKey))[0].key;
    return this.seriesSummarizers[e].ranking(!0);
  }
  // Substatement
  chartTheme() {
    return [q4(this.model)];
  }
  dependentAxisLabel() {
    const e = OSe(this.model.getChartTheme());
    if (this.depFacet.units !== void 0 && (this.depFacet.units in G4 || this.depFacet.units in b2)) {
      let r = xe.a("plural", xe.noun(this.depFacet.units));
      this.depFacet.multiplier !== void 0 && (r = {
        type: "simple-entity",
        detType: "indefinite",
        number: "plural",
        category: W4[this.depFacet.multiplier],
        mods: [xe.of(r)]
      }), e.mods = [xe.in_(r)];
    } else if (this.depFacet.multiplier !== void 0 && this.model.getChartTheme().baseKind === "number") {
      const r = {
        type: "simple-entity",
        detType: "indefinite",
        number: "plural",
        category: W4[this.depFacet.multiplier]
      };
      e.mods ?? (e.mods = []), e.mods.push(xe.in_(r));
    }
    return [e];
  }
}
const HSe = {
  pie: xe.this_("singular", xe.noun("slice")),
  donut: xe.this_("singular", xe.noun("slice"))
}, KV = {
  pie: xe.this_("singular", { ...Oe.CHART, mods: [xe.noun("pie")] }),
  donut: xe.this_("singular", { ...Oe.CHART, mods: [xe.noun("donut")] })
};
class GSe {
  constructor(e, r, n, i, s) {
    Vt(this, "seriesThemePhrase"), Vt(this, "seriesLabel"), this.key = e, this.seriesMetadata = r, this.model = n, this.depFacetKey = i, this.indepFacetKey = s, this.seriesThemePhrase = UV(this.model.getSeriesTheme(this.key)), this.seriesLabel = this.seriesMetadata.getLabel();
  }
  // Sentences
  // Overall Series Summary Sentence
  summarizeSeries(e = !1) {
    const r = e ? KV[this.model.type] : HSe[this.model.type];
    return r ? [{
      type: "simple-statement",
      subject: r,
      clause: {
        type: "simple-clause",
        pred: Oe.SHOW,
        object: this.seriesThemePhrase
      }
    }] : (console.error(`[ParaSummary]: series summaries are not implemented for ${this.model.type} charts yet`), []);
  }
  _extremePie(e) {
    if (e === "both")
      return xe.and(this._extremePie("max"), this._extremePie("min"));
    const r = this.seriesMetadata.getFacetStats(this.depFacetKey)[e], n = r.datapoints.map(
      (p) => xe.proper(xe.noun(p.facetValue(this.indepFacetKey)))
    ), i = n.length, s = i === 1 ? n[0] : xe.and(...n), o = i === 1 ? "singular" : "plural", a = r.value, l = e === "min" ? { ...xe.adj("small"), comparative: "superlative" } : { ...Oe.LARGE, comparative: "superlative" }, c = xe.the(o, xe.noun("slice"), [l]);
    return xe.svo(
      c,
      {
        ...Oe.COPULA
        /*number: extremeGramNumber*/
      },
      s,
      xe.at({
        type: "number-entity",
        number: a,
        scale: Ol[0.01]
      })
    );
  }
  extreme(e) {
    return [this._extremePie(e)];
  }
  datapoint(e) {
    if (e >= this.seriesMetadata.length)
      throw new Qr(`The datapoint index ${e} is too large`);
    const r = { type: "label", text: this.seriesLabel }, n = this.seriesMetadata.datapoints[e].facetValue(this.indepFacetKey), i = { type: "quote", text: `${this.seriesMetadata.datapoints[e].facetValue(this.depFacetKey)} at ${n}.` };
    return [r, i];
  }
  intersections() {
    return console.error("Pastry charts do not have intersections and therefore do not have intersection summaries"), [];
  }
  recordCount() {
    return console.error(`[ParaSummary]: record count summaries are not implemented for ${this.model.type} charts yet`), [];
  }
  async trend() {
    return console.error("Pastry charts do not have trends and therefore do not have trends summaries"), [];
  }
}
var WSe = Object.defineProperty, qSe = Object.getOwnPropertyDescriptor, YV = (t, e, r, n) => {
  for (var i = qSe(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && WSe(e, r, i), i;
};
const QSe = [
  "$.datasets[0]",
  "$.datasets[0].stats.extremes",
  "$.datasets[0].labels"
];
class C9 extends pv {
  /**
   * @param model - The data model for the chart
   */
  constructor(e) {
    super(e), Vt(this, "summarizer"), this.summarizer = new KSe(e);
  }
  getSummarizer() {
    return this.summarizer;
  }
  async getChartSummary() {
    return this._model.multi ? V3("Summaries are not implemented for multi-series pastry charts") : this._model.description ? { text: this._model.description, html: this._model.description } : this.highlightSummaries(QSe);
  }
  async getSeriesSummary(e) {
    return V3("Series summaries are not implemented for pastry charts");
  }
  async getSequenceSummary(e) {
    return V3("sequence is not defined for pastry charts");
  }
}
YV([
  jd()
], C9.prototype, "getChartSummary");
YV([
  jd()
], C9.prototype, "getSeriesSummary");
class KSe {
  // * Initialization *
  constructor(e) {
    Vt(this, "multi"), Vt(this, "indepFacetKey"), Vt(this, "depFacetKey"), Vt(this, "seriesKeys"), Vt(this, "seriesMetadata"), Vt(this, "seriesSummarizers"), this.model = e, this.multi = this.model.multi, this.indepFacetKey = this.model.independentFacetKeys[0], this.depFacetKey = this.model.dependentFacetKeys[0], this.seriesKeys = this.model.seriesKeys, this.seriesSummarizers = {}, this.seriesMetadata = {};
    for (const r of this.seriesKeys)
      this.seriesMetadata[r] = this.model.atKey(r), this.seriesSummarizers[r] = new GSe(
        r,
        this.seriesMetadata[r],
        this.model,
        this.depFacetKey,
        this.indepFacetKey
      );
  }
  // * Data Helpers *
  _getOnlySeriesSummarizer() {
    if (this.multi)
      throw new Qr("Cannot call `_getOnlySeriesSummarizer` on multi series chart.");
    return this.seriesSummarizers[this.seriesKeys[0]];
  }
  // * Summary Helpers *
  // Statement
  // Overall Chart Summary Sentence
  // 'This {chart type} chart compares {theme of entity}.'
  _chartMultiNonTimeSeries(e) {
    return {
      type: "simple-statement",
      subject: e,
      clause: {
        type: "simple-clause",
        pred: Oe.COMPARE,
        object: HV(
          this.model.getChartTheme(),
          this.model,
          `of ${this.model.getChartTheme().entity}`
        )
      }
    };
  }
  _extreme(e) {
    throw new n2("extreme");
  }
  // * Summary Generation *
  // All Chart
  chart() {
    if (this.multi) {
      const e = KV[this.model.type];
      return e ? [this._chartMultiNonTimeSeries(e)] : (console.error(`[ParaSummary]: whole chart summaries are not implemented for ${this.model.type} charts yet`), []);
    } else
      return this._getOnlySeriesSummarizer().summarizeSeries(!0);
  }
  // Series Topics Sentence
  //The {number of series} {lines/bar segments} show the {quantity type}s of {series 1 topic}, {series 2 topic} ... 
  allSeries() {
    return console.error(`[ParaSummary]: all series summaries are not implemented for ${this.model.type} charts yet`), [];
  }
  chartMin() {
    return this.multi ? this._extreme("min") : this._getOnlySeriesSummarizer().extreme("min");
  }
  chartMax() {
    return this.multi ? this._extreme("max") : this._getOnlySeriesSummarizer().extreme("max");
  }
  chartExtremes() {
    return this.multi ? this._extreme("both") : this._getOnlySeriesSummarizer().extreme("both");
  }
  async onlySeriesTrend() {
    return on("onlySeriesTrend is not defined for pastry charts");
  }
  // Series
  specificSeries(e) {
    return this.seriesSummarizers[e].summarizeSeries();
  }
  seriesMax(e) {
    return this.seriesSummarizers[e].extreme("max");
  }
  seriesMin(e) {
    return this.seriesSummarizers[e].extreme("min");
  }
  seriesExtremes(e) {
    return this.seriesSummarizers[e].extreme("both");
  }
  seriesDatapoint(e, r) {
    const n = this.seriesSummarizers[e], i = parseInt(r);
    return n.datapoint(i);
  }
  seriesIntersections(e) {
    if (!this.multi)
      throw new Qr("Series-Intersection can not be requested in single-series charts.");
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].intersections(
      /*this.differentia!*/
    );
  }
  seriesRecordCount(e) {
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].recordCount(
      /*this.differentia!*/
    );
  }
  async seriesTrend(e) {
    return on("seriesTrend is not defined for pastry charts");
  }
  seriesRanking(e) {
    return on("seriesRanking is not defined for pastry charts");
  }
  // Other
  dependentAxis() {
    return on("Pastry charts do not have axes and therefore do not have dependent axis summaries");
  }
  independentAxis() {
    return on("Pastry charts do not have axes and therefore do not have independent axis summaries");
  }
  intersection(e) {
    return on("Pastry charts do not have intersections and therefore do not have intersection summaries");
  }
  allIntersection() {
    return on("Pastry charts do not have intersections and therefore do not have intersection summaries");
  }
  allCluster() {
    return on("Pastry charts do not have clusters and therefore do not have cluster summaries");
  }
  allTrackingGroup() {
    return on("Pastry charts do not have tracking groups and therefore do not have cluster summaries");
  }
  datapoint(e, r) {
    const n = this.model.allPoints.filter((i) => i.facetValue("x") === e && i.facetValue("y") === r).map((i) => i.seriesKey).map((i) => this.model.atKey(i).getLabel());
    return [{
      type: "label",
      text: `X: ${e}, Y: ${r}, Series: ${n.join(", ")}`
    }];
  }
  async sequence(e, r, n) {
    return on("Sequence summaries not implemented for pastry charts");
  }
  chartLabels() {
    const e = {
      type: "simple-entity",
      detType: "indefinite",
      number: this.model[0].length,
      category: xe.noun("slice")
    };
    return [{
      type: "simple-statement",
      subject: xe.the("singular", Oe.CHART),
      clause: {
        type: "simple-clause",
        pred: Oe.HAS,
        object: e
      }
    }];
  }
  highestRanking() {
    return on("highestRanking is not defined for pastry charts");
  }
  // Substatement
  chartTheme() {
    return [q4(this.model)];
  }
  dependentAxisLabel() {
    return console.error("Pastry charts do not have axes and therefore do not have dependent axis labels"), [];
  }
}
const YSe = ["up", "down", "left", "right", "in", "out"], ZSe = {
  horizTick: "axis.horiz.ticks.labelFormat",
  vertTick: "axis.vert.ticks.labelFormat",
  linePoint: "type.line.pointLabelFormat",
  scatterPoint: "type.scatter.pointLabelFormat",
  histogramPoint: "type.histogram.pointLabelFormat",
  heatmapPoint: "type.histogram.pointLabelFormat",
  barCluster: "type.bar.clusterLabelFormat",
  pieSliceLabel: "type.pie.sliceLabelFormat",
  pieSliceValue: "type.pie.sliceValueFormat",
  donutSliceLabel: "type.donut.sliceLabelFormat",
  gaugeSliceLabel: "type.gauge.sliceLabelFormat",
  steplinePoint: "type.stepline.pointLabelFormat",
  lollipopPoint: "type.lollipop.pointLabelFormat",
  lollipopCluster: "type.lollipop.clusterLabelFormat",
  jimX: "jim.xValueFormat",
  dataTableX: "dataTable.xValueFormat",
  dataTableY: "dataTable.yValueFormat",
  statusBar: "statusBar.valueFormat",
  domId: "NA"
};
class br {
  static hydrateInput(e) {
    const r = {};
    for (const [n, i] of Object.entries(e))
      br.set(n, i, r, !0);
    return r;
  }
  /**
   * Generate a list of setting [key, value] pairs that would need to be applied
   * to `this` to turn it into `other`.
   * @param other - Another setting store object.
   * @returns List of [key, value] pairs. 
   */
  /*diff(other: SettingStore): [string, Setting | undefined][] {
      return this.diffGroup(this.settings, other.settings);
    }
  
    private diffGroup<T extends SettingGroup>(group: Partial<T>, withGroup: T, path = '') {
      let diff: [string, Setting | undefined][] = [];
      const keys = Object.keys(withGroup) as (keyof T)[];
      for (const key of keys) {
        const pathPlusKey = `${path ? path + '.' : ''}${key as string}`;
        if (group.hasOwnProperty(key)) {
          if (typeof group[key] === 'object') {
            if (typeof withGroup[key] !== 'object') {
              throw new Error(`type of setting '${key as string}' must be ${typeof withGroup[key]}`);
            }
            diff = diff.concat(this.diffGroup(group[key] as SettingGroup, withGroup[key] as SettingGroup, 
              pathPlusKey));
          } else if (group[key] !== withGroup[key]) {
            diff.push([pathPlusKey, withGroup[key] as Setting | undefined]);
          } 
        } else {
          // withGroup is guaranteed to have the key
          if (typeof withGroup[key] === 'object') {
            diff = diff.concat(this.diffGroup({}, withGroup[key] as SettingGroup, 
              `${path}.${key as string}`));
          } else {
            diff.push([pathPlusKey, withGroup[key] as Setting | undefined]);
          }
        }
      }
      return diff;
    }
  
    /**
     * Given a group path, return the object for it.
     * @param path - Dotted path to the group.
     * @param group - Optional group to start search from (default: root of the setting tree).
     * @param create - Optionally create groups that don't exist.
     * @returns Setting group object.
     */
  static getGroup(e, r, n = !1) {
    const i = e.split(".");
    let s = r, o = null;
    for (const a of i)
      if (o = s, s = s[a], typeof s != "object")
        if (n && s === void 0)
          s = {}, o[a] = s;
        else
          throw new Error(`invalid setting group type '${typeof s}' in '${e}'`);
    return s;
  }
  static getGroupLink(e, r) {
    return br.getGroup(e, r);
  }
  /**
   * Given a full setting path, return the group that immediately
   * contains the setting.
   * @param path - Dotted path to the setting.
   * @param group - Optional group to start search from (default: root of the setting tree).
   * @param create - Optionally create groups that don't exist.
   * @returns Setting group.
   */
  static getGroupForSetting(e, r, n = !1) {
    const i = e.split(".");
    if (i.length < 2)
      throw new Error("setting path must have at least two elements");
    return br.getGroup(i.slice(0, -1).join("."), r, n);
  }
  static get(e, r) {
    const n = br.getGroupForSetting(e, r)[e.split(".").at(-1)];
    if (typeof n == "object")
      throw new Error("can only get settings, not groups");
    return n;
  }
  static set(e, r, n, i = !1) {
    const s = e.split("."), o = br.getGroupForSetting(e, n, i);
    o[s.at(-1)] = r;
  }
  static cloneSettings(e) {
    const r = {}, n = Object.keys(e);
    for (const i of n)
      br.cloneProp(r, e, i);
    return r;
  }
  static cloneProp(e, r, n) {
    typeof r[n] == "object" ? e[n] = br.cloneSettings(r[n]) : e[n] = r[n];
  }
  static suppleteSettings(e, r) {
    const n = Object.keys(r);
    for (const i of n)
      if (e.hasOwnProperty(i))
        if (typeof e[i] == "object") {
          if (typeof r[i] != "object")
            throw new Error(`type of setting '${i}' must be ${typeof r[i]}`);
          this.suppleteSettings(e[i], r[i]);
        } else if (e[i] === void 0)
          br.cloneProp(e, r, i);
        else
          continue;
      else
        br.cloneProp(e, r, i);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ZV = Symbol.for(""), JSe = (t) => {
  if ((t == null ? void 0 : t.r) === ZV) return t == null ? void 0 : t._$litStatic$;
}, Lu = (t, ...e) => ({ _$litStatic$: e.reduce((r, n, i) => r + ((s) => {
  if (s._$litStatic$ !== void 0) return s._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${s}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(n) + t[i + 1], t[0]), r: ZV }), cR = /* @__PURE__ */ new Map(), JV = (t) => (e, ...r) => {
  const n = r.length;
  let i, s;
  const o = [], a = [];
  let l, c = 0, p = !1;
  for (; c < n; ) {
    for (l = e[c]; c < n && (s = r[c], (i = JSe(s)) !== void 0); ) l += i + e[++c], p = !0;
    c !== n && a.push(s), o.push(l), c++;
  }
  if (c === n && o.push(e[n]), p) {
    const h = o.join("$$lit$$");
    (e = cR.get(h)) === void 0 && (o.raw = o, cR.set(h, e = o)), r = a;
  }
  return t(e, ...r);
}, XSe = JV(qe), e8e = JV(Tt);
var t8e = Object.defineProperty, r8e = (t, e, r, n) => {
  for (var i = void 0, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && t8e(e, r, i), i;
};
const n8e = {
  textfield: Lu`para-textfield-setting-control`,
  dropdown: Lu`para-dropdown-setting-control`,
  checkbox: Lu`para-checkbox-setting-control`,
  radio: Lu`para-radio-setting-control`,
  slider: Lu`para-slider-setting-control`,
  button: Lu`para-button-setting-control`
};
class XV extends Ay {
  constructor(e) {
    super(), this._store = e, this.log = qt("SettingControlManager"), this._settingControlInfo = {};
  }
  add(e) {
    this._settingControlInfo = Wse(this._settingControlInfo, (r) => {
      const n = {}, i = n8e[e.type];
      n.key = e.key, n.parentView = e.parentView, n.options = e.options, n.validator = e.validator, n.render = () => XSe`
        <${i}
          .value=${e.value ?? br.get(e.key, this._store.settings)}
          .label=${e.label}
          .info=${n}
          .store=${this._store}
          ?hidden=${e.hidden}
          id="setting-${Yn(e.key)}"
        ></${i}>
      `, r[e.key] = n;
    });
  }
  info(e) {
    return this._settingControlInfo[e];
  }
  // value<T extends Setting>(key: string) {
  //   const controlInfo = this.info(key);
  //   if (!controlInfo) {
  //     throw new Error(`no setting control info for key '${key}'`);
  //   }
  //   return controlInfo.settingControlRef.value!.value as T;
  // }
  // setVisible(key: string, visible: boolean) {
  //   const controlInfo = this.info(key);
  //   if (!controlInfo) {
  //     throw new Error(`no setting control info for key '${key}'`);
  //   }
  //   if (visible) {
  //     controlInfo.settingControlRef.value!.removeAttribute('hidden');
  //   } else {
  //     controlInfo.settingControlRef.value!.setAttribute('hidden', 'hidden');
  //   }
  // }
  getContent(e) {
    return Object.values(this._settingControlInfo).filter((r) => r.parentView === e).map((r) => r.render());
  }
  /**
   * Update the control (if any) for a setting with a new value.
   * @returns Setting keys.
   */
  // update(key: string, value: Setting | undefined) {
  //   const controlInfo = this._settingControlInfo[key];
  //   if (controlInfo) {
  //     const control = controlInfo.settingControlRef.value!;
  //     if (control) {
  //       control.value = value;
  //     }
  //   } else {
  //     this.log.info(`no setting control for key '${key}'`);
  //   }
  // }
  // updateOptions(key: string, options: SettingControlOptionsType<any>) {
  //   const controlInfo = this._settingControlInfo[key];
  //   if (controlInfo) {
  //     const control = controlInfo.settingControlRef.value!;
  //     if (control) {
  //       if (!controlInfo.options) {
  //         controlInfo.options = {};
  //       }
  //       for (const prop in options) {
  //         const key = prop as keyof typeof options;
  //         controlInfo.options[key] = options[key];
  //       }
  //       control.requestUpdate();
  //     }
  //   } else {
  //     this.log.info(`no setting control for key '${key}'`);
  //   }
  // }
}
r8e([
  Ar()
], XV.prototype, "_settingControlInfo");
const Q4 = [
  16.3516,
  17.32391,
  18.35405,
  19.44544,
  20.60172,
  21.82676,
  23.12465,
  24.49971,
  25.95654,
  27.5,
  29.13524,
  30.86771,
  // octave 0
  32.7032,
  34.64783,
  36.7081,
  38.89087,
  41.20344,
  43.65353,
  46.2493,
  48.99943,
  51.91309,
  55,
  58.27047,
  61.73541,
  // octave 1
  65.40639,
  69.29566,
  73.41619,
  77.78175,
  82.40689,
  87.30706,
  92.49861,
  97.99886,
  103.8262,
  110,
  116.5409,
  123.4708,
  // octave 2
  130.8128,
  138.5913,
  146.8324,
  155.5635,
  164.8138,
  174.6141,
  184.9972,
  195.9977,
  207.6523,
  220,
  233.0819,
  246.9417,
  // octave 3
  261.6256,
  277.1826,
  293.6648,
  311.127,
  329.6276,
  349.2282,
  369.9944,
  391.9954,
  415.3047,
  440,
  466.1638,
  493.8833,
  // octave 4
  523.2511,
  554.3653,
  587.3295,
  622.254,
  659.2551,
  698.4565,
  739.9888,
  783.9909,
  830.6094,
  880,
  932.3275,
  987.7666,
  // octave 5
  1046.502,
  1108.731,
  1174.659,
  1244.508,
  1318.51,
  1396.913,
  1479.978,
  1567.982,
  1661.219,
  1760,
  1864.655,
  1975.533,
  // octave 6
  2093.005,
  2217.461,
  2349.318,
  2489.016,
  2637.02,
  2793.826,
  2959.955,
  3135.963,
  3322.438,
  3520,
  3729.31,
  3951.066,
  // octave 7
  4186.009,
  4434.922,
  4698.636,
  4978.032,
  5274.041,
  5587.652,
  5919.911,
  6271.927,
  6644.875,
  7040,
  7458.62,
  7902.133
  // octave 8
], Ip = "http://www.w3.org/2000/svg", uR = {
  bar: {
    "chart.orientation": "east",
    "axis.vert.labelOrder": "northToSouth",
    "axis.horiz.ticks.isDrawTicks": !1,
    "grid.isDrawHorizLines": !1
  },
  column: {
    "axis.horiz.ticks.isDrawTicks": !0,
    "axis.vert.line.isDrawOverhang": !0,
    "grid.isDrawVertLines": !1
  },
  line: {
    "grid.isDrawVertLines": !1
  }
}, i8e = {
  chart: {
    type: "bar",
    size: {
      width: 600,
      height: 450
    },
    title: {
      isDrawTitle: !0,
      margin: 40,
      fontSize: "12pt",
      align: "center",
      position: "top"
    },
    orientation: "north",
    padding: "8 20",
    //chartType: 'line'
    fontFamily: "Helvetica, sans-serif",
    fontWeight: "300",
    fontScale: 1,
    stroke: "purple",
    strokeWidth: 4,
    strokeHighlightScale: 1.5,
    symbolStrokeWidth: 2,
    symbolHighlightScale: 1.5,
    hasDirectLabels: !0,
    directLabelFontSize: "10pt",
    hasLegendWithDirectLabels: !1,
    isDrawSymbols: !0,
    isStatic: !1,
    isShowVisitedDatapointsOnly: !1,
    isShowPopups: !1
  },
  axis: {
    minInterval: 25,
    datapointMargin: 3,
    horiz: {
      isDrawAxis: !0,
      position: "south",
      title: {
        isDrawTitle: !1,
        gap: 8,
        fontSize: "12pt"
      },
      ticks: {
        isDrawTicks: !1,
        padding: 3,
        opacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        length: 10,
        labelFormat: "raw",
        labels: {
          isDrawTickLabels: !0,
          fontSize: "10pt",
          angle: -45,
          offsetGap: 4,
          gap: 0
        },
        step: 1
      },
      line: {
        isDrawAxisLine: !0,
        isDrawOverhang: !0,
        strokeWidth: 2,
        strokeLinecap: "round"
      },
      labelOrder: "westToEast",
      interval: "unset"
    },
    vert: {
      isDrawAxis: !0,
      position: "west",
      title: {
        isDrawTitle: !0,
        gap: 8,
        fontSize: "12pt"
      },
      ticks: {
        isDrawTicks: !0,
        padding: 3,
        opacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        length: 10,
        labelFormat: "raw",
        labels: {
          isDrawTickLabels: !0,
          fontSize: "10pt",
          angle: 0,
          offsetGap: 0,
          gap: 0
        },
        step: 1
      },
      line: {
        isDrawAxisLine: !0,
        isDrawOverhang: !0,
        strokeWidth: 2,
        strokeLinecap: "round"
      },
      labelOrder: "southToNorth"
    },
    x: {
      minValue: "unset",
      maxValue: "unset",
      interval: "unset"
    },
    y: {
      minValue: "unset",
      maxValue: "unset",
      interval: "unset"
    }
  },
  legend: {
    isDrawLegend: !0,
    isDrawLegendWhenNeeded: !0,
    isAlwaysDrawLegend: !1,
    boxStyle: {
      outline: "none",
      //outline: 'gray',
      outlineWidth: 1,
      fill: "none"
      //fill: 'aliceblue',
    },
    padding: 10,
    symbolLabelGap: 5,
    pairGap: 30,
    position: "east",
    margin: 20,
    itemOrder: "series",
    fontSize: "10pt"
  },
  plotArea: {
    size: {
      width: 600,
      height: 250
    }
  },
  popup: {
    opacity: 1,
    leftPadding: 10,
    rightPadding: 10,
    upPadding: 10,
    downPadding: 10,
    margin: 40,
    maxWidth: 175,
    shape: "boxWithArrow",
    activation: "onHover",
    borderRadius: 10,
    backgroundColor: "dark"
  },
  type: {
    bar: {
      stacking: "standard",
      barWidth: 20,
      colorByDatapoint: !1,
      isDrawTotalLabels: !0,
      stackLabelGap: 10,
      isDrawRecordLabels: !1,
      isDrawDataLabels: !1,
      dataLabelPosition: "center",
      clusterBy: void 0,
      clusterGap: 0,
      isAbbrevSeries: !0,
      orderBy: void 0,
      barGap: 2,
      //stackInsideGap: 4,
      clusterLabelFormat: "raw",
      lineWidth: 5,
      isShowPopups: !1,
      labelFontSize: "8pt"
    },
    column: {
      stacking: "standard",
      barWidth: 10,
      colorByDatapoint: !1,
      isDrawTotalLabels: !1,
      isDrawRecordLabels: !1,
      isDrawDataLabels: !1,
      dataLabelPosition: "center",
      stackLabelGap: 10,
      clusterBy: void 0,
      clusterGap: 2,
      isAbbrevSeries: !0,
      orderBy: void 0,
      barGap: 20,
      //stackInsideGap: 0,
      clusterLabelFormat: "raw",
      lineWidth: 5,
      isShowPopups: !1,
      labelFontSize: "8pt"
    },
    line: {
      lineWidth: 5,
      lineWidthMax: 25,
      lowVisionLineWidth: 15,
      lineHighlightScale: 1.5,
      baseSymbolSize: 10,
      seriesLabelPadding: 5,
      pointLabelFormat: "raw",
      leaderLineLength: 30,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      },
      isDrawSymbols: !0,
      isShowPopups: !1,
      isTrendNavigationModeEnabled: !1
    },
    scatter: {
      isDrawTrendLine: !1,
      isShowOutliers: !1,
      pointLabelFormat: "raw",
      symbolStrokeWidth: 2,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      }
    },
    histogram: {
      pointLabelFormat: "raw",
      bins: 20,
      displayAxis: "x",
      groupingAxis: "",
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      },
      relativeAxes: "Counts"
    },
    heatmap: {
      pointLabelFormat: "raw",
      resolution: 20,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      }
    },
    pie: {
      outsideLabels: {
        vertGap: 10,
        arcGap: 10,
        horizShift: 15,
        horizPadding: 10,
        leaderStyle: "direct",
        format: "raw",
        underlineGap: 2,
        contents: "percentage:(value)"
      },
      insideLabels: {
        format: "raw",
        position: 0.9,
        contents: "category"
      },
      isRenderCenterLabel: !0,
      annularThickness: 1,
      centerLabel: "none",
      centerLabelPadding: 10,
      orientationAngleOffset: 90,
      explode: "",
      explodeDistance: 20
    },
    donut: {
      outsideLabels: {
        vertGap: 10,
        arcGap: 10,
        horizShift: 15,
        horizPadding: 10,
        leaderStyle: "direct",
        format: "raw",
        underlineGap: 2,
        contents: "percentage:(value)"
      },
      insideLabels: {
        format: "raw",
        position: 0.85,
        contents: "category"
      },
      isRenderCenterLabel: !0,
      annularThickness: 0.5,
      centerLabel: "title",
      centerLabelPadding: 15,
      orientationAngleOffset: 90,
      explode: "",
      explodeDistance: 20
    },
    gauge: {
      outsideLabels: {
        vertGap: 4,
        arcGap: 10,
        horizShift: 15,
        horizPadding: 10,
        leaderStyle: "direct",
        format: "raw",
        underlineGap: 6,
        contents: "percentage:(value)"
      },
      insideLabels: {
        format: "raw",
        position: 0.85,
        contents: "category"
      },
      isRenderCenterLabel: !0,
      annularThickness: 0.5,
      centerLabel: "none",
      centerLabelPadding: 10,
      orientationAngleOffset: 90,
      explode: "",
      explodeDistance: 20
    },
    stepline: {
      lineWidth: 5,
      lineWidthMax: 25,
      baseSymbolSize: 10,
      seriesLabelPadding: 5,
      pointLabelFormat: "raw",
      leaderLineLength: 30,
      symbolStrokeWidth: 2,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      }
    },
    lollipop: {
      stacking: "standard",
      barWidth: 10,
      minBarWidth: 6,
      colorByDatapoint: !1,
      isDrawTotalLabels: !1,
      stackLabelGap: 10,
      isDrawRecordLabels: !1,
      isDrawDataLabels: !1,
      dataLabelPosition: "end",
      lineWidth: 5,
      clusterBy: void 0,
      clusterGap: 5,
      isAbbrevSeries: !0,
      orderBy: void 0,
      barGap: 0.25,
      //stackInsideGap: 4,
      clusterLabelFormat: "raw",
      isShowPopups: !1,
      labelFontSize: "8pt"
    }
  },
  grid: {
    isDrawHorizLines: !0,
    isDrawVertLines: !0,
    isDrawHorizAxisOppositeLine: !0,
    isDrawVertAxisOppositeLine: !0
  },
  ui: {
    isVoicingEnabled: !1,
    isNarrativeHighlightEnabled: !1,
    isNarrativeHighlightPaused: !1,
    isAnnouncementEnabled: !0,
    speechRate: 1.3,
    isFullscreenEnabled: !1,
    isLowVisionModeEnabled: !1,
    isFocusRingEnabled: !1,
    focusRingGap: 10,
    navRunTimeoutMs: 125
  },
  animation: {
    isAnimationEnabled: !0,
    animateRevealTimeMs: 2500,
    popInAnimateRevealTimeMs: 750,
    animationType: "uniform",
    animationOrigin: "initialValue",
    animationOriginValue: 0,
    expandPoints: !0,
    lineSnake: !1,
    symbolPopIn: !1
  },
  scrollytelling: {
    isScrollytellingEnabled: !0,
    isScrollyAnnouncementsEnabled: !0,
    isScrollySoniEnabled: !0
  },
  controlPanel: {
    isControlPanelDefaultOpen: !0,
    tabLabelStyle: "label",
    isCaptionVisible: !0,
    isExplorationBarVisible: !0,
    caption: {
      isCaptionExternalWhenControlPanelClosed: !0,
      hasBorder: !1,
      isExplorationBarBeside: !0
    },
    isSparkBrailleVisible: !1,
    isSparkBrailleControlVisible: !0,
    isMDRAnnotationsVisible: !1,
    isDataTabVisible: !0,
    isColorsTabVisible: !0,
    isAudioTabVisible: !0,
    isControlsTabVisible: !0,
    isChartTabVisible: !0,
    isAnnotationsTabVisible: !0,
    isAnalysisTabVisible: !0,
    isColorPaletteControlVisible: !0,
    isCVDControlVisible: !0
  },
  color: {
    colorVisionMode: "normal",
    isDarkModeEnabled: !1,
    contrastLevel: 1,
    colorPalette: "diva"
  },
  jim: {
    xValueFormat: "raw"
  },
  dataTable: {
    xValueFormat: "raw",
    yValueFormat: "raw"
  },
  statusBar: {
    valueFormat: "raw"
  },
  sonification: {
    isSoniEnabled: !1,
    isRiffEnabled: !0,
    isNotificationEnabled: !0,
    hertzLower: 35,
    hertzUpper: Q4.length - 12,
    soniPlaySpeed: 3,
    riffSpeed: "medium",
    riffSpeedIndex: 2,
    isArpeggiateChords: !0
  },
  dev: {
    isDebug: !1,
    isShowGridTerritories: !1
  }
};
class eU {
  constructor(e) {
    this._store = e, this.keys = /* @__PURE__ */ new Map(), this._colorMap = null, this.primary = "hsl(270, 50%, 50%)", this.accent = "hsl(270, 50%, 25%)", this.active = "hsl(270, 50%, 65%)", this._prevSelectedColor = "", this.palettes = [
      {
        key: "diva",
        title: "diva (color-blind safe)",
        colors: [
          {
            value: "hsl(227, 26%, 52%)",
            name: "blue-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(13, 58%, 35%)",
            name: "red-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(109, 93%, 24%)",
            name: "green-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(300, 50%, 50%)",
            name: "purple-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(180, 100%, 25%)",
            name: "blue-green-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(40, 98%, 69%)",
            name: "yellow",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(215, 37%, 66%)",
            name: "light blue",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(63, 100%, 23%)",
            name: "olive green",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(34, 57%, 46%)",
            name: "caramel",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(51, 56%, 64%)",
            name: "tan",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(85, 65%, 36%)",
            name: "forest green"
          },
          {
            value: "hsl(12, 56%, 51%)",
            name: "red-orange"
          },
          {
            value: "hsl(30, 42%, 35%)",
            name: "brown"
          },
          {
            value: "hsl(240, 100%, 50%)",
            name: "bright blue"
          },
          {
            value: "hsl(120, 100%, 50%)",
            name: "lime green"
          },
          {
            value: "hsl(39, 100%, 50%)",
            name: "orange",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(300, 100%, 25%)",
            name: "royal purple"
          },
          {
            value: "hsl(51, 100%, 50%)",
            name: "lemon yellow"
          },
          {
            value: "hsl(328, 100%, 54%)",
            name: "fuschia"
          },
          {
            value: "hsl(177, 70%, 41%)",
            name: "cyan"
          },
          {
            value: "hsl(234, 20.5%, 47.8%)",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "warm",
        title: "warm hues (color-blind safe)",
        colors: [
          {
            value: "hsl(38, 96%, 58%)",
            name: "orange"
          },
          {
            value: "hsl(82, 77%, 40%)",
            name: "green"
          },
          {
            value: "hsl(54, 81%, 73%)",
            name: "yellow"
          },
          {
            value: "hsl(22, 97%, 51%)",
            name: "red"
          },
          {
            value: "hsl(77, 98%, 25%)",
            name: "forest green"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "cold",
        title: "cold hues (color-blind safe)",
        colors: [
          {
            value: "hsl(223, 100%, 70%)",
            name: "blue"
          },
          {
            value: "hsl(331, 72%, 51%)",
            name: "pink"
          },
          {
            value: "hsl(23, 100%, 50%)",
            name: "tangerine"
          },
          {
            value: "hsl(251, 83%, 65%)",
            name: "purple"
          },
          {
            value: "hsl(41, 100%, 50%)",
            name: "orange"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "rainbow",
        title: "rainbow (color-blind safe)",
        colors: [
          {
            value: "hsl(270, 100%, 29%)",
            name: "purple"
          },
          {
            value: "hsl(330, 100%, 71%)",
            name: "pink"
          },
          {
            value: "hsl(30, 100%, 43%)",
            name: "cinnamon"
          },
          {
            value: "hsl(180, 100%, 14%)",
            name: "green"
          },
          {
            value: "hsl(210, 100%, 43%)",
            name: "blue"
          },
          {
            value: "hsl(0, 100%, 29%)",
            name: "red"
          },
          {
            value: "hsl(120, 100%, 57%)",
            name: "pale green"
          },
          {
            value: "hsl(60, 100%, 71%)",
            name: "pale yellow"
          },
          {
            value: "hsl(330, 100%, 86%)",
            name: "pale pink"
          },
          {
            value: "hsl(210, 100%, 86%)",
            name: "pale blue"
          },
          {
            value: "hsl(30, 100%, 29%)",
            name: "brown"
          },
          {
            value: "hsl(180, 100%, 29%)",
            name: "blue-gree"
          },
          {
            value: "hsl(270, 100%, 71%)",
            name: "lavendar"
          },
          {
            value: "hsl(210, 100%, 71%)",
            name: "light blue"
          },
          {
            value: "hsl(0, 0%, 0%)",
            name: "black"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "ffb",
        title: "FFB",
        colors: [
          {
            value: "hsl(4, 50%, 52%)",
            //'rgb(210,67,62)',
            name: "red",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(39, 70%, 44%)",
            // rgb(246,171,6)',
            name: "yellow",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(131, 100%, 18%)",
            // 'rgb(33,131,57)',
            name: "green",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(210, 25%, 25%)",
            //'rgb(38,121,153)',
            name: "blue",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(4, 50%, 52%)",
            //'rgb(42,64,81)',
            name: "indigo",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "rgb(13,53,67)",
            name: "slate",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "rgb(48,64,69)",
            name: "dark gray",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(0, 0%, 80%)",
            // 'rgb(204,204,204)',
            name: "light gray",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            name: "no_opinion",
            value: "hsl(0, 0%, 80%)",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            name: "very_unrewarding",
            value: "hsl(4, 50%, 52%)"
          },
          {
            name: "neutral",
            value: "hsl(39, 70%, 44%)"
          },
          {
            name: "somewhat_rewarding",
            value: "hsl(131, 100%, 18%)"
          },
          {
            name: "very_rewarding",
            value: "hsl(210, 25%, 25%)"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "deutan",
        title: "deutan",
        cvd: !0,
        colors: [
          {
            value: "hsl(300, 100%, 25%)",
            name: ""
          },
          {
            value: "hsl(300, 100%, 50%)",
            name: ""
          },
          {
            value: "hsl(320, 100%, 40%)",
            name: ""
          },
          {
            value: "hsl(329, 100%, 49%)",
            name: ""
          },
          {
            value: "hsl(300, 100%, 35%)",
            name: ""
          },
          {
            value: "hsl(210, 43%, 47%)",
            name: ""
          },
          {
            value: "hsl(353, 80%, 67%)",
            name: ""
          },
          {
            value: "hsl(130, 60%, 33%)",
            name: ""
          },
          {
            value: "hsl(52, 57%, 53%)",
            name: ""
          },
          {
            value: "hsl(195, 80%, 67%)",
            name: ""
          },
          {
            value: "hsl(326, 54%, 43%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "protan",
        title: "protan",
        cvd: !0,
        colors: [
          {
            value: "hsl(39, 70%, 54%)",
            name: ""
          },
          {
            value: "hsl(206, 68%, 66%)",
            name: ""
          },
          {
            value: "hsl(154, 39%, 44%)",
            name: ""
          },
          {
            value: "hsl(56, 81%, 66%)",
            name: ""
          },
          {
            value: "hsl(209, 57%, 43%)",
            name: ""
          },
          {
            value: "hsl(24, 68%, 46%)",
            name: ""
          },
          {
            value: "hsl(324, 35%, 62%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "tritan",
        title: "tritan",
        cvd: !0,
        colors: [
          {
            value: "hsl(210, 60%, 67%)",
            name: ""
          },
          {
            value: "hsl(200, 100%, 80%)",
            name: ""
          },
          {
            value: "hsl(163, 47%, 50%)",
            name: ""
          },
          {
            value: "hsl(67, 60%, 50%)",
            name: ""
          },
          {
            value: "hsl(60, 100%, 33%)",
            name: ""
          },
          {
            value: "hsl(50, 75%, 73%)",
            name: ""
          },
          {
            value: "hsl(348, 100%, 83%)",
            name: ""
          },
          {
            value: "hsl(210, 60%, 67%)",
            name: ""
          },
          {
            value: "hsl(200, 100%, 80%)",
            name: ""
          },
          {
            value: "hsl(163, 47%, 50%)",
            name: ""
          },
          {
            value: "hsl(67, 60%, 50%)",
            name: ""
          },
          {
            value: "hsl(60, 100%, 33%)",
            name: ""
          },
          {
            value: "hsl(50, 75%, 73%)",
            name: ""
          },
          {
            value: "hsl(348, 100%, 83%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "grayscale",
        title: "grayscale",
        cvd: !0,
        colors: [
          {
            value: "hsl(0, 0%, 15%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 35%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 50%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 63%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 73%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 83%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 93%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 15%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 35%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 50%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 63%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 73%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 83%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 93%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "pattern",
        title: "pattern",
        isPattern: !0,
        colors: [
          {
            value: "hsl(225, 30%, 52%)",
            name: "blue"
          },
          {
            value: "hsl(12, 69%, 35%)",
            name: "red"
          },
          {
            value: "hsl(75, 43%, 45%)",
            name: "green"
          },
          {
            value: "hsl(40, 98%, 69%)",
            name: "yellow"
          },
          {
            value: "hsl(215, 37%, 66%)",
            name: "light blue"
          },
          {
            value: "hsl(63, 100%, 23%)",
            name: "olive green"
          },
          {
            value: "hsl(34, 57%, 46%)",
            name: "caramel"
          },
          {
            value: "hsl(51, 56%, 64%)",
            name: "tan"
          },
          {
            value: "hsl(253, 26%, 43%)",
            name: "purple"
          },
          {
            value: "hsl(85, 65%, 36%)",
            name: "forest green"
          },
          {
            value: "hsl(12, 56%, 51%)",
            name: "red-orange"
          },
          {
            value: "hsl(30, 42%, 35%)",
            name: "brown"
          },
          {
            value: "hsl(240, 100%, 50%)",
            name: "bright blue"
          },
          {
            value: "hsl(120, 100%, 50%)",
            name: "lime green"
          },
          {
            value: "hsl(39, 100%, 50%)",
            name: "orange"
          },
          {
            value: "hsl(300, 100%, 25%)",
            name: "royal purple"
          },
          {
            value: "hsl(51, 100%, 50%)",
            name: "lemon yellow"
          },
          {
            value: "hsl(328, 100%, 54%)",
            name: "fuschia"
          },
          {
            value: "hsl(177, 70%, 41%)",
            name: "cyan"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ],
        patterns: [
          {
            value: Tt`
              <pattern id="Pattern0"  patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(45)">
                <line class="pattern" x1="0" y="0" x2="0" y2="10" stroke='hsl(225, 30%, 52%)' stroke-width="5" />
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "diagonal_lines"
          },
          {
            value: Tt`
              <pattern id="Pattern1" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10">
                <circle cx="5" cy="5" r="2" fill='hsl(12, 69%, 35%)' />
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "dots"
          },
          {
            value: Tt`
              <pattern id="Pattern2" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10">
                <path d="M 10 0 L 0 0 0 10" fill="none" stroke='hsl(75, 43%, 45%)' stroke-width="5"/>
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "grid"
          },
          {
            value: Tt`
              <pattern id="Pattern3" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10">
                <path d="M 0 0 L 10 10 M 10 0 L 0 10" stroke='hsl(40, 98%, 69%)' stroke-width="3"/>
              </pattern>
               `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "crosshatch"
          },
          {
            value: Tt`
              <pattern id="Pattern4" class="pattern" patternUnits="userSpaceOnUse" width="20" height="10">
                <path d="M 0 5 Q 5 0, 10 5 T 20 5" fill="none" stroke='hsl(215, 37%, 66%)' stroke-width="3"/>
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "waves"
          },
          {
            value: Tt`
              <pattern id="Pattern5" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(135)">
                <line x1="0" y="0" x2="0" y2="10" stroke='hsl(63, 100%, 23%)' stroke-width="5" />
              </pattern>`,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "diagonal_lines2"
          },
          {
            value: Tt`
              <pattern id="Pattern6" class="pattern" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
              <circle cx="10" cy="10" r="10" fill='hsl(34, 57%, 46%)'" />
              </pattern>`,
            contrastValue: "hsl(0, 0%, 0%)",
            name: ""
          },
          {
            value: Tt`hsl(0, 100%, 50%)`,
            name: "visit"
          }
        ]
      },
      {
        key: "low-vision",
        title: "low-vision",
        colors: [
          {
            value: "hsl(240, 100%, 60%)",
            name: "blue-2",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(13, 58%, 35%)",
            name: "red-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(120, 100%, 33%)",
            name: "green-2",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(300, 77%, 54%)",
            name: "magenta-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(39, 100%, 31%)",
            name: "brown-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(40, 98%, 69%)",
            name: "yellow",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(215, 37%, 66%)",
            name: "light blue",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(63, 100%, 23%)",
            name: "olive green",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(34, 57%, 46%)",
            name: "caramel",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(51, 56%, 64%)",
            name: "tan",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(85, 65%, 36%)",
            name: "forest green"
          },
          {
            value: "hsl(12, 56%, 51%)",
            name: "red-orange"
          },
          {
            value: "hsl(30, 42%, 35%)",
            name: "brown"
          },
          {
            value: "hsl(240, 100%, 50%)",
            name: "bright blue"
          },
          {
            value: "hsl(120, 100%, 50%)",
            name: "lime green"
          },
          {
            value: "hsl(39, 100%, 50%)",
            name: "orange",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(300, 100%, 25%)",
            name: "royal purple"
          },
          {
            value: "hsl(51, 100%, 50%)",
            name: "lemon yellow"
          },
          {
            value: "hsl(328, 100%, 54%)",
            name: "fuschia"
          },
          {
            value: "hsl(177, 70%, 41%)",
            name: "cyan"
          },
          {
            value: "hsl(234, 20.5%, 47.8%)",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      }
    ], e.settings.color.colorMap && this.setColorMap(...e.settings.color.colorMap.split(",").map((r) => r.trim()));
  }
  get paletteKey() {
    return this._store.settings.color.colorVisionMode === "normal" ? this._store.settings.color.colorPalette : this._store.settings.color.colorVisionMode;
  }
  get palette() {
    const e = this.palettes[this.indexOfPalette(this.paletteKey)];
    if (e)
      return e;
    throw new Error(`no palette named '${this.paletteKey}'`);
  }
  get prevSelectedColor() {
    return this._prevSelectedColor;
  }
  setColorMap(...e) {
    e.includes("visit") || e.push("visit");
    for (const r of e) {
      const n = this.colorIndex(r);
      if (n === -1)
        throw new Error(`no color named '${r}' in current palette`);
      this._colorMap || (this._colorMap = []), this._colorMap.push(n);
    }
  }
  addPalette(e) {
    this.palettes.push(e);
  }
  indexOfPalette(e) {
    return this.palettes.findIndex((r) => r.key === e);
  }
  colorAt(e) {
    var r;
    return ((r = this.palette.colors[e]) == null ? void 0 : r.name) ?? "default";
  }
  /**
   * Wrap color index if out of range.
   * @param index
   * @returns valid index
   */
  wrapColorIndex(e) {
    return e % this.palette.colors.length;
  }
  /**
   * Get palette index of a color.
   * @param name
   * @returns index or -1 if not found
   */
  colorIndex(e) {
    return this.palette.colors.findIndex((r) => r.name === e);
  }
  /**
   * Get palette index of a color value.
   * @param value
   * @returns index or -1 if not found
   */
  colorValueIndex(e) {
    return this.palette.colors.findIndex((r) => r.value === e);
  }
  colorValue(e) {
    if (e === "default")
      return "hsl(0, 0%, 50%)";
    const r = this.palette.colors.find((n) => n.name === e);
    if (!r)
      throw new Error(`no color named '${e}'`);
    return r.value;
  }
  colorValueAt(e) {
    const r = this._colorMap ? this._colorMap.map((n) => this.palette.colors[n]) : this.palette.colors;
    return e === -1 ? r.at(-1).value : e === -2 ? r.at(-2).value : r[e % (r.length - 1)].value;
  }
  patternValueAt(e) {
    const r = this.palette.patterns;
    return e === -1 ? r.at(-1).value : r[e % (r.length - 1)].value;
  }
  contrastValueAt(e) {
    const r = this.palette.isPattern ? this.palette.patterns : this._colorMap ? this._colorMap.map((n) => this.palette.colors[n]) : this.palette.colors;
    return e === -1 ? r.at(-1).contrastValue : r[e % (r.length - 1)].contrastValue ?? "hsl(0, 0%, 100%)";
  }
  registerKey(e) {
    this.keys.has(e) || this.keys.set(e, {
      index: this.keys.size,
      base: null,
      light: null,
      dark: null
    });
  }
  getPaletteList() {
  }
  // set_colors(color_obj: Colors) {
  //   if (!color_obj.palette) {
  //     // if no palette, use the default palette
  //     this.setPalette(0);
  //   } else {
  //     // if palette, append the default palette to the supplied palette, for more values
  //     this.palette = color_obj.palette.concat(this.palette);
  //   }
  //   this.primary = color_obj.primary;
  //   this.accent = color_obj.accent;
  //   this.active = color_obj.active;
  // }
  selectPaletteWithKey(e) {
    this._prevSelectedColor = this.paletteKey, this._store.updateSettings((r) => {
      r.color.colorPalette = e;
    });
  }
  /*get_palettes  ( palette_ids ) {
      if (!palette_ids) {
        return this.palettes;
      }
  
      if ( `string` === typeof palette_ids) {
        return this.palettes[palette_ids];
      }
  
      let palettes = [];
      for (let i = 0, i_len = palette_ids.length; i_len > i; ++i) {
        let palette = this.palettes[palette_ids[i]];
        if (!palette) {
          palette = this.palettes[`palette-${palette_ids[i]}`];
        }
  
        if (palette) {
          palettes.push(palette);
        }
      }
      return palettes;
    }*/
  /*set_palette_color_by_index  ( palette_id, index, color ) {
    let palette = this.palettes[palette_id];
    if (palette) {
      palette[index] = color;
    }
  }*/
  /*create_palette  ( id, colors, metadata ) {
    let palette = this.palettes[id];
    if (!palette) {
      this.palettes[id] = {};
      palette = this.palettes[id];
    }
    palette.name = metadata.name;
    palette.title = metadata.title;
    palette.type = metadata.type;
    palette.colors = colors;
  }*/
  getHslComponents(e) {
    let r = /hsl[a]?\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/, n = e.match(r);
    return {
      hue: +n[1],
      h: +n[1],
      saturation: +n[2],
      s: +n[2],
      lightness: +n[3],
      l: +n[3],
      alpha: 1,
      a: 1
    };
  }
  lighten(e, r) {
    let n = this.getHslComponents(e), i = n.hue, s = n.saturation, o = n.lightness;
    const a = Math.min(o + r * 5, 100);
    return `hsl(${i}, ${s}%, ${a}%)`;
  }
  generateSequentialPalette(e, r, n) {
    let i = this.getHslComponents(e), s = i.hue, o = i.saturation, a = i.lightness, l = o - 15;
    n && (l = 85 - o);
    let c = Math.round(l / r / 5), p = a - 15;
    n && (p = 85 - a);
    let h = Math.round(p / r), d = [];
    for (let b = 0, m = r; m > b; ++b)
      d.push(`hsl(${s}, ${o}%, ${a}%)`), n ? (o += c, a += h) : (o -= c, a -= h);
    return d;
  }
  /*generate_interpolation_palette  ( hsl1, hsl2, count, palette_id ) {
      let hsl_comp1 = this.getHslComponents(hsl1);
      let h1 = hsl_comp1.hue;
      let s1 = hsl_comp1.saturation;
      let l1 = hsl_comp1.lightness;
  
      let hsl_comp2 = this.getHslComponents(hsl2);
      let h2 = hsl_comp2.hue;
      let s2 = hsl_comp2.saturation;
      let l2 = hsl_comp2.lightness;
  
      count -= 1;
  
      let h_range = h1 - h2;
      let h_interval = h_range/count;
  
      let s_range = s1 - s2;
      let s_interval = s_range/count;
  
      let l_range = l1 - l2;
      let l_interval = l_range/count;
  
      let palette = [];
      for (let i = 0, i_len = count; i_len > i; ++i) {
        palette.push(`hsl(${Math.round(h1)}, ${Math.round(s1)}%, ${Math.round(l1)}%)`);
        h1 -= h_interval;
        s1 -= s_interval;
        l1 -= l_interval;
      }
      palette.push(`hsl(${h2}, ${s2}%, ${l2}% )`);
  
      this.create_palette( palette_id, palette,
        {
          name: palette_id,
          title: palette_id,
          type: `numeric`
        }
      )
    }*/
  /*hsl_to_hex (h, s, l) {
    // function credit to https://stackoverflow.com/questions/7609130/set-the-value-of-an-input-field
    h /= 360;
    s /= 100;
    l /= 100;
    let r, g, b;
    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    const toHex = x => {
      const hex = Math.round(x * 255).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }*/
  //https://stackoverflow.com/questions/46432335/hex-to-hsl-convert-javascript
  /*hex_to_hsl (hex, is_formatted) {
      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  
      let r = parseInt(result[1], 16);
      let g = parseInt(result[2], 16);
      let b = parseInt(result[3], 16);
  
      r /= 255, g /= 255, b /= 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
  
      if(max == min){
          h = s = 0; // achromatic
      } else {
          let d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch(max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
      }
  
      s = s*100;
      s = Math.round(s);
      l = l*100;
      l = Math.round(l);
      h = Math.round(360*h);
  
      let colorInHSL=[h,s,l];
      if (!is_formatted) {
        return colorInHSL;
      } else {
        return `hsl(${h}, ${s}%, ${l}%)`;
      }
    }*/
}
const s8e = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left",
  topLeft: "bottomRight",
  topRight: "bottomLeft",
  bottomRight: "topLeft",
  bottomLeft: "topRight"
};
function o8e(t, e = 2, r = !0) {
  return r && Math.trunc(t) === t ? t.toString() : t.toFixed(e);
}
function nt(t, ...e) {
  if (e.length === 0)
    return t[0];
  const r = t.slice(0, -1).map((n, i) => n + (typeof e[i] == "number" ? o8e(e[i]) : e[i]));
  return r.push(t.at(-1)), r.join("");
}
function KIe(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function a8e(t, e) {
  t = t.replace(/\s+/g, "_").replace(/[^\w-]+/g, "");
  let r = 0, n = t;
  for (; e.idList[n]; )
    n = t + "-" + ++r;
  return e.idList[n] = !0, n;
}
function YIe() {
  return null;
}
function ZIe(...t) {
  return new DOMRect(
    Math.min(...t.map((e) => e.left)),
    Math.min(...t.map((e) => e.top)),
    Math.max(...t.map((e) => e.width)),
    Math.max(...t.map((e) => e.height))
  );
}
function K4(...t) {
  const e = Math.min(...t.map((s) => s.left)), r = Math.max(...t.map((s) => s.right)), n = Math.min(...t.map((s) => s.top)), i = Math.max(...t.map((s) => s.bottom));
  return new DOMRect(
    e,
    n,
    r - e,
    i - n
  );
}
function JIe(t, e, r) {
  return t.seriesKey === e && t.index === r;
}
function l8e(t) {
  return s8e[t];
}
function c8e(t, e) {
  return t.documentView ? !(e.offsetX - t.documentView.padding.left - t.documentView.chartLayers.x < 0 || e.offsetX - t.documentView.padding.left - t.documentView.chartLayers.x > t.documentView.chartLayers.width || e.offsetY - t.documentView.padding.top - t.documentView.chartLayers.y < 0 || e.offsetY - t.documentView.padding.top - t.documentView.chartLayers.y > t.documentView.chartLayers.height) : !0;
}
function Y4(t, e, r) {
  const n = Date.now(), i = () => {
    let s = setTimeout(() => {
      t.requestUpdate(), i();
    }, r);
    Date.now() - n > e && clearTimeout(s);
  };
  i();
}
class Ye {
  constructor(e = 0, r = 0) {
    this._x = e, this._y = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e;
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e;
  }
  clone() {
    return new Ye(this._x, this._y);
  }
  equal(e) {
    return this._x === e._x && this._y === e._y;
  }
  setX(e) {
    return new Ye(e, this._y);
  }
  setY(e) {
    return new Ye(this._x, e);
  }
  add(e) {
    return new Ye(
      this._x + e._x,
      this._y + e._y
    );
  }
  addScalar(e) {
    return new Ye(
      this._x + e,
      this._y + e
    );
  }
  addX(e) {
    return new Ye(
      this._x + e,
      this._y
    );
  }
  addY(e) {
    return new Ye(
      this._x,
      this._y + e
    );
  }
  subtract(e) {
    return new Ye(
      this._x - e._x,
      this._y - e._y
    );
  }
  subtractScalar(e) {
    return new Ye(
      this._x - e,
      this._y - e
    );
  }
  subtractX(e) {
    return new Ye(
      this._x - e,
      this._y
    );
  }
  subtractY(e) {
    return new Ye(
      this._x,
      this._y - e
    );
  }
  multiply(e) {
    return new Ye(
      this._x * e._x,
      this._y * e._y
    );
  }
  multiplyScalar(e) {
    return new Ye(
      this._x * e,
      this._y * e
    );
  }
  divide(e) {
    return new Ye(
      this._x / e._x,
      this._y / e._y
    );
  }
  divideScalar(e) {
    return new Ye(
      this._x / e,
      this._y / e
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y;
  }
  length() {
    return Math.sqrt(this.dot(this));
  }
  normalize() {
    return this.divideScalar(this.length());
  }
  project(e) {
    return e.multiplyScalar(this.dot(e) / e.dot(e));
  }
  rotate(e) {
    const r = Math.cos(e), n = Math.sin(e), i = -n, s = r;
    return new Ye(
      this._x * r + this._y * n,
      this._x * i + this._y * s
    );
  }
  lerp(e, r) {
    return new Ye(
      this._x * (1 - r) + e._x * r,
      this._y * (1 - r) + e._y * r
    );
  }
}
class u8e {
  constructor(e, r, n, i) {
    this._centerDiffX = e, this._centerDiffY = r, this._rSumX = n, this._rSumY = i;
  }
  // {+x, -x, +y, -y}, shortest
  escape() {
    const r = [0, 0, 0, 0];
    this._centerDiffX > 0 ? (r[0] = this._rSumX - this._centerDiffX + 1e-3, r[1] = -(this._rSumX + this._centerDiffX + 1e-3)) : (r[0] = this._rSumX - this._centerDiffX + 1e-3, r[1] = -(this._rSumX + this._centerDiffX + 1e-3)), this._centerDiffY > 0 ? (r[2] = this._rSumY - this._centerDiffY + 1e-3, r[3] = -(this._rSumY + this._centerDiffY + 1e-3)) : (r[2] = this._rSumY - this._centerDiffY + 1e-3, r[3] = -(this._rSumY + this._centerDiffY + 1e-3));
    let n = 0;
    for (let i = 1; i < 4; i++)
      Math.abs(r[i]) < Math.abs(r[n]) && (n = i);
    return {
      dists: r,
      shortest: n
    };
  }
  escapeVector() {
    const r = this._rSumX - Math.abs(this._centerDiffX), n = this._rSumY - Math.abs(this._centerDiffY), i = { x: 0, y: 0 };
    return r < n ? i.x = this._centerDiffX > 0 ? r + 1e-3 : -r - 1e-3 : i.y = this._centerDiffY > 0 ? n + 1e-3 : -n - 1e-3, i;
  }
}
class h8e {
  constructor() {
    this.log = qt("BaseView"), this.isContainer = !1;
  }
  get id() {
    return "";
  }
  get x() {
    return 0;
  }
  get y() {
    return 0;
  }
  get width() {
    return 0;
  }
  get height() {
    return 0;
  }
  set width(e) {
  }
  set height(e) {
  }
  get children() {
    return [];
  }
  get padding() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  set padding(e) {
  }
  get hidden() {
    return !1;
  }
  set hidden(e) {
  }
  get el() {
    return null;
  }
  get styleInfo() {
    return {};
  }
  get classInfo() {
    return {};
  }
  renderChildren() {
    return Tt`${this.children.map((e) => e.render())}`;
  }
  content(...e) {
    return this.renderChildren();
  }
  render(...e) {
    return this.hidden ? Tt`` : this.content(...e);
  }
}
class Pr extends h8e {
  constructor(e) {
    super(), this.paraview = e, this._parent = null, this._prev = null, this._next = null, this._children = [], this._loc = new Ye(), this._locOffset = new Ye(), this._width = -1, this._height = -1, this._canWidthFlex = !1, this._canHeightFlex = !1, this._isBubbleSizeChange = !1, this._currFocus = null, this._padding = { top: 0, bottom: 0, left: 0, right: 0 }, this._hidden = !1, this._styleInfo = {}, this._classInfo = {}, this._isObserveStore = !1, this._isObserveNotices = !1;
  }
  get id() {
    return this._id;
  }
  set id(e) {
    this._id = e, this.paraview.requestUpdate();
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    if (e && this._parent)
      throw new Error("parent already set");
    if (!e) {
      if (this._parent) {
        this._parent._children.splice(this.index, 1);
        const r = this._parent;
        this._parent = null, this._prev && (this._prev._next = this._next), this._next && (this._next._prev = this._prev), this._prev = null, this._next = null, this._removedFromParent(), r._didRemoveChild(this);
      }
      return;
    }
    this._width === -1 && this._height === -1 && this.updateSize(), this._parent = e, this.index && (this._prev = e.children[this.index - 1], this._prev._next = this), this._next = e._children[this.index + 1] ?? null, this._next && (this._next._prev = this), this._addedToParent(), this._parent._didAddChild(this), this._id || (this.id = this._createId());
  }
  _createId(...e) {
    return "";
  }
  _addedToParent() {
  }
  _removedFromParent() {
  }
  _didAddChild(e) {
  }
  _didRemoveChild(e) {
  }
  get children() {
    return this._children;
  }
  get index() {
    var e;
    return ((e = this._parent) == null ? void 0 : e._children.indexOf(this)) ?? -1;
  }
  get isFocused() {
    return this._parent.currFocus === this;
  }
  get loc() {
    return this._loc.clone();
  }
  set loc(e) {
    this._loc = e;
  }
  get locOffset() {
    return this._locOffset.clone();
  }
  set locOffset(e) {
    this._locOffset = e;
  }
  // XXX These next 4 accessors are for legacy compatibility
  get _x() {
    return this._loc.x;
  }
  set _x(e) {
    this._loc.x = e;
  }
  get _y() {
    return this._loc.y;
  }
  set _y(e) {
    this._loc.y = e;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(e) {
    this._x = e;
  }
  set y(e) {
    this._y = e;
  }
  get width() {
    return this._hidden ? 0 : this._width;
  }
  get height() {
    return this._hidden ? 0 : this._height;
  }
  set width(e) {
    const r = this._width;
    this._width = e, r !== e && this._boundingSizeDidChange(r, this._height);
  }
  set height(e) {
    const r = this._height;
    this._height = e, r !== e && this._boundingSizeDidChange(this._width, r);
  }
  get paddedWidth() {
    return this._hidden ? 0 : this.width + this._padding.left + this._padding.right;
  }
  get paddedHeight() {
    return this._hidden ? 0 : this.height + this._padding.top + this._padding.bottom;
  }
  get padding() {
    return this._padding;
  }
  set padding(e) {
    const r = this._padding.top + this._padding.bottom, n = this._padding.left + this._padding.right;
    this._padding = this._expandPadding(e), (r !== this._padding.top + this._padding.bottom || n !== this._padding.left + this._padding.right) && this._boundingSizeDidChange(n + this._width, r + this._height);
  }
  _expandPadding(e, r) {
    if (typeof e == "number")
      return { top: e, bottom: e, left: e, right: e };
    {
      let n = {};
      return e.all !== void 0 && (n = { top: e.all, bottom: e.all, left: e.all, right: e.all }), e.horiz !== void 0 && (n.left = e.horiz, n.right = e.horiz), e.vert !== void 0 && (n.top = e.vert, n.bottom = e.vert), e.top !== void 0 && (n.top = e.top), e.bottom !== void 0 && (n.bottom = e.bottom), e.left !== void 0 && (n.left = e.left), e.right !== void 0 && (n.right = e.right), n.left === void 0 && (n.left = (r == null ? void 0 : r.left) ?? 0), n.right === void 0 && (n.right = (r == null ? void 0 : r.right) ?? 0), n.top === void 0 && (n.top = (r == null ? void 0 : r.top) ?? 0), n.bottom === void 0 && (n.bottom = (r == null ? void 0 : r.bottom) ?? 0), n;
    }
  }
  get canWidthFlex() {
    return this._canWidthFlex;
  }
  set canWidthFlex(e) {
    this._canWidthFlex = e;
  }
  get canHeightFlex() {
    return this._canHeightFlex;
  }
  set canHeightFlex(e) {
    this._canHeightFlex = e;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(e) {
    const r = this.paddedWidth, n = this.paddedHeight;
    this._hidden = e, (r || n) && this._boundingSizeDidChange(r, n);
  }
  get left() {
    return this._x - this._locOffset.x;
  }
  set left(e) {
    this._x = e + this._locOffset.x;
  }
  get paddedLeft() {
    return this.left - this._padding.left;
  }
  set paddedLeft(e) {
    this._x = e + this._padding.left + this._locOffset.x;
  }
  get right() {
    return this.left + this.width;
  }
  set right(e) {
    this._x = e - this.width + this._locOffset.x;
  }
  get paddedRight() {
    return this.right + this._padding.right;
  }
  set paddedRight(e) {
    this._x = e - this._padding.right - this.width + this._locOffset.x;
  }
  get centerX() {
    return this.left + this.width / 2;
  }
  set centerX(e) {
    this._x = e - this.width / 2 + this._locOffset.x;
  }
  get top() {
    return this._y - this._locOffset.y;
  }
  set top(e) {
    this._y = e + this._locOffset.y;
  }
  get paddedTop() {
    return this.top - this._padding.top;
  }
  set paddedTop(e) {
    this._y = e + this._padding.top + this._locOffset.y;
  }
  get bottom() {
    return this.top + this.height;
  }
  set bottom(e) {
    this._y = e - this.height + this._locOffset.y;
  }
  get paddedBottom() {
    return this.bottom + this._padding.bottom;
  }
  set paddedBottom(e) {
    this._y = e - this._padding.bottom - this.height + this._locOffset.y;
  }
  get centerY() {
    return this.top + this.height / 2;
  }
  set centerY(e) {
    this._y = e - this.height / 2 + this._locOffset.y;
  }
  get bbox() {
    return new DOMRect(this.left, this.top, this.width, this.height);
  }
  /**
   * Bounding box inclusive of stroke width
   */
  get outerBbox() {
    return this.bbox;
  }
  computeSize() {
    return [this.width, this.height];
  }
  setSize(e, r, n = !0) {
    const i = this._width, s = this._height;
    this._width = e, this._height = r, (i !== this._width || s !== this._height) && this._boundingSizeDidChange(i, s, n);
  }
  resize(e, r) {
    this.setSize(e, r);
  }
  get isBubbleSizeChange() {
    return this._isBubbleSizeChange;
  }
  set isBubbleSizeChange(e) {
    this._isBubbleSizeChange = e;
  }
  _boundingSizeDidChange(e, r, n = !0) {
  }
  _bubbleSizeChange() {
    this._parent._childDidResize(this);
  }
  updateSize(e = !0) {
    this.setSize(...this.computeSize(), e);
  }
  _childDidResize(e) {
  }
  snapXTo(e, r) {
    r === "start" ? this.left = e.left : r === "end" ? this.right = e.right : this.centerX = e.centerX;
  }
  snapYTo(e, r) {
    r === "start" ? this.top = e.top : r === "end" ? this.bottom = e.bottom : this.centerY = e.centerY;
  }
  get styleInfo() {
    return { ...this._styleInfo };
  }
  set styleInfo(e) {
    this._styleInfo = { ...e };
  }
  get classInfo() {
    return { ...this._classInfo };
  }
  set classInfo(e) {
    this._classInfo = { ...e };
  }
  get prev() {
    return this._prev;
  }
  get next() {
    return this._next;
  }
  get siblings() {
    return this._parent.children.filter((e) => e !== this);
  }
  get withSiblings() {
    return this._parent.children;
  }
  get cousins() {
    return this._parent.siblings.map((e) => e.children[this.index]);
  }
  get withCousins() {
    return this._parent.withSiblings.map((e) => e.children[this.index]);
  }
  get nextCousin() {
    return this._parent.next ? this.cousins[this._parent.index] : null;
  }
  get prevCousin() {
    return this._parent.prev ? this.cousins[this._parent.index - 1] : null;
  }
  get currFocus() {
    return this._currFocus;
  }
  set currFocus(e) {
    this._currFocus = e;
  }
  /*get eventActionManager() {
      return this._eventActionManager;
    }
  
    get hotkeyActionManager() {
      return this._hotkeyActionManager;
    }
  
    protected get _eventActions(): Actions<this> {
      return {};
    }
  
    protected get _hotkeyActions(): Actions<this> {
      return {};
    }
  
    get keymap(): KeyRegistrations {
      return {};
    }
  
    protected _setActions() {
      const eventActions = this._eventActions;
      if (Object.keys(eventActions).length) {
        this._eventActionManager = new EventActionManager(this, eventActions);
      }
      this._hotkeyActionManager = new HotkeyActionManager(this, this._hotkeyActions);
    }
  
    updateKeymap() {
      const keyMap = this.keymap;
      if (Object.keys(keyMap).length) {
        this._keymapManager = new KeymapManager(this);
      }
    }
  
    hotkeyInfo(key: string): HotkeyInfo | undefined {
      const action = this._keymapManager?.actionForKey(key);
      if (action) {
        return todo().canvas.hotkeyInfo(key, action, this);
      }
      if (this._parent) {
        return this._parent.hotkeyInfo(key);
      }
      return undefined;
    }*/
  intersects(e) {
    const r = this.centerX - e.centerX, n = e.paddedWidth / 2 + this.paddedWidth / 2;
    if (Math.abs(r) >= n)
      return null;
    const i = this.centerY - e.centerY, s = e.paddedHeight / 2 + this.paddedHeight / 2;
    return Math.abs(i) >= s ? null : new u8e(r, i, n, s);
  }
  async focus(e = !1, r = 0) {
    this._parent && (this._parent.currFocus && this._parent.currFocus !== this && !r && await this._parent.currFocus.blur(!1), this._parent.currFocus = this, await this._parent.focus(e, r + 1), this._currFocus ? r || await this.focusLeaf.onFocus(e) : await this.onFocus(e));
  }
  async onFocus(e = !1) {
  }
  async blur(e = !0) {
    this._parent.currFocus = null, await this.onBlur(), e && await this._parent.onFocus();
  }
  async onBlur() {
  }
  get focusLeaf() {
    return this._currFocus ? this._currFocus.focusLeaf : this;
  }
  _didAddChildToList(e) {
  }
  append(e) {
    this._children.push(e), this._didAddChildToList(e), e.parent = this;
  }
  prepend(e) {
    this._children.unshift(e), this._didAddChildToList(e), e.parent = this;
  }
  insert(e, r) {
    this._children.splice(r, 0, e), this._didAddChildToList(e), e.parent = this;
  }
  remove() {
    this.parent = null;
  }
  reverseChildren() {
    this._children.reverse(), this._children.forEach((e, r) => {
      const n = e._prev;
      e._prev = e._next, e._next = n;
    });
  }
  sortChildren(e) {
    this._children.sort(e), this._children.forEach((r, n) => {
      n === 0 ? r._prev = null : (n === this._children.length - 1 && (r._next = null), r._prev = this._children[n - 1], r._prev._next = r);
    });
  }
  clearChildren() {
    [...this._children].forEach((e) => {
      e.remove();
    });
  }
  replaceChild(e, r) {
    const n = e.index;
    e.remove(), this.insert(r, n);
  }
  settingDidChange(e, r, n) {
    this._children.forEach((i) => i.settingDidChange(e, r, n));
  }
  get isObserveStore() {
    return this._isObserveStore;
  }
  observeStore() {
    this._isObserveStore = !0, this._parent && this._parent.observeStore();
  }
  async storeDidChange(e, r) {
    this._isObserveStore && this._children.forEach((n) => {
      n.isObserveStore && n.storeDidChange(e, r);
    });
  }
  get isObserveNotices() {
    return this._isObserveNotices;
  }
  observeNotices() {
    this._isObserveNotices = !0, this._parent && this._parent.observeNotices();
  }
  noticePosted(e, r) {
    this._isObserveNotices && this._children.forEach((n) => {
      n.isObserveNotices && n.noticePosted(e, r);
    });
  }
  focusRingShape() {
    return null;
  }
  focusRingBbox() {
    return null;
  }
}
function bo(t) {
  return class extends t {
    constructor() {
      super(...arguments), this.isContainer = !0;
    }
    render() {
      if (this.hidden)
        return Tt``;
      const r = this.x + this.padding.left, n = this.y + this.padding.top;
      return e8e`
        <g
          ${this.ref}
          id=${this.id || De}
          class=${Object.keys(this.classInfo).length ? Br(this.classInfo) : De}
          style=${Object.keys(this.styleInfo).length ? mn(this.styleInfo) : De}
          role=${this.role || De}
          aria-roledescription=${this.roleDescription || De}
          transform=${r || n ? nt`translate(${r},${n})` : De}
        >
          ${this.content()}
        </g>
      `;
    }
  };
}
class p8e extends Pr {
  _createId() {
    return "chart-landing";
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get children() {
    return this._children;
  }
  get datapointViews() {
    return this._children.flatMap((e) => e.children);
  }
  get focusLeaf() {
    return super.focusLeaf;
  }
  getSeriesView(e) {
    return this._children.find((r) => r.series.key === e);
  }
  chartSummary() {
    return "At top level.";
  }
}
let tU = class Z4 extends Pr {
  constructor(e, r) {
    super(e.paraview), this.chart = e, this.seriesKey = r, this._isStyleEnabled = !1, this._series = this.chart.paraview.store.model.atKey(r);
  }
  get series() {
    return this._series;
  }
  get seriesProps() {
    return this.chart.paraview.store.seriesProperties.properties(this.seriesKey);
  }
  get siblings() {
    return super.siblings.filter((e) => e instanceof Z4);
  }
  get withSiblings() {
    return super.withSiblings.filter((e) => e instanceof Z4);
  }
  get prev() {
    return super.prev;
  }
  get next() {
    return super.next;
  }
  get currFocus() {
    return this._currFocus;
  }
  set currFocus(e) {
    super.currFocus = e;
  }
  get prevFocus() {
    return this._prevFocus;
  }
  get color() {
    return this.seriesProps.color;
  }
  get styleInfo() {
    const e = super.styleInfo;
    return this._isStyleEnabled && this._updateStyleInfo(e), e;
  }
  set styleInfo(e) {
    super.styleInfo = e;
  }
  _updateStyleInfo(e) {
    let r = this.chart.paraview.store.colors.colorValueAt(this.color);
    e.fill = r, e.stroke = r, e.strokeWidth = this.paraview.store.settings.chart.strokeWidth;
  }
  async onFocus(e = !1) {
  }
  select(e) {
  }
};
class Wv extends Pr {
  constructor(e, r) {
    super(e), this._role = "", this._ref = null, this._isPattern = !1, this._x = r.x ?? this._x, this._y = r.y ?? this._y, this._scale = r.scale ?? 1, r.strokeWidth && (this._styleInfo.strokeWidth = r.strokeWidth), r.stroke && (this._styleInfo.stroke = r.stroke), r.fill && (this._styleInfo.fill = r.fill), r.opacity !== void 0 && (this._styleInfo.opacity = r.opacity), this._isClip = !!r.isClip;
  }
  get _options() {
    return {
      x: this._x,
      y: this._y,
      fill: this._styleInfo.fill,
      stroke: this._styleInfo.stroke,
      opacity: this._styleInfo.opacity,
      strokeWidth: this._styleInfo.strokeWidth,
      scale: this._scale,
      isClip: this._isClip
    };
  }
  get role() {
    return this._role;
  }
  set role(e) {
    this._role = e;
  }
  get stroke() {
    if (this._styleInfo.stroke)
      return this._styleInfo.stroke;
    let e = this._parent;
    for (; e; ) {
      if (e.styleInfo.stroke)
        return e.styleInfo.stroke;
      e = e.parent;
    }
    return this.paraview.store.settings.chart.stroke;
  }
  set stroke(e) {
    this._styleInfo.stroke = e;
  }
  get strokeWidth() {
    if (this._styleInfo.strokeWidth !== void 0)
      return this._styleInfo.strokeWidth;
    let e = this._parent;
    for (; e; ) {
      if (e.styleInfo.strokeWidth !== void 0)
        return e.styleInfo.strokeWidth;
      e = e.parent;
    }
    return this.paraview.store.settings.chart.strokeWidth;
  }
  set strokeWidth(e) {
    this._styleInfo.strokeWidth = e;
  }
  get effectiveStrokeWidth() {
    return this.stroke === "none" ? 0 : this.strokeWidth;
  }
  get fill() {
    return this._styleInfo.fill;
  }
  set fill(e) {
    this._styleInfo.fill = e;
  }
  get outerBbox() {
    return new DOMRect(
      this.left - this.effectiveStrokeWidth / 2,
      this.top - this.effectiveStrokeWidth / 2,
      this.width + this.effectiveStrokeWidth,
      this.height + this.effectiveStrokeWidth
    );
  }
  get scale() {
    return this._scale;
  }
  set scale(e) {
    this._scale = e;
  }
  get isClip() {
    return this._isClip;
  }
  set isClip(e) {
    this._isClip = e;
  }
  get ref() {
    return this._ref;
  }
  set ref(e) {
    this._ref = e;
  }
}
class sn extends Wv {
  constructor(e, r) {
    super(e, r), this.options = r, this._width = r.width, this._height = r.height, r.isPattern && (this._isPattern = r.isPattern);
  }
  get _options() {
    let e = super._options;
    return e.width = this._width, e.height = this._height, e.isPattern = this._isPattern, e;
  }
  clone() {
    return new sn(this.paraview, this._options);
  }
  render() {
    if (this._options.isPattern) {
      let e = this.parent.parent.index;
      return this._styleInfo.fill = `url(#Pattern${e})`, Tt`
      <defs>${this.paraview.store.colors.patternValueAt(e)}</defs>
      <rect
        x=${nt`${this._x}`}
        y=${nt`${this._y}`}
        width=${nt`${this.width}`}
        height=${nt`${this.height}`}
        fill="white"
        stroke-width=2
      ></rect>
      <rect
        ${this._ref ? yt(this._ref) : void 0}
        id=${this._id || De}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : De}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : De}
        role=${this._role || De}
        x=${nt`${this._x}`}
        y=${nt`${this._y}`}
        width=${nt`${this.width}`}
        height=${nt`${this.height}`}
        @pointerenter=${this.options.pointerEnter ?? De}
        @pointerleave=${this.options.pointerLeave ?? De}
      ></rect>
    `;
    } else
      return Tt`
      <rect
        ${this._ref ? yt(this._ref) : void 0}
        id=${this._id || De}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : De}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : De}
        role=${this._role || De}
        x=${nt`${this._x}`}
        y=${nt`${this._y}`}
        width=${nt`${this.width}`}
        height=${nt`${this.height}`}
        clip-path=${this._options.isClip ? "url(#clip-path)" : De}
        @pointerenter=${this.options.pointerEnter ?? De}
        @pointerleave=${this.options.pointerLeave ?? De}
      ></rect>
    `;
  }
}
class pf extends tU {
  constructor(e) {
    super(e.chart, e.series.key), this._shapes = [], this._symbol = null, this._baseSymbolScale = 1, this._animStartState = {}, this._animEndState = {};
  }
  _addedToParent() {
    super._addedToParent();
  }
  _removedFromParent() {
    super._removedFromParent(), this._parent.chart.unregisterDatapoint(this);
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get cousins() {
    return super.cousins;
  }
  get withCousins() {
    return super.withCousins;
  }
  get nextSeriesLanding() {
    return this._parent.next;
  }
  get prevSeriesLanding() {
    return this._parent.prev;
  }
  get datapoint() {
    return this.series.datapoints[this.index];
  }
  /**
   * Identifier of the form: `${seriesKey}-${index}`
   * NB: *NOT* the same as the `id` property (the DOM ID)
   */
  get datapointId() {
    return `${this.seriesKey}-${this.index}`;
  }
  get selectedMarker() {
    return new sn(this.paraview, {
      width: this._width / 2,
      height: this._width / 2,
      x: this._x - this._width / 4,
      y: this._y - this._width / 4,
      fill: "none",
      stroke: "black",
      strokeWidth: 2,
      isClip: this.shouldClip
    });
  }
  get shapes() {
    return [...this._shapes];
  }
  get symbol() {
    return this._symbol;
  }
  set baseSymbolScale(e) {
    this._baseSymbolScale = e;
  }
  get classInfo() {
    return {
      datapoint: !0,
      visited: this.paraview.store.isVisited(this.seriesKey, this.index),
      selected: this.paraview.store.isSelected(this.seriesKey, this.index),
      highlighted: this.chart.chartInfo.isHighlighted(this.seriesKey, this.index)
    };
  }
  get color() {
    return this._isStyleEnabled ? this.index : this._parent.color;
  }
  /**
   * May be overridden to apply shape-specific style info
   * (e.g., if only a particular shape should be highlighted on visitation)
   * @param shapeIndex - Index of the shape in `_shapes`.
   * @returns Style info
   */
  _shapeStyleInfo(e) {
    return this.styleInfo;
  }
  get ref() {
    return this.chart.paraview.ref(this._id);
  }
  get el() {
    return this.ref.value;
  }
  get x() {
    return super.x;
  }
  set x(e) {
    this._shapes.forEach((r) => {
      r.x += e - this._x;
    }), this._symbol && (this._symbol.x += e - this._x), super.x = e;
  }
  get y() {
    return super.y;
  }
  set y(e) {
    this._shapes.forEach((r) => {
      r.y += e - this._y;
    }), this._symbol && (this._symbol.y += e - this._y), super.y = e;
  }
  get shouldClip() {
    const e = this.outerBbox;
    return this.paraview.store.settings.animation.isAnimationEnabled && this.paraview.store.settings.animation.lineSnake ? !0 : e.right < this.chart.x || e.bottom < this.chart.y || e.left > this.chart.right || e.top > this.chart.bottom;
  }
  _createId(...e) {
    const r = this._parent.modelIndex * this._series.length + this.index + 1;
    return this.paraview.store.jimerator.jim.selectors[`datapoint${r}`].dom.slice(1);
  }
  get id() {
    return super.id;
  }
  set id(e) {
    super.id = e, this._parent.chart.registerDatapoint(this);
  }
  /** Compute and set `x` and `y` */
  computeLocation() {
  }
  /** Do any other layout (which may depend on the location being set) */
  completeLayout() {
    if (this._createShapes(), this._createSymbol(), this._children.length === 1) {
      const e = this._children[0];
      e.id = this._id, e.role = "datapoint";
    } else
      this._children.forEach((e, r) => {
        const n = e instanceof Wv ? `${r}` : "sym";
        e.id = `${this._id}-${n}`;
      });
    this.layoutSymbol();
  }
  /**
   *
   * @param t - Value between 0 and 1
   */
  beginAnimStep(e, r) {
  }
  /**
   *
   * @param t - Value between 0 and 1
   */
  endAnimStep(e, r) {
    this.completeLayout();
  }
  /**
   * Subclasses should override this;
   * If there will be shapes, add them to `this._shapes` first,
   * THEN call `super._createShapes()`.
   * Otherwise, override with an empty method.
   */
  _createShapes() {
    this._shapes.forEach((e) => {
      this.append(e);
    });
  }
  _createSymbol() {
    var n;
    let r = this.seriesProps.symbol;
    (n = this._symbol) == null || n.remove(), this._symbol = Fa.fromType(this.paraview, r), this.append(this._symbol);
  }
  layoutSymbol() {
    this._symbol && (this._symbol.x = this._x, this._symbol.y = this._y);
  }
  get symbolScale() {
    return this.paraview.store.isVisited(this.seriesKey, this.index) ? this.paraview.store.settings.chart.symbolHighlightScale * this._baseSymbolScale : this.chart.chartInfo.isHighlighted(this.seriesKey, this.index) ? 1 : this._baseSymbolScale;
  }
  get _symbolColor() {
    return this.paraview.store.isVisited(this.seriesKey, this.index) ? -1 : this.color;
  }
  _contentUpdateShapes() {
    this._shapes.forEach((e, r) => {
      e.styleInfo = this._shapeStyleInfo(r);
    });
  }
  _contentUpdateSymbol() {
    this._symbol && (this._symbol.scale = this.symbolScale, this._symbol.color = this._symbolColor, this._symbol.hidden = !this.paraview.store.settings.chart.isDrawSymbols);
  }
  content() {
    if (this._contentUpdateShapes(), this._contentUpdateSymbol(), this._children.length === 1) {
      const e = this._children[0];
      return e.classInfo = this.classInfo, super.content();
    } else
      return Tt`
        <g
          id=${this._id}
          class=${Br(this.classInfo)}
          role="datapoint"
        >
          ${super.content()}
        </g>`;
  }
  equals(e) {
    return this.datapoint.seriesKey === e.datapoint.seriesKey && this.datapoint.datapointIndex === e.datapoint.datapointIndex;
  }
  addPopup(e) {
  }
  removePopup(e) {
  }
}
class I9 extends bo(tU) {
  constructor(e, r, n) {
    super(e, r), this._isStyleEnabled = n ?? !0;
  }
  _createId() {
    return `series-${Yn(this.seriesKey)}`;
  }
  _seriesRef(e) {
    return this.chart.paraview.ref(`series.${e}`);
  }
  get ref() {
    return yt(this._seriesRef(this._series.key));
  }
  get class() {
    return "series";
  }
  get classInfo() {
    return {
      series: !0,
      lowlight: this.paraview.store.isSeriesLowlighted(this._series.key),
      hidden: this.paraview.store.isSeriesHidden(this._series.key)
    };
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  // @ts-ignore
  get children() {
    return this._children;
  }
  get modelIndex() {
    return this.paraview.store.model.seriesKeys.indexOf(this.seriesKey);
  }
  _updateStyleInfo(e) {
    super._updateStyleInfo(e), this.chart.updateSeriesStyle(e);
  }
  nextSeriesLanding() {
    return this._next;
  }
  prevSeriesLanding() {
    return this._prev;
  }
}
const eu = 100;
function d8e() {
  const t = Math.sqrt(eu / Math.PI), e = t * 2;
  return {
    path: nt`m0,${-t} a${t},${t} 0 1,1 0,${e} a${t},${t} 0 1,1 0,${-e}`,
    baseWidth: e,
    baseHeight: e
  };
}
function f8e() {
  const t = Math.sqrt(eu), e = t / 2;
  return {
    path: `m${-e},${-e} h${t} v${t} h${-t} z`,
    baseWidth: t,
    baseHeight: t
  };
}
function g8e() {
  const t = Math.sqrt(0.75), e = Math.sqrt(2 * eu / t), r = e * t;
  return {
    path: nt`m${-e / 2},${r / 2.5} h${e} l${-e / 2},${-r} z`,
    baseWidth: e,
    baseHeight: r
  };
}
function m8e() {
  const t = Math.sqrt(0.75), e = Math.sqrt(2 * eu / t), r = e * t;
  return {
    path: nt`m${-e / 2},-${r / 2.5} h${e} l${-e / 2},${r} z`,
    baseWidth: e,
    baseHeight: r
  };
}
function y8e() {
  const t = Math.sqrt(eu), e = Math.sqrt(2 * t ** 2) / 2;
  return {
    path: nt`
      m0,-${e}
      l${e},${e}
      l-${e},${e}
      l-${e},-${e} z`,
    baseWidth: e * 2,
    baseHeight: e * 2
  };
}
function b8e() {
  const t = eu / 5, e = Math.sqrt(t);
  return {
    path: nt`
      m${-e * 1.5},${e / 2}
      h${e}
      v${e}
      h${e}
      v${-e}
      h${e}
      v${-e}
      h${-e}
      v${-e}
      h${-e}
      v${e}
      h${-e} z`,
    baseWidth: e * 3,
    baseHeight: e * 3
  };
}
function v8e() {
  const t = eu / 5, e = Math.sqrt(t), r = Math.sqrt(2 * e ** 2) / 2;
  return {
    path: nt`
      m-${r},0
      l-${r},-${r}
      l${r},-${r}
      l${r},${r}
      l${r},-${r}
      l${r},${r}
      l-${r},${r}
      l${r},${r}
      l-${r},${r}
      l-${r},-${r}
      l-${r},${r}
      l-${r},-${r} z`,
    baseWidth: r * 3,
    baseHeight: r * 3
  };
}
function w8e() {
  const t = eu / 2, e = Math.sqrt(t / 1.72), n = (100 - t) / 5 * 2 / e, i = Math.sqrt((e / 2) ** 2 + n ** 2), s = 2 * 180 * Math.atan(e / 2 / n) / Math.PI, o = s + 72, a = o - s / 2 - 90, l = Math.cos(a * Math.PI / 180) * i, c = Math.sin(a * Math.PI / 180) * i, h = 180 - (90 - a) - s, d = 90 - h, b = o - d, m = Math.sin(h * Math.PI / 180) * i, w = Math.cos(h * Math.PI / 180) * i, f = Math.cos(b * Math.PI / 180) * i, E = Math.sin(b * Math.PI / 180) * i, A = Math.sin(o / 2 * Math.PI / 180) * i, x = Math.cos(o / 2 * Math.PI / 180) * i, g = 0.6682 * e;
  return {
    path: nt`
      m-${e / 2},-${g}
      l${e / 2},-${n}
      l${e / 2},${n}
      l${l},${c}
      l-${m},${w}
      l${f},${E}
      l-${A},-${x}
      l-${A},${x}
      l${f},-${E}
      l-${m},-${w} z`,
    baseWidth: l * 2 + e,
    baseHeight: n + c + +w + E
  };
}
const X3 = {
  circle: d8e(),
  square: f8e(),
  triangle_up: g8e(),
  triangle_down: m8e(),
  diamond: y8e(),
  plus: b8e(),
  x: v8e(),
  star: w8e()
};
class Fa extends Pr {
  constructor(e, r, n, i) {
    super(e), this._role = "", this._options = {
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? this.paraview.store.settings.chart.symbolStrokeWidth,
      scale: (i == null ? void 0 : i.scale) ?? 1,
      color: i == null ? void 0 : i.color,
      opacity: i == null ? void 0 : i.opacity,
      dashed: (i == null ? void 0 : i.dashed) ?? !1,
      lighten: (i == null ? void 0 : i.lighten) ?? !1,
      isClip: (i == null ? void 0 : i.isClip) ?? !1,
      pointerEnter: i == null ? void 0 : i.pointerEnter,
      pointerLeave: i == null ? void 0 : i.pointerLeave
    }, this.type = `${r}.${n}`, this._locOffset.x = this.width / 2, this._locOffset.y = this.height / 2, this._updateStyleInfo(), this._classInfo = {
      symbol: !0,
      [n]: !0
    };
  }
  static fromType(e, r, n) {
    let i, s;
    return r === "default" ? (i = "circle", s = "outline", n ?? (n = {}), n.dashed = !0) : [i, s] = r.split("."), new Fa(e, i, s, n);
  }
  get type() {
    return this._type;
  }
  set type(e) {
    this._type = e;
    const [r, n] = e.split(".");
    this._defsKey = `sym-${r}-${n}`, this.paraview.defs[this._defsKey] || this.paraview.addDef(this._defsKey, Tt`
        <path
          id=${this._defsKey}
          d=${X3[this.shape].path}
        />
      `), this._updateStyleInfo();
  }
  get width() {
    return X3[this.shape].baseWidth * this._options.scale;
  }
  get height() {
    return X3[this.shape].baseHeight * this._options.scale;
  }
  get outerBbox() {
    return new DOMRect(
      this._x - this.width / 2 - this._options.scale * this._options.strokeWidth / 2,
      this._y - this.height / 2 - this._options.scale * this._options.strokeWidth / 2,
      this.width + this._options.scale * this._options.strokeWidth,
      this.height + this._options.scale * this._options.strokeWidth
    );
  }
  get shape() {
    return this._type.split(".")[0];
  }
  set shape(e) {
    this.type = e + "." + this._type.split(".")[1];
  }
  get fill() {
    return this._type.split(".")[1];
  }
  set fill(e) {
    this.type = this._type.split(".")[0] + "." + e, this._updateStyleInfo();
  }
  get color() {
    return this._options.color;
  }
  set color(e) {
    this._options.color = e, this._updateStyleInfo();
  }
  get opacity() {
    return this._options.opacity;
  }
  set opacity(e) {
    this._options.opacity = e, this._updateStyleInfo();
  }
  get scale() {
    return this._options.scale;
  }
  set scale(e) {
    this._options.scale = e;
  }
  get role() {
    return this._role;
  }
  set role(e) {
    this._role = e;
  }
  clone() {
    const e = Fa.fromType(this.paraview, this._type, this._options);
    return e.x = this._x, e.y = this._y, e;
  }
  _updateStyleInfo() {
    if (this._styleInfo = {
      strokeWidth: this._options.strokeWidth
    }, this._options.dashed && (this._styleInfo.strokeDasharray = "1px 2px"), this._options.color !== void 0) {
      if (this.fill === "solid")
        if (this._options.lighten) {
          const e = this.paraview.store.colors.colorValueAt(
            this._options.color
          ).match(/\d+/g).map(Number);
          e[1] -= Math.min(10, e[1]), e[2] += Math.min(25, 100 - e[2]), this._styleInfo.fill = `hsl(${e[0]}, ${e[1]}%, ${e[2]}%)`;
        } else
          this._styleInfo.fill = this.paraview.store.colors.colorValueAt(
            this._options.color
          );
      else this.fill === "outline" ? this._styleInfo.fill = "white" : this._styleInfo.fill = "none";
      this._options.opacity !== void 0 && (this._styleInfo.opacity = this._options.opacity), this._styleInfo.stroke = this.paraview.store.colors.colorValueAt(
        this._options.color
      );
    }
  }
  content() {
    let e = nt`translate(${this._x},${this._y})`;
    return this._options.scale !== 1 && (e += nt` scale(${this._options.scale})`), this.paraview.store.type, this.parent instanceof pf && (this._y < 0 || this._y > this.parent.chart.parent.logicalHeight) && (this.hidden = !0), this.hidden ? Tt`` : Tt`
      <use
        href="#${this._defsKey}"
        id=${this._id || De}
        role=${this._role || De}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : De}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : De}
        transform=${e}
        @pointerenter=${this._options.pointerEnter ?? De}
        @pointerleave=${this._options.pointerLeave ?? De}
        clip-path=${/*this._options.isClip ? 'url(#clip-path)' :*/
    De}
      />
    `;
  }
}
class rU {
  constructor() {
    this.shapes = [
      "circle",
      "square",
      "triangle_up",
      "diamond",
      "plus",
      "star",
      "triangle_down",
      "x"
    ], this.fills = [
      "outline",
      "solid"
    ], this.types = this.fills.flatMap((e) => this.shapes.map((r) => `${r}.${e}`));
  }
  symbolAt(e) {
    return this.types[e] ?? "default";
  }
}
class hR {
  constructor(e) {
    this.store = e, this.seriesList = e.model.series.map((r, n) => new x8e(r.key, e.colors.wrapColorIndex(n), e.symbols.symbolAt(n)));
  }
  properties(e) {
    const r = this.seriesList.find((n) => n.key === e);
    if (!r)
      throw new Error(`no properties for series key '${e}'`);
    return r;
  }
}
class x8e {
  constructor(e, r, n) {
    this.key = e, this.color = r, this.symbol = n;
  }
}
const E8e = {
  label: "Add an annotation",
  hotkeys: [
    "a"
  ]
}, S8e = {
  label: "Toggle screen reader announcements",
  hotkeys: [
    "b"
  ]
}, A8e = {
  label: "Jump to chord landing",
  hotkeys: [
    "c"
  ]
}, k8e = {
  label: "Show the help dialog",
  hotkeys: [
    "h"
  ]
}, _8e = {
  label: "Toggle dark mode",
  hotkeys: [
    "k"
  ]
}, C8e = {
  label: "Toggle low-vision mode",
  hotkeys: [
    "l"
  ]
}, I8e = {
  label: "Toggle narrative highlight mode",
  hotkeys: [
    "n"
  ]
}, P8e = {
  label: "Query data",
  hotkeys: [
    "q"
  ]
}, R8e = {
  label: "Repeat last message",
  hotkeys: [
    "r"
  ]
}, O8e = {
  label: "Toggle sonification mode",
  hotkeys: [
    "s"
  ]
}, T8e = {
  label: "Toggle trend navigation mode",
  hotkeys: [
    "t"
  ]
}, L8e = {
  label: "Clear the datapoint selection",
  hotkeys: [
    "u"
  ]
}, M8e = {
  label: "Toggle self-voicing mode",
  hotkeys: [
    "v"
  ]
}, N8e = {
  label: "Move the cursor",
  parameters: {
    direction: "string"
  },
  hotkeys: [
    {
      keyID: "arrowright",
      args: {
        direction: "right"
      }
    },
    {
      keyID: "arrowleft",
      args: {
        direction: "left"
      }
    },
    {
      keyID: "arrowup",
      args: {
        direction: "up"
      }
    },
    {
      keyID: "arrowdown",
      args: {
        direction: "down"
      }
    },
    {
      keyID: "Shift+arrowup",
      args: {
        direction: "out"
      }
    },
    {
      keyID: "Shift+arrowdown",
      args: {
        direction: "in"
      }
    }
  ]
}, D8e = {
  label: "Play datapoints to the right",
  hotkeys: [
    "Shift+end"
  ]
}, $8e = {
  label: "Play datapoints to the left",
  hotkeys: [
    "Shift+home"
  ]
}, j8e = {
  label: "Stop playing",
  hotkeys: [
    "Ctrl+control"
  ]
}, B8e = {
  label: "Go to first point in series",
  hotkeys: [
    "home",
    ";"
  ]
}, F8e = {
  label: "Go to last point in series",
  hotkeys: [
    "end",
    "'"
  ]
}, z8e = {
  label: "Play or pause audio",
  hotkeys: [
    " "
  ]
}, V8e = {
  label: "Reset the chart",
  hotkeys: [
    "Shift+ "
  ]
}, U8e = {
  label: "Select a datapoint",
  hotkeys: [
    "enter"
  ]
}, H8e = {
  label: "Extend the datapoint selection",
  hotkeys: [
    "Shift+enter"
  ]
}, G8e = {
  label: "Go to the series minimum",
  hotkeys: [
    "["
  ]
}, W8e = {
  label: "Go to the series maximum",
  hotkeys: [
    "]"
  ]
}, q8e = {
  label: "Go to the chart minimum",
  hotkeys: [
    "Shift+{"
  ]
}, Q8e = {
  label: "Go to the chart maximum",
  hotkeys: [
    "Shift+}"
  ]
}, K8e = {
  label: "Announce version info",
  hotkeys: [
    "Ctrl+Shift+v"
  ]
}, Y8e = {
  label: "Stop speaking (self-voicing mode)",
  hotkeys: [
    "Ctrl",
    "escape"
  ]
}, Z8e = {
  addAnnotation: E8e,
  toggleAnnouncementMode: S8e,
  jumpToChordLanding: A8e,
  openHelp: k8e,
  toggleDarkMode: _8e,
  toggleLowVisionMode: C8e,
  toggleNarrativeHighlightMode: I8e,
  queryData: P8e,
  repeatLastAnnouncement: R8e,
  toggleSonificationMode: O8e,
  toggleTrendNavigationMode: T8e,
  clearSelection: L8e,
  toggleVoicingMode: M8e,
  move: N8e,
  playRight: D8e,
  playLeft: $8e,
  stopPlay: j8e,
  goFirst: B8e,
  goLast: F8e,
  playPauseMedia: z8e,
  reset: V8e,
  select: U8e,
  extendSelection: H8e,
  goMinimum: G8e,
  goMaximum: W8e,
  goTotalMinimum: q8e,
  goTotalMaximum: Q8e,
  announceVersionInfo: K8e,
  shutUp: Y8e
}, nU = Z8e;
class J8e extends Event {
  constructor(e, r, n) {
    super("hotkeypress", { bubbles: !0, cancelable: !0, composed: !0 }), this.key = e, this.action = r, this.args = n;
  }
}
class X8e extends EventTarget {
  constructor(e) {
    super(), this.log = qt("KeymapManager"), this._keyDetails = {}, this.registerHotkeys(e);
  }
  /**
   * Handle the keydown event
   * @param event - keydown event
   */
  // handleKeyEvents(event: CustomEvent) {
  //   if (event.detail in this._keymap) {
  //     this.view.actionManager!.call(this._keymap[keyPress].action);
  //   } else if (keyPress.toUpperCase() in this._keymap) {
  //     this.view.actionManager!.call(this._keymap[keyPress.toUpperCase()].action);
  //   }
  // }
  /**
   * Register a hotkey.
   * @param keyInfo - the key ID string or key with args object
   * @param action - the action to perform if the key is pressed
   */
  registerHotkey(e, r) {
    const n = typeof e == "string" ? e : e.keyID;
    try {
      this._keyDetails[n] = {
        key: n,
        //title: this.todo.controller.translator.translate(titleId),
        //description,
        action: r
        //keyDescription
      }, typeof e != "string" && (this._keyDetails[n].args = e.args), n.length === 1 && n.toLocaleUpperCase() !== n && (this._keyDetails[`Shift+${n}`] = {
        key: n,
        //title: this.todo.controller.translator.translate(titleId),
        //description,
        action: r
        //keyDescription
      });
    } catch (i) {
      i instanceof Error && this.log.warn(i.message);
    }
  }
  /**
   * Register multiple hotkeys.
   * Effectively a shortcut to calling `.registerHotkey()` multiple times
   * @param keyRegistrations - hotkey registration info
   */
  registerHotkeys(e) {
    for (const [r, n] of Object.entries(e))
      for (const i of n.hotkeys)
        this.registerHotkey(i, r);
  }
  onKeydown(e) {
    const r = this._keyDetails[e];
    return r ? (this.dispatchEvent(new J8e(e, r.action, r.args)), !0) : !1;
  }
  /**
   * Build a help dialog
   * @param lang Language of the dialog - used in attribute, and for i18n
   * @param translationCallback - get language-specific verbiage
   */
  /*generateHelpDialog(
      lang: string,
      translationCallback: (
        code: string,
        //evaluators?: translateEvaluators
      ) => string
    ) {
      const dialog = document.createElement("dialog");
      dialog.setAttribute("lang", lang);
  
      const closeButton = document.createElement("button");
      closeButton.textContent = 'X';
      closeButton.ariaLabel = translationCallback("close");
      closeButton.style.position = 'absolute';
      closeButton.style.top = '10px';
      closeButton.style.right = '10px';
      closeButton.addEventListener("click", () => {
        dialog.close();
      });
      dialog.appendChild(closeButton);
  
      const heading = translationCallback("kbmg-title");
      const h1 = document.createElement("h1");
      h1.textContent = heading;
      dialog.setAttribute("aria-live", heading);
      dialog.appendChild(h1);
  
      const table = document.createElement("table");
      const tbody = document.createElement("tbody");
      Object.entries(this._keyMap).forEach(([keystroke, details]) => {
        const tr = document.createElement("tr");
        const th = document.createElement("th");
        th.scope = 'row';
        th.textContent = details.title;
        tr.appendChild(th);
  
        const td1 = document.createElement("td");
        td1.textContent = details.keyDescription ?? keystroke;
        tr.appendChild(td1);
  
        const td2 = document.createElement("td");
        td2.textContent = details.description;
        tr.appendChild(td2);
  
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
  
      dialog.appendChild(table);
      return dialog;
    }*/
  /**
   * Launch help dialog
   * @param lang Language of the dialog - used in attribute, and for i18n
   * @param translationCallback - get language-specific verbiage
   */
  /*launchHelpDialog(
    lang: string,
    translationCallback: (
      code: string,
      evaluators?: translateEvaluators
    ) => string
  ) {
    if (this._dialog === null) {
      this._dialog = this.generateHelpDialog(lang, translationCallback);
      document.body.appendChild(this._dialog);
    }
    this._dialog.showModal();
    this._dialog.focus();
  }*/
}
var eAe = Object.defineProperty, Rr = (t, e, r, n) => {
  for (var i = void 0, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && eAe(e, r, i), i;
};
Gse();
function rn(t) {
  const [e, r] = t.split("-");
  return {
    seriesKey: e,
    index: parseInt(r)
  };
}
class Cr extends Ay {
  constructor(e, r, n, i) {
    super(), this.paraChart = e, this._inputSettings = r, this.symbols = new rU(), this.dataState = "initial", this.darkMode = !1, this.announcement = { text: "", html: "", highlights: [], startFrom: 0 }, this.annotations = [], this.popups = [], this.sparkBrailleInfo = null, this.seriesAnalyses = {}, this.frontSeries = "", this._lowlightedSeries = [], this._hiddenSeries = [], this.data = null, this.focused = "chart", this.selected = null, this.queryLevel = "default", this._visitedDatapoints = /* @__PURE__ */ new Set(), this._prevVisitedDatapoints = /* @__PURE__ */ new Set(), this._everVisitedDatapoints = /* @__PURE__ */ new Set(), this._highlightedSelector = "", this._selectedDatapoints = /* @__PURE__ */ new Set(), this._prevSelectedDatapoints = /* @__PURE__ */ new Set(), this._rangeHighlights = [], this._modelLineBreaks = [], this._userLineBreaks = [], this._modelTrendLines = [], this._userTrendLines = [], this._settingControls = new XV(this), this._settingObservers = {}, this._manifest = null, this._jimerator = null, this._model = null, this._facets = null, this._type = "line", this._title = "", this._seriesProperties = null, this._keymapManager = new X8e(nU), this.annotID = 0, this.log = qt("ParaStore"), this.idList = {}, this._createSettings(), this.subscribe((s, o) => this._propertyChanged(s, o)), this._colors = new eU(this), this._seriesAnalyzerConstructor = n, this._pairAnalyzerConstructor = i, this._getUrlAnnotations();
  }
  get settingControls() {
    return this._settingControls;
  }
  get type() {
    return this._type;
  }
  get model() {
    return this._model;
  }
  get title() {
    return this._title;
  }
  get jimerator() {
    return this._jimerator;
  }
  get seriesProperties() {
    return this._seriesProperties;
  }
  get colors() {
    return this._colors;
  }
  get keymapManager() {
    return this._keymapManager;
  }
  get rangeHighlights() {
    return this._rangeHighlights;
  }
  get modelLineBreaks() {
    return this._modelLineBreaks;
  }
  get userLineBreaks() {
    return this._userLineBreaks;
  }
  get modelTrendLines() {
    return this._modelTrendLines;
  }
  get userTrendLines() {
    return this._userTrendLines;
  }
  _createSettings() {
    const e = br.hydrateInput(this._inputSettings);
    br.suppleteSettings(e, i8e), this.settings = e;
  }
  setManifest(e, r) {
    this._manifest = e;
    const n = this._manifest.datasets[0];
    if (this._createSettings(), uR[n.type] && Object.entries(uR[n.type]).forEach(([i, s]) => this.updateSettings((o) => {
      br.set(i, s, o);
    })), n.settings && (Object.entries(n.settings).forEach(([i, s]) => this.updateSettings((o) => {
      br.set(i, s, o);
    })), this.settings.color.colorMap && this._colors.setColorMap(...this.settings.color.colorMap.split(",").map((i) => i.trim()))), this._jimerator = new aye(this._manifest, r), this._jimerator.render(), this._type = n.type, this._title = n.title, this._facets = _g(n), n.data.source === "inline")
      i_(n.type) ? this._model = rie(e) : this._model = iie(
        e,
        this._seriesAnalyzerConstructor,
        this._pairAnalyzerConstructor
      ), this._seriesProperties = new hR(this), this.data = kpe(e);
    else if (r)
      i_(n.type) ? this._model = nie(r, e) : this._model = sie(
        r,
        e,
        this._seriesAnalyzerConstructor,
        this._pairAnalyzerConstructor
      ), this._seriesProperties = new hR(this), this.data = r;
    else
      throw new Error("store lacks external or inline chart data");
    this._model instanceof _c && this._model.seriesKeys.forEach(async (i) => {
      this.seriesAnalyses = {
        [i]: await this._model.getSeriesAnalysis(i),
        ...this.seriesAnalyses
      };
    });
  }
  _propertyChanged(e, r) {
  }
  updateSettings(e, r = !1) {
    var a;
    const [n, i, s] = qse(this.settings, e);
    if (this.settings = n, r)
      return;
    const o = {};
    for (const l of i) {
      if (l.op !== "replace") {
        this.log.error(`unexpected patch op '${l.op}' (${l.path})`);
        continue;
      }
      o[l.path.join(".")] = { newValue: l.value };
    }
    for (const l of s) {
      if (l.op !== "replace") {
        this.log.error(`unexpected patch op '${l.op}' (${l.path})`);
        continue;
      }
      o[l.path.join(".")].oldValue = l.value;
    }
    for (const [l, c] of Object.entries(o))
      (a = this._settingObservers[l]) == null || a.forEach(
        (p) => p(c.oldValue, c.newValue)
      ), this.paraChart.settingDidChange(l, c.oldValue, c.newValue);
  }
  observeSetting(e, r) {
    if (this._settingObservers[e] || (this._settingObservers[e] = []), this._settingObservers[e].includes(r))
      throw new Error(`observer already registered for setting '${e}'`);
    this._settingObservers[e].push(r);
  }
  observeSettings(e, r) {
    for (let n of e)
      this.observeSetting(n, r);
  }
  unobserveSetting(e, r) {
    if (!this._settingObservers[e])
      throw new Error(`no observers for setting '${e}'`);
    const n = this._settingObservers[e].indexOf(r);
    if (n === -1)
      throw new Error(`observer not registered for setting '${e}'`);
    this._settingObservers[e].splice(n, 1), this._settingObservers[e].length === 0 && delete this._settingObservers[e];
  }
  lowlightSeries(e) {
    this._lowlightedSeries.includes(e) || (this._lowlightedSeries = [...this._lowlightedSeries, e]);
  }
  clearSeriesLowlight(e) {
    this._lowlightedSeries.includes(e) && (this._lowlightedSeries = this._lowlightedSeries.filter((r) => r !== e));
  }
  isSeriesLowlighted(e) {
    return this._lowlightedSeries.includes(e);
  }
  lowlightOtherSeries(...e) {
    this._lowlightedSeries = this._model.seriesKeys.filter((r) => !e.includes(r));
  }
  clearAllSeriesLowlights() {
    this._lowlightedSeries = [];
  }
  hideSeries(e) {
    this._hiddenSeries.includes(e) || (this._hiddenSeries = [...this._hiddenSeries, e]);
  }
  unhideSeries(e) {
    this._hiddenSeries.includes(e) && (this._hiddenSeries = this._hiddenSeries.filter((r) => r !== e));
  }
  isSeriesHidden(e) {
    return this._hiddenSeries.includes(e);
  }
  hideOtherSeries(...e) {
    this._hiddenSeries = this._model.seriesKeys.filter((r) => !e.includes(r));
  }
  hideAllSeries() {
    this._hiddenSeries = [...this._model.seriesKeys];
  }
  unhideAllSeries() {
    this._hiddenSeries = [];
  }
  announce(e, r = !1, n = 0) {
    let i = "", s = "";
    const o = `\r
`;
    let a = [];
    typeof e == "string" ? (i = e, s = e) : Array.isArray(e) ? (i = this._joinStrArray(e, o), s = i) : (i = e.text, s = e.html, a = e.highlights ?? []), this.settings.ui.isAnnouncementEnabled && (this.announcement = { text: i, html: s, highlights: a, clear: r, startFrom: n }, this.log.info("ANNOUNCE:", this.announcement.text));
  }
  _joinStrArray(e, r) {
    if (e = e.filter((n) => /\S/.test(n)), e.length) {
      const n = e.length - 1;
      return e.reduce((i, s, o) => {
        const a = o === n ? "." : "", l = i ? ` ${r}` : "";
        return `${i.match(/[.,?:;]$/) ? i : `${i}.`} ${l}${s}${a}`;
      });
    }
    return "";
  }
  get visitedDatapoints() {
    return this._visitedDatapoints;
  }
  get prevVisitedDatapoints() {
    return this._prevVisitedDatapoints;
  }
  get everVisitedDatapoints() {
    return this._everVisitedDatapoints;
  }
  visit(e) {
    this._prevVisitedDatapoints = this._visitedDatapoints, this._visitedDatapoints = /* @__PURE__ */ new Set(), e.forEach((r) => {
      this._visitedDatapoints.add(`${r.seriesKey}-${r.datapointIndex}`);
    });
    for (const r of e)
      this._everVisitedDatapoints.add(`${r.seriesKey}-${r.datapointIndex}`);
    this.settings.controlPanel.isMDRAnnotationsVisible && (this.removeMDRAnnotations(this._prevVisitedDatapoints), this.showMDRAnnotations()), this.paraChart.paraView.requestUpdate();
  }
  _datapointSetHas(e, r, n) {
    return n.has(`${e}-${r}`);
  }
  isVisited(e, r) {
    return this._datapointSetHas(e, r, this._visitedDatapoints);
  }
  isVisitedSeries(e) {
    return this._visitedDatapoints.values().some((r) => r.startsWith(e));
  }
  wasVisited(e, r) {
    return this._datapointSetHas(e, r, this._prevVisitedDatapoints);
  }
  wasVisitedSeries(e) {
    return this._prevVisitedDatapoints.values().some((r) => r.startsWith(e));
  }
  everVisited(e, r) {
    return this._datapointSetHas(e, r, this._everVisitedDatapoints);
  }
  everVisitedSeries(e) {
    return this._everVisitedDatapoints.values().some((r) => r.startsWith(e));
  }
  clearVisited() {
    this._prevVisitedDatapoints = this._visitedDatapoints, this._visitedDatapoints = /* @__PURE__ */ new Set();
  }
  get highlightedSelector() {
    return this._highlightedSelector;
  }
  highlight(e) {
    this._highlightedSelector = e;
  }
  clearHighlight() {
    this.popups.splice(0, this.popups.length), this._highlightedSelector = "";
  }
  get selectedDatapoints() {
    return this._selectedDatapoints;
  }
  get prevSelectedDatapoints() {
    return this._prevSelectedDatapoints;
  }
  select() {
    let e = /* @__PURE__ */ new Set();
    if (this._visitedDatapoints.size === 1) {
      const r = [...this._visitedDatapoints.values()][0], { seriesKey: n, index: i } = rn(r);
      (!this.isSelected(n, i) || this._selectedDatapoints.size > 1) && e.add(r);
    } else
      for (const r of this._visitedDatapoints) {
        const { seriesKey: n, index: i } = rn(r);
        this.isSelected(n, i) || e.add(r);
      }
    this._prevSelectedDatapoints = this._selectedDatapoints, this._selectedDatapoints = e;
  }
  extendSelection() {
    const e = new Set(this._selectedDatapoints);
    for (const r of this._visitedDatapoints) {
      const { seriesKey: n, index: i } = rn(r);
      this.isSelected(n, i) ? e.delete(r) : e.add(r);
    }
    this._prevSelectedDatapoints = this._selectedDatapoints, this._selectedDatapoints = e;
  }
  isSelected(e, r) {
    return this._datapointSetHas(e, r, this._selectedDatapoints);
  }
  isSelectedSeries(e) {
    return this._selectedDatapoints.values().some((r) => r.startsWith(e));
  }
  wasSelected(e, r) {
    return this._datapointSetHas(e, r, this._prevSelectedDatapoints);
  }
  wasSelectedSeries(e) {
    return this._prevSelectedDatapoints.values().some((r) => r.startsWith(e));
  }
  clearSelected() {
    this._prevSelectedDatapoints = this._selectedDatapoints, this._selectedDatapoints = /* @__PURE__ */ new Set();
  }
  getFormatType(e) {
    return e === "domId" ? "domId" : br.get(ZSe[e], this.settings);
  }
  addAnnotation() {
    const e = [];
    this._visitedDatapoints.forEach((r) => {
      const { seriesKey: n, index: i } = rn(r), s = Zu(
        this._model.atKeyAndIndex(n, i),
        "raw"
      ), o = prompt("Annotation:");
      o && (e.push({
        type: "datapoint",
        seriesKey: n,
        index: i,
        annotation: `${n}, ${s}: ${o}`,
        text: o,
        id: `${n}-${s}-${this.annotID}`
      }), this.annotID += 1);
    }), this.annotations = [...this.annotations, ...e];
  }
  annotatePoint(e, r, n) {
    if (this.annotations.find((s) => s.seriesKey === e && s.index === r && s.text === n))
      return;
    const i = Zu(
      this._model.atKeyAndIndex(e, r),
      "raw"
    );
    this.annotations = [...this.annotations, {
      type: "datapoint",
      seriesKey: e,
      index: r,
      annotation: `${e}, ${i}: ${n}`,
      text: n,
      id: `${e}-${i}-${this.annotID}`
    }], this.annotID++;
  }
  async showMDRAnnotations() {
    if (this.type === "line")
      if (this.settings.controlPanel.isMDRAnnotationsVisible) {
        let e, r;
        if (this.visitedDatapoints.size > 0 ? (r = rn(this.visitedDatapoints.keys().toArray()[0]).seriesKey, e = this.model ? await this.model.getSeriesAnalysis(r) : void 0) : (r = this.model.series[0][0].seriesKey, e = this.model ? await this.model.getSeriesAnalysis(r) : void 0), !e) {
          this.log.info("This chart does not support AI trend annotations"), this.updateSettings((o) => {
            o.controlPanel.isMDRAnnotationsVisible = !this.settings.controlPanel.isMDRAnnotationsVisible;
          });
          return;
        }
        const n = this.model.series[0].length - 1;
        let i = e == null ? void 0 : e.messageSeqs.map((o) => e.sequences[o]);
        for (let o of i)
          this.highlightRange(o.start / n, (o.end - 1) / n);
        this.addModelLineBreaks(e.sequences, r), this.addModelTrendLines(e.sequences, r);
        let s = `Detected trend: ${e == null ? void 0 : e.message}, consisting of ${e == null ? void 0 : e.messageSeqs.length} datapoint sequences from`;
        for (let o of i)
          s += ` ${this.model.allPoints[o.start].facetValueNumericized("x")} to ${this.model.allPoints[o.end - 1].facetValueNumericized("x")} (${o.message}),`;
        if (this.annotations.some((o) => o.id == "trend-analysis-annotation")) {
          const o = this.annotations.findIndex((a) => a.id == "trend-analysis-annotation");
          this.annotations.splice(o, 1);
        }
        this.annotations.push({
          type: "trend",
          annotation: s,
          id: "trend-analysis-annotation"
        });
      } else
        this.removeMDRAnnotations();
    else
      this.log.info("Trend annotations not currently supported for this chart type"), this.updateSettings((e) => {
        e.controlPanel.isMDRAnnotationsVisible = !this.settings.controlPanel.isMDRAnnotationsVisible;
      });
  }
  async removeMDRAnnotations(e) {
    let r = null, n = null;
    e || (e = this.visitedDatapoints), this.type !== "line" || (e.size > 0 ? (n = rn(this.visitedDatapoints.keys().toArray()[0]).seriesKey, r = this.model ? await this.model.getSeriesAnalysis(n) : null) : (n = this.model.series[0][0].seriesKey, r = this.model ? await this.model.getSeriesAnalysis(n) : null));
    const i = this.model.series[0].length - 1;
    let s = r == null ? void 0 : r.messageSeqs.map((o) => r.sequences[o]);
    for (let o of s)
      this.unhighlightRange(o.start / i, (o.end - 1) / i);
    if (n !== null && (this.removeModelLineBreaks(r.sequences, n), this.removeModelTrendLines(r.sequences, n)), this.annotations.some((o) => o.id == "trend-analysis-annotation")) {
      const o = this.annotations.findIndex((a) => a.id == "trend-analysis-annotation");
      this.annotations.splice(o, 1);
    }
  }
  _getUrlAnnotations() {
    const e = (s) => s.replace(/(\r\n|\n|\r)/gm, "").replace(/\s+/g, " ").trim();
    let n = window.location.search;
    if (n) {
      var i = new URLSearchParams(n);
      let s = i.get("text");
      i.get("note"), s && (s = e(s));
    }
  }
  highlightRange(e, r) {
    if (this._rangeHighlights.find((n) => n.startPortion === e && n.endPortion === r))
      throw new Error("range already highlighted");
    this._rangeHighlights = [...this._rangeHighlights, { startPortion: e, endPortion: r }];
  }
  unhighlightRange(e, r) {
    const n = this._rangeHighlights.findIndex((i) => i.startPortion === e && i.endPortion === r);
    if (n === -1)
      throw new Error("range not highlighted");
    this._rangeHighlights = this._rangeHighlights.toSpliced(n, 1);
  }
  getModelCsv() {
    const e = this._model.getFacet(this.model.independentFacetKeys[0]).label;
    return LN.unparse(this.model.series[0].datapoints.map((r, n) => ({
      [e]: Zu(r, "raw"),
      ...Object.fromEntries(this.model.series.map((i) => [i.key, wS(i[n], "value")]))
    })));
  }
  addModelLineBreaks(e, r) {
    const i = this.model.series.filter((s) => s[0].seriesKey == r)[0].length - 1;
    for (let s of e)
      this.addLineBreak(s.start / i, s.start, r, !0);
    this.addLineBreak((e[e.length - 1].end - 1) / i, e[e.length - 1].end - 1, r, !0);
  }
  removeModelLineBreaks(e, r) {
    const i = this.model.series.filter((o) => o[0].seriesKey == r)[0].length - 1;
    for (let o of e) {
      const a = this._modelLineBreaks.findIndex((l) => l.startPortion === o.start / i);
      a === -1 || (this._modelLineBreaks = this._modelLineBreaks.toSpliced(a, 1));
    }
    const s = this._modelLineBreaks.findIndex((o) => o.startPortion === (e[e.length - 1].end - 1) / i);
    s === -1 || (this._modelLineBreaks = this._modelLineBreaks.toSpliced(s, 1));
  }
  addLineBreak(e, r, n, i) {
    i ? this._modelLineBreaks.find((s) => s.startPortion === e) || (this._modelLineBreaks = [...this._modelLineBreaks, { startPortion: e, seriesKey: n, index: r }]) : this._userLineBreaks.find((s) => s.startPortion === e && s.seriesKey === n) || this._userLineBreaks.push({ startPortion: e, seriesKey: n, index: r });
  }
  addUserLineBreaks() {
    for (const e of this.selectedDatapoints) {
      const { seriesKey: r, index: n } = rn(e), i = this.model.series.filter((o) => o[0].seriesKey === r)[0], s = i.length - 1;
      this.addLineBreak(n / s, n, r, !1), this.annotations.push({
        type: "lineBreak",
        seriesKey: r,
        index: n,
        annotation: `${i.key}, ${i.rawData[n].x}: Added line break`,
        id: `line-break-${n}`
      }), this.paraChart.postNotice("addLineBreak", { seriesKey: r, index: n });
    }
    if (this.userLineBreaks.length) {
      this.clearUserTrendLines();
      for (let e of new Set(this.userLineBreaks.map((r) => r.seriesKey))) {
        let r = this.userLineBreaks.filter((s) => s.seriesKey === e).sort((s, o) => s.index - o.index);
        this.addTrendLine(0, r[0].startPortion, 0, r[0].index + 1, e, !1);
        for (let s = 0; s < r.length - 1; s++)
          this.addTrendLine(r[s].startPortion, r[s + 1].startPortion, r[s].index, r[s + 1].index + 1, e, !1);
        const i = this.model.series.filter((s) => s[0].seriesKey == e)[0].length - 1;
        this.addTrendLine(r[r.length - 1].startPortion, 1, r[r.length - 1].index, i + 1, e, !1);
      }
    }
  }
  addModelTrendLines(e, r) {
    const i = this.model.series.filter((s) => s[0].seriesKey == r)[0].length - 1;
    for (let s of e)
      this.addTrendLine(s.start / i, (s.end - 1) / i, s.start, s.end, r, !0);
  }
  addTrendLine(e, r, n, i, s, o) {
    o ? this._modelTrendLines.find((a) => a.startPortion === e && a.endPortion === r) || (this._modelTrendLines = [...this._modelTrendLines, { startPortion: e, endPortion: r, startIndex: n, endIndex: i, seriesKey: s }]) : this._userTrendLines.find((a) => a.startPortion === e && a.endPortion === r && a.seriesKey === s) || (this._userTrendLines = [...this._userTrendLines, { startPortion: e, endPortion: r, startIndex: n, endIndex: i, seriesKey: s }]);
  }
  removeModelTrendLines(e, r) {
    const i = this.model.series.filter((s) => s[0].seriesKey == r)[0].length - 1;
    for (let s of e) {
      const o = this._modelTrendLines.findIndex((a) => a.startPortion === s.start / i && a.endPortion === (s.end - 1) / i);
      o === -1 || (this._modelTrendLines = this._modelTrendLines.toSpliced(o, 1));
    }
  }
  clearUserLineBreaks() {
    this._userLineBreaks = [], this.annotations = this.annotations.filter((e) => !/line-break/.test(e.id)), this.paraChart.postNotice("clearLineBreaks", null);
  }
  clearUserTrendLines() {
    this._userTrendLines = [];
  }
}
Rr([
  Ar()
], Cr.prototype, "dataState");
Rr([
  Ar()
], Cr.prototype, "settings");
Rr([
  Ar()
], Cr.prototype, "darkMode");
Rr([
  Ar()
], Cr.prototype, "announcement");
Rr([
  Ar()
], Cr.prototype, "annotations");
Rr([
  Ar()
], Cr.prototype, "popups");
Rr([
  Ar()
], Cr.prototype, "sparkBrailleInfo");
Rr([
  Ar()
], Cr.prototype, "seriesAnalyses");
Rr([
  Ar()
], Cr.prototype, "frontSeries");
Rr([
  Ar()
], Cr.prototype, "_lowlightedSeries");
Rr([
  Ar()
], Cr.prototype, "_hiddenSeries");
Rr([
  Ar()
], Cr.prototype, "data");
Rr([
  Ar()
], Cr.prototype, "focused");
Rr([
  Ar()
], Cr.prototype, "selected");
Rr([
  Ar()
], Cr.prototype, "queryLevel");
Rr([
  Ar()
], Cr.prototype, "_highlightedSelector");
Rr([
  Ar()
], Cr.prototype, "_selectedDatapoints");
Rr([
  Ar()
], Cr.prototype, "_prevSelectedDatapoints");
Rr([
  Ar()
], Cr.prototype, "_rangeHighlights");
Rr([
  Ar()
], Cr.prototype, "_modelLineBreaks");
Rr([
  Ar()
], Cr.prototype, "_userLineBreaks");
Rr([
  Ar()
], Cr.prototype, "_modelTrendLines");
Rr([
  Ar()
], Cr.prototype, "_userTrendLines");
var tAe = Object.defineProperty, rAe = Object.getOwnPropertyDescriptor, P9 = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? rAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && tAe(e, r, i), i;
};
const G9 = class G9 extends ts {
  constructor() {
    super(...arguments), this.log = qt("SettingControl"), this.hidden = !1;
  }
  set value(e) {
    this._value = e;
  }
  get value() {
    return this._value;
  }
  _updateSetting(e, r) {
    this._store.updateSettings((n) => br.set(e, r, n));
  }
  _validateInput(e, r) {
    if (this.info.validator) {
      const n = this.info.validator(e);
      if (n.err)
        return r.dispatchEvent(
          new CustomEvent(
            "invalidvalue",
            { bubbles: !0, composed: !0, detail: n.err }
          )
        ), !1;
    }
    return !0;
  }
  render() {
    return qe`
      <div
        class="setting"
      >
        ${this.content()}
      </div>
    `;
  }
};
G9.styles = [
  //styles,
  Nt`
    `
];
let Ys = G9;
P9([
  Vr()
], Ys.prototype, "label", 2);
P9([
  Vr()
], Ys.prototype, "value", 1);
P9([
  Ke({ type: Boolean })
], Ys.prototype, "hidden", 2);
var nAe = Object.getOwnPropertyDescriptor, iAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? nAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let pR = class extends Ys {
  content() {
    const t = this.info.options;
    return qe`
      <label>
        ${this.label}
        <input 
          type=${(t == null ? void 0 : t.inputType) ?? "text"}
          .value=${this._value} 
          min=${(t == null ? void 0 : t.inputType) === "number" ? t.min : De}
          max=${(t == null ? void 0 : t.inputType) === "number" ? t.max : De}
          size=${(t == null ? void 0 : t.size) ?? "8"}
          @change=${(e) => {
      const r = e.target, n = (t == null ? void 0 : t.inputType) === "number" ? parseFloat(r.value) : r.value;
      this._validateInput(n, r) ? (this._value = n, this._updateSetting(this.info.key, n)) : r.value = this._value.toString();
    }}
        />
      </label>
    `;
  }
};
pR = iAe([
  Dt("para-textfield-setting-control")
], pR);
var sAe = Object.getOwnPropertyDescriptor, oAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? sAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let dR = class extends Ys {
  connectedCallback() {
    super.connectedCallback(), this.values = this.info.options.values ?? this.info.options.options;
  }
  content() {
    return qe`
      <fizz-dropdown 
        label=${this.label} 
        .options=${this.info.options.options}
        selected=${this.values.indexOf(this._value)}
        @select=${(t) => {
      const e = t.target.selectedIndex;
      this._updateSetting(this.info.key, this.values[e]);
    }}
      ></fizz-dropdown>
    `;
  }
};
dR = oAe([
  Dt("para-dropdown-setting-control")
], dR);
var aAe = Object.getOwnPropertyDescriptor, lAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? aAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let fR = class extends Ys {
  content() {
    return qe`
      <label>
        <input 
          type="checkbox"
          .checked=${!!this._value}
          @change=${(t) => {
      this._updateSetting(
        this.info.key,
        t.target.checked
      );
    }}
        >
          ${this.label} 
      </label>
    `;
  }
};
fR = lAe([
  Dt("para-checkbox-setting-control")
], fR);
var cAe = Object.getOwnPropertyDescriptor, uAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? cAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let gR = class extends Ys {
  content() {
    const t = this.info.options;
    return qe`
      <fizz-radiogroup
        .buttons=${t.buttons}
        selected=${this._value}
        layout=${t.layout ?? De}
        ?wrap=${t.wrap}
        @select=${(e) => this._updateSetting(
      this.info.key,
      e.detail
    )}
      >
        <span slot="legend">${this.label}</span>
      </fizz-radiogroup>
    `;
  }
};
gR = uAe([
  Dt("para-radio-setting-control")
], gR);
var hAe = Object.getOwnPropertyDescriptor, pAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? hAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let mR = class extends Ys {
  content() {
    const t = this.info.options, e = Et(), r = t != null && t.width ? {
      "--width": t.width
    } : {};
    return qe`
      <fizz-slider
        ${yt(e)}
        style=${mn(r)}
        label=${this.label}
        key=${Yn(this.info.key)}
        value=${this._value}
        min=${(t == null ? void 0 : t.min) ?? De}
        max=${(t == null ? void 0 : t.max) ?? De}
        step=${(t == null ? void 0 : t.step) ?? De}
        lowbound=${(t == null ? void 0 : t.lowBound) ?? De}
        highbound=${(t == null ? void 0 : t.highBound) ?? De}
        ?percent=${t == null ? void 0 : t.percent}
        ?showvalue=${t == null ? void 0 : t.showValue}
        ?compact=${t == null ? void 0 : t.compact}
        @update=${(n) => this._updateSetting(
      this.info.key,
      n.detail
    )}
      ></fizz-slider>
    `;
  }
};
mR = pAe([
  Dt("para-slider-setting-control")
], mR);
var dAe = Object.getOwnPropertyDescriptor, fAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? dAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let yR = class extends Ys {
  content() {
    return qe`
      <label>
        <button
          type="button"
          @click=${(t) => {
      this._value = !this._value, this._updateSetting(this.info.key, this._value);
    }}
        >
          ${this.label}
        </button> 
      </label>
    `;
  }
};
yR = fAe([
  Dt("para-button-setting-control")
], yR);
class gAe {
  constructor(e) {
    this._store = e, this.log = qt("ParaViewController");
  }
  handleKeyEvent(e) {
    if (this._store.settings.chart.isStatic)
      return;
    let r = e.key === "Control" ? "Ctrl" : e.key.toLocaleLowerCase(), n = [
      e.altKey ? "Alt" : "",
      e.ctrlKey ? "Ctrl" : "",
      e.shiftKey ? "Shift" : "",
      e.metaKey ? "Meta" : ""
    ].filter((s) => s);
    n.includes(r) && (r = "");
    const i = (r ? [...n, r] : n).join("+");
    this._store.keymapManager.onKeydown(i) && (e.stopPropagation(), e.preventDefault());
  }
}
class mAe {
  constructor(e) {
    this._paraView = e, this.log = qt("PointerEventManager"), this._touchArray = [], this._currentTarget = null, this._selectedElement = null, this._selectedElements = [], this._highlightBoxes = /* @__PURE__ */ new WeakMap(), this._coords = null, this._dataRoot = null, this._dataRect = null;
  }
  get coords() {
    return this._coords;
  }
  /**
   * Records pointer event info.
   * @param event - The event on the element.
   */
  _registerPointerEvent(e) {
    return {
      id: e.pointerId,
      target: e.target,
      x: e.clientX,
      y: e.clientY,
      offsetX: e.offsetX,
      offsetY: e.offsetY
    };
  }
  /**
   * Starts pointer events.
   * @param event - The event on the element.
   */
  handleStart(e) {
    const r = this._registerPointerEvent(e);
    this._touchArray.push(r);
  }
  /**
   * Ends pointer events.
   * @param event - The event on the element.
   */
  handleEnd(e) {
    this.handleCancel(e);
  }
  /**
   * Cancels pointer events.
   * @param event - The event on the element.
   */
  handleCancel(e) {
    const r = e.pointerId, n = this._touchArray.findIndex((i) => i.id === r);
    n >= 0 && this._touchArray.splice(n, 1);
  }
  /**
   * Reads element labels and default settings, and triggers speech.
   * @param event - The event on the element.
   */
  handleMove(e) {
    const r = e.target;
    if (r.releasePointerCapture(e.pointerId), this._coords = this._localCoords(e), r === this._paraView.root || r === this._dataRoot)
      this._currentTarget = null;
    else if (r !== this._currentTarget) {
      if (r !== this._currentTarget) {
        this._currentTarget = r, this._selectedElements.includes(r);
        const n = e.pointerId, i = this._touchArray.findIndex((s) => s.id === n);
        if (i >= 0) {
          this._touchArray[i];
          const s = this._registerPointerEvent(e);
          this._touchArray[i] = s;
        }
      }
    }
  }
  /**
   * .
   * @param event - The event on the element.
   */
  _updateTouchArray(e) {
    const r = e.pointerId, n = this._touchArray.findIndex((i) => i.id === r);
    if (n >= 0) {
      this._touchArray[n];
      const i = this._registerPointerEvent(e);
      this._touchArray[n] = i, this._coords = this._localCoords(e);
    }
  }
  /**
   * Reads element labels and default settings, and triggers speech.
   * @param event - The event on the element.
   */
  handleClick(e) {
    const r = e.target;
    e.detail < 2 && (r === this._paraView.frame || r === this._dataRect ? this.log.info("clicked backdrop!") : this._selectElement(r, e.shiftKey));
  }
  /**
   * Double click handler.
   * @param event - The event on the element.
   */
  handleDoubleClick(e) {
    const r = e.target;
    e.preventDefault(), r === this._paraView.root || this._dataRoot;
  }
  /**
   * Set selected element and add a highlight box.
   * @param target - The element to be selected; deselects if absent or `null`.
   */
  async _selectElement(e, r) {
    if (!e)
      this._clearSelectedElements();
    else {
      r || this._clearSelectedElements();
      const n = e.closest('[role="datapoint"]');
      if (n) {
        const i = n.id.endsWith("-sym") || n.id.endsWith("-rlb") || n.id.endsWith("-blb") || n.id.endsWith("-ilb") ? n.id.slice(0, -4) : n.id, s = this._paraView.documentView.chartLayers.dataLayer.datapointViewForId(i), o = this._paraView.documentView.chartInfo;
        o.navMap.goTo(o.navDatapointType, {
          seriesKey: s.seriesKey,
          index: s.index
        }), this._paraView.documentView.chartInfo.selectCurrent(!!r), this._selectedElement = e, this._selectedElements.push(e);
      } else
        this.log.info("not a datapoint!");
    }
  }
  // /**
  //  * Set selected element and add a highlight box.
  //  * @param {Element} target The element to be selected; deselects if absent or `null`.
  //  * @private
  //  * @memberOf module:@fizz/touchUI
  //  */
  // _createSelectBox(target: SVGGraphicsElement) {
  //   // this.log.info('_selectElement');
  //   if (target) {
  //     // highlight box
  //     const bbox = target.getBBox();
  //     let x = bbox.x;
  //     let y = bbox.y;
  //     // find any transforms on the element
  //     // TODO: fix this hack
  //     const transforms = (target.parentNode! as SVGGraphicsElement).getAttribute('transform');
  //     if (transforms) {
  //       // highlightBox.setAttribute('transform', transforms );
  //       // x += transforms.e;
  //       // y += transforms.f;
  //       let translate = transforms.split('translate(')[1].split(')')[0].split(',');
  //       x += parseFloat(translate[0]);
  //       y += parseFloat(translate[1]);
  //       // const transformMatrix = target.transform.baseVal.consolidate().matrix;
  //       // this.log.info('target.transform.baseVal.consolidate()', target.transform.baseVal.consolidate());
  //     }
  //     const highlightBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  //     highlightBox.classList.add('_highlight_box');
  //     highlightBox.setAttribute('x', (x - 2.5).toString());
  //     highlightBox.setAttribute('y', (y - 2.5).toString());
  //     highlightBox.setAttribute('width', (bbox.width + 5).toString());
  //     highlightBox.setAttribute('height', (bbox.height + 5).toString());
  //     // this.canvasContainer.firstElementChild.append(highlightBox);
  //     this._highlightBoxes.set(target, highlightBox);
  //   }
  // }
  /**
   * Remove selected element and remove its highlight box.
   * @param target - The element to be selected; deselects if absent or `null`.
   */
  _deselectElement(e) {
  }
  /**
   * Deselect all elements.
   */
  _clearSelectedElements() {
    this._selectedElement = null;
  }
  /**
  * Adjust the coordinates for transforms
  * @param event - The mouse event with the coordinates
  * @returns A coordinate point object with the proper transforms, as a 2-precision float
  */
  _localCoords(e) {
    var n, i;
    let r = {
      x: 0,
      y: 0
    };
    if (e.isTrusted) {
      let s = this._paraView.root.createSVGPoint();
      s.x = e.clientX, s.y = e.clientY, s = s.matrixTransform((i = (n = this._paraView.frame) == null ? void 0 : n.getScreenCTM()) == null ? void 0 : i.inverse()), r = {
        x: +s.x.toFixed(2),
        y: +s.y.toFixed(2)
      };
    }
    return r;
  }
}
const bR = {
  up: "down",
  down: "up",
  left: "right",
  right: "left",
  in: "out",
  out: "in"
};
function yAe(t, e) {
  for (const r in t)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function bAe(t, e) {
  if (!Object.keys(t).length)
    return !0;
  for (const r in t)
    if (t[r] === e[r])
      return !0;
  return !1;
}
class R9 {
  constructor(e, r) {
    this._store = e, this._chart = r, this._layers = /* @__PURE__ */ new Map(), this._runTimer = null, this._currentLayer = "root";
    const n = new w2(this, this._currentLayer);
    this._layers.set(this._currentLayer, n);
  }
  get currentLayer() {
    return this._currentLayer;
  }
  set currentLayer(e) {
    this._currentLayer = e;
  }
  get cursor() {
    return this.layer(this._currentLayer).cursor;
  }
  get root() {
    return this._layers.get("root");
  }
  get chartInfo() {
    return this._chart;
  }
  clone() {
    const e = new R9(this._store, this._chart);
    return e._layers = new Map(this._layers.entries().map(([r, n]) => [r, n.clone(e)])), e._currentLayer = this._currentLayer, e;
  }
  layer(e) {
    return this._layers.get(e);
  }
  registerLayer(e) {
    this._layers.has(e.id) || this._layers.set(e.id, e);
  }
  async visitDatapoints() {
    this._store.visit(this.cursor.datapoints), this._runTimer ? clearTimeout(this._runTimer) : await this._chart.navRunDidStart(this.cursor), this._runTimer = setTimeout(() => {
      this._runTimer = null, this._chart.navRunDidEnd(this.cursor);
    }, this._store.settings.ui.navRunTimeoutMs);
  }
  node(e, r) {
    for (const n of this._layers.values()) {
      const i = n.get(e, r);
      if (i)
        return i;
    }
  }
  goTo(e, r) {
    const n = this.node(e, r);
    if (n)
      n.layer.cursor = n, this._currentLayer = n.layer.id, this.visitDatapoints();
    else
      throw new Error("nav node not found");
  }
  datapointsForSelector(e, r) {
    const n = this._layers.get(e);
    if (!n)
      throw new Error(`no such layer '${e}'`);
    const i = r.split(/-/), s = i[0];
    let o;
    if (s === "datapoint")
      o = n.get("datapoint", {
        seriesKey: i[1],
        index: parseInt(i[2])
      });
    else if (s === "sequence")
      o = n.get("sequence", {
        seriesKey: i[1],
        start: parseInt(i[2]),
        end: parseInt(i[3])
      });
    else if (s === "series")
      o = n.get("series", { seriesKey: i[1] });
    else
      return [];
    return o ? o.datapoints : [];
  }
}
const B2 = class B2 {
  constructor(e, r) {
    this._map = e, this._id = r, this._nodes = /* @__PURE__ */ new Map(), this._nodesById = /* @__PURE__ */ new Map(), e.registerLayer(this);
  }
  get map() {
    return this._map;
  }
  get id() {
    return this._id;
  }
  get cursor() {
    return this._nodesById.get(this._cursor);
  }
  set cursor(e) {
    this._cursor = e.id;
  }
  clone(e) {
    const r = new B2(e, this._id);
    return r._nodesById = new Map(this._nodesById.entries().map(([n, i]) => [n, i.clone(r)])), r._nodes = new Map(this._nodes.entries().map(([n, i]) => [n, [...i]])), r._cursor = this._cursor, r;
  }
  registerNode(e) {
    if (e.index !== -1)
      return;
    this._nodesById.set(e.id, e);
    let r = this._nodes.get(e.type);
    r || (r = [], this._nodes.set(e.type, r)), r.push(e.id), e.index = r.length - 1, this._cursor || (this._cursor = e.id);
  }
  /** Get a node from its ID. */
  node(e) {
    return this._nodesById.get(e);
  }
  /** Get a node from its options or index. */
  get(e, r = 0) {
    const n = this._nodes.get(e);
    if (n)
      return this._nodesById.get(typeof r == "number" ? n[r] : n.find((i) => yAe(r, this._nodesById.get(i).options)));
  }
  /** Get all nodes matching partial options. */
  query(e, r = {}) {
    const n = this._nodes.get(e);
    return n ? n.filter((i) => bAe(r, this._nodesById.get(i).options)).map((i) => this._nodesById.get(i)) : [];
  }
  goToNode(e) {
    this._cursor = e.id, this.map.visitDatapoints();
  }
  goTo(e, r) {
    const n = this.get(e, r);
    if (n)
      this.goToNode(n);
    else
      throw new Error(`nav node not found (type='${e}')`);
  }
};
B2.nextId = 0;
let w2 = B2;
const Rp = class Rp {
  constructor(e, r, n, i) {
    this._layer = e, this._type = r, this._options = n, this._store = i, this._links = /* @__PURE__ */ new Map(), this._index = -1, this._id = `:${Rp.nextId++}`, e.registerNode(this);
  }
  // get datapoints(): readonly DatapointCursor[] {
  //   return this._datapoints;
  // }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get options() {
    return this._options;
  }
  get layer() {
    return this._layer;
  }
  get index() {
    return this._index;
  }
  set index(e) {
    this._index = e;
  }
  get datapoints() {
    const e = [];
    if (this.isNodeType("datapoint") || this.isNodeType("scatterpoint"))
      e.push(this._store.model.atKeyAndIndex(this._options.seriesKey, this._options.index));
    else if (this.isNodeType("series")) {
      const r = this._store.model.atKey(this._options.seriesKey).length;
      for (let n = 0; n < r; n++)
        e.push(this._store.model.atKeyAndIndex(this._options.seriesKey, n));
    } else if (this.isNodeType("chord"))
      e.push(...this._layer.map.chartInfo.seriesInNavOrder().map((r) => r.datapoints[this._options.index]));
    else if (this.isNodeType("sequence"))
      for (let r = this._options.start; r < this._options.end; r++)
        e.push(this._store.model.atKeyAndIndex(this._options.seriesKey, r));
    else this.isNodeType("cluster") && e.push(...this._store.model.atKey(this._options.seriesKey).datapoints.filter((r) => this._options.datapoints.includes(r.datapointIndex)));
    return e;
  }
  clone(e) {
    const r = new Rp(e, this._type, this._options, this._store);
    return r._links = new Map(this._links), r._index = this._index, r._id = this._id, r;
  }
  getLink(e) {
    return this._links.get(e);
  }
  setLink(e, r) {
    this._links.set(e, r.id);
  }
  removeLink(e) {
    this._links.delete(e);
  }
  connect(e, r, n = !0) {
    this.setLink(e, r), r instanceof Rp && n && r.setLink(bR[e], this);
  }
  disconnect(e, r = !0) {
    const n = this._links.get(e);
    n && (this.removeLink(e), n[0] === ":" && r && this._layer.node(n).removeLink(bR[e]));
  }
  peekNode(e, r) {
    let n = this._id;
    for (; n && r--; ) {
      const i = this._layer.node(n).getLink(e);
      n = i && i[0] !== ":" ? void 0 : i;
    }
    return n ? this._layer.node(n) : void 0;
  }
  allNodes(e, r) {
    let n = 1, i;
    const s = [];
    for (; i = this.peekNode(e, n++), i && (!r || r === i.type); ) {
      if (s.includes(i))
        break;
      s.push(i);
    }
    return s;
  }
  async move(e) {
    const r = this._links.get(e);
    r && (r[0] === ":" ? this.layer.cursor = this._layer.node(r) : this._layer.map.currentLayer = r, this._layer.map.visitDatapoints());
  }
  go() {
    this.layer.goToNode(this);
  }
  isNodeType(e) {
    return this.type === e;
  }
  isDatapointNode() {
    return this.type === "datapoint";
  }
};
Rp.nextId = 0;
let Ia = Rp;
var kn = /* @__PURE__ */ ((t) => (t.Annotation = "annotation", t.Bumper = "bumper", t.Threshold = "threshold", t.Intersection = "intersection", t.High = "high", t.Low = "low", t.Series = "series", t))(kn || {});
const Bf = 130.8128, Ff = 195.9977, ex = Bf * 2, z1 = Ff * 2, vR = z1 * 2;
class vAe {
  /**
   * Create a new OscillatorAudioEngine.
   * @param context - the audio context
   */
  constructor(e) {
    this._audioContext = e, this._masterCompressor = e.createDynamicsCompressor(), this._masterCompressor.connect(this._audioContext.destination), this._masterCompressor.threshold.value = -50, this._masterCompressor.knee.value = 40, this._masterCompressor.ratio.value = 12, this._masterCompressor.attack.value = 0, this._masterCompressor.release.value = 0.25, this._masterGain = this._audioContext.createGain(), this._masterGain.gain.value = 0.5, this._masterCompressor.connect(this._masterGain), this._masterGain.connect(this._audioContext.destination);
  }
  get masterGain() {
    return this._masterGain.gain.value;
  }
  /**
   *The overall loudness of the audio engine.
   */
  set masterGain(e) {
    this._masterGain.gain.value = e;
  }
  /**
   * Play a sound to represent a data point.
   * @param frequency - the fundimental frequency
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds, defaults to 0.2
   */
  playDataPoint(e, r, n = 0.2) {
    this._playNote(
      e,
      r,
      n,
      this._masterCompressor
    );
  }
  /**
   * Play an audio notification.
   * @param notificationType - the type of audio notification
   * @param [panning] - where to play the sound (-1 <= 0 <= 1, 0 == center). Default: 0
   * @param [duration] - the duration of the notification in seconds. Default: 0.15
   */
  playNotification(e, r = 0, n = 0.15) {
    switch (e) {
      case kn.Annotation:
        this._playAnnotation(r, n);
        break;
      case kn.Bumper:
        this._playBumper(r, n);
        break;
      case kn.Intersection:
        this._playIntersection(r, n);
        break;
      case kn.High:
        this._playHigh(r, n);
        break;
      case kn.Low:
        this._playLow(r, n);
        break;
      case kn.Series:
        this._playSeriesChange(r, n);
        break;
      case kn.Threshold:
        this._playThreshold(r, n);
        break;
    }
  }
  /**
   * Play a data point, sending the audio to the given destination node.
   * @param frequency - the fundimental frequency
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   * @param destinationNode - the node to receive the audio
   */
  _playNote(e, r, n, i) {
    const s = this._audioContext.currentTime, o = this._audioContext.createOscillator();
    o.frequency.value = e, o.start();
    const {
      carrier: a,
      amp: l,
      modulator: c,
      filter: p,
      adsr: h
    } = wAe(
      this._audioContext,
      e * 0.5,
      e * 3,
      e * 2
    );
    a.type = "triangle", h.gain.setValueCurveAtTime([0.2, 0.1], s, n * 0.75), p.frequency.value = e, p.type = "lowpass";
    const d = this._audioContext.createGain();
    d.gain.setValueCurveAtTime(
      [0.5, 1, 0.5, 0.5, 0.5, 0.1, 1e-4],
      s,
      n
    );
    const b = this._audioContext.createStereoPanner();
    b.pan.value = r, o.connect(d), h.connect(d), d.connect(b), b.connect(i), setTimeout(
      () => {
        b.disconnect(), d.disconnect(), h.disconnect(), o.stop(), o.disconnect(), c.stop(), c.disconnect(), a.stop(), a.disconnect(), l.disconnect(), p.disconnect();
      },
      n * 1e3 * 2
    );
  }
  /**
   * Play a sound that means that an annotation is present.
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playAnnotation(e, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = e;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(Bf, 0, r / 4, i), this._playNote(ex, 0, r / 4, i), setTimeout(
      () => {
        this._playNote(Ff, 0, r / 4, i), this._playNote(z1, 0, r / 4, i), this._playNote(vR, 0, r / 4, i);
      },
      r * 1e3 * 0.25
    ), setTimeout(
      () => {
        this._playNote(Bf, 0, r / 4, i), this._playNote(ex, 0, r / 4, i);
      },
      r * 1e3 * 0.5
    ), setTimeout(
      () => {
        this._playNote(Ff, 0, r / 4, i), this._playNote(z1, 0, r / 4, i), this._playNote(vR, 0, r / 4, i);
      },
      r * 1e3 * 0.75
    ), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
   * Play a sound that means that an annotation is present.
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playBumper(e, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = e;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(Bf, 0, r / 4, i), this._playNote(ex, 0, r / 4, i), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
   * Play a sound that means that an annotation is present.
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playSeriesChange(e, r) {
  }
  /**
   * Play a sound to indicate this is the series or chart low
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playLow(e, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = e;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(Ff, 0, r / 4, i), setTimeout(
      () => {
        this._playNote(Bf, 0, r / 4, i);
      },
      r * 1e3 * 0.5
    ), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
   * Play a sound to indicate this is the series or chart high
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playHigh(e, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = e;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(Ff, 0, r / 4, i), setTimeout(
      () => {
        this._playNote(z1, 0, r / 4, i);
      },
      r * 1e3 * 0.5
    ), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
  * Play a sound to indicate that this section contains an intersection
  * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
  * @param duration - the duration of the note in seconds
  */
  _playIntersection(e, r) {
  }
  /**
  * Play a sound to indicate that this section intersects a threshold line or point
  * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
  * @param duration - the duration of the note in seconds
  */
  _playThreshold(e, r) {
  }
}
function wAe(t, e, r, n) {
  const i = t.createOscillator(), s = t.createGain(), o = t.createOscillator(), a = t.createBiquadFilter(), l = t.createGain();
  return i.frequency.value = e, o.frequency.value = r, s.gain.value = n, o.connect(s), s.connect(i.frequency), i.connect(a), a.connect(l), i.start(), o.start(), { carrier: i, amp: s, modulator: o, filter: a, adsr: l };
}
class df extends bo(Pr) {
  constructor(e, r, n) {
    super(e), this._width = r, this._height = n;
  }
  _createId(e) {
    return `${e}-layer`;
  }
  _addedToParent() {
    this.setSize(this._parent.logicalWidth, this._parent.logicalHeight, !1);
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
}
class jo extends Wv {
  constructor(e, r) {
    super(e, r), this._points = r.points.map((n) => n.clone());
  }
  get _options() {
    let e = super._options;
    return e.points = this._points.map((r) => r.clone()), e;
  }
  clone() {
    return new jo(this.paraview, this._options);
  }
  get points() {
    return this._points.map((e) => e.clone());
  }
  set points(e) {
    this._points = e.map((r) => r.clone());
  }
  get xs() {
    return this._points.map((e) => e.x);
  }
  get ys() {
    return this._points.map((e) => e.y);
  }
  get width() {
    return Math.max(...this.xs) - Math.min(...this.xs);
  }
  get height() {
    return Math.max(...this.ys) - Math.min(...this.ys);
  }
  get left() {
    return this._x + Math.min(...this.xs);
  }
  set left(e) {
    this._x += e - this.left;
  }
  get right() {
    return this._x + Math.max(...this.xs);
  }
  set right(e) {
    this._x += e - this.right;
  }
  get top() {
    return this._y + Math.min(...this.ys);
  }
  set top(e) {
    this._y += e - this.top;
  }
  get bottom() {
    return this._y + Math.max(...this.ys);
  }
  set bottom(e) {
    this._y += e - this.bottom;
  }
  get _pathD() {
    const e = this._points.map((n) => n.add(this._loc));
    let r = nt`M${e[0].x},${e[0].y}`;
    return e.slice(1).forEach((n) => {
      r += nt`L${n.x},${n.y}`;
    }), r;
  }
  render() {
    return Tt`
      <path
        ${this._ref ? yt(this._ref) : void 0}
        id=${this._id || De}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : De}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : De}
        role=${this._role || De}
        d=${this._pathD}
        clip-path=${this._options.isClip ? "url(#clip-path)" : De}
      ></path>
    `;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class J4 extends _b {
  constructor(e) {
    if (super(e), this.it = De, e.type !== Ab.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(e) {
    if (e === De || e == null) return this._t = void 0, this.it = e;
    if (e === Ra) return e;
    if (typeof e != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (e === this.it) return this._t;
    this.it = e;
    const r = [e];
    return r.raw = r, this._t = { _$litType$: this.constructor.resultType, strings: r, values: [] };
  }
}
J4.directiveName = "unsafeHTML", J4.resultType = 1;
const iU = kb(J4);
class di extends Pr {
  constructor(e, r) {
    super(e), this.options = r, this._elRef = Et(), this._textLines = [], this._canWidthFlex = !0, this._canHeightFlex = !0, r.classList ? (r.classList.includes("label") || r.classList.push("label"), this._classInfo = Object.fromEntries(r.classList.map((n) => [n, !0]))) : this._classInfo = {
      label: !0
    }, this._angle = this.options.angle ?? 0, this._textAnchor = this.options.textAnchor ?? (r.wrapWidth ? "start" : "middle"), this._justify = this.options.justify ?? "start", this._lineSpacing = this.options.lineSpacing ?? 0, this._text = this.options.text, this.updateSize(), this.options.loc && (this._loc = this.options.loc), this.options.x && (this._x = this.options.x), this.options.y && (this._y = this.options.y), this.options.left && (this.left = this.options.left), this.options.right && (this.right = this.options.right), this.options.top && (this.top = this.options.top), this.options.bottom && (this.bottom = this.options.bottom), this.options.centerX && (this.centerX = this.options.centerX), this.options.centerY && (this.centerY = this.options.centerY), this.options.topLeft && (this.topLeft = this.options.topLeft), this.options.topRight && (this.topRight = this.options.topRight), this.options.bottomRight && (this.bottomRight = this.options.bottomRight), this.options.bottomLeft && (this.bottomLeft = this.options.bottomLeft);
  }
  _createId() {
    return this.options.id || a8e(this._text, this.paraview.store);
  }
  get el() {
    return this._elRef.value;
  }
  get text() {
    return this._text;
  }
  set text(e) {
    this._text = e, this.updateSize(), this.paraview.requestUpdate();
  }
  get angle() {
    return this._angle;
  }
  set angle(e) {
    this._angle = e, this.updateSize();
  }
  get textAnchor() {
    return this._textAnchor;
  }
  set textAnchor(e) {
    this._textAnchor = e, this.updateSize();
  }
  // get bbox() {
  //   return this._elRef.value!.getBBox();
  // }
  get topLeft() {
    return this._loc.add(this._textCornerOffsets.topLeft);
  }
  set topLeft(e) {
    this._loc = e.subtract(this._textCornerOffsets.topLeft);
  }
  get topRight() {
    return this._loc.add(this._textCornerOffsets.topRight);
  }
  set topRight(e) {
    this._loc = e.subtract(this._textCornerOffsets.topRight);
  }
  get bottomRight() {
    return this._loc.add(this._textCornerOffsets.bottomRight);
  }
  set bottomRight(e) {
    this._loc = e.subtract(this._textCornerOffsets.bottomRight);
  }
  get bottomLeft() {
    return this._loc.add(this._textCornerOffsets.bottomLeft);
  }
  set bottomLeft(e) {
    this._loc = e.subtract(this._textCornerOffsets.bottomLeft);
  }
  get textCorners() {
    return {
      topLeft: this.topLeft,
      topRight: this.topRight,
      bottomRight: this.bottomRight,
      bottomLeft: this.bottomLeft
    };
  }
  resize(e, r) {
  }
  computeSize() {
    var w;
    const e = document.createElementNS(Ip, "text");
    this.options.classList && e.classList.add(...this.options.classList), e.setAttribute("text-anchor", this._textAnchor), e.style.visibility = "hidden", this._text ? e.textContent = this._text : e.innerHTML = "&nbsp;", this._angle && e.setAttribute("transform", `rotate(${this._angle})`), this.paraview.root.append(e);
    const r = ((w = this.paraview.root) == null ? void 0 : w.getBoundingClientRect()) ?? new DOMRect(0, 0, 0, 0), n = e.getBoundingClientRect();
    let i = n.width, s = n.height;
    this._locOffset.x = -(n.x - r.x), this._locOffset.y = -(n.y - r.y);
    let o = 0, a = 0, l = 0, c = 0;
    const p = this.options.wrapWidth !== void 0 && Math.max(i, s) > this.options.wrapWidth;
    if (p || this._text.includes(`
`)) {
      e.textContent = "";
      const f = [document.createElementNS(Ip, "tspan")], E = this._text.split(p ? /(\s+)/ : /(\n+)/);
      for (f.at(-1).textContent = E.shift(), e.append(f.at(-1)); E.length; ) {
        const x = E.shift();
        if (x.includes(`
`)) {
          f.push(document.createElementNS(Ip, "tspan"));
          const k = f.at(-1);
          e.append(k), k.textContent = x, k.setAttribute("x", "0");
          const S = f.at(-2).getBoundingClientRect();
          k.setAttribute("dy", `${S.height + this._lineSpacing}px`);
          continue;
        }
        if (!x.match(/\w/))
          continue;
        const g = f.at(-1), v = g.textContent;
        if (p) {
          g.textContent += " " + x;
          const k = this.paraview.store.settings.ui.isFullscreenEnabled ? g.getBBox() : g.getBoundingClientRect();
          Math.max(k.height, k.width) >= this.options.wrapWidth && (g.textContent = v, f.push(document.createElementNS(Ip, "tspan")), e.append(f.at(-1)), f.at(-1).textContent = x, f.at(-1).setAttribute("x", "0"), f.at(-1).setAttribute("dy", `${Math.min(k.height, k.width) + this._lineSpacing}px`));
        } else {
          g.textContent = x;
          const k = g.getBoundingClientRect();
          f.length > 1 && (f.at(-1).setAttribute("x", "0"), f.at(-1).setAttribute("dy", `${k.height + this._lineSpacing}px`));
        }
      }
      const A = this.paraview.store.settings.ui.isFullscreenEnabled ? e.getBBox() : e.getBoundingClientRect();
      i = A.width, s = A.height, this._locOffset.x = -(A.x - r.x), this._locOffset.y = -(A.y - r.y), this._textLines = f.map((x) => ({ text: x.textContent, offset: 0 })), this._justify !== "start" && f.forEach((x, g) => {
        const v = x.getBoundingClientRect();
        let k = i - v.width;
        this._justify === "center" && (k = k / 2), this._textLines[g].offset = k;
      }), f.forEach((x) => {
        const g = x.getNumberOfChars();
        for (let v = 0; v < g; v++) {
          const k = x.getExtentOfChar(v);
          o = Math.min(o, k.y), a = Math.max(a, k.y + k.height), l = Math.min(l, k.x), c = Math.max(c, k.x + k.width);
        }
      }), this._lineHeight = f[0].getExtentOfChar(0).height, f.forEach((x) => x.remove());
    } else {
      this._textLines = [];
      const f = e.getNumberOfChars();
      o = e.getExtentOfChar(0).y, a = e.getExtentOfChar(0).y + e.getExtentOfChar(0).height, l = e.getExtentOfChar(0).x, c = e.getExtentOfChar(f - 1).x + e.getExtentOfChar(f - 1).width, this._lineHeight = e.getExtentOfChar(0).height;
    }
    const h = new Ye(l, o).rotate(-this._angle * Math.PI / 180), d = new Ye(c, o).rotate(-this._angle * Math.PI / 180), b = new Ye(c, a).rotate(-this._angle * Math.PI / 180), m = new Ye(l, a).rotate(-this._angle * Math.PI / 180);
    return this._textCornerOffsets = {
      topLeft: h,
      topRight: d,
      bottomRight: b,
      bottomLeft: m
    }, e.remove(), [i, s];
  }
  _makeTransform() {
    let e;
    return this._angle && (e = nt`
        translate(${this._x},${this._y})
        rotate(${this._angle})
        translate(${-this._x},${-this._y})`), e;
  }
  settingDidChange(e, r, n) {
    this.updateSize(), super.settingDidChange(e, r, n);
  }
  render() {
    return Tt`
      ${this.options.hasBackground ? Tt`
          <path
            class="label-bg"
            d="
              M${this.topLeft.x},${this.topLeft.y}
              L${this.topRight.x},${this.topRight.y}
              L${this.bottomRight.x},${this.bottomRight.y}
              L${this.bottomLeft.x},${this.bottomLeft.y}
              Z"
            width=${this._width}
            height=${this._height}
          ></path>
        ` : ""}
      <text
        ${yt(this._elRef)}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : De}
        role=${this.options.role ?? De}
        x=${nt`${this._x}`}
        y=${nt`${this._y}`}
        text-anchor=${this._textAnchor !== "start" ? this._textAnchor : De}
        transform=${this._makeTransform() ?? De}
        id=${this.id}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : De}
        @pointerenter=${this.options.pointerEnter ?? De}
        @pointerleave=${this.options.pointerLeave ?? De}
        @click=${this.options.click ?? De}
      >
        ${this._textLines.length ? this._textLines.map((e, r) => Tt`
              <tspan
                x=${nt`${this._x + e.offset}`}
                dy=${r === 0 ? "0" : this._lineHeight + this._lineSpacing}
              >
                ${e.text}
              </tspan>
            `) : this._text ? this._text : iU("&nbsp;")}
      </text>
    `;
  }
}
function r1(t) {
  return t * Math.PI / 180;
}
function xAe(t) {
  return t * 180 / Math.PI;
}
function wR(t) {
  return t %= 360, t < 0 ? 360 + t : t;
}
function n1(t, e, r) {
  return t * (1 - r) + e * r;
}
class x2 extends Wv {
  constructor(e, r) {
    super(e, r), this.options = r, this._annularThickness = null, this._arcSweep = 1, this._r = r.r, this._centralAngle = r.centralAngle, this._orientationAngle = r.orientationAngle, this._orientationAngleCounterclockwise = !!r.orientationAngleCounterclockwise, r.annularThickness && (this._annularThickness = r.annularThickness), this._arcCenterIsOrientationAnchor = !!r.arcCenterIsOrientationAnchor, this._orientationAngleOffset = r.orientationAngleOffset ?? 90, r.isPattern && (this._isPattern = r.isPattern), this.computeLayout();
  }
  get _options() {
    let e = super._options;
    return e.r = this._r, e.centralAngle = this._centralAngle, e.orientationAngle = this._orientationAngle, e.orientationAngleCounterclockwise = this._orientationAngleCounterclockwise, this._annularThickness && (e.annularThickness = this._annularThickness), e.arcCenterIsOrientationAnchor = this._arcCenterIsOrientationAnchor, e.orientationAngleOffset = this._orientationAngleOffset, this._isPattern && (e.isPattern = this._isPattern), e;
  }
  clone() {
    return new x2(this.paraview, this._options);
  }
  get x() {
    return super.x;
  }
  set x(e) {
    super.x = e, this.computeLayout();
  }
  get y() {
    return super.y;
  }
  set y(e) {
    super.y = e, this.computeLayout();
  }
  get loc() {
    return this._loc;
  }
  set loc(e) {
    this._loc = e, this.computeLayout();
  }
  get startX() {
    return this._startX;
  }
  get startY() {
    return this._startY;
  }
  get endX() {
    return this._endX;
  }
  get endY() {
    return this._endY;
  }
  _orientationAngleToPolar(e) {
    return wR((this._orientationAngleCounterclockwise ? e : 360 - e) + this._orientationAngleOffset);
  }
  _polarAngleToOrientation(e) {
    const r = e - this._orientationAngleOffset;
    return wR(this._orientationAngleCounterclockwise ? r : 360 - r);
  }
  /**
   * Convert polar angle to Cartesian vector.
   * @returns Vector with origin at circle center, positive y UP
   */
  _angleToVector(e) {
    return new Ye(
      this._r * Math.cos(r1(e)),
      this._r * Math.sin(r1(e))
    );
  }
  /**
   * Convert Cartesian vector to polar angle.
   */
  _vectorToAngle(e) {
    e = e.normalize();
    const r = Math.abs(xAe(Math.asin(e.y)));
    return e.x >= 0 && e.y >= 0 ? r : e.x < 0 && e.y >= 0 ? 180 - r : e.x < 0 && e.y < 0 ? 180 + r : 360 - r;
  }
  get arcCenterAngle() {
    return this._orientationAngleToPolar(this._arcCenterIsOrientationAnchor ? this._orientationAngle : this._orientationAngle + this._centralAngle / 2);
  }
  get arcCenter() {
    return this._angleToVector(this.arcCenterAngle).multiply(new Ye(1, -1)).add(this._loc);
  }
  get arcLeftAngle() {
    return this._orientationAngleToPolar(this._arcCenterIsOrientationAnchor ? this._orientationAngle + this._centralAngle / 2 : this._orientationAngle);
  }
  get arcLeft() {
    return this._angleToVector(this.arcLeftAngle).multiply(new Ye(1, -1)).add(this._loc);
  }
  get arcRightAngle() {
    return this._orientationAngleToPolar(this._arcCenterIsOrientationAnchor ? this._orientationAngle + this._centralAngle / 2 : this._orientationAngle + this._centralAngle);
  }
  get arcRight() {
    return this._angleToVector(this.arcRightAngle).multiply(new Ye(1, -1)).add(this._loc);
  }
  get r() {
    return this._r;
  }
  set r(e) {
    this._r = e, this.computeLayout();
  }
  get centralAngle() {
    return this._centralAngle;
  }
  set centralAngle(e) {
    this._centralAngle = e, this.computeLayout();
  }
  get orientationAngle() {
    return this._orientationAngle;
  }
  set orientationAngle(e) {
    this._orientationAngle = e, this.computeLayout();
  }
  get annularThickness() {
    return this._annularThickness;
  }
  set annularThickness(e) {
    this._annularThickness = e, this.computeLayout();
  }
  get orientationVector() {
    return this.arcCenter.subtract(this._loc).normalize();
  }
  containsPoint(e) {
    const r = e.subtract(this._loc);
    r.y = -r.y;
    const n = this._polarAngleToOrientation(this._vectorToAngle(r)), i = this._polarAngleToOrientation(this.arcLeftAngle), s = this._polarAngleToOrientation(this.arcRightAngle), o = n >= i && n <= (s === 0 ? 360 : s);
    return this._annularThickness === null || this._annularThickness === 1 ? o && r.length() <= this._r : o && r.length() >= this._r - this._annularThickness * this._r;
  }
  computeLayout() {
    const e = r1(this.arcLeftAngle), r = r1(this.arcRightAngle);
    this._startX = this._x + this._r * Math.cos(e), this._startY = this._y - this._r * Math.sin(e), this._endX = this._x + this._r * Math.cos(r), this._endY = this._y - this._r * Math.sin(r), this._arcLarge = this._centralAngle >= 180 ? 1 : 0;
  }
  get _pathD() {
    let e = this._x, r = this.y, n = 0;
    return this._annularThickness !== null && this._annularThickness < 1 && (n = this._r * (1 - this._annularThickness), e = n1(this._x, this._startX, 1 - this._annularThickness), r = n1(this._y, this._startY, 1 - this._annularThickness)), nt`
      M${e},${r}
      L${this._startX},${this._startY}
      A${this._r},${this._r}
        0 ${this._arcLarge} ${this._arcSweep}
        ${this._endX},${this._endY}
      ${this._annularThickness !== null && this._annularThickness < 1 ? nt`
          L${n1(this._endX, this._x, this._annularThickness)},
          ${n1(this._endY, this._y, this._annularThickness)}
          A${n},${n}
            0 ${this._arcLarge} ${1 - this._arcSweep}
            ${e},${r}
        ` : ""}
      Z`;
  }
  render() {
    if (this._options.isPattern) {
      let e = this.parent.index, r = this.parent;
      return this._styleInfo.fill = `url(#Pattern${e})`, this.paraview.store.isVisited(r.seriesKey, e) && (this._styleInfo.stroke = this.paraview.store.colors.colorValue("visit"), this._styleInfo.strokeWidth = 6), Tt`
          <defs>${this.paraview.store.colors.patternValueAt(e)}</defs>
          <path
            d=${this._pathD}
            transform=${this._scale !== 1 ? `translate(${this._x},${this._y})
                    scale(${this._scale})
                    translate(${-this._x},${-this._y})` : De}
            fill="white"
            stroke="black"
            stroke-width=4
            clip-path=${this._options.isClip ? "url(#clip-path)" : De}
          ></path>
          <path
            ${this._ref ? yt(this._ref) : void 0}
            id=${this._id || De}
            style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : De}
            class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : De}
            role=${this._role || De}
            d=${this._pathD}
            transform=${this._scale !== 1 ? `translate(${this._x},${this._y})
                    scale(${this._scale})
                    translate(${-this._x},${-this._y})` : De}
            clip-path=${this._options.isClip ? "url(#clip-path)" : De}
            @pointerenter=${this.options.pointerEnter ?? De}
            @pointerleave=${this.options.pointerLeave ?? De}
          ></path>
        `;
    } else
      return Tt`
      <path
        ${this._ref ? yt(this._ref) : void 0}
        id=${this._id || De}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : De}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : De}
        role=${this._role || De}
        d=${this._pathD}
        transform=${this._scale !== 1 ? `translate(${this._x},${this._y})
             scale(${this._scale})
             translate(${-this._x},${-this._y})` : De}
        clip-path=${this._options.isClip ? "url(#clip-path)" : De}
        @pointerenter=${this.options.pointerEnter ?? De}
        @pointerleave=${this.options.pointerLeave ?? De}
      ></path>
    `;
  }
}
/*!
 *  decimal.js v10.5.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var X4 = 9e15, tu = 1e9, eE = "0123456789abcdef", E2 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", S2 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", tE = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -9e15,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: X4,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, sU, ba, _t = !0, qv = "[DecimalError] ", uc = qv + "Invalid argument: ", oU = qv + "Precision limit exceeded", aU = qv + "crypto unavailable", lU = "[object Decimal]", Fn = Math.floor, Kr = Math.pow, EAe = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, SAe = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, AAe = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, cU = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Ws = 1e7, xt = 7, kAe = 9007199254740991, _Ae = E2.length - 1, rE = S2.length - 1, Be = { toStringTag: lU };
Be.absoluteValue = Be.abs = function() {
  var t = new this.constructor(this);
  return t.s < 0 && (t.s = 1), ft(t);
};
Be.ceil = function() {
  return ft(new this.constructor(this), this.e + 1, 2);
};
Be.clampedTo = Be.clamp = function(t, e) {
  var r, n = this, i = n.constructor;
  if (t = new i(t), e = new i(e), !t.s || !e.s) return new i(NaN);
  if (t.gt(e)) throw Error(uc + e);
  return r = n.cmp(t), r < 0 ? t : n.cmp(e) > 0 ? e : new i(n);
};
Be.comparedTo = Be.cmp = function(t) {
  var e, r, n, i, s = this, o = s.d, a = (t = new s.constructor(t)).d, l = s.s, c = t.s;
  if (!o || !a)
    return !l || !c ? NaN : l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? l : a[0] ? -c : 0;
  if (l !== c) return l;
  if (s.e !== t.e) return s.e > t.e ^ l < 0 ? 1 : -1;
  for (n = o.length, i = a.length, e = 0, r = n < i ? n : i; e < r; ++e)
    if (o[e] !== a[e]) return o[e] > a[e] ^ l < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
};
Be.cosine = Be.cos = function() {
  var t, e, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + xt, n.rounding = 1, r = CAe(n, fU(n, r)), n.precision = t, n.rounding = e, ft(ba == 2 || ba == 3 ? r.neg() : r, t, e, !0)) : new n(1) : new n(NaN);
};
Be.cubeRoot = Be.cbrt = function() {
  var t, e, r, n, i, s, o, a, l, c, p = this, h = p.constructor;
  if (!p.isFinite() || p.isZero()) return new h(p);
  for (_t = !1, s = p.s * Kr(p.s * p, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = dn(p.d), t = p.e, (s = (t - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Kr(r, 1 / 3), t = Fn((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + t : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + t), n = new h(r), n.s = p.s) : n = new h(s.toString()), o = (t = h.precision) + 3; ; )
    if (a = n, l = a.times(a).times(a), c = l.plus(p), n = lr(c.plus(p).times(a), c.plus(l), o + 2, 1), dn(a.d).slice(0, o) === (r = dn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (ft(a, t + 1, 0), a.times(a).times(a).eq(p))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (ft(n, t + 1, 1), e = !n.times(n).times(n).eq(p));
        break;
      }
  return _t = !0, ft(n, t, h.rounding, e);
};
Be.decimalPlaces = Be.dp = function() {
  var t, e = this.d, r = NaN;
  if (e) {
    if (t = e.length - 1, r = (t - Fn(this.e / xt)) * xt, t = e[t], t) for (; t % 10 == 0; t /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
Be.dividedBy = Be.div = function(t) {
  return lr(this, new this.constructor(t));
};
Be.dividedToIntegerBy = Be.divToInt = function(t) {
  var e = this, r = e.constructor;
  return ft(lr(e, new r(t), 0, 1, 1), r.precision, r.rounding);
};
Be.equals = Be.eq = function(t) {
  return this.cmp(t) === 0;
};
Be.floor = function() {
  return ft(new this.constructor(this), this.e + 1, 3);
};
Be.greaterThan = Be.gt = function(t) {
  return this.cmp(t) > 0;
};
Be.greaterThanOrEqualTo = Be.gte = function(t) {
  var e = this.cmp(t);
  return e == 1 || e === 0;
};
Be.hyperbolicCosine = Be.cosh = function() {
  var t, e, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (t = Math.ceil(i / 3), e = (1 / Kv(4, t)).toString()) : (t = 16, e = "2.3283064365386962890625e-10"), s = cd(o, 1, s.times(e), new o(1), !0);
  for (var l, c = t, p = new o(8); c--; )
    l = s.times(s), s = a.minus(l.times(p.minus(l.times(p))));
  return ft(s, o.precision = r, o.rounding = n, !0);
};
Be.hyperbolicSine = Be.sinh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero()) return new s(i);
  if (e = s.precision, r = s.rounding, s.precision = e + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = cd(s, 2, i, i, !0);
  else {
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, i = i.times(1 / Kv(5, t)), i = cd(s, 2, i, i, !0);
    for (var o, a = new s(5), l = new s(16), c = new s(20); t--; )
      o = i.times(i), i = i.times(a.plus(o.times(l.times(o).plus(c))));
  }
  return s.precision = e, s.rounding = r, ft(i, e, r, !0);
};
Be.hyperbolicTangent = Be.tanh = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 7, n.rounding = 1, lr(r.sinh(), r.cosh(), n.precision = t, n.rounding = e)) : new n(r.s);
};
Be.inverseCosine = Be.acos = function() {
  var t = this, e = t.constructor, r = t.abs().cmp(1), n = e.precision, i = e.rounding;
  return r !== -1 ? r === 0 ? t.isNeg() ? Mo(e, n, i) : new e(0) : new e(NaN) : t.isZero() ? Mo(e, n + 4, i).times(0.5) : (e.precision = n + 6, e.rounding = 1, t = new e(1).minus(t).div(t.plus(1)).sqrt().atan(), e.precision = n, e.rounding = i, t.times(2));
};
Be.inverseHyperbolicCosine = Be.acosh = function() {
  var t, e, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, _t = !1, r = r.times(r).minus(1).sqrt().plus(r), _t = !0, n.precision = t, n.rounding = e, r.ln()) : new n(r);
};
Be.inverseHyperbolicSine = Be.asinh = function() {
  var t, e, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, _t = !1, r = r.times(r).plus(1).sqrt().plus(r), _t = !0, n.precision = t, n.rounding = e, r.ln());
};
Be.inverseHyperbolicTangent = Be.atanh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (t = s.precision, e = s.rounding, n = i.sd(), Math.max(n, t) < 2 * -i.e - 1 ? ft(new s(i), t, e, !0) : (s.precision = r = n - i.e, i = lr(i.plus(1), new s(1).minus(i), r + t, 1), s.precision = t + 4, s.rounding = 1, i = i.ln(), s.precision = t, s.rounding = e, i.times(0.5))) : new s(NaN);
};
Be.inverseSine = Be.asin = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (e = i.abs().cmp(1), r = s.precision, n = s.rounding, e !== -1 ? e === 0 ? (t = Mo(s, r + 4, n).times(0.5), t.s = i.s, t) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
Be.inverseTangent = Be.atan = function() {
  var t, e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new p(c);
    if (c.abs().eq(1) && h + 4 <= rE)
      return o = Mo(p, h + 4, d).times(0.25), o.s = c.s, o;
  } else {
    if (!c.s) return new p(NaN);
    if (h + 4 <= rE)
      return o = Mo(p, h + 4, d).times(0.5), o.s = c.s, o;
  }
  for (p.precision = a = h + 10, p.rounding = 1, r = Math.min(28, a / xt + 2 | 0), t = r; t; --t) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (_t = !1, e = Math.ceil(a / xt), n = 1, l = c.times(c), o = new p(c), i = c; t !== -1; )
    if (i = i.times(l), s = o.minus(i.div(n += 2)), i = i.times(l), o = s.plus(i.div(n += 2)), o.d[e] !== void 0) for (t = e; o.d[t] === s.d[t] && t--; ) ;
  return r && (o = o.times(2 << r - 1)), _t = !0, ft(o, p.precision = h, p.rounding = d, !0);
};
Be.isFinite = function() {
  return !!this.d;
};
Be.isInteger = Be.isInt = function() {
  return !!this.d && Fn(this.e / xt) > this.d.length - 2;
};
Be.isNaN = function() {
  return !this.s;
};
Be.isNegative = Be.isNeg = function() {
  return this.s < 0;
};
Be.isPositive = Be.isPos = function() {
  return this.s > 0;
};
Be.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
Be.lessThan = Be.lt = function(t) {
  return this.cmp(t) < 0;
};
Be.lessThanOrEqualTo = Be.lte = function(t) {
  return this.cmp(t) < 1;
};
Be.logarithm = Be.log = function(t) {
  var e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding, b = 5;
  if (t == null)
    t = new p(10), e = !0;
  else {
    if (t = new p(t), r = t.d, t.s < 0 || !r || !r[0] || t.eq(1)) return new p(NaN);
    e = t.eq(10);
  }
  if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1))
    return new p(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (e)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      s = i !== 1;
    }
  if (_t = !1, a = h + b, o = Ll(c, a), n = e ? A2(p, a + 10) : Ll(t, a), l = lr(o, n, a, 1), Z0(l.d, i = h, d))
    do
      if (a += 10, o = Ll(c, a), n = e ? A2(p, a + 10) : Ll(t, a), l = lr(o, n, a, 1), !s) {
        +dn(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = ft(l, h + 1, 0));
        break;
      }
    while (Z0(l.d, i += 10, d));
  return _t = !0, ft(l, h, d);
};
Be.minus = Be.sub = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, b = this, m = b.constructor;
  if (t = new m(t), !b.d || !t.d)
    return !b.s || !t.s ? t = new m(NaN) : b.d ? t.s = -t.s : t = new m(t.d || b.s !== t.s ? b : NaN), t;
  if (b.s != t.s)
    return t.s = -t.s, b.plus(t);
  if (c = b.d, d = t.d, a = m.precision, l = m.rounding, !c[0] || !d[0]) {
    if (d[0]) t.s = -t.s;
    else if (c[0]) t = new m(b);
    else return new m(l === 3 ? -0 : 0);
    return _t ? ft(t, a, l) : t;
  }
  if (r = Fn(t.e / xt), p = Fn(b.e / xt), c = c.slice(), s = p - r, s) {
    for (h = s < 0, h ? (e = c, s = -s, o = d.length) : (e = d, r = p, o = c.length), n = Math.max(Math.ceil(a / xt), o) + 2, s > n && (s = n, e.length = 1), e.reverse(), n = s; n--; ) e.push(0);
    e.reverse();
  } else {
    for (n = c.length, o = d.length, h = n < o, h && (o = n), n = 0; n < o; n++)
      if (c[n] != d[n]) {
        h = c[n] < d[n];
        break;
      }
    s = 0;
  }
  for (h && (e = c, c = d, d = e, t.s = -t.s), o = c.length, n = d.length - o; n > 0; --n) c[o++] = 0;
  for (n = d.length; n > s; ) {
    if (c[--n] < d[n]) {
      for (i = n; i && c[--i] === 0; ) c[i] = Ws - 1;
      --c[i], c[n] += Ws;
    }
    c[n] -= d[n];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --r;
  return c[0] ? (t.d = c, t.e = Qv(c, r), _t ? ft(t, a, l) : t) : new m(l === 3 ? -0 : 0);
};
Be.modulo = Be.mod = function(t) {
  var e, r = this, n = r.constructor;
  return t = new n(t), !r.d || !t.s || t.d && !t.d[0] ? new n(NaN) : !t.d || r.d && !r.d[0] ? ft(new n(r), n.precision, n.rounding) : (_t = !1, n.modulo == 9 ? (e = lr(r, t.abs(), 0, 3, 1), e.s *= t.s) : e = lr(r, t, 0, n.modulo, 1), e = e.times(t), _t = !0, r.minus(e));
};
Be.naturalExponential = Be.exp = function() {
  return nE(this);
};
Be.naturalLogarithm = Be.ln = function() {
  return Ll(this);
};
Be.negated = Be.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s, ft(t);
};
Be.plus = Be.add = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h = this, d = h.constructor;
  if (t = new d(t), !h.d || !t.d)
    return !h.s || !t.s ? t = new d(NaN) : h.d || (t = new d(t.d || h.s === t.s ? h : NaN)), t;
  if (h.s != t.s)
    return t.s = -t.s, h.minus(t);
  if (c = h.d, p = t.d, a = d.precision, l = d.rounding, !c[0] || !p[0])
    return p[0] || (t = new d(h)), _t ? ft(t, a, l) : t;
  if (s = Fn(h.e / xt), n = Fn(t.e / xt), c = c.slice(), i = s - n, i) {
    for (i < 0 ? (r = c, i = -i, o = p.length) : (r = p, n = s, o = c.length), s = Math.ceil(a / xt), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = c.length, i = p.length, o - i < 0 && (i = o, r = p, p = c, c = r), e = 0; i; )
    e = (c[--i] = c[i] + p[i] + e) / Ws | 0, c[i] %= Ws;
  for (e && (c.unshift(e), ++n), o = c.length; c[--o] == 0; ) c.pop();
  return t.d = c, t.e = Qv(c, n), _t ? ft(t, a, l) : t;
};
Be.precision = Be.sd = function(t) {
  var e, r = this;
  if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(uc + t);
  return r.d ? (e = uU(r.d), t && r.e + 1 > e && (e = r.e + 1)) : e = NaN, e;
};
Be.round = function() {
  var t = this, e = t.constructor;
  return ft(new e(t), t.e + 1, e.rounding);
};
Be.sine = Be.sin = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + xt, n.rounding = 1, r = PAe(n, fU(n, r)), n.precision = t, n.rounding = e, ft(ba > 2 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Be.squareRoot = Be.sqrt = function() {
  var t, e, r, n, i, s, o = this, a = o.d, l = o.e, c = o.s, p = o.constructor;
  if (c !== 1 || !a || !a[0])
    return new p(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (_t = !1, c = Math.sqrt(+o), c == 0 || c == 1 / 0 ? (e = dn(a), (e.length + l) % 2 == 0 && (e += "0"), c = Math.sqrt(e), l = Fn((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? e = "5e" + l : (e = c.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + l), n = new p(e)) : n = new p(c.toString()), r = (l = p.precision) + 3; ; )
    if (s = n, n = s.plus(lr(o, s, r + 2, 1)).times(0.5), dn(s.d).slice(0, r) === (e = dn(n.d)).slice(0, r))
      if (e = e.slice(r - 3, r + 1), e == "9999" || !i && e == "4999") {
        if (!i && (ft(s, l + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (ft(n, l + 1, 1), t = !n.times(n).eq(o));
        break;
      }
  return _t = !0, ft(n, l, p.rounding, t);
};
Be.tangent = Be.tan = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = lr(r, new n(1).minus(r.times(r)).sqrt(), t + 10, 0), n.precision = t, n.rounding = e, ft(ba == 2 || ba == 4 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Be.times = Be.mul = function(t) {
  var e, r, n, i, s, o, a, l, c, p = this, h = p.constructor, d = p.d, b = (t = new h(t)).d;
  if (t.s *= p.s, !d || !d[0] || !b || !b[0])
    return new h(!t.s || d && !d[0] && !b || b && !b[0] && !d ? NaN : !d || !b ? t.s / 0 : t.s * 0);
  for (r = Fn(p.e / xt) + Fn(t.e / xt), l = d.length, c = b.length, l < c && (s = d, d = b, b = s, o = l, l = c, c = o), s = [], o = l + c, n = o; n--; ) s.push(0);
  for (n = c; --n >= 0; ) {
    for (e = 0, i = l + n; i > n; )
      a = s[i] + b[n] * d[i - n - 1] + e, s[i--] = a % Ws | 0, e = a / Ws | 0;
    s[i] = (s[i] + e) % Ws | 0;
  }
  for (; !s[--o]; ) s.pop();
  return e ? ++r : s.shift(), t.d = s, t.e = Qv(s, r), _t ? ft(t, h.precision, h.rounding) : t;
};
Be.toBinary = function(t, e) {
  return O9(this, 2, t, e);
};
Be.toDecimalPlaces = Be.toDP = function(t, e) {
  var r = this, n = r.constructor;
  return r = new n(r), t === void 0 ? r : (fi(t, 0, tu), e === void 0 ? e = n.rounding : fi(e, 0, 8), ft(r, t + r.e + 1, e));
};
Be.toExponential = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Zo(n, !0) : (fi(t, 0, tu), e === void 0 ? e = i.rounding : fi(e, 0, 8), n = ft(new i(n), t + 1, e), r = Zo(n, !0, t + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Be.toFixed = function(t, e) {
  var r, n, i = this, s = i.constructor;
  return t === void 0 ? r = Zo(i) : (fi(t, 0, tu), e === void 0 ? e = s.rounding : fi(e, 0, 8), n = ft(new s(i), t + i.e + 1, e), r = Zo(n, !1, t + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
Be.toFraction = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, b = this, m = b.d, w = b.constructor;
  if (!m) return new w(b);
  if (c = r = new w(1), n = l = new w(0), e = new w(n), s = e.e = uU(m) - b.e - 1, o = s % xt, e.d[0] = Kr(10, o < 0 ? xt + o : o), t == null)
    t = s > 0 ? e : c;
  else {
    if (a = new w(t), !a.isInt() || a.lt(c)) throw Error(uc + a);
    t = a.gt(e) ? s > 0 ? e : c : a;
  }
  for (_t = !1, a = new w(dn(m)), p = w.precision, w.precision = s = m.length * xt * 2; h = lr(a, e, 0, 1, 1), i = r.plus(h.times(n)), i.cmp(t) != 1; )
    r = n, n = i, i = c, c = l.plus(h.times(i)), l = i, i = e, e = a.minus(h.times(i)), a = i;
  return i = lr(t.minus(r), n, 0, 1, 1), l = l.plus(i.times(c)), r = r.plus(i.times(n)), l.s = c.s = b.s, d = lr(c, n, s, 1).minus(b).abs().cmp(lr(l, r, s, 1).minus(b).abs()) < 1 ? [c, n] : [l, r], w.precision = p, _t = !0, d;
};
Be.toHexadecimal = Be.toHex = function(t, e) {
  return O9(this, 16, t, e);
};
Be.toNearest = function(t, e) {
  var r = this, n = r.constructor;
  if (r = new n(r), t == null) {
    if (!r.d) return r;
    t = new n(1), e = n.rounding;
  } else {
    if (t = new n(t), e === void 0 ? e = n.rounding : fi(e, 0, 8), !r.d) return t.s ? r : t;
    if (!t.d)
      return t.s && (t.s = r.s), t;
  }
  return t.d[0] ? (_t = !1, r = lr(r, t, 0, e, 1).times(t), _t = !0, ft(r)) : (t.s = r.s, r = t), r;
};
Be.toNumber = function() {
  return +this;
};
Be.toOctal = function(t, e) {
  return O9(this, 8, t, e);
};
Be.toPower = Be.pow = function(t) {
  var e, r, n, i, s, o, a = this, l = a.constructor, c = +(t = new l(t));
  if (!a.d || !t.d || !a.d[0] || !t.d[0]) return new l(Kr(+a, c));
  if (a = new l(a), a.eq(1)) return a;
  if (n = l.precision, s = l.rounding, t.eq(1)) return ft(a, n, s);
  if (e = Fn(t.e / xt), e >= t.d.length - 1 && (r = c < 0 ? -c : c) <= kAe)
    return i = hU(l, a, r, n), t.s < 0 ? new l(1).div(i) : ft(i, n, s);
  if (o = a.s, o < 0) {
    if (e < t.d.length - 1) return new l(NaN);
    if (t.d[e] & 1 || (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = Kr(+a, c), e = r == 0 || !isFinite(r) ? Fn(c * (Math.log("0." + dn(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, e > l.maxE + 1 || e < l.minE - 1 ? new l(e > 0 ? o / 0 : 0) : (_t = !1, l.rounding = a.s = 1, r = Math.min(12, (e + "").length), i = nE(t.times(Ll(a, n + r)), n), i.d && (i = ft(i, n + 5, 1), Z0(i.d, n, s) && (e = n + 10, i = ft(nE(t.times(Ll(a, e + r)), e), e + 5, 1), +dn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = ft(i, n + 1, 0)))), i.s = o, _t = !0, l.rounding = s, ft(i, n, s));
};
Be.toPrecision = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Zo(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (fi(t, 1, tu), e === void 0 ? e = i.rounding : fi(e, 0, 8), n = ft(new i(n), t, e), r = Zo(n, t <= n.e || n.e <= i.toExpNeg, t)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Be.toSignificantDigits = Be.toSD = function(t, e) {
  var r = this, n = r.constructor;
  return t === void 0 ? (t = n.precision, e = n.rounding) : (fi(t, 1, tu), e === void 0 ? e = n.rounding : fi(e, 0, 8)), ft(new n(r), t, e);
};
Be.toString = function() {
  var t = this, e = t.constructor, r = Zo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() && !t.isZero() ? "-" + r : r;
};
Be.truncated = Be.trunc = function() {
  return ft(new this.constructor(this), this.e + 1, 1);
};
Be.valueOf = Be.toJSON = function() {
  var t = this, e = t.constructor, r = Zo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() ? "-" + r : r;
};
function dn(t) {
  var e, r, n, i = t.length - 1, s = "", o = t[0];
  if (i > 0) {
    for (s += o, e = 1; e < i; e++)
      n = t[e] + "", r = xt - n.length, r && (s += El(r)), s += n;
    o = t[e], n = o + "", r = xt - n.length, r && (s += El(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function fi(t, e, r) {
  if (t !== ~~t || t < e || t > r)
    throw Error(uc + t);
}
function Z0(t, e, r, n) {
  var i, s, o, a;
  for (s = t[0]; s >= 10; s /= 10) --e;
  return --e < 0 ? (e += xt, i = 0) : (i = Math.ceil((e + 1) / xt), e %= xt), s = Kr(10, xt - e), a = t[i] % s | 0, n == null ? e < 3 ? (e == 0 ? a = a / 100 | 0 : e == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 100 | 0) == Kr(10, e - 2) - 1 || (a == s / 2 || a == 0) && (t[i + 1] / s / 100 | 0) == 0 : e < 4 ? (e == 0 ? a = a / 1e3 | 0 : e == 1 ? a = a / 100 | 0 : e == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 1e3 | 0) == Kr(10, e - 3) - 1, o;
}
function V1(t, e, r) {
  for (var n, i = [0], s, o = 0, a = t.length; o < a; ) {
    for (s = i.length; s--; ) i[s] *= e;
    for (i[0] += eE.indexOf(t.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function CAe(t, e) {
  var r, n, i;
  if (e.isZero()) return e;
  n = e.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Kv(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), t.precision += r, e = cd(t, 1, e.times(i), new t(1));
  for (var s = r; s--; ) {
    var o = e.times(e);
    e = o.times(o).minus(o).times(8).plus(1);
  }
  return t.precision -= r, e;
}
var lr = /* @__PURE__ */ function() {
  function t(n, i, s) {
    var o, a = 0, l = n.length;
    for (n = n.slice(); l--; )
      o = n[l] * i + a, n[l] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function e(n, i, s, o) {
    var a, l;
    if (s != o)
      l = s > o ? 1 : -1;
    else
      for (a = l = 0; a < s; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, o, a, l) {
    var c, p, h, d, b, m, w, f, E, A, x, g, v, k, S, R, L, F, z, j, ee = n.constructor, X = n.s == i.s ? 1 : -1, ie = n.d, ce = i.d;
    if (!ie || !ie[0] || !ce || !ce[0])
      return new ee(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (ie ? ce && ie[0] == ce[0] : !ce) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          ie && ie[0] == 0 || !ce ? X * 0 : X / 0
        )
      );
    for (l ? (b = 1, p = n.e - i.e) : (l = Ws, b = xt, p = Fn(n.e / b) - Fn(i.e / b)), z = ce.length, L = ie.length, E = new ee(X), A = E.d = [], h = 0; ce[h] == (ie[h] || 0); h++) ;
    if (ce[h] > (ie[h] || 0) && p--, s == null ? (k = s = ee.precision, o = ee.rounding) : a ? k = s + (n.e - i.e) + 1 : k = s, k < 0)
      A.push(1), m = !0;
    else {
      if (k = k / b + 2 | 0, h = 0, z == 1) {
        for (d = 0, ce = ce[0], k++; (h < L || d) && k--; h++)
          S = d * l + (ie[h] || 0), A[h] = S / ce | 0, d = S % ce | 0;
        m = d || h < L;
      } else {
        for (d = l / (ce[0] + 1) | 0, d > 1 && (ce = t(ce, d, l), ie = t(ie, d, l), z = ce.length, L = ie.length), R = z, x = ie.slice(0, z), g = x.length; g < z; ) x[g++] = 0;
        j = ce.slice(), j.unshift(0), F = ce[0], ce[1] >= l / 2 && ++F;
        do
          d = 0, c = e(ce, x, z, g), c < 0 ? (v = x[0], z != g && (v = v * l + (x[1] || 0)), d = v / F | 0, d > 1 ? (d >= l && (d = l - 1), w = t(ce, d, l), f = w.length, g = x.length, c = e(w, x, f, g), c == 1 && (d--, r(w, z < f ? j : ce, f, l))) : (d == 0 && (c = d = 1), w = ce.slice()), f = w.length, f < g && w.unshift(0), r(x, w, g, l), c == -1 && (g = x.length, c = e(ce, x, z, g), c < 1 && (d++, r(x, z < g ? j : ce, g, l))), g = x.length) : c === 0 && (d++, x = [0]), A[h++] = d, c && x[0] ? x[g++] = ie[R] || 0 : (x = [ie[R]], g = 1);
        while ((R++ < L || x[0] !== void 0) && k--);
        m = x[0] !== void 0;
      }
      A[0] || A.shift();
    }
    if (b == 1)
      E.e = p, sU = m;
    else {
      for (h = 1, d = A[0]; d >= 10; d /= 10) h++;
      E.e = h + p * b - 1, ft(E, a ? s + E.e + 1 : s, o, m);
    }
    return E;
  };
}();
function ft(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, b = t.constructor;
  e: if (e != null) {
    if (h = t.d, !h) return t;
    for (i = 1, a = h[0]; a >= 10; a /= 10) i++;
    if (s = e - i, s < 0)
      s += xt, o = e, p = h[d = 0], l = p / Kr(10, i - o - 1) % 10 | 0;
    else if (d = Math.ceil((s + 1) / xt), a = h.length, d >= a)
      if (n) {
        for (; a++ <= d; ) h.push(0);
        p = l = 0, i = 1, s %= xt, o = s - xt + 1;
      } else
        break e;
    else {
      for (p = a = h[d], i = 1; a >= 10; a /= 10) i++;
      s %= xt, o = s - xt + i, l = o < 0 ? 0 : p / Kr(10, i - o - 1) % 10 | 0;
    }
    if (n = n || e < 0 || h[d + 1] !== void 0 || (o < 0 ? p : p % Kr(10, i - o - 1)), c = r < 4 ? (l || n) && (r == 0 || r == (t.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? p / Kr(10, i - o) : 0 : h[d - 1]) % 10 & 1 || r == (t.s < 0 ? 8 : 7)), e < 1 || !h[0])
      return h.length = 0, c ? (e -= t.e + 1, h[0] = Kr(10, (xt - e % xt) % xt), t.e = -e || 0) : h[0] = t.e = 0, t;
    if (s == 0 ? (h.length = d, a = 1, d--) : (h.length = d + 1, a = Kr(10, xt - s), h[d] = o > 0 ? (p / Kr(10, i - o) % Kr(10, o) | 0) * a : 0), c)
      for (; ; )
        if (d == 0) {
          for (s = 1, o = h[0]; o >= 10; o /= 10) s++;
          for (o = h[0] += a, a = 1; o >= 10; o /= 10) a++;
          s != a && (t.e++, h[0] == Ws && (h[0] = 1));
          break;
        } else {
          if (h[d] += a, h[d] != Ws) break;
          h[d--] = 0, a = 1;
        }
    for (s = h.length; h[--s] === 0; ) h.pop();
  }
  return _t && (t.e > b.maxE ? (t.d = null, t.e = NaN) : t.e < b.minE && (t.e = 0, t.d = [0])), t;
}
function Zo(t, e, r) {
  if (!t.isFinite()) return dU(t);
  var n, i = t.e, s = dn(t.d), o = s.length;
  return e ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + El(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (t.e < 0 ? "e" : "e+") + t.e) : i < 0 ? (s = "0." + El(-i - 1) + s, r && (n = r - o) > 0 && (s += El(n))) : i >= o ? (s += El(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + El(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += El(n))), s;
}
function Qv(t, e) {
  var r = t[0];
  for (e *= xt; r >= 10; r /= 10) e++;
  return e;
}
function A2(t, e, r) {
  if (e > _Ae)
    throw _t = !0, r && (t.precision = r), Error(oU);
  return ft(new t(E2), e, 1, !0);
}
function Mo(t, e, r) {
  if (e > rE) throw Error(oU);
  return ft(new t(S2), e, r, !0);
}
function uU(t) {
  var e = t.length - 1, r = e * xt + 1;
  if (e = t[e], e) {
    for (; e % 10 == 0; e /= 10) r--;
    for (e = t[0]; e >= 10; e /= 10) r++;
  }
  return r;
}
function El(t) {
  for (var e = ""; t--; ) e += "0";
  return e;
}
function hU(t, e, r, n) {
  var i, s = new t(1), o = Math.ceil(n / xt + 4);
  for (_t = !1; ; ) {
    if (r % 2 && (s = s.times(e), ER(s.d, o) && (i = !0)), r = Fn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    e = e.times(e), ER(e.d, o);
  }
  return _t = !0, s;
}
function xR(t) {
  return t.d[t.d.length - 1] & 1;
}
function pU(t, e, r) {
  for (var n, i, s = new t(e[0]), o = 0; ++o < e.length; ) {
    if (i = new t(e[o]), !i.s) {
      s = i;
      break;
    }
    n = s.cmp(i), (n === r || n === 0 && s.s === r) && (s = i);
  }
  return s;
}
function nE(t, e) {
  var r, n, i, s, o, a, l, c = 0, p = 0, h = 0, d = t.constructor, b = d.rounding, m = d.precision;
  if (!t.d || !t.d[0] || t.e > 17)
    return new d(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
  for (e == null ? (_t = !1, l = m) : l = e, a = new d(0.03125); t.e > -2; )
    t = t.times(a), h += 5;
  for (n = Math.log(Kr(2, h)) / Math.LN10 * 2 + 5 | 0, l += n, r = s = o = new d(1), d.precision = l; ; ) {
    if (s = ft(s.times(t), l, 1), r = r.times(++p), a = o.plus(lr(s, r, l, 1)), dn(a.d).slice(0, l) === dn(o.d).slice(0, l)) {
      for (i = h; i--; ) o = ft(o.times(o), l, 1);
      if (e == null)
        if (c < 3 && Z0(o.d, l - n, b, c))
          d.precision = l += 10, r = s = a = new d(1), p = 0, c++;
        else
          return ft(o, d.precision = m, b, _t = !0);
      else
        return d.precision = m, o;
    }
    o = a;
  }
}
function Ll(t, e) {
  var r, n, i, s, o, a, l, c, p, h, d, b = 1, m = 10, w = t, f = w.d, E = w.constructor, A = E.rounding, x = E.precision;
  if (w.s < 0 || !f || !f[0] || !w.e && f[0] == 1 && f.length == 1)
    return new E(f && !f[0] ? -1 / 0 : w.s != 1 ? NaN : f ? 0 : w);
  if (e == null ? (_t = !1, p = x) : p = e, E.precision = p += m, r = dn(f), n = r.charAt(0), Math.abs(s = w.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      w = w.times(t), r = dn(w.d), n = r.charAt(0), b++;
    s = w.e, n > 1 ? (w = new E("0." + r), s++) : w = new E(n + "." + r.slice(1));
  } else
    return c = A2(E, p + 2, x).times(s + ""), w = Ll(new E(n + "." + r.slice(1)), p - m).plus(c), E.precision = x, e == null ? ft(w, x, A, _t = !0) : w;
  for (h = w, l = o = w = lr(w.minus(1), w.plus(1), p, 1), d = ft(w.times(w), p, 1), i = 3; ; ) {
    if (o = ft(o.times(d), p, 1), c = l.plus(lr(o, new E(i), p, 1)), dn(c.d).slice(0, p) === dn(l.d).slice(0, p))
      if (l = l.times(2), s !== 0 && (l = l.plus(A2(E, p + 2, x).times(s + ""))), l = lr(l, new E(b), p, 1), e == null)
        if (Z0(l.d, p - m, A, a))
          E.precision = p += m, c = o = w = lr(h.minus(1), h.plus(1), p, 1), d = ft(w.times(w), p, 1), i = a = 1;
        else
          return ft(l, E.precision = x, A, _t = !0);
      else
        return E.precision = x, l;
    l = c, i += 2;
  }
}
function dU(t) {
  return String(t.s * t.s / 0);
}
function U1(t, e) {
  var r, n, i;
  for ((r = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (r = e.length), n = 0; e.charCodeAt(n) === 48; n++) ;
  for (i = e.length; e.charCodeAt(i - 1) === 48; --i) ;
  if (e = e.slice(n, i), e) {
    if (i -= n, t.e = r = r - n - 1, t.d = [], n = (r + 1) % xt, r < 0 && (n += xt), n < i) {
      for (n && t.d.push(+e.slice(0, n)), i -= xt; n < i; ) t.d.push(+e.slice(n, n += xt));
      e = e.slice(n), n = xt - e.length;
    } else
      n -= i;
    for (; n--; ) e += "0";
    t.d.push(+e), _t && (t.e > t.constructor.maxE ? (t.d = null, t.e = NaN) : t.e < t.constructor.minE && (t.e = 0, t.d = [0]));
  } else
    t.e = 0, t.d = [0];
  return t;
}
function IAe(t, e) {
  var r, n, i, s, o, a, l, c, p;
  if (e.indexOf("_") > -1) {
    if (e = e.replace(/(\d)_(?=\d)/g, "$1"), cU.test(e)) return U1(t, e);
  } else if (e === "Infinity" || e === "NaN")
    return +e || (t.s = NaN), t.e = NaN, t.d = null, t;
  if (SAe.test(e))
    r = 16, e = e.toLowerCase();
  else if (EAe.test(e))
    r = 2;
  else if (AAe.test(e))
    r = 8;
  else
    throw Error(uc + e);
  for (s = e.search(/p/i), s > 0 ? (l = +e.slice(s + 1), e = e.substring(2, s)) : e = e.slice(2), s = e.indexOf("."), o = s >= 0, n = t.constructor, o && (e = e.replace(".", ""), a = e.length, s = a - s, i = hU(n, new n(r), s, s * 2)), c = V1(e, r, Ws), p = c.length - 1, s = p; c[s] === 0; --s) c.pop();
  return s < 0 ? new n(t.s * 0) : (t.e = Qv(c, p), t.d = c, _t = !1, o && (t = lr(t, i, a * 4)), l && (t = t.times(Math.abs(l) < 54 ? Kr(2, l) : Ds.pow(2, l))), _t = !0, t);
}
function PAe(t, e) {
  var r, n = e.d.length;
  if (n < 3)
    return e.isZero() ? e : cd(t, 2, e, e);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, e = e.times(1 / Kv(5, r)), e = cd(t, 2, e, e);
  for (var i, s = new t(5), o = new t(16), a = new t(20); r--; )
    i = e.times(e), e = e.times(s.plus(i.times(o.times(i).minus(a))));
  return e;
}
function cd(t, e, r, n, i) {
  var s, o, a, l, c = t.precision, p = Math.ceil(c / xt);
  for (_t = !1, l = r.times(r), a = new t(n); ; ) {
    if (o = lr(a.times(l), new t(e++ * e++), c, 1), a = i ? n.plus(o) : n.minus(o), n = lr(o.times(l), new t(e++ * e++), c, 1), o = a.plus(n), o.d[p] !== void 0) {
      for (s = p; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = n, n = o, o = s;
  }
  return _t = !0, o.d.length = p + 1, o;
}
function Kv(t, e) {
  for (var r = t; --e; ) r *= t;
  return r;
}
function fU(t, e) {
  var r, n = e.s < 0, i = Mo(t, t.precision, 1), s = i.times(0.5);
  if (e = e.abs(), e.lte(s))
    return ba = n ? 4 : 1, e;
  if (r = e.divToInt(i), r.isZero())
    ba = n ? 3 : 2;
  else {
    if (e = e.minus(r.times(i)), e.lte(s))
      return ba = xR(r) ? n ? 2 : 3 : n ? 4 : 1, e;
    ba = xR(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return e.minus(i).abs();
}
function O9(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, b = t.constructor, m = r !== void 0;
  if (m ? (fi(r, 1, tu), n === void 0 ? n = b.rounding : fi(n, 0, 8)) : (r = b.precision, n = b.rounding), !t.isFinite())
    p = dU(t);
  else {
    for (p = Zo(t), o = p.indexOf("."), m ? (i = 2, e == 16 ? r = r * 4 - 3 : e == 8 && (r = r * 3 - 2)) : i = e, o >= 0 && (p = p.replace(".", ""), d = new b(1), d.e = p.length - o, d.d = V1(Zo(d), 10, i), d.e = d.d.length), h = V1(p, 10, i), s = l = h.length; h[--l] == 0; ) h.pop();
    if (!h[0])
      p = m ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (t = new b(t), t.d = h, t.e = s, t = lr(t, d, r, n, 0, i), h = t.d, s = t.e, c = sU), o = h[r], a = i / 2, c = c || h[r + 1] !== void 0, c = n < 4 ? (o !== void 0 || c) && (n === 0 || n === (t.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || c || n === 6 && h[r - 1] & 1 || n === (t.s < 0 ? 8 : 7)), h.length = r, c)
        for (; ++h[--r] > i - 1; )
          h[r] = 0, r || (++s, h.unshift(1));
      for (l = h.length; !h[l - 1]; --l) ;
      for (o = 0, p = ""; o < l; o++) p += eE.charAt(h[o]);
      if (m) {
        if (l > 1)
          if (e == 16 || e == 8) {
            for (o = e == 16 ? 4 : 3, --l; l % o; l++) p += "0";
            for (h = V1(p, i, e), l = h.length; !h[l - 1]; --l) ;
            for (o = 1, p = "1."; o < l; o++) p += eE.charAt(h[o]);
          } else
            p = p.charAt(0) + "." + p.slice(1);
        p = p + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) p = "0" + p;
        p = "0." + p;
      } else if (++s > l) for (s -= l; s--; ) p += "0";
      else s < l && (p = p.slice(0, s) + "." + p.slice(s));
    }
    p = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + p;
  }
  return t.s < 0 ? "-" + p : p;
}
function ER(t, e) {
  if (t.length > e)
    return t.length = e, !0;
}
function RAe(t) {
  return new this(t).abs();
}
function OAe(t) {
  return new this(t).acos();
}
function TAe(t) {
  return new this(t).acosh();
}
function LAe(t, e) {
  return new this(t).plus(e);
}
function MAe(t) {
  return new this(t).asin();
}
function NAe(t) {
  return new this(t).asinh();
}
function DAe(t) {
  return new this(t).atan();
}
function $Ae(t) {
  return new this(t).atanh();
}
function jAe(t, e) {
  t = new this(t), e = new this(e);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !t.s || !e.s ? r = new this(NaN) : !t.d && !e.d ? (r = Mo(this, s, 1).times(e.s > 0 ? 0.25 : 0.75), r.s = t.s) : !e.d || t.isZero() ? (r = e.s < 0 ? Mo(this, n, i) : new this(0), r.s = t.s) : !t.d || e.isZero() ? (r = Mo(this, s, 1).times(0.5), r.s = t.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(lr(t, e, s, 1)), e = Mo(this, s, 1), this.precision = n, this.rounding = i, r = t.s < 0 ? r.minus(e) : r.plus(e)) : r = this.atan(lr(t, e, s, 1)), r;
}
function BAe(t) {
  return new this(t).cbrt();
}
function FAe(t) {
  return ft(t = new this(t), t.e + 1, 2);
}
function zAe(t, e, r) {
  return new this(t).clamp(e, r);
}
function VAe(t) {
  if (!t || typeof t != "object") throw Error(qv + "Object expected");
  var e, r, n, i = t.defaults === !0, s = [
    "precision",
    1,
    tu,
    "rounding",
    0,
    8,
    "toExpNeg",
    -9e15,
    0,
    "toExpPos",
    0,
    X4,
    "maxE",
    0,
    X4,
    "minE",
    -9e15,
    0,
    "modulo",
    0,
    9
  ];
  for (e = 0; e < s.length; e += 3)
    if (r = s[e], i && (this[r] = tE[r]), (n = t[r]) !== void 0)
      if (Fn(n) === n && n >= s[e + 1] && n <= s[e + 2]) this[r] = n;
      else throw Error(uc + r + ": " + n);
  if (r = "crypto", i && (this[r] = tE[r]), (n = t[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(aU);
      else
        this[r] = !1;
    else
      throw Error(uc + r + ": " + n);
  return this;
}
function UAe(t) {
  return new this(t).cos();
}
function HAe(t) {
  return new this(t).cosh();
}
function gU(t) {
  var e, r, n;
  function i(s) {
    var o, a, l, c = this;
    if (!(c instanceof i)) return new i(s);
    if (c.constructor = i, SR(s)) {
      c.s = s.s, _t ? !s.d || s.e > i.maxE ? (c.e = NaN, c.d = null) : s.e < i.minE ? (c.e = 0, c.d = [0]) : (c.e = s.e, c.d = s.d.slice()) : (c.e = s.e, c.d = s.d ? s.d.slice() : s.d);
      return;
    }
    if (l = typeof s, l === "number") {
      if (s === 0) {
        c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        _t ? o > i.maxE ? (c.e = NaN, c.d = null) : o < i.minE ? (c.e = 0, c.d = [0]) : (c.e = o, c.d = [s]) : (c.e = o, c.d = [s]);
        return;
      }
      if (s * 0 !== 0) {
        s || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return U1(c, s.toString());
    }
    if (l === "string")
      return (a = s.charCodeAt(0)) === 45 ? (s = s.slice(1), c.s = -1) : (a === 43 && (s = s.slice(1)), c.s = 1), cU.test(s) ? U1(c, s) : IAe(c, s);
    if (l === "bigint")
      return s < 0 ? (s = -s, c.s = -1) : c.s = 1, U1(c, s.toString());
    throw Error(uc + s);
  }
  if (i.prototype = Be, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = VAe, i.clone = gU, i.isDecimal = SR, i.abs = RAe, i.acos = OAe, i.acosh = TAe, i.add = LAe, i.asin = MAe, i.asinh = NAe, i.atan = DAe, i.atanh = $Ae, i.atan2 = jAe, i.cbrt = BAe, i.ceil = FAe, i.clamp = zAe, i.cos = UAe, i.cosh = HAe, i.div = GAe, i.exp = WAe, i.floor = qAe, i.hypot = QAe, i.ln = KAe, i.log = YAe, i.log10 = JAe, i.log2 = ZAe, i.max = XAe, i.min = e9e, i.mod = t9e, i.mul = r9e, i.pow = n9e, i.random = i9e, i.round = s9e, i.sign = o9e, i.sin = a9e, i.sinh = l9e, i.sqrt = c9e, i.sub = u9e, i.sum = h9e, i.tan = p9e, i.tanh = d9e, i.trunc = f9e, t === void 0 && (t = {}), t && t.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; ) t.hasOwnProperty(r = n[e++]) || (t[r] = this[r]);
  return i.config(t), i;
}
function GAe(t, e) {
  return new this(t).div(e);
}
function WAe(t) {
  return new this(t).exp();
}
function qAe(t) {
  return ft(t = new this(t), t.e + 1, 3);
}
function QAe() {
  var t, e, r = new this(0);
  for (_t = !1, t = 0; t < arguments.length; )
    if (e = new this(arguments[t++]), e.d)
      r.d && (r = r.plus(e.times(e)));
    else {
      if (e.s)
        return _t = !0, new this(1 / 0);
      r = e;
    }
  return _t = !0, r.sqrt();
}
function SR(t) {
  return t instanceof Ds || t && t.toStringTag === lU || !1;
}
function KAe(t) {
  return new this(t).ln();
}
function YAe(t, e) {
  return new this(t).log(e);
}
function ZAe(t) {
  return new this(t).log(2);
}
function JAe(t) {
  return new this(t).log(10);
}
function XAe() {
  return pU(this, arguments, -1);
}
function e9e() {
  return pU(this, arguments, 1);
}
function t9e(t, e) {
  return new this(t).mod(e);
}
function r9e(t, e) {
  return new this(t).mul(e);
}
function n9e(t, e) {
  return new this(t).pow(e);
}
function i9e(t) {
  var e, r, n, i, s = 0, o = new this(1), a = [];
  if (t === void 0 ? t = this.precision : fi(t, 1, tu), n = Math.ceil(t / xt), this.crypto)
    if (crypto.getRandomValues)
      for (e = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = e[s], i >= 429e7 ? e[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (e = crypto.randomBytes(n *= 4); s < n; )
        i = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((e[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(aU);
  else for (; s < n; ) a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], t %= xt, n && t && (i = Kr(10, xt - t), a[s] = (n / i | 0) * i); a[s] === 0; s--) a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= xt) a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
    n < xt && (r -= xt - n);
  }
  return o.e = r, o.d = a, o;
}
function s9e(t) {
  return ft(t = new this(t), t.e + 1, this.rounding);
}
function o9e(t) {
  return t = new this(t), t.d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN;
}
function a9e(t) {
  return new this(t).sin();
}
function l9e(t) {
  return new this(t).sinh();
}
function c9e(t) {
  return new this(t).sqrt();
}
function u9e(t, e) {
  return new this(t).sub(e);
}
function h9e() {
  var t = 0, e = arguments, r = new this(e[t]);
  for (_t = !1; r.s && ++t < e.length; ) r = r.plus(e[t]);
  return _t = !0, ft(r, this.precision, this.rounding);
}
function p9e(t) {
  return new this(t).tan();
}
function d9e(t) {
  return new this(t).tanh();
}
function f9e(t) {
  return ft(t = new this(t), t.e + 1, 1);
}
Be[Symbol.for("nodejs.util.inspect.custom")] = Be.toString;
Be[Symbol.toStringTag] = "Decimal";
var Ds = Be.constructor = gU(tE);
E2 = new Ds(E2);
S2 = new Ds(S2);
function k2(t, e, r, n = !0) {
  const i = new Ds(t), s = new Ds(e), o = s.sub(i), a = o.div(10);
  let l, c, p;
  l = new Ds(10).pow(a.log(10).ceil()), l.div(o).gte(0.8) ? l = l.div(10) : l.div(o).gte(0.5) ? l = l.div(4) : l.div(o).gte(0.2) && (l = l.div(2)), c = i.div(l).floor().mul(l), p = s.div(l).ceil().mul(l);
  const h = new Intl.NumberFormat(void 0, { maximumFractionDigits: 5, useGrouping: n }), d = new Array(p.sub(c).div(l).toNumber() + 1).fill(0).map((b, m) => h.format(+c.add(l.mul(m))) + (r ? "%" : ""));
  return {
    min: c.toNumber(),
    max: p.toNumber(),
    range: p.sub(c).toNumber(),
    labelTiers: [d]
  };
}
function g9e(t, e, r, n, i = !0) {
  if (r < 0)
    throw new Error("tick interval must be > 0");
  const s = t - t % r, o = e + (r - e % r), a = new Intl.NumberFormat(void 0, { maximumFractionDigits: 5, useGrouping: i });
  return {
    min: s,
    max: o,
    range: o - s,
    labelTiers: [new Array((o - s) / r + 1).fill(0).map((l, c) => a.format(s + r * c) + "")]
  };
}
class Yv {
  constructor(e, r) {
    this._store = e, this._options = r, r.xTiers ? this._xLabelInfo = { labelTiers: r.xTiers } : this._computeXLabelInfo(), r.yTiers ? this._yLabelInfo = { labelTiers: r.yTiers } : this._computeYLabelInfo();
  }
  get xLabelInfo() {
    return this._xLabelInfo;
  }
  get yLabelInfo() {
    return this._yLabelInfo;
  }
  get options() {
    return this._options;
  }
  get horizFacet() {
    return this._store.model.getAxisFacet(
      this._options.isXVertical ? "vert" : "horiz"
    );
  }
  get vertFacet() {
    return this._store.model.getAxisFacet(
      this._options.isXVertical ? "horiz" : "vert"
    );
  }
  getFacetForOrientation(e) {
    return e === "horiz" ? this.horizFacet : this.vertFacet;
  }
  updateYRange() {
    this._computeYLabelInfo();
  }
  _computeXLabels(e, r) {
    return k2(
      this._store.settings.axis.x.minValue === "unset" ? e : this._store.settings.axis.x.minValue,
      this._store.settings.axis.x.maxValue === "unset" ? r : this._store.settings.axis.x.maxValue,
      !1
    );
  }
  _computeYLabels(e, r) {
    return this._store.settings.axis.y.interval !== "unset" ? g9e(e, r, this._store.settings.axis.y.interval) : k2(e, r, !1);
  }
  _computeXLabelInfo() {
    if (this._options.xValues)
      this._xLabelInfo = this._computeXLabels(
        Math.min(...this._options.xValues),
        Math.max(...this._options.xValues)
      );
    else {
      const e = this._store.model.series[0].datapoints.map(
        (r) => Wr(r.facetBox("x"), this._store.getFormatType("horizTick"))
      );
      this._xLabelInfo = {
        labelTiers: [e]
      };
    }
  }
  _computeYLabelInfo() {
    const e = this._store.settings.axis.y.minValue === "unset" ? this._options.yMin ?? Math.min(...this._options.yValues) : this._store.settings.axis.y.minValue, r = this._store.settings.axis.y.maxValue === "unset" ? this._options.yMax ?? Math.max(...this._options.yValues) : this._store.settings.axis.y.maxValue;
    this._yLabelInfo = this._computeYLabels(e, r);
  }
}
class iE {
  constructor(e, r, n, i, s) {
    this._pts = [];
    const o = new Ye(e, r), a = new Ye(n, i);
    for (let l = 0; l < s; l++) {
      const c = l / s, p = c * c, h = p * c;
      this._pts.push(
        o.multiplyScalar(3 * (h - 2 * p + c)).add(
          a.multiplyScalar(3 * (p - h)).add(
            new Ye(h, h)
          )
        )
      );
    }
    this._pts.push(new Ye(1, 1));
  }
  // copy() {
  //   cdef Bezier c = Bezier.__new__(Bezier)
  //   c.pts = [v.copy() for v in self.pts]
  //   return c
  // }
  eval(e) {
    for (let r = 0; r < this._pts.length - 1; r++)
      if (e <= this._pts[r + 1].x) {
        const n = this._pts[r], i = this._pts[r + 1];
        return n.lerp(i, (e - n.x) / (i.x - n.x)).y;
      }
  }
}
class m9e extends Pr {
  constructor(e, r) {
    super(e), r && (this._id = r);
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(e) {
    this._children.forEach((r) => {
      r.x += e - this._x;
    }), super.x = e;
  }
  set y(e) {
    this._children.forEach((r) => {
      r.y += e - this._y;
    }), super.y = e;
  }
  // setSize(width: number, height: number, isBubble = true) {
  //   super.setSize(width, height, isBubble);
  //   this.layoutViews();
  // }
  // constrainSize(maxWidth: number, maxHeight: number, isBubble = false) {
  //   this.log.info('CONSTRAIN', this.id || this.constructor.name, maxWidth, maxHeight, isBubble);
  //   this.setSize(Math.min(this._width, maxWidth), Math.min(this._height, maxHeight), isBubble);
  //   this._children.forEach(kid => {
  //     kid.constrainSize(this._width, this._height, false);
  //   });
  //   this._adjustToSizeConstraint();
  // }
  // protected _adjustToSizeConstraint() {
  //   this.layoutViews();
  // }
  _didAddChildToList(e) {
    e.isBubbleSizeChange = !0;
  }
  _childDidResize(e) {
    this.updateSize();
  }
  _didAddChild(e) {
  }
  _didRemoveChild(e) {
    this.updateSize();
  }
}
function AR(t) {
  return Math.round(t * 100) / 100;
}
class _h extends m9e {
  constructor(e, r, n) {
    super(e, n), this._rows = [], this._territories = /* @__PURE__ */ new Map(), this._hRules = [], this._vRules = [], this.log = qt("GridLayout "), this._canWidthFlex = !!r.canWidthFlex, this._canHeightFlex = !!r.canHeightFlex, this._width = r.width ?? this._width, this._height = r.height ?? this._height, this._isAutoWidth = !!r.isAutoWidth, this._isAutoHeight = !!r.isAutoHeight, this._numCols = r.numCols, this._rowGaps = r.rowGaps !== void 0 ? this._expandRowGaps(r.rowGaps) : [0], this._colGaps = r.colGaps !== void 0 ? this._expandColGaps(r.colGaps) : new Array(this._numCols - 1).fill(0), this._rowAligns = r.rowAligns !== void 0 ? this._expandRowAligns(r.rowAligns) : ["center"], this._colAligns = r.colAligns !== void 0 ? this._expandColAligns(r.colAligns) : new Array(this._numCols).fill("center"), this._rows.push(new Array(this._numCols).fill(null)), this._resetRules();
  }
  get padding() {
    return super.padding;
  }
  set padding(e) {
    super.padding = e, this.layoutViews();
  }
  get numRows() {
    return this._rows.length;
  }
  get numCols() {
    return this._numCols;
  }
  get rowGaps() {
    return Array.from(this._rowGaps);
  }
  get colGaps() {
    return Array.from(this._colGaps);
  }
  get rowAligns() {
    return Array.from(this._rowAligns);
  }
  get colAligns() {
    return Array.from(this._colAligns);
  }
  set numCols(e) {
    this._numCols = e, this._arrangeChildren(), this.layoutViews();
  }
  set rowGaps(e) {
    this._rowGaps = this._expandRowGaps(e), this.setSize(...this.computeSize()), this.layoutViews();
  }
  get hRules() {
    return this._hRules;
  }
  get vRules() {
    return this._vRules;
  }
  setRowGap(e, r) {
    if (e >= this._rowGaps.length)
      throw new Error(`row gap index '${e}' out of bounds`);
    const n = this._rowGaps[e];
    this._rowGaps[e] = r;
    const i = e + 1, s = this._hRules.slice(i + 1).map((o) => o - (r - n));
    this._hRules.splice(i + 1, s.length, ...s), this._hRules[i] -= r, this._territories.keys().forEach((o) => {
      this._adjustViewToRules(o);
    }), this.layoutViews();
  }
  _expandRowGaps(e) {
    return typeof e == "object" ? Array.from(e) : [e];
  }
  set colGaps(e) {
    this._colGaps = this._expandColGaps(e), this.setSize(...this.computeSize()), this.layoutViews();
  }
  setColGap(e, r) {
    if (e < 0 || e >= this._colGaps.length)
      throw new Error(`col gap index '${e}' out of bounds`);
    const n = this._colGaps[e];
    this._colGaps[e] = r;
    const i = e + 1, s = this._vRules.slice(i + 1).map((o) => o - (r - n));
    this._vRules.splice(i + 1, s.length, ...s), this._vRules[i] -= r, this._territories.keys().forEach((o) => {
      this._adjustViewToRules(o);
    }), this.layoutViews();
  }
  _expandColGaps(e) {
    return typeof e == "object" ? Array.from(e) : new Array(this._numCols - 1).fill(e);
  }
  set rowAligns(e) {
    this._rowAligns = this._expandRowAligns(e), this.layoutViews();
  }
  _expandRowAligns(e) {
    return typeof e == "object" ? Array.from(e) : [e];
  }
  set colAligns(e) {
    this._colAligns = this._expandColAligns(e), this.layoutViews();
  }
  /** Contents of each cell in the given column. */
  col(e) {
    return this._rows.map((r) => r[e]);
  }
  _expandColAligns(e) {
    return typeof e == "object" ? Array.from(e) : new Array(this._numCols).fill(e);
  }
  // getAvailableSpace(territory: GridTerritory): {width: number, height: number} {
  //   // all cells must be empty
  //   for (let i = territory.x; i < territory.x + territory.width; i++) {
  //     for (let j = territory.y; j < territory.y + territory.height; j++) {
  //       if (this._rows[j][i]) {
  //         throw new Error(`grid row=${j} col=${i} already occupied`);
  //       }
  //     }
  //   }
  // }
  addColumnLeft() {
    this._numCols++, this._colGaps.unshift(0), this._colAligns.unshift("center"), this._rows.forEach((e) => e.unshift(null)), this._territories.values().forEach((e) => {
      e.x++;
    }), this._vRules.unshift(0);
  }
  addColumnRight() {
    this._numCols++, this._colGaps.push(0), this._colAligns.push("center"), this._rows.forEach((e) => e.push(null)), this._vRules.push(this._vRules.at(-1));
  }
  splitColumnRight(e, r = 0, n = "center") {
    const i = this.col(e).filter((s) => {
      if (s) {
        const o = this._territories.get(s);
        return o.x + o.width === e + 1;
      }
      return !1;
    });
    this._territories.values().forEach((s) => {
      s.x > e && s.x++;
    }), this._numCols++, this._colGaps.splice(e, 0, r), this._colAligns.splice(e + 1, 0, n), this._rows.forEach((s) => {
      s.splice(e + 1, 0, null);
    }), this._vRules.splice(e + 1, 0, i.length ? Math.max(...i.map((s) => s.paddedRight)) : this._vRules[e + 1]);
  }
  addRowTop() {
    this._rowGaps.unshift(0), this._rowAligns.unshift("center"), this._rows.unshift(new Array(this._numCols).fill(null)), this._territories.values().forEach((e) => {
      e.y++;
    }), this._hRules.unshift(0);
  }
  addRowBottom() {
    this._rowGaps.push(0), this._rowAligns.push("center"), this._rows.push(new Array(this._numCols).fill(null)), this._hRules.push(this._hRules.at(-1));
  }
  splitRowTop(e, r = "center") {
    const n = this._rows[e].filter((i) => i ? this._territories.get(i).y === e : !1);
    this._territories.values().forEach((i) => {
      i.y >= e && i.y++;
    }), this._rowGaps.splice(e - 1, 0, 0), this._rowAligns.splice(e, 0, r), this._rows.splice(e, 0, this._rows[0].map((i) => null)), this._hRules.splice(e + 1, 0, n.length ? Math.min(...n.map((i) => i.paddedTop)) : this._hRules[e]);
  }
  insertRow(e, r = 0, n = "center") {
    if (this._rowGaps.splice(e, 0, r), this._rowAligns.splice(e, 0, n), this._rows.splice(e, 0, new Array(this._numCols).fill(null)), this._territories.values().forEach((i) => {
      i.y >= e && i.y++;
    }), this._hRules.splice(e, 0, this._hRules[e] ?? this._hRules.at(-1)), r)
      for (let i = e + 2; i < this._hRules.length; i++)
        this._hRules[i] -= r;
  }
  _resetRules() {
    this._hRules = [0, this._isAutoHeight ? 0 : this._height - this._rowGaps.reduce((e, r) => e + r, 0)], this._vRules = new Array(this._numCols).fill(0), this._vRules.push(this._isAutoWidth ? 0 : this._width - this._colGaps.reduce((e, r) => e + r, 0));
  }
  _defaultMargin(e, r) {
    return {
      left: this._colGaps[this._leftGapIndex(e)] ?? 0,
      right: this._colGaps[this._rightGapIndex(e)] ?? 0,
      top: this._rowGaps[this._topGapIndex(r)] ?? 0,
      bottom: this._rowGaps[this._bottomGapIndex(r)] ?? 0
    };
  }
  _createTerritory(e) {
    const r = e.x ?? 0, n = e.y ?? 0;
    return {
      x: r,
      y: n,
      width: e.width ?? 1,
      height: e.height ?? 1,
      rowAlign: e.rowAlign,
      colAlign: e.colAlign
      // margin: input.margin !== undefined
      //   ? this._expandPadding(input.margin, this._defaultMargin(x, y))
      //   : this._defaultMargin(x, y)
    };
  }
  _claimTerritory(e, r) {
    if (this._territories.has(e))
      throw new Error("view already present in grid");
    r && this._territories.set(e, this._createTerritory(r));
  }
  _territoryView(e) {
    return this._territories.keys().find((r) => this._territories.get(r) === e);
  }
  _territoryPhysWidth(e, r = !0) {
    return this._vRuleDist(e.x, e.x + e.width, r);
  }
  _territoryPhysHeight(e, r = !0) {
    return this._hRuleDist(e.y, e.y + e.height, r);
  }
  /** Physical distance between two hRules, possibly inclusive of gaps */
  _hRuleDist(e, r, n = !0) {
    return this._hRules[r] - this._hRules[e] + (n ? this._rowGaps.slice(e, r).reduce((i, s) => i + s, 0) : 0);
  }
  /** Physical distance between two vRules, possibly inclusive of gaps */
  _vRuleDist(e, r, n = !0) {
    return this._vRules[r] - this._vRules[e] + (n ? this._colGaps.slice(e, r).reduce((i, s) => i + s, 0) : 0);
  }
  /**
   * View's unused horizontal space in its territory
   */
  _viewAvailWidth(e) {
    return this._territoryPhysWidth(this._territories.get(e), !1) - e.paddedWidth;
  }
  /**
   * View's unused vertical space in its territory
   */
  _viewAvailHeight(e) {
    return this._territoryPhysHeight(this._territories.get(e), !1) - e.paddedHeight;
  }
  _territoryBbox(e) {
    let r = this.left;
    const n = this._vRules.slice(1).map((d, b) => d - this._vRules[b]), i = this._colGaps;
    for (let d = 0; d < e.x; d++)
      r += n[d] + i[d];
    const s = n.slice(e.x, e.x + e.width).reduce((d, b) => d + b, 0) + i.slice(e.x, e.x + e.width - 1).reduce((d, b) => d + b, 0), o = r + s;
    let a = this.top;
    const l = this._hRules.slice(1).map((d, b) => d - this._hRules[b]), c = this._rowGaps;
    for (let d = 0; d < e.y; d++)
      a += l[d] + c[d];
    const p = l.slice(e.y, e.y + e.height).reduce((d, b) => d + b, 0) + c.slice(e.y, e.y + e.height - 1).reduce((d, b) => d + b, 0), h = a + p;
    return new DOMRect(r, a, o - r, h - a);
  }
  append(e, r) {
    this._claimTerritory(e, r), super.append(e);
  }
  prepend(e, r) {
    this._claimTerritory(e, r), super.prepend(e);
  }
  _didAddChild(e) {
    this._arrangeChild(e), this._adjustRules(e), (this._isAutoWidth || this._isAutoHeight) && this.updateSize(), this.layoutViews(), super._didAddChild(e);
  }
  _didRemoveChild(e) {
    this._rows = this._rows.map((r) => r.map((n) => n === e ? null : n)), this._territories.delete(e), this._contractRules(), super._didRemoveChild(e);
  }
  _firstEmptyCell() {
    for (let e = 0; e < this._rows.length; e++) {
      const r = this._rows[e];
      for (let n = 0; n < r.length; n++)
        if (!r[n])
          return [e, n];
    }
    return [this._rows.length, 0];
  }
  _arrangeChild(e) {
    const r = this._territories.get(e);
    let n = [], i = [];
    if (r)
      r.x < 0 && (r.x = this._numCols + r.x), r.y < 0 && (r.y = this._rows.length + r.y), n = ua(r.height, (s) => r.y + s), i = ua(r.width, (s) => r.x + s);
    else {
      const [s, o] = this._firstEmptyCell();
      n = [s], i = [o], this._territories.set(e, {
        x: o,
        y: s,
        width: 1,
        height: 1
        // margin: this._defaultMargin(col, row)
      });
    }
    n.filter((s) => s > this._rows.length - 1).forEach((s) => {
      this._rows.push(ua(this._numCols, (o) => null)), this._rowGaps.push(0), this._hRules.push(this._hRules.at(-1));
    }), n.forEach(
      (s) => i.forEach((o) => {
        if (this._rows[s][o])
          throw new Error("grid children cannot overlap");
        this._rows[s][o] = e;
      })
    );
  }
  colWidth(e) {
    if (e > this._rows[0].length - 1)
      throw new Error(`col index '${e}' out of bounds`);
    return this._vRuleDist(e, e + 1, !1);
  }
  rowHeight(e) {
    if (e > this._rows.length - 1)
      throw new Error(`row index '${e}' out of bounds`);
    return this._hRuleDist(e, e + 1, !1);
  }
  /** Whether a row can expand vertically. */
  _rowCanGrow(e) {
    return this.rowHeight(e) ? this._rows[e].every((n) => !n || n.canWidthFlex) : !1;
  }
  /**
   * How much a row can shrink vertically;
   * max value is the current row height
   */
  _rowShrinkability(e) {
    const r = this.rowHeight(e);
    if (!r)
      return 0;
    const n = this._rows[e].filter(
      (s) => {
        if (s) {
          const o = this._territories.get(s);
          return o.y === e || o.y + o.height === e + 1;
        }
      }
    );
    if (!n.length)
      return r;
    const i = n.map((s) => s.canHeightFlex ? r : Math.min(r, this._viewAvailHeight(s)));
    return AR(Math.min(...i));
  }
  /** Whether a column can expand horizontally. */
  _columnCanGrow(e) {
    return this.colWidth(e) ? this.col(e).every((n) => !n || n.canWidthFlex) : !1;
  }
  /**
   * How much a column can shrink horizontally;
   * max value is the current column width
   */
  _columnShrinkability(e) {
    const r = this.colWidth(e);
    if (!r)
      return 0;
    const n = this._rows.map((i) => i[e]).filter(
      (i) => {
        if (i) {
          const s = this._territories.get(i);
          return s.x === e || s.x + s.width === e + 1;
        }
      }
    );
    return n.length === 0 ? r : AR(Math.min(...n.map((i) => i.canWidthFlex ? r : Math.min(r, this._viewAvailWidth(i)))));
  }
  // protected _hRuleUpFlexibility(hRule: number): number {
  //   // views that end on hRule
  //   const prevRowViews = this._rows[hRule - 1]
  //     .filter(view => {
  //       if (view) {
  //         const t = this._territories.get(view)!;
  //         return t.y + t.height === hRule;
  //       }
  //     }
  //   ) as View[];
  //   if (prevRowViews.length) {
  //     const canShrink = prevRowViews.filter(view => view.isHeightCanShrink);
  //     const cantShrink = prevRowViews.filter(view => !view.isHeightCanShrink);
  //     if (canShrink.length === 0) {
  //       if (hRule > 1) {
  //         return this._hRuleUpFlexibility(hRule - 1);
  //       } else {
  //         return 0;
  //       }
  //     } else if (cantShrink.length === 0) {
  //       const rowFlex = Math.max(...canShrink.map(view => view.paddedHeight));
  //       if (hRule > 1) {
  //         return rowFlex + this._hRuleUpFlexibility(hRule - 1);
  //       } else {
  //         return rowFlex;
  //       }
  //     } else {
  //       const rowCanFlex = Math.max(...canShrink.map(view => view.paddedHeight));
  //       const rowCantFlex = Math.max(...cantShrink.map(view => view.paddedHeight));
  //       const rowFlex = Math.max(0, rowCanFlex - rowCantFlex);
  //       if (hRule > 1) {
  //         return rowFlex + this._hRuleUpFlexibility(hRule - 1);
  //       } else {
  //         return rowFlex;
  //       }
  //     }
  //   } else if (hRule > 1) {
  //     return this._hRuleUpFlexibility(hRule - 1);
  //   } else {
  //     return 0;
  //   }
  // }
  // canChildResize(kid: View, newWidth: number, newHeight: number): boolean {
  //   const territory = this._territories.get(kid)!;
  //   const hRuleStart = territory.y;
  //   const hRuleEnd = hRuleStart + territory.height;
  //   const vRuleStart = territory.x;
  //   const vRuleEnd = vRuleStart + territory.width;
  //   let rowShrinkage = new Map<number, number>();
  //   let columnShrinkage = new Map<number, number>();
  //   let kidWidthShrink = 0;
  //   let kidHeightShrink = 0;
  //   if (!this._canWidthFlex) {
  //     const territoryPhysWidth = this._territoryPhysWidth(territory);
  //     this.log.info('TPW', territoryPhysWidth, this._hRules, this._vRules);
  //     const widthDiff = kid.paddedWidth - territoryPhysWidth;
  //     this.log.info('WIDTH DIFF', widthDiff);
  //     if (widthDiff > 0) {
  //       let otherCols = this._rows[0].map((_, i) => i).filter(i =>
  //         i < territory.x || i >= territory.x + territory.width);
  //       let availShrink = otherCols.map(i => this._columnShrinkability(i));
  //       otherCols = otherCols.filter((_rowIdx, i) => availShrink[i]);
  //       availShrink = availShrink.filter(avail => avail).map(avail => avail);
  //       this.log.info('AVAIL COL SHRINK', otherCols, availShrink);
  //       // NB: otherCols may be empty
  //       const availShrinkSum = availShrink.reduce((a, b) => a + b, 0);
  //       if (availShrinkSum < widthDiff) {
  //         // we can shrink as much as possible, but kid must be able to shrink
  //         // XXX any view resizing should be queued and performed after all new sizes
  //         // are determined, in case a view needs to resize in both width and height
  //         if (availShrinkSum) {
  //           columnShrinkage = this._apportionShrinkage(
  //             availShrinkSum, availShrinkSum,
  //             availShrink, otherCols);
  //         }
  //         kidWidthShrink = widthDiff - availShrinkSum;
  //         this.log.info('KIDWIDTHSHRINK', kidWidthShrink, columnShrinkage);
  //       } else {
  //         // apportion space among shrinkable columns
  //         columnShrinkage = this._apportionShrinkage(
  //           widthDiff, availShrinkSum,
  //           availShrink, otherCols);
  //         this.log.info('COL SHRINK', columnShrinkage);
  //       }
  //     }
  //   } else {
  //     // All territories spanning the previous column that end on vRuleEnd
  //     const prevColTerritories = this._rows
  //       .map(row => row[vRuleEnd - 1])
  //       .filter(view => view)
  //       .map(view => this._territories.get(view!)!)
  //       .filter(t => t.x + t.width === vRuleEnd);
  //     const territoryDiffs = prevColTerritories.map(t => {
  //       const vRuleStart = t.x;
  //       const vRuleEnd = vRuleStart + t.width;
  //       const vDiff = this._vRules[vRuleEnd] - this._vRules[vRuleStart];
  //       const tView = this._rows[t.y][t.x];
  //       return tView!.paddedWidth - vDiff;
  //     });
  //     const vShift = Math.max(...territoryDiffs);
  //     if (vShift) {
  //       this._vRules[vRuleEnd] += vShift;
  //       this._vRules.slice(vRuleEnd + 1).forEach((vRule, i) => {
  //         this._vRules[vRuleEnd + 1 + i] += vShift;
  //       });
  //     }
  //   }
  //   if (!this._canHeightFlex) {
  //     const territoryPhysHeight = this._territoryPhysHeight(territory);
  //     this.log.info('TPH', territoryPhysHeight, kid.paddedHeight);
  //     const heightDiff = kid.paddedHeight - territoryPhysHeight;
  //     this.log.info('HEIGHT DIFF', heightDiff);
  //     if (heightDiff > 0) {
  //       let otherRows = this._rows.map((_, i) => i).filter(i =>
  //         i < territory.y || i >= territory.y + territory.height);
  //       this.log.info('OTHER ROWS', otherRows);
  //       let availShrink = otherRows.map(i => this._rowShrinkability(i));
  //       this.log.info('AVAIL SHRINK', availShrink);
  //       otherRows = otherRows.filter((_rowIdx, i) => availShrink[i]);
  //       availShrink = availShrink.filter(avail => avail).map(avail => avail);
  //       const availShrinkSum = availShrink.reduce((a, b) => a + b, 0);
  //       if (availShrinkSum < heightDiff) {
  //         if (availShrinkSum) {
  //           rowShrinkage = this._apportionShrinkage(
  //             availShrinkSum, availShrinkSum,
  //             availShrink, otherRows);
  //         }
  //         kidHeightShrink = heightDiff - availShrinkSum;
  //       } else {
  //         rowShrinkage = this._apportionShrinkage(
  //           heightDiff, availShrinkSum,
  //           availShrink, otherRows);
  //         this.log.info('ROW SHRINK', rowShrinkage);
  //       }
  //     }
  //   } else {
  //     // views in bottom-most row of territory that end on hRuleEnd
  //     const prevRowTerritories = this._rows[hRuleEnd - 1]
  //       .filter(view => view)
  //       .map(view => this._territories.get(view!)!)
  //       .filter(t => t.y + t.height === hRuleEnd);
  //     const rowTerritoryDiffs = prevRowTerritories.map(t => {
  //       const hRuleStart = t.y;
  //       const hRuleEnd = hRuleStart + t.height;
  //       const hDiff = this._hRules[hRuleEnd] - this._hRules[hRuleStart];
  //       const tView = this._rows[t.y][t.x];
  //       // XXX not all views here will necessarily start at hRuleStart!
  //       return tView!.paddedHeight - hDiff;
  //     });
  //     const hShift = Math.max(...rowTerritoryDiffs);
  //     if (hShift) {
  //       this._hRules[hRuleEnd] += hShift;
  //       this._hRules.slice(hRuleEnd + 1).forEach((hRule, i) => {
  //         this._hRules[hRuleEnd + 1 + i] += hShift;
  //       });
  //     }
  //   }
  //   const toResize = new Map<View, {width: number, height: number}>();
  //   if (rowShrinkage.size) {
  //     this.log.info('ROWS WILL SHRINK');
  //     rowShrinkage.entries().forEach(([idx, shrink]) => {
  //       this._rows[idx].forEach(view => {
  //         if (view) {
  //           toResize.set(view, {width: view.width, height: view.height - shrink});
  //         }
  //       });
  //     });
  //     this.log.info('TO RESIZE', toResize);
  //     const rowsAbove = new Map(rowShrinkage.entries().filter(([idx, shrink]) =>
  //       idx < territory.y));
  //     const rowsBelow = new Map(rowShrinkage.entries().filter(([idx, shrink]) =>
  //       idx >= territory.y + territory.height));
  //     this.log.info('ROWS ABOVE', rowsAbove, rowsBelow);
  //     this.log.info('HRULES BEFORE', [...this._hRules]);
  //     // Move hrules above territory up
  //     rowsAbove.forEach((shrink, idx) => {
  //       this._hRules.splice(idx + 1, rowsAbove.size,
  //         ...this._hRules.slice(idx + 1, idx + 1 + rowsAbove.size).map(hr => hr - shrink));
  //     });
  //     // Move hrules below territory down
  //     rowsBelow.forEach((shrink, idx) => {
  //       this._hRules.splice(idx, rowsBelow.size,
  //         ...this._hRules.slice(idx).map(hr => hr + shrink));
  //     });
  //     this.log.info('HRULES', this._hRules);
  //   }
  //   if (columnShrinkage.size) {
  //     this.log.info('COLS WILL SHRINK');
  //     columnShrinkage.entries().forEach(([idx, shrink]) => {
  //       this._rows.map(row => row[idx]).forEach(view => {
  //         if (view) {
  //           toResize.set(view, {width: view.width - shrink, height: view.height});
  //         }
  //       });
  //     });
  //     this.log.info('TO RESIZE', toResize);
  //     const colsLeft = columnShrinkage.entries().filter(([idx, shrink]) =>
  //       idx < territory.x).toArray();
  //     const colsRight = columnShrinkage.entries().filter(([idx, shrink]) =>
  //       idx >= territory.x + territory.width).toArray().toReversed();
  //     this.log.info('VRULES BEFORE', [...this._vRules]);
  //     // Move vrules at territory left
  //     colsLeft.forEach(([idx, shrink]) => {
  //       this._vRules.splice(idx + 1, territory.x - (idx + 1),
  //         ...this._vRules.slice(idx + 1, territory.x).map(vr => vr - shrink));
  //     });
  //     // Move vrules at territory right
  //     colsRight.forEach(([idx, shrink]) => {
  //       const start = territory.x + territory.width;
  //       this._vRules.splice(start, idx + 1 - start,
  //         ...this._vRules.slice(start, idx + 1).map(vr => vr + shrink)
  //       );
  //     });
  //     this.log.info('VRULES', this._vRules);
  //   }
  //   toResize.forEach((newSize, view) => {
  //     // Set the size without notifying the parent of the size change
  //     this.log.info('RESIZING VIEWS', [...this._hRules]);
  //     // view.constrainSize(newSize.width, newSize.height);
  //     view.setSize(newSize.width, newSize.height, false);
  //     .log('RESIZING VIEWS COMPLETE', [...this._hRules]);
  //   });
  //   if (kidWidthShrink || kidHeightShrink) {
  //     this.log.info('KID CONSTRAIN', kid.width - kidWidthShrink, kid.height - kidHeightShrink);
  //     // kid.constrainSize(kid.width - kidWidthShrink, kid.height - kidHeightShrink);
  //     kid.setSize(kid.width - kidWidthShrink, kid.height - kidHeightShrink, false);
  //   }
  //   // XXX Don't forget to resize any other views in the kid's territory's row(s)/col(s),
  //   // if necessary
  // }
  _adjustRules(e) {
    const r = this._territories.get(e), i = r.y + r.height, o = r.x + r.width;
    let a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = 0, p = 0;
    if (this._isAutoWidth) {
      const d = e.paddedWidth - this._territoryPhysWidth(r);
      d > 0 && (this._vRules[o] += d, this._vRules.slice(o + 1).forEach((b, m) => {
        this._vRules[o + 1 + m] += d;
      }));
    } else {
      const d = this._territoryPhysWidth(r, !1), b = e.paddedWidth - d;
      if (b > 0) {
        let m = this._rows[0].map((E, A) => A).filter((E) => E < r.x || E >= r.x + r.width), w = m.map((E) => this._columnShrinkability(E));
        m = m.filter((E, A) => w[A]), w = w.filter((E) => E).map((E) => E);
        const f = w.reduce((E, A) => E + A, 0);
        f < b ? (f && (l = this._apportionShrinkage(
          f,
          f,
          w,
          m
        )), c = b - f) : l = this._apportionShrinkage(
          b,
          f,
          w,
          m
        );
      }
    }
    if (this._isAutoHeight) {
      const b = this._rows[i - 1].filter((w) => w).map((w) => this._territories.get(w)).filter((w) => w.y + w.height === i).map((w) => {
        const f = w.y, E = f + w.height, A = this._hRules[E] - this._hRules[f];
        return this._rows[w.y][w.x].paddedHeight - A;
      }), m = Math.max(...b);
      m && (this._hRules[i] += m, this._hRules.slice(i + 1).forEach((w, f) => {
        this._hRules[i + 1 + f] += m;
      }));
    } else {
      const d = this._territoryPhysHeight(r, !1), b = e.paddedHeight - d;
      if (b > 0) {
        let m = this._rows.map((E, A) => A).filter((E) => E < r.y || E >= r.y + r.height), w = m.map((E) => this._rowShrinkability(E));
        m = m.filter((E, A) => w[A]), w = w.filter((E) => E);
        const f = w.reduce((E, A) => E + A, 0);
        f < b ? (f && (a = this._apportionShrinkage(
          f,
          f,
          w,
          m
        )), p = b - f) : a = this._apportionShrinkage(
          b,
          f,
          w,
          m
        );
      }
    }
    const h = /* @__PURE__ */ new Map();
    if (a.size) {
      a.entries().forEach(([m, w]) => {
        this._rows[m].forEach((f) => {
          f && h.set(f, { width: f.width, height: f.height - w });
        });
      });
      const d = new Map(a.entries().filter(([m, w]) => m < r.y)), b = new Map(a.entries().filter(([m, w]) => m >= r.y + r.height));
      d.forEach((m, w) => {
        this._hRules.splice(
          w + 1,
          d.size,
          ...this._hRules.slice(w + 1, w + 1 + d.size).map((f) => f - m)
        );
      }), b.entries().forEach(([m, w]) => {
        this._hRules[m] += w;
      });
    }
    if (l.size) {
      l.entries().forEach(([m, w]) => {
        this._rows.map((f) => f[m]).forEach((f) => {
          f && h.set(f, { width: f.width - w, height: f.height });
        });
      });
      const d = l.entries().filter(([m, w]) => m < r.x).toArray(), b = l.entries().filter(([m, w]) => m >= r.x + r.width).toArray().toReversed();
      d.forEach(([m, w]) => {
        const f = this._vRules.slice(m + 1, r.x + 1).map((E) => E - w);
        this._vRules.splice(m + 1, f.length, ...f);
      }), b.forEach(([m, w]) => {
        const f = r.x + r.width;
        this._vRules.splice(
          f,
          m + 1 - f,
          ...this._vRules.slice(f, m + 1).map((E) => E + w)
        );
      });
    }
    h.forEach((d, b) => {
      b.resize(d.width, d.height);
    }), (c || p) && e.resize(e.width - c, e.height - p);
  }
  _adjustViewToRules(e) {
    const r = this._territories.get(e);
    let n = 0, i = 0;
    const s = this._territoryPhysWidth(r, !1), o = e.paddedWidth - s;
    o > 0 && (n = o);
    const a = this._territoryPhysHeight(r, !1), l = e.paddedHeight - a;
    l > 0 && (i = l), (n || i) && e.resize(e.width - n, e.height - i);
  }
  /**
   * Apportion shrinkage of rows or columns
   * @param toApportion - Total amount of shrinkage to apportion
   * @param availShrinkSum - Total shrinkage available in rows/columns
   * @param availShrink - Amount of shrinkage available in each row/column
   * @param indices - Row/column indices
   * @returns Map of row/column index to amount of shrinkage
   */
  _apportionShrinkage(e, r, n, i) {
    const s = /* @__PURE__ */ new Map(), o = e / r;
    return i.forEach((a, l) => {
      s.set(a, n[l] * o);
    }), s;
  }
  // protected _apportionColumnShrinkage(
  //   toApportion: number, availShrinkSum: number,
  //   availShrink: number[], cols: number[]
  // ): Map<number, number> {
  //   const shrinkage = new Map<number, number>();
  //   const apportionPct = toApportion/availShrinkSum;
  //   cols.forEach((colIdx, i) => {
  //     shrinkage.set(colIdx, availShrink[i]*apportionPct);
  //   });
  //   return shrinkage;
  // }
  _contractRules() {
    this._rows.forEach((r, n) => {
      if (r.every((i) => i === null)) {
        const i = this._hRules[n + 1] - this._hRules[n];
        this._hRules.splice(
          n + 1,
          this._hRules.length - (n + 1),
          ...this._hRules.slice(n + 1).map((s) => s - i)
        );
      }
    });
    const e = [];
    this._rows.forEach((r, n) => {
      r.forEach((i, s) => {
        e[s] || (e[s] = []), e[s][n] = i;
      });
    }), e.forEach((r, n) => {
      if (r.every((i) => i === null)) {
        const i = this._vRules[n + 1] - this._vRules[n];
        this._vRules.splice(
          n + 1,
          this._vRules.length - (n + 1),
          ...this._vRules.slice(n + 1).map((s) => s - i)
        );
      }
    });
  }
  // protected _computeColGap(index: number) {
  //   if (index < 0 || index > this._colGaps.length - 1) {
  //     return 0;
  //   }
  //   const leftViewMargins = this._rows
  //     .flatMap(row => row.filter((v, i) => v && (i === index)) as View[])
  //     .map(v => this._territories.get(v)!.margin.right);
  //   const rightViewMargins = this._rows
  //     .flatMap(row => row.filter((v, i) => v && (i === index + 1)) as View[])
  //     .map(v => this._territories.get(v)!.margin.left);
  //   const margins = leftViewMargins.concat(rightViewMargins);
  //   return margins.length ? Math.max(...margins) : 0;
  // }
  // protected _computeRowGap(index: number) {
  //   if (index < 0 || index > this._rowGaps.length - 1) {
  //     return 0;
  //   }
  //   const topViewMargins = ((this._rows[index]
  //     ?.filter(v => v) ?? []) as View[])
  //     .map(v => {
  //       return this._territories.get(v)!.margin.bottom;
  //     });
  //   const bottomViewMargins = ((this._rows[index + 1]
  //     ?.filter(v => v) ?? []) as View[])
  //     .map(v => this._territories.get(v)!.margin.top);
  //   const margins = topViewMargins.concat(bottomViewMargins);
  //   return margins.length ? Math.max(...margins) : 0;
  // }
  _leftGapIndex(e) {
    return e - 1;
  }
  _rightGapIndex(e) {
    return e;
  }
  _topGapIndex(e) {
    return e - 1;
  }
  _bottomGapIndex(e) {
    return e;
  }
  // protected _adjustGaps(kid: View) {
  //   const territory = this._territories.get(kid)!;
  //   const leftIndex = this._leftGapIndex(territory.x);
  //   if (leftIndex >= 0) {
  //     this._colGaps[leftIndex] = this._computeColGap(leftIndex);
  //   }
  //   const rightIndex = this._rightGapIndex(territory.x);
  //   if (rightIndex < this._colGaps.length) {
  //     this._colGaps[rightIndex] = this._computeColGap(rightIndex);
  //   }
  //   const topIndex = this._topGapIndex(territory.y);
  //   if (topIndex >= 0) {
  //     this._rowGaps[topIndex] = this._computeRowGap(topIndex);
  //   }
  //   const bottomIndex = this._bottomGapIndex(territory.y);
  //   if (bottomIndex < this._rowGaps.length) {
  //     this._rowGaps[bottomIndex] = this._computeRowGap(bottomIndex);
  //   }
  // }
  // protected _updateGaps() {
  //   for (const index of this._colGaps) {
  //     this._colGaps[index] = this._computeColGap(index);
  //   }
  //   for (const index of this._rowGaps) {
  //     this._rowGaps[index] = this._computeRowGap(index);
  //   }
  // }
  _arrangeChildren() {
    this._rows = [], this._territories.clear(), this._resetRules(), this._children.forEach((e) => {
      this._arrangeChild(e), this._adjustRules(e);
    }), this.setSize(...this.computeSize());
  }
  _childDidResize(e) {
    this._adjustRules(e), super._childDidResize(e);
  }
  computeSize() {
    const e = this._colGaps.reduce((n, i) => n + i, 0), r = this._rowGaps.reduce((n, i) => n + i, 0);
    return [
      this._vRules.at(-1) + e,
      this._hRules.at(-1) + r
    ];
  }
  _adjustToSizeConstraint() {
  }
  resize(e, r) {
    const n = /* @__PURE__ */ new Map();
    if (this._width !== e) {
      const i = ua(this.numCols, (s) => s);
      if (this._width > e) {
        const s = i.map((a) => this._columnShrinkability(a)), o = this._apportionShrinkage(
          this._width - e,
          s.reduce((a, l) => a + l, 0),
          s,
          i
        );
        i.forEach((a) => {
          this._vRules[a + 1] -= o.get(a), i.slice(a + 1).forEach((l) => {
            this._vRules[l + 1] -= o.get(a);
          });
        }), o.entries().forEach(([a, l]) => {
          this._rows.map((c) => c[a]).forEach((c) => {
            c && l && c.canWidthFlex && n.set(c, { width: c.width - l, height: c.height });
          });
        });
      } else if (this._width < e) {
        const s = i.map((l) => this._columnCanGrow(l)), o = s.reduce((l, c) => (l ? 1 : 0) + (c ? 1 : 0), 0), a = s.map((l) => l ? (e - this._width) / o : 0);
        i.forEach((l) => {
          this._vRules[l + 1] += a[l], i.slice(l + 1).forEach((c) => {
            this._vRules[c + 1] += a[l];
          });
        }), a.forEach((l, c) => {
          this._rows.map((p) => p[c]).forEach((p) => {
            p && l && n.set(p, { width: p.width + l, height: p.height });
          });
        });
      }
      this._width = e;
    }
    if (this._height > r) {
      const i = ua(this.numRows, (a) => a), s = i.map((a) => this._rowShrinkability(a)), o = this._apportionShrinkage(
        this._height - r,
        s.reduce((a, l) => a + l, 0),
        s,
        i
      );
      i.forEach((a) => {
        this._hRules[a + 1] -= o.get(a), i.slice(a + 1).forEach((l) => {
          this._hRules[l + 1] -= o.get(a);
        });
      }), o.entries().forEach(([a, l]) => {
        this._rows[a].forEach((c) => {
          c && l && c.canHeightFlex && n.set(c, { width: c.width, height: c.height - l });
        });
      }), this._height = r;
    } else if (this._height < r) {
      const i = ua(this.numRows, (l) => l), s = i.map((l) => this._rowCanGrow(l)), o = s.reduce((l, c) => (l ? 1 : 0) + (c ? 1 : 0), 0), a = s.map((l) => l ? (r - this._height) / o : 0);
      i.forEach((l) => {
        this._hRules[l + 1] += a[l], i.slice(l + 1).forEach((c) => {
          this._hRules[c + 1] += a[l];
        });
      }), a.forEach((l, c) => {
        this._rows[c].forEach((p) => {
          p && l && n.set(p, { width: p.width, height: p.height + l });
        });
      }), this._height = r;
    }
    n.forEach((i, s) => {
      s instanceof di || s.resize(i.width, i.height);
    }), this.layoutViews();
  }
  layoutViews() {
    this._children.forEach((e, r) => {
      this._snapChildX(e), this._snapChildY(e);
    });
  }
  _snapChildX(e) {
    const r = this._territories.get(e);
    let n = this.left;
    const i = this._vRules.slice(1).map((l, c) => l - this._vRules[c]), s = this._colGaps;
    for (let l = 0; l < r.x; l++)
      n += i[l] + s[l];
    const o = r.colAlign ?? this._colAligns[r.x], a = i.slice(r.x, r.x + r.width).reduce((l, c) => l + c, 0) + s.slice(r.x, r.x + r.width - 1).reduce((l, c) => l + c, 0);
    o === "start" ? e.left = n : o === "end" ? e.right = n + a : e.centerX = n + a / 2;
  }
  _snapChildY(e) {
    const r = this._territories.get(e);
    let n = this.top;
    const i = this._hRules.slice(1).map((l, c) => l - this._hRules[c]), s = this._rowGaps;
    for (let l = 0; l < r.y; l++)
      n += i[l] + s[l];
    const o = r.rowAlign ?? this._rowAligns[r.y], a = i.slice(r.y, r.y + r.height).reduce((l, c) => l + c, 0) + s.slice(r.y, r.y + r.height - 1).reduce((l, c) => l + c, 0);
    o === "start" ? e.paddedTop = n : o === "end" ? e.paddedBottom = n + a : e.centerY = n + a / 2;
  }
  content(...e) {
    const r = this._territories.values().map((n) => {
      const i = this._territoryBbox(n), s = new sn(this.paraview, {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      });
      return s.classInfo = { "debug-grid-territory": !0 }, s;
    });
    return Tt`
      ${super.content()}
      ${this.paraview.store.settings.dev.isShowGridTerritories ? r.map((n) => n.render()) : ""}
    `;
  }
}
var y9e = Object.defineProperty, b9e = Object.getOwnPropertyDescriptor, mU = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? b9e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && y9e(e, r, i), i;
};
const cl = 10, kR = 15, v9e = 6;
class ls extends Pr {
  constructor(e, r, n) {
    super(e), this.popupLabelOptions = r, this.popupShapeOptions = n, this.leftPadding = this.paraview.store.settings.popup.leftPadding, this.rightPadding = this.paraview.store.settings.popup.rightPadding, this.downPadding = this.paraview.store.settings.popup.downPadding, this.upPadding = this.paraview.store.settings.popup.upPadding, this.horizShift = 0, this.arrowPosition = "bottom", this._wrapWidth = this.paraview.store.settings.popup.maxWidth, this.applyDefaults(), this._label = new di(this.paraview, this.popupLabelOptions), this.paraview.store.settings.popup.backgroundColor === "dark" && (this._label.styleInfo = {
      stroke: "none",
      fill: this.popupLabelOptions.fill ? this.popupLabelOptions.fill : this.popupLabelOptions.type == "chord" ? "black" : this.paraview.store.colors.contrastValueAt(this.popupLabelOptions.color)
    }), this.paraview.store.settings.ui.isLowVisionModeEnabled && (this._label.styleInfo = {
      stroke: "none",
      fill: "black"
    }), this._grid = this.generateGrid(), this.popupLabelOptions.inbounds && this.shiftGrid(), this.append(this._grid), (this.popupLabelOptions.type == "vertTick" || this.popupLabelOptions.type == "vertAxis") && (this.arrowPosition = "left"), this._box = this.generateBox(n), this.append(this._box);
    const i = parseFloat(this.paraview.documentView.chartLayers.width.toFixed(5));
    if (this.popupLabelOptions.type === "sequence") {
      const s = this.popupLabelOptions.points;
      s.map((o) => o.shapes.map((a) => a.intersects(this.box))).flat().some(Boolean) && (i - s[s.length - 1].x > this.grid.width ? (this.arrowPosition = "left", this.grid.x = s[s.length - 1].x + this.leftPadding + cl) : s[0].x > this.grid.width && (this.arrowPosition = "right", this.grid.x = s[0].x - this.grid.width - this.leftPadding - cl), this._children.pop(), this._box = this.generateBox(n), this.append(this._box));
    }
    this.box.classInfo = { "popup-box": !0 }, this.label.classInfo = { "popup-text": !0 }, this._children.unshift(this._box), this._children.pop(), r.id && (this.id = r.id);
  }
  get grid() {
    return this._grid;
  }
  get label() {
    return this._label;
  }
  get box() {
    return this._box;
  }
  get margin() {
    return this.popupLabelOptions.margin ?? this.paraview.store.settings.popup.margin;
  }
  get wrapWidth() {
    return this._wrapWidth;
  }
  set wrapWidth(e) {
    this._wrapWidth = e;
  }
  get text() {
    return this.popupLabelOptions.text;
  }
  applyDefaults() {
    this.popupLabelOptions.color || (this.popupLabelOptions.color = 0), this.popupLabelOptions.wrapWidth || (this.popupLabelOptions.wrapWidth = this.wrapWidth), this.popupLabelOptions.y && (this.popupLabelOptions.y -= this.margin), this.popupLabelOptions.inbounds == null && (this.popupLabelOptions.inbounds = !0), this.popupLabelOptions.rotationExempt == null && (this.popupLabelOptions.rotationExempt = !0), this.popupShapeOptions.fill || (this.popupShapeOptions.fill = this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(this.popupLabelOptions.color), 6) : this.paraview.store.colors.colorValueAt(this.popupLabelOptions.color)), this.popupShapeOptions.stroke || (this.popupShapeOptions.stroke = this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(this.popupLabelOptions.color) : "black"), this.paraview.store.settings.ui.isLowVisionModeEnabled || (this.popupShapeOptions.fill = `${this.popupShapeOptions.fill.slice(0, -1)}, ${this.paraview.store.settings.popup.opacity})`), this.popupShapeOptions.shape || (this.popupShapeOptions.shape = this.paraview.store.settings.popup.shape);
  }
  shiftGrid() {
    var n, i;
    const e = parseFloat(this.paraview.documentView.chartLayers.width.toFixed(5));
    this.grid.right + this.rightPadding > e && (this.popupLabelOptions.type === "chord" ? (this.arrowPosition = "right", this.grid.x += -(this.grid.width + 2 * cl + this.rightPadding + this.leftPadding)) : (this.horizShift = this.grid.right + this.rightPadding - e, this.grid.x -= this.horizShift));
    let r = 0;
    this.popupLabelOptions.type === "vertAxis" ? r = 0 - this.paraview.documentView.vertAxis.layout.vRules[1] : this.popupLabelOptions.type === "controlPanelIcon" && (r = 0 - this.paraview.documentView.chartLayers.x), this.grid.left - this.leftPadding < r && (this.horizShift = -(this.leftPadding - this.grid.left + r), this.grid.x -= this.horizShift), this.grid.y - this.grid.bottom < 0 && this.popupLabelOptions.type !== "chord" && (this.grid.y += this.grid.y - this.grid.bottom), this.grid.top - this.upPadding < 0 && (this.popupLabelOptions.type !== "chord" ? (this.arrowPosition = "up", this.grid.y += 2 * this.margin + this.grid.height) : this.grid.height > ((n = this.paraview.documentView) == null ? void 0 : n.chartLayers.dataLayer.height) && this.wrapWidth + 50 < ((i = this.paraview.documentView) == null ? void 0 : i.chartLayers.dataLayer.width) && (this.wrapWidth += 50, this.generateGrid(), this.shiftGrid()));
  }
  generateGrid() {
    if (this.popupLabelOptions.type === "chord") {
      let e = [];
      this.leftPadding += 10, this.arrowPosition = "left";
      let r = [];
      for (let n = 0; n < this.popupLabelOptions.items.length - 1; n++)
        r.push(v9e);
      this._grid = new _h(this.paraview, {
        numCols: 2,
        colGaps: [15],
        rowGaps: r,
        colAligns: ["center", "start"],
        isAutoWidth: !0,
        isAutoHeight: !0
      }, "popup-grid"), this.popupLabelOptions.items.forEach((n, i) => {
        e.push(Fa.fromType(
          this.paraview,
          this.paraview.store.settings.chart.isDrawSymbols ? n.symbol ?? "square.solid" : "square.solid",
          {
            color: n.color
          }
        ));
        const o = this.popupLabelOptions.text.split(/\r?\n|\r/);
        e.push(new di(this.paraview, {
          text: o[i],
          x: 0,
          y: 0,
          wrapWidth: this.wrapWidth,
          textAnchor: "start"
        }));
      }), e.forEach((n) => this._grid.append(n)), this._grid.y = this.paraview.documentView.chartLayers.height / 2 - this._grid.height / 2, this._grid.x = this.popupLabelOptions.x + cl + this.leftPadding + this.horizShift;
    } else {
      let e = [];
      this._grid = new _h(this.paraview, {
        numCols: 1,
        colAligns: ["start"],
        isAutoWidth: !0,
        isAutoHeight: !0
      }, "popup-grid"), e.push(this._label), e.forEach((r) => this._grid.append(r)), this._grid.y = this.popupLabelOptions.y, this._grid.x = this.popupLabelOptions.x - this._grid.width / 2;
    }
    return this._grid;
  }
  generateBox(e) {
    const r = e.shape ?? "box", n = this._grid, i = n.bottom, s = n.x, o = n.width, a = n.height, l = this.leftPadding, c = this.rightPadding, p = this.upPadding, h = this.downPadding, d = this.horizShift;
    return r === "boxWithArrow" ? this.arrowPosition == "bottom" ? new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i + h),
        new Ye(Math.max(s + o / 2 - Math.min(o / 2, kR) + d, s - l), i + h),
        //This is manually correcting for what I'm pretty sure are floating-point errors
        new Ye(Math.abs(s + o / 2 + d - (s + o + c)) < 0.5 ? s + o + c : Math.abs(s + o / 2 + d - (s - l)) < 0.5 ? s - l : s + o / 2 + d, i + h + cl),
        new Ye(Math.min(s + o / 2 + Math.min(o / 2, kR) + d, s + o + c), i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "boxWithArrow",
      arrowPosition: "down"
    }) : this.arrowPosition == "right" ? new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a / 2 + Math.min(a / 4, 15)),
        new Ye(s + o + c + cl, i - a / 2),
        new Ye(s + o + c, i - a / 2 - Math.min(a / 4, 15)),
        new Ye(s + o + c, i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "boxWithArrow",
      arrowPosition: "right"
    }) : this.arrowPosition == "left" ? new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i - a / 2 - Math.min(a / 4, 15)),
        new Ye(s - l - cl, i - a / 2),
        new Ye(s - l, i - a / 2 + Math.min(a / 4, 15)),
        new Ye(s - l, i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "boxWithArrow",
      arrowPosition: "left"
    }) : new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a - p),
        new Ye(Math.min(s + o / 2 + Math.min(o / 4, 15) + d, s + o + c), i - a - p),
        //This is manually correcting for what I'm pretty sure are floating-point errors
        new Ye(Math.abs(s + o / 2 + d - (s + o + c)) < 0.5 ? s + o + c : Math.abs(s + o / 2 + d - (s - l)) < 0.5 ? s - l : s + o / 2 + d, i - a - p - cl),
        new Ye(Math.max(s + o / 2 + -Math.min(o / 4, 15) + d, s - l), i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "boxWithArrow",
      arrowPosition: "up"
    }) : new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "box"
    });
  }
  content() {
    var r, n, i, s, o, a;
    let e = nt``;
    return this.popupLabelOptions.rotationExempt && (((r = this.paraview.documentView) == null ? void 0 : r.chartLayers.orientation) === "east" ? e += nt`
                 rotate(-90)
                translate(${-((n = this.paraview.documentView) == null ? void 0 : n.chartLayers.logicalHeight)},${0})
            ` : ((i = this.paraview.documentView) == null ? void 0 : i.chartLayers.orientation) === "west" ? e += nt`
                rotate(90)
              translate(0,${-((s = this.paraview.documentView) == null ? void 0 : s.chartLayers.logicalHeight)})
            ` : ((o = this.paraview.documentView) == null ? void 0 : o.chartLayers.orientation) === "south" && (e += nt`
                scale(1,-1)
              translate(0,${-((a = this.paraview.documentView) == null ? void 0 : a.chartLayers.logicalHeight)})
            `)), Tt`
              <g
                id=${this.id ?? "popup"}
                transform=${e}
              >
                ${super.content()}
              </g>
            `;
  }
}
let _2 = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("PopupSettingsDialog"), this._dialogRef = Et(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "dropdown",
      key: "popup.shape",
      label: "Shape",
      options: { options: ["box", "boxWithArrow"] },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: "popup.activation",
      label: "Activate popups on",
      options: { options: ["onHover", "onFocus", "onSelect"] },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "slider",
      key: "popup.opacity",
      label: "Opacity",
      options: {
        min: 0,
        max: 1,
        //highBound: this._store.settings.sonification.hertzUpper - 1,
        step: 0.1
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.maxWidth",
      label: "Max width",
      options: {
        inputType: "number",
        min: 0,
        max: 300
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.leftPadding",
      label: "Left padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.rightPadding",
      label: "Right padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.upPadding",
      label: "Up padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.downPadding",
      label: "Down padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.margin",
      label: "Vertical margin",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.borderRadius",
      label: "Border radius",
      options: {
        inputType: "number",
        min: 0,
        max: 20
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: "popup.backgroundColor",
      label: "Color mode",
      options: {
        options: ["dark", "light"]
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    });
  }
  render() {
    return qe`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="Popup Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        <div id="controls">
          <div id="popup-settings"
            class="popup-views"
          >
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.dialog.popups")}
          </div>
        </div>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show();
  }
};
_2.styles = Nt`
    #controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  `;
mU([
  Ke()
], _2.prototype, "btnText", 2);
_2 = mU([
  Dt("para-popup-settings-dialog")
], _2);
class Pf extends jo {
  constructor(e, r) {
    super(e, r), this.options = r, this.curvePoints = {
      boxWithArrow: [1, 1, 0, 0, 0, 1, 1, 1],
      boxWithDownArrow: [1, 1, 0, 0, 0, 1, 1, 1],
      boxWithUpArrow: [1, 1, 1, 1, 0, 0, 0, 1],
      boxWithRightArrow: [1, 1, 1, 0, 0, 0, 1, 1],
      boxWithLeftArrow: [1, 0, 0, 0, 1, 1, 1, 1],
      box: [1, 1, 1, 1, 1]
    }, this._points = r.points.map((n) => n.clone()), this.shape = this.options.shape;
  }
  get _pathD() {
    const e = this.paraview.store.settings.popup.borderRadius;
    let r;
    this.shape == "boxWithArrow" && this.options.arrowPosition === "up" ? r = this.curvePoints.boxWithUpArrow : this.shape == "boxWithArrow" && this.options.arrowPosition === "down" ? r = this.curvePoints.boxWithDownArrow : this.shape == "boxWithArrow" && this.options.arrowPosition === "right" ? r = this.curvePoints.boxWithRightArrow : this.shape == "boxWithArrow" && this.options.arrowPosition === "left" ? r = this.curvePoints.boxWithLeftArrow : r = this.curvePoints[this.shape];
    const n = this._points.map((o) => o.add(this._loc));
    let i = nt``, s = n.length;
    if (!r[0] || Math.abs(n[0].x - n[s - 2].x) < e / 2 && Math.abs(n[0].y - n[s - 2].y) < e / 2)
      i += nt`M${n[0].x},${n[0].y}`;
    else {
      let o = n[0], a = n[1 % s];
      const l = Math.sign(o.x - a.x), c = Math.sign(o.y - a.y);
      i += nt`M${o.x - l * e},${o.y - c * e}`;
    }
    for (let o = 1; o < s; o++) {
      let a = n[o % s], l = n[(o - 1 + s) % s], c = n[(o + 1 + (o === s - 1 ? 1 : 0)) % s];
      if (!r[o % s] || Math.abs(a.x - l.x) < e / 2 && Math.abs(a.y - l.y) < e / 2 || Math.abs(a.x - c.x) < e / 2 && Math.abs(a.y - c.y) < e / 2 && o !== s - 1)
        i += nt`L${a.x},${a.y}`;
      else {
        const p = Math.sign(a.x - l.x), h = Math.sign(a.y - l.y), d = Math.sign(c.x - a.x), b = Math.sign(c.y - a.y);
        i += nt`L${a.x - p * e},${a.y - h * e}`, i += nt`A ${e}, ${e}, 0, 0, 0, ${a.x + d * e}, ${a.y + b * e}`;
      }
    }
    return i;
  }
}
class _R extends df {
  constructor(e, r, n, i) {
    super(e, r, n), this.type = i, this._groups = /* @__PURE__ */ new Map();
  }
  _createId() {
    return super._createId(`${this.type}-annotation`);
  }
  group(e) {
    return this._groups.get(e);
  }
  addGroup(e, r = !1) {
    if (this._groups.has(e)) {
      if (r)
        return;
      throw new Error(`group '${e}' already exists`);
    }
    this._groups.set(e, new w9e(this.paraview, e)), this.append(this._groups.get(e));
  }
  removeGroup(e, r = !1) {
    if (this._groups.has(e))
      this._groups.delete(e);
    else {
      if (r)
        return;
      throw new Error(`group '${e}' does not exist`);
    }
  }
  renderChildren() {
    var e;
    if (this.type === "foreground") {
      if (this.paraview.store.modelTrendLines) {
        this.addGroup("trend-lines", !0), this.group("trend-lines").clearChildren();
        for (const r of this.paraview.store.modelTrendLines) {
          const n = this.paraview.store.model.series.filter((b) => b[0].seriesKey == r.seriesKey)[0], i = this.parent.docView.chartInfo.getYAxisInterval(), s = i.start ?? Number(this.paraview.store.settings.axis.y.minValue), o = i.end ?? Number(this.paraview.store.settings.axis.y.maxValue), a = this.height - (n.datapoints[r.startIndex].facetValueNumericized("y") - s) / (o - s) * this.height, l = this.height - (n.datapoints[r.endIndex - 1].facetValueNumericized("y") - s) / (o - s) * this.height, c = this.width * r.startPortion, p = this.width * r.endPortion, h = this.paraview.store.colors.colorValue("visit"), d = new jo(this.paraview, {
            x: this._x,
            y: this._y,
            points: [new Ye(c, a), new Ye(p, l)],
            fill: h,
            stroke: h
          });
          d.classInfo = { "trend-line": !0 }, this.group("trend-lines").append(d);
        }
      } else
        this._groups.has("trend-lines") && this.removeGroup("trend-lines", !0);
      if (this.paraview.store.userTrendLines) {
        this.addGroup("user-trend-lines", !0), this.group("user-trend-lines").clearChildren();
        let r = structuredClone(this.paraview.store.userTrendLines);
        if (this.paraview.store.visitedDatapoints.size > 0) {
          const n = rn(this.paraview.store.visitedDatapoints.values().toArray()[0]);
          r = r.filter((i) => i.seriesKey == n.seriesKey);
        }
        for (const n of r) {
          const i = this.paraview.store.model.series.filter((m) => m[0].seriesKey == n.seriesKey)[0], s = this.parent.docView.chartInfo.getYAxisInterval(), o = s.start ?? Number(this.paraview.store.settings.axis.y.minValue), a = s.end ?? Number(this.paraview.store.settings.axis.y.maxValue), l = this.height - (i.datapoints[n.startIndex].facetValueNumericized("y") - o) / (a - o) * this.height, c = this.height - (i.datapoints[n.endIndex - 1].facetValueNumericized("y") - o) / (a - o) * this.height, p = this.width * n.startPortion, h = this.width * n.endPortion, d = this.paraview.store.colors.colorValue("highlight"), b = new jo(this.paraview, {
            x: this._x,
            y: this._y,
            points: [new Ye(p, l), new Ye(h, c)],
            fill: d,
            stroke: d
          });
          b.classInfo = { "user-trend-line": !0 }, this.group("user-trend-lines").append(b);
        }
      } else
        this._groups.has("user-trend-lines") && this.removeGroup("user-trend-lines", !0);
      if (this.paraview.store.annotations) {
        this.addGroup("annotation-popups", !0), this.group("annotation-popups").clearChildren();
        let r = structuredClone(this.paraview.store.annotations.filter((n) => n.type == "datapoint" && n.isSelected == !0));
        for (let n of this.paraview.store.visitedDatapoints) {
          let i = rn(n), s = this.paraview.documentView.chartLayers.dataLayer.datapointView(i.seriesKey, i.index);
          for (let o of this.paraview.store.annotations)
            s.seriesKey === o.seriesKey && s.index === o.index && !o.isSelected && r.push(o);
        }
        for (const n of r) {
          const i = this.paraview.store.model.series.filter((a) => a[0].seriesKey == n.seriesKey)[0].key, s = (e = this.paraview.documentView) == null ? void 0 : e.chartLayers.dataLayer.datapointViews.filter((a) => a.seriesKey == i && a.index == n.index)[0];
          if (!s)
            break;
          let o = new ls(
            this.paraview,
            {
              text: n.text,
              x: s.x,
              y: s.y,
              textAnchor: "middle",
              classList: ["annotationlabel"],
              id: this.id,
              color: s.color,
              points: [s]
            },
            {
              fill: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(s.color), 6) : this.paraview.store.colors.colorValueAt(s.color),
              stroke: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(s.color) : "black"
            }
          );
          o.classInfo = { popup: !0 }, this.group("annotation-popups").append(o);
        }
      } else
        this._groups.has("annotation-popups") && this.removeGroup("annotation-popups", !0);
    }
    if (this.type === "background") {
      if (this.paraview.store.rangeHighlights) {
        this.addGroup("range-highlights", !0), this.group("range-highlights").clearChildren();
        for (const r of this.paraview.store.rangeHighlights) {
          const n = this.width * r.startPortion, i = this.width * r.endPortion, s = new sn(this.paraview, {
            x: n,
            y: 0,
            width: i - n,
            height: this.height
          });
          s.classInfo = { "range-highlight": !0 }, this.group("range-highlights").append(s);
        }
      } else
        this._groups.has("range-highlights") && this.removeGroup("range-highlights", !0);
      if (this.paraview.store.modelLineBreaks) {
        this.addGroup("linebreaker-markers", !0), this.group("linebreaker-markers").clearChildren();
        for (const r of this.paraview.store.modelLineBreaks) {
          const n = this.width * r.startPortion, i = new sn(this.paraview, {
            x: n - 1.5,
            y: 0,
            width: 3,
            height: this.height
          });
          i.classInfo = { "linebreaker-marker": !0 }, this.group("linebreaker-markers").append(i);
        }
      } else
        this._groups.has("linebreaker-markers") && this.removeGroup("linebreaker-markers", !0);
      if (this.paraview.store.userLineBreaks) {
        this.addGroup("user-linebreaker-markers", !0), this.group("user-linebreaker-markers").clearChildren();
        let r = structuredClone(this.paraview.store.userLineBreaks);
        if (this.paraview.store.visitedDatapoints.size > 0) {
          const n = rn(this.paraview.store.visitedDatapoints.values().toArray()[0]);
          r = r.filter((i) => i.seriesKey == n.seriesKey);
        }
        for (const n of r) {
          const i = this.paraview.store.model.series.findIndex((l) => l.key == n.seriesKey), s = this.paraview.store.colors.colorValueAt(i), o = this.width * n.startPortion, a = new sn(this.paraview, {
            x: o - 1.5,
            y: 0,
            width: 3,
            height: this.height,
            fill: s
          });
          a.classInfo = { "user-linebreaker-marker": !0 }, this.group("user-linebreaker-markers").append(a);
        }
      } else
        this._groups.has("user-linebreaks") && this.removeGroup("userlinebreaks", !0);
    }
    return super.renderChildren();
  }
}
let w9e = class extends bo(Pr) {
  constructor(e, r) {
    super(e), this._name = r;
  }
  get name() {
    return this._name;
  }
};
class yU extends df {
  constructor(e, r, n, i, s) {
    super(e, r, n), this.dataLayerIndex = i, this._chartInfo = s, this._datapointDomIds = /* @__PURE__ */ new Map(), this._currentAnimationFrame = null, this._animateRevealComplete = !1;
  }
  _createId() {
    return super._createId("data");
  }
  _addedToParent() {
    super._addedToParent(), this._chartLandingView = new p8e(this.paraview), this.append(this._chartLandingView);
  }
  get managedSettingKeys() {
    return [`type.${this._parent.docView.type}`];
  }
  get settings() {
    return br.getGroupLink(this.managedSettingKeys[0], this.paraview.store.settings);
  }
  get chartInfo() {
    return this._chartInfo;
  }
  resize(e, r) {
    super.resize(e, r), this._layoutDatapoints();
  }
  // get sonifier() {
  //   return this._sonifier;
  // }
  get chartLandingView() {
    return this._chartLandingView;
  }
  get datapointViews() {
    return this._chartLandingView.datapointViews;
  }
  get visitedDatapointViews() {
    return this.datapointViews.filter(
      (e) => this.paraview.store.isVisited(e.seriesKey, e.index)
    );
  }
  get selectedDatapointViews() {
    return this.datapointViews.filter(
      (e) => this.paraview.store.isSelected(e.seriesKey, e.index)
    );
  }
  registerDatapoint(e) {
    const r = `${e.seriesKey}-${e.index}`;
    this._datapointDomIds.set(r, e.id);
  }
  unregisterDatapoint(e) {
    this._datapointDomIds.delete(`${e.seriesKey}-${e.index}`);
  }
  get datapointDomIds() {
    return this._datapointDomIds;
  }
  get dataset() {
    return this.paraview.ref(`dataset${this.index}`).value;
  }
  get role() {
    return "dataset";
  }
  get ref() {
    return yt(this.paraview.ref(`dataset${this.index}`));
  }
  get animateRevealComplete() {
    return this._animateRevealComplete;
  }
  init() {
    this._layoutDatapoints(), this.paraview.store.settings.animation.isAnimationEnabled && this._animateReveal();
  }
  settingDidChange(e, r, n) {
    ["ui.isLowVisionModeEnabled"].includes(e) && (r || this.paraview.store.updateSettings((i) => {
      i.popup.activation = "onSelect";
    })), ["popup.activation"].includes(e) && (r === "onSelect" || r === "onFocus") && (this.paraview.store.popups.splice(0, this.paraview.store.popups.length), this.paraview.store.userLineBreaks.splice(0, this.paraview.store.userLineBreaks.length)), ["chart.isShowPopups"].includes(e) && this.paraview.store.popups.splice(0, this.paraview.store.popups.length), super.settingDidChange(e, r, n);
  }
  /**
   * Stroke width for visited datapoints. Can be overridden.
   */
  get visitedStrokeWidth() {
    const e = this.paraview.store.settings.chart.strokeHighlightScale;
    return this.paraview.store.settings.chart.strokeWidth * e;
  }
  /**
   * Mutate `styleInfo` with any custom series styles.
   * @param styleInfo
   */
  updateSeriesStyle(e) {
  }
  _beginDatapointLayout() {
    this._createDatapoints();
    for (const e of this.datapointViews)
      e.computeLocation();
  }
  _completeDatapointLayout() {
    for (const e of this.datapointViews)
      e.completeLayout();
  }
  _layoutDatapoints() {
    this._chartLandingView.clearChildren(), this._beginDatapointLayout(), this.paraview.store.settings.animation.isAnimationEnabled && this.paraview.store.settings.animation.symbolPopIn && this.datapointViews.map((e) => e.baseSymbolScale = 0), this._completeDatapointLayout();
  }
  // protected _layoutComponents() {
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.computeLocation();
  //   }
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.completeLayout();
  //   }
  //   //this._layoutSymbols();
  // }
  _animateReveal() {
    let e = -1;
    const r = new iE(0.2, 0.9, 0.5, 1, 10), n = new iE(0, 0, 1, 1, 10), i = (s) => {
      e === -1 && (e = s);
      const o = s - e, a = Math.max(1, this.paraview.store.settings.animation.animateRevealTimeMs), l = Math.min(o / a, 1), c = r.eval(l), p = n.eval(l);
      this._animStep(c, p), this.paraview.paraChart.postNotice("animRevealStep", c), this.paraview.requestUpdate(), o < a ? this._currentAnimationFrame = requestAnimationFrame(i) : this._animEnd();
    };
    this._currentAnimationFrame = requestAnimationFrame(i), Y4(this.paraview, 500 + this.paraview.store.settings.animation.popInAnimateRevealTimeMs + this.paraview.store.settings.animation.animateRevealTimeMs, 50);
  }
  _animStep(e, r) {
    this.paraview.store.settings.animation.lineSnake && (this.paraview.clipWidth = r * this.paraview.documentView.chartLayers.width);
    for (const n of this.datapointViews)
      n.beginAnimStep(e, r);
    for (const n of this.datapointViews)
      n.endAnimStep(e, r);
  }
  _animEnd() {
    this.paraview.paraChart.postNotice("animRevealEnd", null), this._currentAnimationFrame = null, this._animateRevealComplete = !0;
    for (const e of this.datapointViews)
      e.endAnimStep(1, 1);
  }
  stopAnimation() {
    this._currentAnimationFrame !== null && (cancelAnimationFrame(this._currentAnimationFrame), this._animStep(1, 1), this.paraview.paraChart.postNotice("animRevealStep", 1), this.paraview.requestUpdate(), this._animEnd());
  }
  _newDatapointView(e, ...r) {
    return new pf(e);
  }
  _newSeriesView(e, r, ...n) {
    return new I9(this, e, r);
  }
  datapointView(e, r) {
    return this.datapointViews.find((n) => n.seriesKey === e && n.index === r);
  }
  datapointViewForId(e) {
    return this.datapointViews.find((r) => r.id === e);
  }
  // protected _layoutSymbols() {
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.layoutSymbol();
  //   }
  // }
  focusRingBbox() {
    const r = this._parent.docView.chartInfo.navMap.cursor;
    return ["series", "chord", "datapoint", "sequence"].includes(r.type) ? K4(...r.datapoints.map((n) => this.datapointView(n.seriesKey, n.datapointIndex).outerBbox)) : null;
  }
  handlePan(e, r, n, i) {
  }
  handleZoom(e, r) {
  }
}
class Zv extends yU {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this.log = qt("PlanePlotView");
  }
  get datapointViews() {
    return super.datapointViews;
  }
  get visitedDatapointViews() {
    return super.visitedDatapointViews;
  }
  get selectedDatapointViews() {
    return super.selectedDatapointViews;
  }
  /*
  protected get _eventActions(): Actions<this> {
    return {
      ...super._eventActions,
      // User attempted to move past series endpoint in chord mode
      series_endpoint_reached: function() {
        todo().controller.announce('On final point.');
      },
      // User attempted to move past endpoint of final series
      final_series_endpoint_reached: function() {
        todo().controller.appendAnnouncement('Press the up arrow to go to the previous series, or the left arrow to go to the previous point in this series');
        todo().controller.announce('On final point of final series.');
      },
      // User attempted to move up from first series
      first_series_reached: function() {
        todo().controller.appendAnnouncement('Press the down arrow to go to the next series, or the left or right arrow to explore this series');
        todo().controller.announce('On first series.');
      },
      // User attempted to move down from final series
      final_series_reached: function() {
        todo().controller.appendAnnouncement('Press the up arrow to go to the previous series, or the left or right arrow to explore this series');
        todo().controller.announce('On final series.');
      },
      // User attempted to move up or down while on the root nav point
      no_series: function() {
        todo().controller.announce('No series selected.');
      },
      chord_mode_no_up_down: function() {
        todo().controller.announce('Cannot switch series in chord mode.');
      },
    };
  }*/
  /*compareDatapoints(datapoint1: XYDatapointView, datapoint2: XYDatapointView) :
      {
        comparator: string,
        diff: number
      }
    {
      // TODO: localize this text output
      // TODO: move this to some statistical / NLP module
      const value1 = datapoint1.datapoint.y;
      const value2 = datapoint2.datapoint.y;
      const result = value1.compare(value2);
      let comparator = '';
      if (result.relationship === 'equal') {
        comparator = 'equal to';
      } else {
        comparator = (result.relationship === 'greater') ? 'greater than' : 'less than';
      }
      return {
        comparator,
        diff: result.diff!
      };
    }
  
    capitalize(string: string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }*/
}
class Jv extends I9 {
  get children() {
    return super.children;
  }
  get siblings() {
    return super.siblings;
  }
}
class bU extends pf {
  constructor(e) {
    super(e);
  }
  _addedToParent() {
    super._addedToParent();
  }
  // override to get more specific return type
  get datapoint() {
    return super.datapoint;
  }
  // get styleInfo() {
  //   const styles = super.styleInfo;
  //   styles['--datapoint-centroid'] = this.centroid;
  //   return styles;
  // }
  /*protected get _eventActions(): Actions<this> {
    return {
      datapoint_focused: function(focusInfo: FocusInfo) {
        todo().controller.announce(this.summary(focusInfo));
      },
      datapoint_selected: function(selectionInfo: XYSelectionInfo) {
        todo().controller.announce(this.chart.composeDatapointSelectionAnnouncement(selectionInfo));
      },
    };
  }*/
  //abstract computeLayout(): void;
  /*summary(focusInfo: FocusInfo) {
    if (focusInfo.visited.length > 1) {
      return `${this.datapoint.formatX('statusBar')}, all points`;
    } else {
      // Don't include the series name unless the previously-visited point
      // was in a different series
      const datapoint = this.datapoint.format('statusBar');
      /*if (!focusInfo.isSeriesChange) {
        return datapoint;
      } else if (todo().seriesSummaries[focusInfo.visited[0].series.name!]) {
        return `${todo().controller.todo.seriesSummaries[focusInfo.visited[0].series.name!]} ${datapoint}`;
      } else {
        return `${focusInfo.visited[0].series.name!}: ${datapoint}`;
      }*/
  //  }
  //}
  async onFocus(e = !1) {
    await super.onFocus(e);
  }
}
class vU extends Zv {
  settingDidChange(e, r, n) {
    ["axis.y.maxValue", "axis.y.minValue"].includes(e) && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  async storeDidChange(e, r) {
    await super.storeDidChange(e, r), e === "frontSeries" && this._raiseSeries(r);
  }
  get datapointViews() {
    return super.datapointViews;
  }
  _newSeriesView(e) {
    return new x9e(this, e);
  }
  _newDatapointView(e) {
    return new Xv(e);
  }
  _createDatapoints() {
    const e = [];
    for (const [r, n] of Wn(this.paraview.store.model.series[0].datapoints))
      e.push(Wr(r.facetBox("x"), this.paraview.store.getFormatType(`${this.parent.docView.type}Point`))), Yn(e.at(-1));
    for (const [r, n] of Wn(this.paraview.store.model.series)) {
      const i = this._newSeriesView(r.key);
      this._chartLandingView.append(i);
      for (const [s, o] of Wn(r)) {
        const a = this._newDatapointView(i);
        i.append(a);
      }
    }
    this._chartLandingView.sortChildren((r, n) => n.children[0].datapoint.facetValueNumericized(n.children[0].datapoint.depKey) - r.children[0].datapoint.facetValueNumericized(r.children[0].datapoint.depKey));
  }
  // protected _layoutDatapoints() {
  //   ChartPoint.computeSize(this);
  //   for (const datapointView of this.datapointViews) {
  //      datapointView.computeLayout();
  //   }
  // }
  seriesRef(e) {
    return this.paraview.ref(`series.${e}`);
  }
  _raiseSeries(e) {
    this.log.info("RAISING", e);
    const r = this.seriesRef(e).value;
    this.dataset.append(r);
  }
  getDatapointGroupBbox(e) {
    const n = this.paraview.store.model.allFacetValues("x").map(
      (s) => Wr(s, this.paraview.store.getFormatType("horizTick"))
    ).findIndex((s) => s === e);
    if (n === -1)
      throw new Error(`no such datapoint with label '${e}'`);
    return this.paraview.ref("dataset").value.children[n].getBBox();
  }
  getTickX(e) {
    return this.datapointViews[e].x;
  }
}
class x9e extends Jv {
}
class Xv extends bU {
  // static computeSize(chart: PointChart) {
  //   const axisDivisions = chart.paraview.store.model!.allFacetValues('x')!.length - 1;
  //   this.width = chart.parent.contentWidth/axisDivisions;
  // }
  constructor(e) {
    super(e), this._currentAnimationFrame = null, this._isAnimating = !1, this._hasAnimated = !1;
  }
  get width() {
    const e = this.paraview.store.model.series[0].length - 1;
    return this.chart.width / e;
  }
  get height() {
    return 0;
  }
  get _selectedMarkerX() {
    return this._x - this.width / 2;
  }
  get _selectedMarkerY() {
    return this._y - this.height / 2;
  }
  get hasAnimated() {
    return this._hasAnimated;
  }
  computeX() {
    return this.width * this.index;
  }
  computeY() {
    const e = this.chart.parent.docView.chartInfo.axisInfo.yLabelInfo, r = this.chart.height / e.range;
    return this.chart.height - (this.datapoint.facetValueNumericized("y") - e.min) * r;
  }
  computeLocation() {
    this._x = this.computeX(), this.paraview.store.settings.animation.isAnimationEnabled && this.paraview.store.settings.animation.expandPoints ? (this.paraview.store.settings.animation.animationOrigin === "initialValue" ? this._animStartState.y = this._parent.children[0].computeY() : this.paraview.store.settings.animation.animationOrigin === "baseline" ? this._animStartState.y = this.chart.height : this.paraview.store.settings.animation.animationOrigin === "top" ? this._animStartState.y = 0 : this._animStartState.y = this.paraview.store.settings.animation.animationOriginValue, this._animEndState.y = this.computeY(), this._y = this._animStartState.y) : (this._y = this.computeY(), this._animStartState.y = this._y, this._animEndState.y = this._y);
  }
  beginAnimStep(e, r) {
    this.paraview.store.settings.animation.symbolPopIn && r + 0.01 >= this.x / this.chart.width && !this._isAnimating && !this._hasAnimated && this.popInAnimation(), this._y = this._animStartState.y * (1 - e) + this._animEndState.y * e, super.beginAnimStep(e, r);
  }
  _animEnd() {
    this._currentAnimationFrame = null, this._isAnimating = !1, this._hasAnimated = !0;
  }
  popInAnimation() {
    this._isAnimating = !0;
    let e = -1;
    const r = new iE(0.2, 6, 1, 1, 10), n = (i) => {
      e === -1 && (e = i);
      const s = i - e, o = Math.max(1, this.paraview.store.settings.animation.popInAnimateRevealTimeMs), a = Math.min(s / o, 1), l = r.eval(a);
      this._baseSymbolScale = l * 0.25 + 0.75, this._contentUpdateSymbol(), s < o ? this._currentAnimationFrame = requestAnimationFrame(n) : this._animEnd();
    };
    this._currentAnimationFrame = requestAnimationFrame(n);
  }
}
class E9e extends Pr {
  constructor(e) {
    super(e.paraview), this.chart = e, this.x1 = 0, this.x2 = 0, this.y1 = 0, this.y2 = 0, this._generateEndpoints();
  }
  _generateEndpoints() {
    const e = [];
    for (const n of this.chart.datapointViews)
      e.push([n.x, n.y]);
    const r = _E(e);
    this.y1 = r.b, this.x2 = this.chart.parent.width, this.y2 = this.x2 * r.m + r.b, this.y2 < 0 && (this.x2 = -1 * r.b / r.m, this.y2 = 0), this.y2 > this.chart.parent.height && (this.x2 = (this.chart.parent.height - r.b) / r.m, this.y2 = this.chart.parent.height);
  }
  render() {
    return Tt`
    <line x1=${this.x1} x2=${this.x2} y1=${this.y1} y2=${this.y2} style="stroke:red;stroke-width:3"/>
    `;
  }
}
const S9e = 8, CR = 0.125;
function A9e(t) {
  let e = 1, r = [], n = !0;
  for (; !r.length; )
    for (let s = 0; s < t.length; s++) {
      let o;
      if (t[s].match(/\s/) && !n ? o = t[s].split(/\s+/).map((a) => a.slice(0, e)).join("") : o = t[s].slice(0, e), r.includes(o)) {
        r = [], e++, n = !1;
        break;
      }
      r[s] = o;
    }
  const i = {};
  return t.forEach((s, o) => i[s] = r[o]), i;
}
class i1 extends Zv {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this._totalLabels = [], this.log = qt("BarPlotView");
  }
  _addedToParent() {
    super._addedToParent(), this.paraview.store.settings.type.bar.isAbbrevSeries && (this._abbrevs = A9e(this.paraview.store.model.seriesKeys));
  }
  settingDidChange(e, r, n) {
    ["color.colorPalette", "color.colorVisionMode", "chart.isShowPopups"].includes(e) && (n === "pattern" || n !== "pattern" && r === "pattern" || this.paraview.store.settings.color.colorPalette === "pattern") && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  get abbrevs() {
    return this._abbrevs;
  }
  get numStacks() {
    return this._numStacks;
  }
  get stackWidth() {
    return this._stackWidth;
  }
  get clusterWidth() {
    return this._clusterWidth;
  }
  get availSpace() {
    return this._availSpace;
  }
  _newDatapointView(e, r) {
    return new k9e(e, r);
  }
  _beginDatapointLayout() {
    const e = Object.values(this._chartInfo.clusteredData).length;
    this._numStacks = e * this._chartInfo.stacksPerCluster;
    let r = (this._width - e * this._chartInfo.settings.clusterGap) / this._numStacks, n = 0;
    r >= S9e ? (this._stackWidth = (1 - CR) * r, n = CR * r) : this._stackWidth = r, this._availSpace = n * this._numStacks, super._beginDatapointLayout();
  }
  _createDatapoints() {
    const e = this._parent.docView.chartInfo, r = {};
    Object.entries(e.clusteredData).forEach(([n, i], s) => {
      for (const [o, a] of Object.entries(i.stacks))
        for (const [l, c] of Object.entries(a.bars))
          r[l] || (r[l] = new Jv(this, l), this._chartLandingView.append(r[l])), r[l].append(this._newDatapointView(r[l], a));
    }), this.paraview.store.type === "column" && this._chartLandingView.reverseChildren();
  }
  _completeDatapointLayout() {
    if (super._completeDatapointLayout(), this._chartInfo.settings.stacking === "standard" && this._chartInfo.settings.isDrawTotalLabels) {
      this._totalLabels.forEach((i) => {
        i.remove();
      }), this._totalLabels = [];
      const e = this._chartLandingView.children;
      let r = 0;
      this.parent.orientation === "east" && (r = -90);
      let n = 0;
      for (const [i, s] of Object.entries(this._chartInfo.clusteredData))
        for (const [o, a] of Object.entries(s.stacks)) {
          const l = Object.values(a.bars).at(-1), p = e.find((d) => d.seriesKey === l.series).children[n++], h = Object.values(a.bars).map((d) => e.find((m) => m.seriesKey === d.series).children[n - 1].datapoint).reduce((d, b) => d + b.facetValueAsNumber("y"), 0);
          this._totalLabels.push(new di(this.paraview, {
            // XXX hack
            text: h.toFixed(2),
            id: this._id + "-slb",
            classList: [`${this.paraview.store.type}-total-label`],
            role: "datapoint",
            // textAnchor,
            angle: r
          })), this.append(this._totalLabels.at(-1)), this._totalLabels.at(-1).centerX = p.centerX, this._totalLabels.at(-1).bottom = p.top;
        }
    }
  }
  noticePosted(e, r) {
    ["animRevealStep", "animRevealEnd"].includes(e) && this._completeDatapointLayout();
  }
  // protected _resizeToFitLabels() {
  //   const labels = Object.values(this.bars).flatMap(cluster =>
  //     Object.values(cluster.stacks)).map(stack => stack.label!);
  //   const minX = Math.min(...labels.map(label => label.left));
  //   if (minX < 0) {
  //     this._parent.logicalWidth += -minX;
  //     this.log.info('NEW WIDTH', this._width);
  //     this.datapointViews.forEach(dp => {
  //       dp.x += -minX;
  //     });
  //   }
  //   const maxX = Math.max(...labels.map(label => label.right));
  //   if (maxX > this._width) {
  //     const diff = maxX - this._width;
  //     this._parent.logicalWidth += diff;
  //     this.log.info('NEW WIDTH', this._width);
  //   }
  //   const minY = Math.min(...labels.map(label => label.top));
  //   if (minY < 0) {
  //     this._parent.logicalHeight += -minY;
  //     this.log.info('NEW HEIGHT', this._height);
  //     this.datapointViews.forEach(dp => {
  //       dp.y += -minY;
  //     });
  //     labels.forEach(label => {
  //       label.y += -minY;
  //     });
  //   }
  //   const maxY = Math.max(...labels.map(label => label.bottom));
  //   if (maxY > this._height) {
  //     const diff = maxY - this._height;
  //     this._parent.logicalHeight += diff;
  //     this.log.info('NEW HEIGHT', this._height);
  //   }
  //   //this._checkLabelSpacing();
  // }
  // protected _checkLabelSpacing() {
  //   const labels = Object.values(this.bars).flatMap(cluster =>
  //     Object.values(cluster.stacks)).map(stack => stack.label!);
  //   const gaps = labels.slice(1).map((label, i) => label.left - labels[i].right);
  //   const minGap = Math.min(...gaps);
  //   if (Math.round(minGap) < 0) {
  //     const diffBefore = labels.at(-1)!.x - labels[0].x;
  //     labels.slice(1).forEach((label, i) => {
  //       // NB: Even if the anchor is set to middle, the labels may be rotated, so
  //       // the anchor will no longer be in the middle of the bbox
  //       label.x = labels[i].right + 0 + label.anchorXOffset;
  //     });
  //     const diffAfter = labels.at(-1)!.x - labels[0].x;
  //     this._parent.logicalWidth += diffAfter - diffBefore;
  //   }
  // }
}
class k9e extends bU {
  constructor(e, r) {
    super(e), this._stack = r, this._recordLabel = null, this._dataLabel = null, this._isStyleEnabled = this.paraview.store.settings.type.bar.colorByDatapoint;
  }
  get classInfo() {
    return { bar: !0, ...super.classInfo };
  }
  get x() {
    return super.x;
  }
  set x(e) {
    this._dataLabel && (this._dataLabel.x += e - this._x), super.x = e;
  }
  get y() {
    return super.y;
  }
  set y(e) {
    this._dataLabel && (this._dataLabel.y += e - this._y), super.y = e;
  }
  get recordLabel() {
    return this._recordLabel;
  }
  set recordLabel(e) {
    this._recordLabel = e;
  }
  get dataLabel() {
    return this._dataLabel;
  }
  set dataLabel(e) {
    this._dataLabel = e;
  }
  get _selectedMarkerX() {
    return this._x;
  }
  get _selectedMarkerY() {
    return this._y;
  }
  // get styleInfo(): StyleInfo {
  //   const style = super.styleInfo;
  //   if (!this.paraview.store.isVisited(this.seriesKey, this.index)) {
  //     style.strokeWidth = 0;
  //   }
  //   return style;
  // }
  computeLocation() {
    const e = this.chart.chartInfo, r = this.chart.stackWidth;
    if (this._width = this.chart.stackWidth, this.paraview.store.settings.animation.isAnimationEnabled)
      this._height = 0, this._y = 0;
    else {
      const s = Object.keys(this._stack.bars).indexOf(this.series.key), o = this.chart.parent.logicalHeight / e.axisInfo.yLabelInfo.range, a = Object.values(this._stack.bars).slice(0, s).map((c) => c.value.value * o).reduce((c, p) => c + p, 0), l = this.chart.parent.logicalHeight - e.axisInfo.yLabelInfo.max * this.chart.parent.logicalHeight / e.axisInfo.yLabelInfo.range;
      this._height = Math.abs(this.datapoint.data.y.value * o), this.datapoint.data.y.value < 0 ? this._y = this.chart.height - a - l : this._y = this.chart.height - this.height - a - l;
    }
    const n = this.chart.availSpace / this.chart.numStacks, i = e.settings.clusterGap;
    this._x = i / 2 + n / 2 + r * (e.stacksPerCluster * this._stack.cluster.index + this._stack.index) + i * this._stack.cluster.index + n * (e.stacksPerCluster * this._stack.cluster.index + this._stack.index);
  }
  beginAnimStep(e, r) {
    const n = this.chart.chartInfo, i = Object.keys(this._stack.bars).indexOf(this.series.key), s = this.chart.parent.logicalHeight / n.axisInfo.yLabelInfo.range, o = Object.values(this._stack.bars).slice(0, i).map((l) => l.value.value * s).reduce((l, c) => l + c, 0), a = this.chart.parent.logicalHeight - n.axisInfo.yLabelInfo.max * this.chart.parent.logicalHeight / n.axisInfo.yLabelInfo.range;
    this._height = Math.abs(this.datapoint.data.y.value * s * e), this.datapoint.data.y.value < 0 ? this._y = this.chart.height - o * e - a : this._y = this.chart.height - this.height - o * e - a, super.beginAnimStep(e, r);
  }
  completeLayout() {
    super.completeLayout();
    const e = this.chart.chartInfo;
    let r = "middle", n = 0;
    this.chart.parent.orientation === "east" && (r = "start", n = -90), e.settings.isDrawRecordLabels && (this._recordLabel = new di(this.paraview, {
      // @ts-ignore
      text: Wr(this.datapoint.data.x, this.paraview.store.getFormatType("pieSliceValue")),
      id: this._id + "-rlb",
      classList: [`${this.paraview.store.type}-label`],
      role: "datapoint",
      textAnchor: r,
      angle: n
    }), this.append(this._recordLabel), this._recordLabel.styleInfo = {
      stroke: "none",
      fill: this.paraview.store.colors.contrastValueAt(this._isStyleEnabled ? this.index : this.parent.index)
    }, this._recordLabel.centerX = this.centerX, this._recordLabel.y = this.chart.height - this._recordLabel.height - e.settings.stackLabelGap), e.settings.isDrawDataLabels && (this._dataLabel = new di(this.paraview, {
      // @ts-ignore
      text: Wr(this.datapoint.data.y, this.paraview.store.getFormatType("pieSliceValue")),
      id: this._id + "-blb",
      classList: [`${this.paraview.store.type}-label`],
      role: "datapoint",
      textAnchor: r,
      angle: n
    }), this.append(this._dataLabel), this._dataLabel.styleInfo = {
      stroke: "none",
      fill: this.paraview.store.colors.contrastValueAt(this._isStyleEnabled ? this.index : this.parent.index)
    }, this._dataLabel.centerX = this.centerX, e.settings.dataLabelPosition === "center" ? this._dataLabel.centerY = this.centerY : e.settings.dataLabelPosition === "end" ? this._dataLabel.top = this.top : e.settings.dataLabelPosition === "base" ? this._dataLabel.bottom = this.bottom : this._dataLabel.bottom = this.top);
  }
  _createSymbol() {
  }
  // protected get _d() {
  //   return fixed`
  //     M${this._x},${this._y + this.chart.settings.barGap}
  //     v${this._height - this.chart.settings.barGap*2}
  //     h${BarStack.width}
  //     v${-(this._height - this.chart.settings.barGap*2)}
  //     Z`;
  // }
  _createShapes() {
    const e = this.paraview.store.colors.palette.isPattern;
    this._shapes.forEach((r) => {
      r.remove();
    }), this._shapes = [], this._shapes.push(new sn(this.paraview, {
      x: this._x,
      y: this._y,
      width: this._width,
      height: this._height,
      isPattern: !!e,
      pointerEnter: (r) => {
        this.paraview.store.settings.chart.isShowPopups && this.addPopup();
      },
      pointerLeave: (r) => {
        this.paraview.store.settings.chart.isShowPopups && this.removePopup(this.id);
      }
    })), super._createShapes();
  }
  get selectedMarker() {
    return new sn(this.paraview, {
      width: this._width + 4,
      height: this._height + 4,
      x: this._x - 2,
      y: this._y - 2,
      fill: "none",
      stroke: "black",
      strokeWidth: 2,
      isClip: this.shouldClip
    });
  }
  addPopup(e) {
    let r = `${this.index + 1}/${this.series.datapoints.length}: ${this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar")}`;
    this.paraview.store.model.multi && (r = `${this.series.getLabel()} ${r}`);
    let n = new ls(
      this.paraview,
      {
        text: e ?? r,
        x: this.x + this.width / 2,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this],
        rotationExempt: this.paraview.store.type != "bar",
        angle: this.paraview.store.type == "bar" ? -90 : 0
      },
      {}
    );
    this.paraview.store.popups.push(n);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
}
class tx extends vU {
  get datapointViews() {
    return super.datapointViews;
  }
  get settings() {
    return super.settings;
  }
  settingDidChange(e, r, n) {
    ["chart.hasDirectLabels"].includes(e) && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  updateSeriesStyle(e) {
    super.updateSeriesStyle(e), e.strokeWidth = this.effectiveLineWidth;
  }
  get effectiveLineWidth() {
    return this.paraview.store.settings.ui.isLowVisionModeEnabled ? this.paraview.store.settings.type.line.lowVisionLineWidth : this.paraview.store.settings.type.line.lineWidth;
  }
  get effectiveVisitedScale() {
    return this.paraview.store.settings.ui.isLowVisionModeEnabled ? 1 : this.paraview.store.settings.type.line.lineHighlightScale;
  }
  get visitedStrokeWidth() {
    return this.effectiveLineWidth * this.effectiveVisitedScale;
  }
  _newDatapointView(e) {
    return new _9e(e);
  }
}
class _9e extends Xv {
  // get height() {
  //   // apparently this can get called before the shape is created
  //   return bboxOfBboxes(...this._shapes.map(shape => shape.bbox)).height ?? 0;
  // }
  // get left() {
  //   return this._shape!.left;
  // }
  // get right() {
  //   return this._shape!.right;
  // }
  // get top() {
  //   return this._shape!.top;
  // }
  // get bottom() {
  //   return this._shape!.bottom;
  // }
  get outerBbox() {
    const e = this._shapes.map((r) => r.outerBbox);
    return this._symbol ? K4(...e, this._symbol.outerBbox) : K4(...e);
  }
  completeLayout() {
    this.index && this._computePrev(), this.index < this.chart.paraview.store.model.series[0].length - 1 && this._computeNext(), this._computeCentroid(), super.completeLayout();
  }
  _createSymbol() {
    var n;
    let r = this.seriesProps.symbol;
    (n = this._symbol) == null || n.remove(), this._symbol = Fa.fromType(this.paraview, r), this.append(this._symbol);
  }
  _computePrev() {
    this._prevMidX = -this.width / 2, this._prevMidY = (this._prev.y - this.y) / 2;
  }
  _computeNext() {
    this._nextMidX = this.width / 2, this._nextMidY = (this._next.y - this.y) / 2;
  }
  _computeCentroid() {
    var s, o;
    const e = ((s = this._symbol) == null ? void 0 : s.width) ?? 0, r = ((o = this._symbol) == null ? void 0 : o.height) ?? 0;
    let n = "50%";
    this._prevMidX ? this._nextMidX || (n = `calc(100% - ${e / 2}px)`) : n = `${e / 2}px`;
    let i = "50%";
    if (!this._prevMidY && this._nextMidY)
      i = this._y > this._nextMidY ? `calc(100% - ${r / 2}px)` : `${r / 2}px`;
    else if (!this._nextMidY && this._prevMidY)
      i = this._y > this._prevMidY ? `calc(100% - ${r / 2}px)` : `${r / 2}px`;
    else if (this._nextMidY && this._prevMidY) {
      const a = this._y - r / 2, l = this._y + r / 2;
      l > this._nextMidY && l > this._prevMidY ? i = `calc(100% - ${r / 2}px)` : a < this._nextMidY && a < this._prevMidY ? i = `${r / 2}px` : i = `${this._y - Math.min(this._prevMidY, this._nextMidY)}px`;
    }
    this.centroid = `${n} ${i}`;
  }
  get _points() {
    return this._prevMidY !== void 0 && this._nextMidY !== void 0 ? [
      new Ye(this._prevMidX, this._prevMidY),
      new Ye(),
      new Ye(this._nextMidX, this._nextMidY)
    ] : this._prevMidY === void 0 && this._nextMidY !== void 0 ? [
      new Ye(),
      new Ye(this._nextMidX, this._nextMidY)
    ] : this._prevMidY !== void 0 && this._nextMidY === void 0 ? [
      new Ye(this._prevMidX, this._prevMidY),
      new Ye()
    ] : [
      new Ye()
    ];
  }
  get classInfo() {
    return {
      "data-line": !0,
      ...super.classInfo
    };
  }
  _shapeStyleInfo(e) {
    if (this.paraview.documentView.chartInfo.navMap.cursor.isNodeType("sequence")) {
      const r = this.paraview.documentView.chartInfo.navMap.cursor;
      if (this.index === r.options.start && this.index && !e || this.index === r.options.end - 1 && e)
        return {
          fill: this._parent.styleInfo.fill,
          stroke: this._parent.styleInfo.stroke,
          strokeWidth: this._parent.styleInfo.strokeWidth
        };
    }
    return super._shapeStyleInfo(e);
  }
  _createShapes() {
    this._shapes.forEach((i) => {
      i.remove();
    }), this._shapes = [];
    const e = this._points;
    let r = 0, n = 0;
    if (this.chart.animateRevealComplete) {
      let i = this.withCousins.map((s, o) => [s, o]).toSorted((s, o) => s[0].y - o[0].y);
      if (i.length === 1)
        r = 0, n = this.chart.height;
      else if (i[0][1] === this.parent.index)
        r = 0, n = (i[1][0].y - this.y) / 2 + this.y;
      else if (i[i.length - 1][1] === this.parent.index)
        r = (this.y - i[i.length - 2][0].y) / 2 + i[i.length - 2][0].y, n = this.chart.height - ((this.y - i[i.length - 2][0].y) / 2 + i[i.length - 2][0].y);
      else {
        let s = i.findIndex((o) => o[1] === this.parent.index);
        r = (this.y - i[s - 1][0].y) / 2 + i[s - 1][0].y, n = (i[s + 1][0].y - this.y) / 2 + this.y - ((this.y - i[s - 1][0].y) / 2 + i[s - 1][0].y);
      }
    }
    if (e.length === 3) {
      const i = [e.slice(0, -1), e.slice(1)];
      if (this._shapes.push(
        new jo(this.paraview, {
          x: this._x,
          y: this._y,
          points: i[0],
          isClip: !0
        }),
        new jo(this.paraview, {
          x: this._x,
          y: this._y,
          points: i[1],
          isClip: !0
        })
      ), this._shapes[0].classInfo = { "leg-left": !0 }, this._shapes[1].classInfo = { "leg-right": !0 }, this.chart.animateRevealComplete) {
        let s = new sn(this.paraview, {
          x: this._x + i[0][0].x,
          y: r,
          width: i[1][1].x - i[0][0].x,
          height: n,
          stroke: "white",
          fill: "white",
          pointerEnter: (o) => {
            this.paraview.store.settings.chart.isShowPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.addPopup();
          },
          pointerLeave: (o) => {
            this.paraview.store.settings.chart.isShowPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.removePopup(this.id);
          }
        });
        s.classInfo = { invis: !0 }, this.append(s);
      }
    } else if (e.length === 2 && (this._shapes.push(
      new jo(this.paraview, {
        x: this._x,
        y: this._y,
        points: e,
        isClip: !0
      })
    ), this._shapes[0].classInfo = this._prevMidY !== void 0 ? { "leg-left": !0 } : { "leg-right": !0 }, this.chart.animateRevealComplete)) {
      let i = new sn(this.paraview, {
        x: e[0].x == 0 ? this._x : this._x + e[0].x,
        y: r,
        width: e[0].x == 0 ? e[1].x : this.x,
        height: n,
        stroke: "white",
        fill: "white",
        pointerEnter: (s) => {
          this.paraview.store.settings.chart.isShowPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.addPopup();
        },
        pointerLeave: (s) => {
          this.paraview.store.settings.chart.isShowPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.removePopup(this.id);
        }
      });
      i.classInfo = { invis: !0 }, this.append(i);
    }
    this._shapes.forEach((i) => {
      i.isClip = this.shouldClip;
    }), super._createShapes();
  }
  addPopup(e) {
    let r = `${this.index + 1}/${this.series.datapoints.length}: ${this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar")}`;
    this.paraview.store.model.multi && (r = `${this.series.getLabel()} ${r}`);
    let n = new ls(
      this.paraview,
      {
        text: e ?? r,
        x: this.x,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {}
    );
    this.paraview.store.popups.push(n);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1);
  }
}
class C9e extends yU {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this._arcType = "circle", this._startAngleOffset = -0.25, this._arc = 1, this._radiusDivisor = 2.3, this._centerLabel = null;
  }
  _addedToParent() {
    super._addedToParent(), this._resetRadius(), this._arcType === "semicircle" && (this._arc = 0.5, this._startAngleOffset = -0.25);
  }
  // get radius() {
  //   return this._radius;
  // }
  get settings() {
    return super.settings;
  }
  get cx() {
    return this._cx;
  }
  get cy() {
    return this._cy;
  }
  get arcType() {
    return this._arcType;
  }
  get startAngleOffset() {
    return this._startAngleOffset;
  }
  get radius() {
    return this._radius;
  }
  get datapointViews() {
    return super.datapointViews;
  }
  _completeDatapointLayout() {
    super._completeDatapointLayout(), this._createLabels();
  }
  _animStep(e, r) {
    super._animStep(e, r), this._createLabels();
  }
  init() {
    super.init(), this._resizeToFitLabels(), this.settings.centerLabel === "title" && (this.paraview.store.updateSettings((e) => {
      e.chart.title.isDrawTitle = !1;
    }), this._centerLabel = new di(this.paraview, {
      text: this.paraview.store.title,
      centerX: this._cx,
      centerY: this._cy,
      textAnchor: "middle",
      wrapWidth: 2 * (this.radius - this.settings.annularThickness * this.radius) - this.settings.centerLabelPadding * 2,
      id: "chart-title",
      classList: ["chart-title"]
    }), this.append(this._centerLabel));
  }
  settingDidChange(e, r, n) {
    ["color.colorPalette", "color.colorVisionMode"].includes(e) && (n === "pattern" || n !== "pattern" && r === "pattern" || this.paraview.store.settings.color.colorPalette === "pattern") && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), ["explode", "orientationAngleOffset", "insideLabels.contents", "outsideLabels.contents"].map((s) => `type.${this.paraview.store.type}.${s}`).includes(e) && (this._resetRadius(), this._chartLandingView.clearChildren(), this._layoutDatapoints(), this._resizeToFitLabels(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  _resetRadius() {
    this._radius = Math.min(this._height, this._width) / 2, this._cx = this._width / 2, this._cy = this._height / 2;
  }
  _resizeToFitLabels() {
    for (; ; ) {
      const e = this.datapointViews.map((a) => a.outsideLabel).filter((a) => a);
      if (!e.length) return;
      let r = 1;
      const n = Math.min(...e.map((a) => a.paddedLeft));
      if (n < 0) {
        const a = this.datapointViews.find((h) => {
          var d;
          return ((d = h.outsideLabel) == null ? void 0 : d.paddedLeft) === n;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.x), p = Math.max((c + n) / c, 0.5);
        p < r && (r = p);
      }
      const i = Math.max(...e.map((a) => a.paddedRight));
      if (i > this._width) {
        const a = this.datapointViews.find((h) => {
          var d;
          return ((d = h.outsideLabel) == null ? void 0 : d.paddedRight) === i;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.x), p = Math.max((c - (i - this._width)) / c, 0.5);
        p < r && (r = p);
      }
      const s = Math.min(...e.map((a) => a.paddedTop));
      if (s < 0) {
        const a = this.datapointViews.find((h) => {
          var d;
          return ((d = h.outsideLabel) == null ? void 0 : d.paddedTop) === s;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.y), p = Math.max((c + s) / c, 0.5);
        p < r && (r = p);
      }
      const o = Math.max(...e.map((a) => a.paddedBottom));
      if (o > this._height) {
        const a = this.datapointViews.find((h) => {
          var d;
          return ((d = h.outsideLabel) == null ? void 0 : d.paddedBottom) === o;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.y), p = Math.max((c - (o - this._height)) / c, 0.5);
        p < r && (r = p);
      }
      if (Math.round(r * 100) < 100)
        this._radius *= r, this._chartLandingView.clearChildren(), this._layoutDatapoints();
      else
        break;
    }
  }
  _createDatapoints() {
    const e = this.paraview.store.model.series[0].datapoints.map(
      (o) => Wr(o.facetBox("x"), this.paraview.store.getFormatType("pieSliceLabel"))
    ), r = this.paraview.store.model.series[0].datapoints.map((o) => o.facetValueNumericized("y")), n = r.reduce((o, a) => o + a, 0), i = new I9(this, this.paraview.store.model.seriesKeys[0], !1);
    this._chartLandingView.append(i);
    let s = 0;
    for (const [o, a] of Wn(e)) {
      const l = r.at(a), c = this._arc * l / n, p = this._createSlice(i, {
        value: l,
        category: o,
        seriesIdx: a,
        percentage: c,
        accum: s,
        numDatapoints: e.length
      });
      i.append(p), s += c;
    }
  }
  _createLabels() {
    const e = this.paraview.store.model.series[0].datapoints.map(
      (n) => Wr(n.facetBox("x"), this.paraview.store.getFormatType("pieSliceLabel"))
    );
    this.paraview.store.model.series[0].datapoints.map(
      (n) => Wr(n.facetBox("y"), this.paraview.store.getFormatType("pieSliceLabel"))
    );
    for (const [n, i] of Wn(e)) {
      const s = this._chartLandingView.children[0].children[i];
      this.settings.outsideLabels.contents && s.createOutsidelabel(), this.settings.insideLabels.contents && s.createInsideLabel();
    }
    this.datapointViews.map((n) => n.outsideLabel).filter((n) => n).length && this._resolveOutsideLabelCollisions();
  }
  _resolveOutsideLabelCollisions() {
    const e = this.datapointViews.filter((r) => r.outsideLabel);
    e.sort((r, n) => n.outsideLabel.y - r.outsideLabel.y), e.slice(1).forEach((r, n) => {
      if (r.outsideLabel.intersects(e[n].outsideLabel)) {
        const i = r.outsideLabel.y;
        r.outsideLabel.bottom = e[n].outsideLabel.top - this.settings.outsideLabels.vertGap;
        const s = r.outsideLabel.y - i;
        r.adjustLeader(s);
      }
    });
  }
  focusRingShape() {
    const r = this._parent.docView.chartInfo.navMap.cursor;
    return r.isNodeType("datapoint") ? this.datapointView(r.options.seriesKey, r.options.index).focusRingShape() : null;
  }
}
class I9e extends pf {
  constructor(e, r) {
    super(e), this._params = r, this._outsideLabel = null, this._insideLabel = null, this._leader = null, this._focusRingShape = null, this._centralAngle = 0, this._isStyleEnabled = !0;
  }
  get percentage() {
    return this._params.percentage;
  }
  get outsideLabel() {
    return this._outsideLabel;
  }
  get insideLabel() {
    return this._insideLabel;
  }
  get shapes() {
    return this._shapes;
  }
  get role() {
    return "graphics-symbol";
  }
  get roleDescription() {
    return "datapoint";
  }
  get classInfo() {
    return {
      ...super.classInfo,
      "pastry-slice": !0
      // bad workaround for the problem that, when a visited datapoint is recreated,
      // the store data cursor now has a ref to the old instance
      // visited: this.paraview.store.isVisited(this.seriesKey, this.index),
      // selected: this.paraview.store.isSelected(this.seriesKey, this.index)
    };
  }
  get styleInfo() {
    const e = super.styleInfo;
    return delete e.strokeWidth, delete e.stroke, e;
  }
  get x() {
    return super.x;
  }
  set x(e) {
    this._outsideLabel && (this._outsideLabel.x += e - this._x), this._insideLabel && (this._insideLabel.x += e - this._x), this._leader && (this._leader.x += e - this._x), super.x = e;
  }
  get y() {
    return super.y;
  }
  set y(e) {
    this._outsideLabel && (this._outsideLabel.y += e - this._y), this._insideLabel && (this._insideLabel.y += e - this._y), this._leader && (this._leader.y += e - this._y), super.y = e;
  }
  _createSymbol() {
  }
  get isPositionRight() {
    return this.shapes[0].arcCenter.x > this.chart.cx;
  }
  get isPositionBottom() {
    return this.shapes[0].arcCenter.y > this.chart.cy;
  }
  _createShapes() {
    const e = this._shapes[0].clone(), r = this.paraview.store.settings.ui.focusRingGap, n = e.centralAngle;
    if (e.centralAngle += 2 * r * 360 / (2 * Math.PI * e.r), e.orientationAngle -= (e.centralAngle - n) / 2, e.annularThickness < 1) {
      e.r += r;
      const i = e.annularThickness * e.r;
      e.annularThickness = (i + 2 * r) / (e.r + r);
    } else
      e.scale = (e.r + r) / e.r;
    this._focusRingShape = e, super._createShapes();
  }
  _labelContents(e) {
    return e.split(/:/).map((i) => {
      let s = !1;
      i[0] === "(" && i.at(-1) === ")" && (s = !0, i = i.slice(1, -1));
      let o = "";
      if (i === "series")
        o = this.seriesKey;
      else if (i === "category")
        o = this._params.category;
      else if (i === "percentage")
        o = `${Math.round(this._params.percentage * 100)}%`;
      else if (i === "value")
        o = `${this._params.value}`;
      else
        throw new Error(`invalid radial label content field '${i}'`);
      return s ? `(${o})` : o;
    }).join(" ");
  }
  createOutsidelabel(e = "") {
    var c, p;
    const r = this.shapes[0], n = r.orientationVector.multiplyScalar(
      this.chart.settings.outsideLabels.arcGap
    );
    let i = "end", s = "topLeft", o = 0, a = 0;
    const l = r.arcCenter.add(n);
    this.isPositionRight ? (l.x += this.chart.settings.outsideLabels.horizShift, o = this.chart.settings.outsideLabels.horizPadding, i = "start") : (l.x -= this.chart.settings.outsideLabels.horizShift, a = this.chart.settings.outsideLabels.horizPadding), this.isPositionBottom ? s = i === "start" ? "topLeft" : "topRight" : s = i === "start" ? "bottomLeft" : "bottomRight", (c = this._outsideLabel) == null || c.remove(), this._outsideLabel = new di(this.paraview, {
      text: this._labelContents(e || this.chart.settings.outsideLabels.contents),
      id: this.id + "-rlb",
      classList: ["pastry-outside-label"],
      role: "datapoint",
      [s]: l,
      textAnchor: i
    }), this._outsideLabel.padding = { left: o, right: a }, (p = this._leader) == null || p.remove(), this._leader = this._createOutsideLabelLeader(), this.append(this._leader), this.append(this._outsideLabel);
  }
  _createOutsideLabelLeader() {
    const e = new Ye(
      this.isPositionRight ? this._outsideLabel.paddedLeft : this._outsideLabel.paddedRight,
      this.chart.settings.outsideLabels.leaderStyle === "direct" ? this._outsideLabel.centerY : this._outsideLabel.bottom
    ).addY(
      this.chart.settings.outsideLabels.leaderStyle === "underline" ? this.chart.settings.outsideLabels.underlineGap : 0
    ), r = this.chart.settings.outsideLabels.leaderStyle === "direct" ? this.chart.settings.outsideLabels.horizPadding : this._outsideLabel.paddedWidth, n = new jo(this.paraview, {
      points: [this.shapes[0].arcCenter, e, e.x > this._outsideLabel.centerX ? e.subtractX(r) : e.addX(r)],
      stroke: this.paraview.store.colors.colorValueAt(this.color)
    });
    return n.classInfo = { "pastry-outside-label-leader": !0 }, n;
  }
  adjustLeader(e) {
    this._leader.points = [
      this._leader.points[0],
      this._leader.points[1].addY(e),
      this._leader.points[2].addY(e)
    ];
  }
  createInsideLabel() {
    var n;
    const e = this.shapes[0];
    let r = "topLeft";
    if (this.isPositionBottom ? r = this.isPositionRight ? "topLeft" : "topRight" : r = this.isPositionRight ? "bottomLeft" : "bottomRight", (n = this._insideLabel) == null || n.remove(), this._insideLabel = new di(this.paraview, {
      text: this._labelContents(this.chart.settings.insideLabels.contents),
      id: this.id + "-ilb",
      classList: ["pastry-inside-label"],
      role: "datapoint",
      [l8e(r)]: e.loc.add(
        e.orientationVector.multiplyScalar(
          this.chart.radius * this.chart.settings.insideLabels.position
        )
      )
    }), Object.values(this._insideLabel.textCorners).every((i) => e.containsPoint(i)))
      this._insideLabel.styleInfo = {
        fill: this.paraview.store.colors.contrastValueAt(this.color)
      }, this.append(this._insideLabel);
    else {
      if (this._outsideLabel) {
        this._outsideLabel.text += `
${this._insideLabel.text}`;
        const i = this._leader;
        this._leader = this._createOutsideLabelLeader(), this.replaceChild(i, this._leader);
      } else
        this.createOutsidelabel(
          this.chart.settings.insideLabels.contents + (this.chart.settings.outsideLabels.contents ? ":" + this.chart.settings.outsideLabels.contents : "")
        );
      this._insideLabel = null;
    }
  }
  focusRingShape() {
    return this._focusRingShape;
  }
}
class IR extends C9e {
  _createSlice(e, r) {
    return new P9e(e, r);
  }
}
class P9e extends I9e {
  constructor(e, r) {
    super(e, r), this.log = qt("PieSlice"), this._x = this.chart.cx, this._y = this.chart.cy;
  }
  get width() {
    return 0;
  }
  get height() {
    return 0;
  }
  computeLocation() {
    this.paraview.store.settings.animation.isAnimationEnabled ? this._centralAngle = this.chart.animateRevealComplete ? this._params.percentage * 360 : 0 : this._centralAngle = this._params.percentage * 360;
  }
  beginAnimStep(e, r) {
    this._centralAngle = this._params.percentage * 360 * e, super.beginAnimStep(e, r);
  }
  _createShapes() {
    const e = this.paraview.store.colors.palette.isPattern;
    this._shapes.forEach((i) => {
      i.remove();
    }), this._shapes = [];
    const r = new x2(this.paraview, {
      x: this._x,
      y: this._y,
      r: this.chart.radius,
      centralAngle: this._centralAngle,
      orientationAngle: this._params.accum * 360,
      orientationAngleOffset: this.chart.settings.orientationAngleOffset,
      annularThickness: this.chart.settings.annularThickness,
      isPattern: !!e,
      pointerEnter: (i) => {
        this.paraview.store.settings.chart.isShowPopups && this.addPopup();
      },
      pointerLeave: (i) => {
        this.paraview.store.settings.chart.isShowPopups && this.removePopup(this.id);
      }
    });
    this._shapes.push(r), this.chart.settings.explode.split(":").map((i) => parseInt(i)).includes(this.index) && (r.loc = r.loc.add(r.orientationVector.multiplyScalar(this.chart.settings.explodeDistance))), super._createShapes();
  }
  // protected _computeLabelOptions() {
  //   const r = this.chart.radius.outer;
  //   const sector = (this._children[0] as Sector);
  //   const centerAngle = sector.options.orientationAngle + sector.options.centralAngle/2;
  //   let className = 'radial_label';
  //   // if (centerAngle >= 0.05 && centerAngle <= 0.45) {
  //   //   className = 'radial_label_right';
  //   // } else if (centerAngle >= 0.55 && centerAngle <= 0.95) {
  //   //   className = 'radial_label_left';
  //   // }
  //   // this.log.info('LABEL OPTS', r, centerAngle, this.chart.cx, this.chart.cy, this._radians);
  //   return {
  //     x: this.chart.cx + r*Math.cos(centerAngle*Math.PI/180),
  //     y: this.chart.cy + r*Math.sin(centerAngle*Math.PI/180),
  //     className
  //   };
  // }
  get selectedMarker() {
    return new x2(this.paraview, {
      x: this._x,
      y: this._y,
      r: this.chart.radius,
      centralAngle: this._params.percentage * 360,
      orientationAngle: this._params.accum * 360,
      orientationAngleOffset: this.chart.settings.orientationAngleOffset,
      annularThickness: this.chart.settings.annularThickness,
      fill: "none",
      stroke: "black",
      strokeWidth: 2
    });
  }
  addPopup(e) {
    if (this.paraview.store.popups.some((a) => a.id == this.id))
      return;
    let r = 2 * Math.PI - (this._params.accum * 2 * Math.PI + this._params.percentage * Math.PI - this.chart.settings.orientationAngleOffset * 2 * Math.PI / 360), n = this.x + this.chart.radius * (1 - this.chart.settings.annularThickness / 2) * Math.cos(r), i = this.y - this.chart.radius * (1 - this.chart.settings.annularThickness / 2) * Math.sin(r), s = `${this.index + 1}/${this.series.datapoints.length}: ${this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar")}`;
    this.paraview.store.model.multi && (s = `${this.series.getLabel()} ${s}`);
    let o = new ls(
      this.paraview,
      {
        text: e ?? s,
        x: n,
        y: i,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {
        shape: "boxWithArrow",
        fill: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(this.color), 6) : this.paraview.store.colors.colorValueAt(this.color),
        stroke: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(this.color) : "black"
      }
    );
    this.paraview.store.popups.push(o);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
}
class R9e extends vU {
  constructor() {
    super(...arguments), this._clusterShellView = null;
  }
  get settings() {
    return super.settings;
  }
  get chartInfo() {
    return this._chartInfo;
  }
  get datapointViews() {
    return super.datapointViews;
  }
  settingDidChange(e, r, n) {
    ["type.scatter.isShowOutliers"].includes(e) && this.updateOutliers(), super.settingDidChange(e, r, n);
  }
  _newDatapointView(e) {
    return new O9e(e);
  }
  _createDatapoints() {
    for (const [r, n] of Wn(this.paraview.store.model.series)) {
      const i = this._newSeriesView(r.key);
      this._chartLandingView.append(i);
      for (const [s, o] of Wn(r)) {
        const a = this._newDatapointView(i);
        i.append(a);
      }
    }
    const e = this.datapointViews;
    for (const r of this._chartInfo.clustering) {
      for (const n of r.dataPointIDs)
        e[n].clusterID = r.id;
      for (const n of r.outlierIDs)
        e[n].clusterID = r.id, e[n].isOutlier = !0;
    }
    this.datapointViewsStatic = super.datapointViews;
  }
  _beginDatapointLayout() {
    super._beginDatapointLayout();
    for (let r of this.children)
      r instanceof PR && r.remove();
    let e = new PR(this);
    this.append(e);
  }
  updateOutliers() {
    for (let e of this.datapointViews)
      e.isOutlier && e.completeLayout();
  }
  content(...e) {
    var n;
    const r = this.parent.docView.chartInfo;
    return r.clustering && ((n = this._clusterShellView) == null || n.remove(), r.currentCluster !== -1 && (this._clusterShellView = new T9e(this, r.currentCluster), this.append(this._clusterShellView))), super.content(...e);
  }
}
class O9e extends Xv {
  constructor() {
    super(...arguments), this.isOutlier = !1;
  }
  computeX() {
    const e = this.chart.chartInfo.axisInfo, r = (this.datapoint.facetValueNumericized("x") - e.xLabelInfo.min) / e.xLabelInfo.range;
    return this.chart.parent.width * r;
  }
  get width() {
    var e;
    return (e = this._symbol) != null && e.width ? 2 * 1.5 * this._symbol.width : 36;
  }
  _createShape() {
  }
  get _symbolColor() {
    return this.symbolColor === void 0 && (this.symbolColor = this.seriesProps.color), this.paraview.store.isVisited(this.seriesKey, this.index) ? -1 : this.symbolColor;
  }
  _createSymbol() {
    const e = this.seriesProps;
    let r = e.symbol, n = e.color;
    const i = new rU().types;
    this.chart.chartInfo.clustering && (this.clusterID !== void 0 ? (n = Number(this.clusterID), r = i[n % i.length]) : r = i[8], this.paraview.store.settings.type.scatter.isShowOutliers && this.isOutlier && (n = 0, r = i[8])), this._symbol = Fa.fromType(this.paraview, r, {
      strokeWidth: this.paraview.store.settings.chart.symbolStrokeWidth,
      lighten: !0,
      pointerEnter: (s) => {
        this.paraview.store.settings.chart.isShowPopups && this.addPopup();
      },
      pointerLeave: (s) => {
        this.paraview.store.settings.chart.isShowPopups && this.removePopup(this.id);
      }
    }), this._symbol.role = "datapoint", this._symbol.id = `${this._id}-sym`, this.symbolColor = n, this._children = this.children.filter((s) => !(s instanceof Fa)), this.append(this._symbol);
  }
  get classInfo() {
    return {
      [`cluster-${this.clusterID}`]: this.clusterID !== void 0,
      ...super.classInfo
    };
  }
  get color() {
    return this.chart.chartInfo.clustering ? this.clusterID : super.color;
  }
  addPopup() {
    let e = new ls(
      this.paraview,
      {
        text: this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar"),
        x: this.x,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {
        shape: "boxWithArrow",
        fill: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(this.color), 6) : this.paraview.store.colors.colorValueAt(this.color),
        stroke: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(this.color) : "black"
      }
    );
    this.paraview.store.popups.push(e);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
}
class PR extends E9e {
  render() {
    return this.paraview.store.settings.type.scatter.isDrawTrendLine ? Tt`
    <line x1=${this.x1} x2=${this.x2} y1=${this.y1} y2=${this.y2} style="stroke:red;stroke-width:3"/>
    ` : Tt``;
  }
}
class T9e extends Pr {
  constructor(e, r, n) {
    super(e.paraview), this.chart = e, this.clusterID = r, this.selectedPoints = n, this._points = [], this.generatePoints();
  }
  _createId(...e) {
    return "";
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  generatePoints() {
    if (this.selectedPoints !== void 0) {
      let e = [];
      for (let r of this.selectedPoints)
        e.push([r.x, r.y]);
      this._points = e;
    } else if (this.clusterID !== void 0) {
      const e = this.chart.datapointViewsStatic, i = this.chart.parent.docView.chartInfo.clustering[this.clusterID].hullIDs, s = [];
      for (const o of i)
        s.push([e[o].x, e[o].y]);
      this._points = s;
    } else
      this._points = [];
  }
  get points() {
    return this._points;
  }
  get pointsString() {
    let e = "";
    for (const r of this.points)
      e = e.concat(nt`${r[0]},${r[1]} `);
    return e;
  }
  get centroid() {
    const e = [0, 0];
    for (const r of this.points)
      e[0] += r[0] / this.points.length, e[1] += r[1] / this.points.length;
    return e;
  }
  get color() {
    return this.clusterID !== void 0 ? this.clusterID : 0;
  }
  render() {
    let e = new eU(this.paraview.store);
    return Tt`<g>
      <polygon points=${this.pointsString} style="stroke:black; fill:none; stroke-width:2"/>
      <circle
        cx=${nt`${this.centroid[0]}`}
        cy=${nt`${this.centroid[1]}`} r="8"
        style=stroke:black;fill:${e.colorValueAt(this.color)}
      />
    </g>`;
  }
}
class L9e extends Zv {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this.log = qt("HeatMapPlotView"), this._settings = this.paraview.store.settings.type.heatmap;
  }
  settingDidChange(e, r, n) {
    e === "type.heatmap.resolution" && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  get settings() {
    return this._settings;
  }
  get chartInfo() {
    return this._chartInfo;
  }
  _newDatapointView(e) {
    return new RR(this, e);
  }
  _createDatapoints() {
    this.log.info("CREATING DATAPOINTS");
    const e = [];
    for (const [r, n] of Wn(this.paraview.store.model.allFacetValues("x")))
      e.push(Wr(r, this.paraview.store.getFormatType(`${this.parent.docView.type}Point`))), Yn(e.at(-1));
    for (const [r, n] of Wn(this.paraview.store.model.series)) {
      const i = new Jv(this, r.key);
      this._chartLandingView.append(i);
      for (let s = 0; s < this._chartInfo.resolution ** 2; s++) {
        const o = new RR(this, i);
        i.append(o);
      }
    }
    this._chartLandingView.sortChildren((r, n) => n.children[0].datapoint.facetValueNumericized(n.children[0].datapoint.depKey) - r.children[0].datapoint.facetValueNumericized(r.children[0].datapoint.depKey));
  }
  // protected _layoutDatapoints() {
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.completeLayout();
  //   }
  // }
  seriesRef(e) {
    return this.paraview.ref(`series.${e}`);
  }
  _raiseSeries(e) {
    const r = this.seriesRef(e).value;
    this.dataset.append(r);
  }
  getTickX(e) {
    return this.datapointViews[e].x;
  }
}
class RR extends pf {
  constructor(e, r) {
    super(r), this._count = 0;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get count() {
    return this._count;
  }
  get fillColor() {
    let e = "hsl(0, 0%, 0%)";
    return this._count > 0 && (e = `hsl(0, 0%, ${85 * this._count / this.chart.chartInfo.maxCount + 15}%)`), e;
  }
  get _selectedMarkerX() {
    return this._x;
  }
  get _selectedMarkerY() {
    return this._y;
  }
  get selectedMarker() {
    return new sn(this.paraview, {
      width: this._width + 4,
      height: this._height + 4,
      x: this._x - 2,
      y: this._y - 2,
      fill: "none",
      stroke: "red",
      strokeWidth: 5
    });
  }
  _createId(...e) {
    return [
      "datapoint",
      Yn(this.series.key),
      //facets,
      `${this.index}`
    ].join("-");
  }
  completeLayout() {
    const e = this.chart.chartInfo;
    this._height = this.chart.parent.height / e.resolution, this._width = this.chart.parent.width / e.resolution, this._x = this.index % e.resolution * this._width, this._y = Math.floor(this.index / e.resolution) * this._height;
    const r = this.index;
    this._count = e.grid[r % e.resolution][Math.floor(r / e.resolution)], this.id = [
      "datapoint",
      Yn(this.seriesKey),
      nt`${this._x}`,
      nt`${this._y}`
    ].join("-"), super.completeLayout();
  }
  _createSymbol() {
  }
  _contentUpdateShapes() {
  }
  layoutSymbol() {
  }
  _createShapes() {
    const e = new M9e(this.paraview, {
      x: this._x,
      y: this._y,
      width: this._width,
      height: this._height,
      fill: this.fillColor,
      stroke: this.fillColor
    });
    this._shapes.push(e), super._createShapes();
  }
}
class M9e extends sn {
  get count() {
    return this.parent.count;
  }
  get chart() {
    return this.parent.chart;
  }
  get fillColor() {
    return this.parent.fillColor;
  }
  get parentIndex() {
    return this.parent.index;
  }
  render() {
    return this._styleInfo.stroke = this.paraview.store.visitedDatapoints.values().some((e) => e === this.parent.datapointId) ? "hsl(0, 100.00%, 50.00%)" : this.options.stroke ?? this._options.stroke, Tt`
        <rect
          ${this._ref ? yt(this._ref) : void 0}
          id=${this._id || De}
          style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : De}
          class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : De}
          role=${this._role || De}
          x=${nt`${this._x}`}
          y=${nt`${this._y}`}
          width=${nt`${this.width}`}
          height=${nt`${this.height}`}
          fill= '${this.fillColor}'

          clip-path=${this._options.isClip ? "url(#clip-path)" : De}
        ></rect>
      `;
  }
}
class N9e extends Zv {
  settingDidChange(e, r, n) {
    ["type.histogram.groupingAxis", "type.histogram.displayAxis", "type.histogram.relativeAxes", "axis.y.maxValue", "axis.y.minValue"].includes(e) ? (this.paraview.createDocumentView(), this.paraview.requestUpdate()) : e === "type.histogram.bins" && (this.paraview.createDocumentView(), this.paraview.requestUpdate(), this.paraview.store.updateSettings((i) => {
      i.axis.y.maxValue = "unset";
    }), this.paraview.store.updateSettings((i) => {
      i.axis.y.minValue = "unset";
    })), super.settingDidChange(e, r, n);
  }
  get chartInfo() {
    return this._chartInfo;
  }
  get datapointViews() {
    return super.datapointViews;
  }
  get settings() {
    return this._settings;
  }
  _newDatapointView(e) {
    return new OR(this, e);
  }
  _createDatapoints() {
    const e = [];
    for (const [n, i] of Wn(this.paraview.store.model.series[0].datapoints))
      e.push(Wr(n.facetBox("x"), this.paraview.store.getFormatType(`${this.parent.docView.type}Point`))), Yn(e.at(-1));
    const r = new Jv(this, this.paraview.store.model.series[0].key);
    this._chartLandingView.append(r);
    for (let n = 0; n < this.chartInfo.bins; n++) {
      const i = new OR(this, r);
      r.append(i);
    }
    this._chartLandingView.sortChildren((n, i) => i.children[0].datapoint.facetValueNumericized(i.children[0].datapoint.depKey) - n.children[0].datapoint.facetValueNumericized(n.children[0].datapoint.depKey));
  }
  _layoutDatapoints() {
    for (const e of this.datapointViews)
      e.completeLayout();
  }
  seriesRef(e) {
    return this.paraview.ref(`series.${e}`);
  }
  _raiseSeries(e) {
    const r = this.seriesRef(e).value;
    this.dataset.append(r);
  }
  getTickX(e) {
    return this.datapointViews[e].x;
  }
}
class OR extends pf {
  constructor(e, r) {
    super(r), this._count = 0;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get count() {
    return this._count;
  }
  get _selectedMarkerX() {
    return this._x;
  }
  get _selectedMarkerY() {
    return this._y;
  }
  get selectedMarker() {
    return new sn(this.paraview, {
      width: this._width,
      height: this._height,
      x: this._x,
      y: this._y - this._height,
      fill: "none",
      stroke: "black",
      strokeWidth: 4
    });
  }
  // protected get visitedTransform() {
  //   return 'scaleX(1.15)';
  // }
  computeLocation() {
  }
  layoutSymbol() {
  }
  /*
     completeLayout() {
    //super.completeLayout();
  }
    */
  completeLayout() {
    const e = this.chart.chartInfo;
    if (this.chart.settings.displayAxis == "x" || this.chart.settings.displayAxis == null) {
      const r = this.index;
      this._y = this.chart.parent.height, this._width = this.chart.parent.width / e.bins, this._x = this.index % e.bins * this._width, this._height = (e.grid[r] - e.axisInfo.yLabelInfo.min) / e.axisInfo.yLabelInfo.max * this._y, this.chart.settings.relativeAxes == "Percentage" && (this._height = this._height / e.grid.reduce((n, i) => n + i)), this._count = e.grid[r], this._id = [
        "datapoint-tile",
        Yn(this.seriesKey),
        `${this._x}`,
        `${this._y}`
      ].join("-");
    } else {
      const r = this.index - length;
      this._x = 0, this._height = this.chart.parent.height / e.bins, this._y = (e.grid.length - r - 1) % e.bins * this._height + this._height, this._width = (e.grid[r] - e.axisInfo.xLabelInfo.min) / e.axisInfo.xLabelInfo.max * this.chart.parent.width, this.chart.settings.relativeAxes == "Percentage" && (this._width = this._width / e.grid.reduce((n, i) => n + i)), this._count = e.grid[r], this._id = [
        "datapoint-tile",
        Yn(this.seriesKey),
        `${this._x}`,
        `${this._y}`
      ].join("-");
    }
  }
  summary() {
    const e = this.paraview.store.model.series.flat()[0].length, r = this.chart.chartInfo.axisInfo.xLabelInfo, n = r.range / this.chart.chartInfo.bins, i = (r.min + n * (this.index % this.chart.chartInfo.bins)).toFixed(2), s = (r.min + n * (this.index % this.chart.chartInfo.bins + 1)).toFixed(2);
    return `This bin contains ${this.count} datapoints, which is ${(100 * this.count / e).toFixed(2)}% of the overall data.
        It spans x values from ${i} to ${s}}`;
  }
  //Note: I'm overriding this for now because at the time of writing JIM doesn't support visualizations with a
  //different number of visible datapoints (treating bins as datapoints in this case) than exist in the dataset
  _createId(...e) {
    return `datapoint-${this.index}`;
  }
  get _d() {
    return nt`
          M${this._x},${this._y}
          v${-1 * this._height}
          h${this._width}
          v${this._height}
          Z`;
  }
  render() {
    let e = "hsl(0, 0%, 0%)", r = this.paraview.store.colors.colorValueAt(0);
    return this.paraview.store.visitedDatapoints.values().some((n) => rn(n).index === this.index) ? this.chart.settings.displayAxis == "x" || this.chart.settings.displayAxis == null ? Tt`
                    <g>
                        <path
                            d='${this._d}'
                            role="datapoint"
                            stroke-width= '2'
                            fill= '${"hsl(0, 100.00%, 50.00%)"}'
                            stroke= '${e}'
                            id= '${this.id}'
                        ></path>
                        <line x1=${this._x} y1=${this._y} x2=${this._x + this._width} y2=${this._y} stroke="hsl(0, 100.00%, 50.00%)" stroke-width= 2 />
                    </g>
                ` : Tt`
                    <g>
                        <path
                            d='${this._d}'
                            role="datapoint"
                            stroke-width= '2'
                            fill= '${"hsl(0, 100.00%, 50.00%)"}'
                            stroke= '${e}'
                            id= '${this.id}'
                        ></path>
                        <line x1=${this._x} y1=${this._y} x2=${this._x} y2=${this._y - this._height} stroke="hsl(0, 100.00%, 50.00%)" stroke-width= 2 />
                    </g>
                ` : Tt`
                    <path
                        d='${this._d}'
                        role="datapoint"
                        stroke-width= '2'
                        fill= '${r}'
                        stroke= '${e}'
                        id= '${this.id}'
                    ></path>
            `;
  }
}
class TR extends df {
  constructor(e, r, n, i) {
    super(e, r, n), this.type = i;
  }
  _createId() {
    return super._createId(`${this.type}-highlights`);
  }
  content() {
    var o;
    const e = this.paraview.store.highlightedSelector;
    let r = null, n = [], i = null, s = [];
    return e && (s = this.paraview.documentView.chartInfo.datapointsForSelector(e).map((l) => this._parent.dataLayer.datapointView(l.seriesKey, l.datapointIndex)), e.startsWith("datapoint") ? (n.push(s[0].symbol.clone()), this.paraview.store.settings.chart.isShowPopups && this.type == "foreground" && s[0].addPopup()) : e.startsWith("sequence") && (n.push(s[0].symbol.clone()), n.push(s.at(-1).symbol.clone()), i = new jo(this.paraview, {
      x: 0,
      y: 0,
      points: [n[0].loc, n[1].loc],
      stroke: this.paraview.store.colors.colorValueAt(n[0].color),
      opacity: 0.5,
      strokeWidth: 20
    }), this.type === "background" && (r = new sn(this.paraview, {
      x: n[0].x,
      y: 0,
      width: n[1].x - n[0].x,
      height: this._height,
      fill: this.paraview.store.colors.colorValueAt(n[0].color),
      opacity: 0.25
    })), this.paraview.store.settings.chart.isShowPopups && this.type == "foreground" && this.paraview.store.popups.push(...this.parent.popupLayer.addSequencePopups(s))), n.forEach((l) => {
      l.scale *= 3, l.opacity = 0.5, l.fill = "empty";
    }), (o = this.paraview.documentView) == null || o.chartLayers.popupLayer.addPopups()), Tt`
      ${this.paraview.store.visitedDatapoints.values().map((a) => {
      const { seriesKey: l, index: c } = rn(a);
      return Tt`
            <use
              id="visited-mark-${l}-${c}"
              class="visited-mark"
              href="#${this._parent.dataLayer.datapointDomIds.get(a)}"
            />
          `;
    })}
      ${this.type === "background" && r ? r.render() : ""}
      ${/*overlaySym
            ?
                svg`
                  <use
                    id="highlighted-mark-${datapointViews[0].seriesKey}-${datapointViews[0].index}"
                    class="highlighted-mark"
                    href="#${datapointViews[0].id}-sym"
                  />
                `
    
            : ''*/
    this.type === "foreground" && i ? i.render() : ""}
      ${this.type === "foreground" && n.length ? n.map((a) => a.render()) : ""}
    `;
  }
}
class D9e extends df {
  _createId() {
    return super._createId("selection");
  }
  get class() {
    return "selected-datapoint-marker";
  }
  content() {
    const e = this._parent.dataLayer;
    return Tt`
      ${this.paraview.store.selectedDatapoints.values().map((r) => e.datapointViewForId(e.datapointDomIds.get(r)).selectedMarker.render())}
    `;
  }
}
const vp = 4, LR = 2;
class $9e extends bo(Pr) {
  constructor(e, r) {
    super(e);
    const n = e.store.settings.ui.focusRingGap;
    let i = r.focusRingShape();
    if (i) {
      i.remove(), i.stroke = "white", i.strokeWidth = vp, i.fill = "none", this.append(i);
      const s = i.clone();
      s.stroke = "black", s.strokeWidth = LR, s.fill = "none", this.append(s);
    } else {
      const s = r.focusRingBbox() ?? r.outerBbox, o = s.left - vp / 2 - n, a = s.top - vp / 2 - n, l = s.width + vp + n * 2, c = s.height + vp + n * 2;
      this.append(new sn(e, {
        x: o,
        y: a,
        width: l,
        height: c,
        stroke: "white",
        strokeWidth: vp,
        fill: "none"
      })), this.append(new sn(e, {
        x: o,
        y: a,
        width: l,
        height: c,
        stroke: "black",
        strokeWidth: LR,
        fill: "none"
      }));
    }
  }
}
class j9e extends df {
  _createId() {
    return super._createId("focus");
  }
  content() {
    const e = this._parent.dataLayer.focusLeaf, r = this._parent.docView.chartInfo.shouldDrawFocusRing && (this.paraview.store.settings.ui.isLowVisionModeEnabled || this.paraview.store.settings.ui.isFocusRingEnabled) ? new $9e(this.paraview, e) : null;
    return Tt`
      ${r == null ? void 0 : r.render()}
    `;
  }
}
const MR = {
  /** A single rising sequence */
  Rise: "Rising",
  /** A single falling sequence */
  Fall: "Falling",
  /** A single stable sequence */
  Stable: "Stable",
  /** A single sequence that shows a large, rapid increase in value */
  BigJump: "Big Jump",
  /** A single sequence that shows a large, rapid decrease in value */
  BigFall: "Big Fall",
  /** A falling sequence followed by a rising sequence */
  ReversalToRise: "Reversal to Rising",
  /** A rising sequence followed by a falling sequence */
  ReversalToFall: "Reversal to Falling",
  /** A stable sequence followed by a rising sequence */
  EmergingRise: "Emerging Rising",
  /** A stable sequence followed by a falling sequence */
  EmergingFall: "Emerging Falling",
  /** A rising sequence followed by a stable sequence */
  RiseToStable: "Rising to Stable",
  /** A falling sequence followed by a stable sequence */
  FallToStable: "Falling to Stable",
  /** A rising sequence followed by a falling sequence and another rising sequence */
  Rebound: "Rebounding",
  /** A falling sequence followed by a rising sequence and another falling sequence */
  TemporaryJump: "Temporary Jump",
  /** A falling sequence followed by a short rising sequence at the end of the chart */
  PossibleReversalToRise: "Possible Reversal to Rising",
  /** A rising sequence followed by a short falling sequence at the end of the chart */
  PossibleReversalToFall: "Possible Reversal to Falling",
  /** A stable sequence followed by a short rising sequence at the end of the chart */
  PossibleEmergingRise: "Possible Emerging Rising",
  /** A stable sequence followed by a short falling sequence at the end of the chart */
  PossibleEmergingFall: "Possible Emerging Falling",
  /** A rising sequence followed by a short stable sequence at the end of the chart */
  PossibleRiseToStable: "Possible Rising to Stable",
  /** A falling sequence followed by a short stable sequence at the end of the chart */
  PossibleFallToStable: "Possible Falling to Stable",
  /** A rising sequence followed by a falling sequence and another short rising sequence at the end of the chart */
  PossibleRebound: "Possible Rebounding",
  /** A falling sequence followed by a rising sequence and another short falling sequence at the end of the chart */
  PossibleTemporaryJump: "Possible Temporary Jump"
};
class B9e extends df {
  constructor(e, r, n, i) {
    super(e, r, n), this.type = i, this._groups = /* @__PURE__ */ new Map();
  }
  _createId() {
    return super._createId(`${this.type}-annotation`);
  }
  group(e) {
    return this._groups.get(e);
  }
  addGroup(e, r = !1) {
    if (this._groups.has(e)) {
      if (r)
        return;
      throw new Error(`group '${e}' already exists`);
    }
    this._groups.set(e, new F9e(this.paraview, e)), this.append(this._groups.get(e));
  }
  removeGroup(e, r = !1) {
    if (this._groups.has(e))
      this._groups.delete(e);
    else {
      if (r)
        return;
      throw new Error(`group '${e}' does not exist`);
    }
  }
  addPopups() {
    if (this.addGroup("datapoint-popups", !0), this.group("datapoint-popups").clearChildren(), this.paraview.store.settings.chart.isShowPopups && this.paraview.store.settings.popup.activation === "onFocus") {
      this.paraview.store.userLineBreaks.splice(0, this.paraview.store.userLineBreaks.length), this.paraview.store.popups.splice(0, this.paraview.store.popups.length);
      const e = this.paraview.documentView.chartLayers.dataLayer.chartInfo.navMap.cursor, n = e.datapoints.map((s) => this._parent.dataLayer.datapointView(s.seriesKey, s.datapointIndex));
      let i = [];
      if (e.type === "chord")
        i.push(...this.addChordPopups(n));
      else if (e.type === "sequence")
        i.push(...this.addSequencePopups(n));
      else if (e.type === "series")
        i.push(...this.addSeriesPopups(n));
      else
        for (let s of this.paraview.store.visitedDatapoints) {
          const { seriesKey: o, index: a } = rn(s);
          this.paraview.documentView.chartLayers.dataLayer.datapointView(o, a).addPopup();
        }
      for (let s of i)
        this.paraview.store.popups.push(s);
    } else if (this.paraview.store.settings.chart.isShowPopups && this.paraview.store.settings.popup.activation === "onSelect") {
      this.paraview.store.popups.splice(0, this.paraview.store.popups.length);
      for (let e of this.paraview.store.selectedDatapoints) {
        const { seriesKey: r, index: n } = rn(e);
        this.paraview.documentView.chartLayers.dataLayer.datapointView(r, n).addPopup();
      }
    }
    for (const e of this.paraview.store.popups)
      e.classInfo = { popup: !0 }, this.type === "foreground" ? this.group("datapoint-popups").append(e) : this._groups.has("datapoint-popups") && this.removeGroup("datapoint-popups", !0);
  }
  addChordPopups(e) {
    var o, a, l;
    let r = "";
    for (let c of e)
      r = r.concat(`${c.seriesKey}: ${this.paraview.documentView.chartLayers.dataLayer.chartInfo.summarizer.getDatapointSummary(c.datapoint, "statusBar")}
`);
    const n = e[0], i = (o = this.paraview.documentView) == null ? void 0 : o.chartLayers.dataLayer.chartInfo.popuplegend();
    this.paraview.store.addLineBreak(
      ((a = this.paraview.documentView) == null ? void 0 : a.chartLayers.dataLayer.chartInfo.navMap.cursor.index) / (this.paraview.store.model.series[0].datapoints.length - 1),
      n.index,
      n.seriesKey,
      !1
    ), (l = this.paraview.documentView) == null || l.chartLayers.backgroundAnnotationLayer.render();
    const s = new ls(
      this.paraview,
      {
        text: r,
        x: n.x,
        y: n.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: n.color,
        //margin: 60,
        type: "chord",
        items: i,
        points: e
      },
      {
        fill: "hsl(0, 0%, 100%)",
        stroke: "hsl(0, 0%, 0%)"
      }
    );
    return s.classInfo = { popup: !0 }, [s];
  }
  addSequencePopups(e) {
    const r = e[0];
    let i = (e[e.length - 1].x + r.x) / 2, s = 0;
    if (e.length % 2 == 0) {
      const b = e[e.length / 2 - 1], m = e[e.length / 2];
      s = (b.y + m.y) / 2;
    } else
      s = e[(e.length - 1) / 2].y;
    const o = this.paraview.store.seriesAnalyses[r.seriesKey], a = o.sequences.findIndex((b) => b.start === e[0].index && b.end - 1 === e[e.length - 1].index), l = this.paraview.store.model.series[0].datapoints.map(
      (b) => Wr(b.facetBox("x"), this.paraview.store.getFormatType("horizTick"))
    ), c = this.paraview.store.model.series.find((b) => b.key === e[0].seriesKey).datapoints;
    let p = "";
    if (o.sequences[a].message == null) {
      let b = o.sequences[a];
      e[e.length - 1].y - e[0].y > 0 && Math.abs(b.slopeInfo.slope) > 0.2 ? p = p.concat("Falling trend") : e[e.length - 1].y - e[0].y <= 0 && Math.abs(b.slopeInfo.slope) > 0.2 ? p = p.concat("Rising trend") : p = p.concat("Stable trend");
    } else
      p = p.concat(`${MR[o.sequences[a].message]} trend`);
    const h = parseFloat((c[o.sequences[a].end - 1].facetValueAsNumber("y") - c[o.sequences[a].start].facetValueAsNumber("y")).toFixed(4));
    p = p.concat(`
${h > 0 ? "+" : ""}${h}`), p = p.concat(`
${l[o.sequences[a].start]}-${l[o.sequences[a].end - 1]}`), p = p.concat(`
${o.sequences[a].end - o.sequences[a].start} records`);
    const d = new ls(
      this.paraview,
      {
        text: p,
        x: i,
        y: s,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: r.color,
        margin: 60,
        type: "sequence",
        points: e
      },
      {}
    );
    return d.classInfo = { popup: !0 }, [d];
  }
  addSeriesPopups(e) {
    const r = e[0];
    let i = (e[e.length - 1].x + r.x) / 2, s = 0;
    if (e.length % 2 == 0) {
      const d = e[e.length / 2 - 1], b = e[e.length / 2];
      s = (d.y + b.y) / 2;
    } else
      s = e[(e.length - 1) / 2].y;
    const o = this.paraview.store.seriesAnalyses[r.seriesKey], a = this.paraview.store.model.series[0].datapoints.map(
      (d) => Wr(d.facetBox("x"), this.paraview.store.getFormatType("horizTick"))
    ), l = this.paraview.store.model.series.find((d) => d.key === e[0].seriesKey).datapoints;
    let c = "";
    c = c.concat(`${e[0].seriesKey}`), (o == null ? void 0 : o.message) == null ? c = c.concat(`
No trend detected`) : c = c.concat(`
${MR[o == null ? void 0 : o.message]} trend`);
    let p = parseFloat((l[l.length - 1].facetValueAsNumber("y") - l[0].facetValueAsNumber("y")).toFixed(4));
    c = c.concat(`
${p > 0 ? "+" : ""}${p}`), c = c.concat(`
${a[0]}-${a[l.length - 1]}`), c = c.concat(`
${l.length} records`);
    const h = new ls(
      this.paraview,
      {
        text: c,
        x: i,
        y: s,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: r.color,
        margin: 60,
        points: e
      },
      {}
    );
    return h.classInfo = { popup: !0 }, [h];
  }
  renderChildren() {
    return super.renderChildren();
  }
}
class F9e extends bo(Pr) {
  constructor(e, r) {
    super(e), this._name = r;
  }
  get name() {
    return this._name;
  }
}
const z9e = {
  bar: i1,
  column: i1,
  line: tx,
  scatter: R9e,
  histogram: N9e,
  heatmap: L9e,
  pie: IR,
  donut: IR,
  gauge: i1,
  //GaugeChart,
  stepline: tx,
  //StepLineChart,
  lollipop: i1,
  //LollipopChart
  graph: tx
};
class V9e extends Pr {
  constructor(e, r, n) {
    super(e.paraview), this.docView = e, this._orientation = this.paraview.store.settings.chart.orientation, this.width = r, this.height = n, this._canWidthFlex = !0, this._canHeightFlex = !0, this.createLayers();
  }
  _createId() {
    return "layers";
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  createLayers() {
    this._backgroundHighlightsLayer = new TR(this.paraview, this._width, this._height, "background"), this.append(this._backgroundHighlightsLayer), this._backgroundAnnotationLayer = new _R(this.paraview, this._width, this._height, "background"), this.append(this._backgroundAnnotationLayer), this.createDataLayers(), this._foregroundHighlightsLayer = new TR(this.paraview, this._width, this._height, "foreground"), this.append(this._foregroundHighlightsLayer), this._foregroundAnnotationLayer = new _R(this.paraview, this._width, this._height, "foreground"), this.append(this._foregroundAnnotationLayer), this._selectionLayer = new D9e(this.paraview, this._width, this._height), this.append(this._selectionLayer), this._focusLayer = new j9e(this.paraview, this._width, this._height), this.append(this._focusLayer), this._popupLayer = new B9e(this.paraview, this._width, this._height, "foreground"), this.append(this._popupLayer);
  }
  /** Physical width of the chart; i.e., width onscreen after any rotation. */
  get width() {
    return super.width;
  }
  set width(e) {
    this._orientation === "north" || this._orientation === "south" ? this._logicalWidth = e : this._logicalHeight = e, super.width = e, this._resizeLayers();
  }
  /** Physical height of the chart; i.e., height onscreen after any rotation. */
  get height() {
    return super.height;
  }
  set height(e) {
    this._orientation === "north" || this._orientation === "south" ? this._logicalHeight = e : this._logicalWidth = e, super.height = e, this._resizeLayers();
  }
  get logicalWidth() {
    return this._logicalWidth;
  }
  set logicalWidth(e) {
    this._orientation === "north" || this._orientation === "south" ? this.width = e : this.height = e, this._logicalWidth = e, this._resizeLayers();
  }
  get logicalHeight() {
    return this._logicalHeight;
  }
  set logicalHeight(e) {
    this._orientation === "north" || this._orientation === "south" ? this.height = e : this.width = e, this._logicalHeight = e, this._resizeLayers();
  }
  get orientation() {
    return this._orientation;
  }
  get backgroundHighlightsLayer() {
    return this._backgroundHighlightsLayer;
  }
  get backgroundAnnotationLayer() {
    return this._backgroundAnnotationLayer;
  }
  get dataLayer() {
    return this._dataLayers[0];
  }
  get foregroundHighlightsLayer() {
    return this._foregroundHighlightsLayer;
  }
  get foregroundAnnotationLayer() {
    return this._foregroundAnnotationLayer;
  }
  get selectionLayer() {
    return this._selectionLayer;
  }
  get popupLayer() {
    return this._popupLayer;
  }
  _resizeLayers() {
    this._children.forEach((e) => {
      e.resize(this._logicalWidth, this._logicalHeight);
    });
  }
  resize(e, r) {
    super.resize(e, r), this._orientation === "north" || this._orientation === "south" ? (this._logicalWidth = e, this._logicalHeight = r) : (this._logicalHeight = e, this._logicalWidth = r), this._resizeLayers();
  }
  createDataLayers() {
    const e = z9e[this.paraview.store.type];
    let r;
    if (e)
      r = new e(this.paraview, this._width, this._height, 0, this.docView.chartInfo), this.append(r);
    else
      throw new Error(`no class found for chart type '${this.paraview.store.type}'`);
    this._dataLayers = [r];
  }
  updateLoc() {
  }
  render() {
    this.popupLayer.addPopups();
    let e = nt`translate(${this._x + this._padding.left},${this._y + this._padding.top})`;
    return this._orientation === "east" ? e += nt`
        translate(${this._logicalHeight},${0})
        rotate(90)
      ` : this._orientation === "west" ? e += nt`
        translate(0,${this._logicalHeight})
        rotate(-90)
      ` : this._orientation === "south" && (e += nt`
        translate(0,${this._logicalHeight})
        scale(1,-1)
      `), Tt`
      <g
        id="chart-layers"
        transform=${e}
      >
        <rect
          id="data-backdrop"
          width=${nt`${this._logicalWidth}`}
          height=${nt`${this._logicalHeight}`}
        />
        ${this._backgroundHighlightsLayer.render()}
        ${this._backgroundAnnotationLayer.render()}
        ${this._dataLayers.map((r) => r.render())}
        ${this._foregroundHighlightsLayer.render()}
        ${this._selectionLayer.render()}
        ${this._foregroundAnnotationLayer.render()}
        ${this._focusLayer.render()}
        ${this.popupLayer.render()}
      </g>
    `;
  }
}
const U9e = [
  16.3516,
  17.32391,
  18.35405,
  19.44544,
  20.60172,
  21.82676,
  23.12465,
  24.49971,
  25.95654,
  27.5,
  29.13524,
  30.86771,
  // octave 0
  32.7032,
  34.64783,
  36.7081,
  38.89087,
  41.20344,
  43.65353,
  46.2493,
  48.99943,
  51.91309,
  55,
  58.27047,
  61.73541,
  // octave 1
  65.40639,
  69.29566,
  73.41619,
  77.78175,
  82.40689,
  87.30706,
  92.49861,
  97.99886,
  103.8262,
  110,
  116.5409,
  123.4708,
  // octave 2
  130.8128,
  138.5913,
  146.8324,
  155.5635,
  164.8138,
  174.6141,
  184.9972,
  195.9977,
  207.6523,
  220,
  233.0819,
  246.9417,
  // octave 3
  261.6256,
  277.1826,
  293.6648,
  311.127,
  329.6276,
  349.2282,
  369.9944,
  391.9954,
  415.3047,
  440,
  466.1638,
  493.8833,
  // octave 4
  523.2511,
  554.3653,
  587.3295,
  622.254,
  659.2551,
  698.4565,
  739.9888,
  783.9909,
  830.6094,
  880,
  932.3275,
  987.7666,
  // octave 5
  1046.502,
  1108.731,
  1174.659,
  1244.508,
  1318.51,
  1396.913,
  1479.978,
  1567.982,
  1661.219,
  1760,
  1864.655,
  1975.533,
  // octave 6
  2093.005,
  2217.461,
  2349.318,
  2489.016,
  2637.02,
  2793.826,
  2959.955,
  3135.963,
  3322.438,
  3520,
  3729.31,
  3951.066,
  // octave 7
  4186.009,
  4434.922,
  4698.636,
  4978.032,
  5274.041,
  5587.652,
  5919.911,
  6271.927,
  6644.875,
  7040,
  7458.62,
  7902.133
  // octave 8
], NR = 0.25, H9e = (t, e, r) => isNaN(t) || t < e || t > r, DR = (t) => isNaN(t) ? 0 : (t * 2 - 1) * 0.98, G9e = ({
  point: t,
  min: e,
  max: r,
  bins: n,
  scale: i
}) => W9e({ point: t, min: e, max: r, bins: n }), W9e = ({
  point: t,
  min: e,
  max: r,
  bins: n
}) => {
  const i = (t - e) / (r - e);
  return Math.floor(n * i);
};
class q9e {
  //private _playListContinuous: NodeJS.Timeout[] = [];
  constructor(e, r) {
    this._chartInfo = e, this._store = r, this.context = null, this._audioEngine = null;
  }
  /**
   * Confirm the audio engine was initialized
   */
  _checkAudioEngine() {
    this.context || (this.context = new AudioContext()), !this._audioEngine && this.context && (this._audioEngine = this._providedAudioEngine ?? new vAe(this.context));
  }
  /**
   * Get the available hertzes
   * @returns number[]
   */
  _getHertzRange() {
    return U9e.slice(
      this._store.settings.sonification.hertzLower,
      this._store.settings.sonification.hertzUpper
    );
  }
  /**
   * Play a given data point
   * @param datapoint - the data point to play
   */
  playDatapoints(e, {
    cont: r = !1,
    invert: n = !1,
    durationVariable: i = !1
  } = {}) {
    if (this._checkAudioEngine(), !this._audioEngine)
      return;
    const s = this._getHertzRange(), o = this._store.model.getFacet("x").datatype === "string";
    e.forEach((a, l) => {
      var A;
      const c = (A = this._store.paraChart.paraView.documentView) == null ? void 0 : A.chartLayers.dataLayer.datapointView(a.seriesKey, a.datapointIndex);
      c instanceof Xv && c.popInAnimation();
      const p = a.facetValueNumericized(a.indepKey ?? "x");
      let h = a.facetValueNumericized(a.depKey ?? "y");
      const d = o ? l : p - this._chartInfo.axisInfo.xLabelInfo.min, b = o ? e.length - 1 : this._chartInfo.axisInfo.xLabelInfo.range, m = (
        /*this._xAxis.type === 'log10'
          ? calcPan(
            (Math.log10(current.x) -
              Math.log10(this._xAxis.minimum)) /
            (Math.log10(this._xAxis.maximum) -
              Math.log10(this._xAxis.minimum))
          )
          :*/
        DR(
          d / b
        )
      );
      let w, f;
      if (this._chartInfo.axisInfo)
        w = this._chartInfo.axisInfo.yLabelInfo.min, f = this._chartInfo.axisInfo.yLabelInfo.max;
      else {
        const x = this._store.model.getFacetInterval("y");
        w = x.start, f = x.end;
      }
      const E = h;
      if (n && (h = f - (h - w)), !H9e(h, w, f))
        if (r) {
          let x = Math.min(...s);
          const g = (h - w) / (f - w), v = x * 1.05946 ** (g * s.length);
          let k = DR((p - this._chartInfo.axisInfo.xLabelInfo.min) / this._chartInfo.axisInfo.xLabelInfo.range);
          this._audioEngine.playDataPoint(v, k, NR);
        } else {
          const x = G9e({
            point: h,
            min: w,
            max: f,
            bins: s.length - 1,
            scale: "linear"
          }), g = i ? 0.1 + (E - w) / (f - w) : NR;
          this._audioEngine.playDataPoint(s[x], m, g);
        }
    });
  }
  /**
   * Play an audio notification
   * @param earcon - the type of notification to play
   */
  playNotification(e) {
    if (this._store.settings.sonification.isNotificationEnabled) {
      if (this._checkAudioEngine(), !this._audioEngine)
        return;
      let r = kn.Annotation, n = 0.5;
      switch (e) {
        case "annotation":
          r = kn.Annotation;
          break;
        case "bumper":
          r = kn.Bumper, n = 0.25;
          break;
        case "high":
          r = kn.High;
          break;
        case "low":
          r = kn.Low;
          break;
        case "series":
          r = kn.Series, n = 0.3;
          break;
        case "intersection":
          r = kn.Intersection;
          break;
        case "threshold":
          r = kn.Threshold;
          break;
      }
      this._audioEngine.playNotification(r, 0, n);
    }
  }
}
class wU {
  constructor(e, r) {
    this._type = e, this._store = r, this.log = qt("BaseChartInfo"), this._navMap = null, this._axisInfo = null, this._chordPrevSeriesKey = "", this._soniInterval = null, this._soniRiffInterval = null, this._init(), this._addSettingControls();
  }
  _addSettingControls() {
    this._store.settingControls.add({
      type: "textfield",
      key: "chart.size.width",
      label: "Width",
      options: {
        inputType: "number",
        min: 1,
        max: 1e3
      },
      parentView: "controlPanel.tabs.chart.general.width"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "chart.size.height",
      label: "Height",
      options: {
        inputType: "number",
        min: 1,
        max: 1e3
      },
      parentView: "controlPanel.tabs.chart.general.height"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "chart.isShowPopups",
      label: "Show popups",
      parentView: "controlPanel.tabs.chart.popups"
    });
  }
  _init() {
    this._createNavMap(), this._sonifier = new q9e(this, this._store), this._storeChangeUnsub = this._store.subscribe(async (e, r) => {
      e === "data" && this._createSummarizer();
    }), this._createSummarizer();
  }
  _createSummarizer() {
    this._summarizer = this._type === "pie" || this._type === "donut" ? new C9(this._store.model) : new _9(this._store.model);
  }
  get summarizer() {
    return this._summarizer;
  }
  get managedSettingKeys() {
    return [`type.${this._type}`];
  }
  get settings() {
    return br.getGroupLink(this.managedSettingKeys[0], this._store.settings);
  }
  get navMap() {
    return this._navMap;
  }
  /** Overridden by ScatterChartInfo */
  get navDatapointType() {
    return "datapoint";
  }
  get axisInfo() {
    return this._axisInfo;
  }
  settingDidChange(e, r, n) {
  }
  async storeDidChange(e, r) {
  }
  noticePosted(e, r) {
  }
  _createNavMap() {
    this._navMap = new R9(this._store, this);
    const e = this._navMap.layer("root"), r = new Ia(e, "top", {}, this._store);
    e.registerNode(r), e.cursor = r;
  }
  didAddHighlight(e) {
  }
  didRemoveHighlight(e) {
  }
  legend() {
    return [];
  }
  popuplegend() {
    return this.seriesInNavOrder().map((r) => r.key).map((r, n) => ({
      label: "",
      seriesKey: r,
      color: this._store.seriesProperties.properties(r).color,
      symbol: this._store.seriesProperties.properties(r).symbol
    }));
  }
  navToDatapoint(e, r) {
    this._navMap.goTo(this.navDatapointType, { seriesKey: e, index: r });
  }
  async move(e) {
    await this._navMap.cursor.move(e), this._store.paraChart.postNotice("move", { dir: e, options: this._navMap.cursor.options });
  }
  /**
   * Navigate to the series minimum/maximum datapoint
   * @param isMin - If true, go the the minimum. Otherwise, go to the maximum
   */
  goSeriesMinMax(e) {
    const r = this._navMap.cursor;
    if (r.isNodeType("top") || r.isNodeType("chord"))
      this.goChartMinMax(e);
    else if (r.isNodeType(this.navDatapointType) || r.isNodeType("series") || r.isNodeType("sequence") || r.isNodeType("cluster")) {
      let n = null;
      const i = r.options.seriesKey;
      r.isNodeType(this.navDatapointType) && (n = this._store.model.atKeyAndIndex(r.options.seriesKey, r.options.index));
      const s = this._store.model.dependentFacetKeys[0], o = this._store.model.atKey(i).getFacetStats(s);
      let a = e ? o.min.datapoints : o.max.datapoints;
      if (n && a.length > 1) {
        const l = a.findIndex((c) => c === n);
        l !== -1 && l !== a.length + 1 && (a = a.toSpliced(0, l));
      }
      this._navMap.goTo(this.navDatapointType, {
        seriesKey: a[0].seriesKey,
        index: a[0].datapointIndex
      }), this._store.paraChart.postNotice("goSeriesMinMax", { isMin: e, options: this._navMap.cursor.options });
    }
  }
  /**
   * Navigate to (one of) the chart minimum/maximum datapoint(s)
   * @param isMin - If true, go the the minimum. Otherwise, go to the maximum
   */
  goChartMinMax(e) {
    const r = this._store.model.getFacetStats("y"), n = e ? r.min.value : r.max.value, i = this._store.model.allPoints.find((s) => s.facetValueAsNumber("y") === n);
    this._navMap.goTo(this.navDatapointType, {
      seriesKey: i == null ? void 0 : i.seriesKey,
      index: i == null ? void 0 : i.datapointIndex
    }), this._store.paraChart.postNotice("goChartMinMax", { isMin: e, options: this._navMap.cursor.options });
  }
  _composePointSelectionAnnouncement(e) {
    const r = (c) => {
      const { seriesKey: p, index: h } = rn(c), d = this._store.model.atKeyAndIndex(p, h);
      return `${p} (${Wr(d.facetBox("x"), this._store.getFormatType("statusBar"))}, ${Wr(d.facetBox("y"), this._store.getFormatType("statusBar"))})`;
    }, n = this._store.selectedDatapoints.size, i = this._store.prevSelectedDatapoints.size, s = this._store.selectedDatapoints.difference(
      this._store.prevSelectedDatapoints
    ), o = this._store.prevSelectedDatapoints.difference(
      this._store.selectedDatapoints
    ), l = `${n} point${n === 1 ? "" : "s"} selected.`;
    return i === 0 ? `Selected ${r(s.values().toArray()[0])}` : i === 1 && !n ? `Deselected ${r(o.values().toArray()[0])}. No points selected.` : !e && s.size && i ? `Selected ${r(s.values().toArray()[0])}. 1 point selected.` : !e && n && i ? `Deselected ${r(o.values().toArray()[0])}. 1 point selected.` : e && o.size ? `Deselected ${r(o.values().toArray()[0])}. ${l}` : e && s.size ? `Selected ${r(s.values().toArray()[0])}. ${l}` : "ERROR";
  }
  _composeSeriesSelectionAnnouncement() {
    const e = this._store.selectedDatapoints.size, r = this._store.prevSelectedDatapoints.size, n = this._store.selectedDatapoints.values().filter((a) => {
      const l = rn(a);
      return !this._store.wasSelected(l.seriesKey, l.index);
    }).toArray();
    let i = e === 1 ? "" : "s";
    const s = `${e} point${i} selected.`;
    i = n.length === 1 ? "" : "s";
    const o = `Selected ${n.length} point${i}.`;
    return r === 0 ? o : `${o} ${s}`;
  }
  selectCurrent(e = !1) {
    e ? this._store.extendSelection() : this._store.select();
    const r = this._navMap.cursor.isNodeType("datapoint") ? this._composePointSelectionAnnouncement(e) : this._navMap.cursor.isNodeType("series") ? this._composeSeriesSelectionAnnouncement() : "";
    r && this._store.announce(r), this._store.paraChart.postNotice("select", { isExtend: e, options: this._navMap.cursor.options });
  }
  clearDatapointSelection(e = !1) {
    this._store.clearSelected(), e || this._store.announce("No items selected."), this._store.paraChart.postNotice("clearSelection", null);
  }
  // NOTE: This should be overriden in subclasses
  queryData() {
    const e = this._navMap.cursor.type;
    this._store.announce(
      `[ParaChart/Internal] Error: DataLayer.queryData should be overriden. Query Type: ${e}`
    );
  }
  navFirst() {
    var r;
    const e = this._navMap.cursor.type;
    if ([this.navDatapointType, "chord", "series"].includes(e)) {
      const n = {
        datapoint: "left",
        chord: "left",
        series: "up"
      };
      (r = this._navMap.cursor.allNodes(n[e], e).at(-1)) == null || r.go(), this._store.paraChart.postNotice("goFirst", { options: this._navMap.cursor.options });
    }
  }
  navLast() {
    var r;
    const e = this._navMap.cursor.type;
    if ([this.navDatapointType, "chord", "series"].includes(e)) {
      const n = {
        datapoint: "right",
        chord: "right",
        series: "down"
      };
      (r = this._navMap.cursor.allNodes(n[e], e).at(-1)) == null || r.go(), this._store.paraChart.postNotice("goLast", { options: this._navMap.cursor.options });
    }
  }
  navToChordLanding() {
    if (["line", "bar", "column"].includes(this._store.type) && this._store.model.series.length > 1)
      if (this._navMap.cursor.isNodeType(this.navDatapointType)) {
        const e = this._navMap.cursor.options.seriesKey;
        this._navMap.cursor.layer.goTo("chord", this._navMap.cursor.options.index), this._chordPrevSeriesKey = e, this._store.paraChart.postNotice("enterChordMode", { options: this._navMap.cursor.options });
      } else this._navMap.cursor.isNodeType("chord") && (this._navMap.cursor.layer.goTo(
        this.navDatapointType,
        {
          seriesKey: this._chordPrevSeriesKey,
          index: this._navMap.cursor.options.index
        }
      ), this._store.paraChart.postNotice("exitChordMode", { options: this._navMap.cursor.options }));
    else
      this.log.info("Chord mode not supported for this chart type");
  }
  async navRunDidStart(e) {
    (e.isNodeType("series") || e.isNodeType(this.navDatapointType)) && (this._store.frontSeries = e.options.seriesKey);
  }
  async navRunDidEnd(e) {
    if (e.isNodeType("top"))
      this._store.announce(await this._summarizer.getChartSummary());
    else if (e.isNodeType("series"))
      this._store.announce(
        await this._summarizer.getSeriesSummary(e.options.seriesKey)
      ), this._playCurrentRiff(), this._store.sparkBrailleInfo = this._sparkBrailleInfo();
    else if (e.isNodeType(this.navDatapointType)) {
      const r = this._store.everVisitedSeries(e.options.seriesKey), n = this._store.model.atKeyAndIndex(e.options.seriesKey, e.options.index), i = [this._summarizer.getDatapointSummary(n, "statusBar")];
      if (!this._store.wasVisitedSeries(e.options.seriesKey) && (i[0] = `${this._store.model.atKey(e.options.seriesKey).getLabel()}: ${i[0]}`, !r)) {
        const o = await this._summarizer.getSeriesSummary(e.options.seriesKey);
        i.push(o.text);
      }
      this._store.announce(i), this._store.settings.sonification.isSoniEnabled && this.playDatapoints([n]), this._store.sparkBrailleInfo = this._sparkBrailleInfo();
    } else if (e.isNodeType("chord")) {
      if (this._store.settings.sonification.isSoniEnabled)
        if (this._store.settings.sonification.isArpeggiateChords)
          this._playCurrentRiff(this._chordRiffOrder());
        else {
          const r = e.datapoints.map((n) => this._store.model.atKeyAndIndex(n.seriesKey, n.datapointIndex));
          this.playDatapoints(r);
        }
    } else e.isNodeType("sequence") && (this._store.announce(
      await this._summarizer.getSequenceSummary({
        seriesKey: e.options.seriesKey,
        start: e.options.start,
        end: e.options.end
      })
    ), this._playCurrentRiff());
  }
  /** Can be overridden by subclasses. */
  seriesInNavOrder() {
    return this._store.model.series;
  }
  /** Nav map layer from which to interpret selectors */
  get selectorLayer() {
    return "root";
  }
  datapointsForSelector(e) {
    return this._navMap.datapointsForSelector(this.selectorLayer, e);
  }
  isHighlighted(e, r) {
    if (this._store.highlightedSelector) {
      const n = this.datapointsForSelector(this._store.highlightedSelector);
      for (const i of n)
        if (i.seriesKey === e && i.datapointIndex === r)
          return !0;
    }
    return !1;
  }
  get shouldDrawFocusRing() {
    return this._navMap.cursor.type !== "top";
  }
  /** Play a riff for the current nav node */
  _playCurrentRiff(e) {
    this._store.settings.sonification.isSoniEnabled && this._store.settings.sonification.isRiffEnabled && this.playRiff(this._navMap.cursor.datapoints, e);
  }
  _chordRiffOrder() {
    return "normal";
  }
  /**
   * Clear outstanding play intervals/timeouts
   */
  clearPlay() {
    clearInterval(this._soniInterval), clearInterval(this._soniRiffInterval);
  }
  getXAxisInterval() {
    let e = [];
    if (this._store.model.getFacet("x").datatype === "number" || this._store.model.getFacet("x").datatype === "date")
      e = this._store.model.allFacetValues("x").map((r) => r.asNumber());
    else
      throw new Error("axis must be of type number or date to take interval");
    return { start: Math.min(...e), end: Math.max(...e) };
  }
  getYAxisInterval() {
    if (!this.axisInfo)
      throw new Error("chart is missing `axisInfo` object");
    return {
      start: this.axisInfo.yLabelInfo.min,
      end: this.axisInfo.yLabelInfo.max
    };
  }
  getAxisInterval(e) {
    return e === "x" ? this.getXAxisInterval() : this.getYAxisInterval();
  }
}
const Q9e = [1e3, 250, 100, 50, 25], H1 = [450, 300, 150, 100, 75];
class T9 extends wU {
  constructor(e, r) {
    super(e, r), this._soniSequenceIndex = 0, this._soniNoteIndex = 0, this._soniSpeedRateIndex = 1;
  }
  _createNavMap() {
    super._createNavMap(), this._createPrimaryNavNodes(), this._store.model.seriesKeys.length > 1 && (this._createVerticalNavLinks(), this._createChordNavNodes());
  }
  get _datapointNavNodeType() {
    return "datapoint";
  }
  _datapointNavNodeOptions(e) {
    return {
      seriesKey: e.seriesKey,
      index: e.datapointIndex
    };
  }
  _createPrimaryNavNodes() {
    let e = this._navMap.root.get("top");
    this._store.model.dependentFacetKeys[0], this.seriesInNavOrder().forEach((n, i) => {
      const s = new Ia(this._navMap.root, "series", {
        seriesKey: n.key
      }, this._store);
      s.connect("left", e), e = s, n.datapoints.forEach((o, a) => {
        const l = new Ia(
          this._navMap.root,
          this._datapointNavNodeType,
          this._datapointNavNodeOptions(o),
          this._store
        );
        l.connect("left", e), e = l;
      });
    });
  }
  _createVerticalNavLinks() {
    this._store.model.series.slice(0, -1).forEach((e, r) => {
      const n = this._navMap.root.get("series", r), i = this._navMap.root.get("series", r + 1);
      n.connect("down", i);
      for (let s = 1; s <= e.datapoints.length; s++)
        n.peekNode("right", s).connect(
          "down",
          i.peekNode("right", s)
        );
    });
  }
  _createChordNavNodes() {
    this._navMap.root.query(this._datapointNavNodeType, {
      seriesKey: this.seriesInNavOrder()[0].key
    }).forEach((e) => {
      new Ia(
        this._navMap.root,
        "chord",
        { index: e.options.index },
        this._store
      );
    }), this._navMap.root.query("chord").slice(0, -1).forEach((e, r) => {
      e.connect("right", this._navMap.root.get("chord", r + 1));
    });
  }
  playRiff(e, r) {
    if (r === "sorted" ? e.sort((n, i) => n.facetValueAsNumber("y") - i.facetValueAsNumber("y")) : r === "reversed" && e.reverse(), e.length) {
      this._soniRiffInterval && clearInterval(this._soniRiffInterval), this._soniSequenceIndex++;
      const n = e.length;
      Y4(
        this._store.paraChart.paraView,
        this._store.paraChart.paraView.store.settings.animation.popInAnimateRevealTimeMs + H1.at(this._store.settings.sonification.riffSpeedIndex) * n,
        50
      ), this._soniRiffInterval = setInterval(() => {
        const i = e.shift();
        i ? (this._sonifier.playDatapoints([i]), this._soniNoteIndex++) : clearInterval(this._soniRiffInterval);
      }, H1.at(this._store.settings.sonification.riffSpeedIndex));
    }
  }
  playDatapoints(e) {
    const r = e.length;
    Y4(
      this._store.paraChart.paraView,
      this._store.paraChart.paraView.store.settings.animation.popInAnimateRevealTimeMs + H1.at(this._store.settings.sonification.riffSpeedIndex) * r,
      50
    ), this._sonifier.playDatapoints(e);
  }
  playDir(e) {
    if (this._navMap.cursor.type !== this._datapointNavNodeType)
      return;
    this.clearPlay();
    let r = this._navMap.cursor;
    this._soniInterval = setInterval(() => {
      const n = r.peekNode(e, 1);
      n && n.type === this._datapointNavNodeType ? (this.playDatapoints([n.datapoints[0]]), r = n) : this.clearPlay();
    }, Q9e.at(this._soniSpeedRateIndex));
  }
  _sparkBrailleInfo() {
    return {
      data: this._navMap.cursor.isNodeType(this._datapointNavNodeType) || this._navMap.cursor.isNodeType("series") || this._navMap.cursor.isNodeType("sequence") ? this._store.model.atKey(this._navMap.cursor.options.seriesKey).datapoints.map((e) => e.facetValueAsNumber("y")).join(" ") : "0",
      isBar: this._type === "bar" || this._type === "column"
    };
  }
}
class xU extends T9 {
  constructor(e, r) {
    super(e, r);
  }
  _init() {
    super._init(), this._axisInfo = new Yv(this._store, {
      yValues: this._store.model.allFacetValues("y").map((e) => e.value)
    });
  }
  seriesInNavOrder() {
    const e = this._store.model.dependentFacetKeys[0];
    return this._store.model.series.toSorted((r, n) => n.datapoints[0].facetValueNumericized(e) - r.datapoints[0].facetValueNumericized(e));
  }
}
function L9(t, e) {
  const r = [], n = e.some((s) => s.equals(t));
  if (e.length >= (n ? 2 : 1)) {
    const s = n ? ji.other : void 0;
    r.push(qn(ji.comparisonSelectedDatapoints, { other: s }));
    const o = e.toSorted((a, l) => a.datapoint.facetValueNumericized("y") > l.datapoint.facetValueNumericized("y") ? -1 : 1);
    for (const a of o)
      if (!a.equals(t)) {
        const l = a.datapoint.facetValueNumericized("y"), c = t.datapoint.facetValueNumericized("y"), p = AU(c, l), h = SU[p.relationship].msg, d = p.diff !== 0 ? qn("${diff:number} ", { diff: p.diff }) : void 0;
        r.push(d2e(qn(
          "${diff:string?}${comparatorMsg:string} ${seriesLabel:string} ${datapointXY:string}",
          { diff: d, comparatorMsg: h, seriesLabel: a.series.getLabel(), datapointXY: xS(a.datapoint, "raw") }
        )));
      }
  }
  return r;
}
function M9(t, e, r) {
  let n = qt("getDatapointMinMax");
  const i = [], s = t.series.filter((d) => d.key === r)[0];
  let o = [], a = [];
  for (let d of s.rawData)
    o.push(Number(d.y));
  for (let d of t.series)
    for (let b of d.rawData)
      a.push(Number(b.y));
  const l = Math.min(...o), c = Math.min(...a), p = Math.max(...o), h = Math.max(...a);
  return e == c ? i.push(ji.seriesChartMin) : e == l && i.push(ji.seriesMin), e == h ? i.push(ji.seriesChartMax) : e == p && i.push(ji.seriesMax), n.info(i), i;
}
function EU(t, e) {
  const r = [];
  let n, i;
  return (n = $R(t, e, "prev")) && r.push(n), (i = $R(t, e, "next")) && r.push(i), f2e(r, !0);
}
function $R(t, e, r) {
  let n = qt("describeAdjacentDatapointComparison");
  const i = e[r];
  if (!i)
    return null;
  const s = `${i.series[i.index].facetBox("x").raw}, ${i.series[i.index].facetBox("y").raw}`;
  n.info(e.index);
  const o = t.series.filter((m) => m.key == e.seriesKey)[0], a = t.series.filter((m) => m.key == i.seriesKey)[0], l = o[e.index].facetBox("y").raw, c = a[i.index].facetBox("y").raw, p = AU(l, c);
  n.info(p);
  const h = SU[p.relationship][r], d = r === "prev" ? p.percentagePrev : p.percentageNext;
  if (p.diff === 0)
    return qn("${comparator:string} ${otherLabel:string}", { comparator: h, otherLabel: s });
  const b = r === "prev" ? "from" : "in";
  return qn(
    "${comparator:string} ${diff:number} (${percent:number#.1}%) ${preposition:string} ${otherLabel:string}",
    { comparator: h, diff: p.diff, percent: d, preposition: b, otherLabel: s }
  );
}
const ji = {
  comparisonSelectedDatapoints: "Comparison to${other:string?} selected datapoints",
  other: " other",
  seriesMin: "Series low",
  seriesChartMin: "Series low and chart low",
  seriesMax: "Series high",
  seriesChartMax: "Series high and chart high",
  seriesLabelLength: "${seriesLabel:string}. ${datapointCount:number} datapoints",
  datapointLabelLength: "${seriesLabel:string} ${datapointXY:string}. Datapoint ${datapointIndex:number} of ${datapointCount:number}.",
  percentageOfSeries: "${datapointX:string}% of total amount in series: ${seriesLabel:string}. Datapoint ${datapointIndex:number} of ${datapointCount:number}.",
  percentageOfChart: "${datapointX:string}% of total amount in chart. Datapoint ${datapointIndex:number} of ${datapointCount:number}."
}, SU = {
  equal: {
    msg: "equal to",
    prev: "stayed the same from",
    next: "will stay the same in"
  },
  greater: {
    msg: "more than",
    prev: "grew by",
    next: "will decrease by"
  },
  less: {
    msg: "less than",
    prev: "decreased by",
    next: "will grow by"
  }
};
function AU(t, e) {
  qt("compare").info(e);
  const n = {
    diff: 0
  };
  if (t === e)
    n.relationship = "equal";
  else {
    n.relationship = t > e ? "greater" : "less";
    const i = new Ds(Math.min(t, e)), s = new Ds(Math.max(t, e));
    n.diff = s.sub(i).toNumber();
    const o = new Ds(t), a = new Ds(e);
    o && (n.percentageNext = a.sub(o).dividedBy(o).times(100).toNumber()), a && (n.percentagePrev = o.sub(a).dividedBy(a).times(100).toNumber());
  }
  return n;
}
class K9e extends xU {
  constructor(e, r) {
    super(e, r), this._prevHighlightNavcode = "", this.log = qt("LineChartInfo");
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "textfield",
      key: "type.line.lineWidth",
      label: "Line width",
      options: {
        inputType: "number",
        min: 1,
        max: this._store.settings.type.line.lineWidthMax
      },
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "chart.isDrawSymbols",
      label: "Show symbols",
      parentView: "controlPanel.tabs.chart.chart"
    });
  }
  get settings() {
    return super.settings;
  }
  settingDidChange(e, r, n) {
    ["type.line.isTrendNavigationModeEnabled"].includes(e) && ([this._navMap, this._altNavMap] = [this._altNavMap, this._navMap], this._navMap.root.goTo("top", {})), super.settingDidChange(e, r, n);
  }
  async storeDidChange(e, r) {
    await super.storeDidChange(e, r), e === "seriesAnalyses" && this._createSequenceNavNodes();
  }
  _canCreateSequenceNavNodes() {
    return !!this._navMap && Object.keys(this._store.seriesAnalyses).length === this._store.model.seriesKeys.length && !!this._store.seriesAnalyses[this._store.model.seriesKeys[0]];
  }
  _createNavMap() {
    super._createNavMap(), this._createSequenceNavNodes();
  }
  _createSequenceNavNodes() {
    if (!this._canCreateSequenceNavNodes()) return;
    const e = [];
    this._altNavMap = this._navMap.clone(), this._altNavMap.root.query("series").forEach((r) => {
      e.length && r.connect("left", e.at(-1).at(-1));
      const n = this._store.seriesAnalyses[r.options.seriesKey], i = r.allNodes("right", "datapoint"), s = [];
      n.sequences.forEach((o) => {
        const a = new Ia(r.layer, "sequence", {
          seriesKey: r.options.seriesKey,
          start: o.start,
          end: o.end
        }, this._store);
        s.push(a);
      }), e.push(s), s.slice(0, -1).forEach((o, a) => {
        o.connect("right", s[a + 1]);
      }), r.connect("right", s[0]), i[0].disconnect("left", !1), i.at(-1).disconnect("right"), s.forEach((o) => {
        o.connect(
          "in",
          i[o.options.start],
          !i[o.options.start].getLink("out")
        );
        for (let a = o.options.start + 1; a < o.options.end; a++)
          i[a].connect("out", o, !1);
        o.peekNode("right", 1) && i[o.options.end - 1].connect("in", o.peekNode("right", 1), !1);
      });
    }), e.slice(0, -1).forEach((r, n) => {
      r.forEach((i) => {
        const s = e[n + 1].find((o) => o.options.start <= i.options.start && o.options.end > i.options.start);
        i.connect("down", s, !1);
      });
    }), e.slice(1).forEach((r, n) => {
      r.forEach((i, s) => {
        const o = e[n].find((a) => a.options.start <= i.options.start && a.options.end > i.options.start);
        i.connect("up", o, !1);
      });
    });
  }
  noticePosted(e, r) {
    if (super.noticePosted(e, r), this._store.settings.ui.isNarrativeHighlightEnabled)
      if (e === "utteranceBoundary") {
        const n = r;
        this._prevHighlightNavcode = this._doHighlight(n, this._prevHighlightNavcode);
      } else e === "utteranceEnd" && (this._store.paraChart.captionBox.highlightManualOverride || (this._store.clearHighlight(), this._store.clearAllSeriesLowlights()), this._prevHighlightNavcode && (this.didRemoveHighlight(this._prevHighlightNavcode), this._prevHighlightNavcode = ""));
  }
  _doHighlight(e, r) {
    if (e.navcode) {
      if (e.navcode.startsWith("series")) {
        const n = e.navcode.split(/-/);
        this._store.lowlightOtherSeries(...n.slice(1));
      } else
        this._store.clearHighlight(), this._store.highlight(e.navcode), r && this.didRemoveHighlight(r), this.didAddHighlight(e.navcode);
      r = e.navcode;
    } else
      this._store.clearHighlight(), this._store.clearAllSeriesLowlights(), r && (this.didRemoveHighlight(r), r = "");
    return r;
  }
  legend() {
    const e = this._store.model, r = [...e.seriesKeys];
    return this._store.settings.legend.itemOrder === "alphabetical" && r.sort(), r.map((n) => ({
      label: e.atKey(n).getLabel(),
      seriesKey: n,
      color: this._store.seriesProperties.properties(n).color
    }));
  }
  // TODO: localize this text output
  // focused view: e.options!.focus
  // all visited datapoint views: e.options!.visited
  queryData() {
    const e = [], r = this._navMap.cursor;
    if (r.isNodeType("top"))
      e.push(`Displaying Chart: ${this._store.title}`);
    else if (r.isNodeType("series")) {
      const n = r.options.seriesKey, i = this._store.model.atKey(n), s = i.length, o = i.getLabel();
      e.push(qn(
        ji.seriesLabelLength,
        { seriesLabel: o, datapointCount: s }
      ));
    } else if (r.isNodeType("datapoint")) {
      const n = this._store.selectedDatapoints, i = r.options.seriesKey, s = r.options.index, o = this._store.model.atKey(i), a = o.datapoints[s], l = o.getLabel(), c = this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(i, s);
      if (e.push(qn(
        ji.datapointLabelLength,
        {
          seriesLabel: l,
          datapointXY: xS(a, "raw"),
          datapointIndex: r.options.index + 1,
          datapointCount: this._store.model.atKey(i).length
        }
      )), n.size > 0) {
        const h = n.values().map((b) => {
          const m = rn(b);
          return this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(m.seriesKey, m.index);
        }).toArray(), d = L9(
          c,
          h
        );
        e.push(...d);
      } else {
        const h = EU(this._store.model, c);
        e.push(h);
      }
      const p = M9(
        this._store.model,
        a.facetValueAsNumber("y"),
        i
      );
      e.push(...p);
    }
    this._store.announce(e);
  }
}
class Y9e {
  constructor(e, r) {
    this.chartInfo = e, this.key = r, this.stacks = {}, this.log = qt("BarCluster"), this.id = `barcluster-${Yn(this.key)}`, this.labelId = `tick-x-${this.id}`;
  }
  get index() {
    return Object.keys(this.chartInfo.clusteredData).indexOf(this.key);
  }
}
class jR {
  constructor(e, r) {
    this.cluster = e, this.key = r, this.bars = {}, this._label = null, this.id = `barstack-${Yn(this.cluster.key)}-${Yn(this.key)}`, this.labelId = `tick-x-${this.id}`;
  }
  get index() {
    return Object.keys(this.cluster.stacks).indexOf(this.key);
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._label = e;
  }
}
class BR extends T9 {
  constructor(e, r) {
    super(e, r);
  }
  _init() {
    super._init(), this._clusteredData = this._clusterData();
    const e = Object.values(this._clusteredData).flatMap((n) => Object.values(n.stacks).map(
      (i) => Object.values(i.bars).map((s) => s.value.value).reduce((s, o) => s + o, 0)
      //        + Object.values(s.bars).length*this.settings.stackInsideGap
    ));
    this._axisInfo = new Yv(this._store, {
      // xTiers: [this.paraview.store.model!.allFacetValues('x')!.map(x =>
      //   formatBox(x, 'barCluster', this.paraview.store))],
      xTiers: [Object.keys(this._clusteredData)],
      yValues: e,
      yMin: Math.min(0, Math.min(...e)),
      isXInterval: !0,
      // manifest can override this
      isXVertical: this._store.type === "bar"
    });
    const r = this._store.model.numSeries;
    this.settings.stacking === "standard" ? this._stacksPerCluster = 1 : this.settings.stacking === "none" && (this._stacksPerCluster = Math.ceil(r / 1));
  }
  get settings() {
    return super.settings;
  }
  get clusteredData() {
    return this._clusteredData;
  }
  get stacksPerCluster() {
    return this._stacksPerCluster;
  }
  _clusterData() {
    const e = this._store.settings.type[this._type], r = {}, n = this._store.model.series[0].datapoints.map((o) => o.facetBox("x")), i = [];
    for (const [o, a] of Wn(n)) {
      const l = Wr(o, this._store.getFormatType("barCluster"));
      let c = r[l];
      c || (c = new Y9e(this, l), r[l] = c, i.push(c));
    }
    const s = [...this._store.model.series];
    this._store.type === "column" && e.stacking === "standard" && s.reverse();
    for (const [o, a] of Wn(s))
      for (const [l, c] of Wn(o.datapoints.map((p) => p.facetBox("y")))) {
        let p, h;
        e.stacking === "standard" ? (h = "stack", p = i[c].stacks[h], p || (p = new jR(i[c], h), i[c].stacks[h] = p)) : e.stacking === "none" && (h = o.key, p = i[c].stacks[h], p || (p = new jR(i[c], h), i[c].stacks[h] = p)), p.bars[o.key] = {
          series: o.key,
          value: o.datapoints[c].facetBox("y")
        };
      }
    return r;
  }
  legend() {
    const e = this._store.model;
    return this._store.settings.legend.itemOrder === "series" ? e.series.map((r) => ({
      label: r.getLabel(),
      seriesKey: r.key,
      color: this._store.seriesProperties.properties(r.key).color
    })) : e.seriesKeys.toSorted().map((r) => ({
      label: e.atKey(r).getLabel(),
      seriesKey: r,
      color: this._store.seriesProperties.properties(r).color
    }));
  }
  // TODO: localize this text output
  // focused view: e.options!.focus
  // all visited datapoint views: e.options!.visited
  queryData() {
    const e = [], r = this._navMap.cursor;
    if (r.isNodeType("top"))
      e.push(`Displaying Chart: ${this._store.title}`);
    else if (r.isNodeType("series")) {
      const n = r.options.seriesKey, i = this._store.model.atKey(n), s = i.length, o = i.getLabel();
      e.push(qn(
        ji.seriesLabelLength,
        { seriesLabel: o, datapointCount: s }
      ));
    } else if (r.isNodeType("datapoint")) {
      const n = this._store.selectedDatapoints, i = r.options.seriesKey, s = r.options.index, o = this._store.model.atKey(i), a = o.datapoints[s], l = o.getLabel(), c = this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(i, s);
      if (e.push(qn(
        ji.datapointLabelLength,
        {
          seriesLabel: l,
          datapointXY: xS(a, "raw"),
          datapointIndex: r.options.index + 1,
          datapointCount: o.length
        }
      )), n.size > 0) {
        const h = n.values().map((b) => {
          const m = rn(b);
          return this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(m.seriesKey, m.index);
        }).toArray(), d = L9(
          c,
          h
        );
        e.push(...d);
      } else {
        const h = EU(this._store.model, c);
        e.push(h);
      }
      const p = M9(
        this._store.model,
        a.facetValueAsNumber("y"),
        i
      );
      e.push(...p);
    }
    this._store.announce(e);
  }
}
class FR extends wU {
  constructor(e, r) {
    super(e, r);
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "slider",
      key: `type.${this._type}.orientationAngleOffset`,
      label: "Orientation",
      options: {
        min: 0,
        max: 360,
        step: 1,
        compact: !0,
        width: "8rem"
      },
      parentView: "controlPanel.tabs.chart.chart"
    });
    const e = ["", "category", "percentage:(value)"];
    this._store.settingControls.add({
      type: "dropdown",
      key: `type.${this._type}.insideLabels.contents`,
      label: "Inside labels:",
      options: { options: e },
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: `type.${this._type}.outsideLabels.contents`,
      label: "Outside labels:",
      options: { options: e },
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "textfield",
      key: `type.${this._type}.explode`,
      label: "Explode",
      options: {
        inputType: "text"
      },
      parentView: "controlPanel.tabs.chart.chart"
    });
  }
  _createNavMap() {
    super._createNavMap();
    const e = new w2(this._navMap, "slices");
    YSe.forEach((n) => {
      this._navMap.node("top", {}).connect(n, e);
    });
    const r = this._store.model.series[0].datapoints.map((n, i) => {
      const s = new Ia(e, "datapoint", {
        seriesKey: n.seriesKey,
        index: n.datapointIndex
      }, this._store);
      return s.connect("out", this._navMap.root), s.connect("up", this._navMap.root), s;
    });
    r.slice(0, -1).forEach((n, i) => {
      n.connect("right", e.get("datapoint", i + 1));
    }), r.at(-1).connect("right", r[0]);
  }
  legend() {
    const e = this._store.model.series[0], r = e.datapoints.map((i) => Wr(i.facetBox("x"), this._store.getFormatType("pieSliceLabel"))), n = e.datapoints.map((i) => Wr(i.facetBox("y"), this._store.getFormatType("pieSliceValue")));
    return r.map((i, s) => ({
      label: `${i}: ${n[s]}`,
      seriesKey: e.key,
      color: s,
      datapointIndex: s
    }));
  }
  playDatapoints(e) {
    this._sonifier.playDatapoints(e, { invert: !0, durationVariable: !0 });
  }
  playDir(e) {
  }
  playRiff(e, r) {
  }
  _sparkBrailleInfo() {
    return {
      data: this._navMap.cursor.isNodeType("datapoint") || this._navMap.cursor.isNodeType("series") ? JSON.stringify(this._store.model.atKey(
        this._navMap.cursor.options.seriesKey
      ).datapoints.map((e) => ({
        // XXX shouldn't assume x is string (or that we have an 'x' facet, for that matter)
        label: e.facetValue("x"),
        value: e.facetValueAsNumber("y")
      }))) : "0",
      isProportional: !0
    };
  }
  // TODO: localize this text output
  // focused view: e.options!.focus
  // all visited datapoint views: e.options!.visited
  queryData() {
    const e = [], r = this._navMap.cursor;
    if (r.isNodeType("top"))
      e.push(`Displaying Chart: ${this._store.title}`);
    else if (r.isNodeType("series")) {
      const n = r.options.seriesKey, i = this._store.model.atKey(n), s = i.length, o = i.getLabel();
      e.push(qn(
        ji.seriesLabelLength,
        { seriesLabel: o, datapointCount: s }
      ));
    } else if (r.isNodeType("datapoint")) {
      const n = this._store.selectedDatapoints, i = r.options.seriesKey, s = r.options.index, o = this._store.model.atKey(i).datapoints[s], a = this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(i, s);
      if (n.size) {
        const c = n.values().map((h) => {
          const d = rn(h);
          return this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(d.seriesKey, d.index);
        }).toArray(), p = L9(
          a,
          c
        );
        e.push(...p);
      } else {
        const c = this._store.model.atKey(i);
        e.push(qn(
          ji.percentageOfChart,
          {
            datapointX: Zu(o, "raw"),
            datapointIndex: r.options.index + 1,
            datapointCount: c.length
          }
        )), this._store.model.multi && e.push(qn(
          ji.percentageOfSeries,
          {
            seriesLabel: c.getLabel(),
            datapointX: Zu(o, "raw"),
            datapointIndex: r.options.index + 1,
            datapointCount: c.length
          }
        ));
      }
      const l = M9(
        this._store.model,
        o.facetValueAsNumber("y"),
        i
      );
      e.push(...l);
    }
    this._store.announce(e);
  }
}
var Z9e = Object.defineProperty, J9e = (t, e, r) => e in t ? Z9e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, rs = (t, e, r) => J9e(t, typeof e != "symbol" ? e + "" : e, r);
function X9e(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var zR = { exports: {} }, rx, VR;
function kU() {
  if (VR) return rx;
  VR = 1, rx = e;
  var t = +(Math.pow(2, 27) + 1);
  function e(r, n, i) {
    var s = r * n, o = t * r, a = o - r, l = o - a, c = r - l, p = t * n, h = p - n, d = p - h, b = n - d, m = s - l * d, w = m - c * d, f = w - l * b, E = c * b - f;
    return i ? (i[0] = E, i[1] = s, i) : [E, s];
  }
  return rx;
}
var nx, UR;
function eke() {
  if (UR) return nx;
  UR = 1, nx = e;
  function t(r, n) {
    var i = r + n, s = i - r, o = i - s, a = n - s, l = r - o, c = l + a;
    return c ? [c, i] : [i];
  }
  function e(r, n) {
    var i = r.length | 0, s = n.length | 0;
    if (i === 1 && s === 1)
      return t(r[0], n[0]);
    var o = i + s, a = new Array(o), l = 0, c = 0, p = 0, h = Math.abs, d = r[c], b = h(d), m = n[p], w = h(m), f, E;
    b < w ? (E = d, c += 1, c < i && (d = r[c], b = h(d))) : (E = m, p += 1, p < s && (m = n[p], w = h(m))), c < i && b < w || p >= s ? (f = d, c += 1, c < i && (d = r[c], b = h(d))) : (f = m, p += 1, p < s && (m = n[p], w = h(m)));
    for (var A = f + E, x = A - f, g = E - x, v = g, k = A, S, R, L, F, z; c < i && p < s; )
      b < w ? (f = d, c += 1, c < i && (d = r[c], b = h(d))) : (f = m, p += 1, p < s && (m = n[p], w = h(m))), E = v, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = k + A, R = S - k, L = S - R, F = A - R, z = k - L, v = z + F, k = S;
    for (; c < i; )
      f = d, E = v, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = k + A, R = S - k, L = S - R, F = A - R, z = k - L, v = z + F, k = S, c += 1, c < i && (d = r[c]);
    for (; p < s; )
      f = m, E = v, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = k + A, R = S - k, L = S - R, F = A - R, z = k - L, v = z + F, k = S, p += 1, p < s && (m = n[p]);
    return v && (a[l++] = v), k && (a[l++] = k), l || (a[l++] = 0), a.length = l, a;
  }
  return nx;
}
var ix, HR;
function tke() {
  if (HR) return ix;
  HR = 1, ix = t;
  function t(e, r, n) {
    var i = e + r, s = i - e, o = i - s, a = r - s, l = e - o;
    return n ? (n[0] = l + a, n[1] = i, n) : [l + a, i];
  }
  return ix;
}
var sx, GR;
function rke() {
  if (GR) return sx;
  GR = 1;
  var t = kU(), e = tke();
  sx = r;
  function r(n, i) {
    var s = n.length;
    if (s === 1) {
      var o = t(n[0], i);
      return o[0] ? o : [o[1]];
    }
    var a = new Array(2 * s), l = [0.1, 0.1], c = [0.1, 0.1], p = 0;
    t(n[0], i, l), l[0] && (a[p++] = l[0]);
    for (var h = 1; h < s; ++h) {
      t(n[h], i, c);
      var d = l[1];
      e(d, c[0], l), l[0] && (a[p++] = l[0]);
      var b = c[1], m = l[1], w = b + m, f = w - b, E = m - f;
      l[1] = w, E && (a[p++] = E);
    }
    return l[1] && (a[p++] = l[1]), p === 0 && (a[p++] = 0), a.length = p, a;
  }
  return sx;
}
var ox, WR;
function nke() {
  if (WR) return ox;
  WR = 1, ox = e;
  function t(r, n) {
    var i = r + n, s = i - r, o = i - s, a = n - s, l = r - o, c = l + a;
    return c ? [c, i] : [i];
  }
  function e(r, n) {
    var i = r.length | 0, s = n.length | 0;
    if (i === 1 && s === 1)
      return t(r[0], -n[0]);
    var o = i + s, a = new Array(o), l = 0, c = 0, p = 0, h = Math.abs, d = r[c], b = h(d), m = -n[p], w = h(m), f, E;
    b < w ? (E = d, c += 1, c < i && (d = r[c], b = h(d))) : (E = m, p += 1, p < s && (m = -n[p], w = h(m))), c < i && b < w || p >= s ? (f = d, c += 1, c < i && (d = r[c], b = h(d))) : (f = m, p += 1, p < s && (m = -n[p], w = h(m)));
    for (var A = f + E, x = A - f, g = E - x, v = g, k = A, S, R, L, F, z; c < i && p < s; )
      b < w ? (f = d, c += 1, c < i && (d = r[c], b = h(d))) : (f = m, p += 1, p < s && (m = -n[p], w = h(m))), E = v, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = k + A, R = S - k, L = S - R, F = A - R, z = k - L, v = z + F, k = S;
    for (; c < i; )
      f = d, E = v, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = k + A, R = S - k, L = S - R, F = A - R, z = k - L, v = z + F, k = S, c += 1, c < i && (d = r[c]);
    for (; p < s; )
      f = m, E = v, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = k + A, R = S - k, L = S - R, F = A - R, z = k - L, v = z + F, k = S, p += 1, p < s && (m = -n[p]);
    return v && (a[l++] = v), k && (a[l++] = k), l || (a[l++] = 0), a.length = l, a;
  }
  return ox;
}
var qR;
function ike() {
  return qR || (qR = 1, function(t) {
    var e = kU(), r = eke(), n = rke(), i = nke(), s = 5, o = 11102230246251565e-32, a = (3 + 16 * o) * o, l = (7 + 56 * o) * o;
    function c(x, g, v, k) {
      return function(S, R, L) {
        var F = x(x(g(R[1], L[0]), g(-L[1], R[0])), x(g(S[1], R[0]), g(-R[1], S[0]))), z = x(g(S[1], L[0]), g(-L[1], S[0])), j = k(F, z);
        return j[j.length - 1];
      };
    }
    function p(x, g, v, k) {
      return function(S, R, L, F) {
        var z = x(x(v(x(g(L[1], F[0]), g(-F[1], L[0])), R[2]), x(v(x(g(R[1], F[0]), g(-F[1], R[0])), -L[2]), v(x(g(R[1], L[0]), g(-L[1], R[0])), F[2]))), x(v(x(g(R[1], F[0]), g(-F[1], R[0])), S[2]), x(v(x(g(S[1], F[0]), g(-F[1], S[0])), -R[2]), v(x(g(S[1], R[0]), g(-R[1], S[0])), F[2])))), j = x(x(v(x(g(L[1], F[0]), g(-F[1], L[0])), S[2]), x(v(x(g(S[1], F[0]), g(-F[1], S[0])), -L[2]), v(x(g(S[1], L[0]), g(-L[1], S[0])), F[2]))), x(v(x(g(R[1], L[0]), g(-L[1], R[0])), S[2]), x(v(x(g(S[1], L[0]), g(-L[1], S[0])), -R[2]), v(x(g(S[1], R[0]), g(-R[1], S[0])), L[2])))), ee = k(z, j);
        return ee[ee.length - 1];
      };
    }
    function h(x, g, v, k) {
      return function(S, R, L, F, z) {
        var j = x(x(x(v(x(v(x(g(F[1], z[0]), g(-z[1], F[0])), L[2]), x(v(x(g(L[1], z[0]), g(-z[1], L[0])), -F[2]), v(x(g(L[1], F[0]), g(-F[1], L[0])), z[2]))), R[3]), x(v(x(v(x(g(F[1], z[0]), g(-z[1], F[0])), R[2]), x(v(x(g(R[1], z[0]), g(-z[1], R[0])), -F[2]), v(x(g(R[1], F[0]), g(-F[1], R[0])), z[2]))), -L[3]), v(x(v(x(g(L[1], z[0]), g(-z[1], L[0])), R[2]), x(v(x(g(R[1], z[0]), g(-z[1], R[0])), -L[2]), v(x(g(R[1], L[0]), g(-L[1], R[0])), z[2]))), F[3]))), x(v(x(v(x(g(L[1], F[0]), g(-F[1], L[0])), R[2]), x(v(x(g(R[1], F[0]), g(-F[1], R[0])), -L[2]), v(x(g(R[1], L[0]), g(-L[1], R[0])), F[2]))), -z[3]), x(v(x(v(x(g(F[1], z[0]), g(-z[1], F[0])), R[2]), x(v(x(g(R[1], z[0]), g(-z[1], R[0])), -F[2]), v(x(g(R[1], F[0]), g(-F[1], R[0])), z[2]))), S[3]), v(x(v(x(g(F[1], z[0]), g(-z[1], F[0])), S[2]), x(v(x(g(S[1], z[0]), g(-z[1], S[0])), -F[2]), v(x(g(S[1], F[0]), g(-F[1], S[0])), z[2]))), -R[3])))), x(x(v(x(v(x(g(R[1], z[0]), g(-z[1], R[0])), S[2]), x(v(x(g(S[1], z[0]), g(-z[1], S[0])), -R[2]), v(x(g(S[1], R[0]), g(-R[1], S[0])), z[2]))), F[3]), x(v(x(v(x(g(R[1], F[0]), g(-F[1], R[0])), S[2]), x(v(x(g(S[1], F[0]), g(-F[1], S[0])), -R[2]), v(x(g(S[1], R[0]), g(-R[1], S[0])), F[2]))), -z[3]), v(x(v(x(g(L[1], F[0]), g(-F[1], L[0])), R[2]), x(v(x(g(R[1], F[0]), g(-F[1], R[0])), -L[2]), v(x(g(R[1], L[0]), g(-L[1], R[0])), F[2]))), S[3]))), x(v(x(v(x(g(L[1], F[0]), g(-F[1], L[0])), S[2]), x(v(x(g(S[1], F[0]), g(-F[1], S[0])), -L[2]), v(x(g(S[1], L[0]), g(-L[1], S[0])), F[2]))), -R[3]), x(v(x(v(x(g(R[1], F[0]), g(-F[1], R[0])), S[2]), x(v(x(g(S[1], F[0]), g(-F[1], S[0])), -R[2]), v(x(g(S[1], R[0]), g(-R[1], S[0])), F[2]))), L[3]), v(x(v(x(g(R[1], L[0]), g(-L[1], R[0])), S[2]), x(v(x(g(S[1], L[0]), g(-L[1], S[0])), -R[2]), v(x(g(S[1], R[0]), g(-R[1], S[0])), L[2]))), -F[3]))))), ee = x(x(x(v(x(v(x(g(F[1], z[0]), g(-z[1], F[0])), L[2]), x(v(x(g(L[1], z[0]), g(-z[1], L[0])), -F[2]), v(x(g(L[1], F[0]), g(-F[1], L[0])), z[2]))), S[3]), v(x(v(x(g(F[1], z[0]), g(-z[1], F[0])), S[2]), x(v(x(g(S[1], z[0]), g(-z[1], S[0])), -F[2]), v(x(g(S[1], F[0]), g(-F[1], S[0])), z[2]))), -L[3])), x(v(x(v(x(g(L[1], z[0]), g(-z[1], L[0])), S[2]), x(v(x(g(S[1], z[0]), g(-z[1], S[0])), -L[2]), v(x(g(S[1], L[0]), g(-L[1], S[0])), z[2]))), F[3]), v(x(v(x(g(L[1], F[0]), g(-F[1], L[0])), S[2]), x(v(x(g(S[1], F[0]), g(-F[1], S[0])), -L[2]), v(x(g(S[1], L[0]), g(-L[1], S[0])), F[2]))), -z[3]))), x(x(v(x(v(x(g(L[1], z[0]), g(-z[1], L[0])), R[2]), x(v(x(g(R[1], z[0]), g(-z[1], R[0])), -L[2]), v(x(g(R[1], L[0]), g(-L[1], R[0])), z[2]))), S[3]), v(x(v(x(g(L[1], z[0]), g(-z[1], L[0])), S[2]), x(v(x(g(S[1], z[0]), g(-z[1], S[0])), -L[2]), v(x(g(S[1], L[0]), g(-L[1], S[0])), z[2]))), -R[3])), x(v(x(v(x(g(R[1], z[0]), g(-z[1], R[0])), S[2]), x(v(x(g(S[1], z[0]), g(-z[1], S[0])), -R[2]), v(x(g(S[1], R[0]), g(-R[1], S[0])), z[2]))), L[3]), v(x(v(x(g(R[1], L[0]), g(-L[1], R[0])), S[2]), x(v(x(g(S[1], L[0]), g(-L[1], S[0])), -R[2]), v(x(g(S[1], R[0]), g(-R[1], S[0])), L[2]))), -z[3])))), X = k(j, ee);
        return X[X.length - 1];
      };
    }
    function d(x) {
      var g = x === 3 ? c : x === 4 ? p : h;
      return g(r, e, n, i);
    }
    var b = d(3), m = d(4), w = [
      function() {
        return 0;
      },
      function() {
        return 0;
      },
      function(x, g) {
        return g[0] - x[0];
      },
      function(x, g, v) {
        var k = (x[1] - v[1]) * (g[0] - v[0]), S = (x[0] - v[0]) * (g[1] - v[1]), R = k - S, L;
        if (k > 0) {
          if (S <= 0)
            return R;
          L = k + S;
        } else if (k < 0) {
          if (S >= 0)
            return R;
          L = -(k + S);
        } else
          return R;
        var F = a * L;
        return R >= F || R <= -F ? R : b(x, g, v);
      },
      function(x, g, v, k) {
        var S = x[0] - k[0], R = g[0] - k[0], L = v[0] - k[0], F = x[1] - k[1], z = g[1] - k[1], j = v[1] - k[1], ee = x[2] - k[2], X = g[2] - k[2], ie = v[2] - k[2], ce = R * j, ke = L * z, ye = L * F, Ce = S * j, Ie = S * z, Te = R * F, ue = ee * (ce - ke) + X * (ye - Ce) + ie * (Ie - Te), O = (Math.abs(ce) + Math.abs(ke)) * Math.abs(ee) + (Math.abs(ye) + Math.abs(Ce)) * Math.abs(X) + (Math.abs(Ie) + Math.abs(Te)) * Math.abs(ie), N = l * O;
        return ue > N || -ue > N ? ue : m(x, g, v, k);
      }
    ];
    function f(x) {
      var g = w[x.length];
      return g || (g = w[x.length] = d(x.length)), g.apply(void 0, x);
    }
    function E(x, g, v, k, S, R, L) {
      return function(F, z, j, ee, X) {
        switch (arguments.length) {
          case 0:
          case 1:
            return 0;
          case 2:
            return k(F, z);
          case 3:
            return S(F, z, j);
          case 4:
            return R(F, z, j, ee);
          case 5:
            return L(F, z, j, ee, X);
        }
        for (var ie = new Array(arguments.length), ce = 0; ce < arguments.length; ++ce)
          ie[ce] = arguments[ce];
        return x(ie);
      };
    }
    function A() {
      for (; w.length <= s; )
        w.push(d(w.length));
      t.exports = E.apply(void 0, [f].concat(w));
      for (var x = 0; x <= s; ++x)
        t.exports[x] = w[x];
    }
    A();
  }(zR)), zR.exports;
}
var ske = ike();
const s1 = /* @__PURE__ */ X9e(ske);
function sE(t, e, r) {
  for (var n = e[0], i = e[1], s = t.length, o = 1, a = s, l = 0, c = s - 1; l < a; c = l++) {
    var p = t[l], h = t[c], d = p[1], b = h[1];
    if (b < d) {
      if (b < i && i < d) {
        var m = s1(p, h, e);
        if (Math.abs(m) < r)
          return 0;
        o ^= 0 < m | 0;
      } else if (i === d) {
        var w = t[(l + 1) % s], f = w[1];
        if (d < f) {
          var m = s1(p, h, e);
          if (m === 0)
            return 0;
          o ^= 0 < m | 0;
        }
      }
    } else if (d < b) {
      if (d < i && i < b) {
        var m = s1(p, h, e);
        if (m === 0)
          return 0;
        o ^= m < 0 | 0;
      } else if (i === d) {
        var w = t[(l + 1) % s], f = w[1];
        if (f < d) {
          var m = s1(p, h, e);
          if (m === 0)
            return 0;
          o ^= m < 0 | 0;
        }
      }
    } else if (i === d) {
      var E = Math.min(p[0], h[0]), A = Math.max(p[0], h[0]);
      if (l === 0) {
        for (; c > 0; ) {
          var x = (c + s - 1) % s, g = t[x];
          if (g[1] !== i)
            break;
          var v = g[0];
          E = Math.min(E, v), A = Math.max(A, v), c = x;
        }
        if (c === 0)
          return E <= n && n <= A ? 0 : 1;
        a = c + 1;
      }
      for (var k = t[(c + s - 1) % s][1]; l + 1 < a; ) {
        var g = t[l + 1];
        if (g[1] !== i)
          break;
        var v = g[0];
        E = Math.min(E, v), A = Math.max(A, v), l += 1;
      }
      if (E <= n && n <= A)
        return 0;
      var S = t[(l + 1) % s][1];
      n < E && k < i != S < i && (o ^= 1);
    }
  }
  return 2 * o - 1;
}
function oE(t) {
  let e = t.slice();
  return e.sort(ake), oke(e);
}
function oke(t) {
  if (t.length <= 1)
    return t.slice();
  let e = [];
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    for (; e.length >= 2; ) {
      const s = e[e.length - 1], o = e[e.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
        e.pop();
      else
        break;
    }
    e.push(i);
  }
  e.pop();
  let r = [];
  for (let n = t.length - 1; n >= 0; n--) {
    const i = t[n];
    for (; r.length >= 2; ) {
      const s = r[r.length - 1], o = r[r.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
        r.pop();
      else
        break;
    }
    r.push(i);
  }
  return r.pop(), e.length == 1 && r.length == 1 && e[0].x == r[0].x && e[0].y == r[0].y ? e : e.concat(r);
}
function ake(t, e) {
  return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0;
}
class lke {
  constructor(e, r, n, i, s) {
    rs(this, "dataset"), rs(this, "epsilon"), rs(this, "minPts"), rs(this, "distance"), rs(this, "forceIn"), rs(this, "clusters"), rs(this, "clusterCentroids"), rs(this, "noise"), rs(this, "noiseAssigned"), rs(this, "_visited"), rs(this, "_assigned"), rs(this, "_datasetLength"), this.dataset = e, this.epsilon = r, this.minPts = n, s || (s = this._euclideanDistance), this.distance = s, this.forceIn = i, this.clusters = [], this.clusterCentroids = [], this.noise = [], this.noiseAssigned = [], this._visited = [], this._assigned = [], this._datasetLength = e.length, this.run(e, r, n, i, s);
  }
  /******************************************************************************/
  // public functions
  /**
   * Start clustering
   *
   * @param {Array} dataset
   * @param {number} epsilon
   * @param {number} minPts
   * @param {function} distanceFunction
   * @param {boolean} distanceFunction
   * @returns {undefined}
   * @access public
   */
  run(e, r, n, i, s) {
    this._init(e, r, n, i, s);
    for (var o = 0; o < this._datasetLength; o++)
      if (this._visited[o] !== 1) {
        this._visited[o] = 1;
        var a = this._regionQuery(o);
        if (a.length < this.minPts)
          this.noise.push(o);
        else {
          var l = this.clusters.length;
          this.clusters.push([]), this._addToCluster(o, l), this._expandCluster(l, a);
        }
      }
    for (var c = Math.log(this.dataset.length), l = 0; l < this.clusters.length; l++) {
      var p = this.clusters[l];
      if (p.length < c) {
        for (var o = 0; o < p.length; o++)
          this.noise.push(p[o]);
        this.clusters[l] = [];
      }
    }
    this.clusters = this.clusters.filter((m) => m.length > 0);
    for (var h = 0; h < this.clusters.length; h++)
      this.clusterCentroids.push(this._centroid(this.clusters[h]));
    let d = [];
    for (let m = 0; m < this._datasetLength; m++)
      d.push(0);
    for (let m = 0; m < this.clusters.length; m++)
      for (let w of this.clusters[m])
        d[w] = Number(m);
    let b = [];
    for (let m of this.noise) {
      let w = this._nearestAssignedNeighbor(this.clusters.flat(), m);
      b.push([m, Number(d[w])]);
    }
    if (this.forceIn) {
      this.noiseAssigned = [];
      for (let m = 0; m < b.length; m++) {
        let w = b[m];
        this.noiseAssigned.push([w[0], w[1]]), this._addToCluster(w[0], w[1]), d[w[0]] = w[1];
      }
      this.noise = [];
    } else {
      this.noiseAssigned = [];
      for (let m = 0; m < b.length; m++) {
        let w = b[m];
        this.noiseAssigned.push([w[0], w[1]]), d[w[0]] = w[1];
      }
    }
    return this.clusters;
  }
  /******************************************************************************/
  // protected functions
  /**
   * Set object properties
   *
   * @param {Array} dataset
   * @param {number} epsilon
   * @param {number} minPts
   * @param {function} distance
   * @param {boolean} forceIn
   * @returns {undefined}
   * @access protected
   */
  _init(e, r, n, i, s) {
    if (e) {
      if (!(e instanceof Array))
        throw Error("Dataset must be of type array, " + typeof e + " given");
      this.dataset = e, this.clusters = [], this.noise = [], this._datasetLength = e.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength);
    }
    r && (this.epsilon = r), n && (this.minPts = n), s && (this.distance = s), i && (this.forceIn = i);
  }
  /**
   * Expand cluster to closest points of given neighborhood
   *
   * @param {number} clusterId
   * @param {Array} neighbors
   * @returns {undefined}
   * @access protected
   */
  _expandCluster(e, r) {
    for (var n = 0; n < r.length; n++) {
      var i = r[n];
      if (this._visited[i] !== 1) {
        this._visited[i] = 1;
        var s = this._regionQuery(i);
        s.length >= this.minPts && (r = this._mergeArrays(r, s));
      }
      this._assigned[i] !== 1 && (this._addToCluster(i, e), this.noise.indexOf(i) > -1 && this.noise.splice(this.noise.indexOf(i), 1));
    }
  }
  /**
   * Add new point to cluster
   *
   * @param {number} pointId
   * @param {number} clusterId
   */
  _addToCluster(e, r) {
    this.clusters[r].push(e), this._assigned[e] = 1;
  }
  /**
   * Find all neighbors around given point
   *
   * @param {number} pointId,
   * @param {number} epsilon
   * @returns {Array}
   * @access protected
   */
  _regionQuery(e) {
    let r = [];
    for (var n = 0; n < this._datasetLength; n++) {
      var i = this.distance(this.dataset[e], this.dataset[n]);
      i < this.epsilon && r.push(n);
    }
    return r;
  }
  /******************************************************************************/
  // helpers
  /**
   * @param {Array} a
   * @param {Array} b
   * @returns {Array}
   * @access protected
   */
  _mergeArrays(e, r) {
    for (var n = r.length, i = 0; i < n; i++) {
      var s = r[i];
      e.indexOf(s) < 0 && e.push(s);
    }
    return e;
  }
  /**
   * Calculate euclidean distance in multidimensional space
   *
   * @param {Array} p
   * @param {Array} q
   * @returns {number}
   * @access protected
   */
  _euclideanDistance(e, r) {
    for (var n = 0, i = Math.min(e.length, r.length); i--; )
      n += (e[i] - r[i]) * (e[i] - r[i]);
    return Math.sqrt(n);
  }
  /**
   * Calculate centroid of a group of points
   *
   * @param {Array} c
   * @returns {Array}
   * @access protected
   */
  _centroid(e) {
    let r = 0, n = 0;
    const i = e.length;
    for (let s of e)
      r += this.dataset[s][0], n += this.dataset[s][1];
    return [r / i, n / i];
  }
  /**
  * Given a list of clustered points and an outlier, returns the closest clustered point.
  *
  * @param {Array} datasetIds
  * @param {number} pointId
  * @returns {number}
  * @access protected
  */
  _nearestAssignedNeighbor(e, r) {
    var n = [0, 0];
    for (var i of e) {
      n[1] == 0 && (n = [i, this.distance(this.dataset[r], this.dataset[i])]);
      let s = this.distance(this.dataset[r], this.dataset[i]);
      n[1] > s && (n = [i, s]);
    }
    return n[0];
  }
}
/*!
Copyright (C) 2010-2013 Raymond Hill: https://github.com/gorhill/Javascript-Voronoi
MIT License: See https://github.com/gorhill/Javascript-Voronoi/LICENSE.md
*/
function pt() {
  this.vertices = null, this.edges = null, this.cells = null, this.toRecycle = null, this.beachsectionJunkyard = [], this.circleEventJunkyard = [], this.vertexJunkyard = [], this.edgeJunkyard = [], this.cellJunkyard = [];
}
pt.prototype.reset = function() {
  if (this.beachline || (this.beachline = new this.RBTree()), this.beachline.root)
    for (var t = this.beachline.getFirst(this.beachline.root); t; )
      this.beachsectionJunkyard.push(t), t = t.rbNext;
  this.beachline.root = null, this.circleEvents || (this.circleEvents = new this.RBTree()), this.circleEvents.root = this.firstCircleEvent = null, this.vertices = [], this.edges = [], this.cells = [];
};
pt.prototype.sqrt = Math.sqrt;
pt.prototype.abs = Math.abs;
pt.prototype. = pt. = 1e-9;
pt.prototype.inv = pt.inv = 1 / pt.;
pt.prototype.equalWithEpsilon = function(t, e) {
  return this.abs(t - e) < 1e-9;
};
pt.prototype.greaterThanWithEpsilon = function(t, e) {
  return t - e > 1e-9;
};
pt.prototype.greaterThanOrEqualWithEpsilon = function(t, e) {
  return e - t < 1e-9;
};
pt.prototype.lessThanWithEpsilon = function(t, e) {
  return e - t > 1e-9;
};
pt.prototype.lessThanOrEqualWithEpsilon = function(t, e) {
  return t - e < 1e-9;
};
pt.prototype.RBTree = function() {
  this.root = null;
};
pt.prototype.RBTree.prototype.rbInsertSuccessor = function(t, e) {
  var r;
  if (t) {
    if (e.rbPrevious = t, e.rbNext = t.rbNext, t.rbNext && (t.rbNext.rbPrevious = e), t.rbNext = e, t.rbRight) {
      for (t = t.rbRight; t.rbLeft; )
        t = t.rbLeft;
      t.rbLeft = e;
    } else
      t.rbRight = e;
    r = t;
  } else this.root ? (t = this.getFirst(this.root), e.rbPrevious = null, e.rbNext = t, t.rbPrevious = e, t.rbLeft = e, r = t) : (e.rbPrevious = e.rbNext = null, this.root = e, r = null);
  e.rbLeft = e.rbRight = null, e.rbParent = r, e.rbRed = !0;
  var n, i;
  for (t = e; r && r.rbRed; )
    n = r.rbParent, r === n.rbLeft ? (i = n.rbRight, i && i.rbRed ? (r.rbRed = i.rbRed = !1, n.rbRed = !0, t = n) : (t === r.rbRight && (this.rbRotateLeft(r), t = r, r = t.rbParent), r.rbRed = !1, n.rbRed = !0, this.rbRotateRight(n))) : (i = n.rbLeft, i && i.rbRed ? (r.rbRed = i.rbRed = !1, n.rbRed = !0, t = n) : (t === r.rbLeft && (this.rbRotateRight(r), t = r, r = t.rbParent), r.rbRed = !1, n.rbRed = !0, this.rbRotateLeft(n))), r = t.rbParent;
  this.root.rbRed = !1;
};
pt.prototype.RBTree.prototype.rbRemoveNode = function(t) {
  t.rbNext && (t.rbNext.rbPrevious = t.rbPrevious), t.rbPrevious && (t.rbPrevious.rbNext = t.rbNext), t.rbNext = t.rbPrevious = null;
  var e = t.rbParent, r = t.rbLeft, n = t.rbRight, i;
  r ? n ? i = this.getFirst(n) : i = r : i = n, e ? e.rbLeft === t ? e.rbLeft = i : e.rbRight = i : this.root = i;
  var s;
  if (r && n ? (s = i.rbRed, i.rbRed = t.rbRed, i.rbLeft = r, r.rbParent = i, i !== n ? (e = i.rbParent, i.rbParent = t.rbParent, t = i.rbRight, e.rbLeft = t, i.rbRight = n, n.rbParent = i) : (i.rbParent = e, e = i, t = i.rbRight)) : (s = t.rbRed, t = i), t && (t.rbParent = e), !s) {
    if (t && t.rbRed) {
      t.rbRed = !1;
      return;
    }
    var o;
    do {
      if (t === this.root)
        break;
      if (t === e.rbLeft) {
        if (o = e.rbRight, o.rbRed && (o.rbRed = !1, e.rbRed = !0, this.rbRotateLeft(e), o = e.rbRight), o.rbLeft && o.rbLeft.rbRed || o.rbRight && o.rbRight.rbRed) {
          (!o.rbRight || !o.rbRight.rbRed) && (o.rbLeft.rbRed = !1, o.rbRed = !0, this.rbRotateRight(o), o = e.rbRight), o.rbRed = e.rbRed, e.rbRed = o.rbRight.rbRed = !1, this.rbRotateLeft(e), t = this.root;
          break;
        }
      } else if (o = e.rbLeft, o.rbRed && (o.rbRed = !1, e.rbRed = !0, this.rbRotateRight(e), o = e.rbLeft), o.rbLeft && o.rbLeft.rbRed || o.rbRight && o.rbRight.rbRed) {
        (!o.rbLeft || !o.rbLeft.rbRed) && (o.rbRight.rbRed = !1, o.rbRed = !0, this.rbRotateLeft(o), o = e.rbLeft), o.rbRed = e.rbRed, e.rbRed = o.rbLeft.rbRed = !1, this.rbRotateRight(e), t = this.root;
        break;
      }
      o.rbRed = !0, t = e, e = e.rbParent;
    } while (!t.rbRed);
    t && (t.rbRed = !1);
  }
};
pt.prototype.RBTree.prototype.rbRotateLeft = function(t) {
  var e = t, r = t.rbRight, n = e.rbParent;
  n ? n.rbLeft === e ? n.rbLeft = r : n.rbRight = r : this.root = r, r.rbParent = n, e.rbParent = r, e.rbRight = r.rbLeft, e.rbRight && (e.rbRight.rbParent = e), r.rbLeft = e;
};
pt.prototype.RBTree.prototype.rbRotateRight = function(t) {
  var e = t, r = t.rbLeft, n = e.rbParent;
  n ? n.rbLeft === e ? n.rbLeft = r : n.rbRight = r : this.root = r, r.rbParent = n, e.rbParent = r, e.rbLeft = r.rbRight, e.rbLeft && (e.rbLeft.rbParent = e), r.rbRight = e;
};
pt.prototype.RBTree.prototype.getFirst = function(t) {
  for (; t.rbLeft; )
    t = t.rbLeft;
  return t;
};
pt.prototype.RBTree.prototype.getLast = function(t) {
  for (; t.rbRight; )
    t = t.rbRight;
  return t;
};
pt.prototype.Diagram = function(t) {
  this.site = t;
};
pt.prototype.Cell = function(t) {
  this.site = t, this.halfedges = [], this.closeMe = !1;
};
pt.prototype.Cell.prototype.init = function(t) {
  return this.site = t, this.halfedges = [], this.closeMe = !1, this;
};
pt.prototype.createCell = function(t) {
  var e = this.cellJunkyard.pop();
  return e ? e.init(t) : new this.Cell(t);
};
pt.prototype.Cell.prototype.prepareHalfedges = function() {
  for (var t = this.halfedges, e = t.length, r; e--; )
    r = t[e].edge, (!r.vb || !r.va) && t.splice(e, 1);
  return t.sort(function(n, i) {
    return i.angle - n.angle;
  }), t.length;
};
pt.prototype.Cell.prototype.getNeighborIds = function() {
  for (var t = [], e = this.halfedges.length, r; e--; )
    r = this.halfedges[e].edge, r.lSite !== null && r.lSite.voronoiId != this.site.voronoiId ? t.push(r.lSite.voronoiId) : r.rSite !== null && r.rSite.voronoiId != this.site.voronoiId && t.push(r.rSite.voronoiId);
  return t;
};
pt.prototype.Cell.prototype.getBbox = function() {
  for (var t = this.halfedges, e = t.length, r = 1 / 0, n = 1 / 0, i = -1 / 0, s = -1 / 0, o, a, l; e--; )
    o = t[e].getStartpoint(), a = o.x, l = o.y, a < r && (r = a), l < n && (n = l), a > i && (i = a), l > s && (s = l);
  return {
    x: r,
    y: n,
    width: i - r,
    height: s - n
  };
};
pt.prototype.Cell.prototype.pointIntersection = function(t, e) {
  for (var r = this.halfedges, n = r.length, i, s, o, a; n--; ) {
    if (i = r[n], s = i.getStartpoint(), o = i.getEndpoint(), a = (e - s.y) * (o.x - s.x) - (t - s.x) * (o.y - s.y), !a)
      return 0;
    if (a > 0)
      return -1;
  }
  return 1;
};
pt.prototype.Vertex = function(t, e) {
  this.x = t, this.y = e;
};
pt.prototype.Edge = function(t, e) {
  this.lSite = t, this.rSite = e, this.va = this.vb = null;
};
pt.prototype.Halfedge = function(t, e, r) {
  if (this.site = e, this.edge = t, r)
    this.angle = Math.atan2(r.y - e.y, r.x - e.x);
  else {
    var n = t.va, i = t.vb;
    this.angle = t.lSite === e ? Math.atan2(i.x - n.x, n.y - i.y) : Math.atan2(n.x - i.x, i.y - n.y);
  }
};
pt.prototype.createHalfedge = function(t, e, r) {
  return new this.Halfedge(t, e, r);
};
pt.prototype.Halfedge.prototype.getStartpoint = function() {
  return this.edge.lSite === this.site ? this.edge.va : this.edge.vb;
};
pt.prototype.Halfedge.prototype.getEndpoint = function() {
  return this.edge.lSite === this.site ? this.edge.vb : this.edge.va;
};
pt.prototype.createVertex = function(t, e) {
  var r = this.vertexJunkyard.pop();
  return r ? (r.x = t, r.y = e) : r = new this.Vertex(t, e), this.vertices.push(r), r;
};
pt.prototype.createEdge = function(t, e, r, n) {
  var i = this.edgeJunkyard.pop();
  return i ? (i.lSite = t, i.rSite = e, i.va = i.vb = null) : i = new this.Edge(t, e), this.edges.push(i), r && this.setEdgeStartpoint(i, t, e, r), n && this.setEdgeEndpoint(i, t, e, n), this.cells[t.voronoiId].halfedges.push(this.createHalfedge(i, t, e)), this.cells[e.voronoiId].halfedges.push(this.createHalfedge(i, e, t)), i;
};
pt.prototype.createBorderEdge = function(t, e, r) {
  var n = this.edgeJunkyard.pop();
  return n ? (n.lSite = t, n.rSite = null) : n = new this.Edge(t, null), n.va = e, n.vb = r, this.edges.push(n), n;
};
pt.prototype.setEdgeStartpoint = function(t, e, r, n) {
  !t.va && !t.vb ? (t.va = n, t.lSite = e, t.rSite = r) : t.lSite === r ? t.vb = n : t.va = n;
};
pt.prototype.setEdgeEndpoint = function(t, e, r, n) {
  this.setEdgeStartpoint(t, r, e, n);
};
pt.prototype.Beachsection = function() {
};
pt.prototype.createBeachsection = function(t) {
  var e = this.beachsectionJunkyard.pop();
  return e || (e = new this.Beachsection()), e.site = t, e;
};
pt.prototype.leftBreakPoint = function(t, e) {
  var r = t.site, n = r.x, i = r.y, s = i - e;
  if (!s)
    return n;
  var o = t.rbPrevious;
  if (!o)
    return -1 / 0;
  r = o.site;
  var a = r.x, l = r.y, c = l - e;
  if (!c)
    return a;
  var p = a - n, h = 1 / s - 1 / c, d = p / c;
  return h ? (-d + this.sqrt(d * d - 2 * h * (p * p / (-2 * c) - l + c / 2 + i - s / 2))) / h + n : (n + a) / 2;
};
pt.prototype.rightBreakPoint = function(t, e) {
  var r = t.rbNext;
  if (r)
    return this.leftBreakPoint(r, e);
  var n = t.site;
  return n.y === e ? n.x : 1 / 0;
};
pt.prototype.detachBeachsection = function(t) {
  this.detachCircleEvent(t), this.beachline.rbRemoveNode(t), this.beachsectionJunkyard.push(t);
};
pt.prototype.removeBeachsection = function(t) {
  var e = t.circleEvent, r = e.x, n = e.ycenter, i = this.createVertex(r, n), s = t.rbPrevious, o = t.rbNext, a = [t], l = Math.abs;
  this.detachBeachsection(t);
  for (var c = s; c.circleEvent && l(r - c.circleEvent.x) < 1e-9 && l(n - c.circleEvent.ycenter) < 1e-9; )
    s = c.rbPrevious, a.unshift(c), this.detachBeachsection(c), c = s;
  a.unshift(c), this.detachCircleEvent(c);
  for (var p = o; p.circleEvent && l(r - p.circleEvent.x) < 1e-9 && l(n - p.circleEvent.ycenter) < 1e-9; )
    o = p.rbNext, a.push(p), this.detachBeachsection(p), p = o;
  a.push(p), this.detachCircleEvent(p);
  var h = a.length, d;
  for (d = 1; d < h; d++)
    p = a[d], c = a[d - 1], this.setEdgeStartpoint(p.edge, c.site, p.site, i);
  c = a[0], p = a[h - 1], p.edge = this.createEdge(c.site, p.site, void 0, i), this.attachCircleEvent(c), this.attachCircleEvent(p);
};
pt.prototype.addBeachsection = function(t) {
  for (var e = t.x, r = t.y, n, i, s, o, a = this.beachline.root; a; )
    if (s = this.leftBreakPoint(a, r) - e, s > 1e-9)
      a = a.rbLeft;
    else if (o = e - this.rightBreakPoint(a, r), o > 1e-9) {
      if (!a.rbRight) {
        n = a;
        break;
      }
      a = a.rbRight;
    } else {
      s > -1e-9 ? (n = a.rbPrevious, i = a) : o > -1e-9 ? (n = a, i = a.rbNext) : n = i = a;
      break;
    }
  var l = this.createBeachsection(t);
  if (this.beachline.rbInsertSuccessor(n, l), !(!n && !i)) {
    if (n === i) {
      this.detachCircleEvent(n), i = this.createBeachsection(n.site), this.beachline.rbInsertSuccessor(l, i), l.edge = i.edge = this.createEdge(n.site, l.site), this.attachCircleEvent(n), this.attachCircleEvent(i);
      return;
    }
    if (n && !i) {
      l.edge = this.createEdge(n.site, l.site);
      return;
    }
    if (n !== i) {
      this.detachCircleEvent(n), this.detachCircleEvent(i);
      var c = n.site, p = c.x, h = c.y, d = t.x - p, b = t.y - h, m = i.site, w = m.x - p, f = m.y - h, E = 2 * (d * f - b * w), A = d * d + b * b, x = w * w + f * f, g = this.createVertex((f * A - b * x) / E + p, (d * x - w * A) / E + h);
      this.setEdgeStartpoint(i.edge, c, m, g), l.edge = this.createEdge(c, t, void 0, g), i.edge = this.createEdge(t, m, void 0, g), this.attachCircleEvent(n), this.attachCircleEvent(i);
      return;
    }
  }
};
pt.prototype.CircleEvent = function() {
  this.arc = null, this.rbLeft = null, this.rbNext = null, this.rbParent = null, this.rbPrevious = null, this.rbRed = !1, this.rbRight = null, this.site = null, this.x = this.y = this.ycenter = 0;
};
pt.prototype.attachCircleEvent = function(t) {
  var e = t.rbPrevious, r = t.rbNext;
  if (!(!e || !r)) {
    var n = e.site, i = t.site, s = r.site;
    if (n !== s) {
      var o = i.x, a = i.y, l = n.x - o, c = n.y - a, p = s.x - o, h = s.y - a, d = 2 * (l * h - c * p);
      if (!(d >= -2e-12)) {
        var b = l * l + c * c, m = p * p + h * h, w = (h * b - c * m) / d, f = (l * m - p * b) / d, E = f + a, A = this.circleEventJunkyard.pop();
        A || (A = new this.CircleEvent()), A.arc = t, A.site = i, A.x = w + o, A.y = E + this.sqrt(w * w + f * f), A.ycenter = E, t.circleEvent = A;
        for (var x = null, g = this.circleEvents.root; g; )
          if (A.y < g.y || A.y === g.y && A.x <= g.x)
            if (g.rbLeft)
              g = g.rbLeft;
            else {
              x = g.rbPrevious;
              break;
            }
          else if (g.rbRight)
            g = g.rbRight;
          else {
            x = g;
            break;
          }
        this.circleEvents.rbInsertSuccessor(x, A), x || (this.firstCircleEvent = A);
      }
    }
  }
};
pt.prototype.detachCircleEvent = function(t) {
  var e = t.circleEvent;
  e && (e.rbPrevious || (this.firstCircleEvent = e.rbNext), this.circleEvents.rbRemoveNode(e), this.circleEventJunkyard.push(e), t.circleEvent = null);
};
pt.prototype.connectEdge = function(t, e) {
  var r = t.vb;
  if (r)
    return !0;
  var n = t.va, i = e.xl, s = e.xr, o = e.yt, a = e.yb, l = t.lSite, c = t.rSite, p = l.x, h = l.y, d = c.x, b = c.y, m = (p + d) / 2, w = (h + b) / 2, f, E;
  if (this.cells[l.voronoiId].closeMe = !0, this.cells[c.voronoiId].closeMe = !0, b !== h && (f = (p - d) / (b - h), E = w - f * m), f === void 0) {
    if (m < i || m >= s)
      return !1;
    if (p > d) {
      if (!n || n.y < o)
        n = this.createVertex(m, o);
      else if (n.y >= a)
        return !1;
      r = this.createVertex(m, a);
    } else {
      if (!n || n.y > a)
        n = this.createVertex(m, a);
      else if (n.y < o)
        return !1;
      r = this.createVertex(m, o);
    }
  } else if (f < -1 || f > 1)
    if (p > d) {
      if (!n || n.y < o)
        n = this.createVertex((o - E) / f, o);
      else if (n.y >= a)
        return !1;
      r = this.createVertex((a - E) / f, a);
    } else {
      if (!n || n.y > a)
        n = this.createVertex((a - E) / f, a);
      else if (n.y < o)
        return !1;
      r = this.createVertex((o - E) / f, o);
    }
  else if (h < b) {
    if (!n || n.x < i)
      n = this.createVertex(i, f * i + E);
    else if (n.x >= s)
      return !1;
    r = this.createVertex(s, f * s + E);
  } else {
    if (!n || n.x > s)
      n = this.createVertex(s, f * s + E);
    else if (n.x < i)
      return !1;
    r = this.createVertex(i, f * i + E);
  }
  return t.va = n, t.vb = r, !0;
};
pt.prototype.clipEdge = function(t, e) {
  var r = t.va.x, n = t.va.y, i = t.vb.x, s = t.vb.y, o = 0, a = 1, l = i - r, c = s - n, p = r - e.xl;
  if (l === 0 && p < 0)
    return !1;
  var h = -p / l;
  if (l < 0) {
    if (h < o)
      return !1;
    h < a && (a = h);
  } else if (l > 0) {
    if (h > a)
      return !1;
    h > o && (o = h);
  }
  if (p = e.xr - r, l === 0 && p < 0)
    return !1;
  if (h = p / l, l < 0) {
    if (h > a)
      return !1;
    h > o && (o = h);
  } else if (l > 0) {
    if (h < o)
      return !1;
    h < a && (a = h);
  }
  if (p = n - e.yt, c === 0 && p < 0)
    return !1;
  if (h = -p / c, c < 0) {
    if (h < o)
      return !1;
    h < a && (a = h);
  } else if (c > 0) {
    if (h > a)
      return !1;
    h > o && (o = h);
  }
  if (p = e.yb - n, c === 0 && p < 0)
    return !1;
  if (h = p / c, c < 0) {
    if (h > a)
      return !1;
    h > o && (o = h);
  } else if (c > 0) {
    if (h < o)
      return !1;
    h < a && (a = h);
  }
  return o > 0 && (t.va = this.createVertex(r + o * l, n + o * c)), a < 1 && (t.vb = this.createVertex(r + a * l, n + a * c)), (o > 0 || a < 1) && (this.cells[t.lSite.voronoiId].closeMe = !0, this.cells[t.rSite.voronoiId].closeMe = !0), !0;
};
pt.prototype.clipEdges = function(t) {
  for (var e = this.edges, r = e.length, n, i = Math.abs; r--; )
    n = e[r], (!this.connectEdge(n, t) || !this.clipEdge(n, t) || i(n.va.x - n.vb.x) < 1e-9 && i(n.va.y - n.vb.y) < 1e-9) && (n.va = n.vb = null, e.splice(r, 1));
};
pt.prototype.closeCells = function(t) {
  for (var e = t.xl, r = t.xr, n = t.yt, i = t.yb, s = this.cells, o = s.length, a, l, c, p, h, d, b, m, w, f = Math.abs; o--; )
    if (a = s[o], !!a.prepareHalfedges() && a.closeMe) {
      for (c = a.halfedges, p = c.length, l = 0; l < p; ) {
        if (d = c[l].getEndpoint(), m = c[(l + 1) % p].getStartpoint(), f(d.x - m.x) >= 1e-9 || f(d.y - m.y) >= 1e-9)
          switch (!0) {
            case (this.equalWithEpsilon(d.x, e) && this.lessThanWithEpsilon(d.y, i)):
              if (w = this.equalWithEpsilon(m.x, e), b = this.createVertex(e, w ? m.y : i), h = this.createBorderEdge(a.site, d, b), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, w)
                break;
              d = b;
            case (this.equalWithEpsilon(d.y, i) && this.lessThanWithEpsilon(d.x, r)):
              if (w = this.equalWithEpsilon(m.y, i), b = this.createVertex(w ? m.x : r, i), h = this.createBorderEdge(a.site, d, b), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, w)
                break;
              d = b;
            case (this.equalWithEpsilon(d.x, r) && this.greaterThanWithEpsilon(d.y, n)):
              if (w = this.equalWithEpsilon(m.x, r), b = this.createVertex(r, w ? m.y : n), h = this.createBorderEdge(a.site, d, b), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, w)
                break;
              d = b;
            case (this.equalWithEpsilon(d.y, n) && this.greaterThanWithEpsilon(d.x, e)):
              if (w = this.equalWithEpsilon(m.y, n), b = this.createVertex(w ? m.x : e, n), h = this.createBorderEdge(a.site, d, b), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, w || (d = b, w = this.equalWithEpsilon(m.x, e), b = this.createVertex(e, w ? m.y : i), h = this.createBorderEdge(a.site, d, b), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, w) || (d = b, w = this.equalWithEpsilon(m.y, i), b = this.createVertex(w ? m.x : r, i), h = this.createBorderEdge(a.site, d, b), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, w) || (d = b, w = this.equalWithEpsilon(m.x, r), b = this.createVertex(r, w ? m.y : n), h = this.createBorderEdge(a.site, d, b), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, w))
                break;
            default:
              throw "Voronoi.closeCells() > this makes no sense!";
          }
        l++;
      }
      a.closeMe = !1;
    }
};
pt.prototype.quantizeSites = function(t) {
  for (var e = this., r = t.length, n; r--; )
    n = t[r], n.x = Math.floor(n.x / e) * e, n.y = Math.floor(n.y / e) * e;
};
pt.prototype.recycle = function(t) {
  if (t)
    if (t instanceof this.Diagram)
      this.toRecycle = t;
    else
      throw "Voronoi.recycleDiagram() > Need a Diagram object.";
};
pt.prototype.compute = function(t, e) {
  var r = /* @__PURE__ */ new Date();
  this.reset(), this.toRecycle && (this.vertexJunkyard = this.vertexJunkyard.concat(this.toRecycle.vertices), this.edgeJunkyard = this.edgeJunkyard.concat(this.toRecycle.edges), this.cellJunkyard = this.cellJunkyard.concat(this.toRecycle.cells), this.toRecycle = null);
  var n = t.slice(0);
  n.sort(function(d, b) {
    var m = b.y - d.y;
    return m || b.x - d.x;
  });
  for (var i = n.pop(), s = 0, o, a, l = this.cells, c; ; )
    if (c = this.firstCircleEvent, i && (!c || i.y < c.y || i.y === c.y && i.x < c.x))
      (i.x !== o || i.y !== a) && (l[s] = this.createCell(i), i.voronoiId = s++, this.addBeachsection(i), a = i.y, o = i.x), i = n.pop();
    else if (c)
      this.removeBeachsection(c.arc);
    else
      break;
  this.clipEdges(e), this.closeCells(e);
  var p = /* @__PURE__ */ new Date(), h = new this.Diagram();
  return h.cells = this.cells, h.edges = this.edges, h.vertices = this.vertices, h.execTime = p.getTime() - r.getTime(), this.reset(), h;
};
typeof module < "u" && (module.exports = pt);
/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function cke(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(p) {
      return l([c, p]);
    };
  }
  function l(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
      switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
        case 0:
        case 1:
          s = c;
          break;
        case 4:
          return r.label++, { value: c[1], done: !1 };
        case 5:
          r.label++, i = c[1], c = [0];
          continue;
        case 7:
          c = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            r = 0;
            continue;
          }
          if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
            r.label = c[1];
            break;
          }
          if (c[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = c;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(c);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      c = e.call(t, r);
    } catch (p) {
      c = [6, p], i = 0;
    } finally {
      n = s = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
var hc = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r) {
      this.next = null, this.key = e, this.data = r, this.left = null, this.right = null;
    }
    return t;
  }()
);
function uke(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}
function Il(t, e, r) {
  for (var n = new hc(null, null), i = n, s = n; ; ) {
    var o = r(t, e.key);
    if (o < 0) {
      if (e.left === null)
        break;
      if (r(t, e.left.key) < 0) {
        var a = e.left;
        if (e.left = a.right, a.right = e, e = a, e.left === null)
          break;
      }
      s.left = e, s = e, e = e.left;
    } else if (o > 0) {
      if (e.right === null)
        break;
      if (r(t, e.right.key) > 0) {
        var a = e.right;
        if (e.right = a.left, a.left = e, e = a, e.right === null)
          break;
      }
      i.right = e, i = e, e = e.right;
    } else
      break;
  }
  return i.right = e.left, s.left = e.right, e.left = n.right, e.right = n.left, e;
}
function ax(t, e, r, n) {
  var i = new hc(t, e);
  if (r === null)
    return i.left = i.right = null, i;
  r = Il(t, r, n);
  var s = n(t, r.key);
  return s < 0 ? (i.left = r.left, i.right = r, r.left = null) : s >= 0 && (i.right = r.right, i.left = r, r.right = null), i;
}
function QR(t, e, r) {
  var n = null, i = null;
  if (e) {
    e = Il(t, e, r);
    var s = r(e.key, t);
    s === 0 ? (n = e.left, i = e.right) : s < 0 ? (i = e.right, e.right = null, n = e) : (n = e.left, e.left = null, i = e);
  }
  return { left: n, right: i };
}
function hke(t, e, r) {
  return e === null ? t : (t === null || (e = Il(t.key, e, r), e.left = t), e);
}
function aE(t, e, r, n, i) {
  if (t) {
    n("" + e + (r ? " " : " ") + i(t) + `
`);
    var s = e + (r ? "    " : "   ");
    t.left && aE(t.left, s, !1, n, i), t.right && aE(t.right, s, !0, n, i);
  }
}
var N9 = (
  /** @class */
  function() {
    function t(e) {
      e === void 0 && (e = uke), this._root = null, this._size = 0, this._comparator = e;
    }
    return t.prototype.insert = function(e, r) {
      return this._size++, this._root = ax(e, r, this._root, this._comparator);
    }, t.prototype.add = function(e, r) {
      var n = new hc(e, r);
      this._root === null && (n.left = n.right = null, this._size++, this._root = n);
      var i = this._comparator, s = Il(e, this._root, i), o = i(e, s.key);
      return o === 0 ? this._root = s : (o < 0 ? (n.left = s.left, n.right = s, s.left = null) : o > 0 && (n.right = s.right, n.left = s, s.right = null), this._size++, this._root = n), this._root;
    }, t.prototype.remove = function(e) {
      this._root = this._remove(e, this._root, this._comparator);
    }, t.prototype._remove = function(e, r, n) {
      var i;
      if (r === null)
        return null;
      r = Il(e, r, n);
      var s = n(e, r.key);
      return s === 0 ? (r.left === null ? i = r.right : (i = Il(e, r.left, n), i.right = r.right), this._size--, i) : r;
    }, t.prototype.pop = function() {
      var e = this._root;
      if (e) {
        for (; e.left; )
          e = e.left;
        return this._root = Il(e.key, this._root, this._comparator), this._root = this._remove(e.key, this._root, this._comparator), { key: e.key, data: e.data };
      }
      return null;
    }, t.prototype.findStatic = function(e) {
      for (var r = this._root, n = this._comparator; r; ) {
        var i = n(e, r.key);
        if (i === 0)
          return r;
        i < 0 ? r = r.left : r = r.right;
      }
      return null;
    }, t.prototype.find = function(e) {
      return this._root && (this._root = Il(e, this._root, this._comparator), this._comparator(e, this._root.key) !== 0) ? null : this._root;
    }, t.prototype.contains = function(e) {
      for (var r = this._root, n = this._comparator; r; ) {
        var i = n(e, r.key);
        if (i === 0)
          return !0;
        i < 0 ? r = r.left : r = r.right;
      }
      return !1;
    }, t.prototype.forEach = function(e, r) {
      for (var n = this._root, i = [], s = !1; !s; )
        n !== null ? (i.push(n), n = n.left) : i.length !== 0 ? (n = i.pop(), e.call(r, n), n = n.right) : s = !0;
      return this;
    }, t.prototype.range = function(e, r, n, i) {
      for (var s = [], o = this._comparator, a = this._root, l; s.length !== 0 || a; )
        if (a)
          s.push(a), a = a.left;
        else {
          if (a = s.pop(), l = o(a.key, r), l > 0)
            break;
          if (o(a.key, e) >= 0 && n.call(i, a))
            return this;
          a = a.right;
        }
      return this;
    }, t.prototype.keys = function() {
      var e = [];
      return this.forEach(function(r) {
        var n = r.key;
        return e.push(n);
      }), e;
    }, t.prototype.values = function() {
      var e = [];
      return this.forEach(function(r) {
        var n = r.data;
        return e.push(n);
      }), e;
    }, t.prototype.min = function() {
      return this._root ? this.minNode(this._root).key : null;
    }, t.prototype.max = function() {
      return this._root ? this.maxNode(this._root).key : null;
    }, t.prototype.minNode = function(e) {
      if (e === void 0 && (e = this._root), e)
        for (; e.left; )
          e = e.left;
      return e;
    }, t.prototype.maxNode = function(e) {
      if (e === void 0 && (e = this._root), e)
        for (; e.right; )
          e = e.right;
      return e;
    }, t.prototype.at = function(e) {
      for (var r = this._root, n = !1, i = 0, s = []; !n; )
        if (r)
          s.push(r), r = r.left;
        else if (s.length > 0) {
          if (r = s.pop(), i === e)
            return r;
          i++, r = r.right;
        } else
          n = !0;
      return null;
    }, t.prototype.next = function(e) {
      var r = this._root, n = null;
      if (e.right) {
        for (n = e.right; n.left; )
          n = n.left;
        return n;
      }
      for (var i = this._comparator; r; ) {
        var s = i(e.key, r.key);
        if (s === 0)
          break;
        s < 0 ? (n = r, r = r.left) : r = r.right;
      }
      return n;
    }, t.prototype.prev = function(e) {
      var r = this._root, n = null;
      if (e.left !== null) {
        for (n = e.left; n.right; )
          n = n.right;
        return n;
      }
      for (var i = this._comparator; r; ) {
        var s = i(e.key, r.key);
        if (s === 0)
          break;
        s < 0 ? r = r.left : (n = r, r = r.right);
      }
      return n;
    }, t.prototype.clear = function() {
      return this._root = null, this._size = 0, this;
    }, t.prototype.toList = function() {
      return dke(this._root);
    }, t.prototype.load = function(e, r, n) {
      r === void 0 && (r = []), n === void 0 && (n = !1);
      var i = e.length, s = this._comparator;
      if (n && uE(e, r, 0, i - 1, s), this._root === null)
        this._root = lE(e, r, 0, i), this._size = i;
      else {
        var o = fke(this.toList(), pke(e, r), s);
        i = this._size + i, this._root = cE({ head: o }, 0, i);
      }
      return this;
    }, t.prototype.isEmpty = function() {
      return this._root === null;
    }, Object.defineProperty(t.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(t.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: !0,
      configurable: !0
    }), t.prototype.toString = function(e) {
      e === void 0 && (e = function(n) {
        return String(n.key);
      });
      var r = [];
      return aE(this._root, "", !0, function(n) {
        return r.push(n);
      }, e), r.join("");
    }, t.prototype.update = function(e, r, n) {
      var i = this._comparator, s = QR(e, this._root, i), o = s.left, a = s.right;
      i(e, r) < 0 ? a = ax(r, n, a, i) : o = ax(r, n, o, i), this._root = hke(o, a, i);
    }, t.prototype.split = function(e) {
      return QR(e, this._root, this._comparator);
    }, t.prototype[Symbol.iterator] = function() {
      var e, r, n;
      return cke(this, function(i) {
        switch (i.label) {
          case 0:
            e = this._root, r = [], n = !1, i.label = 1;
          case 1:
            return n ? [3, 6] : e === null ? [3, 2] : (r.push(e), e = e.left, [3, 5]);
          case 2:
            return r.length === 0 ? [3, 4] : (e = r.pop(), [4, e]);
          case 3:
            return i.sent(), e = e.right, [3, 5];
          case 4:
            n = !0, i.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    }, t;
  }()
);
function lE(t, e, r, n) {
  var i = n - r;
  if (i > 0) {
    var s = r + Math.floor(i / 2), o = t[s], a = e[s], l = new hc(o, a);
    return l.left = lE(t, e, r, s), l.right = lE(t, e, s + 1, n), l;
  }
  return null;
}
function pke(t, e) {
  for (var r = new hc(null, null), n = r, i = 0; i < t.length; i++)
    n = n.next = new hc(t[i], e[i]);
  return n.next = null, r.next;
}
function dke(t) {
  for (var e = t, r = [], n = !1, i = new hc(null, null), s = i; !n; )
    e ? (r.push(e), e = e.left) : r.length > 0 ? (e = s = s.next = r.pop(), e = e.right) : n = !0;
  return s.next = null, i.next;
}
function cE(t, e, r) {
  var n = r - e;
  if (n > 0) {
    var i = e + Math.floor(n / 2), s = cE(t, e, i), o = t.head;
    return o.left = s, t.head = t.head.next, o.right = cE(t, i + 1, r), o;
  }
  return null;
}
function fke(t, e, r) {
  for (var n = new hc(null, null), i = n, s = t, o = e; s !== null && o !== null; )
    r(s.key, o.key) < 0 ? (i.next = s, s = s.next) : (i.next = o, o = o.next), i = i.next;
  return s !== null ? i.next = s : o !== null && (i.next = o), n.next;
}
function uE(t, e, r, n, i) {
  if (!(r >= n)) {
    for (var s = t[r + n >> 1], o = r - 1, a = n + 1; ; ) {
      do
        o++;
      while (i(t[o], s) < 0);
      do
        a--;
      while (i(t[a], s) > 0);
      if (o >= a)
        break;
      var l = t[o];
      t[o] = t[a], t[a] = l, l = e[o], e[o] = e[a], e[a] = l;
    }
    uE(t, e, r, a, i), uE(t, e, a + 1, n, i);
  }
}
const Pa = 11102230246251565e-32, En = 134217729, gke = (3 + 8 * Pa) * Pa;
function lx(t, e, r, n, i) {
  let s, o, a, l, c = e[0], p = n[0], h = 0, d = 0;
  p > c == p > -c ? (s = c, c = e[++h]) : (s = p, p = n[++d]);
  let b = 0;
  if (h < t && d < r)
    for (p > c == p > -c ? (o = c + s, a = s - (o - c), c = e[++h]) : (o = p + s, a = s - (o - p), p = n[++d]), s = o, a !== 0 && (i[b++] = a); h < t && d < r; )
      p > c == p > -c ? (o = s + c, l = o - s, a = s - (o - l) + (c - l), c = e[++h]) : (o = s + p, l = o - s, a = s - (o - l) + (p - l), p = n[++d]), s = o, a !== 0 && (i[b++] = a);
  for (; h < t; )
    o = s + c, l = o - s, a = s - (o - l) + (c - l), c = e[++h], s = o, a !== 0 && (i[b++] = a);
  for (; d < r; )
    o = s + p, l = o - s, a = s - (o - l) + (p - l), p = n[++d], s = o, a !== 0 && (i[b++] = a);
  return (s !== 0 || b === 0) && (i[b++] = s), b;
}
function mke(t, e) {
  let r = e[0];
  for (let n = 1; n < t; n++) r += e[n];
  return r;
}
function Sm(t) {
  return new Float64Array(t);
}
const yke = (3 + 16 * Pa) * Pa, bke = (2 + 12 * Pa) * Pa, vke = (9 + 64 * Pa) * Pa * Pa, wp = Sm(4), KR = Sm(8), YR = Sm(12), ZR = Sm(16), Hn = Sm(4);
function wke(t, e, r, n, i, s, o) {
  let a, l, c, p, h, d, b, m, w, f, E, A, x, g, v, k, S, R;
  const L = t - i, F = r - i, z = e - s, j = n - s;
  g = L * j, d = En * L, b = d - (d - L), m = L - b, d = En * j, w = d - (d - j), f = j - w, v = m * f - (g - b * w - m * w - b * f), k = z * F, d = En * z, b = d - (d - z), m = z - b, d = En * F, w = d - (d - F), f = F - w, S = m * f - (k - b * w - m * w - b * f), E = v - S, h = v - E, wp[0] = v - (E + h) + (h - S), A = g + E, h = A - g, x = g - (A - h) + (E - h), E = x - k, h = x - E, wp[1] = x - (E + h) + (h - k), R = A + E, h = R - A, wp[2] = A - (R - h) + (E - h), wp[3] = R;
  let ee = mke(4, wp), X = bke * o;
  if (ee >= X || -ee >= X || (h = t - L, a = t - (L + h) + (h - i), h = r - F, c = r - (F + h) + (h - i), h = e - z, l = e - (z + h) + (h - s), h = n - j, p = n - (j + h) + (h - s), a === 0 && l === 0 && c === 0 && p === 0) || (X = vke * o + gke * Math.abs(ee), ee += L * p + j * a - (z * c + F * l), ee >= X || -ee >= X)) return ee;
  g = a * j, d = En * a, b = d - (d - a), m = a - b, d = En * j, w = d - (d - j), f = j - w, v = m * f - (g - b * w - m * w - b * f), k = l * F, d = En * l, b = d - (d - l), m = l - b, d = En * F, w = d - (d - F), f = F - w, S = m * f - (k - b * w - m * w - b * f), E = v - S, h = v - E, Hn[0] = v - (E + h) + (h - S), A = g + E, h = A - g, x = g - (A - h) + (E - h), E = x - k, h = x - E, Hn[1] = x - (E + h) + (h - k), R = A + E, h = R - A, Hn[2] = A - (R - h) + (E - h), Hn[3] = R;
  const ie = lx(4, wp, 4, Hn, KR);
  g = L * p, d = En * L, b = d - (d - L), m = L - b, d = En * p, w = d - (d - p), f = p - w, v = m * f - (g - b * w - m * w - b * f), k = z * c, d = En * z, b = d - (d - z), m = z - b, d = En * c, w = d - (d - c), f = c - w, S = m * f - (k - b * w - m * w - b * f), E = v - S, h = v - E, Hn[0] = v - (E + h) + (h - S), A = g + E, h = A - g, x = g - (A - h) + (E - h), E = x - k, h = x - E, Hn[1] = x - (E + h) + (h - k), R = A + E, h = R - A, Hn[2] = A - (R - h) + (E - h), Hn[3] = R;
  const ce = lx(ie, KR, 4, Hn, YR);
  g = a * p, d = En * a, b = d - (d - a), m = a - b, d = En * p, w = d - (d - p), f = p - w, v = m * f - (g - b * w - m * w - b * f), k = l * c, d = En * l, b = d - (d - l), m = l - b, d = En * c, w = d - (d - c), f = c - w, S = m * f - (k - b * w - m * w - b * f), E = v - S, h = v - E, Hn[0] = v - (E + h) + (h - S), A = g + E, h = A - g, x = g - (A - h) + (E - h), E = x - k, h = x - E, Hn[1] = x - (E + h) + (h - k), R = A + E, h = R - A, Hn[2] = A - (R - h) + (E - h), Hn[3] = R;
  const ke = lx(ce, YR, 4, Hn, ZR);
  return ZR[ke - 1];
}
function xke(t, e, r, n, i, s) {
  const o = (e - s) * (r - i), a = (t - i) * (n - s), l = o - a, c = Math.abs(o + a);
  return Math.abs(l) >= yke * c ? l : -wke(t, e, r, n, i, s, c);
}
const Rf = (t, e) => t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y, hE = (t, e) => {
  if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null;
  const r = t.ll.x < e.ll.x ? e.ll.x : t.ll.x, n = t.ur.x < e.ur.x ? t.ur.x : e.ur.x, i = t.ll.y < e.ll.y ? e.ll.y : t.ll.y, s = t.ur.y < e.ur.y ? t.ur.y : e.ur.y;
  return {
    ll: {
      x: r,
      y: i
    },
    ur: {
      x: n,
      y: s
    }
  };
};
let Ml = Number.EPSILON;
Ml === void 0 && (Ml = Math.pow(2, -52));
const Eke = Ml * Ml, JR = (t, e) => {
  if (-Ml < t && t < Ml && -Ml < e && e < Ml)
    return 0;
  const r = t - e;
  return r * r < Eke * t * e ? 0 : t < e ? -1 : 1;
};
class Ske {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new XR(), this.yRounder = new XR();
  }
  round(e, r) {
    return {
      x: this.xRounder.round(e),
      y: this.yRounder.round(r)
    };
  }
}
let XR = class {
  constructor() {
    this.tree = new N9(), this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(e) {
    const r = this.tree.add(e), n = this.tree.prev(r);
    if (n !== null && JR(r.key, n.key) === 0)
      return this.tree.remove(e), n.key;
    const i = this.tree.next(r);
    return i !== null && JR(r.key, i.key) === 0 ? (this.tree.remove(e), i.key) : e;
  }
};
const J0 = new Ske(), G1 = (t, e) => t.x * e.y - t.y * e.x, _U = (t, e) => t.x * e.x + t.y * e.y, eO = (t, e, r) => {
  const n = xke(t.x, t.y, e.x, e.y, r.x, r.y);
  return n > 0 ? -1 : n < 0 ? 1 : 0;
}, C2 = (t) => Math.sqrt(_U(t, t)), Ake = (t, e, r) => {
  const n = {
    x: e.x - t.x,
    y: e.y - t.y
  }, i = {
    x: r.x - t.x,
    y: r.y - t.y
  };
  return G1(i, n) / C2(i) / C2(n);
}, kke = (t, e, r) => {
  const n = {
    x: e.x - t.x,
    y: e.y - t.y
  }, i = {
    x: r.x - t.x,
    y: r.y - t.y
  };
  return _U(i, n) / C2(i) / C2(n);
}, tO = (t, e, r) => e.y === 0 ? null : {
  x: t.x + e.x / e.y * (r - t.y),
  y: r
}, rO = (t, e, r) => e.x === 0 ? null : {
  x: r,
  y: t.y + e.y / e.x * (r - t.x)
}, _ke = (t, e, r, n) => {
  if (e.x === 0) return rO(r, n, t.x);
  if (n.x === 0) return rO(t, e, r.x);
  if (e.y === 0) return tO(r, n, t.y);
  if (n.y === 0) return tO(t, e, r.y);
  const i = G1(e, n);
  if (i == 0) return null;
  const s = {
    x: r.x - t.x,
    y: r.y - t.y
  }, o = G1(s, e) / i, a = G1(s, n) / i, l = t.x + a * e.x, c = r.x + o * n.x, p = t.y + a * e.y, h = r.y + o * n.y, d = (l + c) / 2, b = (p + h) / 2;
  return {
    x: d,
    y: b
  };
};
let Co = class CU {
  // for ordering sweep events in the sweep event queue
  static compare(e, r) {
    const n = CU.comparePoints(e.point, r.point);
    return n !== 0 ? n : (e.point !== r.point && e.link(r), e.isLeft !== r.isLeft ? e.isLeft ? 1 : -1 : I2.compare(e.segment, r.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(e, r) {
    return e.x < r.x ? -1 : e.x > r.x ? 1 : e.y < r.y ? -1 : e.y > r.y ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(e, r) {
    e.events === void 0 ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = r;
  }
  link(e) {
    if (e.point === this.point)
      throw new Error("Tried to link already linked events");
    const r = e.point.events;
    for (let n = 0, i = r.length; n < i; n++) {
      const s = r[n];
      this.point.events.push(s), s.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const e = this.point.events.length;
    for (let r = 0; r < e; r++) {
      const n = this.point.events[r];
      if (n.segment.consumedBy === void 0)
        for (let i = r + 1; i < e; i++) {
          const s = this.point.events[i];
          s.consumedBy === void 0 && n.otherSE.point.events === s.otherSE.point.events && n.segment.consume(s.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const e = [];
    for (let r = 0, n = this.point.events.length; r < n; r++) {
      const i = this.point.events[r];
      i !== this && !i.segment.ringOut && i.segment.isInResult() && e.push(i);
    }
    return e;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(e) {
    const r = /* @__PURE__ */ new Map(), n = (i) => {
      const s = i.otherSE;
      r.set(i, {
        sine: Ake(this.point, e.point, s.point),
        cosine: kke(this.point, e.point, s.point)
      });
    };
    return (i, s) => {
      r.has(i) || n(i), r.has(s) || n(s);
      const {
        sine: o,
        cosine: a
      } = r.get(i), {
        sine: l,
        cosine: c
      } = r.get(s);
      return o >= 0 && l >= 0 ? a < c ? 1 : a > c ? -1 : 0 : o < 0 && l < 0 ? a < c ? -1 : a > c ? 1 : 0 : l < o ? -1 : l > o ? 1 : 0;
    };
  }
}, Cke = 0, I2 = class W1 {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(e, r) {
    const n = e.leftSE.point.x, i = r.leftSE.point.x, s = e.rightSE.point.x, o = r.rightSE.point.x;
    if (o < n) return 1;
    if (s < i) return -1;
    const a = e.leftSE.point.y, l = r.leftSE.point.y, c = e.rightSE.point.y, p = r.rightSE.point.y;
    if (n < i) {
      if (l < a && l < c) return 1;
      if (l > a && l > c) return -1;
      const h = e.comparePoint(r.leftSE.point);
      if (h < 0) return 1;
      if (h > 0) return -1;
      const d = r.comparePoint(e.rightSE.point);
      return d !== 0 ? d : -1;
    }
    if (n > i) {
      if (a < l && a < p) return -1;
      if (a > l && a > p) return 1;
      const h = r.comparePoint(e.leftSE.point);
      if (h !== 0) return h;
      const d = e.comparePoint(r.rightSE.point);
      return d < 0 ? 1 : d > 0 ? -1 : 1;
    }
    if (a < l) return -1;
    if (a > l) return 1;
    if (s < o) {
      const h = r.comparePoint(e.rightSE.point);
      if (h !== 0) return h;
    }
    if (s > o) {
      const h = e.comparePoint(r.rightSE.point);
      if (h < 0) return 1;
      if (h > 0) return -1;
    }
    if (s !== o) {
      const h = c - a, d = s - n, b = p - l, m = o - i;
      if (h > d && b < m) return 1;
      if (h < d && b > m) return -1;
    }
    return s > o ? 1 : s < o || c < p ? -1 : c > p ? 1 : e.id < r.id ? -1 : e.id > r.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(e, r, n, i) {
    this.id = ++Cke, this.leftSE = e, e.segment = this, e.otherSE = r, this.rightSE = r, r.segment = this, r.otherSE = e, this.rings = n, this.windings = i;
  }
  static fromRing(e, r, n) {
    let i, s, o;
    const a = Co.comparePoints(e, r);
    if (a < 0)
      i = e, s = r, o = 1;
    else if (a > 0)
      i = r, s = e, o = -1;
    else throw new Error(`Tried to create degenerate segment at [${e.x}, ${e.y}]`);
    const l = new Co(i, !0), c = new Co(s, !1);
    return new W1(l, c, [n], [o]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(e) {
    this.rightSE = e, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const e = this.leftSE.point.y, r = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: e < r ? e : r
      },
      ur: {
        x: this.rightSE.point.x,
        y: e > r ? e : r
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(e) {
    return e.x === this.leftSE.point.x && e.y === this.leftSE.point.y || e.x === this.rightSE.point.x && e.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(e) {
    if (this.isAnEndpoint(e)) return 0;
    const r = this.leftSE.point, n = this.rightSE.point, i = this.vector();
    if (r.x === n.x)
      return e.x === r.x ? 0 : e.x < r.x ? 1 : -1;
    const s = (e.y - r.y) / i.y, o = r.x + s * i.x;
    if (e.x === o) return 0;
    const a = (e.x - r.x) / i.x, l = r.y + a * i.y;
    return e.y === l ? 0 : e.y < l ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(e) {
    const r = this.bbox(), n = e.bbox(), i = hE(r, n);
    if (i === null) return null;
    const s = this.leftSE.point, o = this.rightSE.point, a = e.leftSE.point, l = e.rightSE.point, c = Rf(r, a) && this.comparePoint(a) === 0, p = Rf(n, s) && e.comparePoint(s) === 0, h = Rf(r, l) && this.comparePoint(l) === 0, d = Rf(n, o) && e.comparePoint(o) === 0;
    if (p && c)
      return d && !h ? o : !d && h ? l : null;
    if (p)
      return h && s.x === l.x && s.y === l.y ? null : s;
    if (c)
      return d && o.x === a.x && o.y === a.y ? null : a;
    if (d && h) return null;
    if (d) return o;
    if (h) return l;
    const b = _ke(s, this.vector(), a, e.vector());
    return b === null || !Rf(i, b) ? null : J0.round(b.x, b.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(e) {
    const r = [], n = e.events !== void 0, i = new Co(e, !0), s = new Co(e, !1), o = this.rightSE;
    this.replaceRightSE(s), r.push(s), r.push(i);
    const a = new W1(i, o, this.rings.slice(), this.windings.slice());
    return Co.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), Co.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), n && (i.checkForConsuming(), s.checkForConsuming()), r;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const e = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = e, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let r = 0, n = this.windings.length; r < n; r++)
      this.windings[r] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(e) {
    let r = this, n = e;
    for (; r.consumedBy; ) r = r.consumedBy;
    for (; n.consumedBy; ) n = n.consumedBy;
    const i = W1.compare(r, n);
    if (i !== 0) {
      if (i > 0) {
        const s = r;
        r = n, n = s;
      }
      if (r.prev === n) {
        const s = r;
        r = n, n = s;
      }
      for (let s = 0, o = n.rings.length; s < o; s++) {
        const a = n.rings[s], l = n.windings[s], c = r.rings.indexOf(a);
        c === -1 ? (r.rings.push(a), r.windings.push(l)) : r.windings[c] += l;
      }
      n.rings = null, n.windings = null, n.consumedBy = r, n.leftSE.consumedBy = r.leftSE, n.rightSE.consumedBy = r.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev) this._beforeState = {
      rings: [],
      windings: [],
      multiPolys: []
    };
    else {
      const e = this.prev.consumedBy || this.prev;
      this._beforeState = e.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const e = this.beforeState();
    this._afterState = {
      rings: e.rings.slice(0),
      windings: e.windings.slice(0),
      multiPolys: []
    };
    const r = this._afterState.rings, n = this._afterState.windings, i = this._afterState.multiPolys;
    for (let a = 0, l = this.rings.length; a < l; a++) {
      const c = this.rings[a], p = this.windings[a], h = r.indexOf(c);
      h === -1 ? (r.push(c), n.push(p)) : n[h] += p;
    }
    const s = [], o = [];
    for (let a = 0, l = r.length; a < l; a++) {
      if (n[a] === 0) continue;
      const c = r[a], p = c.poly;
      if (o.indexOf(p) === -1)
        if (c.isExterior) s.push(p);
        else {
          o.indexOf(p) === -1 && o.push(p);
          const h = s.indexOf(c.poly);
          h !== -1 && s.splice(h, 1);
        }
    }
    for (let a = 0, l = s.length; a < l; a++) {
      const c = s[a].multiPoly;
      i.indexOf(c) === -1 && i.push(c);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const e = this.beforeState().multiPolys, r = this.afterState().multiPolys;
    switch ($s.type) {
      case "union": {
        const n = e.length === 0, i = r.length === 0;
        this._isInResult = n !== i;
        break;
      }
      case "intersection": {
        let n, i;
        e.length < r.length ? (n = e.length, i = r.length) : (n = r.length, i = e.length), this._isInResult = i === $s.numMultiPolys && n < i;
        break;
      }
      case "xor": {
        const n = Math.abs(e.length - r.length);
        this._isInResult = n % 2 === 1;
        break;
      }
      case "difference": {
        const n = (i) => i.length === 1 && i[0].isSubject;
        this._isInResult = n(e) !== n(r);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${$s.type}`);
    }
    return this._isInResult;
  }
}, nO = class {
  constructor(e, r, n) {
    if (!Array.isArray(e) || e.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = r, this.isExterior = n, this.segments = [], typeof e[0][0] != "number" || typeof e[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const i = J0.round(e[0][0], e[0][1]);
    this.bbox = {
      ll: {
        x: i.x,
        y: i.y
      },
      ur: {
        x: i.x,
        y: i.y
      }
    };
    let s = i;
    for (let o = 1, a = e.length; o < a; o++) {
      if (typeof e[o][0] != "number" || typeof e[o][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      let l = J0.round(e[o][0], e[o][1]);
      l.x === s.x && l.y === s.y || (this.segments.push(I2.fromRing(s, l, this)), l.x < this.bbox.ll.x && (this.bbox.ll.x = l.x), l.y < this.bbox.ll.y && (this.bbox.ll.y = l.y), l.x > this.bbox.ur.x && (this.bbox.ur.x = l.x), l.y > this.bbox.ur.y && (this.bbox.ur.y = l.y), s = l);
    }
    (i.x !== s.x || i.y !== s.y) && this.segments.push(I2.fromRing(s, i, this));
  }
  getSweepEvents() {
    const e = [];
    for (let r = 0, n = this.segments.length; r < n; r++) {
      const i = this.segments[r];
      e.push(i.leftSE), e.push(i.rightSE);
    }
    return e;
  }
};
class Ike {
  constructor(e, r) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new nO(e[0], this, !0), this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    }, this.interiorRings = [];
    for (let n = 1, i = e.length; n < i; n++) {
      const s = new nO(e[n], this, !1);
      s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.interiorRings.push(s);
    }
    this.multiPoly = r;
  }
  getSweepEvents() {
    const e = this.exteriorRing.getSweepEvents();
    for (let r = 0, n = this.interiorRings.length; r < n; r++) {
      const i = this.interiorRings[r].getSweepEvents();
      for (let s = 0, o = i.length; s < o; s++)
        e.push(i[s]);
    }
    return e;
  }
}
let iO = class {
  constructor(e, r) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof e[0][0][0] == "number" && (e = [e]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let n = 0, i = e.length; n < i; n++) {
      const s = new Ike(e[n], this);
      s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.polys.push(s);
    }
    this.isSubject = r;
  }
  getSweepEvents() {
    const e = [];
    for (let r = 0, n = this.polys.length; r < n; r++) {
      const i = this.polys[r].getSweepEvents();
      for (let s = 0, o = i.length; s < o; s++)
        e.push(i[s]);
    }
    return e;
  }
}, Pke = class pE {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(e) {
    const r = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      if (!s.isInResult() || s.ringOut) continue;
      let o = null, a = s.leftSE, l = s.rightSE;
      const c = [a], p = a.point, h = [];
      for (; o = a, a = l, c.push(a), a.point !== p; )
        for (; ; ) {
          const d = a.getAvailableLinkedEvents();
          if (d.length === 0) {
            const w = c[0].point, f = c[c.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${w.x}, ${w.y}]. Last matching segment found ends at [${f.x}, ${f.y}].`);
          }
          if (d.length === 1) {
            l = d[0].otherSE;
            break;
          }
          let b = null;
          for (let w = 0, f = h.length; w < f; w++)
            if (h[w].point === a.point) {
              b = w;
              break;
            }
          if (b !== null) {
            const w = h.splice(b)[0], f = c.splice(w.index);
            f.unshift(f[0].otherSE), r.push(new pE(f.reverse()));
            continue;
          }
          h.push({
            index: c.length,
            point: a.point
          });
          const m = a.getLeftmostComparator(o);
          l = d.sort(m)[0].otherSE;
          break;
        }
      r.push(new pE(c));
    }
    return r;
  }
  constructor(e) {
    this.events = e;
    for (let r = 0, n = e.length; r < n; r++)
      e[r].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let e = this.events[0].point;
    const r = [e];
    for (let c = 1, p = this.events.length - 1; c < p; c++) {
      const h = this.events[c].point, d = this.events[c + 1].point;
      eO(h, e, d) !== 0 && (r.push(h), e = h);
    }
    if (r.length === 1) return null;
    const n = r[0], i = r[1];
    eO(n, e, i) === 0 && r.shift(), r.push(r[0]);
    const s = this.isExteriorRing() ? 1 : -1, o = this.isExteriorRing() ? 0 : r.length - 1, a = this.isExteriorRing() ? r.length : -1, l = [];
    for (let c = o; c != a; c += s) l.push([r[c].x, r[c].y]);
    return l;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const e = this.enclosingRing();
      this._isExteriorRing = e ? !e.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let e = this.events[0];
    for (let i = 1, s = this.events.length; i < s; i++) {
      const o = this.events[i];
      Co.compare(e, o) > 0 && (e = o);
    }
    let r = e.segment.prevInResult(), n = r ? r.prevInResult() : null;
    for (; ; ) {
      if (!r) return null;
      if (!n) return r.ringOut;
      if (n.ringOut !== r.ringOut)
        return n.ringOut.enclosingRing() !== r.ringOut ? r.ringOut : r.ringOut.enclosingRing();
      r = n.prevInResult(), n = r ? r.prevInResult() : null;
    }
  }
}, sO = class {
  constructor(e) {
    this.exteriorRing = e, e.poly = this, this.interiorRings = [];
  }
  addInterior(e) {
    this.interiorRings.push(e), e.poly = this;
  }
  getGeom() {
    const e = [this.exteriorRing.getGeom()];
    if (e[0] === null) return null;
    for (let r = 0, n = this.interiorRings.length; r < n; r++) {
      const i = this.interiorRings[r].getGeom();
      i !== null && e.push(i);
    }
    return e;
  }
};
class Rke {
  constructor(e) {
    this.rings = e, this.polys = this._composePolys(e);
  }
  getGeom() {
    const e = [];
    for (let r = 0, n = this.polys.length; r < n; r++) {
      const i = this.polys[r].getGeom();
      i !== null && e.push(i);
    }
    return e;
  }
  _composePolys(e) {
    const r = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      if (!s.poly)
        if (s.isExteriorRing()) r.push(new sO(s));
        else {
          const o = s.enclosingRing();
          o.poly || r.push(new sO(o)), o.poly.addInterior(s);
        }
    }
    return r;
  }
}
class Oke {
  constructor(e) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : I2.compare;
    this.queue = e, this.tree = new N9(r), this.segments = [];
  }
  process(e) {
    const r = e.segment, n = [];
    if (e.consumedBy)
      return e.isLeft ? this.queue.remove(e.otherSE) : this.tree.remove(r), n;
    const i = e.isLeft ? this.tree.add(r) : this.tree.find(r);
    if (!i) throw new Error(`Unable to find segment #${r.id} [${r.leftSE.point.x}, ${r.leftSE.point.y}] -> [${r.rightSE.point.x}, ${r.rightSE.point.y}] in SweepLine tree.`);
    let s = i, o = i, a, l;
    for (; a === void 0; )
      s = this.tree.prev(s), s === null ? a = null : s.key.consumedBy === void 0 && (a = s.key);
    for (; l === void 0; )
      o = this.tree.next(o), o === null ? l = null : o.key.consumedBy === void 0 && (l = o.key);
    if (e.isLeft) {
      let c = null;
      if (a) {
        const h = a.getIntersection(r);
        if (h !== null && (r.isAnEndpoint(h) || (c = h), !a.isAnEndpoint(h))) {
          const d = this._splitSafely(a, h);
          for (let b = 0, m = d.length; b < m; b++)
            n.push(d[b]);
        }
      }
      let p = null;
      if (l) {
        const h = l.getIntersection(r);
        if (h !== null && (r.isAnEndpoint(h) || (p = h), !l.isAnEndpoint(h))) {
          const d = this._splitSafely(l, h);
          for (let b = 0, m = d.length; b < m; b++)
            n.push(d[b]);
        }
      }
      if (c !== null || p !== null) {
        let h = null;
        c === null ? h = p : p === null ? h = c : h = Co.comparePoints(c, p) <= 0 ? c : p, this.queue.remove(r.rightSE), n.push(r.rightSE);
        const d = r.split(h);
        for (let b = 0, m = d.length; b < m; b++)
          n.push(d[b]);
      }
      n.length > 0 ? (this.tree.remove(r), n.push(e)) : (this.segments.push(r), r.prev = a);
    } else {
      if (a && l) {
        const c = a.getIntersection(l);
        if (c !== null) {
          if (!a.isAnEndpoint(c)) {
            const p = this._splitSafely(a, c);
            for (let h = 0, d = p.length; h < d; h++)
              n.push(p[h]);
          }
          if (!l.isAnEndpoint(c)) {
            const p = this._splitSafely(l, c);
            for (let h = 0, d = p.length; h < d; h++)
              n.push(p[h]);
          }
        }
      }
      this.tree.remove(r);
    }
    return n;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(e, r) {
    this.tree.remove(e);
    const n = e.rightSE;
    this.queue.remove(n);
    const i = e.split(r);
    return i.push(n), e.consumedBy === void 0 && this.tree.add(e), i;
  }
}
const oO = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, Tke = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
class Lke {
  run(e, r, n) {
    $s.type = e, J0.reset();
    const i = [new iO(r, !0)];
    for (let p = 0, h = n.length; p < h; p++)
      i.push(new iO(n[p], !1));
    if ($s.numMultiPolys = i.length, $s.type === "difference") {
      const p = i[0];
      let h = 1;
      for (; h < i.length; )
        hE(i[h].bbox, p.bbox) !== null ? h++ : i.splice(h, 1);
    }
    if ($s.type === "intersection")
      for (let p = 0, h = i.length; p < h; p++) {
        const d = i[p];
        for (let b = p + 1, m = i.length; b < m; b++)
          if (hE(d.bbox, i[b].bbox) === null) return [];
      }
    const s = new N9(Co.compare);
    for (let p = 0, h = i.length; p < h; p++) {
      const d = i[p].getSweepEvents();
      for (let b = 0, m = d.length; b < m; b++)
        if (s.insert(d[b]), s.size > oO)
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
    }
    const o = new Oke(s);
    let a = s.size, l = s.pop();
    for (; l; ) {
      const p = l.key;
      if (s.size === a) {
        const d = p.segment;
        throw new Error(`Unable to pop() ${p.isLeft ? "left" : "right"} SweepEvent [${p.point.x}, ${p.point.y}] from segment #${d.id} [${d.leftSE.point.x}, ${d.leftSE.point.y}] -> [${d.rightSE.point.x}, ${d.rightSE.point.y}] from queue.`);
      }
      if (s.size > oO)
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      if (o.segments.length > Tke)
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      const h = o.process(p);
      for (let d = 0, b = h.length; d < b; d++) {
        const m = h[d];
        m.consumedBy === void 0 && s.insert(m);
      }
      a = s.size, l = s.pop();
    }
    J0.reset();
    const c = Pke.factory(o.segments);
    return new Rke(c).getGeom();
  }
}
const $s = new Lke(), Mke = function(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  return $s.run("union", t, r);
}, Nke = function(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  return $s.run("intersection", t, r);
}, Dke = function(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  return $s.run("xor", t, r);
}, $ke = function(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  return $s.run("difference", t, r);
};
var jke = {
  union: Mke,
  intersection: Nke,
  xor: Dke,
  difference: $ke
};
function aO(t, e, r) {
  const n = t.length;
  if (n == 0)
    throw new Error("Error: Given data has zero length");
  const i = [];
  let s = [], o = [];
  if (r != null) {
    if (n != r.length)
      throw new Error("Error: Given labels do not match length of data");
    o = [...new Set(r.flat())];
    for (let X = 0; X < o.length; X++)
      s.push({ label: o[X], factor: X });
    for (let X = 0; X < r.length; X++)
      i.push(o.indexOf(r[X]));
  }
  const a = 4, l = 2, c = [];
  for (let X = 0; X < n; X++)
    c.push([Number(t[X].x), Number(t[X].y)]);
  const p = [], h = [];
  for (let X = 0; X < n; X++)
    h.push(Vke(c, X, a));
  for (let X = 0; X < n; X++) {
    let ie = 0;
    for (let ce = 0; ce < n; ce++)
      ie += h[ce][X];
    p.push(ie / n);
  }
  const d = new lke(c, l * p[a], a, e);
  let b = d.clusters, m = d.clusterCentroids, w = d.noiseAssigned;
  if (r != null) {
    b = [];
    for (let X = 0; X < o.length; X++)
      b.push([]);
    for (let X = 0; X < c.length; X++) {
      let ie = i[X];
      b[ie].push(X);
    }
    m = [];
    for (let X = 0; X < b.length; X++) {
      let ie = [];
      for (let ce of b[X])
        ie.push(c[ce]);
      m.push(Zke(ie));
    }
    w = [];
  }
  const f = [], E = Qke(m), A = Kke(E), x = [], g = [];
  for (let X = 0; X < n; X++)
    x.push(c[X][0]), g.push(c[X][1]);
  const v = Math.max(...g), k = Math.max(...x), S = Math.min(...g), R = Math.min(...x);
  let L = 0;
  for (let X of b) {
    const ie = {
      area: 0,
      centroid: [],
      dataPoints: [],
      dataPointIDs: [],
      outliers: [],
      outlierIDs: [],
      density: 0,
      densityRank: 0,
      hasSignificantHole: !1,
      holes: [],
      hull: [],
      hullIDs: [],
      hullSimplified: [],
      id: 0,
      perimeter: 0,
      region: 0,
      regionDesc: "",
      relations: [{
        angle: 0,
        cardDirection: "",
        distance: 0,
        id: 0,
        isNeighbor: !1
      }],
      shape: { description: "" },
      xMin: 0,
      xMax: 0,
      yMin: 0,
      yMax: 0
    }, ce = [];
    for (let oe of X)
      ce.push(c[oe]);
    r && (ie.label = o[L]), ie.dataPoints = ce, ie.dataPointIDs = X;
    let ke = ce[0][0], ye = ce[0][0], Ce = ce[0][1], Ie = ce[0][1];
    for (let oe of ce)
      oe[0] < ke && (ke = oe[0]), oe[0] > ye && (ye = oe[0]), oe[1] < Ce && (Ce = oe[1]), oe[1] > Ie && (Ie = oe[1]);
    ie.xMin = ke, ie.xMax = ye, ie.yMin = Ce, ie.yMax = Ie, ie.centroid = m[L], ie.id = L, ie.region = E[L], ie.regionDesc = A[L];
    const Te = oE(r0(ce));
    ie.hull = Te;
    for (let oe of Te) {
      const fe = c.findIndex((H) => H[0] == oe.x && H[1] == oe.y);
      ie.hullIDs.push(fe);
    }
    const ue = lO(Te);
    ie.hullSimplified = ue;
    const O = q1(Te);
    ie.area = O;
    const N = D9(Te);
    ie.perimeter = N;
    const Z = ee(ie);
    ie.shape = Z;
    const re = X.length / O;
    ie.density = re, ie.relations = [];
    const le = Wke(m, L), te = zke(m, L);
    for (let oe = 0; oe < b.length; oe++) {
      const fe = To(m[L], m[le[oe]]), H = Yke(m[L], m[le[oe]]);
      ie.relations.push({
        id: le[oe],
        distance: te[oe],
        angle: fe,
        cardDirection: H
      });
    }
    ie.holes = Fke(ie), ie.holes[0][2] > 0.2 ? ie.hasSignificantHole = !0 : ie.hasSignificantHole = !1, f.push(ie), L++;
  }
  for (let X of w)
    f[X[1]].outliers.push(c[X[0]]), f[X[1]].outlierIDs.push(X[0]);
  const F = JSON.parse(JSON.stringify(f)).sort((X, ie) => X.density - ie.density), z = [];
  for (let X of F)
    z.push(X.id);
  for (let X of f)
    X.densityRank = z.indexOf(X.id);
  L = 0;
  const j = 1.2;
  for (let X of m) {
    let ie = 0;
    for (let ce of m) {
      let ke = [];
      if (L == ie)
        f[L].relations[0].isNeighbor = !0, ie++;
      else {
        L < ie && (ke = [...m.slice(0, L), ...m.slice(L + 1)], ke.splice(ie - 1, 1)), L > ie && (ke = [...m.slice(0, ie), ...m.slice(ie + 1)], ke.splice(L - 1, 1));
        const ye = fr(X, ce), Ce = [];
        for (let Te of ke)
          fr(X, Te) < fr(X, ce) && Ce.push(fr(X, Te) + fr(Te, ce));
        let Ie = {
          angle: 0,
          cardDirection: "",
          distance: 0,
          id: 0,
          isNeighbor: !1
        };
        for (let Te of f[L].relations)
          Te.id == ie && (Ie = Te);
        Math.min(...Ce) < j * ye ? f[L].relations[f[L].relations.indexOf(Ie)].isNeighbor = !1 : f[L].relations[f[L].relations.indexOf(Ie)].isNeighbor = !0, ie++;
      }
    }
    L++;
  }
  for (let X = 0; X < f.length; X++) {
    let ie = f[X];
    for (let ce = 0; ce < f.length; ce++) {
      let ke = 0;
      for (let ye = 0; ye < f[X].relations.length; ye++)
        f[X].relations[ye].id == Number(ce) && (ke = Number(ye));
      if (X == ce)
        f[X].relations[ke].overlap = 1;
      else {
        let ye = f[ce], Ce = jke.intersection([Ls(ie.hull)], [Ls(ye.hull)]);
        if (Ce.length > 0) {
          let Ie = q1(r0(Ce[0][0])) / ie.area;
          f[X].relations[ke].overlap = Ie, f[X].relations[ke].sharedPts = [];
          for (let Te of ie.dataPoints) {
            let ue = 10 ** (Math.log10(Math.max(ie.xMax - ie.xMin, ie.yMax - ie.yMin)) - 4);
            sE(Ls(ye.hull), Te, ue) < 1 && f[X].relations[ke].sharedPts.push(Te);
          }
          f[X].relations[ke].percentPtsShared = f[X].relations[ke].sharedPts.length / f[X].dataPoints.length;
        } else
          f[X].relations[ke].overlap = 0;
      }
    }
  }
  function ee(X) {
    const ie = X.dataPoints, ce = oE(r0(ie)), ke = qke(ce);
    if (ke > 0.92)
      return {
        description: "roughly circular",
        radius: Math.sqrt(q1(ce) / Math.PI)
      };
    if (ke > 0.7) {
      const ye = Ls(lO(ce)), Ce = ye.length;
      switch (!0) {
        case Ce == 3:
          return {
            description: "triangular",
            averageSideLength: (fr(ye[0], ye[1]) + fr(ye[1], ye[2]) + fr(ye[2], ye[0])) / 3
          };
        case Ce == 4:
          const Ie = To(ye[0], ye[1]), Te = To(ye[1], ye[2]), ue = To(ye[2], ye[3]), O = To(ye[3], ye[0]), N = Te - Ie, Z = ue - Te, re = O - ue, le = Ie - O;
          if (Math.abs((N + 720) % 360 - 270) < 15 && Math.abs((Z + 720) % 360 - 270) < 15 && Math.abs((re + 720) % 360 - 270) < 15 && Math.abs((le + 720) % 360 - 270) < 15) {
            const Se = fr(ye[0], ye[1]), Re = fr(ye[1], ye[2]), Fe = fr(ye[2], ye[3]), Le = fr(ye[3], ye[0]), ze = (Se + Re + Fe + Le) / 4;
            return ze * 0.91 < Se && Se < ze * 1.1 && ze * 0.91 < Re && Re < ze * 1.1 && ze * 0.91 < Fe && Fe < ze * 1.1 && ze * 0.91 < Le && Le < ze * 1.1 ? (Ie % 90 + Te % 90 + ue % 90 + O % 90) / 4 > 25 && (Ie % 90 + Te % 90 + ue % 90 + O % 90) / 4 < 65 ? {
              description: "diamond",
              averageSideLength: ze
            } : {
              description: "square",
              averageSideLength: ze
            } : { description: "rectangular" };
          } else return Math.abs((N + 720) % 360 - (re + 720) % 360) < 20 && Math.abs((Z + 720) % 360 - (le + 720) % 360) < 20 ? { description: "parallelogram" } : { description: "irregular quadrilateral" };
        case Ce == 5:
          return { description: "pentagon" };
        case Ce > 5:
          const te = [], oe = [];
          for (let Se = 0; Se < ce.length; Se++)
            te.push(ce[Se].x), oe.push(ce[Se].y);
          const fe = cO(te, oe)[1], H = (Math.max(...te) - Math.min(...te)) / (k - R), J = (Math.max(...oe) - Math.min(...oe)) / (v - S);
          if (H / J > 2 || J / H > 2)
            return H > J ? {
              description: "elliptical: horizontal",
              slope: fe
            } : {
              description: "elliptical: vertical",
              slope: fe
            };
          switch (!0) {
            case fe >= 0.3:
              return {
                description: "elliptical: positively correlated",
                slope: fe
              };
            case fe <= -0.3:
              return {
                description: "elliptical: negatively correlated",
                slope: fe
              };
            case (fe < 0.3 && fe > -0.3 && (Math.max(...te) - Math.min(...te)) / (k - R) > (Math.max(...oe) - Math.min(...oe)) / (v - S)):
              return {
                description: "elliptical: horizontal",
                slope: fe
              };
            case (fe < 0.3 && fe > -0.3 && (Math.max(...te) - Math.min(...te)) / (k - R) <= (Math.max(...oe) - Math.min(...oe)) / (v - S)):
              return {
                description: "elliptical: vertical",
                slope: fe
              };
          }
      }
    } else {
      const ye = [], Ce = [];
      for (let Te = 0; Te < ce.length; Te++)
        ye.push(ce[Te].x), Ce.push(ce[Te].y);
      const Ie = cO(ye, Ce)[1];
      switch (!0) {
        case Ie > 0.3:
          return {
            description: "roughly linear: positively correlated",
            slope: Ie
          };
        case Ie < -0.3:
          return {
            description: "roughly linear: negatively correlated",
            slope: Ie
          };
        case (Ie < 0.3 && Ie > -0.3 && (Math.max(...ye) - Math.min(...ye)) / (k - R) > (Math.max(...Ce) - Math.min(...Ce)) / (v - S)):
          return {
            description: "roughly linear: horizontal",
            slope: Ie
          };
        case (Ie < 0.3 && Ie > -0.3 && (Math.max(...ye) - Math.min(...ye)) / (k - R) < (Math.max(...Ce) - Math.min(...Ce)) / (v - S)):
          return {
            description: "roughly linear: vertical",
            slope: Ie
          };
      }
    }
    throw new Error("Something has gone wrong in judgeShape()");
  }
  return f;
}
function lO(t) {
  const e = Ls(t), r = 15;
  let n = e.length;
  for (let o = 0; o < n; o++) {
    const a = To(e[o % n], e[(o + 1) % n]), l = To(e[(o + 1) % n], e[(o + 2) % n]) - a;
    (Math.abs(l) < r || Math.abs(l + 360) < r || Math.abs(l - 360) < r) && (e.splice((o + 1) % n, 1), o--, n--);
  }
  const i = 20, s = D9(t);
  for (let o = 0; o < n; o++)
    if (fr(e[(o + 1) % n], e[(o + 2) % n]) < s / i) {
      const a = To(e[o % n], e[(o + 1) % n]), l = To(e[(o + 2) % n], e[(o + 3) % n]) - a;
      if (!(160 < (l + 720) % 360 && (l + 720) % 360 < 200)) {
        const c = IU(e[o % n], e[(o + 1) % n], e[(o + 2) % n], e[(o + 3) % n]);
        e[(o + 1) % n] = c, e.splice((o + 2) % n, 1), o--, n--;
      }
    }
  return r0(e);
}
function IU(t, e, r, n) {
  if (Array.isArray(t) || (t = [t.x, t.y]), Array.isArray(e) || (e = [e.x, e.y]), Array.isArray(r) || (r = [r.x, r.y]), Array.isArray(n) || (n = [n.x, n.y]), e[0] - t[0] == 0) {
    if (n[0] - r[0] == 0)
      throw new Error("Error: attempting to compare parallel lines in completeAngle");
    return [t[0], (n[1] - r[1]) / (n[0] - r[0]) * t[0] + r[1] - (n[1] - r[1]) / (n[0] - r[0]) * r[0]];
  }
  if (n[0] - r[0] == 0)
    return [r[0], (e[1] - t[1]) / (e[0] - t[0]) * r[0] + t[1] - (e[1] - t[1]) / (e[0] - t[0]) * t[0]];
  const i = (e[1] - t[1]) / (e[0] - t[0]), s = (n[1] - r[1]) / (n[0] - r[0]);
  if (i - s == 0)
    throw new Error("Error: attempting to compare parallel lines in completeAngle");
  const o = (t[1] - r[1] - i * t[0] + s * r[0]) / (s - i);
  return [o, i * o + t[1] - i * t[0]];
}
function Bke(t, e, r, n) {
  if (Array.isArray(t) || (t = [t.x, t.y]), Array.isArray(e) || (e = [e.x, e.y]), Array.isArray(r) || (r = [r.x, r.y]), Array.isArray(n) || (n = [n.x, n.y]), e[0] - t[0] == 0)
    return n[0] - r[0] == 0;
  const i = (e[1] - t[1]) / (e[0] - t[0]), s = (n[1] - r[1]) / (n[0] - r[0]);
  return i - s == 0;
}
function cO(t, e) {
  const r = t.length;
  let n = 0, i = 0, s = 0, o = 0;
  for (let l = 0; l < r; l++) {
    const c = t[l], p = e[l];
    n += c, i += p, s += c * p, o += c * c;
  }
  const a = (r * s - n * i) / (r * o - n * n);
  return [i / r - a * (n / r), a];
}
function Fke(t) {
  const e = r0(t.dataPoints), r = new pt(), n = { xl: t.xMin, xr: t.xMax, yt: t.yMin, yb: t.yMax }, i = r.compute(e, n), s = oE(e), o = [], a = [];
  for (let w of i.edges) {
    const f = [w.va.x, w.va.y], E = [w.vb.x, w.vb.y], A = s.length;
    for (let x = 0; x < A; x++)
      if (!Bke(f, E, s[x % A], s[(x + 1) % A])) {
        let g = IU(f, E, s[x % A], s[(x + 1) % A]);
        (g[0] > f[0] && g[0] < E[0] || g[0] < f[0] && g[0] > E[0]) && (g[1] > f[1] && g[1] < E[1] || g[1] < f[1] && g[1] > E[1]) && o.push(g);
      }
  }
  const l = 10 ** (Math.log10(Math.max(t.xMax - t.xMin, t.yMax - t.yMin)) - 4);
  for (let w of Ls(i.vertices))
    sE(Ls(s), w, l) < 1 && a.push(w);
  for (let w of o)
    sE(Ls(s), w, l) < 1 && a.push(w);
  let c = [];
  for (let w = 0; w < a.length; w++) {
    let f = a[w], E = [Number(w), fr(f, Ls(e)[0])];
    for (let A of Ls(e))
      E[1] > fr(f, A) && (E = [Number(w), fr(f, A)]);
    c.push(E);
  }
  let p = c.sort((w, f) => f[1] - w[1]);
  for (let w = 0; w < p.length; w++) {
    const f = p[w];
    let E = Number(w) + 1;
    for (; E < p.length; )
      fr(a[f[0]], a[p[E][0]]) < f[1] && (p.splice(E, 1), E--), E++;
  }
  const h = Ls(t.hull);
  let d = fr(h[0], t.centroid), b = 0;
  for (let w of h) {
    const f = fr(w, t.centroid);
    d < f && (d = f), b += f / h.length;
  }
  const m = [];
  for (let w = 0; w < p.length; w++) {
    const f = [a[p[w][0]], p[w][1], 0], E = fr(f[0], t.centroid), A = f[1] / b * (1 - E / d);
    f[2] = A, m.push(f);
  }
  return m.sort((w, f) => f[2] - w[2]);
}
function fr(t, e) {
  let r = 0, n = Math.min(t.length, e.length);
  for (; n--; )
    r += (t[n] - e[n]) * (t[n] - e[n]);
  return Math.sqrt(r);
}
function zke(t, e) {
  const r = [];
  for (let n = 0; n < t.length; n++) {
    const i = fr(t[e], t[n]);
    r.push(i);
  }
  return r.sort((n, i) => n - i), r;
}
function Vke(t, e, r) {
  const n = [];
  for (let i = 0; i < t.length; i++) {
    const s = fr(t[e], t[i]);
    n.push(s);
  }
  return Gke(n, 2 * r);
}
function Uke(t, e, r, n) {
  let i;
  for (typeof r > "u" && (r = 0), typeof n > "u" && (n = t.length); r < n; )
    i = Math.floor((r + n) / 2), e < t[i] ? n = i : r = i + 1;
  return r;
}
function Hke(t, e) {
  t.splice(Uke(t, e), 0, e);
}
function Gke(t, e) {
  let r = [];
  for (let n = 0, i = t.length; n < i; ++n) {
    const s = t[n];
    (r.length < e || s < r[r.length - 1]) && (Hke(r, s), r.length > e && r.splice(e, 1));
  }
  return r;
}
function Wke(t, e) {
  let r = [];
  for (let i = 0; i < t.length; i++) {
    const s = [i, fr(t[e], t[i])];
    r.push(s);
  }
  r = r.sort((i, s) => i[1] - s[1]);
  const n = [];
  for (let i = 0; i < t.length; i++)
    n.push(r[i][0]);
  return n;
}
function q1(t) {
  if (t.length == 0)
    return 0;
  let e = 0;
  const r = t.length;
  for (let n = 0; n < r - 1; n++)
    e += t[n].x * t[n + 1].y - t[n].y * t[n + 1].x;
  return e += t[r - 1].x * t[0].y - t[r - 1].y * t[0].x, Math.abs(e / 2);
}
function D9(t) {
  let e = 0;
  const r = t.length;
  if (r < 2)
    return 0;
  if (r == 2)
    return fr([t[0].x, t[0].y], [t[1].x, t[1].y]);
  for (let n = 0; n < r - 1; n++) {
    let i = [t[n].x, t[n].y], s = [t[n + 1].x, t[n + 1].y];
    e += fr(i, s);
  }
  return e += fr([t[r - 1].x, t[r - 1].y], [t[0].x, t[0].y]), e;
}
function qke(t) {
  return 2 * Math.sqrt(q1(t) * Math.PI) / D9(t);
}
function Qke(t) {
  const e = [], r = t.length;
  let n = t[0][0], i = t[0][1], s = t[0][0], o = t[0][1];
  for (let h = 0; h < r; h++)
    n < t[h][0] && (n = t[h][0]), s > t[h][0] && (s = t[h][0]), i < t[h][1] && (i = t[h][1]), o > t[h][1] && (o = t[h][1]);
  const a = (n - s) / 3 + s, l = (n - s) * 2 / 3 + s, c = (i - o) / 3 + o, p = (i - o) * 2 / 3 + o;
  for (let h of t) {
    const d = [h[0] < a, h[0] < l, h[1] < c, h[1] < p];
    switch (!0) {
      case JSON.stringify(d) == JSON.stringify([!0, !0, !0, !0]):
        e.push(0);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !0, !0, !0]):
        e.push(1);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !1, !0, !0]):
        e.push(2);
        break;
      case JSON.stringify(d) == JSON.stringify([!0, !0, !1, !0]):
        e.push(3);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !0, !1, !0]):
        e.push(4);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !1, !1, !0]):
        e.push(5);
        break;
      case JSON.stringify(d) == JSON.stringify([!0, !0, !1, !1]):
        e.push(6);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !0, !1, !1]):
        e.push(7);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !1, !1, !1]):
        e.push(8);
    }
  }
  return e;
}
function Kke(t) {
  const e = [], r = t.length;
  for (let n = 0; n < r; n++) {
    const i = t[n];
    switch (!0) {
      case i == 0:
        e.push("bottom left");
        break;
      case i == 1:
        e.push("bottom center");
        break;
      case i == 2:
        e.push("bottom right");
        break;
      case i == 3:
        e.push("left");
        break;
      case i == 4:
        e.push("center");
        break;
      case i == 5:
        e.push("right");
        break;
      case i == 6:
        e.push("top left");
        break;
      case i == 7:
        e.push("top center");
        break;
      case i == 8:
        e.push("top right");
    }
  }
  return e;
}
function To(t, e) {
  const r = e.map((i, s) => i - t[s]);
  let n = 0;
  if (r[0] == 0 && r[1] > 0)
    return 90;
  if (r[0] == 0 && r[1] < 0)
    return 270;
  if (r[1] == 0 && r[0] >= 0)
    return 0;
  if (r[1] == 0 && r[0] < 0)
    return 180;
  switch (!0) {
    case (r[0] > 0 && r[1] > 0):
      n = Math.atan(r[1] / r[0]);
      break;
    case (r[0] < 0 && r[1] > 0):
      n = Math.atan(r[0] / r[1]), n = Math.abs(n) + Math.PI / 2;
      break;
    case (r[0] < 0 && r[1] < 0):
      n = Math.atan(r[1] / r[0]), n = Math.abs(n) + Math.PI;
      break;
    case (r[0] > 0 && r[1] < 0):
      n = Math.atan(r[0] / r[1]), n = Math.abs(n) + 3 * Math.PI / 2;
      break;
  }
  return n = n * 180 / Math.PI, n;
}
function Yke(t, e) {
  const r = To(t, e);
  switch (!0) {
    case (345 < r || r <= 15):
      return "east";
    case (15 < r && r <= 75):
      return "north-east";
    case (75 < r && r <= 105):
      return "north";
    case (105 < r && r <= 165):
      return "north-west";
    case (165 < r && r <= 195):
      return "west";
    case (195 < r && r <= 255):
      return "south-west";
    case (255 < r && r <= 285):
      return "south";
    case (285 < r && r <= 345):
      return "south-east";
  }
  throw new Error("Error: undefined angle in judgeAngle()");
}
function Ls(t) {
  if (t.length == 0)
    return [];
  const e = [];
  for (let r = 0; r < t.length; r++)
    e.push([t[r].x, t[r].y]);
  return e;
}
function r0(t) {
  if (t.length == 0)
    return [];
  const e = [];
  for (let r = 0; r < t.length; r++)
    e.push({ x: t[r][0], y: t[r][1] });
  return e;
}
function Zke(t) {
  var e = [0, 0], r = 0, n = 0, i = t.length;
  for (r = 0; r < i; r++)
    for (n = 0; n < t[r].length; n++)
      e[n] !== void 0 || e.push(0), e[n] += t[r][n] / i;
  return e;
}
class Jke extends xU {
  constructor(e, r) {
    super(e, r), this._currentCluster = -1;
  }
  _init() {
    this._generateClustering(), super._init(), this._axisInfo = new Yv(this._store, {
      xValues: this._store.model.allFacetValues("x").map((e) => e.value),
      yValues: this._store.model.allFacetValues("y").map((e) => e.value)
    });
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "checkbox",
      key: "type.scatter.isDrawTrendLine",
      label: "Trend line",
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "type.scatter.isShowOutliers",
      label: "Show outliers",
      parentView: "controlPanel.tabs.chart.chart"
    });
  }
  get clustering() {
    return this._clustering;
  }
  get currentCluster() {
    return this._currentCluster;
  }
  get _datapointNavNodeType() {
    return "scatterpoint";
  }
  _datapointNavNodeOptions(e) {
    const r = super._datapointNavNodeOptions(e);
    return r.cluster = this._findCluster(e.datapointIndex), r;
  }
  _createNavMap() {
    super._createNavMap(), this._clustering && this._createClusterNavNodes();
  }
  _generateClustering() {
    const e = [], r = this._store.model.series;
    for (const i of r)
      for (let s = 0; s < i.length; s++)
        e.push({ x: Number(i.rawData[s].x), y: Number(i.rawData[s].y) });
    const n = [];
    if (r.length > 1)
      for (const i of r)
        for (let s = 0; s < i.length; s++)
          n.push(i[s].seriesKey);
    this._store.model.numSeries > 1 ? this._clustering = aO(e, !0, n) : this._clustering = aO(e, !1);
  }
  get navDatapointType() {
    return "scatterpoint";
  }
  seriesInNavOrder() {
    return this._store.model.series;
  }
  _createClusterNavNodes() {
    const e = [];
    this._navMap.root.query("series").forEach((n) => {
      e.length && n.connect("left", e.at(-1).at(-1));
      let i = this.clustering;
      this._store.model.numSeries > 1 && (i = i.slice(n.index, n.index + 1));
      const s = n.allNodes("right", "scatterpoint"), o = [];
      i.forEach((a) => {
        const l = new Ia(n.layer, "cluster", {
          seriesKey: n.options.seriesKey,
          start: 0,
          //cluster.dataPointIDs[0],
          end: a.dataPointIDs.length - 1,
          //cluster.dataPointIDs[cluster.dataPointIDs.length - 1],
          datapoints: this._store.model.numSeries > 1 ? a.dataPointIDs.map((c) => c - a.dataPointIDs[0]) : [...a.dataPointIDs, ...a.outlierIDs],
          clustering: a
        }, this._store);
        o.push(l);
      }), e.push(o), o.sort((a, l) => a.options.clustering.centroid[0] - l.options.clustering.centroid[0]), o.slice(0, -1).forEach((a, l) => {
        a.connect("right", o[l + 1]);
      }), n.connect("right", o[0]), s[0].disconnect("left", !1), s.at(-1).disconnect("right"), o.forEach((a) => {
        a.connect(
          "in",
          s[0],
          !s[0].getLink("out")
        );
        for (const l of s)
          l.connect("out", a, !1);
        a.peekNode("right", 1) && s.at(-1).connect("in", a.peekNode("right", 1), !1);
      });
    });
    const r = this.navMap.node("top", {});
    e.forEach((n, i) => {
      n.forEach((s, o) => {
        s.connect("out", r, !1);
      });
    }), r.connect("right", e[0][0], !0), e.slice(0, -1).forEach((n, i) => {
      n[n.length - 1].connect("right", e[i + 1][0], !0);
    });
  }
  _findCluster(e) {
    return this._clustering.findIndex((r) => r.dataPointIDs.includes(e));
  }
  async navRunDidEnd(e) {
    this._clustering && (e.isNodeType("cluster") ? this._currentCluster = e.options.clustering.id : e.isNodeType("scatterpoint") ? this._currentCluster = e.options.cluster : e.isNodeType("top") && (this._currentCluster = -1), this._store.paraChart.paraView.requestUpdate(), super.navRunDidEnd(e));
  }
}
class Xke extends T9 {
  constructor(e, r) {
    super(e, r);
  }
  _init() {
    this._resolution = this._store.settings.type.heatmap.resolution ?? 20, this._generateHeatmap();
    const e = this._grid.flat();
    this._maxCount = Math.max(...e), this._axisInfo = new Yv(this._store, {
      xValues: this._store.model.allFacetValues("x").map((r) => r.value),
      yValues: this._store.model.allFacetValues("y").map((r) => r.value)
    }), super._init();
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "textfield",
      key: "type.heatmap.resolution",
      label: "Resolution",
      options: {
        inputType: "number",
        min: 5,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.chart"
    });
  }
  get grid() {
    return this._grid;
  }
  get maxCount() {
    return this._maxCount;
  }
  _createPrimaryNavNodes() {
    super._createPrimaryNavNodes(), this._navMap.root.query("series").forEach((e) => {
      e.allNodes("right").slice(0, -this._resolution).forEach((r, n) => {
        r.connect("down", r.layer.get("datapoint", n + this._resolution));
      });
    });
  }
  _createNavLinksBetweenSeries() {
  }
  _createChordNavNodes() {
  }
  _datapointSummary(e) {
    const r = this._grid[e % this._resolution][Math.floor(e / this._resolution)], n = this._axisInfo.xLabelInfo, i = this._axisInfo.yLabelInfo, s = n.range / this._resolution, o = i.range / this._resolution, a = (i.max - o * Math.floor(e / this._resolution)).toFixed(2), l = (i.max - o * (Math.floor(e / this._resolution) + 1)).toFixed(2), c = (n.min + s * (e % this._resolution)).toFixed(2), p = (n.min + s * (e % this._resolution + 1)).toFixed(2);
    return `This block contains ${r} datapoints. It spans x values from ${c} to ${p}, and y values from ${l} to ${a}`;
  }
  async navRunDidEnd(e) {
    e.isNodeType("datapoint") && this._store.announce(this._datapointSummary(e.options.index));
  }
  _generateHeatmap() {
    const e = this._store.model.series;
    this._data = [];
    for (let h of e)
      for (let d = 0; d < h.length; d++)
        this._data.push([h[d].facetValueNumericized("x"), h[d].facetValueNumericized("y")]);
    const r = [], n = [];
    for (const h of this._data)
      n.push(h[0]), r.push(h[1]);
    const i = k2(
      Math.min(...this._store.model.allFacetValues("x").map((h) => h.value)),
      Math.max(...this._store.model.allFacetValues("x").map((h) => h.value)),
      !1
    ), s = k2(
      Math.min(...this._store.model.allFacetValues("y").map((h) => h.value)),
      Math.max(...this._store.model.allFacetValues("y").map((h) => h.value)),
      !1
    );
    let o = s.max, a = i.max, l = s.min, c = i.min;
    a += (a - c) / 10, c -= (a - c) / 10;
    const p = [];
    for (let h = 0; h < this.resolution; h++) {
      p.push([]);
      for (let d = 0; d < this.resolution; d++)
        p[h].push(0);
    }
    for (const h of this._data) {
      const d = Math.floor((h[0] - c) * this.resolution / (a - c)), b = Math.floor((h[1] - l) * this.resolution / (o - l));
      p[d][this.resolution - b - 1]++;
    }
    return this._grid = p, p;
  }
  get resolution() {
    return this._resolution;
  }
  goSeriesMinMax(e) {
  }
  goChartMinMax(e) {
  }
}
const e7e = {
  bar: BR,
  column: BR,
  line: K9e,
  pie: FR,
  donut: FR,
  scatter: Jke,
  heatmap: Xke
  // histogram: Histogram,
  // gauge: BarChart, //GaugeChart,
  // stepline: LineChart, //StepLineChart,
  // lollipop: BarChart, //LollipopChart
};
class PU extends Pr {
  constructor(e, r) {
    super(e.paraview), this.axis = e, this.length = r, this._classInfo = { "axis-line": !0 };
  }
  get length() {
    return 0;
  }
  set length(e) {
  }
  _createId(...e) {
    return `${this.axis.orientation}-axis-line`;
  }
  render() {
    const e = nt`translate(${this._x},${this._y})`;
    return Tt`
      <path
        transform=${this._x !== 0 || this._y !== 0 ? e : De}
        id=${this._id}
        class=${Br(this._classInfo)}
        d=${this.getLineD()}
      ></path>
    `;
  }
}
class t7e extends PU {
  constructor(e, r) {
    super(e, r), this._height = 0, this._canWidthFlex = !0;
  }
  get length() {
    return this.width;
  }
  set length(e) {
    this.width = e, super.length = e;
  }
  getLineD() {
    if (this.axis.orientationSettings.line.isDrawOverhang) {
      const e = this.paraview.store.settings.axis.vert.ticks.length, r = this.paraview.store.settings.axis.vert.position === "west" ? -e : 0;
      return nt`M${r},0 h${this.width + e}`;
    } else
      return nt`M0,0 h${this.width}`;
  }
}
class r7e extends PU {
  constructor(e, r) {
    super(e, r), this._width = 0, this._canHeightFlex = !0;
  }
  get length() {
    return this.height;
  }
  set length(e) {
    this.height = e, super.length = e;
  }
  getLineD() {
    if (this.axis.orientationSettings.line.isDrawOverhang) {
      const e = this.paraview.store.settings.axis.horiz.ticks.length, r = this.paraview.store.settings.axis.horiz.position === "north" ? -e : 0;
      return nt`M0,${r} v${this.height + e}`;
    } else
      return nt`M0,0 v${this.height}`;
  }
}
class RU extends bo(Pr) {
  constructor(e, r, n, i, s, o) {
    super(o), this.axis = e, this.tickLabels = r, this.tierIndex = n, this._tickStep = s, this._updateSizeFromLength(i), this.createTickLabels();
  }
  resize(e, r) {
    super.resize(e, r), this.createTickLabels();
  }
  get class() {
    return "tick-label-tier";
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get tickInterval() {
    return this._labelDistance;
  }
  _createId(...e) {
    return `tick-label-tier-${this.axis.orientation}-${this.tierIndex}`;
  }
  _maxLabelWidth() {
    return this._children.length ? Math.max(...this._children.map((e) => e.paddedWidth ?? 0)) : 0;
  }
  _maxLabelHeight() {
    return this._children.length ? Math.max(...this._children.map((e) => e.paddedHeight ?? 0)) : 0;
  }
  createTickLabels(e = !0) {
    const r = this.axis.isInterval ? this.tickLabels.length : this.tickLabels.length - 1;
    this._labelDistance = this._length / (r / this._tickStep), this.clearChildren();
    for (const [n, i] of this.tickLabels.entries()) {
      if (n % this._tickStep)
        continue;
      const s = new di(this.paraview, {
        id: `tick-label-${this.axis.orientation}-${n}`,
        classList: [
          "tick-label",
          `tick-label-${this.axis.orientation}`,
          this.axis.orientationSettings.position
        ],
        role: "axislabel",
        text: i,
        textAnchor: this._labelTextAnchor,
        wrapWidth: this._labelWrapWidth,
        x: 0,
        y: 0,
        pointerEnter: (o) => {
          this.addPopup(i, n);
        },
        pointerLeave: (o) => {
          this.removePopup(this.id);
        }
      });
      this.append(s);
    }
  }
  addPopup(e, r) {
  }
  removePopup(e) {
  }
  updateTickLabelIds() {
  }
}
class n7e extends RU {
  constructor(e, r, n, i, s, o) {
    super(e, r, n, i, s, o), this.axis = e, this.tickLabels = r, this.log = qt("HorizTickLabelTier"), this._canWidthFlex = !0, this.padding = { top: this.axis.orientationSettings.ticks.labels.offsetGap };
  }
  _updateSizeFromLength(e) {
    this._width = e;
  }
  get _length() {
    return this._width;
  }
  get _labelTextAnchor() {
    return this.axis.orientationSettings.ticks.labels.angle ? "end" : "middle";
  }
  get _labelWrapWidth() {
    return this._labelDistance;
  }
  computeSize() {
    return [this._width, this._maxLabelHeight()];
  }
  _tickLabelX(e) {
    let r = this._labelDistance * e;
    return this.axis.isInterval && (r += this._labelDistance / this._tickStep / 2), this.axis.orientationSettings.labelOrder === "westToEast" ? r : this._width - r;
  }
  _tickLabelY(e) {
    return this.paraview.store.model.getAxisFacet(this.axis.orientation) ?? this.paraview.store.model.getFacet(this.axis.orientation === "horiz" ? "x" : "y"), this.axis.orientationSettings.position === "north" ? this.height : 0;
  }
  createTickLabels(e = !0) {
    super.createTickLabels(), this._children.forEach((r, n) => {
      this.paraview.store.settings.axis.horiz.ticks.labels.angle && (r.angle = this.axis.orientationSettings.ticks.labels.angle), r.angle === 0 ? (r.top = this._tickLabelY(n), r.centerX = this._tickLabelX(n)) : r.angle > 0 ? r.topLeft = new Ye(this._tickLabelX(n), this._tickLabelY(n)) : r.topRight = new Ye(this._tickLabelX(n), this._tickLabelY(n));
    }), this.updateSize(), e && (this._tickStep = this._optimizeLabelSpacing(), this.createTickLabels(!1));
  }
  _optimizeLabelSpacing() {
    const e = this._children.map((i) => i.bbox);
    let r = [...e];
    this._children.map((i) => i.locOffset.x);
    let n = this._tickStep;
    for (this._width; ; ) {
      const i = r.slice(1).map((o, a) => o.left - r[a].right), s = Math.min(...i);
      if (Math.round(s) < this.axis.orientationSettings.ticks.labels.gap) {
        if (n++, r = e.filter((a, l) => l % n === 0), !(Math.floor(this.tickLabels.length / n) + this.tickLabels.length % n))
          throw new Error("tick labels will always overlap");
        continue;
      }
      break;
    }
    return n;
  }
  addPopup(e, r) {
    var o;
    let n = "no text detected";
    const i = this.tickLabels.length % this.children.length == 0 ? this.children.length / this.tickLabels.length : this.children.length / (this.tickLabels.length + 1);
    let s = new ls(
      this.paraview,
      {
        text: e ?? n,
        x: this._tickLabelX(r ?? 0) * i,
        y: (o = this.paraview.documentView) == null ? void 0 : o.chartLayers.height,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        type: "horizTick",
        fill: "hsl(0, 0%, 0%)",
        inbounds: !1
      },
      {
        fill: "hsl(0, 0%, 100%)",
        shape: "boxWithArrow"
      }
    );
    this.paraview.store.popups.push(s);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
}
class i7e extends RU {
  constructor(e, r, n, i, s, o) {
    super(e, r, n, i, s, o), this.axis = e, this.tickLabels = r, this._canHeightFlex = !0, this.padding = { right: this.axis.orientationSettings.ticks.labels.offsetGap };
  }
  _updateSizeFromLength(e) {
    this._height = e;
  }
  get _length() {
    return this._height;
  }
  get _labelTextAnchor() {
    return "end";
  }
  get _labelWrapWidth() {
  }
  computeSize() {
    return [this._maxLabelWidth(), this._height];
  }
  _tickLabelX(e) {
    return this.axis.orientationSettings.position === "west" ? this.width : 0;
  }
  _tickLabelY(e) {
    const r = this._labelDistance * e;
    return this.axis.orientationSettings.labelOrder === "northToSouth" ? r + this._labelDistance / 2 + this._children[e].height / 3 : this.height - r + this._children[e].height / 3;
  }
  createTickLabels() {
    super.createTickLabels(), this.updateSize(!1), this._children.forEach((e, r) => {
      e.x = this._tickLabelX(r), e.y = this._tickLabelY(r);
    });
  }
  addPopup(e, r) {
    let n = "no text detected", i = new ls(
      this.paraview,
      {
        text: e ?? n,
        x: this._tickLabelX(r ?? 0) + 15,
        y: this._tickLabelY(r ?? 0) + this.paraview.store.settings.popup.margin - this.children[r ?? 0].height,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        type: "vertTick",
        fill: "hsl(0, 0%, 0%)",
        inbounds: !1
      },
      {
        fill: "hsl(0, 0%, 100%)",
        shape: "boxWithArrow"
      }
    );
    this.paraview.store.popups.push(i);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
}
class OU extends Pr {
  constructor(e, r = !0, n, i, s = !1) {
    super(e), this._major = r, this._orientation = i, this.darken = s, this.length = n;
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get length() {
    return 0;
  }
  set length(e) {
  }
  _addedToParent() {
    this.updateSize();
  }
  content() {
    const e = this._shouldNegateLength ? -this.length : this.length, r = nt`M${this._x},${this._y}`, n = this._orientation + nt`${e}`;
    return Tt`
      <path
        id=${this.darken ? "grid-zero" : ""}
        class=${Br(this.classInfo)}
        d=${r + " " + n}
      ></path>
    `;
  }
}
class TU extends OU {
  /**
   * @param _pointsTo - The tick starts on the axis and points in this direction.
   * @param major
   */
  constructor(e, r, n = !0, i, s = !1) {
    super(r, n, i, "v", s), this._pointsTo = e;
  }
  get length() {
    return this.height;
  }
  set length(e) {
    this.height = e, super.length = e;
  }
  computeSize() {
    return [
      0,
      // computeSize() initially gets called before the parent is set
      this.height
    ];
  }
}
class LU extends OU {
  /**
   * @param _pointsTo - The tick starts on the axis and points in this direction.
   * @param major
   */
  constructor(e, r, n = !0, i, s = !1) {
    super(r, n, i, "h", s), this._pointsTo = e;
  }
  get length() {
    return this.width;
  }
  set length(e) {
    this.width = e, super.length = e;
  }
  computeSize() {
    return [
      // computeSize() initially gets called before the parent is set
      this.width,
      0
    ];
  }
}
class s7e extends TU {
  get classInfo() {
    return {
      tick: !0,
      "tick-horiz": !0
    };
  }
  get length() {
    return this._major ? super.length : super.length / 2;
  }
  set length(e) {
    super.length = e;
  }
  get _shouldNegateLength() {
    return this._pointsTo === "north";
  }
}
class o7e extends LU {
  get classInfo() {
    return {
      tick: !0,
      "tick-vert": !0
    };
  }
  get length() {
    return this._major ? super.length : super.length / 2;
  }
  set length(e) {
    super.length = e;
  }
  get _shouldNegateLength() {
    return this._pointsTo === "west";
  }
}
class a7e extends TU {
  get classInfo() {
    return {
      grid: !0,
      "grid-horiz": !0
    };
  }
  get _shouldNegateLength() {
    return this._pointsTo === "south";
  }
}
class l7e extends LU {
  get classInfo() {
    return {
      grid: !0,
      "grid-vert": !0
    };
  }
  get _shouldNegateLength() {
    return this._pointsTo === "east";
  }
}
class MU extends bo(Pr) {
  constructor(e, r, n, i) {
    super(e), this._axisSettings = r, this._majorModulus = n, this._options = i, this._indices = [], this._updateSizeFromLength(this._options.length), this._count = this._options.tickCount, this._options.isInterval, this._computeInterval();
  }
  resize(e, r) {
    super.resize(e, r), this._computeInterval(), this.clearChildren(), this._createTicks();
  }
  // protected _computeCount() {
  //   // XXX CIRCULAR DEPENDENCY between this and computeInterval()
  //   const intervalCount = this._length / this._interval;
  //   this._count = Math.round(intervalCount);
  //   if (this._options.isInterval) {
  //     this._count++;
  //   }
  // }
  _computeInterval() {
    const e = this._options.isInterval ? this._count : this._count - 1;
    this._interval = this._length / (e / this._options.tickStep);
  }
  _addedToParent() {
    this._createTicks();
  }
  /**
   * Overridden by subclasses to set the appropriate size dimension from `length`.
   */
  _updateSizeFromLength(e) {
    this.updateSize();
  }
  _createId(...e) {
    return `${this._options.orientation}-axis-tick-strip`;
  }
  get parent() {
    return this._parent;
  }
  get class() {
    return "tick-strip";
  }
  set parent(e) {
    super.parent = e;
  }
}
class c7e extends MU {
  constructor(e, r, n, i) {
    super(e, r, n, i), this._ruleXs = [], this._ruleY = 0, this._canWidthFlex = !0;
  }
  computeSize() {
    return [
      this._options.length,
      // NB! The grid lines DON'T COUNT toward the height!
      this._axisSettings.ticks.isDrawTicks || this._options.isDrawOverhang ? this._axisSettings.ticks.length : 0
    ];
  }
  get _length() {
    return this._width;
  }
  _updateSizeFromLength(e) {
    this._width = e, super._updateSizeFromLength(e);
  }
  // resize(width: number, height: number, interval: number) {
  //   this.width = width;
  //   this._gridLineLength = height;
  //   super.resize(width, height, interval);
  // }
  _createTicks() {
    const e = this._options.orthoAxisPosition === "east";
    let r = this._axisSettings.ticks.length;
    this._ruleY = 0, this._axisSettings.position === "north" && (this._ruleY = this._axisSettings.ticks.isDrawTicks || this._options.isDrawOverhang ? r + this._axisSettings.ticks.padding : 0), this._indices = ua(this._count + (this._options.isInterval ? 1 : 0), (n) => n).filter((n) => n % this._options.tickStep === 0), this.paraview.store.settings.grid.isDrawVertAxisOppositeLine || (this._indices = e ? this._indices.slice(0, -1) : this._indices.slice(1)), this._indices = this._indices.slice(1), this._ruleXs = this._indices.map((n) => e ? this.width - n * this._interval : n * this._interval), this._indices.forEach((n, i) => {
      this.append(new s7e(
        this._axisSettings.position,
        this.paraview,
        n % this._majorModulus === 0,
        r
      )), this._children.at(-1).x = this._ruleXs[i], this._children.at(-1).y = this._ruleY;
    });
  }
  addRules(e) {
    this._indices.forEach((r, n) => {
      this.append(new a7e(
        this._axisSettings.position,
        this.paraview,
        void 0,
        e,
        n === this._options.zeroIndex
      )), this._children.at(-1).x = this._ruleXs[n], this._children.at(-1).y = this._ruleY, this._children.at(-1).hidden = !this.paraview.store.settings.grid.isDrawVertLines;
    });
  }
}
class u7e extends MU {
  constructor(e, r, n, i) {
    super(e, r, n, i), this._ruleX = 0, this._ruleYs = [], this._canHeightFlex = !0;
  }
  computeSize() {
    return [
      // NB! The grid lines DON'T COUNT toward the width!
      this._axisSettings.ticks.isDrawTicks || this._options.isDrawOverhang ? this._axisSettings.ticks.length : 0,
      this._options.length
    ];
  }
  get _length() {
    return this._height;
  }
  _updateSizeFromLength(e) {
    this._height = e, super._updateSizeFromLength(e);
  }
  // protected _adjustToSizeConstraint() {
  //   this._gridLineLength = width;
  //   this.height = height;
  //   super.resize(width, height, interval);
  // }
  _createTicks() {
    const e = this._options.orthoAxisPosition === "north", r = this._axisSettings.ticks.length;
    this._ruleX = r, this._indices = ua(this._count, (n) => n), this.paraview.store.settings.grid.isDrawHorizAxisOppositeLine || (this._indices = e ? this._indices.slice(1) : this._indices.slice(0, -1)), this._axisSettings.position === "east" && (this._ruleX = 0), this._ruleYs = this._indices.map((n) => e ? this.height - n * this._interval : n * this._interval), this._indices.forEach((n) => {
      this.append(new o7e(
        this._axisSettings.position,
        this.paraview,
        n % this._majorModulus === 0,
        r
      )), this._children.at(-1).x = this._ruleX, this._children.at(-1).y = this._ruleYs[n];
    });
  }
  addRules(e) {
    this._indices.forEach((r) => {
      this.append(new l7e(
        this._axisSettings.position,
        // XXX don't use `plotWidth` here
        this.paraview,
        void 0,
        e,
        this._indices.length - r - 1 === this._options.zeroIndex
      )), this._children.at(-1).x = this._ruleX, this._children.at(-1).y = this._ruleYs[r], this._children.at(-1).hidden = !this.paraview.store.settings.grid.isDrawHorizLines;
    });
  }
}
class sPe extends Error {
  constructor(e) {
    super(), this.preferredWidth = e;
  }
}
class oPe extends Error {
  constructor(e) {
    super(), this.preferredTickStep = e;
  }
}
class NU extends bo(Pr) {
  constructor(e, r) {
    super(e.paraview), this.docView = e, this.orientation = r, this._tickLabelTiers = [], this._tickStrip = null, this._store = this.paraview.store, this.chartLayers = e.chartLayers, this._facet = e.chartInfo.axisInfo.getFacetForOrientation(this.orientation), this.datatype = this._facet.datatype, this.settings = br.getGroupLink(
      this.managedSettingKeys[0],
      this._store.settings
    ), this.orientationSettings = br.getGroupLink(
      `axis.${r}`,
      this._store.settings
    ), this._tickStep = this.orientationSettings.ticks.step, this._labelInfo = this.coord === "x" ? e.chartInfo.axisInfo.xLabelInfo : e.chartInfo.axisInfo.yLabelInfo, this._isInterval = this.coord === "x" ? !!e.chartInfo.axisInfo.options.isXInterval : !!e.chartInfo.axisInfo.options.isYInterval, this._titleText = this.orientationSettings.title.text ?? "";
  }
  get coord() {
    return this._store.model.facetKeys.find((e) => this._store.model.getFacet(e) === this._facet);
  }
  _createId() {
    return `${this.orientation}-axis`;
  }
  isHoriz() {
    return this.orientation === "horiz";
  }
  isVert() {
    return this.orientation === "vert";
  }
  get asHoriz() {
    if (this.isHoriz())
      return this;
    throw new Error("axis is not horizontal");
  }
  get asVert() {
    if (this.isVert())
      return this;
    throw new Error("axis is not vertical");
  }
  get managedSettingKeys() {
    return [`axis.${this.coord}`];
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get tickStep() {
    return this._tickStep;
  }
  get isInterval() {
    return this._isInterval;
  }
  get tickLabelTiers() {
    return this._tickLabelTiers;
  }
  get role() {
    return "graphics-object";
  }
  get roleDescription() {
    return `${this.coord}-axis`;
  }
  get extraAttrs() {
    return [
      {
        attr: Lu`data-axistype`,
        value: this.datatype
      }
    ];
  }
  get viewGroup() {
    return this._layout;
  }
  get titleText() {
    return this._titleText;
  }
  // get range() {
  //   return this.chartLayers.getAxisInterval(this.coord);
  // }
  get orthoAxis() {
    return this._orthoAxis;
  }
  get layout() {
    return this._layout;
  }
  set orthoAxis(e) {
    this._orthoAxis = e;
  }
  resize(e, r) {
    this._layout.resize(e, r), super.resize(e, r);
  }
  _childDidResize(e) {
    this.updateSize();
  }
  // settingDidChange(path: string, _oldValue?: Setting, _newValue?: Setting): void {
  //   if (['axis.y.maxValue', 'axis.y.minValue'].includes(path)) {
  //     this._layout.clearChildren();
  //     this.createComponents();
  //     this.layoutComponents();
  //   }
  // }
  createComponents() {
    this.orientationSettings.title.isDrawTitle && this._titleText && (this._createAxisTitle(), this._appendTitle()), this.orientationSettings.ticks.labels.isDrawTickLabels && (this._tickLabelTiers = this._createTickLabelTiers(), this._appendTickLabelTiers()), this.orientationSettings.ticks.isDrawTicks && (this._tickStrip = this._createTickStrip(), this._appendTickStrip()), this.orientationSettings.line.isDrawAxisLine && (this._createAxisLine(), this._appendAxisLine());
  }
  layoutComponents() {
  }
  _createAxisTitle() {
    this._axisTitle = new di(this.paraview, {
      id: `axis-title-${this.orientation}`,
      text: this.titleText,
      classList: [`axis-title-${this.orientation}`],
      role: "heading",
      angle: this._getAxisTitleAngle(),
      pointerEnter: (e) => {
        this.addPopup();
      },
      pointerLeave: (e) => {
        this.removePopup(this.id);
      }
    }), this._axisTitle.padding = this._getAxisTitlePadding();
  }
  addPopup(e) {
    let r = `${this.titleText}`, n = new ls(
      this.paraview,
      {
        text: e ?? r,
        x: this.x,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        type: "vertAxis",
        fill: "hsl(0, 0%, 0%)"
      },
      {
        fill: "hsl(0, 0%, 100%)",
        shape: "boxWithArrow"
      }
    );
    this.paraview.store.popups.push(n);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
  updateTickLabelIds() {
    for (const e of this._tickLabelTiers)
      e.updateTickLabelIds();
  }
  setAxisLabelText(e) {
    this._titleText = e ?? this.orientationSettings.title.text ?? "", this._axisTitle && (this._axisTitle.text = this._titleText);
  }
  _getAxisTitleAngle() {
    return 0;
  }
  addGridRules(e) {
    var r;
    (r = this._tickStrip) == null || r.addRules(e);
  }
}
class h7e extends NU {
  constructor(e) {
    super(e, "horiz"), this._canWidthFlex = !0, this._layout = new _h(this.paraview, {
      numCols: 1,
      rowAligns: "end",
      colAligns: "center",
      canWidthFlex: !0,
      width: this.docView.width,
      isAutoHeight: !0
    }, "horiz-axis-layout"), this._layout.isBubbleSizeChange = !0, this.append(this._layout);
  }
  get length() {
    return this._width;
  }
  computeSize() {
    return [
      this._layout.width,
      this._layout.height
    ];
  }
  _appendTitle() {
    this._layout.append(this._axisTitle);
  }
  _createTickLabelTiers() {
    return this._labelInfo.labelTiers.map((e, r) => new n7e(
      this,
      e,
      r,
      this.docView.width,
      this._tickStep,
      this.paraview
    ));
  }
  _appendTickLabelTiers() {
    this._tickLabelTiers.forEach((e, r) => {
      this._layout.splitRowTop(0, "end"), this._layout.append(e);
    });
  }
  _createTickStrip() {
    return new c7e(this.paraview, this.orientationSettings, 1, {
      orientation: this.orientation,
      length: this.docView.width,
      plotWidth: this.docView.width,
      plotHeight: this._layout.height,
      tickCount: this._labelInfo.labelTiers[0].length,
      isInterval: this._isInterval,
      isDrawOverhang: this.paraview.store.settings.axis.vert.line.isDrawOverhang,
      tickStep: this._tickStep,
      orthoAxisPosition: this.paraview.store.settings.axis.vert.position,
      zeroIndex: this._labelInfo.labelTiers[0].findIndex((e) => e === "0") - 1
    });
  }
  _appendTickStrip() {
    this._layout.splitRowTop(0, "end"), this._layout.append(this._tickStrip);
  }
  _createAxisLine() {
    this._axisLine = new t7e(this, this.docView.width);
  }
  _appendAxisLine() {
    this._layout.splitRowTop(0, "end"), this._layout.append(this._axisLine);
  }
  _getAxisTitlePadding() {
    return this.orientationSettings.position === "south" ? { top: this.orientationSettings.title.gap } : { bottom: this.orientationSettings.title.gap };
  }
  layoutComponents() {
    this.orientationSettings.position === "south" && (this._layout.reverseChildren(), this._layout.layoutViews()), super.layoutComponents();
  }
}
class p7e extends NU {
  constructor(e) {
    super(e, "vert"), this._canHeightFlex = !0, this._layout = new _h(this.paraview, {
      numCols: 1,
      // new cols will get added as needed
      rowAligns: "center",
      colAligns: "start",
      canHeightFlex: !0,
      height: this.docView.height,
      isAutoWidth: !0
    }, "vert-axis-layout"), this._layout.isBubbleSizeChange = !0, this.append(this._layout);
  }
  get length() {
    return this._height;
  }
  _addedToParent() {
    super._addedToParent();
    const e = this._labelInfo.min, r = this._labelInfo.max;
    this.paraview.store.settingControls.add({
      type: "textfield",
      key: "axis.y.minValue",
      label: "Min y-value",
      options: { inputType: "number" },
      value: this.settings.minValue === "unset" ? e : this.settings.minValue,
      validator: (n) => {
        const i = this.paraview.store.settings.axis.y.maxValue === "unset" ? Math.max(...this.docView.chartInfo.axisInfo.options.yValues) : this.paraview.store.settings.axis.y.maxValue;
        return n >= i ? { err: `Min y-value (${n}) must be less than (${i})` } : {};
      },
      parentView: "controlPanel.tabs.chart.general.minY"
    }), this.paraview.store.settingControls.add({
      type: "textfield",
      key: "axis.y.maxValue",
      label: "Max y-value",
      options: { inputType: "number" },
      value: this.settings.maxValue === "unset" ? r : this.settings.maxValue,
      validator: (n) => {
        const i = this.paraview.store.settings.axis.y.minValue == "unset" ? Math.min(...this.docView.chartInfo.axisInfo.options.yValues) : this.paraview.store.settings.axis.y.minValue;
        return n <= i ? { err: `Max y-value (${n}) must be greater than (${i})` } : {};
      },
      parentView: "controlPanel.tabs.chart.general.maxY"
    });
  }
  computeSize() {
    return [
      this._layout.width,
      this._layout.height
    ];
  }
  _appendTitle() {
    this._layout.append(this._axisTitle);
  }
  _createTickLabelTiers() {
    return this._labelInfo.labelTiers.map((e, r) => new i7e(
      this,
      e,
      r,
      this.docView.height,
      this._tickStep,
      this.paraview
    ));
  }
  _appendTickLabelTiers() {
    this._tickLabelTiers.forEach((e, r) => {
      this._layout.splitColumnRight(r, 0, "start"), this._layout.append(e, {
        x: r + 1
      });
    });
  }
  _createTickStrip() {
    return new u7e(this.paraview, this.orientationSettings, 1, {
      orientation: this.orientation,
      length: this.docView.height,
      plotWidth: this.docView.width,
      plotHeight: this.docView.height,
      tickCount: this._labelInfo.labelTiers[0].length,
      isInterval: this._isInterval,
      isDrawOverhang: this.paraview.store.settings.axis.horiz.line.isDrawOverhang,
      tickStep: this._tickStep,
      orthoAxisPosition: this.paraview.store.settings.axis.horiz.position,
      // XXX could be '0.0' or have a unit, etc.
      zeroIndex: this._labelInfo.labelTiers[0].findIndex((e) => e === "0")
    });
  }
  _appendTickStrip() {
    this._layout.splitColumnRight(this._tickLabelTiers.length, 0, "start"), this._layout.append(this._tickStrip, {
      x: this._layout.numCols - 1
    });
  }
  _createAxisLine() {
    this._axisLine = new r7e(this, this.docView.height);
  }
  _appendAxisLine() {
    this._layout.splitColumnRight(this._tickLabelTiers.length + 1, 0, "start"), this._layout.append(this._axisLine, {
      x: this._layout.numCols - 1
    });
  }
  _getAxisTitlePadding() {
    return this.orientationSettings.position === "west" ? { right: this.orientationSettings.title.gap } : { left: this.orientationSettings.title.gap };
  }
  tickLabelTotalWidth() {
    return this._tickLabelTiers.map((e) => e.width).reduce((e, r) => e + r, 0);
  }
  layoutComponents() {
    this.orientationSettings.position === "west" || this._layout.reverseChildren(), super.layoutComponents();
  }
  _getAxisTitleAngle() {
    return this.orientationSettings.position === "east" ? 90 : -90;
  }
}
const uO = (...t) => {
  const e = [];
  for (let r = 0; r < Math.max(...t.map((n) => n.length)); r++)
    t.forEach((n) => {
      n[r] !== void 0 && e.push(n[r]);
    });
  return e;
};
class o1 extends bo(Pr) {
  constructor(e, r, n = { orientation: "vert" }) {
    super(e), this._items = r, this._options = n, this._markers = [];
  }
  get settings() {
    return br.getGroupLink("legend", this.paraview.store.settings);
  }
  get classInfo() {
    return { legend: !0 };
  }
  _addedToParent() {
    const e = [], r = this.settings.boxStyle.outline !== "none" || this.settings.boxStyle.fill !== "none";
    this._items.forEach((s) => {
      this._markers.push(new sn(this.paraview, { width: 12, height: 6 })), e.push(this._markers.at(-1)), e.push(Fa.fromType(
        this.paraview,
        this.paraview.store.settings.chart.isDrawSymbols ? s.symbol ?? "square.solid" : "square.solid",
        {
          color: s.color,
          pointerEnter: (o) => {
            this.paraview.store.lowlightOtherSeries(s.seriesKey);
          },
          pointerLeave: (o) => {
            this.paraview.store.clearAllSeriesLowlights();
          }
        }
      )), e.push(new di(this.paraview, {
        text: s.label,
        x: 0,
        y: 0,
        textAnchor: "start",
        classList: ["legend-label"],
        pointerEnter: (o) => {
          this.paraview.store.lowlightOtherSeries(s.seriesKey);
        },
        pointerLeave: (o) => {
          this.paraview.store.clearAllSeriesLowlights();
        }
      }));
    });
    const n = this.paraview.store.settings.legend.symbolLabelGap, i = this.paraview.store.settings.legend.pairGap;
    if (this._options.orientation === "vert")
      this._grid = new _h(this.paraview, {
        numCols: 3,
        colGaps: n,
        colAligns: ["center", "center", "start"],
        isAutoWidth: !0,
        isAutoHeight: !0
      }, "legend-grid"), this._grid.padding = r ? this.paraview.store.settings.legend.padding : 0, e.forEach((s) => this._grid.append(s));
    else {
      let s = e.length / 3;
      for (; ; ) {
        const o = uO(
          new Array(s).fill(0),
          new Array(s).fill(n),
          new Array(s - 1).fill(i)
        );
        if (this._grid = new _h(this.paraview, {
          numCols: s * 3,
          colGaps: o
        }, "legend-grid"), this._grid.padding = r ? this.paraview.store.settings.legend.padding : 0, e.forEach((a) => this._grid.append(a)), this._options.wrapWidth === void 0 || this._grid.paddedWidth <= this._options.wrapWidth || s === 1)
          break;
        s--, e.forEach((a) => a.remove());
      }
      this._grid.colAligns = uO(
        new Array(s).fill("center"),
        new Array(s).fill("start")
      );
    }
    this.append(this._grid), r && this.prepend(new sn(this.paraview, {
      width: this._grid.width,
      height: this._grid.height,
      fill: this.settings.boxStyle.fill,
      stroke: this.settings.boxStyle.outline,
      strokeWidth: this.settings.boxStyle.outlineWidth
    })), this.updateSize();
  }
  computeSize() {
    var e, r;
    return [((e = this._grid) == null ? void 0 : e.paddedWidth) ?? 0, ((r = this._grid) == null ? void 0 : r.paddedHeight) ?? 0];
  }
  content() {
    return this._items.forEach((e, r) => {
      const n = this._markers[r].styleInfo;
      (e.datapointIndex !== void 0 ? this.paraview.store.isVisited(
        this.paraview.store.model.seriesKeys[0],
        e.datapointIndex
      ) : this.paraview.store.isVisitedSeries(e.label)) ? n.fill = this.paraview.store.colors.colorValueAt(-1) : n.fill = "none", this._markers[r].styleInfo = n;
    }), super.content();
  }
}
class d7e extends bo(Pr) {
  constructor(e) {
    super(e.paraview), this._chart = e, this.log = qt("DirectLabelStrip"), this._id = "direct-label-strip", this._createLabels();
  }
  _createLabels() {
    var s;
    const e = this.paraview.store.settings.chart.isDrawSymbols ? this._chart.settings.seriesLabelPadding * 2 : this._chart.settings.seriesLabelPadding, r = this._chart.datapointViews.filter(
      (o) => o.index === this.paraview.store.model.series[0].length - 1
    );
    r.sort((o, a) => o.y - a.y), (s = this._seriesLabels) == null || s.forEach((o) => {
      o.remove();
    }), this._seriesLabels = [], r.forEach((o, a) => {
      this._seriesLabels.push(new di(this.paraview, {
        text: o.series.label,
        left: e,
        y: o.y,
        classList: ["direct-label"],
        pointerEnter: (l) => {
          this.paraview.store.lowlightOtherSeries(o.seriesKey);
        },
        pointerLeave: (l) => {
          this.paraview.store.clearAllSeriesLowlights();
        }
      })), this.append(this._seriesLabels.at(-1));
    }), this._seriesLabels.forEach((o) => {
      o.y += o.locOffset.y / 2;
    });
    const n = this._seriesLabels[0];
    n.y < 0 && (n.y = 0), this._seriesLabels.at(-1).bottom - this.height, this.resolveSeriesLabelCollisions(r);
  }
  _addedToParent() {
    this.observeNotices();
  }
  noticePosted(e, r) {
    ["animRevealStep", "animRevealEnd"].includes(e) && this._createLabels();
  }
  computeSize() {
    return [
      Math.max(...this._seriesLabels.map((e) => e.right)),
      this._chart.height
    ];
  }
  // XXX I don't think this method will get the job done in all cases
  resolveSeriesLabelCollisions(e) {
    var n, i;
    const r = [];
    for (let s = 1; s < this._seriesLabels.length; s++)
      this._seriesLabels[s].top < this._seriesLabels[s - 1].bottom && (((n = r.at(-1)) == null ? void 0 : n.label) !== this._seriesLabels[s - 1] && r.push({ label: this._seriesLabels[s - 1], endpoint: e[s - 1] }), r.push({ label: this._seriesLabels[s], endpoint: e[s] }));
    if ((i = this._leaders) == null || i.forEach((s) => {
      s.remove();
    }), this._leaders = [], r.length) {
      const s = this.paraview.store.settings.chart.isDrawSymbols ? -this._chart.settings.seriesLabelPadding : 0;
      r.reverse().slice(1).forEach((a, l) => {
        a.label.bottom = r[l].label.top;
      });
      const o = this._seriesLabels.filter((a) => !r.map((l) => l.label).includes(a)).toReversed();
      if (o.length) {
        const l = r.at(-1).label.bottom - o[0].y;
        l < 0 && (o.forEach((c) => c.y -= l), o.at(-1).y < 0 && this.log.warn("unable to resolve series label collision"));
      }
      r.forEach((a) => {
        a.label.x += this._chart.settings.leaderLineLength + s, this._leaders.push(new f7e(a.endpoint, a.label, this._chart)), this.prepend(this._leaders.at(-1));
      });
    }
  }
  // content(): TemplateResult {
  //   for (const label of this._seriesLabels) {
  //     const classInfo = label.classInfo;
  //   }
  //   return super.content();
  // }
}
class f7e extends Pr {
  constructor(e, r, n) {
    super(n.paraview), this._endpoint = e, this._chart = n, this._endX = this._chart.paraview.store.settings.type.line.leaderLineLength, this._endY = r.y - r.locOffset.y / 2, this._lineD = nt`
      M${0},${e.y}
      L${this._endX},${this._endY}`;
  }
  get styleInfo() {
    const e = {};
    let r = this._chart.paraview.store.colors.colorValueAt(this._endpoint.seriesProps.color);
    return e.fill = r, e.stroke = r, e;
  }
  get classInfo() {
    return {
      "label-leader": !0,
      lowlight: this.paraview.store.isSeriesLowlighted(this._endpoint.seriesKey)
    };
  }
  content() {
    return Tt`
      <g
        class=${Br(this.classInfo)}
        style=${mn(this.styleInfo)}
      >
        <path
          d=${this._lineD}
          />
        <circle
          cx=${this._endX}
          cy=${this._endY}
          r="1.8"
        />
      </g>
    `;
  }
}
class g7e extends bo(Pr) {
  constructor(e) {
    super(e), this._directLabelStrip = null, this._legends = {}, this.log = qt("DocumentView"), this._store = e.store, this.observeNotices(), this.type = this._store.type, this._chartInfo = new e7e[this.type](this.type, this._store, this), this.setTitleText(this._store.title);
    const r = this._parsePadding(this._store.settings.chart.padding), n = Math.max(8 + 1.1 * 16, r.left);
    this.padding = {
      left: n,
      right: r.right,
      top: r.top,
      bottom: r.bottom
    }, this._createGrid();
  }
  _createGrid() {
    var e;
    (e = this._grid) == null || e.remove(), this._grid = new _h(this.paraview, {
      width: this._store.settings.chart.size.width - this._padding.left - this._padding.right,
      height: this._store.settings.chart.size.height - this._padding.top - this._padding.bottom,
      canWidthFlex: !1,
      canHeightFlex: !1,
      numCols: 4,
      // (this._store.settings.legend.isDrawLegend &&
      // ['east', 'west'].includes(this._store.settings.legend.position))
      // ? 4 : 3,
      rowAligns: "start",
      colAligns: "start"
      // rowGaps: this._store.settings.chart.title.isDrawTitle && this._store.title
      //   ? [this._store.settings.chart.title.margin]
      //   : undefined
    }, "doc-grid"), this.append(this._grid), this.updateSize(), this._populateGrid(), this._grid.layoutViews(), this.setSize(this._grid.paddedWidth, this._grid.paddedHeight, !1);
  }
  /**
   * Parse `padding` like CSS padding (1-4 numbers, same order as CSS)
   */
  _parsePadding(e) {
    const r = e.trim().split(" ");
    if (r.length === 0)
      throw new Error("must supply between 1 and 4 values for chart padding");
    return r.length === 1 ? this._expandPadding(parseFloat(r[0])) : r.length === 2 ? this._expandPadding({
      vert: parseFloat(r[0]),
      horiz: parseFloat(r[1])
    }) : r.length === 3 ? this._expandPadding({
      top: parseFloat(r[0]),
      horiz: parseFloat(r[1]),
      bottom: parseFloat(r[2])
    }) : this._expandPadding({
      top: parseFloat(r[0]),
      right: parseFloat(r[1]),
      bottom: parseFloat(r[2]),
      left: parseFloat(r[3])
    });
  }
  _populateGrid() {
    var o, a;
    this._store.settings.chart.title.isDrawTitle && this._store.title && this.createTitle();
    const e = this._store.settings.axis.horiz.position;
    if (this._chartInfo.axisInfo) {
      if (this._store.settings.axis.horiz.isDrawAxis) {
        this._horizAxis = new h7e(this);
        const l = this._chartInfo.axisInfo.horizFacet;
        this._horizAxis.setAxisLabelText(l.label), this._horizAxis.createComponents(), this._horizAxis.layoutComponents(), this._grid.append(this._horizAxis, {
          x: 1,
          y: (e === "north" ? 0 : 1) + (this._titleLabel ? 1 : 0),
          width: 1,
          rowAlign: "end"
        });
      }
      if (this._store.settings.axis.vert.isDrawAxis) {
        this._vertAxis = new p7e(this);
        const l = this._chartInfo.axisInfo.vertFacet;
        this._vertAxis.setAxisLabelText(l.label), this._vertAxis.createComponents(), this._vertAxis.layoutComponents(), this._grid.append(this._vertAxis, {
          x: 0,
          y: this._titleLabel ? 1 : 0,
          // XXX title might be at bottom
          height: 1,
          rowAlign: e === "north" ? "end" : "start"
        });
      }
      this._titleText = this._store.title ?? this._store.settings.chart.title.text;
    }
    const r = (this._chartInfo.axisInfo && e === "north" ? 1 : 0) + (this._titleLabel ? 1 : 0), n = this._horizAxis ? this._grid.colWidth(1) : this._grid.width, i = this._vertAxis ? this._grid.rowHeight(r) : this._grid.height;
    if (this._chartLayers = new V9e(this, n, i), this._chartLayers.dataLayer.init(), this._grid.append(this._chartLayers, {
      x: 1,
      y: r
    }), this._chartLayers.dataLayer.observeStore(), this._chartLayers.dataLayer.observeNotices(), this._store.settings.chart.hasDirectLabels && this.type === "line" && /*this._chartLayers.dataLayer.settings.isAlwaysShowSeriesLabel || */
    this._store.model.multi) {
      const l = this._store.settings.axis.horiz.position, c = (this._chartInfo.axisInfo && l === "north" ? 1 : 0) + (this._titleLabel ? 1 : 0);
      this._directLabelStrip = new d7e(this._chartLayers.dataLayer), this._grid.append(this._directLabelStrip, {
        x: 2,
        y: c,
        height: 1
      });
    }
    this._shouldAddLegend && this.addLegend(this._store.settings.legend.position), this._chartInfo.axisInfo && ((o = this._horizAxis) == null || o.addGridRules(this._chartLayers.height), (a = this._vertAxis) == null || a.addGridRules(this._chartLayers.width));
  }
  get _shouldAddLegend() {
    return this._store.settings.legend.isDrawLegend && (this._store.settings.legend.isAlwaysDrawLegend || this._directLabelStrip && this._store.settings.chart.hasLegendWithDirectLabels || !this._directLabelStrip && this._store.model.multi);
  }
  settingDidChange(e, r, n) {
    this._chartInfo.settingDidChange(e, r, n), ["chart.size.width", "chart.size.height", "chart.fontScale"].includes(e) && this._createGrid(), super.settingDidChange(e, r, n);
  }
  async storeDidChange(e, r) {
    return await super.storeDidChange(e, r), this._chartInfo.storeDidChange(e, r);
  }
  // noticePosted(key: string, value: any): void {
  //   this.log.info('NOTICE', key);
  //   if (key === 'animRevealEnd') {
  //     const shouldAddDirectLabelStrip = this._store.settings.chart.hasDirectLabels
  //       && this.type === 'line'
  //       && /*this._chartLayers.dataLayer.settings.isAlwaysShowSeriesLabel || */
  //         this._store.model!.multi;
  //     if (shouldAddDirectLabelStrip) {
  //       const horizAxisPos = this._store.settings.axis.horiz.position;
  //       const plotRow = (this._chartInfo.axisInfo && horizAxisPos === 'north'
  //         ? 1
  //         : 0) + (this._titleLabel ? 1 : 0);
  //       this.log.info('PLOT ROW', plotRow);
  //       // this._directLabelStrip = new DirectLabelStrip(this._chartLayers.dataLayer as LinePlotView);
  //       // this._grid.append(this._directLabelStrip, {
  //       //   x: 2,
  //       //   y: plotRow,
  //       //   height: 1
  //       // });
  //     }
  //   }
  // }
  get chartInfo() {
    return this._chartInfo;
  }
  _createId() {
    return "doc-view";
  }
  get role() {
    return "graphics-document";
  }
  get roleDescription() {
    return `${this.type} chart`;
  }
  get chartLayers() {
    return this._chartLayers;
  }
  get titleText() {
    return this._titleText;
  }
  setTitleText(e) {
    this._titleText = e ?? this._store.settings.chart.title.text ?? "[TITLE]", this._titleLabel && (this._titleLabel.text = this._titleText);
  }
  get horizAxis() {
    return this._horizAxis;
  }
  get vertAxis() {
    return this._vertAxis;
  }
  get xAxis() {
    return this.getAxisForCoord("x");
  }
  get yAxis() {
    return this.getAxisForCoord("y");
  }
  getAxisForCoord(e) {
    var r, n;
    if (((r = this._horizAxis) == null ? void 0 : r.coord) === e)
      return this._horizAxis;
    if (((n = this._vertAxis) == null ? void 0 : n.coord) === e)
      return this._vertAxis;
    this.log.info("no axis!", this._horizAxis, this._vertAxis, e);
  }
  /*protected get _hotkeyActions() {
      return hotkeyActions.global;
    }
  
    get keymap() {
      return keymaps.global;
    }*/
  createTitle() {
    const e = this._store.settings.chart.title.align ?? "center";
    this._titleLabel = new di(this.paraview, {
      id: "chart-title",
      role: "heading",
      classList: ["chart-title"],
      text: this._titleText,
      wrapWidth: this._grid.width,
      justify: e
    }), this._titleLabel.canHeightFlex = !1;
    let r = 0;
    this._store.settings.chart.title.margin, this._store.settings.chart.title.position, this._store.settings.chart.title.position === "top" ? this._grid.insertRow(0, this._store.settings.chart.title.margin) : (this._grid.insertRow(this._grid.numRows, this._store.settings.chart.title.margin), r = this._grid.numRows), this._grid.append(this._titleLabel, {
      x: 0,
      y: r,
      colAlign: e,
      width: 4
      // margin: {
      //   top: titlePos === 'top' ? 0 : titleMargin,
      //   bottom: titlePos === 'bottom' ? 0 : titleMargin
      // }
    });
  }
  computeSize() {
    return [this._grid.width, this._grid.height];
  }
  _childDidResize(e) {
    this.updateSize(!1);
  }
  _boundingSizeDidChange() {
    this.paraview.computeViewBox();
  }
  /*updateAllKeymaps() {
    const update = (v: View) => {
      v.updateKeymap();
      v.children.forEach(update);
    };
    update(this);
  }*/
  addLegend(e) {
    const r = this._chartInfo.legend(), n = this._store.settings.legend.margin;
    e === "east" ? (this._legends.east = new o1(this.paraview, r), this._grid.append(this._legends.east, {
      x: 3,
      y: 1,
      height: 1
      //margin: {left: margin}
    }), this._grid.setColGap(this._directLabelStrip ? 2 : 1, n)) : e === "west" ? (this._legends.west = new o1(this.paraview, r), this._grid.addColumnLeft(), this._grid.append(this._legends.west, {
      x: 0,
      y: 0,
      height: 2
      //margin: {right: margin}
    })) : e === "south" ? (this._legends.south = new o1(this.paraview, r, {
      orientation: "horiz",
      wrapWidth: this._chartLayers.paddedWidth
    }), this._grid.insertRow(this._grid.numRows), this._grid.append(this._legends.south, {
      x: 1,
      y: -1,
      width: 1,
      colAlign: "center"
      //margin: {top: margin}
    })) : e === "north" && (this._legends.north = new o1(this.paraview, r, {
      orientation: "horiz",
      wrapWidth: this._chartLayers.paddedWidth
    }), this._grid.insertRow(this._store.settings.chart.title.isDrawTitle && this._store.title ? 1 : 0), this._grid.append(this._legends.north, {
      x: 1,
      y: 0,
      width: 1,
      colAlign: "center"
      //margin: {bottom: margin}
    }));
  }
}
var m7e = Object.defineProperty, y7e = Object.getOwnPropertyDescriptor, vo = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? y7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && m7e(e, r, i), i;
};
let Xi = class extends ts {
  constructor() {
    super(), this.type = "bar", this.contrastLevel = 1, this.disableFocus = !1, this._rootRef = Et(), this._defsRef = Et(), this._frameRef = Et(), this._dataspaceRef = Et(), this.loadingMessageRectRef = Et(), this.loadingMessageTextRef = Et(), this.log = qt("ParaView"), this.loadingMessageStyles = {
      display: "none"
    }, this._chartRefs = /* @__PURE__ */ new Map(), this._fileSavePlaceholderRef = Et(), this._pointerEventManager = null, this._defs = {}, this._jim = "", this._modeSaved = /* @__PURE__ */ new Map(), this._hotkeyListener = (t) => {
      const e = this.paraChart.api.actions[t.action];
      e ? e(t.args) : this.log.warn(`no handler for action '${t.action}'`);
    }, this._jimReadyPromise = new Promise((t, e) => {
      this._jimReadyResolver = t, this._jimReadyRejector = e;
    });
  }
  get viewBox() {
    return this._viewBox;
  }
  get root() {
    return this._rootRef.value;
  }
  get frame() {
    return this._frameRef.value;
  }
  get dataspace() {
    return this._dataspaceRef.value;
  }
  get documentView() {
    return this._documentView;
  }
  get prevFocusLeaf() {
    return this._prevFocusLeaf;
  }
  set prevFocusLeaf(t) {
    this._prevFocusLeaf = t;
  }
  get fileSavePlaceholder() {
    return this._fileSavePlaceholderRef.value;
  }
  get defs() {
    return this._defs;
  }
  async jimReady() {
    await this._jimReadyPromise, this._jimReadyPromise = new Promise((t, e) => {
      this._jimReadyResolver = t, this._jimReadyRejector = e;
    });
  }
  get pointerEventManager() {
    return this._pointerEventManager;
  }
  connectedCallback() {
    super.connectedCallback(), this._controller ?? (this._controller = new gAe(this._store)), this._storeChangeUnsub = this._store.subscribe(async (t, e) => {
      var r;
      t === "data" && await this.dataUpdated(), await ((r = this._documentView) == null ? void 0 : r.storeDidChange(t, e));
    }), this.computeViewBox(), this._store.keymapManager.addEventListener("hotkeypress", this._hotkeyListener), this._store.settings.chart.isStatic || (this._pointerEventManager = new mAe(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._storeChangeUnsub(), this._store.keymapManager.removeEventListener("hotkeyPress", this._hotkeyListener);
  }
  // Anything that needs to be done when data is updated, do here
  async dataUpdated() {
    this.createDocumentView(), this.paraChart.headless && await this.addJIMSeriesSummaries(), this._jim = this._store.jimerator ? JSON.stringify(this._store.jimerator.jim, void 0, 2) : "", this._jimReadyResolver();
  }
  willUpdate(t) {
    t.has("width") && this.computeViewBox(), t.has("chartTitle") && this.documentView && this.documentView.setTitleText(this.chartTitle), t.has("xAxisLabel") && this.documentView && this.documentView.xAxis.setAxisLabelText(this.xAxisLabel), t.has("yAxisLabel") && this.documentView && this.documentView.yAxis.setAxisLabelText(this.yAxisLabel);
  }
  firstUpdated(t) {
    this.log.info("ready"), this.dispatchEvent(new CustomEvent("paraviewready", { bubbles: !0, composed: !0, cancelable: !0 }));
  }
  settingDidChange(t, e, r) {
    var n;
    if ((n = this._documentView) == null || n.settingDidChange(t, e, r), t === "ui.isFullscreenEnabled") {
      if (r && !document.fullscreenElement)
        try {
          this.root.requestFullscreen();
        } catch {
          this.log.error("failed to enter fullscreen"), this._store.updateSettings((i) => {
            i.ui.isFullscreenEnabled = !1;
          }, !0);
        }
      else if (!r && document.fullscreenElement)
        try {
          document.exitFullscreen();
        } catch {
          this.log.error("failed to exit fullscreen"), this._store.updateSettings((i) => {
            i.ui.isFullscreenEnabled = !0;
          }, !0);
        }
    } else if (t === "ui.isLowVisionModeEnabled")
      r ? this._store.colors.selectPaletteWithKey("low-vision") : this._store.colors.prevSelectedColor.length > 0 && this._store.colors.selectPaletteWithKey(this._store.colors.prevSelectedColor), this._store.updateSettings((i) => {
        this._store.announce(`Low vision mode ${r ? "enabled" : "disabled"}`), i.color.isDarkModeEnabled = !!r, i.ui.isFullscreenEnabled = !!r, r ? (this._modeSaved.set("animation.isAnimationEnabled", i.animation.isAnimationEnabled), this._modeSaved.set("chart.fontScale", i.chart.fontScale), this._modeSaved.set("grid.isDrawVertLines", i.grid.isDrawVertLines), this._documentView.chartLayers.dataLayer.stopAnimation(), i.animation.isAnimationEnabled = !1, i.chart.fontScale = 2, i.grid.isDrawVertLines = !0) : (i.animation.isAnimationEnabled = this._modeSaved.get("animation.isAnimationEnabled"), i.chart.fontScale = this._modeSaved.get("chart.fontScale"), i.grid.isDrawVertLines = this._modeSaved.get("grid.isDrawVertLines"), this._modeSaved.delete("animation.isAnimationEnabled"), this._modeSaved.delete("chart.fontScale"), this._modeSaved.delete("grid.isDrawVertLines"));
      });
    else if (t === "ui.isVoicingEnabled")
      if (this._store.settings.ui.isVoicingEnabled)
        if (this._store.settings.ui.isNarrativeHighlightEnabled)
          (async () => this._store.announce(await this._documentView.chartInfo.summarizer.getChartSummary()))();
        else {
          const i = ["Self-voicing enabled."], s = this.paraChart.ariaLiveRegion.lastAnnouncement;
          s && i.push(s), this._store.announce(i);
        }
      else
        this.paraChart.ariaLiveRegion.voicing.shutUp(), this.paraChart.ariaLiveRegion.voicing.speak("Self-voicing disabled.", []);
    else if (t === "ui.isNarrativeHighlightEnabled")
      if (this._store.settings.ui.isNarrativeHighlightEnabled) {
        if (this._store.settings.ui.isVoicingEnabled) {
          this.startNarrativeHighlightMode();
          const i = this.paraChart.ariaLiveRegion.lastAnnouncement, s = ["Narrative Highlights Mode enabled."];
          i && s.push(i), this._store.announce(s), (async () => this._store.announce(await this._documentView.chartInfo.summarizer.getChartSummary()))();
        } else {
          this._store.updateSettings((o) => {
            o.ui.isVoicingEnabled = !0;
          }), this.startNarrativeHighlightMode();
          const i = this.paraChart.ariaLiveRegion.lastAnnouncement, s = ["Narrative Highlights Mode enabled."];
          i && s.push(i), this._store.announce(s), (async () => this._store.announce(await this._documentView.chartInfo.summarizer.getChartSummary()))();
        }
        this._store.updateSettings((i) => {
          this._modeSaved.set(
            "type.line.isTrendNavigationModeEnabled",
            i.type.line.isTrendNavigationModeEnabled
          ), i.type.line.isTrendNavigationModeEnabled = !0;
        });
      } else
        this.endNarrativeHighlightMode(), this._store.updateSettings((i) => {
          i.ui.isVoicingEnabled = !1, i.type.line.isTrendNavigationModeEnabled = this._modeSaved.get(
            "type.line.isTrendNavigationModeEnabled"
          ), this._modeSaved.delete("type.line.isTrendNavigationModeEnabled");
        }), this._store.announce(["Narrative Highlight Mode disabled."]);
    else t === "ui.isNarrativeHighlightPaused" && this.paraChart.ariaLiveRegion.voicing.togglePaused();
  }
  _onFullscreenChange() {
    document.fullscreenElement ? this._store.settings.ui.isFullscreenEnabled || this._store.updateSettings((t) => {
      t.ui.isFullscreenEnabled = !0;
    }, !0) : this._store.settings.ui.isLowVisionModeEnabled ? this._store.updateSettings((t) => {
      t.ui.isLowVisionModeEnabled = !1;
    }) : this._store.settings.ui.isFullscreenEnabled && this._store.updateSettings((t) => {
      t.ui.isFullscreenEnabled = !1;
    }, !0);
  }
  /*protected updated(changedProperties: PropertyValues) {
    this.log.info('canvas updated');
    if (changedProperties.has('dataState')) {
      if (this.dataState === 'pending') {
        const bbox = this._rootRef.value!.getBoundingClientRect();
        const textLength = bbox.width / 3;
        const fontSize = 20;
        const rectHPadding = 5;
        const rectVPadding = 3;
        const rectWidth = textLength + rectHPadding * 2;
        const rectHeight = fontSize + rectVPadding * 2;
        this.loadingMessageRectRef.value!.setAttribute('x', `${bbox.width / 2 - rectWidth / 2}`);
        this.loadingMessageRectRef.value!.setAttribute('y', `${bbox.height / 2}`);
        this.loadingMessageRectRef.value!.setAttribute('width', `${rectWidth}`);
        this.loadingMessageRectRef.value!.setAttribute('height', `${rectHeight}`);
        this.loadingMessageTextRef.value!.setAttribute('x', `${bbox.width / 2 - textLength / 2}`);
        this.loadingMessageTextRef.value!.setAttribute('y', `${bbox.height / 2 + fontSize}`);
        this.loadingMessageTextRef.value!.setAttribute('textLength', `${textLength}`);
        this.loadingMessageStyles = {
          'font-size': `${fontSize}px`,
          color: 'black'
        };
      } else if (this.dataState === 'complete') {
        this.loadingMessageStyles = {
          display: 'none'
        };
        //this.todo.signalManager.signal('canvasDataLoadComplete');
        // this.isReady = true;
      }
    }
  }*/
  ref(t) {
    return this._chartRefs.has(t) || this._chartRefs.set(t, Et()), this._chartRefs.get(t);
  }
  unref(t) {
    if (t.endsWith("*")) {
      const e = t.slice(0, -1);
      for (const r of this._chartRefs.keys())
        r.startsWith(e) && this._chartRefs.delete(r);
    } else if (this._chartRefs.has(t))
      this._chartRefs.delete(t);
    else
      throw new Error(`no ref for key '${t}'`);
  }
  startNarrativeHighlightMode() {
    this._store.updateSettings((t) => {
      t.ui.isVoicingEnabled = !0;
    }), this._store.updateSettings((t) => {
      t.chart.isShowPopups = !0;
    });
  }
  endNarrativeHighlightMode() {
    this._store.updateSettings((t) => {
      t.ui.isVoicingEnabled = !1, t.chart.isShowPopups = !1;
    });
  }
  createDocumentView() {
    this.log.info("creating document view", this.type), this._documentView = new g7e(this), this.computeViewBox(), this.paraChart.styleManager.update();
  }
  computeViewBox() {
    this._viewBox = {
      x: 0,
      y: 0,
      width: this._store.settings.chart.size.width,
      height: this._store.settings.chart.size.height
    }, this.log.info("view box:", this._viewBox.width, "x", this._viewBox.height);
  }
  updateViewbox(t, e, r, n) {
    this.viewBox.x = t ?? this.viewBox.x, this.viewBox.y = e ?? this.viewBox.y, this.viewBox.width = r ?? this.viewBox.width, this.viewBox.height = n ?? this.viewBox.height;
  }
  // updateDefs(el: SVGLinearGradientElement) {
  //   this._defsRef.value!.appendChild(el);
  // }
  async addJIMSeriesSummaries() {
    var r;
    const t = this._documentView.chartInfo.summarizer, e = ((r = this._store.model) == null ? void 0 : r.originalSeriesKeys) || [];
    for (const n of e) {
      const i = await t.getSeriesSummary(Yn(n)), s = typeof i == "string" ? i : i.text;
      this._store.jimerator.addSeriesSummary(n, s);
    }
  }
  serialize() {
    var s, o;
    const t = this.root.cloneNode(!0);
    t.id = "para" + (((o = (s = window.crypto).randomUUID) == null ? void 0 : o.call(s)) ?? "");
    const e = this.paraChart.extractStyles(t.id) + `
` + this.extractStyles(t.id), r = document.createElementNS(Ip, "style");
    r.textContent = e, t.prepend(r);
    const n = [], i = (a) => {
      for (const l of a)
        l instanceof Comment ? n.push(l) : l.childNodes.length && i(l.childNodes);
    };
    return i(t.childNodes), n.forEach((a) => a.remove()), t.removeAttribute("width"), t.removeAttribute("height"), t.removeAttribute("role"), new XMLSerializer().serializeToString(t).split(`
`).filter((a) => !a.match(/^\s*$/)).join(`
`);
  }
  downloadSVG() {
    const t = this.serialize(), e = new Blob([t], {
      type: "image/svg+xml;charset=utf-8"
    }), r = URL.createObjectURL(e);
    this.downloadContent(r, "svg"), URL.revokeObjectURL(r);
  }
  downloadPNG() {
    const t = this.serialize(), e = new Blob([t], {
      type: "image/svg+xml;charset=utf-8"
    }), r = URL.createObjectURL(e), n = new Image();
    n.addEventListener("load", () => {
      const i = this._rootRef.value.getBBox(), s = document.createElement("canvas");
      s.width = i.width, s.height = i.height, s.getContext("2d").drawImage(n, 0, 0, i.width, i.height), URL.revokeObjectURL(r), s.toBlob((a) => {
        if (a) {
          const l = URL.createObjectURL(a);
          this.downloadContent(l, "png"), URL.revokeObjectURL(l);
        } else
          throw new Error("failed to create image download blob");
      });
    }), n.src = r;
  }
  downloadContent(t, e) {
    const r = document.createElement("a");
    this.fileSavePlaceholder.appendChild(r);
    const n = this._documentView.titleText || "parachart";
    r.download = `${n.replace(/\W/g, "_")}.${e}`, r.href = t, r.click(), r.remove();
  }
  addDef(t, e) {
    if (this._defs[t])
      throw new Error("view already in defs");
    this.log.info("ADDING DEF", t), this._defs = { ...this._defs, [t]: e }, this.requestUpdate();
  }
  _rootStyle() {
    const t = {
      fontFamily: this._store.settings.chart.fontFamily,
      fontWeight: this._store.settings.chart.fontWeight
    };
    if (document.fullscreenElement === this.root) {
      const r = Math.round(this._viewBox.width), n = Math.round(this._viewBox.height), i = Math.min(r, n) / Math.max(r, n) * 100;
      r > n ? (t.width = "100vw", t.height = `${i}vh`) : (t.width = `${i}vw`, t.height = "100vh");
    }
    const e = this.store.settings.color.contrastLevel * 50;
    return this._store.settings.color.isDarkModeEnabled ? (t["--axis-line-color"] = `hsl(0, 0%, ${50 + e}%)`, t["--label-color"] = `hsl(0, 0%, ${50 + e}%)`, t["--background-color"] = `hsl(0, 0%, ${(100 - e) / 5 - 10}%)`) : (t["--axis-line-color"] = `hsl(0, 0%, ${50 - e}%)`, t["--label-color"] = `hsl(0, 0%, ${50 - e}%)`), t;
  }
  _rootClasses() {
    return {
      darkmode: this._store.settings.color.isDarkModeEnabled
    };
  }
  navToDatapoint(t, e) {
    this._documentView.chartInfo.navToDatapoint(t, e);
  }
  render() {
    var t, e;
    return this.log.info("render"), qe`
      <svg
        role="application"
        tabindex=${this.disableFocus ? -1 : 0}
        aria-label=${this._documentView ? `${this._documentView.titleText}, accessible chart` : "loading..."}
        ${yt(this._rootRef)}
        xmlns=${Ip}
        data-charttype=${this.paraChart.type ?? this.type}
        width=${nt`${this._viewBox.width}px`}
        height=${nt`${this._viewBox.height}px`}
        class=${Br(this._rootClasses())}
        viewBox=${nt`${this._viewBox.x} ${this._viewBox.y} ${this._viewBox.width} ${this._viewBox.height}`}
        style=${mn(this._rootStyle())}
        @fullscreenchange=${() => this._onFullscreenChange()}
        @focus=${() => {
      this._store.settings.chart.isStatic;
    }}
        @keydown=${(r) => this._controller.handleKeyEvent(r)}
        @pointerdown=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleStart(r);
    }}
        @pointerup=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleEnd(r);
    }}
        @pointercancel=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleCancel(r);
    }}
        @pointermove=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleMove(r);
    }}
        @pointerleave=${(r) => c8e(this, r) ? void 0 : this.requestUpdate()}
        @click=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleClick(r);
    }}
        @dblclick=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleDoubleClick(r);
    }}
      >
        <defs
          ${yt(this._defsRef)}
        >
          ${Object.entries(this._defs).map(([r, n]) => n)}
          ${(t = this._documentView) != null && t.horizAxis ? Tt`
            <clipPath id="clip-path">
              <rect
                x=${0}
                y=${0}
                width=${this.clipWidth ?? this._documentView.chartLayers.width}
                height=${this._documentView.chartLayers.height}>
              </rect>
            </clipPath>
          ` : ""}
        </defs>
        <metadata data-type="text/jim+json">
          ${this._jim}
        </metadata>
        <rect
          ${yt(this._frameRef)}
          id="frame"
          class=${De}
          pointer-events="all"
          x="0"
          y="0"
          width="100%"
          height="100%"
        >
        </rect>
        ${((e = this._documentView) == null ? void 0 : e.render()) ?? ""}
      </svg>
      <div
        ${yt(this._fileSavePlaceholderRef)}
        hidden
      ></div>
    `;
  }
};
Xi.styles = [
  //styles,
  Nt`
      #frame {
        fill: var(--background-color);
        stroke: none;
      }
      #frame.pending {
        fill: lightgray;
      }
      .darkmode {
        --axis-line-color: ghostwhite;
        --label-color: ghostwhite;
        --background-color: black;
      }
      #loading-message {
        fill: black;
      }
      #loading-message text {
        fill: white;
      }
      .grid-horiz {
        stroke: var(--axis-line-color);
        opacity: 0.2;
      }
      .grid-vert {
        stroke: var(--axis-line-color);
        opacity: 0.2;
      }
      #grid-zero {
        opacity: 0.6;
        stroke-width: 2;
      }
      .tick {
        stroke: var(--label-color);
      }
      .chart-title {
        font-size: calc(var(--chart-title-font-size)*var(--chart-font-scale));
      }
      .axis-title-horiz {
        font-size: calc(var(--horiz-axis-title-font-size)*var(--chart-font-scale));
      }
      .axis-title-vert {
        font-size: calc(var(--vert-axis-title-font-size)*var(--chart-font-scale));
      }
      .direct-label {
        font-size: calc(var(--direct-label-font-size)*var(--chart-font-scale));
      }
      .legend-label {
        font-size: calc(var(--legend-label-font-size)*var(--chart-font-scale));
      }
      .label {
        fill: var(--label-color);
        stroke: none;
      }
      .label-bg {
        fill: lightgray;
      }
      .tick-label-horiz {
        font-size: calc(var(--horiz-axis-tick-label-font-size)*var(--chart-font-scale));
      }
      .tick-label-vert {
        font-size: calc(var(--vert-axis-tick-label-font-size)*var(--chart-font-scale));
      }
      .bar-label {
        font-size: calc(var(--bar-label-font-size)*var(--chart-font-scale));
        fill: white;
      }
      .bar-total-label {
        font-size: calc(var(--bar-label-font-size)*var(--chart-font-scale));
      }
      .column-label {
        font-size: calc(var(--column-label-font-size)*var(--chart-font-scale));
        fill: white;
      }
      .column-total-label {
        font-size: calc(var(--column-label-font-size)*var(--chart-font-scale));
                background-color: red;
      }
      .pastry-inside-label {
      }
      .pastry-outside-label-leader {
        fill: none;
        stroke-width: 2;
      }
      .pastry-slice {
        stroke: white;
        stroke-width: 2;
      }
      .label-leader {
        stroke-width: 2;
      }
      #vert-axis-line {
        fill: none;
        stroke: var(--axis-line-color);
        stroke-width: 2px;
        stroke-linecap: round;
      }
      #horiz-axis-line {
        fill: none;
        stroke: var(--axis-line-color);
        opacity: 1;
        stroke-width: 2px;
        stroke-linecap: round;
      }
      rect#data-backdrop {
        stroke: none;
        fill: none; /*lightgoldenrodyellow;*/
        /*opacity: 0.5;*/
        pointer-events: all;
      }
      .symbol {
        /*stroke-width: 2;*/
        stroke-linejoin: round;
      }
      .symbol.outline {
        fill: white;
      }
      use.visited-mark {
       pointer-events: none;
      }
      .bar {
        stroke-width: 0;
      }
      .data-line {
        fill: none;
        /*stroke-width: 3px;*/
        stroke-linecap: round;
      }
      .range-highlight {
        fill: silver;
        opacity: 0.5;
      }
      .linebreaker-marker {
        fill: hsl(0, 17.30%, 37.50%);
      }
      .user-linebreaker-marker {
        fill: hsl(0, 87%, 48%);
      }
      .trend-line{
        display: inline;
        stroke-width: 8px;
        stroke-linecap: butt;
        stroke-dasharray: 12 12;
        stroke-opacity: 0.8;
      }
      .user-trend-line{
        display: inline;
        stroke-width: 8px;
        stroke-linecap: butt;
        stroke-dasharray: 12 12;
        stroke-opacity: 0.8;
      }
      .datapoint.visited:not(.highlighted) {
        stroke: var(--visited-color);
        fill: var(--visited-color);
        stroke-width: var(--visited-stroke-width);
      }
      .datapoint.highlighted {
/*        stroke: var(--highlighted-color);
        fill: var(--highlighted-color);
        stroke-width: var(--visited-stroke-width); */
      }
      .lowlight {
        opacity: 0.20;
      }
      .hidden {
        display: none;
      }
      .invis {
        opacity: 0;
      }
      .popup-box {
        filter: drop-shadow(3px 3px 5px #333);
        pointer-events: none;
      }
      .popup-text {
        pointer-events: none;
      }
      .control-column {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-start;
        gap: 0.5em;
      }
      .debug-grid-territory {
        fill: lightblue;
        stroke: blue;
        stroke-width: 2;
        opacity: 0.5;
      }
    `
];
vo([
  Ke()
], Xi.prototype, "type", 2);
vo([
  Ke()
], Xi.prototype, "chartTitle", 2);
vo([
  Ke()
], Xi.prototype, "xAxisLabel", 2);
vo([
  Ke()
], Xi.prototype, "yAxisLabel", 2);
vo([
  Ke()
], Xi.prototype, "contrastLevel", 2);
vo([
  Ke({ type: Boolean })
], Xi.prototype, "disableFocus", 2);
vo([
  Ke()
], Xi.prototype, "clipWidth", 2);
vo([
  Vr()
], Xi.prototype, "loadingMessageStyles", 2);
vo([
  Vr()
], Xi.prototype, "_defs", 2);
vo([
  Vr()
], Xi.prototype, "_jim", 2);
Xi = vo([
  Dt("para-view")
], Xi);
class DU extends ts {
  constructor() {
    super(...arguments), this.log = qt("SettingControlContainer");
  }
  connectedCallback() {
    super.connectedCallback(), this._controlsState = new A5(this, this._store.settingControls);
  }
}
const W9 = class W9 extends DU {
  get controlPanel() {
    return this._controlPanel;
  }
  set controlPanel(e) {
    this._controlPanel = e, this.store = e.store;
  }
};
W9.styles = [
  Nt`
      .tab-content {
        display: flex;
        flex-direction: row;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
        padding: 0.2rem;
      }

      .tab-content.stacked {
        flex-direction: column;
        gap: 0.1rem;
        align-items: flex-start;
        justify-content: space-between;
        padding: 0.5rem 0.2rem;
      }
    `
];
let xn = W9;
var b7e = Object.getOwnPropertyDescriptor, v7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? b7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let dE = class extends xn {
  render() {
    return qe`   
      <div class="tab-content">
        <div
          class="setting-views"
        >
          <slot name="settings">
            <span id="settings"> </span>
          </slot>
        </div>
      </div>
    `;
  }
};
dE.styles = [
  //styles,
  Nt`
    `
];
dE = v7e([
  Dt("para-analysis-panel")
], dE);
var w7e = Object.getOwnPropertyDescriptor, x7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? w7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let fE = class extends xn {
  constructor() {
    super();
  }
  showAnnotations() {
    return qe`
      <ol class="annotations">
        ${this._store.annotations.map((t) => qe`
            <li
              data-series="${t.seriesKey}"
              data-index="${t.index}"
              @click=${(e) => {
      t.isSelected = !t.isSelected, this._selectAnnotation(e);
    }}
              @dblclick=${(e) => {
      this._store.annotations = this._store.annotations.filter((r) => r.id != t.id);
    }}
            >${t.annotation}</li>
          `)}
      </ol>
    `;
  }
  _selectAnnotation(t) {
    const e = t == null ? void 0 : t.target;
    if (e && (this._highlightAnnotation(e), e.dataset.series && e.dataset.index)) {
      const r = e.dataset.series, n = parseInt(e.dataset.index);
      this._navToAnnotation(r, n);
    }
  }
  _highlightAnnotation(t) {
    var e;
    for (const r of (e = t.parentElement) == null ? void 0 : e.children)
      r.classList.remove("selected");
    t.classList.add("selected"), t.scrollIntoView(!1);
  }
  _navToAnnotation(t, e) {
    this._controlPanel.paraChart.paraView.navToDatapoint(t, e);
  }
  render() {
    return qe`
      <div id="annotation-tab" class="tab-content">
        <section id="annotations">
          ${this.showAnnotations()}
        </section>
        <div>
          <button
            @click=${() => {
      this._store.addAnnotation();
    }}
          >
            Add Annotation
          </button>
        </div>
        <div> 
          <button
            @click=${() => {
      this._store.addUserLineBreaks();
    }}
          >
            Add Line breaks
          </button>
        </div>
         <div>
          <button
            @click=${() => {
      this._store.clearUserLineBreaks(), this._store.clearUserTrendLines();
    }}
          >
            Remove added line breaks
          </button>
        </div>
         <div>
          <button
            @click=${() => {
      this._store.updateSettings((t) => {
        t.controlPanel.isMDRAnnotationsVisible = !this._store.settings.controlPanel.isMDRAnnotationsVisible;
      }), this._store.showMDRAnnotations();
    }}
          >
            Show Trend Annotations
          </button>
        </div>
      </div>
    `;
  }
};
fE.styles = [
  ...xn.styles,
  Nt`
      :host {
        --zebraStripe: hsl(0, 0%, 85%);
      }

      ol.annotations {
        padding-inline-start: 1.5rem;
        max-height: 6rem;
        overflow-y: scroll;
      }

      ol.annotations li {
        cursor: pointer;
        padding: 4px;
      }

      ol.annotations li:nth-child(even) {
        background-color: var(--zebraStripe);
      }

      ol.annotations li.selected {
        font-weight: bold;
        background-color: var(--theme-color-light);
      }
    `
];
fE = x7e([
  Dt("para-annotation-panel")
], fE);
var E7e = Object.defineProperty, S7e = Object.getOwnPropertyDescriptor, $U = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? S7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && E7e(e, r, i), i;
};
let P2 = class extends DU {
  constructor() {
    super(...arguments), this._dialogRef = Et(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isNotificationEnabled",
      label: "Notification sounds",
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "slider",
      key: "sonification.hertzLower",
      label: "Lower hertz",
      options: {
        min: 0,
        max: Q4.length - 1,
        highBound: this._store.settings.sonification.hertzUpper - 1,
        step: 1
      },
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "slider",
      key: "sonification.hertzUpper",
      label: "Upper hertz",
      options: {
        min: 0,
        max: Q4.length - 1,
        lowBound: this._store.settings.sonification.hertzLower + 1,
        step: 1
      },
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isRiffEnabled",
      label: "Series riff enabled",
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isArpeggiateChords",
      label: "Chords are arpeggiated",
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "slider",
      key: "sonification.riffSpeedIndex",
      label: "Riff speed",
      options: {
        min: 0,
        max: H1.length - 1,
        step: 1
      },
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    });
  }
  render() {
    return qe`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="Sonification Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        ${this._store.settingControls.getContent("controlPanel.tabs.audio.sonification.dialog")}
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show();
  }
};
P2.styles = Nt`
  `;
$U([
  Ke()
], P2.prototype, "btnText", 2);
P2 = $U([
  Dt("para-soni-settings-dialog")
], P2);
var A7e = Object.defineProperty, k7e = Object.getOwnPropertyDescriptor, jU = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? k7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && A7e(e, r, i), i;
};
let R2 = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("AdvancedControlSettingsDialog"), this._dialogRef = Et(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "radio",
      key: "controlPanel.tabLabelStyle",
      label: "Tab label style",
      options: {
        buttons: {
          icon: {
            label: "Icon only"
          },
          iconLabel: {
            label: "Icon and label"
          },
          label: {
            label: "Label only"
          }
        },
        layout: "horiz"
      },
      parentView: "controlPanel.tabs.controls.dialog.tabLabels"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.isCaptionVisible",
      label: "Caption visible",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.isExplorationBarVisible",
      label: "Exploration bar visible",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.caption.isCaptionExternalWhenControlPanelClosed",
      label: "Caption external when control panel closed",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.caption.isExplorationBarBeside",
      label: "Exploration bar is beside caption",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    });
  }
  render() {
    return qe`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="Advanced Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        <div id="controls">
          <div id="advanced"
            class="advanced-views"
          >
            ${this._store.settingControls.getContent("controlPanel.tabs.controls.dialog.settings")}
          </div>
          <div>
            ${this._store.settingControls.getContent("controlPanel.tabs.controls.dialog.tabLabels")}
          </div>
        </div>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
R2.styles = Nt`
    #controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  `;
jU([
  Ke()
], R2.prototype, "btnText", 2);
R2 = jU([
  Dt("para-advanced-control-settings-dialog")
], R2);
var _7e = Object.defineProperty, C7e = Object.getOwnPropertyDescriptor, BU = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? C7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && _7e(e, r, i), i;
};
let O2 = class extends ts {
  constructor() {
    super(...arguments), this._dialogRef = Et(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.expandPoints",
      label: "Expand points vertically?",
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "animation.animateRevealTimeMs",
      label: "Animation rate",
      options: {
        inputType: "number",
        min: 0,
        max: 1e4
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "radio",
      key: "animation.animationType",
      label: "Animation type",
      options: {
        buttons: {
          uniform: {
            label: "Uniform"
          },
          progressive: {
            label: "Progressive"
          }
        },
        layout: "horiz"
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "radio",
      key: "animation.animationOrigin",
      label: "Animation origin",
      options: {
        buttons: {
          baseline: {
            label: "Bottom"
          },
          top: {
            label: "Top"
          },
          initialValue: {
            label: "Initial Value"
          },
          custom: {
            label: "Custom"
          }
        },
        layout: "horiz"
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "animation.animationOriginValue",
      label: "Animation origin value",
      options: {
        inputType: "number",
        min: 0,
        max: 1e4
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.lineSnake",
      label: "Snake lines from left?",
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.symbolPopIn",
      label: "Pop in symbols?",
      parentView: "controlPanel.tabs.controls.dialog.animation"
    });
  }
  render() {
    return qe`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="Animation Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        <div id="animation-controls">
          ${this._store.settingControls.getContent("controlPanel.tabs.controls.dialog.animation")}
        </div>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
O2.styles = Nt`
    #animation-controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  `;
BU([
  Ke()
], O2.prototype, "btnText", 2);
O2 = BU([
  Dt("para-animation-dialog")
], O2);
var I7e = Object.getOwnPropertyDescriptor, P7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? I7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let gE = class extends xn {
  constructor() {
    super(...arguments), this._soniDialogRef = Et();
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "checkbox",
      key: "ui.isVoicingEnabled",
      label: "Self-voicing mode",
      parentView: "controlPanel.tabs.audio.voicing"
    }), this._store.settingControls.add({
      type: "slider",
      key: "ui.speechRate",
      label: "Speech rate",
      options: {
        min: 0.5,
        max: 2,
        step: 0.1,
        percent: !0
      },
      parentView: "controlPanel.tabs.audio.voicing"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "ui.isAnnouncementEnabled",
      label: "Announce to screen reader",
      parentView: "controlPanel.tabs.audio.voicing"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isSoniEnabled",
      label: "Sonification mode",
      parentView: "controlPanel.tabs.audio.sonification"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "ui.isNarrativeHighlightEnabled",
      label: "Narrative Highlights mode",
      parentView: "controlPanel.tabs.audio.narrative"
    }), this._store.settingControls.add({
      type: "button",
      key: "ui.isNarrativeHighlightPaused",
      label: "Play/Pause Narrative Highlights",
      parentView: "controlPanel.tabs.audio.narrative"
    });
  }
  render() {
    return qe`   
      <div class="tab-content">
        <section id="voicing">
          ${this._store.settingControls.getContent("controlPanel.tabs.audio.voicing")}
        </section>
        <section id="narrative">
          ${this._store.settingControls.getContent("controlPanel.tabs.audio.narrative")}
        </section>
        <section id="sonification">
          ${this._store.settingControls.getContent("controlPanel.tabs.audio.sonification")}
          <button
            @click=${() => {
      var t;
      return (t = this._soniDialogRef.value) == null ? void 0 : t.show();
    }}
          >
            Sonification Controls
          </button>
        </section>
      </div>
      <para-soni-settings-dialog
        ${yt(this._soniDialogRef)}
        id="sonification-settings-dialog"
        .store=${this._store}
      ></para-soni-settings-dialog>
    `;
  }
};
gE.styles = [
  ...xn.styles,
  Nt`
      #voicing, 
      #sonification,
      #narrative,
      .control-column {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-start;
        align-items: center;
        gap: 0.5em;
      }
    `
];
gE = P7e([
  Dt("para-audio-panel")
], gE);
var R7e = Object.getOwnPropertyDescriptor, O7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? R7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let mE = class extends xn {
  constructor() {
    super(...arguments), this._popupDialogRef = Et();
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "slider",
      key: "chart.fontScale",
      label: "Font scale",
      options: {
        min: 0.5,
        max: 3,
        step: 0.1,
        showValue: !0
      },
      parentView: "controlPanel.tabs.chart.fonts"
    });
  }
  render() {
    const t = this._store.settingControls.getContent("controlPanel.tabs.chart.chart"), e = this._store.settingControls.getContent("controlPanel.tabs.chart.popups"), r = this._store.settingControls.getContent("controlPanel.tabs.chart.fonts");
    return qe`
      <section id="panel">
        <div id="columns">
          <div id="width">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.width")}
          </div>
          <div id="height">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.height")}
          </div>
          <div id="min-y">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.minY")}
          </div>
          <div id="max-y">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.maxY")}
          </div>
          ${t.map((n) => qe`
            <div>
              ${n}
            </div>
          `)}
          ${e.map((n) => qe`
            <div>
              ${n}
            </div>
          `)}

          <section id="popups">
            <button
              @click=${() => {
      var n;
      (n = this._popupDialogRef.value) == null || n.show();
    }}
            >
              Popup settings
            </button>
            <para-popup-settings-dialog
              ${yt(this._popupDialogRef)}
              id="popup-settings-dialog"
              .store=${this._store}
            >
            </para-popup-settings-dialog>
          </section>
        </div>
        <div>
          ${r}
        </div>
      </section>
    `;
  }
};
mE.styles = [
  ...xn.styles,
  Nt`
      #columns {
        display: grid;
        grid-template-columns: repeat(4, 9rem);
        padding: 0.25rem;
        column-gap: 0.5rem;
        row-gap: 0.5rem;
        align-items: center;
      }
      #width {
        grid-row: 1;
        grid-column: 1;
      }
      #height {
        grid-row: 2;
        grid-column: 1;
      }
      #min-y {
        grid-row: 1;
        grid-column: 2;
      }
      #max-y {
        grid-row: 2;
        grid-column: 2;
      }
      #panel {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: center;
      }
    `
];
mE = O7e([
  Dt("para-chart-panel")
], mE);
const T7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eNormal%20Color%20Vision%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(240,%20100%25,%2043%25);%20}%20.medium%20{%20fill:%20hsl(106,%2058%25,%2041%25);%20}%20.long%20{%20fill:%20hsl(5,%2083%25,%2053%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e", L7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eDeutan%20(Green-Red)%20Color%20Vision%20Deficiency%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(240,%20100%25,%2043%25);%20}%20.medium%20{%20fill:%20none;%20stroke:%20hsl(106,%2058%25,%2041%25);%20stroke-width:%2010px;%20}%20.long%20{%20fill:%20hsl(5,%2083%25,%2053%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M48,71.373C30.563,71.373%2014.622,62.651%205.199,48C14.622,33.349%2030.563,24.627%2048,24.627C65.436,24.627%2081.378,33.349%2090.801,48C81.378,62.651%2065.436,71.373%2048,71.373Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e", M7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eProtan%20(Red-Green)%20Color%20Vision%20Deficiency%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(240,%20100%25,%2043%25);%20}%20.medium%20{%20fill:%20hsl(106,%2058%25,%2041%25);%20}%20.long%20{%20fill:%20none;%20stroke:%20hsl(5,%2083%25,%2053%25);%20stroke-width:%2010px;%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M48,71.373C30.563,71.373%2014.622,62.651%205.199,48C14.622,33.349%2030.563,24.627%2048,24.627C65.436,24.627%2081.378,33.349%2090.801,48C81.378,62.651%2065.436,71.373%2048,71.373Z'/%3e%3c/svg%3e", N7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eTriatan%20(Blue-Yellow)%20Color%20Vision%20Deficiency%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20none;%20stroke:%20hsl(240,%20100%25,%2043%25);%20stroke-width:%2010px;%20}%20.medium%20{%20fill:%20hsl(106,%2058%25,%2041%25);%20}%20.long%20{%20fill:%20hsl(5,%2083%25,%2053%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M48,71.373C30.563,71.373%2014.622,62.651%205.199,48C14.622,33.349%2030.563,24.627%2048,24.627C65.436,24.627%2081.378,33.349%2090.801,48C81.378,62.651%2065.436,71.373%2048,71.373Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e", D7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eNormal%20Color%20Vision%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(0,%200%25,%2047%25);%20}%20.medium%20{%20fill:%20hsl(0,%200%25,%2035%25);%20}%20.long%20{%20fill:%20hsl(0,%200%25,%2020%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e";
var $7e = Object.getOwnPropertyDescriptor, j7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? $7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let yE = class extends xn {
  connectedCallback() {
    super.connectedCallback();
    const t = this._store.colors.palettes.filter((e) => !e.cvd).map((e) => e.key);
    this._store.settingControls.add({
      type: "checkbox",
      key: "color.isDarkModeEnabled",
      label: "Dark mode",
      parentView: "controlPanel.tabs.color.colorContrast"
    }), this._store.settingControls.add({
      type: "slider",
      key: "color.contrastLevel",
      label: "Contrast",
      options: {
        min: 0,
        max: 1,
        step: 0.1,
        percent: !0,
        compact: !0
      },
      parentView: "controlPanel.tabs.color.colorContrast"
    }), this._store.settingControls.add({
      type: "radio",
      key: "color.colorVisionMode",
      label: "Chart colors for CVD (color blindness)",
      options: {
        buttons: {
          normal: {
            label: "Normal",
            title: "Trichromat color vision",
            icon: T7e
          },
          deutan: {
            label: "Deutan",
            title: "Green-red color blindness",
            icon: L7e
          },
          protan: {
            label: "Protan",
            title: "Red-green color blindness",
            icon: M7e
          },
          tritan: {
            label: "Tritan",
            title: "Blue-yellow color blindness",
            icon: N7e
          },
          grayscale: {
            label: "Gray",
            title: "Grayscale printing or achromotopsia",
            icon: D7e
          }
        }
      },
      parentView: "controlPanel.tabs.color.colorVision"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: "color.colorPalette",
      label: "Color palette:",
      options: { options: t },
      parentView: "controlPanel.tabs.color.colorPalette"
    }), this._state = new A5(this, this._store.settingControls);
  }
  render() {
    return qe`
      <div class="tab-content">
        <div class="control-column">
          ${this._store.settingControls.getContent("controlPanel.tabs.color.colorContrast")}

          ${this.controlPanel.settings.isColorPaletteControlVisible ? this._store.settingControls.getContent("controlPanel.tabs.color.colorPalette") : De}
        </div>
        ${this.controlPanel.settings.isCVDControlVisible ? qe`
            <div>
              ${this._store.settingControls.getContent("controlPanel.tabs.color.colorVision")}
            </div>
          ` : De}
      </div>
    `;
  }
};
yE.styles = [
  ...xn.styles,
  Nt`
      #setting-colorcontrastlevel {
        --width: 6rem;
      }
    `
];
yE = j7e([
  Dt("para-colors-panel")
], yE);
var B7e = Object.getOwnPropertyDescriptor, F7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? B7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let bE = class extends xn {
  constructor() {
    super(...arguments), this._advancedControlDialogRef = Et(), this._animationDialogRef = Et();
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "button",
      key: "ui.isFullscreenEnabled",
      label: "Fullscreen",
      parentView: "controlPanel.tabs.controls.fullscreen"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.isAnimationEnabled",
      label: "Animation enabled",
      parentView: "controlPanel.tabs.controls.animation"
    });
  }
  _getHelp() {
    return qe`
      <p>ParaCharts is an accessible data visualization app with multimodal features for different disabilities. You can explore it using the mouse, touchscreen, or keyboard.</p>
      <ul>
        <li>Navigate using the arrow keys:
          <ul>
            <li><b>Right or left arrow keys</b>: move to the next or previous data point in this series</li>
            <li><b>Up or down arrow keys</b>: move to the previous or next data series</li>
          </ul>
        </li>
        <li><b>Enter key</b>: select current data point</li>
        <li><b>Shift + Enter key</b>: add current data point to selection</li>
        <li><b>Q key</b>: get more information about this data point or series, and compare selected data points</li>
        <li><b>S key</b>: toggle sonification on or off</li>
        <li><b>V key</b>: toggle self-voicing on or off</li>
        <li><b>L key</b>: low vision mode</li>
        <li><b>C key</b>: chord mode</li>
        <li>High/low jump keys:
          <ul>
            <li><b>] (right bracket) key</b>: jump to the highest data point in this series</li>
            <li><b>Shift + ] (right bracket) key</b>: jump to the highest data point in the chart</li>
            <li><b>[ (left bracket) key</b>: jump to the lowest data point in this series</li>
            <li><b>Shift + [ (left bracket) key</b>: jump to the lowest data point in the chart</li>
          </ul>
        </li>
        <li><b>Escape key</b> or <b>Control key</b>: stop speaking</li>
        <li><b>H key</b>: open this Help dialog</li>
      </ul>

      <p>Explore the collapsible Control Panel to find many more accessibility features, including options for color blindness, dark mode with fine-grained contrast, self-voicing, SparkBraille tactile support, and more.</p>

      <p>For more details, visit the <a href="https://fizzstudio.github.io/paracharts" target="_blank">ParaCharts Documentation</a>.</p>
    `;
  }
  showHelpDialog() {
    this.controlPanel.dialog.show("Help", this._getHelp());
  }
  _getKeyTable() {
    return qe`
      <table>
        <tbody>
          ${Object.entries(nU).map(([t, e]) => qe`
              <tr>
                <th scope="row">${e.label}</th>
                <td>${e.hotkeys}</td>
                <td><button disable>edit</button></td>
              </tr>
            `)}
        </tbody>
      </table>
    `;
  }
  render() {
    return qe`
      <div id="controls-tab" class="tab-content">
        <div>
          <button
            @click=${() => this.controlPanel.dialog.show("Key Bindings", this._getKeyTable())}
          >
            Keyboard Controls
          </button>
          <button
            @click=${() => this.store.updateSettings((t) => {
      t.ui.isFullscreenEnabled = !0;
    })}
          >
            Fullscreen
          </button>
        </div>

        <div>
          ${this._store.settingControls.getContent("controlPanel.tabs.controls")}
        </div>

        <section id="animation">
          ${this._store.settingControls.getContent("controlPanel.tabs.controls.animation")}
          <button
            @click=${() => {
      var t;
      (t = this._animationDialogRef.value) == null || t.show();
    }}
          >
            Animation settings
          </button>
          <para-animation-dialog
            ${yt(this._animationDialogRef)}
            id="animation-settings-dialog"
            .store=${this._store}
          >
          </para-animation-dialog>
        </section>

        <section id="advanced">
          <button
            @click=${() => this.showHelpDialog()}
          >
            Help
          </button>
          <button
            @click=${() => {
      var t;
      return (t = this._advancedControlDialogRef.value) == null ? void 0 : t.show();
    }}
          >
          Advanced Controls
          </button>
        </section>
      </div>
      <div id="file-save-placeholder" style="display: none;">
      </div>
      <para-advanced-control-settings-dialog
        ${yt(this._advancedControlDialogRef)}
        id="advanced-control-settings-dialog"
        .store=${this._store}
      ></para-advanced-control-settings-dialog>
    `;
  }
};
bE.styles = [
  ...xn.styles,
  Nt`
    `
];
bE = F7e([
  Dt("para-controls-panel")
], bE);
var z7e = Object.getOwnPropertyDescriptor, V7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? z7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let vE = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("DataTableView");
  }
  render() {
    return this.log.info("MODEL", this.model), qe`
      <div class="wrapper">
        <table>
          <thead>
            <tr>
              <th>
                ${this.model.getFacet(this.model.independentFacetKeys[0]).label} // TODO: Assumes exactly 1 indep facet
              </th>
              ${this.model.series.map((t) => qe`
                <th scope="col">
                  ${t.key}
                </th>
              `)}
            </tr>
          </thead>
          <tbody>
            ${this.model.series[0].datapoints.map((t, e) => qe`
              <tr>
                <td>
                  ${Zu(t, "raw")}
                </td>
                ${this.model.series.map((r) => qe`
                  <td>
                    ${wS(r[e], "value")}
                  </td>
                `)}
              </tr>
            `)}
          </tbody>
        </table>
      </div>
    `;
  }
};
vE.styles = [
  Nt`
      th, td {
        padding: 0.25rem;
      }
      thead {
        position: sticky;
        top: 0;
        background: var(--theme-color-light);
      }
      .wrapper {
        overflow: scroll;
        max-height: 15rem;
      }
    `
];
vE = V7e([
  Dt("para-datatable")
], vE);
class U7e {
  constructor(e, r) {
    this.data = e, this.binCount = r, this.init();
  }
  get binnedData() {
    return this._binnedData;
  }
  init() {
    this.findMinMax(), this.binData();
  }
  findMinMax() {
    this.min = Math.min(...this.data), this.max = Math.max(...this.data), this.range = this.max - this.min;
  }
  binData() {
    this._binnedData = [], this._binnedData = this.data.map((e) => Math.min(
      this.binCount - 1,
      Math.floor(this.binCount * (e - this.min) / this.range)
    ));
  }
}
const hO = [[1, 2, 3, 7], [4, 5, 6, 8]];
class H7e {
  constructor(e, r = !1) {
    this.binnedData = e, this.isBar = r, this.cellArray = [], this.init();
  }
  get cells() {
    return this.cellArray;
  }
  init() {
    this.buildGlyphs();
  }
  buildGlyphs() {
    let e = [];
    for (let r = 0; r < this.binnedData.length; ++r) {
      const n = this.binnedData[r], i = r % 2;
      if (e.push(hO[i][3 - n]), this.isBar)
        for (let s = 0; s < n; s++)
          e.push(hO[i][3 - s]);
      (i || this.binnedData.length === r + 1) && (this.cellArray.push(e), e = []);
    }
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Q1 = globalThis, $9 = Q1.ShadowRoot && (Q1.ShadyCSS === void 0 || Q1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, j9 = Symbol(), pO = /* @__PURE__ */ new WeakMap();
let FU = class {
  constructor(t, e, r) {
    if (this._$cssResult$ = !0, r !== j9) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if ($9 && t === void 0) {
      const r = e !== void 0 && e.length === 1;
      r && (t = pO.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), r && pO.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const G7e = (t) => new FU(typeof t == "string" ? t : t + "", void 0, j9), W7e = (t, ...e) => {
  const r = t.length === 1 ? t[0] : e.reduce((n, i, s) => n + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + t[s + 1], t[0]);
  return new FU(r, t, j9);
}, q7e = (t, e) => {
  if ($9) t.adoptedStyleSheets = e.map((r) => r instanceof CSSStyleSheet ? r : r.styleSheet);
  else for (const r of e) {
    const n = document.createElement("style"), i = Q1.litNonce;
    i !== void 0 && n.setAttribute("nonce", i), n.textContent = r.cssText, t.appendChild(n);
  }
}, dO = $9 ? (t) => t : (t) => t instanceof CSSStyleSheet ? ((e) => {
  let r = "";
  for (const n of e.cssRules) r += n.cssText;
  return G7e(r);
})(t) : t;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Q7e, defineProperty: K7e, getOwnPropertyDescriptor: Y7e, getOwnPropertyNames: Z7e, getOwnPropertySymbols: J7e, getPrototypeOf: X7e } = Object, ud = globalThis, fO = ud.trustedTypes, e_e = fO ? fO.emptyScript : "", gO = ud.reactiveElementPolyfillSupport, n0 = (t, e) => t, T2 = { toAttribute(t, e) {
  switch (e) {
    case Boolean:
      t = t ? e_e : null;
      break;
    case Object:
    case Array:
      t = t == null ? t : JSON.stringify(t);
  }
  return t;
}, fromAttribute(t, e) {
  let r = t;
  switch (e) {
    case Boolean:
      r = t !== null;
      break;
    case Number:
      r = t === null ? null : Number(t);
      break;
    case Object:
    case Array:
      try {
        r = JSON.parse(t);
      } catch {
        r = null;
      }
  }
  return r;
} }, B9 = (t, e) => !Q7e(t, e), mO = { attribute: !0, type: String, converter: T2, reflect: !1, hasChanged: B9 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), ud.litPropertyMetadata ?? (ud.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class Cp extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, r = mO) {
    if (r.state && (r.attribute = !1), this._$Ei(), this.elementProperties.set(e, r), !r.noAccessor) {
      const n = Symbol(), i = this.getPropertyDescriptor(e, n, r);
      i !== void 0 && K7e(this.prototype, e, i);
    }
  }
  static getPropertyDescriptor(e, r, n) {
    const { get: i, set: s } = Y7e(this.prototype, e) ?? { get() {
      return this[r];
    }, set(o) {
      this[r] = o;
    } };
    return { get() {
      return i == null ? void 0 : i.call(this);
    }, set(o) {
      const a = i == null ? void 0 : i.call(this);
      s.call(this, o), this.requestUpdate(e, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? mO;
  }
  static _$Ei() {
    if (this.hasOwnProperty(n0("elementProperties"))) return;
    const e = X7e(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(n0("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(n0("properties"))) {
      const r = this.properties, n = [...Z7e(r), ...J7e(r)];
      for (const i of n) this.createProperty(i, r[i]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const r = litPropertyMetadata.get(e);
      if (r !== void 0) for (const [n, i] of r) this.elementProperties.set(n, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [r, n] of this.elementProperties) {
      const i = this._$Eu(r, n);
      i !== void 0 && this._$Eh.set(i, r);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const r = [];
    if (Array.isArray(e)) {
      const n = new Set(e.flat(1 / 0).reverse());
      for (const i of n) r.unshift(dO(i));
    } else e !== void 0 && r.push(dO(e));
    return r;
  }
  static _$Eu(e, r) {
    const n = r.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$ES = new Promise((r) => this.enableUpdating = r), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((r) => r(this));
  }
  addController(e) {
    var r;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((r = e.hostConnected) == null || r.call(e));
  }
  removeController(e) {
    var r;
    (r = this._$EO) == null || r.delete(e);
  }
  _$E_() {
    const e = /* @__PURE__ */ new Map(), r = this.constructor.elementProperties;
    for (const n of r.keys()) this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return q7e(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$EO) == null || e.forEach((r) => {
      var n;
      return (n = r.hostConnected) == null ? void 0 : n.call(r);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null || e.forEach((r) => {
      var n;
      return (n = r.hostDisconnected) == null ? void 0 : n.call(r);
    });
  }
  attributeChangedCallback(e, r, n) {
    this._$AK(e, n);
  }
  _$EC(e, r) {
    var n;
    const i = this.constructor.elementProperties.get(e), s = this.constructor._$Eu(e, i);
    if (s !== void 0 && i.reflect === !0) {
      const o = (((n = i.converter) == null ? void 0 : n.toAttribute) !== void 0 ? i.converter : T2).toAttribute(r, i.type);
      this._$Em = e, o == null ? this.removeAttribute(s) : this.setAttribute(s, o), this._$Em = null;
    }
  }
  _$AK(e, r) {
    var n;
    const i = this.constructor, s = i._$Eh.get(e);
    if (s !== void 0 && this._$Em !== s) {
      const o = i.getPropertyOptions(s), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((n = o.converter) == null ? void 0 : n.fromAttribute) !== void 0 ? o.converter : T2;
      this._$Em = s, this[s] = a.fromAttribute(r, o.type), this._$Em = null;
    }
  }
  requestUpdate(e, r, n) {
    if (e !== void 0) {
      if (n ?? (n = this.constructor.getPropertyOptions(e)), !(n.hasChanged ?? B9)(this[e], r)) return;
      this.P(e, r, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(e, r, n) {
    this._$AL.has(e) || this._$AL.set(e, r), n.reflect === !0 && this._$Em !== e && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(e);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (r) {
      Promise.reject(r);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var e;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep) this[s] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [s, o] of i) o.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], o);
    }
    let r = !1;
    const n = this._$AL;
    try {
      r = this.shouldUpdate(n), r ? (this.willUpdate(n), (e = this._$EO) == null || e.forEach((i) => {
        var s;
        return (s = i.hostUpdate) == null ? void 0 : s.call(i);
      }), this.update(n)) : this._$EU();
    } catch (i) {
      throw r = !1, this._$EU(), i;
    }
    r && this._$AE(n);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var r;
    (r = this._$EO) == null || r.forEach((n) => {
      var i;
      return (i = n.hostUpdated) == null ? void 0 : i.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((r) => this._$EC(r, this[r]))), this._$EU();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
}
Cp.elementStyles = [], Cp.shadowRootOptions = { mode: "open" }, Cp[n0("elementProperties")] = /* @__PURE__ */ new Map(), Cp[n0("finalized")] = /* @__PURE__ */ new Map(), gO == null || gO({ ReactiveElement: Cp }), (ud.reactiveElementVersions ?? (ud.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const L2 = globalThis, M2 = L2.trustedTypes, yO = M2 ? M2.createPolicy("lit-html", { createHTML: (t) => t }) : void 0, zU = "$lit$", Pl = `lit$${Math.random().toFixed(9).slice(2)}$`, VU = "?" + Pl, t_e = `<${VU}>`, Ch = document, X0 = () => Ch.createComment(""), eg = (t) => t === null || typeof t != "object" && typeof t != "function", F9 = Array.isArray, r_e = (t) => F9(t) || typeof (t == null ? void 0 : t[Symbol.iterator]) == "function", cx = `[ 	
\f\r]`, Of = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, bO = /-->/g, vO = />/g, Pu = RegExp(`>|${cx}(?:([^\\s"'>=/]+)(${cx}*=${cx}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), wO = /'/g, xO = /"/g, UU = /^(?:script|style|textarea|title)$/i, n_e = (t) => (e, ...r) => ({ _$litType$: t, strings: e, values: r }), i_e = n_e(1), hd = Symbol.for("lit-noChange"), Gr = Symbol.for("lit-nothing"), EO = /* @__PURE__ */ new WeakMap(), zu = Ch.createTreeWalker(Ch, 129);
function HU(t, e) {
  if (!F9(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return yO !== void 0 ? yO.createHTML(e) : e;
}
const s_e = (t, e) => {
  const r = t.length - 1, n = [];
  let i, s = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", o = Of;
  for (let a = 0; a < r; a++) {
    const l = t[a];
    let c, p, h = -1, d = 0;
    for (; d < l.length && (o.lastIndex = d, p = o.exec(l), p !== null); ) d = o.lastIndex, o === Of ? p[1] === "!--" ? o = bO : p[1] !== void 0 ? o = vO : p[2] !== void 0 ? (UU.test(p[2]) && (i = RegExp("</" + p[2], "g")), o = Pu) : p[3] !== void 0 && (o = Pu) : o === Pu ? p[0] === ">" ? (o = i ?? Of, h = -1) : p[1] === void 0 ? h = -2 : (h = o.lastIndex - p[2].length, c = p[1], o = p[3] === void 0 ? Pu : p[3] === '"' ? xO : wO) : o === xO || o === wO ? o = Pu : o === bO || o === vO ? o = Of : (o = Pu, i = void 0);
    const b = o === Pu && t[a + 1].startsWith("/>") ? " " : "";
    s += o === Of ? l + t_e : h >= 0 ? (n.push(c), l.slice(0, h) + zU + l.slice(h) + Pl + b) : l + Pl + (h === -2 ? a : b);
  }
  return [HU(t, s + (t[r] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), n];
};
class tg {
  constructor({ strings: e, _$litType$: r }, n) {
    let i;
    this.parts = [];
    let s = 0, o = 0;
    const a = e.length - 1, l = this.parts, [c, p] = s_e(e, r);
    if (this.el = tg.createElement(c, n), zu.currentNode = this.el.content, r === 2 || r === 3) {
      const h = this.el.content.firstChild;
      h.replaceWith(...h.childNodes);
    }
    for (; (i = zu.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const h of i.getAttributeNames()) if (h.endsWith(zU)) {
          const d = p[o++], b = i.getAttribute(h).split(Pl), m = /([.?@])?(.*)/.exec(d);
          l.push({ type: 1, index: s, name: m[2], strings: b, ctor: m[1] === "." ? a_e : m[1] === "?" ? l_e : m[1] === "@" ? c_e : ew }), i.removeAttribute(h);
        } else h.startsWith(Pl) && (l.push({ type: 6, index: s }), i.removeAttribute(h));
        if (UU.test(i.tagName)) {
          const h = i.textContent.split(Pl), d = h.length - 1;
          if (d > 0) {
            i.textContent = M2 ? M2.emptyScript : "";
            for (let b = 0; b < d; b++) i.append(h[b], X0()), zu.nextNode(), l.push({ type: 2, index: ++s });
            i.append(h[d], X0());
          }
        }
      } else if (i.nodeType === 8) if (i.data === VU) l.push({ type: 2, index: s });
      else {
        let h = -1;
        for (; (h = i.data.indexOf(Pl, h + 1)) !== -1; ) l.push({ type: 7, index: s }), h += Pl.length - 1;
      }
      s++;
    }
  }
  static createElement(e, r) {
    const n = Ch.createElement("template");
    return n.innerHTML = e, n;
  }
}
function pd(t, e, r = t, n) {
  var i, s;
  if (e === hd) return e;
  let o = n !== void 0 ? (i = r._$Co) == null ? void 0 : i[n] : r._$Cl;
  const a = eg(e) ? void 0 : e._$litDirective$;
  return (o == null ? void 0 : o.constructor) !== a && ((s = o == null ? void 0 : o._$AO) == null || s.call(o, !1), a === void 0 ? o = void 0 : (o = new a(t), o._$AT(t, r, n)), n !== void 0 ? (r._$Co ?? (r._$Co = []))[n] = o : r._$Cl = o), o !== void 0 && (e = pd(t, o._$AS(t, e.values), o, n)), e;
}
class o_e {
  constructor(e, r) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = r;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: r }, parts: n } = this._$AD, i = ((e == null ? void 0 : e.creationScope) ?? Ch).importNode(r, !0);
    zu.currentNode = i;
    let s = zu.nextNode(), o = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new Am(s, s.nextSibling, this, e) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, e) : l.type === 6 && (c = new u_e(s, this, e)), this._$AV.push(c), l = n[++a];
      }
      o !== (l == null ? void 0 : l.index) && (s = zu.nextNode(), o++);
    }
    return zu.currentNode = Ch, i;
  }
  p(e) {
    let r = 0;
    for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(e, n, r), r += n.strings.length - 2) : n._$AI(e[r])), r++;
  }
}
class Am {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, r, n, i) {
    this.type = 2, this._$AH = Gr, this._$AN = void 0, this._$AA = e, this._$AB = r, this._$AM = n, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const r = this._$AM;
    return r !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = r.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, r = this) {
    e = pd(this, e, r), eg(e) ? e === Gr || e == null || e === "" ? (this._$AH !== Gr && this._$AR(), this._$AH = Gr) : e !== this._$AH && e !== hd && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : r_e(e) ? this.k(e) : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.O(e));
  }
  _(e) {
    this._$AH !== Gr && eg(this._$AH) ? this._$AA.nextSibling.data = e : this.T(Ch.createTextNode(e)), this._$AH = e;
  }
  $(e) {
    var r;
    const { values: n, _$litType$: i } = e, s = typeof i == "number" ? this._$AC(e) : (i.el === void 0 && (i.el = tg.createElement(HU(i.h, i.h[0]), this.options)), i);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === s) this._$AH.p(n);
    else {
      const o = new o_e(s, this), a = o.u(this.options);
      o.p(n), this.T(a), this._$AH = o;
    }
  }
  _$AC(e) {
    let r = EO.get(e.strings);
    return r === void 0 && EO.set(e.strings, r = new tg(e)), r;
  }
  k(e) {
    F9(this._$AH) || (this._$AH = [], this._$AR());
    const r = this._$AH;
    let n, i = 0;
    for (const s of e) i === r.length ? r.push(n = new Am(this.O(X0()), this.O(X0()), this, this.options)) : n = r[i], n._$AI(s), i++;
    i < r.length && (this._$AR(n && n._$AB.nextSibling, i), r.length = i);
  }
  _$AR(e = this._$AA.nextSibling, r) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, r); e && e !== this._$AB; ) {
      const i = e.nextSibling;
      e.remove(), e = i;
    }
  }
  setConnected(e) {
    var r;
    this._$AM === void 0 && (this._$Cv = e, (r = this._$AP) == null || r.call(this, e));
  }
}
class ew {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, r, n, i, s) {
    this.type = 1, this._$AH = Gr, this._$AN = void 0, this.element = e, this.name = r, this._$AM = i, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = Gr;
  }
  _$AI(e, r = this, n, i) {
    const s = this.strings;
    let o = !1;
    if (s === void 0) e = pd(this, e, r, 0), o = !eg(e) || e !== this._$AH && e !== hd, o && (this._$AH = e);
    else {
      const a = e;
      let l, c;
      for (e = s[0], l = 0; l < s.length - 1; l++) c = pd(this, a[n + l], r, l), c === hd && (c = this._$AH[l]), o || (o = !eg(c) || c !== this._$AH[l]), c === Gr ? e = Gr : e !== Gr && (e += (c ?? "") + s[l + 1]), this._$AH[l] = c;
    }
    o && !i && this.j(e);
  }
  j(e) {
    e === Gr ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}
class a_e extends ew {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === Gr ? void 0 : e;
  }
}
class l_e extends ew {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== Gr);
  }
}
class c_e extends ew {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this.type = 5;
  }
  _$AI(e, r = this) {
    if ((e = pd(this, e, r, 0) ?? Gr) === hd) return;
    const n = this._$AH, i = e === Gr && n !== Gr || e.capture !== n.capture || e.once !== n.once || e.passive !== n.passive, s = e !== Gr && (n === Gr || i);
    i && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var r;
    typeof this._$AH == "function" ? this._$AH.call(((r = this.options) == null ? void 0 : r.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}
class u_e {
  constructor(e, r, n) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = r, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    pd(this, e);
  }
}
const SO = L2.litHtmlPolyfillSupport;
SO == null || SO(tg, Am), (L2.litHtmlVersions ?? (L2.litHtmlVersions = [])).push("3.2.1");
const h_e = (t, e, r) => {
  const n = (r == null ? void 0 : r.renderBefore) ?? e;
  let i = n._$litPart$;
  if (i === void 0) {
    const s = (r == null ? void 0 : r.renderBefore) ?? null;
    n._$litPart$ = i = new Am(e.insertBefore(X0(), s), s, void 0, r ?? {});
  }
  return i._$AI(t), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let i0 = class extends Cp {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = h_e(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
  }
  render() {
    return hd;
  }
};
var AO;
i0._$litElement$ = !0, i0.finalized = !0, (AO = globalThis.litElementHydrateSupport) == null || AO.call(globalThis, { LitElement: i0 });
const kO = globalThis.litElementPolyfillSupport;
kO == null || kO({ LitElement: i0 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const p_e = (t) => (e, r) => {
  r !== void 0 ? r.addInitializer(() => {
    customElements.define(t, e);
  }) : customElements.define(t, e);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const d_e = { attribute: !0, type: String, converter: T2, reflect: !1, hasChanged: B9 }, f_e = (t = d_e, e, r) => {
  const { kind: n, metadata: i } = r;
  let s = globalThis.litPropertyMetadata.get(i);
  if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = /* @__PURE__ */ new Map()), s.set(r.name, t), n === "accessor") {
    const { name: o } = r;
    return { set(a) {
      const l = e.get.call(this);
      e.set.call(this, a), this.requestUpdate(o, l, t);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, t), a;
    } };
  }
  if (n === "setter") {
    const { name: o } = r;
    return function(a) {
      const l = this[o];
      e.call(this, a), this.requestUpdate(o, l, t);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function km(t) {
  return (e, r) => typeof r == "object" ? f_e(t, e, r) : ((n, i, s) => {
    const o = i.hasOwnProperty(s);
    return i.constructor.createProperty(s, o ? { ...n, wrapped: !0 } : n), o ? Object.getOwnPropertyDescriptor(i, s) : void 0;
  })(t, e, r);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function g_e(t) {
  return km({ ...t, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const m_e = (t, e, r) => (r.configurable = !0, r.enumerable = !0, Reflect.decorate && typeof e != "object" && Object.defineProperty(t, e, r), r);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function y_e(t) {
  return (e, r) => {
    const { slot: n } = {}, i = "slot" + (n ? `[name=${n}]` : ":not([name])");
    return m_e(e, r, { get() {
      var s;
      const o = (s = this.renderRoot) == null ? void 0 : s.querySelector(i);
      return (o == null ? void 0 : o.assignedNodes(t)) ?? [];
    } });
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const b_e = (t) => t.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const v_e = { CHILD: 2 }, w_e = (t) => (...e) => ({ _$litDirective$: t, values: e });
class x_e {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, r, n) {
    this._$Ct = e, this._$AM = r, this._$Ci = n;
  }
  _$AS(e, r) {
    return this.update(e, r);
  }
  update(e, r) {
    return this.render(...r);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s0 = (t, e) => {
  var r;
  const n = t._$AN;
  if (n === void 0) return !1;
  for (const i of n) (r = i._$AO) == null || r.call(i, e, !1), s0(i, e);
  return !0;
}, N2 = (t) => {
  let e, r;
  do {
    if ((e = t._$AM) === void 0) break;
    r = e._$AN, r.delete(t), t = e;
  } while ((r == null ? void 0 : r.size) === 0);
}, GU = (t) => {
  for (let e; e = t._$AM; t = e) {
    let r = e._$AN;
    if (r === void 0) e._$AN = r = /* @__PURE__ */ new Set();
    else if (r.has(t)) break;
    r.add(t), A_e(e);
  }
};
function E_e(t) {
  this._$AN !== void 0 ? (N2(this), this._$AM = t, GU(this)) : this._$AM = t;
}
function S_e(t, e = !1, r = 0) {
  const n = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0) if (e) if (Array.isArray(n)) for (let s = r; s < n.length; s++) s0(n[s], !1), N2(n[s]);
  else n != null && (s0(n, !1), N2(n));
  else s0(this, t);
}
const A_e = (t) => {
  t.type == v_e.CHILD && (t._$AP ?? (t._$AP = S_e), t._$AQ ?? (t._$AQ = E_e));
};
class k_e extends x_e {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(e, r, n) {
    super._$AT(e, r, n), GU(this), this.isConnected = e._$AU;
  }
  _$AO(e, r = !0) {
    var n, i;
    e !== this.isConnected && (this.isConnected = e, e ? (n = this.reconnected) == null || n.call(this) : (i = this.disconnected) == null || i.call(this)), r && (s0(this, e), N2(this));
  }
  setValue(e) {
    if (b_e(this._$Ct)) this._$Ct._$AI(e, this);
    else {
      const r = [...this._$Ct._$AH];
      r[this._$Ci] = e, this._$Ct._$AI(r, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const _O = () => new __e();
class __e {
}
const ux = /* @__PURE__ */ new WeakMap(), CO = w_e(class extends k_e {
  render(t) {
    return Gr;
  }
  update(t, [e]) {
    var r;
    const n = e !== this.Y;
    return n && this.Y !== void 0 && this.rt(void 0), (n || this.lt !== this.ct) && (this.Y = e, this.ht = (r = t.options) == null ? void 0 : r.host, this.rt(this.ct = t.element)), Gr;
  }
  rt(t) {
    if (this.isConnected || (t = void 0), typeof this.Y == "function") {
      const e = this.ht ?? globalThis;
      let r = ux.get(e);
      r === void 0 && (r = /* @__PURE__ */ new WeakMap(), ux.set(e, r)), r.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), r.set(this.Y, t), t !== void 0 && this.Y.call(this.ht, t);
    } else this.Y.value = t;
  }
  get lt() {
    var t, e;
    return typeof this.Y == "function" ? (t = ux.get(this.ht ?? globalThis)) == null ? void 0 : t.get(this.Y) : (e = this.Y) == null ? void 0 : e.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
class C_e {
  constructor(e, r) {
    this.labeledDataString = e, this.binCount = r, this._letters = [], this._proportions = [], this._returnString = "", this.labeledData = [], this.init();
  }
  get returnString() {
    return this._returnString;
  }
  init() {
    this.labeledData = JSON.parse(this.labeledDataString), this.labeledData.sort((e, r) => r.value - e.value), this.findTotal();
    for (let e of this.labeledData)
      this.findCandidateLetter(e.label);
    this.assignProportions(), this.composeString();
  }
  findTotal() {
    let e = 0;
    for (let r of this.labeledData)
      e += r.value;
    this.total = e;
  }
  findCandidateLetter(e) {
    const r = [];
    if (this._letters)
      for (let l of this._letters)
        r.push(l.candidate);
    let n = 0, i = e[0].toUpperCase();
    const s = e.replace(/\s+/g, ""), o = [...e.matchAll(/\s(\w)/g)], a = String(o.map((l) => l[1]).join(""));
    for (; r.includes(s[n].toUpperCase()); ) {
      if (o.length > 0 && !r.includes(a[0].toUpperCase())) {
        i = a[0].toUpperCase();
        break;
      }
      if (n += 1, i = s[n].toUpperCase(), n > s.length) {
        i = "?";
        break;
      }
    }
    this._letters.push({ label: e, candidate: i });
  }
  assignProportions() {
    let e = this.binCount;
    for (let r = this.labeledData.length - 1; r > -1; r--) {
      let n = this.labeledData[r];
      const i = n.value / this.total;
      let s = Math.max(1, Math.round(i * this.binCount));
      this.labeledData[0] == n && (s = e);
      const o = this._letters.filter((a) => a.label == n.label)[0].candidate;
      this._proportions.push({ label: o, value: s }), e -= s;
    }
    this._proportions.sort((r, n) => n.value - r.value);
  }
  composeString() {
    for (let e of this._proportions)
      this._returnString = this._returnString.concat(e.label.repeat(e.value));
  }
}
var I_e = Object.defineProperty, P_e = Object.getOwnPropertyDescriptor, Xh = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? P_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && I_e(e, r, i), i;
};
const R_e = 10240;
function O_e(t) {
  return t.reduce((e, r) => {
    if (typeof r > "u" || r === null)
      throw new Error("Invalid dot specification");
    let n = R_e;
    for (const i of r) {
      if (i < 1 || i > 8)
        throw new Error(`Dot out of range: ${i}`);
      n |= 1 << i - 1;
    }
    return e + String.fromCharCode(n);
  }, "");
}
let za = class extends i0 {
  constructor() {
    super(), this.bar = !1, this.isProp = !1, this.regionRef = _O(), this.preRef = _O(), this.onSelectionChange = () => {
      var t, e;
      const r = document.getSelection();
      if (((e = (t = r == null ? void 0 : r.anchorNode) == null ? void 0 : t.parentNode) == null ? void 0 : e.parentNode) !== this.regionRef.value)
        return;
      const n = r == null ? void 0 : r.anchorOffset;
      this.dispatchEvent(
        new CustomEvent(
          "select",
          {
            bubbles: !0,
            composed: !0,
            detail: n
          }
        )
      );
    };
  }
  /** Binned data, in case you want to see it. */
  get binnedData() {
    return this._binnedData;
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("selectionchange", this.onSelectionChange), this.data && !this.cells && this.renderBraille(this.data);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  willUpdate(t) {
    t.has("data") && this.renderBraille(this.data);
  }
  toBraille(t) {
    return t.split("").map((e) => T_e[e]).join("");
  }
  render() {
    let t;
    if (this.isProp) {
      const e = this.labeledData, r = new C_e(e, 20);
      t = this.toBraille(r.returnString);
    } else
      t = this.cells ? O_e(this.cells) : "";
    return i_e`
      <div
        ${CO(this.regionRef)}
        role="textbox"
        contenteditable="true"
      >
        <pre 
          ${CO(this.preRef)}
          contenteditable="false"
        >${t}</pre>
        <div class="data" style="display: none">
          <slot 
          ></slot>
        </div>
      </div>
    `;
  }
  firstUpdated(t) {
    if (this.cells)
      return;
    const e = this.slotNodes.find((r) => {
      var n;
      return (n = r.textContent) == null ? void 0 : n.trim();
    });
    e && this.renderBraille(e.textContent);
  }
  renderBraille(t) {
    const e = t.split(/ /).map(parseFloat), r = new U7e(e, 4);
    this._binnedData = r.binnedData;
    const n = new H7e(this._binnedData, this.bar);
    this.cells = n.cells;
  }
};
za.styles = W7e`
    div {
      font-size: var(--font-size, 2rem);
      padding: var(--padding, unset);
      margin: var(--margin, unset);
    }
    pre {
      margin: 0;
    }
  `;
Xh([
  km()
], za.prototype, "data", 2);
Xh([
  km({ type: Boolean })
], za.prototype, "bar", 2);
Xh([
  km()
], za.prototype, "labeledData", 2);
Xh([
  km({ type: Boolean })
], za.prototype, "isProp", 2);
Xh([
  g_e()
], za.prototype, "cells", 2);
Xh([
  y_e()
], za.prototype, "slotNodes", 2);
za = Xh([
  p_e("fizz-sparkbraille")
], za);
const T_e = {
  " ": "",
  a: "",
  b: "",
  c: "",
  d: "",
  e: "",
  f: "",
  g: "",
  h: "",
  i: "",
  j: "",
  k: "",
  l: "",
  m: "",
  n: "",
  o: "",
  p: "",
  q: "",
  r: "",
  s: "",
  t: "",
  u: "",
  v: "",
  w: "",
  x: "",
  y: "",
  z: "",
  1: "",
  2: "",
  3: "",
  4: "",
  5: "",
  6: "",
  7: "",
  8: "",
  9: "",
  0: "",
  ",": "",
  ".": "",
  ";": "",
  ":": "",
  "!": "",
  "?": "",
  '"': "",
  "'": "",
  "-": "",
  "(": "",
  ")": "",
  A: "",
  B: "",
  C: "",
  D: "",
  E: "",
  F: "",
  G: "",
  H: "",
  I: "",
  J: "",
  K: "",
  L: "",
  M: "",
  N: "",
  O: "",
  P: "",
  Q: "",
  R: "",
  S: "",
  T: "",
  U: "",
  V: "",
  W: "",
  X: "",
  Y: "",
  Z: ""
};
var L_e = Object.defineProperty, M_e = Object.getOwnPropertyDescriptor, WU = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? M_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && L_e(e, r, i), i;
};
let D2 = class extends xn {
  constructor() {
    super(...arguments), this.isSparkBrailleVisible = !1, this._sparkBrailleRef = Et(), this._sparkBrailleWrapperRef = Et();
  }
  _saveChart() {
    const t = this.controlPanel.paraChart.paraView.serialize(), e = new Blob([t], { type: "image/svg+xml;charset=utf-8" }), r = URL.createObjectURL(e);
    this._controlPanel.paraChart.paraView.downloadContent(r, "svg"), URL.revokeObjectURL(r);
  }
  _saveData() {
    const t = this._store.getModelCsv(), e = new Blob([t], { type: "text/csv;charset=utf-8" }), r = URL.createObjectURL(e);
    this._controlPanel.paraChart.paraView.downloadContent(r, "csv"), URL.revokeObjectURL(r);
  }
  render() {
    var e, r, n, i, s, o;
    const t = this.controlPanel.parentElement.firstElementChild;
    return qe`
      <div
        id="data-page"
        class="tab-content"
      >
        <div>
          <p>Source: <span id="source-name">unknown</span></p>
        </div>
        <div id="data-buttons">
          ${this.controlPanel.settings.isSparkBrailleControlVisible ? qe`
              <button
                @click=${() => {
      this.isSparkBrailleVisible = !this.isSparkBrailleVisible, t.store.updateSettings((a) => {
        a.controlPanel.isSparkBrailleVisible = this.isSparkBrailleVisible;
      }), this._sparkBrailleRef.value.focus();
    }}
              >
                SparkBraille
              </button>
            ` : De}
          <button
            @click=${() => {
      this.controlPanel.dialog.show(
        "JSON Image Metadata",
        qe`
                  <pre>
                    <code>
                      ${JSON.stringify(this._store.jimerator.jim, void 0, 2)}
                    </code>
                  </pre>`
      );
    }}
          >
            JIM
          </button>
          <button
            @click=${() => this._saveData()}
          >
            Save data
          </button>
          <button
            @click=${() => {
      this.controlPanel.dialog.show("Data table", qe`
                <para-datatable
                  .model=${this._store.model}
                >
                </para-datatable>
              `);
    }}
          >
            Data table
          </button>
          <button
            @click=${() => this.controlPanel.dialog.show("Source links")}
          >
            Source Links
          </button>
          <button
            @click=${() => {
      this._saveChart();
    }}
          >
            Save chart
          </button>
        </div>
      </div>
      <div
        ${yt(this._sparkBrailleWrapperRef)}
        id="sparkbraille"
        class=${this.isSparkBrailleVisible ? De : "hidden"}
        ?hidden=${!this.isSparkBrailleVisible}
    >
        <!--
          What should happen when a braille cell is selected?
        -->
        <fizz-sparkbraille
          ${yt(this._sparkBrailleRef)}
          ?bar=${(e = this._store.sparkBrailleInfo) == null ? void 0 : e.isBar}
          ?isProp=${(r = this._store.sparkBrailleInfo) == null ? void 0 : r.isProportional}
          data=${(n = this._store.sparkBrailleInfo) != null && n.isProportional ? "" : ((i = this._store.sparkBrailleInfo) == null ? void 0 : i.data) ?? ""}
          labeledData=${(s = this._store.sparkBrailleInfo) != null && s.isProportional ? ((o = this._store.sparkBrailleInfo) == null ? void 0 : o.data) ?? "" : ""}
          @select=${(a) => {
      a.detail * 2;
    }}
        >
        </fizz-sparkbraille>
      </div>
    `;
  }
};
D2.styles = [
  ...xn.styles,
  Nt`
      #data-page {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        align-content: center;
        flex-grow: 1;
      }
      #data-page p {
        white-space: nowrap;
      }
      #data-buttons {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        align-content: center;
        flex-wrap: wrap;
        width: 30rem;
      }

      #data-buttons button {
        width: 8rem;
        max-width: 8rem;
      }
      #sparkbraille {
        background-color: var(--theme-color-light);
        padding: 0.2rem;
      }
    `
];
WU([
  Ke({ type: Boolean })
], D2.prototype, "isSparkBrailleVisible", 2);
D2 = WU([
  Dt("para-data-panel")
], D2);
var N_e = Object.defineProperty, D_e = Object.getOwnPropertyDescriptor, z9 = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? D_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && N_e(e, r, i), i;
};
let rg = class extends xn {
  constructor() {
    super(...arguments), this.caption = "", this.visibleStatus = "", this._captionBoxWrapperRef = Et();
  }
  // get ariaLiveRegion() {
  //   return this._ariaLiveRegionRef.value!;
  // }
  positionCaptionBox() {
    this._controlPanel.settings.isControlPanelDefaultOpen || !this._controlPanel.settings.caption.isCaptionExternalWhenControlPanelClosed ? this.internalizeCaptionBox() : this._controlPanel.externalizeCaptionBox();
  }
  // get speechRate() {
  //   return this._controller.voice.rate;
  // }
  // set speechRate(rate: number) {
  //   this._controller.voice.rate = rate;
  // }
  clearStatusBar() {
    this._controlPanel.paraChart.clearAriaLive();
  }
  // clearAriaLive() {
  //   this._ariaLiveRegionRef.value!.clear();
  // }
  // protected _showAriaLiveHistory() {
  //   this._ariaLiveRegionRef.value!.showHistoryDialog();
  // }
  internalizeCaptionBox() {
    this.renderRoot.querySelector("#wrapper").append(this.controlPanel.paraChart.captionBox);
  }
  render() {
    return qe`
      <div id="wrapper"></div>
    `;
  }
};
rg.styles = [
  ...xn.styles,
  Nt`
      #description {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      #desc-footer {
        background-color: var(--theme-color-light);
        padding: 0.2rem;
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-direction: row;
        justify-content: space-between;
      }
    `
];
z9([
  Ke()
], rg.prototype, "caption", 2);
z9([
  Ke()
], rg.prototype, "visibleStatus", 2);
rg = z9([
  Dt("para-description-panel")
], rg);
const $_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%205px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20%3c/style%3e%3cpath%20d='M95,23.6%20A14.1,14.1,0,0,0,80.8,9.4%20H19.1%20A14.1,14.1,0,0,0,5,23.6%20V52.1%20A14.1,14.1,0,0,0,19.1,66.2%20H45.7%20L69.0,89.9%20a1.9,1.9,0,0,0,3.4%20-1.5%20L70.4,66.2%20H80.8%20A14.1,14.1,0,0,0,95,52.1%20ZM91.0,52.1%20a10.1,10.1,0,0,1-10.1,10.1%20H68.2%20a1.9,1.9,0,0,0-1.9,2.1%20L67.9,83.1%20l-19.9%20-20.2%20a1.9,1.9,0,0,0-1.4%20-.59567h-27.4%20a10.1,10.1,0,0,1-10.1%20-10.1%20V23.6%20a10.1,10.1,0,0,1,10.1%20-10.1%20H80.8%20a10.1,10.1,0,0,1,10.1,10.1%20Z%20M20,25%20H75%20M20,37.5%20H75%20M20,50%20H75'%20/%3e%3c/svg%3e", j_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%207px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20%3c/style%3e%3cpath%20d='M50%204.6875c-21.875%200-39.062%209.2188-39.062%2020.938v48.594c0%2011.875%2017.188%2021.094%2039.062%2021.094s39.062-9.2188%2039.062-20.938v-48.75c0-11.719-17.188-20.938-39.062-20.938zm35.938%2069.688c0%209.6875-16.406%2017.812-35.938%2017.812s-35.938-8.125-35.938-17.812v-15.938c5.9375%207.5%2019.531%2012.656%2035.938%2012.656s30-5.1562%2035.938-12.656zm0-24.375c0%209.6875-16.406%2017.812-35.938%2017.812s-35.938-8.125-35.938-17.812v-15.938c5.9375%207.5%2019.531%2012.656%2035.938%2012.656s30-5.1562%2035.938-12.656zm-35.938-6.4062c-19.531%200-35.938-8.125-35.938-17.812s16.406-17.969%2035.938-17.969%2035.938%208.125%2035.938%2017.812-16.406%2017.969-35.938%2017.969z'%20/%3e%3c/svg%3e", B_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cpath%20d='m44.375%2088.531c1.7109%201.5938%203.5977%202.9883%205.625%204.1562-7.1992%204.1562-15.762%205.2734-23.789%203.0977-8.0234-2.1719-14.852-7.4531-18.973-14.676-4.1211-7.2227-5.1914-15.789-2.9805-23.801%202.2148-8.0156%207.5312-14.82%2014.773-18.902%200.25391%202.1992%200.76953%204.3594%201.5312%206.4375%202.5391%207.0938%207.5391%2013.039%2014.094%2016.75-0.1875%201.3359-0.28125%202.6836-0.28125%204.0312-0.007812%208.6953%203.6172%2017%2010%2022.906zm36.594-50.125c-0.25391%202.1992-0.76953%204.3594-1.5312%206.4375-2.5391%207.0938-7.5391%2013.039-14.094%2016.75%200.1875%201.3359%200.28125%202.6836%200.28125%204.0312%200.007812%208.6953-3.6172%2017-10%2022.906-1.7109%201.5938-3.5977%202.9883-5.625%204.1562%207.1992%204.1562%2015.762%205.2734%2023.789%203.0977%208.0234-2.1719%2014.852-7.4531%2018.973-14.676%204.1211-7.2227%205.1914-15.789%202.9805-23.801-2.2148-8.0156-7.5312-14.82-14.773-18.902zm-7.1875%203.625c-2.6172-0.92969-5.3789-1.4062-8.1562-1.4062-3.4414-0.003906-6.8477%200.71094-10%202.0938%203.6914%203.4258%206.5%207.6914%208.1875%2012.438%204.7266-3.1055%208.2461-7.7383%209.9688-13.125zm-14.438%2022.156c-6.082%201.918-12.605%201.918-18.688%200-0.03125%200.46875-0.03125%200.96875-0.03125%201.4375-0.007812%207.5781%203.4453%2014.75%209.375%2019.469%205.9297-4.7188%209.3828-11.891%209.375-19.469%200-0.46875%200-0.96875-0.03125-1.4375zm-9.3438-4.8125c2.7773%200%205.5391-0.47656%208.1562-1.4062-1.4844-4.6602-4.3242-8.7734-8.1562-11.812-3.832%203.0391-6.6719%207.1523-8.1562%2011.812%202.6172%200.92969%205.3789%201.4062%208.1562%201.4062zm-15.625-18.75c-2.7773%200-5.5391%200.47656-8.1562%201.4062%201.7227%205.3867%205.2422%2010.02%209.9688%2013.125%201.6875-4.7461%204.4961-9.0117%208.1875-12.438-3.1523-1.3828-6.5586-2.0977-10-2.0938zm0-6.25c5.4844-0.003906%2010.875%201.4414%2015.625%204.1875%204.75-2.7461%2010.141-4.1914%2015.625-4.1875%203.1719-0.003906%206.3203%200.48047%209.3438%201.4375%202.0859%200.65234%204.0977%201.5195%206%202.5938%200.1875-1.3359%200.28125-2.6836%200.28125-4.0312%200-11.164-5.957-21.48-15.625-27.062s-21.582-5.582-31.25%200-15.625%2015.898-15.625%2027.062c0%201.3477%200.09375%202.6953%200.28125%204.0312%201.9023-1.0742%203.9141-1.9414%206-2.5938%203.0234-0.95703%206.1719-1.4414%209.3438-1.4375z'%20/%3e%3c/svg%3e", F_e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20100%20100'%20xmlns='http://www.w3.org/2000/svg'%3e%3cstyle%3e%20path%20{%20stroke:%20black;%20stroke-width:%208;%20stroke-linecap:round;%20fill:%20none;%20}%20path%23speaker%20{%20stroke:%20none;%20fill:%20black;%20}%20%3c/style%3e%3cpath%20id='speaker'%20d='M%2052.9,11.7%20C%2050,10.2%2046.5,10.5%2043.8,12.5%20L%2020.9,29.5%20C%2020.7,29.7%2020.3,29.8%2020,29.8%20H%2011.1%20C%206.3,29.8%202.4,33.7%202.4,38.5%20V%2061.5%20C%202.4,66.3%206.3,70.2%2011.1,70.2%20H%2020%20C%2020.3,70.2%2020.6,70.3%2020.9,70.5%20L%2043.8,87.5%20C%2045.3,88.6%2047.1,89.2%2049,89.2%2050.3,89.2%2051.7,88.9%2052.9,88.3%2055.8,86.8%2057.7,83.8%2057.7,80.5%20V%2019.5%20C%2057.6,16.2%2055.8,13.2%2052.9,11.7%20Z'%20/%3e%3cpath%20d='M70.5,31%20C78.5,40%2078.5,60%2070.5,69'%20/%3e%3cpath%20d='M81.5,17%20C97.5,34%2097.5,66%2081.5,83'%20/%3e%3c/svg%3e", z_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%208px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20circle%20{%20fill:%20white;%20stroke:%20black;%20stroke-width:%206px;%20}%20%3c/style%3e%3cg%3e%3cpath%20d='M15,25%20H85'%20/%3e%3ccircle%20cx='28'%20cy='25'%20r='7'%20/%3e%3c/g%3e%3cg%3e%3cpath%20d='M15,50%20H85'%20/%3e%3ccircle%20cx='68'%20cy='50'%20r='7'%20/%3e%3c/g%3e%3cg%3e%3cpath%20d='M15,75%20H85'%20/%3e%3ccircle%20cx='50'%20cy='75'%20r='7'%20/%3e%3c/g%3e%3c/svg%3e", V_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path.new%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%208px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20%3c/style%3e%3cpath%20class='new'%20d='M10,10%20V90%20H90%20M22,60%20L35,75%20L50,58%20L58,68%20L90,28'%20/%3e%3c/svg%3e", IO = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='10%2010%2080%2080'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%207px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20circle%20{%20fill:%20white;%20stroke:%20black;%20stroke-width:%206px;%20}%20%3c/style%3e%3cpath%20d='M57.5%20,70%20m23.3%202.6%20-20.5%20-35.0%20v-20.3%20h4.5%20c1.3%200%202.5-1.1%202.5-2.5%200-1.3%20-1.1%20-2.5%20-2.5%20-2.5%20h-30.1%20c-1.3%200-2.5%201.1%20-2.5%202.5%200%201.3%201.1%202.5%202.5%202.5%20h4.7%20v20.3%20l-19.9%2035.1%20c-1.6%202.9%20-1.6%206.5%200.0%209.4%201.7%202.9%204.7%204.7%208.2%204.7%20h44.8%20c3.4%200%206.5%20-1.7%208.2%20-4.7%201.7%20-2.9%201.6%20-6.5%20-0.0%20-9.5%20z%20M33,50%20H67'%20/%3e%3ccircle%20cx='40'%20cy='63'%20r='4'%20/%3e%3ccircle%20cx='57'%20cy='72'%20r='4'%20/%3e%3c/svg%3e", U_e = "data:image/svg+xml,%3csvg%20id='fizz_logo'%20x='0'%20y='0'%20width='100%25'%20height='100%25'%20viewBox='0%200%20208%20208'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eFizz%20Logo%3c/title%3e%3cstyle%3e%20text%20{%20font-family:%20'Trebuchet%20MS',%20Helvetica,%20sans-serif;%20font-size:%20180px;%20}%20%3c/style%3e%3cg%20fill='hsl(258,%2030%25,%2040%25)'%3e%3ccircle%20id='circle-0-0'%20cx='50'%20cy='50'%20r='30'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-0-1'%20cx='120'%20cy='46.5'%20r='23'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-0-2'%20cx='176'%20cy='43'%20r='16'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-1-0'%20cx='46.5'%20cy='120'%20r='23'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-1-1'%20cx='112'%20cy='112'%20r='16'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-2-0'%20cx='43'%20cy='176'%20r='16'%20fill='%23944bbb'/%3e%3c/g%3e%3c/svg%3e", qU = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMS4yNXJlbSIgaGVpZ2h0PSIxLjI1cmVtIiB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGNpcmNsZSBzdHlsZT0ic3Ryb2tlOmdob3N0d2hpdGU7IHN0cm9rZS13aWR0aDoxLjhweDsgZmlsbDpub25lOyIgY3g9IjEwIiBjeT0iMTAiIHI9IjkiLz48dGV4dCB4PSIxMCIgeT0iMTYiIHN0eWxlPSJmaWxsOmdob3N0d2hpdGU7IGZvbnQ6Ym9sZCAxOHB4ICdUaW1lcyBOZXcgUm9tYW4nLFRpbWVzLHNlcmlmOyB0ZXh0LWFuY2hvcjptaWRkbGU7Ij5pPC90ZXh0Pgo8L3N2Zz4K";
var H_e = Object.defineProperty, G_e = Object.getOwnPropertyDescriptor, V9 = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? G_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && H_e(e, r, i), i;
};
let ng = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("ParaControlPanel"), this.dataState = "initial", this._tabsRef = Et(), this._descriptionPanelRef = Et(), this._dataPanelRef = Et(), this._colorsPanelRef = Et(), this._chartPanelRef = Et(), this._annotationPanelRef = Et(), this._controlsPanelRef = Et(), this._dialogRef = Et(), this._msgDialogRef = Et();
  }
  get settings() {
    return br.getGroupLink(
      this.managedSettingKeys[0],
      this._store.settings
    );
  }
  get managedSettingKeys() {
    return ["controlPanel"];
  }
  get descriptionPanel() {
    return this._descriptionPanelRef.value;
  }
  get chartPanel() {
    return this._chartPanelRef.value;
  }
  get annotationPanel() {
    return this._annotationPanelRef.value;
  }
  // get statusBar() {
  //   return this._descriptionPanelRef.value!.statusBar;
  // }
  get dialog() {
    return this._dialogRef.value;
  }
  connectedCallback() {
    super.connectedCallback(), this._storeChangeUnsub = this._store.subscribe((t, e) => {
      t === "data" && this.dataUpdated();
    }), this.addButtonListeners();
  }
  addButtonListeners() {
    const t = () => {
      var n, i, s;
      let e = setTimeout(() => {
        t();
      }, 100), r = (s = (i = (n = this.shadowRoot) == null ? void 0 : n.getElementById("wrapper")) == null ? void 0 : i.children[0].shadowRoot) == null ? void 0 : s.children[0].getElementsByClassName("toggle")[0];
      r && (r.addEventListener("pointerenter", () => {
        this.addPopup(!!this.paraChart.isControlPanelOpen);
      }), r.addEventListener("pointerleave", () => {
        this.removePopup(this.id);
      }), r.addEventListener("click", () => {
        this.removePopup(this.id), this.addButtonListeners();
      }), clearTimeout(e));
    };
    t();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._storeChangeUnsub();
  }
  // Anything that needs to be done when data is updated, do here
  dataUpdated() {
    this.dataState = "complete";
  }
  settingDidChange(t, e) {
    var s;
    const r = t.match(/controlPanel\.(\w+)/)[1], n = /is(\w+)TabVisible/, i = (s = r.match(n)) == null ? void 0 : s[1];
    if (i)
      e ? this._tabsRef.value.show(i) : this._tabsRef.value.hide(i);
    else if (r === "isControlPanelDefaultOpen" || r === "tabLabelStyle")
      this.requestUpdate();
    else if (r === "isCaptionVisible" || r === "isExplorationBarVisible")
      this._descriptionPanelRef.value.requestUpdate();
    else if (r === "isSparkBrailleVisible")
      this._dataPanelRef.value.isSparkBrailleVisible = e;
    else if (r === "isSparkBrailleControlVisible")
      this._dataPanelRef.value.requestUpdate();
    else if (r === "isColorPaletteControlVisible" || r === "isCVDControlVisible")
      this._colorsPanelRef.value.requestUpdate();
    else
      return !1;
    return !0;
  }
  updated(t) {
    t.has("dataState") && this.dataState === "complete" && this.descriptionPanel.requestUpdate();
  }
  externalizeCaptionBox() {
    this.after(this.paraChart.captionBox);
  }
  onFocus() {
    this._descriptionPanelRef.value.clearStatusBar();
  }
  showHelpDialog() {
    return this._controlsPanelRef.value.showHelpDialog();
  }
  addPopup(t) {
    let e = this.paraChart.paraView, r = t ? "Close control panel" : "Customize settings", n = e.documentView.height - 70, i = 0 - this.paraChart.paraView.documentView.chartLayers.x, s = new ls(
      e,
      {
        text: r ?? "",
        x: i,
        y: n + (t ? 26.4 : 0),
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        type: "controlPanelIcon",
        fill: "hsl(0, 0%, 0%)",
        inbounds: !0
      },
      {
        fill: "hsl(0, 0%, 100%)",
        shape: "boxWithArrow"
      }
    );
    e.store.popups.push(s);
  }
  removePopup(t) {
    this.paraChart.paraView.store.popups.splice(this.paraChart.paraView.store.popups.findIndex((e) => e.id === t), 1), this.paraChart.paraView.requestUpdate();
  }
  render() {
    let t = this.paraChart.isControlPanelOpen ? "expanded" : "collapsed";
    const e = {
      icon: "icons",
      iconLabel: "icons-labels",
      label: "labels"
    };
    return qe`
      <div id="wrapper">
        <fizz-tabs
          ${yt(this._tabsRef)}
          ?open=${this.settings.isControlPanelDefaultOpen}
          class=${t}
          tablabelmode=${e[this.settings.tabLabelStyle]}
		  openbuttonarialabel="ParaCharts control panel"
          @open=${() => {
      this.paraChart.isControlPanelOpen = !0, this.settings.caption.isCaptionExternalWhenControlPanelClosed && this._descriptionPanelRef.value.internalizeCaptionBox();
    }}
          @close=${() => {
      this.paraChart.isControlPanelOpen = !1, this.settings.caption.isCaptionExternalWhenControlPanelClosed && this.externalizeCaptionBox();
    }}
          @invalidvalue=${(r) => this._msgDialogRef.value.show(r.detail)}
          @ready=${() => {
    }}
        >
          <fizz-tab-panel
            tablabel="Description"
            icon=${$_e}
          >
            <para-description-panel
              ${yt(this._descriptionPanelRef)}
              .controlPanel=${this}
            ></para-description-panel>
          </fizz-tab-panel>
          <fizz-tab-panel
            tablabel="Data"
            icon=${j_e}
            ?hidden=${!this.settings.isDataTabVisible}
          >
            <para-data-panel
              ${yt(this._dataPanelRef)}
              .controlPanel=${this}
              .sparkBrailleData=${this.sparkBrailleData}
              .isSparkBrailleVisible=${this.settings.isSparkBrailleVisible}
            ></para-data-panel>
          </fizz-tab-panel>
          <fizz-tab-panel
            tablabel="Colors"
            icon=${B_e}
            ?hidden=${!this.settings.isColorsTabVisible}
          >
            <para-colors-panel
              ${yt(this._colorsPanelRef)}
              .controlPanel=${this}
            ></para-colors-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Audio"
            icon=${F_e}
            ?hidden=${!this.settings.isAudioTabVisible}
          >
            <para-audio-panel
              .controlPanel=${this}
            ></para-audio-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Controls"
            icon=${z_e}
            ?hidden=${!this.settings.isControlsTabVisible}
          >
            <para-controls-panel
              ${yt(this._controlsPanelRef)}
              .controlPanel=${this}
            ></para-controls-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Chart"
            icon=${V_e}
            ?hidden=${!this.settings.isChartTabVisible}
          >
            <para-chart-panel
              ${yt(this._chartPanelRef)}
              .controlPanel=${this}
            ></para-chart-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Annotations"
            icon=${IO}
            ?hidden=${!this.settings.isAnnotationsTabVisible}
          >
            <para-annotation-panel
              ${yt(this._annotationPanelRef)}
              .controlPanel=${this}
            ></para-annotation-panel>
          </fizz-tab-panel>

          <!--<fizz-tab-panel
            tablabel="Analysis"
            icon=${IO}
            ?hidden=${!this.settings.isAnalysisTabVisible}
          >
            <para-analysis-panel
              .controlPanel=${this}
            ></para-analysis-panel>
          </fizz-tab-panel>-->
        </fizz-tabs>
      </div>
      ${this.renderDialog()}
    `;
  }
  renderDialog() {
    return qe`
      <para-dialog
        ${yt(this._dialogRef)}
        id="generic-dialog"
      ></para-dialog>
      <fizz-msg-dialog
        ${yt(this._msgDialogRef)}
      ></fizz-msg-dialog>
    `;
  }
  renderTabDebug() {
    return qe`
      <fizz-tab-panel tablabel="Debug">
        <div class="tab-content">
          <div
            class="setting-views"
          >
          </div>
        </div>
      </fizz-tab-panel>
    `;
  }
  getJsonStr(t, e, r) {
    return e ? `
        <pre><code>${JSON.stringify(t, null, r)}
        </code></pre>
      ` : JSON.stringify(t, null, r);
  }
};
ng.styles = [
  //styles,
  Nt`
      * {
        font-family: "Trebuchet MS", Helvetica, sans-serif;
        font-size: var(--control-panel-font-size, 1rem);
      }
      #wrapper {
        position: relative;
      }
      fizz-tabs {
        --background: #eee;
        --toggle-button-icon: var(--control-panel-icon, url(${Ju(U_e)}));
        /*--control-panel-icon: url(${Ju(qU)});*/
        --summary-marker-font-weight: bold;
        --control-panel-icon-size: 1.1rem;
        --contents-margin: 2px 0 0 0;
        width: 1;
        min-width: 40rem;
        max-width: 50%;
      }
      fizz-tabs.collapsed {
        /*width: rem;*/
        /*min-width: unset;*/
        position: absolute;
        bottom: 10px;
        /*--background: none;
        --control-panel-background: none;
        --control-panel-icon-color: var(--theme-color);
        --control-panel-icon-size: 1.5rem;
        --theme-contrast-color: var(--theme-color);
        --border: none;*/
        border: 2px solid transparent;
      }

      fizz-tabs.expanded {
        border: 2px solid var(--theme-color);
        border-radius: 4px;
        --background: none;
        --control-panel-icon-color: ghostwhite;
        --summary-padding: 0 0.35rem;
        --summary-margin: -2px 0;
      }

      fizz-tabs.collapsed.darkmode  {
        --control-panel-icon-color: ghostwhite;
      }
    `
];
V9([
  Ke()
], ng.prototype, "sparkBrailleData", 2);
V9([
  Vr()
], ng.prototype, "dataState", 2);
ng = V9([
  Dt("para-control-panel")
], ng);
var W_e = Object.defineProperty, q_e = Object.getOwnPropertyDescriptor, U9 = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? q_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && W_e(e, r, i), i;
};
let ig = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("ParaCaptionBox"), this._lastSpans = /* @__PURE__ */ new Set(), this._prevSpanIdx = 0, this._highlightManualOverride = !1, this._caption = { text: "", html: "" }, this._spans = [], this._isEBarVisible = !1;
  }
  get highlightManualOverride() {
    return this._highlightManualOverride;
  }
  connectedCallback() {
    super.connectedCallback(), this.setCaption(), this._storeChangeUnsub = this._store.subscribe(this.setCaption.bind(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._storeChangeUnsub();
  }
  updated(t) {
    if (!this._store.settings.ui.isNarrativeHighlightEnabled) return;
    const e = this.getSpans();
    this._spans = this._spans.filter((r) => e.includes(r)), e.forEach((r, n) => {
      this._spans.includes(r) || (this._spans.push(r), r.addEventListener("pointerenter", (i) => {
        if (!this._store.settings.ui.isNarrativeHighlightEnabled || this._store.paraChart.ariaLiveRegion.voicing.isSpeaking) return;
        const s = this._store.announcement.highlights[n];
        this._store.paraChart.postNotice("utteranceBoundary", s);
      }));
    });
  }
  clearStatusBar() {
    this.parachart.clearAriaLive();
  }
  async setCaption() {
    this._store.dataState === "complete" && (this._caption = await this._store.paraChart.paraView.documentView.chartInfo.summarizer.getChartSummary());
  }
  noticePosted(t, e) {
    if (this._store.settings.ui.isNarrativeHighlightEnabled) {
      if (t === "utteranceBoundary") {
        const r = e;
        for (const n of this.getSpans())
          n.dataset.phrasecode === `${r.phrasecode}` ? (n.classList.add("highlight"), this._lastSpans.add(n)) : (n.classList.remove("highlight"), this._lastSpans.delete(n));
      } else if (t === "utteranceEnd" && !this._highlightManualOverride)
        for (const r of this._lastSpans)
          r.classList.remove("highlight");
    }
  }
  highlightSpan(t = !0) {
    const e = (o) => {
      const a = document.createElement("div");
      return a.innerHTML = this._store.announcement.html, a.children[o].innerText;
    }, r = this._store.paraChart.ariaLiveRegion.voicing;
    let n = this._prevSpanIdx;
    this._highlightManualOverride || (n = r.highlightIndex, this._highlightManualOverride = !0), n = Math.min(
      this._store.announcement.highlights.length - 1,
      Math.max(0, n + (t ? 1 : -1))
    ), this._prevSpanIdx = n;
    const i = e(n), s = this._store.announcement.highlights[n];
    r.shutUp(), r.speakText(i), this._store.paraChart.postNotice("utteranceBoundary", s);
  }
  clearSpanHighlights() {
    for (const t of this.getSpans())
      t.classList.remove("highlight");
  }
  renderSummary(t, e) {
    return typeof t == "string" && (t = { text: t, html: t }), qe`
      <article>
        ${iU(t.html)}
      </article>
    `;
  }
  getSpans() {
    return Array.from(this.renderRoot.querySelectorAll("span"));
  }
  render() {
    this._isEBarVisible = !!this.store.announcement.text && this._store.announcement.text !== this._caption.text;
    const t = !this._isEBarVisible || !this._store.settings.controlPanel.isExplorationBarVisible;
    return qe`
      <figcaption class=${this.parachart.isControlPanelOpen ? "" : "external"}>
        <div id="caption-box">
          <div
            id="caption"
            class=${t ? "solo" : ""}
            ?hidden=${!this._store.settings.controlPanel.isCaptionVisible}
          >
            ${this.renderSummary(this._caption, "caption")}
          </div>
          <div
            id="exploration-bar"
            class=${t ? "hidden" : ""}
          >
            <div
              id="exploration-bar-text"
              aria-hidden="true"
            >
              ${this._store.announcement.text === this._caption.text ? "" : this.renderSummary(this._store.announcement, "statusbar")}
            </div>
            ${!this._store.settings.controlPanel.caption.isCaptionExternalWhenControlPanelClosed || this.parachart.isControlPanelOpen ? qe`
                <button
                  @click=${() => this.parachart.showAriaLiveHistory()}
                >
                  History
                </button>` : ""}
          </div>
        </div>
      </figcaption>
    `;
  }
};
ig.styles = [
  Nt`
      figcaption.external {
        border: var(--caption-border);
      }
      #caption-box {
        display: grid;
        grid-template-columns: var(--caption-grid-template-columns);
      }
      #caption {
        padding: 0.25rem;
      }
      #caption.solo {
        grid-column: 1 / 3
      }
      #exploration-bar {
        background-color: var(--theme-color-light);
        padding: 0.2rem;
        display: var(--exploration-bar-display);
        flex-direction: column;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
      }
      #exploration-bar-text {
        align-self: flex-start;
      }
      #caption span.highlight {
        background-color: var(--theme-color-light);
      }
      #exploration-bar span.highlight {
        background-color: white;
      }
      #exploration-bar.hidden {
        /* Using this rather than 'hidden' attr to override flex display */
        display: none;
      }
    `
];
U9([
  Ke({ attribute: !1 })
], ig.prototype, "parachart", 2);
U9([
  Vr()
], ig.prototype, "_caption", 2);
ig = U9([
  Dt("para-caption-box")
], ig);
const Q_e = "./node_modules/@fizz/chart-data/data/";
class K_e {
  constructor() {
    this.log = qt("ParaLoader"), this._csvParseResult = null;
  }
  async load(e, r, n, i) {
    let s;
    if (e === "content")
      s = JSON.parse(r);
    else {
      let a = "";
      e === "fizz-chart-data" && (a = Q_e), a += r, this.log.info(`loading manifest from ${a}`), s = await (await fetch(a)).json();
    }
    let o;
    if (s.datasets[0].data.source === "external") {
      s.datasets[0].data.source = "inline", o = {}, s.datasets[0].data.path !== "para:preload" && this.preloadData(s.datasets[0].data.path);
      const a = s.datasets[0].series.map((c) => c.key), l = this._csvParseResult.meta.fields.filter((c) => !a.includes(c))[0];
      this._csvParseResult.data.forEach((c, p) => {
        Object.entries(c).forEach(([h, d]) => {
          a.includes(h) && (o[h] || (o[h] = []), o[h].push({
            x: c[l],
            y: d
          }));
        });
      }), s.datasets[0].series.forEach((c) => {
        c.records = o[c.key];
      });
    }
    return this.log.info("manifest loaded"), n && (s.datasets[0].type = n, this.log.info("manifest chart type changed")), i && (s.datasets[0].description = i, this.log.info("manifest description changed")), { result: "success", manifest: s };
  }
  /**
   * Fetch and parse a CSV, storing the parse results.
   * @param url - CSV URL
   * @returns List of FieldInfo records
   */
  async preloadData(e) {
    const r = await (await fetch(e)).text();
    return LN.parse(r, {
      header: !0,
      complete: (n) => {
        this._csvParseResult = n;
      },
      error: (n) => {
        throw new Error(`Papa Parse error: ${n}`);
      }
    }), this._csvParseResult.meta.fields.map((n) => ({
      name: n,
      // XXX need to detect date formats
      type: isNaN(parseFloat(this._csvParseResult.data[0][n])) ? "string" : "number"
    }));
  }
}
class Y_e {
  constructor() {
    this._customPrefix = "--para-", this._paraRules = {}, this._colorPalette = null, this._symbolSet = null, this.log = qt("CustomPropertyLoader");
  }
  get store() {
    return this._store;
  }
  set store(e) {
    this._store = e;
  }
  // Convert `paraRules` to object of key-value pairs of type SettingInput
  processProperties() {
    this._getParaRules();
    const e = {};
    return Object.keys(this._paraRules).forEach((r) => {
      const n = r.replace(/\s+/g, "").substring(1), i = this._paraRules[r];
      this.log.info(r, i), Object.keys(i).forEach((s) => {
        const o = i[s], a = this._isColorProp(s), l = this._isSymbolProp(s);
        if (!a && !l) {
          this.log.info(s, o);
          const c = this._convertPropToSettingStr(s);
          let p = o, h = parseFloat(o);
          Number.isNaN(h) ? o === "true" ? p = !0 : o === "false" ? p = !1 : this._hasDoubleQuotes(o) && (p = this._trimQuotes(o)) : p = h, e[`${n}.${c}`] = p;
        } else a ? this._processColorProps(s, o) : l && this._processSymbolProps(s, o);
      });
    }), e;
  }
  _isSameDomain(e) {
    return e.href ? e.href.indexOf(window.location.origin) === 0 : !0;
  }
  // returns boolean and narrows type to CSSStyleRule
  _isStyleRule(e) {
    return e instanceof CSSStyleRule;
  }
  _isParaProp(e) {
    return e.startsWith(this._customPrefix);
  }
  _getParaRules() {
    const e = [...document.styleSheets].filter(this._isSameDomain);
    for (const r of e) {
      const n = [...r.cssRules].filter(this._isStyleRule);
      for (const i of n) {
        const s = [...i.style].filter(this._isParaProp.bind(this)).map((o) => ({
          [o]: i.style.getPropertyValue(o)
        }));
        if (s.length) {
          const o = i.selectorText;
          this._paraRules[o] ? this.log.warn(`[ParaCharts] Duplicate selector '${o}'; collecting all properties`) : this._paraRules[o] = {}, s.forEach((a) => {
            Object.entries(a).forEach(([l, c]) => {
              this._convertPropToSettingStr(l);
              const p = this._paraRules[o][l];
              if (p) {
                const h = p === c ? `[ParaCharts] Duplicate value '${c}' for property '${l}' in selector '${o}'` : `[ParaCharts] Replaced value '${p}' with value '${c}' for property '${l}' in selector '${o}'`;
                this.log.warn(h);
              }
              this._paraRules[o][l] = c;
            });
          });
        }
      }
    }
  }
  _hasDoubleQuotes(e) {
    return e.startsWith('"') && e.endsWith('"') || e.startsWith("'") && e.endsWith("'");
  }
  _trimQuotes(e) {
    return e.replace(/['"]/g, "");
  }
  _convertPropToSettingStr(e) {
    const r = e.replace(this._customPrefix, "");
    return this._convertKebabToCamelCase(r);
  }
  _convertKebabToCamelCase(e) {
    return e.replace(/-./g, (n) => n[1].toUpperCase());
  }
  _convertCamelToKebabCase(e) {
    return e.replace(/[A-Z0-9]+(?![a-z0-9])|[A-Z]/g, (n, i) => (i ? "-" : "") + n.toLowerCase());
  }
  _isColorProp(e) {
    const r = e.match(/series-\d+-color/gi), n = e.match(/palette/gi);
    return !!(r != null && r.length || n != null && n.length);
  }
  _processColorProps(e, r) {
    if (this._colorPalette || (this._colorPalette = {
      key: "custom-0",
      title: "Custom palette",
      colors: []
    }), e === `${this._customPrefix}palette`) {
      const n = r.split(/,\s+/);
      this._colorPalette.key = this._trimQuotes(n[0]), this._colorPalette.title = this._trimQuotes(n[1]);
    } else {
      const n = parseInt(e.match(/\d+/g)[0]), i = r.split(/,\s+['"]/);
      this.log.info("color valueArray", i), this._colorPalette.colors[n] = {
        value: i[0],
        name: this._trimQuotes(i[1])
      };
    }
  }
  registerColors() {
    this._colorPalette && (this._store.colors.addPalette(this._colorPalette), this._store.colors.selectPaletteWithKey(this._colorPalette.key));
  }
  _isSymbolProp(e) {
    const r = e.match(/series-\d+-symbol/gi);
    return !!(r != null && r.length);
  }
  _processSymbolProps(e, r) {
    this._symbolSet || (this._symbolSet = []);
    const n = parseInt(e.match(/\d+/g)[0]), i = r.split(/,\s+['"]/), s = this._trimQuotes(i[0]), o = this._trimQuotes(i[1]);
    this._symbolSet[n] = `${s}.${o}`;
  }
  registerSymbols() {
    this._symbolSet && (this._store.symbols.types = this._symbolSet);
  }
}
class Z_e {
  constructor(e) {
    this._selector = e, this._declarations = /* @__PURE__ */ new Map();
  }
  get selector() {
    return this._selector;
  }
  set(e) {
    Object.entries(e).forEach(([r, n]) => {
      this._declarations.set(r, n);
    });
  }
  toString() {
    return `${this._selector} {
${this._declarations.entries().map(([e, r]) => `  ${e}: ${typeof r == "function" ? r() : r.toString()};`).toArray().join(`
`)}
}`;
  }
}
class J_e {
  constructor(e) {
    this._stylesheet = e, this._rules = /* @__PURE__ */ new Map(), this.log = qt("StyleManager");
  }
  set(e, r) {
    let n = this._rules.get(e);
    n || (n = new Z_e(e), this._rules.set(e, n)), n.set(r);
  }
  update() {
    this._rules.values().map((r) => {
      const n = r.selector.split(" "), i = new RegExp(["^", ...n, "\\{"].join("\\s*"));
      return Array.from(this._stylesheet.cssRules).findIndex((s) => s.cssText.match(i));
    }).filter((r) => r !== -1).toArray().sort().reverse().forEach((r) => {
      this.log.info("DEL", r), this._stylesheet.deleteRule(r);
    }), this._rules.values().forEach((r) => {
      this.log.info("INS", r), this._stylesheet.insertRule(r.toString());
    });
  }
}
class Pp {
  constructor(e) {
    const r = e.store, n = () => e.documentView.chartInfo, i = () => e.documentView.chartLayers.dataLayer;
    this._commands = {
      key(s) {
        return r.keymapManager.onKeydown(s);
      },
      click(s, o, a = !1) {
        const l = i().datapointView(s, o);
        return l ? (n().navMap.goTo(n().navDatapointType, {
          seriesKey: l.seriesKey,
          index: l.index
        }), n().selectCurrent(a), !0) : !1;
      }
    };
  }
  static getInst(e) {
    return Pp._inst || (Pp._inst = new Pp(e)), Pp._inst;
  }
  get commands() {
    return this._commands;
  }
}
class X_e {
  constructor(e) {
    this._paraChart = e;
    const r = e.store, n = e.paraView;
    this._allSeries = r.model.series.map((a) => new eCe(a.label, this));
    const i = () => e.paraView.documentView.chartInfo, s = this;
    this._standardActions = {
      move(a) {
        i().clearPlay(), i().move(a.direction);
      },
      goFirst() {
        i().navFirst();
      },
      goLast() {
        i().navLast();
      },
      goMinimum() {
        i().goSeriesMinMax(!0);
      },
      goMaximum() {
        i().goSeriesMinMax(!1);
      },
      goTotalMinimum() {
        i().goChartMinMax(!0);
      },
      goTotalMaximum() {
        i().goChartMinMax(!1);
      },
      select() {
        i().selectCurrent(!1);
      },
      extendSelection() {
        i().selectCurrent(!0);
      },
      clearSelection() {
        i().clearDatapointSelection();
      },
      playRight() {
        i().playDir("right");
      },
      playLeft() {
        i().playDir("left");
      },
      stopPlay() {
        i().clearPlay();
      },
      queryData() {
        i().queryData();
      },
      toggleSonificationMode() {
        r.updateSettings((a) => {
          a.sonification.isSoniEnabled = !a.sonification.isSoniEnabled;
          const l = a.sonification.isSoniEnabled ? "enable" : "disable";
          r.announce(`Sonification ${l + "d"}`), e.postNotice(l + "Sonification", null);
        });
      },
      toggleTrendNavigationMode() {
        r.updateSettings((a) => {
          a.type.line.isTrendNavigationModeEnabled = !a.type.line.isTrendNavigationModeEnabled;
          const l = a.type.line.isTrendNavigationModeEnabled ? "enable" : "disable";
          r.announce(`Trend navigation ${l + "d"}`), e.postNotice(l + "TrendNavigation", null);
        });
      },
      toggleAnnouncementMode() {
        r.settings.ui.isAnnouncementEnabled ? (r.announce("Announcements disabled"), r.updateSettings((a) => {
          a.ui.isAnnouncementEnabled = !1;
        }), e.postNotice("disableAnnouncements", null)) : (r.updateSettings((a) => {
          a.ui.isAnnouncementEnabled = !0;
        }), r.announce("Announcements enabled"), e.postNotice("enableAnnouncements", null));
      },
      toggleVoicingMode() {
        r.updateSettings((a) => {
          a.ui.isVoicingEnabled = !a.ui.isVoicingEnabled;
          const l = a.ui.isVoicingEnabled ? "enable" : "disable";
          e.postNotice(l + "Voicing", null);
        });
      },
      toggleDarkMode() {
        r.updateSettings((a) => {
          a.color.isDarkModeEnabled = !a.color.isDarkModeEnabled;
          const l = a.color.isDarkModeEnabled ? "enable" : "disable";
          e.postNotice(l + "DarkMode", null), r.announce(`Dark mode ${l + "d"}`);
        });
      },
      toggleLowVisionMode() {
        r.updateSettings((a) => {
          a.ui.isLowVisionModeEnabled ? (a.ui.isFullscreenEnabled = !1, e.postNotice("disableLowVisionMode", null)) : (a.ui.isLowVisionModeEnabled = !0, e.postNotice("enableLowVisionMode", null));
        });
      },
      openHelp() {
        e.controlPanel.showHelpDialog();
      },
      announceVersionInfo() {
        r.announce(`Version ${__APP_VERSION__}; commit ${__COMMIT_HASH__}`);
      },
      jumpToChordLanding() {
        i().navToChordLanding();
      },
      shutUp() {
        e.ariaLiveRegion.voicing.shutUp();
      },
      repeatLastAnnouncement() {
        e.ariaLiveRegion.replay();
      },
      addAnnotation() {
        r.addAnnotation();
      },
      toggleNarrativeHighlightMode() {
        n.startNarrativeHighlightMode(), s._actions = s._narrativeActions, r.updateSettings((a) => {
          a.ui.isNarrativeHighlightEnabled = !0;
          //!draft.ui.isNarrativeHighlightEnabled;
          e.postNotice("enableNarrativeHighlightMode", null);
        });
      },
      playPauseMedia() {
      },
      reset() {
        r.clearSelected(), i().navMap.root.goTo("top", {}), n.createDocumentView();
      }
    }, this._actions = this._standardActions, this._narrativeActions = Object.create(this._actions);
    const o = n.paraChart.ariaLiveRegion.voicing;
    this._narrativeActions.move = async (a) => {
      r.paraChart.captionBox.highlightSpan(a.direction === "right" || a.direction === "down");
    }, this._narrativeActions.goFirst = () => {
    }, this._narrativeActions.goLast = () => {
    }, this._narrativeActions.repeatLastAnnouncement = () => {
    }, this._narrativeActions.toggleNarrativeHighlightMode = () => {
      e.captionBox.clearSpanHighlights(), r.clearHighlight(), r.clearAllSeriesLowlights(), n.endNarrativeHighlightMode(), s._actions = this._standardActions, r.settings.ui.isNarrativeHighlightEnabled ? r.updateSettings((a) => {
        a.ui.isNarrativeHighlightEnabled = !1;
      }) : r.updateSettings((a) => {
        a.ui.isNarrativeHighlightEnabled = !0;
      });
    }, this._narrativeActions.playPauseMedia = () => {
      o.togglePaused();
    };
  }
  get paraChart() {
    return this._paraChart;
  }
  get chartInfo() {
    return this._paraChart.paraView.documentView.chartInfo;
  }
  get allSeries() {
    return this._allSeries;
  }
  get actions() {
    return this._actions;
  }
  doAction(e, r) {
    this._actions[e](r);
  }
  // protected _labelToKey(seriesLabel: string): string {
  //   const series = this._paraChart.store.model!.series.find(s => s.label === seriesLabel);
  //   if (!series) throw new Error(`no series with label '${seriesLabel}'`);
  //   return series.key;
  // }
  getSeries(e) {
    return this.getAllSeries(e)[0];
  }
  getAllSeries(...e) {
    const r = Array.from(new Set(e)), n = [];
    for (const i of r) {
      const s = this._allSeries.find((o) => o.label === i);
      if (!s) throw new Error(`no series with label '${i}'`);
      n.push(s);
    }
    return n;
  }
  // sendKey(keyId: string) {
  //   this._paraChart.command('key', [keyId]);
  // }
  serializeChart() {
    return this._paraChart.paraView.serialize();
  }
  downloadSVG() {
    this._paraChart.paraView.downloadSVG();
  }
  downloadPNG() {
    this._paraChart.paraView.downloadPNG();
  }
  setSetting(e, r) {
    this._paraChart.store.updateSettings((n) => {
      br.set(e, r, n);
    });
  }
  clearAllSeriesLowlights() {
    this._paraChart.store.clearAllSeriesLowlights();
  }
  hideAllSeries() {
    this._paraChart.store.hideAllSeries();
  }
  unhideAllSeries() {
    this._paraChart.store.unhideAllSeries();
  }
  enableNarrativeActions() {
    this._actions = this._narrativeActions;
  }
  enableStandardActions() {
    this._actions = this._standardActions;
  }
}
class eCe {
  constructor(e, r) {
    this._label = e, this._api = r;
    const n = r.paraChart.store.model.atLabel(e);
    this._key = n.key, this._datapoints = [...n.datapoints], this._allPoints = this._datapoints.map((i) => new tCe(i, this));
  }
  get label() {
    return this._label;
  }
  get key() {
    return this._key;
  }
  get api() {
    return this._api;
  }
  get allPoints() {
    return this._allPoints;
  }
  getPoint(e) {
    return this.getPoints(e)[0];
  }
  getPoints(...e) {
    const r = Array.from(new Set(e)), n = [];
    for (const i of r) {
      const s = this._allPoints[i];
      if (!s) throw new Error(`invalid index '${i}'`);
      n.push(s);
    }
    return n;
  }
  lowlight() {
    this._api.paraChart.store.lowlightSeries(this._key);
  }
  clearLowlight() {
    this._api.paraChart.store.clearSeriesLowlight(this._key);
  }
  isLowlighted() {
    return this._api.paraChart.store.isSeriesLowlighted(this._key);
  }
  lowlightOthers() {
    this._api.paraChart.store.lowlightOtherSeries(this._key);
  }
  hide() {
    this._api.paraChart.store.hideSeries(this._key);
  }
  unhide() {
    this._api.paraChart.store.unhideSeries(this._key);
  }
  isHidden() {
    return this._api.paraChart.store.isSeriesHidden(this._key);
  }
  hideOthers() {
    this._api.paraChart.store.hideOtherSeries(this._key);
  }
  playRiff() {
    this._api.chartInfo.playRiff(this._datapoints);
  }
}
class tCe {
  constructor(e, r) {
    this._datapoint = e, this._apiSeries = r;
  }
  visit() {
    this._apiSeries.api.chartInfo.navMap.goTo(this._apiSeries.api.chartInfo.navDatapointType, {
      seriesKey: this._datapoint.seriesKey,
      index: this._datapoint.datapointIndex
    });
  }
  select(e = !1) {
    this.visit(), this._apiSeries.api.chartInfo.selectCurrent(e);
  }
  highlight() {
  }
  clearHighlight() {
  }
  play() {
    this._apiSeries.api.chartInfo.playDatapoints([this._datapoint]);
  }
  annotate(e) {
    this._apiSeries.api.paraChart.store.annotatePoint(
      this._apiSeries.key,
      this._datapoint.datapointIndex,
      e
    );
  }
}
class rCe {
  constructor(e) {
    this.log = qt("Scrollyteller"), this.parachart = e, this.chartId = this.parachart.id, this._events = /* @__PURE__ */ new Map(), this.steps = [], this.globalOffset = { format: "percent", value: 0.5 }, this.containerElement = void 0, this.rootElement = null, this.progressThreshold = 0, this.isEnabled = !1, this.isProgress = !1, this.isTriggerOnce = !1, this.exclude = [], this.currentScrollY = 0, this.comparisonScrollY = 0, this.direction = void 0, this._handleScroll = this._handleScroll.bind(this), this._resizeStep = this._resizeStep.bind(this), this._intersectStep = this._intersectStep.bind(this), this._intersectProgress = this._intersectProgress.bind(this), this.settings = this.parachart.paraView.store.settings.scrollytelling, this.settings.isScrollytellingEnabled && this.init();
  }
  init() {
    var e;
    this.stepElements = document.querySelectorAll("[data-para-step]"), this.setup({
      step: "[data-para-step]",
      offset: 0.5,
      progress: !0,
      once: !1
    }), this.on("stepEnter", (r) => {
      const n = r.element;
      this.highlightPageContent(n);
      for (const { action: i, params: s } of r.actions) {
        if (i === "highlightSeries" && s.length > 0 && this.parachart.store.lowlightOtherSeries(...s), i === "highlightDatapoint" && s.length >= 2 && this.parachart.api.getSeries(s[0]).getPoint(+s[1]).select(), i === "directLabels") {
          console.warn("directLabels", s);
          const o = s[0] === "true";
          this.parachart.api.setSetting("chart.hasDirectLabels", o);
        }
        if (i === "hasSymbols") {
          console.warn("hasSymbols", s);
          const o = s[0] === "true";
          this.parachart.api.setSetting("chart.isDrawSymbols", o);
        }
        i === "setColorPalette" && (console.warn("setColorPalette", s), this.parachart.api.setSetting("color.colorPalette", s[0])), i === "setManifest" && (console.warn("manifest", s), console.warn("this.parachart", this.parachart), this.parachart.setAttribute("manifest", s[0])), i === "playSonification" && this.parachart.api.getSeries(s[0]).playRiff();
      }
    }), this.on("stepExit", (r) => {
      if (r.element, r.direction === "down")
        this.log.warn("SCROLLY: exit down", r);
      else {
        this.log.warn("SCROLLY: exit up", r), this.log.warn("SCROLLY: reverse action!");
        for (const { action: n, params: i } of r.actions)
          n === "highlightDatapoint" && i.length >= 2 && this.parachart.api.getSeries(i[0]).getPoint(+i[1]).select();
      }
    }), (e = this.stepElements[0]) == null || e.classList.add("para-active");
  }
  highlightPageContent(e) {
    this.stepElements.forEach((r) => r.classList.remove("para-active")), e.classList.add("para-active");
  }
  // internal helpers
  getChartSteps(e, r = document) {
    return this.selectAll(e, r).filter((i) => {
      const s = i.dataset.paraChartid;
      return !s || s === this.chartId;
    });
  }
  selectAll(e, r = document) {
    return typeof e == "string" ? Array.from(r.querySelectorAll(e)) : e instanceof Element ? [e] : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [];
  }
  getIndex(e) {
    const r = e.getAttribute("data-scrollytelling-index");
    return r ? +r : 0;
  }
  indexSteps(e) {
    e.forEach(
      (r) => r.node.setAttribute("data-scrollytelling-index", r.index.toString())
    );
  }
  getOffsetTop(e) {
    const { top: r } = e.getBoundingClientRect(), n = window.pageYOffset, i = document.body.clientTop || 0;
    return r + n - i;
  }
  parseOffset(e) {
    if (typeof e == "string" && e.indexOf("px") > 0) {
      const r = +e.replace("px", "");
      return isNaN(r) ? (this.err('offset value must be in "px" format. Fallback to 0.5.'), { format: "percent", value: 0.5 }) : { format: "pixels", value: r };
    } else if (typeof e == "number" || e != null && !isNaN(+e)) {
      const r = typeof e == "number" ? e : +e;
      return r > 1 && this.err("offset value is greater than 1. Fallback to 1."), r < 0 && this.err("offset value is lower than 0. Fallback to 0."), { format: "percent", value: Math.min(Math.max(0, r), 1) };
    }
    return { format: "percent", value: 0.5 };
  }
  getActions(e) {
    let r = [];
    const n = this.parseActions(e.dataset.paraAction);
    r.push(...n);
    const i = e.querySelectorAll("[data-para-action]");
    return Array.from(i).filter((o) => {
      const a = o.dataset.paraChartid;
      return !a || a === this.chartId;
    }).forEach((o) => {
      const a = this.parseActions(o.dataset.paraAction);
      r.push(...a);
    }), r;
  }
  parseActions(e) {
    if (!e) return [];
    const r = [];
    return e.split(")").forEach((i) => {
      if (i = i.trim(), i) {
        const s = i.split("("), o = s[0].trim(), a = s[1] ? s[1].trim() : "", l = a ? a.split(",").map((c) => c.trim()) : [];
        r.push({
          action: o,
          params: l
        });
      }
    }), r;
  }
  err(e) {
    this.log.error(`scrollytelling: ${e}`);
  }
  createProgressThreshold(e, r) {
    const n = Math.ceil(e / r), i = [], s = 1 / n;
    for (let o = 0; o < n + 1; o += 1) i.push(o * s);
    return i;
  }
  _resetExclusions() {
    this.exclude = [];
  }
  on(e, r) {
    return this._events.has(e) || this._events.set(e, []), this._events.get(e).push(r), this;
  }
  once(e, r) {
    const n = (i) => {
      r(i), this.off(e, n);
    };
    return this.on(e, n);
  }
  off(e, r) {
    if (!e)
      this._events.clear();
    else if (!r)
      this._events.delete(e);
    else {
      const n = this._events.get(e);
      if (n) {
        const i = n.indexOf(r);
        i > -1 && n.splice(i, 1);
      }
    }
    return this;
  }
  emit(e, r) {
    const n = this._events.get(e);
    n && n.forEach((i) => i(r));
  }
  _disconnectObserver(e) {
    Object.keys(e).forEach((r) => e[r].disconnect());
  }
  _disconnectObservers() {
    this.steps.forEach((e) => this._disconnectObserver(e.observers));
  }
  _handleEnable(e) {
    e && !this.isEnabled && this._updateObservers(), !e && this.isEnabled && this._disconnectObservers(), this.isEnabled = e;
  }
  _notifyProgress(e, r) {
    const n = this.getIndex(e), i = this.steps[n];
    r !== void 0 && (i.progress = r);
    const s = { element: e, index: n, progress: r, direction: this.direction, actions: i.actions };
    i.state === "enter" && this.emit("stepProgress", s);
  }
  _notifyStepEnter(e) {
    const r = this.getIndex(e), n = this.steps[r], i = { element: e, index: r, direction: this.direction, actions: n.actions };
    n.direction = this.direction, n.state = "enter", this.exclude[r] || this.emit("stepEnter", i), this.isTriggerOnce && (this.exclude[r] = !0);
  }
  _notifyStepExit(e) {
    const r = this.getIndex(e), n = this.steps[r];
    if (!n.state) return !1;
    const i = { element: e, index: r, direction: this.direction, actions: n.actions };
    return this.isProgress && (this.direction === "down" && n.progress < 1 ? this._notifyProgress(e, 1) : this.direction === "up" && n.progress > 0 && this._notifyProgress(e, 0)), n.direction = this.direction, n.state = "exit", this.emit("stepExit", i), !0;
  }
  _handleScroll() {
    const e = this.containerElement ? this.containerElement.scrollTop : window.pageYOffset;
    this.currentScrollY !== e && (this.currentScrollY = e, this.currentScrollY > this.comparisonScrollY ? this.direction = "down" : this.currentScrollY < this.comparisonScrollY && (this.direction = "up"), this.comparisonScrollY = this.currentScrollY);
  }
  _setupScrollListener() {
    document.removeEventListener("scroll", this._handleScroll), document.addEventListener("scroll", this._handleScroll, { passive: !0 });
  }
  _resizeStep(e) {
    if (e.length === 0) return;
    const r = e[0], n = this.getIndex(r.target), i = this.steps[n], s = r.target.offsetHeight;
    s !== i.height && (i.height = s, this._disconnectObserver(i.observers), this._updateResizeObserver(i), this._updateStepObserver(i), this.isProgress && this._updateProgressObserver(i));
  }
  _intersectStep(e) {
    if (e.length === 0) return;
    const r = e[0];
    this._handleScroll();
    const { isIntersecting: n, target: i } = r;
    n ? this._notifyStepEnter(i) : this._notifyStepExit(i);
  }
  _intersectProgress(e) {
    if (e.length === 0) return;
    const r = e[0], n = this.getIndex(r.target), i = this.steps[n], { isIntersecting: s, intersectionRatio: o, target: a } = r;
    s && i.state === "enter" && this._notifyProgress(a, o);
  }
  _updateResizeObserver(e) {
    const r = new ResizeObserver(this._resizeStep);
    r.observe(e.node), e.observers.resize = r;
  }
  _updateResizeObservers() {
    this.steps.forEach((e) => this._updateResizeObserver(e));
  }
  _updateStepObserver(e) {
    const r = window.innerHeight, n = e.offset || this.globalOffset, i = n.format === "pixels" ? 1 : r, s = n.value * i, o = e.height / 2 - s, a = e.height / 2 - (r - s), l = `${o}px 0px ${a}px 0px`, c = this.rootElement, h = { rootMargin: l, threshold: 0.5, root: c }, d = new IntersectionObserver(this._intersectStep, h);
    d.observe(e.node), e.observers.step = d;
  }
  _updateStepObservers() {
    this.steps.forEach((e) => this._updateStepObserver(e));
  }
  _updateProgressObserver(e) {
    const r = window.innerHeight, n = e.offset || this.globalOffset, i = n.format === "pixels" ? 1 : r, s = n.value * i, o = -s + e.height, a = s - r, l = `${o}px 0px ${a}px 0px`, c = this.createProgressThreshold(e.height, this.progressThreshold), p = { rootMargin: l, threshold: c }, h = new IntersectionObserver(this._intersectProgress, p);
    h.observe(e.node), e.observers.progress = h;
  }
  _updateProgressObservers() {
    this.steps.forEach((e) => this._updateProgressObserver(e));
  }
  _updateObservers() {
    this._disconnectObservers(), this._updateResizeObservers(), this._updateStepObservers(), this.isProgress && this._updateProgressObservers();
  }
  setup({
    step: e,
    parent: r,
    offset: n = 0.5,
    threshold: i = 4,
    progress: s = !1,
    once: o = !1,
    container: a = void 0,
    root: l = null
  }) {
    this._setupScrollListener();
    const c = typeof e == "string" && r && document.querySelector(r) || document;
    return this.steps = this.getChartSteps(e, c).map((p, h) => ({
      index: h,
      direction: void 0,
      height: p.offsetHeight,
      node: p,
      observers: {},
      offset: this.parseOffset(p.dataset.offset),
      actions: this.getActions(p),
      top: this.getOffsetTop(p),
      progress: 0,
      state: void 0
    })), this.steps.length ? (this.isProgress = s, this.isTriggerOnce = o, this.progressThreshold = Math.max(1, +i), this.globalOffset = this.parseOffset(n), this.containerElement = a, this.rootElement = l, this.off(), this._resetExclusions(), this.indexSteps(this.steps), this._handleEnable(!0), this) : (this.log.info("scrollytelling: no step elements found"), this);
  }
  enable() {
    return this._handleEnable(!0), this;
  }
  disable() {
    return this._handleEnable(!1), this;
  }
  destroy() {
    return this._handleEnable(!1), this.off(), this._resetExclusions(), document.removeEventListener("scroll", this._handleScroll), this;
  }
  resize() {
    return this._updateObservers(), this;
  }
  get offset() {
    return this.globalOffset.value;
  }
  set offset(e) {
    this.globalOffset = this.parseOffset(e), this._updateObservers();
  }
}
class nCe {
  constructor() {
    this.log = qt("SlotLoader");
  }
  canLoadData(e) {
    return e.length !== 0 && e[0].tagName === "TABLE";
  }
  async findManifest(e, r, n) {
    if (r && (this.log.info(`Loading from manifest ID: ${r}`), document.getElementById(r)))
      if (document.getElementById(r).hasAttribute("src")) {
        const s = await (await fetch(document.getElementById(r).getAttribute("src"))).json();
        return n && (s.datasets[0].description = n, this.log.info("manifest description changed")), { result: "success", manifest: s };
      } else {
        let i = JSON.parse(document.getElementById(r).innerHTML);
        return { result: "success", manifest: this.validateManifest(e, i, n).manifest };
      }
    if (document.getElementsByClassName("manifest").length > 0) {
      let i = JSON.parse(document.getElementsByClassName("manifest")[0].innerHTML);
      return { result: "success", manifest: this.validateManifest(e, i, n).manifest };
    } else {
      this.log.info("Manifest ID not found or not present, attempting manifest construction from data");
      let i = {
        datasets: [{
          type: "",
          //chartTheme: {baseQuantity: 'Y unit', baseKind: 'number'}, 
          title: "",
          facets: {},
          series: [],
          data: { source: "inline" }
        }]
      };
      return { result: "success", manifest: this.validateManifest(e, i, n).manifest };
    }
  }
  validateManifest(e, r, n) {
    document.getElementsByTagName("para-chart")[0];
    const i = e[0], s = r.datasets[0];
    s.title || (s.title = this.findManifestTitle(i)), (!s.facets || !s.facets.keys) && (s.facets = this.loadFacets(i.rows[0]));
    const o = this.loadHeaders(i.rows[0]);
    if (!s.series || s.series.length === 0) {
      s.series = [];
      for (let l = 1; l < o.length; l++) {
        const c = {
          key: o[l].label,
          /*theme: { 
            baseQuantity: '',
            baseKind: 'number',
            entity: vars[i].label 
          },*/
          records: this.loadDataFromElement(e, r, o[l].label)
        };
        s.series.push(c);
      }
    }
    for (let l = 1; l < o.length; l++)
      r.datasets[0].series[0].records.length === 0 && (s.series[l].records = this.loadDataFromElement(e, r, o[l].label));
    s.type || (s.type = this.findManifestType(e, r)), s.data || (s.data = { source: "inline" }), s.settings || (s.settings = { "sonification.isEnabled": !0 });
    const a = o.map((l) => []);
    Array.from(i.rows).slice(1).forEach((l) => {
      this.loadRow(l, o).forEach((p, h) => {
        a[h].push(p);
      });
    });
    for (let l = 0; l < 2; l++) {
      let c = s.facets[Object.keys(s.facets)[l]];
      /%/.test(a[l][0]) && (c.measure = "ratio"), /\b(year|month|day)\b/i.test(o[l].label) ? c.datatype = "date" : isNaN(Number(a[l][0].replace("%", ""))) ? c.datatype = "string" : c.datatype = "number";
    }
    return n && (r.datasets[0].description = n, this.log.info("manifest description changed")), { result: "success", manifest: r };
  }
  loadDataFromElement(e, r, n) {
    if (!e.length || e[0].tagName !== "TABLE")
      throw this.log.info(e), new Error("'table' element must be provided");
    const i = e[0];
    let s = this.loadHeaders(i.rows[0]), o;
    n && (o = s.filter((p) => p.label == n)[0]);
    let a = s.indexOf(o);
    a == -1 && (a = 1);
    const l = s.map((p) => []);
    Array.from(i.rows).slice(1).forEach((p) => {
      this.loadRow(p, s).forEach((d, b) => {
        l[b].push(d);
      });
    });
    let c = [];
    for (let p = 0; p < l[0].length; p++)
      c.push({ x: l[0][p], y: l[a][p] });
    return c;
  }
  loadHeaders(e) {
    var s;
    const r = document.getElementsByTagName("para-chart")[0];
    if (!e)
      throw new Error("table must include a header row");
    const n = [];
    let i = 0;
    for (const o of e.children) {
      if (o.tagName !== "TD" && o.tagName !== "TH")
        throw new Error("immediate children of 'tr' element must be 'td' or 'th' elements");
      const a = ((s = o.textContent) == null ? void 0 : s.trim()) ?? "";
      if (!a)
        throw new Error("var name must be provided as 'td' element text content");
      let l = o.dataset.type ?? "string";
      if (!["string", "number", "date"].includes(l))
        throw new Error("var type must be provided as 'td' element 'data-type' attribute. Must be string, number, or date");
      const c = o.dataset.independent === "true" ? "independent" : "dependent";
      let p = o.dataset.measure ?? "nominal";
      const h = r.type == "pie" || r.type == "donut", d = ["horizontal", "vertical"];
      let b;
      h ? b = o.dataset.displayType ?? { type: "marking" } : b = o.dataset.displayType ?? { type: "axis", orientation: d[i] }, n.push({
        label: a,
        datatype: l,
        variableType: c,
        measure: p,
        displayType: b
      }), i++;
    }
    return n;
  }
  loadFacets(e) {
    let r = this.loadHeaders(e);
    if (r.length < 2)
      throw new Error("Error: please provide at least two variables");
    if (r.length === 2) {
      let o = { x: r[0], y: r[1] };
      return o.x.variableType = "independent", ["Year", "year", "Years", "years"].includes(o.x.label) ? o.x.units = "year" : o.x.units || (o.x.units = "point"), o;
    }
    let n;
    for (let o of r)
      if (o.variableType == "independent") {
        n = o;
        break;
      }
    n === void 0 && (n = r[0]);
    let i = "";
    for (let o of r.toSpliced(r.indexOf(n), 1)) {
      if (i.concat(o.label, " ").length > 50) {
        i = i.concat("...");
        break;
      }
      i = i.concat(o.label, ", ");
    }
    let s = { x: r[0], y: r[1] };
    return s.x.variableType = "independent", s.y.label = i, ["Year", "year", "Years", "years"].includes(s.x.label) ? s.x.units = "year" : s.x.units || (s.x.units = "point"), s;
  }
  loadRow(e, r) {
    if (!e || e.tagName !== "TR")
      throw new Error("immediate children of 'table' element must be 'tr' elements");
    const n = r.map((i) => "");
    return Array.from(e.children).forEach((i, s) => {
      if (i.tagName !== "TD")
        throw new Error("immediate children of 'tr' element must be 'td' elements");
      const o = i.textContent;
      if (!o)
        throw new Error("var value must be provided as 'td' element text content");
      n[s] = o;
    }), n;
  }
  findManifestTitle(e) {
    for (const r of e.children)
      if (r.nodeName === "CAPTION")
        return r.innerHTML;
    return e.hasAttribute("aria-label") ? e.getAttribute("aria-label") : e.hasAttribute("title") ? e.getAttribute("title") : `'${this.loadHeaders(e.rows[0])[0].label}' vs '${this.loadHeaders(e.rows[0])[1].label}'`;
  }
  findManifestType(e, r) {
    if (document.getElementsByTagName("para-chart")[0].hasAttribute("type"))
      return document.getElementsByTagName("para-chart")[0].getAttribute("type");
    throw new Error("Error: please provide a type for the para-chart");
  }
}
var iCe = Object.defineProperty, sCe = Object.getOwnPropertyDescriptor, QU = (t) => {
  throw TypeError(t);
}, ca = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? sCe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && iCe(e, r, i), i;
}, KU = (t, e, r) => e.has(t) || QU("Cannot " + r), a1 = (t, e, r) => (KU(t, e, "read from private field"), r ? r.call(t) : e.get(t)), l1 = (t, e, r) => e.has(t) ? QU("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), c1 = (t, e, r, n) => (KU(t, e, "write to private field"), e.set(t, r), r), K1, Y1, Z1, J1;
const q9 = class q9 extends ts {
  constructor(e, r) {
    super(), this.headless = !1, l1(this, K1, ""), this.manifestType = "url", this.data = "", l1(this, Y1, {}), l1(this, Z1), l1(this, J1), this.isControlPanelOpen = !1, this._paraViewRef = Et(), this._controlPanelRef = Et(), this._ariaLiveRegionRef = Et(), this._loader = new K_e(), this._slotLoader = new nCe(), this.log = qt("ParaChart"), this._loaderPromise = null, this._loaderResolver = null, this._loaderRejector = null;
    const n = new Y_e(), i = n.processProperties();
    this.store = new Cr(
      this,
      // XXX config won't get set until connectedCallback()
      Object.assign(i, this.config),
      // this._suppleteSettingsWith,
      e,
      r
    ), this.captionBox = document.createElement("para-caption-box"), this.captionBox.store = this._store, this.captionBox.parachart = this, n.store = this.store, n.registerColors(), n.registerSymbols(), this._loaderPromise = new Promise((s, o) => {
      this._loaderResolver = s, this._loaderRejector = o;
    }), this._readyPromise = new Promise((s) => {
      this.addEventListener("paraviewready", async () => {
        if (s(), await X3e(), this.manifest)
          this.data && await this._loader.preloadData(this.data), this._runLoader(this.manifest, this.manifestType).then(() => {
            this.log.info("ParaCharts fully initialized"), this._scrollyteller = new rCe(this);
          });
        else if (this.getElementsByTagName("table")[0]) {
          this.log.info("loading from slot");
          const o = this.getElementsByTagName("table")[0], a = this.getElementsByClassName("manifest")[0];
          if (this._store.dataState = "pending", o) {
            const l = await this._slotLoader.findManifest(
              [o, a],
              "some-manifest",
              this.description
            );
            this.log.info("loaded manifest"), l.result === "success" ? (this.store.setManifest(l.manifest), this._store.dataState = "complete") : this._store.dataState = "error";
          }
        } else
          this.log.info("No datatable in slot"), this._store.dataState = "error";
      });
    });
  }
  get manifest() {
    return a1(this, K1);
  }
  set manifest(e) {
    c1(this, K1, e);
  }
  get config() {
    return a1(this, Y1);
  }
  set config(e) {
    c1(this, Y1, e);
  }
  get forcecharttype() {
    return a1(this, Z1);
  }
  set forcecharttype(e) {
    c1(this, Z1, e);
  }
  get description() {
    return a1(this, J1);
  }
  set description(e) {
    c1(this, J1, e);
  }
  get paraView() {
    return this._paraViewRef.value;
  }
  get controlPanel() {
    return this._controlPanelRef.value;
  }
  get ready() {
    return this._readyPromise;
  }
  get loaded() {
    return this._loaderPromise;
  }
  get loader() {
    return this._loader;
  }
  get ariaLiveRegion() {
    return this._ariaLiveRegionRef.value;
  }
  get slotted() {
    return this._slotted;
  }
  get styleManager() {
    return this._styleManager;
  }
  get api() {
    return this._paraAPI;
  }
  get scrollyteller() {
    return this._scrollyteller;
  }
  connectedCallback() {
    super.connectedCallback(), this.isControlPanelOpen = this._store.settings.controlPanel.isControlPanelDefaultOpen, this._styleManager = new J_e(this.shadowRoot.adoptedStyleSheets[0]), this._styleManager.set(":host", {
      "--axis-line-color": "hsl(0, 0%, 0%)",
      "--label-color": "hsl(0, 0%, 0%)",
      "--tick-grid-color": "hsl(270, 50%, 50%)",
      "--background-color": "white",
      "--theme-color": "var(--fizz-theme-color, purple)",
      "--theme-color-light": "var(--fizz-theme-color-light, hsl(275.4, 100%, 88%))",
      "--theme-contrast-color": "white",
      "--fizz-theme-color": "var(--paracharts-theme-color, navy)",
      "--fizz-theme-color-light": "var(--paracharts-theme-color-light, hsl(210.5, 100%, 88%))",
      "--visited-color": () => this._store.colors.colorValue("visit"),
      "--highlighted-color": () => this._store.colors.colorValue("highlight"),
      "--visited-stroke-width": () => {
        var e, r;
        return ((r = (e = this._paraViewRef.value) == null ? void 0 : e.documentView) == null ? void 0 : r.chartLayers.dataLayer.visitedStrokeWidth) ?? 0;
      },
      "--selected-color": "var(--label-color)",
      "--datapoint-centroid": "50% 50%",
      "--focus-animation": "all 0.5s ease-in-out",
      "--chart-cursor": "pointer",
      "--data-cursor": "cell",
      "--focus-shadow-color": "gray",
      "--focus-shadow": "drop-shadow(0px 0px 4px var(--focus-shadow-color))",
      "--caption-border": () => this._store.settings.controlPanel.caption.hasBorder ? "solid 2px var(--theme-color)" : "none",
      "--caption-grid-template-columns": () => this._store.settings.controlPanel.isExplorationBarVisible && this._store.settings.controlPanel.isCaptionVisible && this._store.settings.controlPanel.caption.isExplorationBarBeside ? "2fr 1fr" : "1fr",
      "--exploration-bar-display": () => this._store.settings.controlPanel.isExplorationBarVisible ? "flex" : "none",
      "--chart-font-scale": () => this._store.settings.chart.fontScale,
      "--chart-title-font-size": () => this._store.settings.chart.title.fontSize,
      "--horiz-axis-title-font-size": () => this._store.settings.axis.horiz.title.fontSize,
      "--vert-axis-title-font-size": () => this._store.settings.axis.vert.title.fontSize,
      "--horiz-axis-tick-label-font-size": () => this._store.settings.axis.horiz.ticks.labels.fontSize,
      "--vert-axis-tick-label-font-size": () => this._store.settings.axis.vert.ticks.labels.fontSize,
      "--direct-label-font-size": () => this._store.settings.chart.directLabelFontSize,
      "--legend-label-font-size": () => this._store.settings.legend.fontSize,
      "--bar-label-font-size": () => this._store.settings.type.bar.labelFontSize,
      "--column-label-font-size": () => this._store.settings.type.column.labelFontSize,
      display: "block",
      "font-family": '"Trebuchet MS", Helvetica, sans-serif',
      "font-size": "var(--chart-view-font-size, 1rem)"
    }), this._store.settings.chart.isShowVisitedDatapointsOnly && (this._styleManager.set(".datapoint:not(.visited)", {
      display: "none"
    }), this._styleManager.set(".leg-right", {
      display: "none"
    })), this._styleManager.update();
  }
  firstUpdated(e) {
    this._commander = Pp.getInst(this._paraViewRef.value);
  }
  willUpdate(e) {
    e.has("manifest") && this.manifest !== "" && this._paraViewRef.value && (this.log.info(`manifest changed: '${this.manifestType === "content" ? "<content>" : this.manifest}`), this._loaderPromise = this._runLoader(this.manifest, this.manifestType), this.dispatchEvent(new CustomEvent("manifestchange", { bubbles: !0, composed: !0, cancelable: !0 }))), e.has("config") && Object.entries(this.config).forEach(([r, n]) => this._store.updateSettings((i) => {
      br.set(r, n, i);
    }));
  }
  async _runLoader(e, r) {
    var i;
    this.log.info(`loading manifest: '${r === "content" ? "<content>" : e}'`), this._store.dataState = "pending";
    const n = await this._loader.load(
      this.manifestType,
      e,
      this.forcecharttype,
      this.description
    );
    this.log.info("loaded manifest"), n.result === "success" ? (this._manifest = n.manifest, this._store.setManifest(n.manifest, n.data), this._store.dataState = "complete", (i = this._controlPanelRef.value) == null || i.descriptionPanel.positionCaptionBox(), this._paraAPI = new X_e(this), this._loaderResolver()) : (this.log.error(n.error), this._store.dataState = "error", this._loaderRejector());
  }
  settingDidChange(e, r, n) {
    var i;
    this.log.info("setting did change:", e, "=", n, `(was ${r})`), this._styleManager.update(), (i = this._paraViewRef.value) == null || i.settingDidChange(e, r, n), this._styleManager.update();
  }
  postNotice(e, r) {
    this.paraView && (this.paraView.documentView.noticePosted(e, r), this.paraView.documentView.chartInfo.noticePosted(e, r), this.captionBox.noticePosted(e, r), this.dispatchEvent(
      new CustomEvent("paranotice", { detail: { key: e, value: r }, bubbles: !0, composed: !0 })
    ));
  }
  clearAriaLive() {
    this._ariaLiveRegionRef.value.clear();
  }
  showAriaLiveHistory() {
    this._ariaLiveRegionRef.value.showHistoryDialog();
  }
  command(e, r) {
    const n = this._commander.commands[e];
    if (n)
      return n(...r);
    this.log.warn(`no handler for command '${e}'`);
  }
  render() {
    var r;
    const e = {
      "sr-only": this.headless
    };
    return qe`
      <figure
        class=${Br(e)}
        aria-hidden=${this.headless ? "true" : "false"}
      >
        <para-view
          ${yt(this._paraViewRef)}
          .paraChart=${this}
          .store=${this._store}
          colormode=${((r = this._store) == null ? void 0 : r.settings.color.colorVisionMode) ?? De}
          ?disableFocus=${this.headless}
        ></para-view>
        ${this.headless || this._store.settings.chart.isStatic ? "" : qe`
            <para-control-panel
              ${yt(this._controlPanelRef)}
              .paraChart=${this}
              .store=${this._store}
            ></para-control-panel>`}
        <para-aria-live-region
          ${yt(this._ariaLiveRegionRef)}
          .store=${this._store}
          .announcement=${this._store.announcement}
        ></para-aria-live-region>
        <slot
          @slotchange=${(n) => {
    }}
        ></slot>
      </figure>
    `;
  }
};
q9.styles = [
  k5,
  Nt`
      :host {
        --summary-marker-size: 1.1rem;
      }
      figure {
        display: inline grid;
        margin: 0;
      }
    `
];
let es = q9;
K1 = /* @__PURE__ */ new WeakMap();
Y1 = /* @__PURE__ */ new WeakMap();
Z1 = /* @__PURE__ */ new WeakMap();
J1 = /* @__PURE__ */ new WeakMap();
ca([
  Ke({ type: Boolean })
], es.prototype, "headless", 2);
ca([
  Ke()
], es.prototype, "manifest", 1);
ca([
  Ke()
], es.prototype, "manifestType", 2);
ca([
  Ke()
], es.prototype, "data", 2);
ca([
  Ke({ type: Object })
], es.prototype, "config", 1);
ca([
  Ke()
], es.prototype, "forcecharttype", 1);
ca([
  Ke()
], es.prototype, "type", 2);
ca([
  Ke()
], es.prototype, "description", 1);
ca([
  Ke({ type: Boolean, attribute: !1 })
], es.prototype, "isControlPanelOpen", 2);
ca([
  Cg({ flatten: !0 })
], es.prototype, "_slotted", 2);
const Q9 = class Q9 extends es {
  constructor() {
    super(LG, Uie), this.log = qt("ParaChartAi"), this.log.info("AI-enhanced ParaChart created");
  }
};
Q9.styles = [
  k5,
  Nt`
      :host {
      --control-panel-icon: url(${Ju(qU)});
        --summary-marker-size: 1.1rem;
      }
      figure {
        display: inline-block;
        margin: 0;
      }
    `
];
let wE = Q9;
class aPe {
  constructor() {
    this._createParaChart(), this._paraChart.store.updateSettings((e) => {
      e.animation.isAnimationEnabled = !1;
    });
  }
  get ready() {
    return this._paraChart.ready;
  }
  _createParaChart() {
    this._paraChart = document.createElement("para-chart"), this._paraChart.setAttribute("headless", ""), document.body.append(this._paraChart);
  }
  loadData(e) {
    return this._paraChart.loader.preloadData(e);
  }
  loadManifest(e, r = "url") {
    return this._paraChart.manifest = e, this._paraChart.manifestType = r, new Promise((n) => {
      this._paraChart.addEventListener("manifestchange", async () => {
        await this._paraChart.loaded, n();
      }, { once: !0 });
    });
  }
  get jimReady() {
    return this._paraChart.paraView.jimReady();
  }
  get api() {
    return this._paraChart.api;
  }
}
customElements.define("para-chart", wE);
export {
  R2 as AdvancedControlSettingsDialog,
  dE as AnalysisPanel,
  O2 as AnimationDialog,
  _R as AnnotationLayer,
  fE as AnnotationPanel,
  Cy as AriaLive,
  x0 as AriaLiveHistoryDialog,
  gE as AudioPanel,
  NU as Axis,
  Yv as AxisInfo,
  PU as AxisLine,
  OU as AxisRule,
  k9e as Bar,
  i1 as BarPlotView,
  iE as Bezier,
  yR as ButtonSettingControl,
  p8e as ChartLandingView,
  mE as ChartPanel,
  sPe as ChartTooDenseError,
  oPe as ChartTooWideError,
  fR as CheckboxSettingControl,
  T9e as ClusterShellView,
  eU as Colors,
  yE as ColorsPanel,
  xn as ControlPanelTabPanel,
  bE as ControlsPanel,
  yU as DataLayer,
  D2 as DataPanel,
  tU as DataView,
  pf as DatapointView,
  rg as DescriptionPanel,
  dR as DropdownSettingControl,
  ZSe as FORMAT_CONTEXT_SETTINGS,
  j9e as FocusLayer,
  Q4 as HERTZ,
  L9e as HeatMapPlotView,
  M9e as HeatmapTile,
  RR as HeatmapTileView,
  TR as HighlightsLayer,
  N9e as Histogram,
  OR as HistogramBinView,
  h7e as HorizAxis,
  t7e as HorizAxisLine,
  a7e as HorizGridLine,
  TU as HorizRule,
  s7e as HorizTick,
  n7e as HorizTickLabelTier,
  c7e as HorizTickStrip,
  J8e as HotkeyEvent,
  X8e as KeymapManager,
  tx as LinePlotView,
  _9e as LineSection,
  Hie as LogLevel,
  Gie as Logger,
  w2 as NavLayer,
  R9 as NavMap,
  Ia as NavNode,
  vAe as OscillatorAudioEngine,
  wE as ParaChartAi,
  ts as ParaComponent,
  ng as ParaControlPanel,
  uh as ParaDialog,
  aPe as ParaHeadless,
  Cr as ParaStore,
  Xi as ParaView,
  gAe as ParaViewController,
  C9e as PastryPlotView,
  jo as PathShape,
  IR as PiePlotView,
  P9e as PieSlice,
  bU as PlaneDatapointView,
  Zv as PlanePlotView,
  Jv as PlaneSeriesView,
  df as PlotLayer,
  V9e as PlotLayerManager,
  Xv as PointDatapointView,
  vU as PointPlotView,
  x9e as PointSeriesView,
  I9e as RadialSlice,
  gR as RadioSettingControl,
  sn as RectShape,
  Ip as SVGNS,
  R9e as ScatterPlotView,
  PR as ScatterTrendLineView,
  w0 as ScreenReaderBridge,
  rCe as Scrollyteller,
  x2 as SectorShape,
  D9e as SelectionLayer,
  x8e as SeriesProperties,
  hR as SeriesPropertyManager,
  I9 as SeriesView,
  Ys as SettingControl,
  XV as SettingControlManager,
  br as SettingsManager,
  Wv as Shape,
  mR as SliderSettingControl,
  P2 as SoniSettingsDialog,
  pR as TextfieldSettingControl,
  RU as TickLabelTier,
  MU as TickStrip,
  E9e as TrendLineView,
  Ye as Vec2,
  p7e as VertAxis,
  r7e as VertAxisLine,
  l7e as VertGridLine,
  LU as VertRule,
  o7e as VertTick,
  i7e as VertTickLabelTier,
  u7e as VertTickStrip,
  K4 as bboxOfBboxes,
  l8e as bboxOppositeAnchor,
  KIe as capitalize,
  z9e as chartClasses,
  uR as chartTypeDefaults,
  k2 as computeLabels,
  rn as datapointIdToCursor,
  JIe as datapointMatchKeyAndIndex,
  i8e as defaults,
  YSe as directions,
  YIe as exhaustive,
  nt as fixed,
  a8e as generateUniqueId,
  qt as getLogger,
  ZIe as groupBbox,
  c8e as isPointerInbounds,
  Y4 as loopParaviewRefresh,
  eIe as setLogLevel,
  o8e as toFixed
};
