var KV = Object.defineProperty;
var YV = (t, e, r) => e in t ? KV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var rr = (t, e, r) => YV(t, typeof e != "symbol" ? e + "" : e, r);
window.process = {
  env: {
    NODE_ENV: "production"
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const h1 = globalThis, wE = h1.ShadowRoot && (h1.ShadyCSS === void 0 || h1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, xE = Symbol(), Wk = /* @__PURE__ */ new WeakMap();
let CO = class {
  constructor(e, r, n) {
    if (this._$cssResult$ = !0, n !== xE) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = r;
  }
  get styleSheet() {
    let e = this.o;
    const r = this.t;
    if (wE && e === void 0) {
      const n = r !== void 0 && r.length === 1;
      n && (e = Wk.get(r)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), n && Wk.set(r, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const Zu = (t) => new CO(typeof t == "string" ? t : t + "", void 0, xE), Nt = (t, ...e) => {
  const r = t.length === 1 ? t[0] : e.reduce((n, i, s) => n + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + t[s + 1], t[0]);
  return new CO(r, t, xE);
}, ZV = (t, e) => {
  if (wE) t.adoptedStyleSheets = e.map((r) => r instanceof CSSStyleSheet ? r : r.styleSheet);
  else for (const r of e) {
    const n = document.createElement("style"), i = h1.litNonce;
    i !== void 0 && n.setAttribute("nonce", i), n.textContent = r.cssText, t.appendChild(n);
  }
}, qk = wE ? (t) => t : (t) => t instanceof CSSStyleSheet ? ((e) => {
  let r = "";
  for (const n of e.cssRules) r += n.cssText;
  return Zu(r);
})(t) : t;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: JV, defineProperty: XV, getOwnPropertyDescriptor: eH, getOwnPropertyNames: tH, getOwnPropertySymbols: rH, getPrototypeOf: nH } = Object, Nl = globalThis, Qk = Nl.trustedTypes, iH = Qk ? Qk.emptyScript : "", rw = Nl.reactiveElementPolyfillSupport, Ff = (t, e) => t, X1 = { toAttribute(t, e) {
  switch (e) {
    case Boolean:
      t = t ? iH : null;
      break;
    case Object:
    case Array:
      t = t == null ? t : JSON.stringify(t);
  }
  return t;
}, fromAttribute(t, e) {
  let r = t;
  switch (e) {
    case Boolean:
      r = t !== null;
      break;
    case Number:
      r = t === null ? null : Number(t);
      break;
    case Object:
    case Array:
      try {
        r = JSON.parse(t);
      } catch {
        r = null;
      }
  }
  return r;
} }, EE = (t, e) => !JV(t, e), Kk = { attribute: !0, type: String, converter: X1, reflect: !1, useDefault: !1, hasChanged: EE };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Nl.litPropertyMetadata ?? (Nl.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let wp = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, r = Kk) {
    if (r.state && (r.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(e) && ((r = Object.create(r)).wrapped = !0), this.elementProperties.set(e, r), !r.noAccessor) {
      const n = Symbol(), i = this.getPropertyDescriptor(e, n, r);
      i !== void 0 && XV(this.prototype, e, i);
    }
  }
  static getPropertyDescriptor(e, r, n) {
    const { get: i, set: s } = eH(this.prototype, e) ?? { get() {
      return this[r];
    }, set(o) {
      this[r] = o;
    } };
    return { get: i, set(o) {
      const a = i == null ? void 0 : i.call(this);
      s == null || s.call(this, o), this.requestUpdate(e, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? Kk;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Ff("elementProperties"))) return;
    const e = nH(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Ff("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(Ff("properties"))) {
      const r = this.properties, n = [...tH(r), ...rH(r)];
      for (const i of n) this.createProperty(i, r[i]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const r = litPropertyMetadata.get(e);
      if (r !== void 0) for (const [n, i] of r) this.elementProperties.set(n, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [r, n] of this.elementProperties) {
      const i = this._$Eu(r, n);
      i !== void 0 && this._$Eh.set(i, r);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const r = [];
    if (Array.isArray(e)) {
      const n = new Set(e.flat(1 / 0).reverse());
      for (const i of n) r.unshift(qk(i));
    } else e !== void 0 && r.push(qk(e));
    return r;
  }
  static _$Eu(e, r) {
    const n = r.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$ES = new Promise((r) => this.enableUpdating = r), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((r) => r(this));
  }
  addController(e) {
    var r;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((r = e.hostConnected) == null || r.call(e));
  }
  removeController(e) {
    var r;
    (r = this._$EO) == null || r.delete(e);
  }
  _$E_() {
    const e = /* @__PURE__ */ new Map(), r = this.constructor.elementProperties;
    for (const n of r.keys()) this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return ZV(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$EO) == null || e.forEach((r) => {
      var n;
      return (n = r.hostConnected) == null ? void 0 : n.call(r);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null || e.forEach((r) => {
      var n;
      return (n = r.hostDisconnected) == null ? void 0 : n.call(r);
    });
  }
  attributeChangedCallback(e, r, n) {
    this._$AK(e, n);
  }
  _$ET(e, r) {
    var s;
    const n = this.constructor.elementProperties.get(e), i = this.constructor._$Eu(e, n);
    if (i !== void 0 && n.reflect === !0) {
      const o = (((s = n.converter) == null ? void 0 : s.toAttribute) !== void 0 ? n.converter : X1).toAttribute(r, n.type);
      this._$Em = e, o == null ? this.removeAttribute(i) : this.setAttribute(i, o), this._$Em = null;
    }
  }
  _$AK(e, r) {
    var s, o;
    const n = this.constructor, i = n._$Eh.get(e);
    if (i !== void 0 && this._$Em !== i) {
      const a = n.getPropertyOptions(i), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((s = a.converter) == null ? void 0 : s.fromAttribute) !== void 0 ? a.converter : X1;
      this._$Em = i, this[i] = l.fromAttribute(r, a.type) ?? ((o = this._$Ej) == null ? void 0 : o.get(i)) ?? null, this._$Em = null;
    }
  }
  requestUpdate(e, r, n) {
    var i;
    if (e !== void 0) {
      const s = this.constructor, o = this[e];
      if (n ?? (n = s.getPropertyOptions(e)), !((n.hasChanged ?? EE)(o, r) || n.useDefault && n.reflect && o === ((i = this._$Ej) == null ? void 0 : i.get(e)) && !this.hasAttribute(s._$Eu(e, n)))) return;
      this.C(e, r, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(e, r, { useDefault: n, reflect: i, wrapped: s }, o) {
    n && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(e) && (this._$Ej.set(e, o ?? r ?? this[e]), s !== !0 || o !== void 0) || (this._$AL.has(e) || (this.hasUpdated || n || (r = void 0), this._$AL.set(e, r)), i === !0 && this._$Em !== e && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(e));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (r) {
      Promise.reject(r);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var n;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep) this[s] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [s, o] of i) {
        const { wrapped: a } = o, l = this[s];
        a !== !0 || this._$AL.has(s) || l === void 0 || this.C(s, void 0, o, l);
      }
    }
    let e = !1;
    const r = this._$AL;
    try {
      e = this.shouldUpdate(r), e ? (this.willUpdate(r), (n = this._$EO) == null || n.forEach((i) => {
        var s;
        return (s = i.hostUpdate) == null ? void 0 : s.call(i);
      }), this.update(r)) : this._$EM();
    } catch (i) {
      throw e = !1, this._$EM(), i;
    }
    e && this._$AE(r);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var r;
    (r = this._$EO) == null || r.forEach((n) => {
      var i;
      return (i = n.hostUpdated) == null ? void 0 : i.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((r) => this._$ET(r, this[r]))), this._$EM();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
};
wp.elementStyles = [], wp.shadowRootOptions = { mode: "open" }, wp[Ff("elementProperties")] = /* @__PURE__ */ new Map(), wp[Ff("finalized")] = /* @__PURE__ */ new Map(), rw == null || rw({ ReactiveElement: wp }), (Nl.reactiveElementVersions ?? (Nl.reactiveElementVersions = [])).push("2.1.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const zf = globalThis, ey = zf.trustedTypes, Yk = ey ? ey.createPolicy("lit-html", { createHTML: (t) => t }) : void 0, IO = "$lit$", Al = `lit$${Math.random().toFixed(9).slice(2)}$`, PO = "?" + Al, sH = `<${PO}>`, Ju = document, o0 = () => Ju.createComment(""), a0 = (t) => t === null || typeof t != "object" && typeof t != "function", SE = Array.isArray, oH = (t) => SE(t) || typeof (t == null ? void 0 : t[Symbol.iterator]) == "function", nw = `[ 	
\f\r]`, df = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Zk = /-->/g, Jk = />/g, gu = RegExp(`>|${nw}(?:([^\\s"'>=/]+)(${nw}*=${nw}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Xk = /'/g, e9 = /"/g, RO = /^(?:script|style|textarea|title)$/i, OO = (t) => (e, ...r) => ({ _$litType$: t, strings: e, values: r }), We = OO(1), Tt = OO(2), Ra = Symbol.for("lit-noChange"), Ne = Symbol.for("lit-nothing"), t9 = /* @__PURE__ */ new WeakMap(), Mu = Ju.createTreeWalker(Ju, 129);
function TO(t, e) {
  if (!SE(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return Yk !== void 0 ? Yk.createHTML(e) : e;
}
const aH = (t, e) => {
  const r = t.length - 1, n = [];
  let i, s = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", o = df;
  for (let a = 0; a < r; a++) {
    const l = t[a];
    let c, p, h = -1, d = 0;
    for (; d < l.length && (o.lastIndex = d, p = o.exec(l), p !== null); ) d = o.lastIndex, o === df ? p[1] === "!--" ? o = Zk : p[1] !== void 0 ? o = Jk : p[2] !== void 0 ? (RO.test(p[2]) && (i = RegExp("</" + p[2], "g")), o = gu) : p[3] !== void 0 && (o = gu) : o === gu ? p[0] === ">" ? (o = i ?? df, h = -1) : p[1] === void 0 ? h = -2 : (h = o.lastIndex - p[2].length, c = p[1], o = p[3] === void 0 ? gu : p[3] === '"' ? e9 : Xk) : o === e9 || o === Xk ? o = gu : o === Zk || o === Jk ? o = df : (o = gu, i = void 0);
    const v = o === gu && t[a + 1].startsWith("/>") ? " " : "";
    s += o === df ? l + sH : h >= 0 ? (n.push(c), l.slice(0, h) + IO + l.slice(h) + Al + v) : l + Al + (h === -2 ? a : v);
  }
  return [TO(t, s + (t[r] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), n];
};
let px = class LO {
  constructor({ strings: e, _$litType$: r }, n) {
    let i;
    this.parts = [];
    let s = 0, o = 0;
    const a = e.length - 1, l = this.parts, [c, p] = aH(e, r);
    if (this.el = LO.createElement(c, n), Mu.currentNode = this.el.content, r === 2 || r === 3) {
      const h = this.el.content.firstChild;
      h.replaceWith(...h.childNodes);
    }
    for (; (i = Mu.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const h of i.getAttributeNames()) if (h.endsWith(IO)) {
          const d = p[o++], v = i.getAttribute(h).split(Al), m = /([.?@])?(.*)/.exec(d);
          l.push({ type: 1, index: s, name: m[2], strings: v, ctor: m[1] === "." ? cH : m[1] === "?" ? uH : m[1] === "@" ? hH : F2 }), i.removeAttribute(h);
        } else h.startsWith(Al) && (l.push({ type: 6, index: s }), i.removeAttribute(h));
        if (RO.test(i.tagName)) {
          const h = i.textContent.split(Al), d = h.length - 1;
          if (d > 0) {
            i.textContent = ey ? ey.emptyScript : "";
            for (let v = 0; v < d; v++) i.append(h[v], o0()), Mu.nextNode(), l.push({ type: 2, index: ++s });
            i.append(h[d], o0());
          }
        }
      } else if (i.nodeType === 8) if (i.data === PO) l.push({ type: 2, index: s });
      else {
        let h = -1;
        for (; (h = i.data.indexOf(Al, h + 1)) !== -1; ) l.push({ type: 7, index: s }), h += Al.length - 1;
      }
      s++;
    }
  }
  static createElement(e, r) {
    const n = Ju.createElement("template");
    return n.innerHTML = e, n;
  }
};
function jp(t, e, r = t, n) {
  var o, a;
  if (e === Ra) return e;
  let i = n !== void 0 ? (o = r._$Co) == null ? void 0 : o[n] : r._$Cl;
  const s = a0(e) ? void 0 : e._$litDirective$;
  return (i == null ? void 0 : i.constructor) !== s && ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1), s === void 0 ? i = void 0 : (i = new s(t), i._$AT(t, r, n)), n !== void 0 ? (r._$Co ?? (r._$Co = []))[n] = i : r._$Cl = i), i !== void 0 && (e = jp(t, i._$AS(t, e.values), i, n)), e;
}
let lH = class {
  constructor(e, r) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = r;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: r }, parts: n } = this._$AD, i = ((e == null ? void 0 : e.creationScope) ?? Ju).importNode(r, !0);
    Mu.currentNode = i;
    let s = Mu.nextNode(), o = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new AE(s, s.nextSibling, this, e) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, e) : l.type === 6 && (c = new pH(s, this, e)), this._$AV.push(c), l = n[++a];
      }
      o !== (l == null ? void 0 : l.index) && (s = Mu.nextNode(), o++);
    }
    return Mu.currentNode = Ju, i;
  }
  p(e) {
    let r = 0;
    for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(e, n, r), r += n.strings.length - 2) : n._$AI(e[r])), r++;
  }
}, AE = class MO {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, r, n, i) {
    this.type = 2, this._$AH = Ne, this._$AN = void 0, this._$AA = e, this._$AB = r, this._$AM = n, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const r = this._$AM;
    return r !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = r.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, r = this) {
    e = jp(this, e, r), a0(e) ? e === Ne || e == null || e === "" ? (this._$AH !== Ne && this._$AR(), this._$AH = Ne) : e !== this._$AH && e !== Ra && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : oH(e) ? this.k(e) : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.O(e));
  }
  _(e) {
    this._$AH !== Ne && a0(this._$AH) ? this._$AA.nextSibling.data = e : this.T(Ju.createTextNode(e)), this._$AH = e;
  }
  $(e) {
    var s;
    const { values: r, _$litType$: n } = e, i = typeof n == "number" ? this._$AC(e) : (n.el === void 0 && (n.el = px.createElement(TO(n.h, n.h[0]), this.options)), n);
    if (((s = this._$AH) == null ? void 0 : s._$AD) === i) this._$AH.p(r);
    else {
      const o = new lH(i, this), a = o.u(this.options);
      o.p(r), this.T(a), this._$AH = o;
    }
  }
  _$AC(e) {
    let r = t9.get(e.strings);
    return r === void 0 && t9.set(e.strings, r = new px(e)), r;
  }
  k(e) {
    SE(this._$AH) || (this._$AH = [], this._$AR());
    const r = this._$AH;
    let n, i = 0;
    for (const s of e) i === r.length ? r.push(n = new MO(this.O(o0()), this.O(o0()), this, this.options)) : n = r[i], n._$AI(s), i++;
    i < r.length && (this._$AR(n && n._$AB.nextSibling, i), r.length = i);
  }
  _$AR(e = this._$AA.nextSibling, r) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, r); e && e !== this._$AB; ) {
      const i = e.nextSibling;
      e.remove(), e = i;
    }
  }
  setConnected(e) {
    var r;
    this._$AM === void 0 && (this._$Cv = e, (r = this._$AP) == null || r.call(this, e));
  }
}, F2 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, r, n, i, s) {
    this.type = 1, this._$AH = Ne, this._$AN = void 0, this.element = e, this.name = r, this._$AM = i, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = Ne;
  }
  _$AI(e, r = this, n, i) {
    const s = this.strings;
    let o = !1;
    if (s === void 0) e = jp(this, e, r, 0), o = !a0(e) || e !== this._$AH && e !== Ra, o && (this._$AH = e);
    else {
      const a = e;
      let l, c;
      for (e = s[0], l = 0; l < s.length - 1; l++) c = jp(this, a[n + l], r, l), c === Ra && (c = this._$AH[l]), o || (o = !a0(c) || c !== this._$AH[l]), c === Ne ? e = Ne : e !== Ne && (e += (c ?? "") + s[l + 1]), this._$AH[l] = c;
    }
    o && !i && this.j(e);
  }
  j(e) {
    e === Ne ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}, cH = class extends F2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === Ne ? void 0 : e;
  }
}, uH = class extends F2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== Ne);
  }
}, hH = class extends F2 {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this.type = 5;
  }
  _$AI(e, r = this) {
    if ((e = jp(this, e, r, 0) ?? Ne) === Ra) return;
    const n = this._$AH, i = e === Ne && n !== Ne || e.capture !== n.capture || e.once !== n.once || e.passive !== n.passive, s = e !== Ne && (n === Ne || i);
    i && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var r;
    typeof this._$AH == "function" ? this._$AH.call(((r = this.options) == null ? void 0 : r.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}, pH = class {
  constructor(e, r, n) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = r, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    jp(this, e);
  }
};
const iw = zf.litHtmlPolyfillSupport;
iw == null || iw(px, AE), (zf.litHtmlVersions ?? (zf.litHtmlVersions = [])).push("3.3.0");
const dH = (t, e, r) => {
  const n = (r == null ? void 0 : r.renderBefore) ?? e;
  let i = n._$litPart$;
  if (i === void 0) {
    const s = (r == null ? void 0 : r.renderBefore) ?? null;
    n._$litPart$ = i = new AE(e.insertBefore(o0(), s), s, void 0, r ?? {});
  }
  return i._$AI(t), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Uu = globalThis;
let $r = class extends wp {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var r;
    const e = super.createRenderRoot();
    return (r = this.renderOptions).renderBefore ?? (r.renderBefore = e.firstChild), e;
  }
  update(e) {
    const r = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = dH(r, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return Ra;
  }
};
var _O;
$r._$litElement$ = !0, $r.finalized = !0, (_O = Uu.litElementHydrateSupport) == null || _O.call(Uu, { LitElement: $r });
const sw = Uu.litElementPolyfillSupport;
sw == null || sw({ LitElement: $r });
(Uu.litElementVersions ?? (Uu.litElementVersions = [])).push("4.2.0");
class r9 {
  /**
   * Constructor
   * @param {*} options 
   * @constructor
   */
  constructor(e) {
    this._options = e;
  }
  /**
   * Initializes the module and calls the different methods in order.
   * @private
   * @memberOf module:@fizz/svmjs
   */
  async _init() {
  }
  // data is NxD array of floats. labels are 1 or -1.
  train(e, r, n) {
    this.data = e, this.labels = r, n = n || {};
    const i = n.C || 1, s = n.tol || 1e-4, o = n.alphatol || 1e-7, a = n.maxiter || 1e4, l = n.numpasses || 10;
    let c = ow;
    if (this.kernelType = "linear", "kernel" in n)
      if (typeof n.kernel == "string") {
        if (n.kernel === "linear" && (this.kernelType = "linear", c = ow), n.kernel === "rbf") {
          const m = n.rbfsigma || 0.5;
          this.rbfSigma = m, this.kernelType = "rbf", c = n9(m);
        }
      } else
        this.kernelType = "custom", c = n.kernel;
    this.kernel = c, this.N = e.length;
    const p = this.N;
    if (this.D = e[0].length, this.D, this.alpha = gH(p), this.b = 0, this.usew_ = !1, n.memoize) {
      this.kernelResults = new Array(p);
      for (let m = 0; m < p; m++) {
        this.kernelResults[m] = new Array(p);
        for (let b = 0; b < p; b++)
          this.kernelResults[m][b] = c(e[m], e[b]);
      }
    }
    let h = 0, d = 0;
    for (; d < l && h < a; ) {
      let m = 0;
      for (let b = 0; b < p; b++) {
        const f = this.marginOne(e[b]) - r[b];
        if (r[b] * f < -s && this.alpha[b] < i || r[b] * f > s && this.alpha[b] > 0) {
          let E = b;
          for (; E === b; ) E = fH(0, this.N);
          const A = this.marginOne(e[E]) - r[E];
          let x = this.alpha[b], g = this.alpha[E], w = 0, _ = i;
          if (r[b] === r[E] ? (w = Math.max(0, x + g - i), _ = Math.min(i, x + g)) : (w = Math.max(0, g - x), _ = Math.min(i, i + g - x)), Math.abs(w - _) < 1e-4) continue;
          const S = 2 * this.kernelResult(b, E) - this.kernelResult(b, b) - this.kernelResult(E, E);
          if (S >= 0) continue;
          let R = g - r[E] * (f - A) / S;
          if (R > _ && (R = _), R < w && (R = w), Math.abs(g - R) < 1e-4) continue;
          this.alpha[E] = R;
          const L = x + r[b] * r[E] * (g - R);
          this.alpha[b] = L;
          const F = this.b - f - r[b] * (L - x) * this.kernelResult(b, b) - r[E] * (R - g) * this.kernelResult(b, E), z = this.b - A - r[b] * (L - x) * this.kernelResult(b, E) - r[E] * (R - g) * this.kernelResult(E, E);
          this.b = 0.5 * (F + z), L > 0 && L < i && (this.b = F), R > 0 && R < i && (this.b = z), m++;
        }
      }
      h++, m == 0 ? d++ : d = 0;
    }
    if (this.kernelType === "linear") {
      this.w = new Array(this.D);
      for (let m = 0; m < this.D; m++) {
        let b = 0;
        for (let f = 0; f < this.N; f++)
          b += this.alpha[f] * r[f] * e[f][m];
        this.w[m] = b, this.usew_ = !0;
      }
    } else {
      const m = [], b = [], f = [];
      for (let E = 0; E < this.N; E++)
        this.alpha[E] > o && (m.push(this.data[E]), b.push(this.labels[E]), f.push(this.alpha[E]));
      this.data = m, this.labels = b, this.alpha = f, this.N = this.data.length;
    }
    const v = {};
    return v.iters = h, v;
  }
  // inst is an array of length D. Returns margin of given example
  // this is the core prediction function. All others are for convenience mostly
  // and end up calling this one somehow.
  marginOne(e) {
    let r = this.b;
    if (this.usew_)
      for (let n = 0; n < this.D; n++)
        r += e[n] * this.w[n];
    else
      for (let n = 0; n < this.N; n++)
        r += this.alpha[n] * this.labels[n] * this.kernel(e, this.data[n]);
    return r;
  }
  predictOne(e) {
    return this.marginOne(e) > 0 ? 1 : -1;
  }
  // data is an NxD array. Returns array of margins.
  margins(e) {
    const r = e.length, n = new Array(r);
    for (let i = 0; i < r; i++)
      n[i] = this.marginOne(e[i]);
    return n;
  }
  kernelResult(e, r) {
    return this.kernelResults ? this.kernelResults[e][r] : this.kernel(this.data[e], this.data[r]);
  }
  // data is NxD array. Returns array of 1 or -1, predictions
  predict(e) {
    const r = this.margins(e);
    for (let n = 0; n < r.length; n++)
      r[n] = r[n] > 0 ? 1 : -1;
    return r;
  }
  // THIS FUNCTION IS NOW DEPRECATED. WORKS FINE BUT NO NEED TO USE ANYMORE. 
  // LEAVING IT HERE JUST FOR BACKWARDS COMPATIBILITY FOR A WHILE.
  // if we trained a linear svm, it is possible to calculate just the weights and the offset
  // prediction is then yhat = sign(X * w + b)
  getWeights() {
    const e = new Array(this.D);
    for (let r = 0; r < this.D; r++) {
      let n = 0;
      for (let i = 0; i < this.N; i++)
        n += this.alpha[i] * this.labels[i] * this.data[i][r];
      e[r] = n;
    }
    return { w: e, b: this.b };
  }
  toJSON() {
    if (this.kernelType === "custom")
      return console.log("Can't save this SVM because it's using custom, unsupported kernel..."), {};
    const e = {};
    return e.N = this.N, e.D = this.D, e.b = this.b, e.kernelType = this.kernelType, this.kernelType === "linear" && (e.w = this.w), this.kernelType === "rbf" && (e.rbfSigma = this.rbfSigma, e.data = this.data, e.labels = this.labels, e.alpha = this.alpha), e;
  }
  fromJSON(e) {
    this.N = e.N, this.D = e.D, this.b = e.b, this.kernelType = e.kernelType, this.kernelType === "linear" ? (this.w = e.w, this.usew_ = !0, this.kernel = ow) : this.kernelType == "rbf" ? (this.rbfSigma = e.rbfSigma, this.kernel = n9(this.rbfSigma), this.data = e.data, this.labels = e.labels, this.alpha = e.alpha) : console.log("ERROR! unrecognized kernel type." + this.kernelType);
  }
}
function n9(t) {
  return function(e, r) {
    let n = 0;
    for (let i = 0; i < e.length; i++)
      n += (e[i] - r[i]) * (e[i] - r[i]);
    return Math.exp(-n / (2 * t * t));
  };
}
function ow(t, e) {
  let r = 0;
  for (let n = 0; n < t.length; n++)
    r += t[n] * e[n];
  return r;
}
function fH(t, e) {
  return Math.floor(Math.random() * (e - t) + t);
}
function gH(t) {
  const e = new Array(t);
  for (let r = 0; r < t; r++)
    e[r] = 0;
  return e;
}
function kE(t) {
  var e, r, n = t.length;
  if (n === 1)
    e = 0, r = t[0][1];
  else {
    for (var i = 0, s = 0, o = 0, a = 0, l, c, p, h = 0; h < n; h++)
      l = t[h], c = l[0], p = l[1], i += c, s += p, o += c * c, a += c * p;
    e = (n * a - i * s) / (n * o - i * i), r = s / n - e * i / n;
  }
  return {
    m: e,
    b: r
  };
}
function mH(t) {
  return function(e) {
    return t.b + t.m * e;
  };
}
function yH(t) {
  if (t.length === 0)
    return 0;
  var e = t[0], r = 0, n;
  if (typeof e != "number")
    return Number.NaN;
  for (var i = 1; i < t.length; i++) {
    if (typeof t[i] != "number")
      return Number.NaN;
    n = e + t[i], Math.abs(e) >= Math.abs(t[i]) ? r += e - n + t[i] : r += t[i] - n + e, e = n;
  }
  return e + r;
}
function Wl(t) {
  if (t.length === 0)
    throw new Error("mean requires at least one data point");
  return yH(t) / t.length;
}
function vH(t, e) {
  var r = Wl(t), n = 0, i, s;
  for (s = 0; s < t.length; s++)
    i = t[s] - r, n += i * i;
  return n;
}
function bH(t, e) {
  if (t.length < 2)
    return 1;
  for (var r = 0, n = 0; n < t.length; n++)
    r += t[n][1];
  for (var i = r / t.length, s = 0, o = 0; o < t.length; o++)
    s += Math.pow(i - t[o][1], 2);
  for (var a = 0, l = 0; l < t.length; l++)
    a += Math.pow(t[l][1] - e(t[l][0]), 2);
  return 1 - a / s;
}
function wH(t) {
  if (t.length === 0)
    throw new Error("mode requires at least one data point");
  if (t.length === 1)
    return t[0];
  for (var e = t[0], r = Number.NaN, n = 0, i = 1, s = 1; s < t.length + 1; s++)
    t[s] !== e ? (i > n && (n = i, r = e), i = 1, e = t[s]) : i++;
  return r;
}
function xH(t) {
  return t.slice().sort(function(e, r) {
    return e - r;
  });
}
function EH(t) {
  return wH(xH(t));
}
function _E(t) {
  if (t.length === 0)
    throw new Error("min requires at least one data point");
  for (var e = t[0], r = 1; r < t.length; r++)
    t[r] < e && (e = t[r]);
  return e;
}
function CE(t) {
  if (t.length === 0)
    throw new Error("max requires at least one data point");
  for (var e = t[0], r = 1; r < t.length; r++)
    t[r] > e && (e = t[r]);
  return e;
}
function i9(t, e) {
  var r = t.length * e;
  if (t.length === 0)
    throw new Error("quantile requires at least one data point.");
  if (e < 0 || e > 1)
    throw new Error("quantiles must be between 0 and 1");
  return e === 1 ? t[t.length - 1] : e === 0 ? t[0] : r % 1 !== 0 ? t[Math.ceil(r) - 1] : t.length % 2 === 0 ? (t[r - 1] + t[r]) / 2 : t[r];
}
function p1(t, e, r, n) {
  for (r = r || 0, n = n || t.length - 1; n > r; ) {
    if (n - r > 600) {
      var i = n - r + 1, s = e - r + 1, o = Math.log(i), a = 0.5 * Math.exp(2 * o / 3), l = 0.5 * Math.sqrt(o * a * (i - a) / i);
      s - i / 2 < 0 && (l *= -1);
      var c = Math.max(r, Math.floor(e - s * a / i + l)), p = Math.min(
        n,
        Math.floor(e + (i - s) * a / i + l)
      );
      p1(t, e, c, p);
    }
    var h = t[e], d = r, v = n;
    for (ff(t, r, e), t[n] > h && ff(t, r, n); d < v; ) {
      for (ff(t, d, v), d++, v--; t[d] < h; )
        d++;
      for (; t[v] > h; )
        v--;
    }
    t[r] === h ? ff(t, r, v) : (v++, ff(t, v, n)), v <= e && (r = v + 1), e <= v && (n = v - 1);
  }
}
function ff(t, e, r) {
  var n = t[e];
  t[e] = t[r], t[r] = n;
}
function SH(t, e) {
  var r = t.slice();
  if (Array.isArray(e)) {
    AH(r, e);
    for (var n = [], i = 0; i < e.length; i++)
      n[i] = i9(r, e[i]);
    return n;
  } else {
    var s = DO(r.length, e);
    return NO(r, s, 0, r.length - 1), i9(r, e);
  }
}
function NO(t, e, r, n) {
  e % 1 === 0 ? p1(t, e, r, n) : (e = Math.floor(e), p1(t, e, r, n), p1(t, e + 1, e + 1, n));
}
function AH(t, e) {
  for (var r = [0], n = 0; n < e.length; n++)
    r.push(DO(t.length, e[n]));
  r.push(t.length - 1), r.sort(kH);
  for (var i = [0, r.length - 1]; i.length; ) {
    var s = Math.ceil(i.pop()), o = Math.floor(i.pop());
    if (!(s - o <= 1)) {
      var a = Math.floor((o + s) / 2);
      NO(
        t,
        r[a],
        Math.floor(r[o]),
        Math.ceil(r[s])
      ), i.push(o, a, a, s);
    }
  }
}
function kH(t, e) {
  return t - e;
}
function DO(t, e) {
  var r = t * e;
  return e === 1 ? t - 1 : e === 0 ? 0 : r % 1 !== 0 ? Math.ceil(r) - 1 : t % 2 === 0 ? r - 0.5 : r;
}
function _H(t) {
  return +SH(t, 0.5);
}
function CH(t, e) {
  if (t.length !== e.length)
    throw new Error("sampleCovariance requires samples with equal lengths");
  if (t.length < 2)
    throw new Error(
      "sampleCovariance requires at least two data points in each sample"
    );
  for (var r = Wl(t), n = Wl(e), i = 0, s = 0; s < t.length; s++)
    i += (t[s] - r) * (e[s] - n);
  var o = t.length - 1;
  return i / o;
}
function IH(t) {
  if (t.length < 2)
    throw new Error("sampleVariance requires at least two data points");
  var e = vH(t), r = t.length - 1;
  return e / r;
}
function s9(t) {
  var e = IH(t);
  return Math.sqrt(e);
}
function PH(t, e) {
  var r = CH(t, e), n = s9(t), i = s9(e);
  return r / n / i;
}
class RH {
  constructor(e) {
    e && (this.df = e);
  }
  LogGamma(e) {
    const r = 1 + 76.18009173 / e - 86.50532033 / (e + 1) + 24.01409822 / (e + 2) - 1.231739516 / (e + 3) + 0.00120858003 / (e + 4) - 536382e-11 / (e + 5);
    return (e - 0.5) * Math.log(e + 4.5) - (e + 4.5) + Math.log(r * 2.50662827465);
  }
  Betinc(e, r, n) {
    let i = 0, s = 1, o = 1, a = 1, l = 0, c = 0, p;
    for (; Math.abs((o - c) / o) > 1e-5; )
      c = o, p = -(r + l) * (r + n + l) * e / (r + 2 * l) / (r + 2 * l + 1), i = o + p * i, s = a + p * s, l = l + 1, p = l * (n - l) * e / (r + 2 * l - 1) / (r + 2 * l), o = i + p * o, a = s + p * a, i = i / a, s = s / a, o = o / a, a = 1;
    return o / r;
  }
  cumulativeProbability(e, r) {
    r || (r = this.df);
    let n;
    if (r <= 0)
      console.error("Degrees of freedom must be positive");
    else {
      const i = r / 2, s = i + 0.5, o = r / (r + e * e), a = Math.exp(this.LogGamma(s) - this.LogGamma(0.5) - this.LogGamma(i) + i * Math.log(o) + 0.5 * Math.log(1 - o));
      let l;
      o < (i + 1) / (s + 2) ? l = a * this.Betinc(o, i, 0.5) : l = 1 - a * this.Betinc(1 - o, 0.5, i), e < 0 ? n = l / 2 : n = 1 - l / 2;
    }
    return n = Math.round(n * 1e5) / 1e5, n;
  }
  invCumulativeProbability(e, r) {
    if (r || (r = this.df), e >= 0.5) {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(o, r) >= e); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(n + o / 100) >= e); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(i + o / 1e4) >= e); o += 1)
        s = i + o / 1e4;
      return s;
    } else {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-o, r) <= e); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-n - o / 100) <= e); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-i - o / 1e4) <= e); o += 1)
        s = i + o / 1e4;
      return -s;
    }
  }
}
class OH {
  constructor(e, r) {
    this.df1 = e, this.df2 = r, this.EPSILON = 1e-10;
  }
  L504(e, r, n, i) {
    const s = e * r / (e * r + n), o = Math.sqrt(s), a = Math.log(o), l = Math.sqrt(1 - s), c = Math.log(l);
    let h = 1 - 2 * Math.atan(o / Math.sqrt(-o * o + 1)) / Math.PI, d = 0;
    if (n != 1) {
      const v = Math.log(2 * o / Math.PI);
      if (h -= Math.exp(v + c), n != 3) {
        const m = Math.floor((n - 3) / 2);
        for (let b = 1; b <= m; b++) {
          const f = 2 * b + 1;
          d += Math.log((f - 1) / f);
          const E = d + c * f + v;
          E > -78.4 && (h -= Math.exp(E));
        }
      }
    }
    if (e != 1) {
      let v = d;
      if (n > 1 && (v += Math.log(n - 1)), v += Math.log(2 / Math.PI) + a + c * n, v > -78.4 && (h += Math.exp(v)), e != 3) {
        const m = Math.floor((e - 3) / 2);
        d = 0;
        for (let b = 1; b <= m; b++) {
          const f = b * 2 + 1;
          d += Math.log((n + f - 2) / f);
          const E = d + a * (f - 1) + v;
          E > -78.4 && (h += Math.exp(E));
        }
      }
    }
    return h;
  }
  L401(e, r, n, i) {
    const s = e * r / (e * r + n), o = Math.log(s);
    let a = 0;
    const l = Math.log(1 - s) * n / 2;
    if (l > -78.4 && (a = Math.exp(l)), e != 2) {
      const c = Math.floor(e / 2 - 1);
      let p = 0;
      for (let h = 1; h <= c; h++) {
        const d = 2 * h;
        p += Math.log(n + d - 2) - Math.log(d) + o, p + l > -78.4 && (a += Math.exp(p + l));
      }
    }
    return i == 1 && (a = 1 - a), a;
  }
  ProbF(e, r, n) {
    let i = n, s = e, o = r, a = 0;
    return Math.floor(s / 2) * 2 == s ? this.L401(s, i, o, a) : Math.floor(o / 2) * 2 != o ? this.L504(s, i, o, a) : (i = 1 / i, s = r, o = e, a = 1, this.L401(s, i, o, a));
  }
  cumulativeProbability(e) {
    if (this.df1 > 0.01 && this.df2 > 0.01 && e > this.EPSILON)
      return 1 - this.ProbF(this.df1, this.df2, e);
    console.error("df1, df2, and F must be numbers greater than 0.");
  }
}
function dx(t) {
  return Math.atan(t) * 180 / Math.PI;
}
function ua(t, e) {
  const r = [];
  for (let n = 0; n < t; n++)
    r.push(e(n));
  return r;
}
const o9 = [
  1.4142024783770517,
  1.7285350177358225,
  1.975558322080508,
  2.165309701618668,
  2.3223314597870495,
  2.43666896580902,
  2.539575597098922,
  2.629725259756139,
  2.6946351910160824,
  2.7571690989287108,
  2.82429436007275,
  2.86976990061697,
  2.911181488216127,
  2.9562785307147474,
  2.991043137459134,
  3.031892332910388,
  3.0390882779033968,
  3.084150339177206,
  3.1068126593538534,
  3.1377944664764175,
  3.1526730795266236,
  3.1856353298858746,
  3.1923941584623616,
  3.2232152987382205,
  3.2423279731889063,
  3.2672678614514434,
  3.28815589678312,
  3.306598538588182,
  3.3169876930034423,
  3.3426537588982366,
  3.338808432731316,
  3.3551800156910674,
  3.3677857453596176,
  3.3801704122612546,
  3.3894353098402292,
  3.4103476461664384,
  3.420758782190955,
  3.4234022273067235,
  3.4377591100482245,
  3.4495251663075597,
  3.45784133640642,
  3.4655169406594553,
  3.499664208072353,
  3.5075228374867624,
  3.4963470841468247,
  3.5194522982765517,
  3.50887461478777,
  3.517883433127914,
  3.527130862311399,
  3.5478465903324174,
  3.5524335509017972,
  3.5453727082671342,
  3.556173872494318,
  3.557087103502499,
  3.589369632641309,
  3.5859140345184524,
  3.572323092223869,
  3.6004177405174853,
  3.6100996977289306,
  3.601519301860006,
  3.606430559116003,
  3.623484959486857,
  3.6110156117453704,
  3.6398254610166214,
  3.6485762129590045,
  3.6369984456518214,
  3.6420217039991707,
  3.6515502039986543,
  3.6534596174533878,
  3.6659253039539754,
  3.678204062277477,
  3.673013776537585,
  3.6873396028854244,
  3.677549442478252,
  3.672393117945697,
  3.694338890356745,
  3.698559967922895,
  3.7088383298959364,
  3.6960214124422732,
  3.6962804693332054,
  3.7259363906151113,
  3.6945941836261005,
  3.7123614650012637,
  3.7266182166220743,
  3.726433940762783,
  3.7262288936328507,
  3.73068538678121,
  3.7464587039431216,
  3.734498500854471,
  3.7666496106093086,
  3.7577811376185797,
  3.755885408241557,
  3.7653220485067256,
  3.759612302718265,
  3.750000422234468,
  3.776893666562007,
  3.7656945047078376
], TH = [
  [
    12.92876788710003,
    18.669362102797844,
    20.708185574014465
  ],
  [
    12.893379950402329,
    17.838738753100234,
    20.009145166260716
  ],
  [
    12.567620517329296,
    17.39284624657391,
    19.327403214291675
  ],
  [
    12.44012368783225,
    17.159725181804923,
    19.031999514734718
  ],
  [
    12.258810404004157,
    16.643626920880678,
    18.520644599539708
  ],
  [
    12.490936102639248,
    17.07031258707699,
    19.26763537042604
  ],
  [
    12.230582644506537,
    16.8611702133535,
    19.04138451550924
  ],
  [
    12.285890759032673,
    16.72028694459538,
    18.998686524252154
  ],
  [
    12.265830882960202,
    16.861313711298223,
    19.01741086021432
  ],
  [
    12.221592293386445,
    16.856569952690425,
    18.679522968116675
  ],
  [
    12.207863926087379,
    16.466760433982508,
    18.327798576854196
  ],
  [
    12.23047144884862,
    16.604698640112442,
    18.778749913667404
  ],
  [
    12.310880515319493,
    16.75477031068603,
    18.61887265606582
  ],
  [
    12.09088910593483,
    16.680683526842817,
    19.10909766756724
  ],
  [
    12.28969274656454,
    16.494346369998592,
    18.555323182091747
  ],
  [
    12.351479909044647,
    17.231085800266705,
    19.12315903511468
  ],
  [
    12.232654018508402,
    17.03319706813043,
    19.36238761950663
  ],
  [
    12.24175327982118,
    17.01249507542771,
    19.29261479388184
  ],
  [
    12.240819762926595,
    16.958668959199564,
    18.703343358289676
  ],
  [
    12.325576191647679,
    16.741637280941735,
    18.706270613293825
  ],
  [
    12.29079270883332,
    16.83580567418819,
    18.885633182327588
  ],
  [
    12.105579742321321,
    16.801481191805877,
    18.74917129995002
  ],
  [
    12.241506985184987,
    16.421107838741005,
    18.51907643327747
  ],
  [
    12.22772321442409,
    16.76637698315794,
    18.59944945667253
  ],
  [
    12.146827427372807,
    16.504491710455042,
    18.624893334253915
  ],
  [
    12.099825423105056,
    16.517727777727934,
    18.389759370770282
  ],
  [
    12.241793182544008,
    16.69983166753318,
    18.199273554649118
  ],
  [
    12.133827646762477,
    16.937161124066893,
    18.865979715097055
  ],
  [
    12.014897172400497,
    16.64164656731907,
    18.52796800753582
  ],
  [
    12.03194886183511,
    16.448427247716083,
    18.360165754021324
  ],
  [
    12.060576333659972,
    16.972556324548336,
    18.909884009510286
  ],
  [
    12.130919558394593,
    16.846538605893603,
    18.974105413083418
  ],
  [
    12.167013704292577,
    16.962535224497064,
    18.952800614645692
  ],
  [
    12.307745895005242,
    16.69776947316106,
    18.73020815902911
  ],
  [
    12.03703814065202,
    16.744259233990512,
    19.40987043616083
  ],
  [
    12.23158902787162,
    16.992381220472012,
    19.23258888861058
  ],
  [
    12.30313545083327,
    16.80175925410746,
    18.88639508508212
  ],
  [
    12.216506652052612,
    16.95978747527697,
    19.07369251354378
  ],
  [
    12.289633178985905,
    17.037358965358983,
    18.978000598844293
  ],
  [
    12.114391564747471,
    16.353909897952686,
    18.35011390560238
  ],
  [
    12.208213936084457,
    16.12841887472018,
    18.239736208276152
  ],
  [
    12.326886082604242,
    16.87043068171149,
    18.900551155302647
  ],
  [
    12.24602935198574,
    16.740078446411406,
    18.57610242578182
  ],
  [
    12.154508067768113,
    16.70375179351137,
    18.84458221820561
  ],
  [
    12.053162931004179,
    16.63616478058826,
    18.764716631834734
  ],
  [
    12.242031428895839,
    16.870439498648583,
    18.946299240629287
  ],
  [
    12.172676093456305,
    16.57616403586386,
    18.901254056077153
  ],
  [
    12.234873290793098,
    16.849691971911838,
    19.020953521536004
  ],
  [
    12.307356477970162,
    17.070904468883104,
    19.124634537613513
  ],
  [
    12.258316325281726,
    16.98236293001686,
    19.362641577913156
  ],
  [
    12.236258781616636,
    16.835948685325945,
    18.872615556171525
  ],
  [
    12.218214829379882,
    16.72052856570416,
    18.576319895769533
  ],
  [
    12.266452802779268,
    17.001974682521503,
    19.397512454689892
  ],
  [
    12.142229768023105,
    16.760040761542093,
    18.73221439686166
  ],
  [
    12.362128316602698,
    16.779263655428466,
    18.690631800055144
  ],
  [
    12.23248525532616,
    16.78957578482738,
    19.290187946573045
  ],
  [
    12.194978246692179,
    16.66872414977679,
    18.38065055971982
  ],
  [
    12.364346090585878,
    16.78308783969924,
    18.787944141467552
  ],
  [
    12.213523054233821,
    16.745070120633624,
    18.779462580096293
  ],
  [
    12.120562728816676,
    16.72947148909386,
    18.540581750860838
  ],
  [
    12.147441684285011,
    16.362711939455345,
    18.5928909502196
  ],
  [
    12.349013958141011,
    17.115157968739332,
    19.074081167238724
  ],
  [
    12.169896474381117,
    16.779107284309674,
    19.095614865501265
  ],
  [
    12.212332899050487,
    17.15220159015151,
    19.18433312800504
  ],
  [
    12.427266331944576,
    17.19802901185036,
    19.08282870552354
  ],
  [
    12.208415329256482,
    16.698611123996386,
    18.437039290733527
  ],
  [
    12.150857540075965,
    16.747967767000077,
    18.522105916017864
  ],
  [
    12.185133777587764,
    16.716543085287885,
    18.75368115517968
  ],
  [
    12.202518998568662,
    16.695350960024488,
    18.766605345681214
  ],
  [
    12.293516845096802,
    16.848652152520355,
    18.73818931670063
  ],
  [
    12.264328782539446,
    16.898700733974184,
    18.91736903501125
  ],
  [
    12.283442238272498,
    16.79113139749197,
    18.762641899116595
  ],
  [
    12.288571666812464,
    16.947956362708894,
    19.26608413111616
  ],
  [
    12.199938820517241,
    16.73882101164454,
    18.649824259785902
  ],
  [
    12.281399931209005,
    16.74455321404603,
    18.993644280454557
  ],
  [
    11.978508088635845,
    16.751385791647305,
    19.067980524092103
  ],
  [
    12.352190443412464,
    17.002035355108024,
    18.910150024775536
  ],
  [
    12.11299191492474,
    16.85211409238294,
    19.21553533835868
  ],
  [
    12.252946905996852,
    16.77267825853487,
    18.758060103809566
  ],
  [
    12.253428278525488,
    17.05117162481038,
    19.437396636388712
  ],
  [
    12.365555609949542,
    17.217797222036967,
    19.557725250431925
  ],
  [
    12.446856234792692,
    17.13219895129848,
    19.189823799758685
  ],
  [
    12.378913383861864,
    16.69420382596318,
    18.614200176451167
  ],
  [
    12.209646506057828,
    17.049298470931937,
    19.21471558598783
  ],
  [
    12.07451389049845,
    16.52146599860598,
    18.646538442813565
  ],
  [
    12.242992826481506,
    17.118044327693312,
    19.109033882498373
  ],
  [
    12.031588638774476,
    16.440292876584916,
    18.365137461548116
  ],
  [
    12.256327863966023,
    16.937124809805663,
    19.055448755862216
  ],
  [
    12.152502866561859,
    16.51661734703226,
    18.292867488178068
  ],
  [
    12.240166584135661,
    17.01144955716148,
    19.269980514360167
  ],
  [
    12.288087364649998,
    16.9124768573556,
    18.78496409520197
  ],
  [
    12.261031067472498,
    17.080660923120398,
    18.993376274931116
  ],
  [
    12.149516099981419,
    16.429960356660846,
    18.693814658804264
  ],
  [
    12.189972968413274,
    16.360091390089806,
    18.372140642711813
  ],
  [
    12.247713311640034,
    16.85901876289993,
    18.747152105084417
  ],
  [
    12.235996387439796,
    16.719425800548546,
    18.73463631602104
  ]
], Vu = {
  minLen3: 0,
  minLen6: 1,
  tooManyPoints: 2
}, LH = {
  [Vu.minLen3]: "line must have at least 3 points",
  [Vu.minLen6]: "line must have at least 6 points",
  [Vu.tooManyPoints]: "line contains too many points"
};
let z2 = class extends Error {
  constructor(e) {
    super(LH[e]), this.code = e;
  }
};
function MH(t, e, r) {
  return t.map((n) => n - e).map((n) => n / r);
}
function aw(t) {
  const e = t.bestFit, r = e.rss();
  return {
    se: Math.sqrt(r / t.length),
    rss: r,
    resid: e.residuals,
    slope: e.slope,
    inter: e.intercept
  };
}
function NH(t) {
  if (t.length < 3)
    throw new z2(Vu.minLen3);
  const e = PH(t.points.map((r) => r.x), t.points.map((r) => r.y));
  return Number.isNaN(e) ? 1 : Math.abs(e);
}
function DH(t) {
  const e = t.length;
  if (e < 6)
    throw new z2(Vu.minLen6);
  const { se: r } = aw(t);
  if (r === 0)
    return { feats: [0, 0, 0] };
  const n = TH[e - 6], i = [];
  for (let a = 2; a < e - 3; a++) {
    const l = a + 1, { se: c } = aw(t.slice(0, l)), { se: p } = aw(t.slice(l));
    i.push(c ** l * p ** (e - l) / r ** e);
  }
  const s = Math.min(...i), o = -Math.log(s);
  return {
    feats: n.map((a) => o > a ? 1 : 0),
    logLambda: o,
    t: i.indexOf(s) + 2
  };
}
function $O(t) {
  const e = t.length;
  if (e < 6)
    throw new z2(Vu.minLen6);
  const r = t.bestFit.rss(), n = [0, 0];
  if (r === 0)
    return { feats: n };
  const i = [], s = t.points.map((f) => f.x), o = t.points.map((f) => f.y), a = (f) => f.reduce((E, A) => E + A), l = (f, E) => a(f.map((A, x) => A * E[x])), c = [], p = [];
  for (let f = 2; f < e - 3; f++) {
    const E = s.slice(0, f + 1), A = o.slice(0, f + 1), x = a(E), g = a(A), w = l(E, A), _ = a(E.map((oe) => oe ** 2)), S = w - x * g / (f + 1), R = _ - x ** 2 / (f + 1), L = S / R, F = Wl(A) - L * Wl(E), z = s[f], j = F + L * z, W = s.slice(f + 1), te = o.slice(f + 1), le = a(W), ce = a(te), Ee = l(W, te), xe = a(W.map((oe) => oe ** 2)), _e = ce - (t.length - (f + 1)) * j, Ie = le - (t.length - (f + 1)) * z, je = _e / Ie, ue = Ee / le - je * xe / le, O = E.map((oe) => F + L * oe), N = a(E.map((oe, ee) => (A[ee] - O[ee]) ** 2)), J = W.map((oe) => ue + je * oe), re = a(W.map((oe, ee) => (te[ee] - J[ee]) ** 2));
    i.push(N + re), c.push({ a1: F, b1: L, a2: ue, b2: je }), p.push(O.concat(J));
  }
  const h = Math.min(...i);
  let d, v = (r - h) / 2 / (h / (e - 4));
  v <= 0 && (v = 1e-3), v === 1 / 0 ? d = 0 : d = 1 - new OH(2, e - 4).cumulativeProbability(v);
  const m = i.indexOf(h) + 2, b = { rssMin: h, rssl: r, F: v, p: d, split: m, params: c[m - 2], yhats: p[m - 2] };
  return d < 0.1 && (n[0] = 1), d < 0.05 && (n[1] = 1), { feats: n, debug: b };
}
function $H(t) {
  const e = t.bestFit.residuals.map(Math.sign), { r, nminus: n, nplus: i } = e.reduce(
    (a, l, c) => (c && l !== e[c - 1] && a.r++, l || (l = 1), a[l === 1 ? "nplus" : "nminus"]++, a),
    { r: 1, nminus: 0, nplus: 0 }
  ), s = 2 * i * n / (i + n) + 1, o = Math.abs(Math.sqrt(
    2 * i * n * (2 * i * n - i - n) / (Math.pow(i + n, 2) * (i + n - 1))
  ));
  return { feats: [r < s - o / 2 ? 1 : r > s + o / 2 ? -1 : 0, r, s, o, Math.abs(r - s) / s] };
}
function jH(t) {
  const e = t.length;
  if (e > o9.length + 4)
    throw new z2(Vu.tooManyPoints);
  const r = t.bestFit.residuals, n = Math.sqrt(
    r.map((d) => d ** 2 / (e - 2)).reduce((d, v) => d + v)
  );
  if (n === 0)
    return [-1, 0];
  const i = t.points.map((d) => d.x), s = Wl(i), o = i.map((d) => (d - s) ** 2), a = o.reduce((d, v) => d + v), l = o.map((d) => n * Math.sqrt(1 - 1 / e - d / a)), c = r.map((d, v) => d / l[v]).map((d) => Math.abs(d)), p = Math.max(...c), h = o9[e - 4];
  return [p, c.filter((d) => d > h).length];
}
function BH(t) {
  const e = t.bestFit.rss(), r = t.points.at(-1).x - t.points[0].x, n = Math.sqrt(e / t.length) / r, i = Math.atan(t.bestFit.slope);
  return [n, n * Math.cos(i) ** 2];
}
let FH = class {
  /**
   * Compute non-standardized feature columns from examples.
   * @param examples - Training examples
   * @returns Feature columns
   */
  computeFeatures(e) {
    function r(i, s) {
      const o = i[0].length, a = {};
      for (let l = 0; l < o; l++)
        a[`${s}${l + 1}`] = [];
      for (const l of i)
        l.forEach((c, p) => a[`${s}${p + 1}`].push(c));
      return a;
    }
    const n = {
      absCorrCoeff: e.map((i) => NH(i.data)),
      nPoints: e.map((i) => i.data.length),
      ...r(e.map((i) => BH(i.data)), "scaledS"),
      nPointsChart: e.map((i) => i.chartLength),
      chartPct: e.map((i) => (i.data.length - 1) / (i.chartLength - 1))
    };
    return e[0].data.length >= 6 && Object.assign(
      n,
      r(e.map((i) => DH(i.data).feats), "qTest"),
      r(e.map((i) => $O(i.data).feats), "fTest"),
      r(e.map((i) => $H(i.data).feats), "runsTest"),
      r(e.map((i) => jH(i.data)), "outlierTest")
    ), n;
  }
  /**
   * Standardize feature columns.
   * @param featCols - Non-standardized feature columns
   * @param featStats - Feature column statistics
   * @returns Standardized feature columns
   */
  standardizeFeatures(e, r) {
    const n = {};
    for (const [i, s] of Object.entries(e)) {
      const o = r[i];
      n[i] = o ? MH(s, o.mean, o.stdDev) : s;
    }
    return n;
  }
  /**
   * Assemble feature matrix from standardized feature columns.
   * @param stdFeatCols - Standardized feature columns.
   * @returns Feature matrix (array of example rows)
   */
  assembleMatrix(e) {
    const r = Object.values(e)[0].length, n = ua(r, (i) => []);
    for (const [i, s] of Object.entries(e))
      s.forEach((o, a) => n[a].push(o));
    return n;
  }
  /**
   * Compute feature matrix from examples.
   * @param examples - Training examples
   * @param featStats - Feature column statistics
   * @returns Feature matrix (array of example rows)
   */
  computeMatrix(e, r) {
    const n = this.computeFeatures(e), i = this.standardizeFeatures(n, r);
    return this.assembleMatrix(i);
  }
};
const jO = {
  "188b757048e": {
    breaks: "breaks_JF_CM3",
    small: {
      model: {
        N: 216,
        D: 6,
        b: 1.0301052191704447,
        kernelType: "linear",
        w: [
          -0.3670377924881308,
          0.24109852608042484,
          0.10770417080350453,
          3.7309289892912494,
          -0.24351287768173968,
          0.1773538767010703
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6613098596026764,
          stdDev: 0.32645241503938466
        },
        nPoints: {
          mean: 4.027777777777778,
          stdDev: 0.79484775003546
        },
        scaledS1: {
          mean: 0.2738191427566398,
          stdDev: 0.31274618795081666
        },
        scaledS2: {
          mean: 0.16552447256379144,
          stdDev: 0.22401114065292482
        },
        nPointsChart: {
          mean: 18.88425925925926,
          stdDev: 11.50047652834366
        },
        chartPct: {
          mean: 0.24575562721992683,
          stdDev: 0.17658868716036033
        }
      }
    },
    big: {
      model: {
        N: 818,
        D: 18,
        b: -0.5949603608497636,
        kernelType: "linear",
        w: [
          -0.4977108970919176,
          0.7541270816821308,
          0.9144109510673445,
          1.6047203771838476,
          -1.4368172642074537,
          -0.21592712823176308,
          0.07644318713996778,
          0.014636523739875784,
          0.1763324579259402,
          1.106707575171747,
          -0.47385129596321995,
          0.45987873914033983,
          0.35112878139332787,
          -0.6236067182671058,
          0.9485075089484734,
          0.19163220544936868,
          0.20546829454342905,
          -0.06915930322456987
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6452237813470705,
          stdDev: 0.3240018443609284
        },
        nPoints: {
          mean: 14.583129584352077,
          stdDev: 8.99604477133496
        },
        scaledS1: {
          mean: 0.10594325137217282,
          stdDev: 0.09177436527475356
        },
        scaledS2: {
          mean: 0.08668479622616888,
          stdDev: 0.07415105573907281
        },
        nPointsChart: {
          mean: 27.0880195599022,
          stdDev: 12.696709863610126
        },
        chartPct: {
          mean: 0.5831555684741223,
          stdDev: 0.28777669079271473
        },
        runsTest2: {
          mean: 5.10757946210269,
          stdDev: 2.511304431521282
        },
        runsTest3: {
          mean: 8.050945471288665,
          stdDev: 4.446028922152818
        },
        runsTest4: {
          mean: 1.6812783091074126,
          stdDev: 0.5646901163167827
        },
        runsTest5: {
          mean: 0.337916669549109,
          stdDev: 0.20151780352623566
        },
        outlierTest1: {
          mean: 2.100035193879811,
          stdDev: 0.5296286424653459
        },
        outlierTest2: {
          mean: 0.05867970660146699,
          stdDev: 0.2351680408679939
        }
      }
    }
  },
  "18afd2f54c7": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3380856560371651,
        kernelType: "linear",
        w: [
          -0.756517811722315,
          0.37069999610745497,
          0.21673055797213336,
          1.1244975473636247,
          0.035519868943893806,
          0.6975781903311828
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6866332461949628,
          stdDev: 0.3229548134968895
        },
        nPoints: {
          mean: 4.069767441860465,
          stdDev: 0.8050959803624481
        },
        scaledS1: {
          mean: 0.03965686197121996,
          stdDev: 0.0338017466328698
        },
        scaledS2: {
          mean: 0.038745499336644146,
          stdDev: 0.033324943757710994
        },
        nPointsChart: {
          mean: 15.078488372093023,
          stdDev: 8.898337515306299
        },
        chartPct: {
          mean: 0.2979532652417984,
          stdDev: 0.1884678355817908
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.22042056305341218,
        kernelType: "linear",
        w: [
          -0.3280468854878086,
          -0.11665058369931192,
          -0.0022542536097451466,
          2.219103384778342,
          0.0342024760983941,
          0.4293989826596215,
          0.2975608661999607,
          -0.6077251584818741,
          0.4000527465309003,
          0.4042384593088002,
          0.001186586425212074,
          0.5190085928118862,
          -0.23537053975123523,
          0.0715945226988598,
          0.033154145420287044,
          -0.06347880606856209,
          0.1850990704458409,
          -0.001228864486559927
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6223429821764429,
          stdDev: 0.3110591999188207
        },
        nPoints: {
          mean: 13.731607629427794,
          stdDev: 8.370686093707965
        },
        scaledS1: {
          mean: 0.03544093688268208,
          stdDev: 0.026611386439376005
        },
        scaledS2: {
          mean: 0.03455363316854854,
          stdDev: 0.026077505679786228
        },
        nPointsChart: {
          mean: 23.768392370572208,
          stdDev: 11.730176258926388
        },
        chartPct: {
          mean: 0.6094307363719895,
          stdDev: 0.26692294365220165
        },
        runsTest2: {
          mean: 5.151226158038147,
          stdDev: 2.6793673522936645
        },
        runsTest3: {
          mean: 7.583581141916727,
          stdDev: 4.081715945141601
        },
        runsTest4: {
          mean: 1.6148756585462214,
          stdDev: 0.5411094264297078
        },
        runsTest5: {
          mean: 0.3153327018423893,
          stdDev: 0.19626169453505887
        },
        outlierTest1: {
          mean: 2.118980108638941,
          stdDev: 0.6300714899329056
        },
        outlierTest2: {
          mean: 0.09128065395095368,
          stdDev: 0.2882041970351209
        }
      }
    }
  },
  "18b1686ceb4": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3309416402875685,
        kernelType: "linear",
        w: [
          -0.20000267112106263,
          0.42809635761540643,
          0.46656203058966117,
          1.841671684760453,
          -0.6434524674952959,
          0.49143545422517687
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6764124363859395,
          stdDev: 0.3236057116921364
        },
        nPoints: {
          mean: 4.116279069767442,
          stdDev: 0.8069465847859293
        },
        scaledS1: {
          mean: 0.1858035195675879,
          stdDev: 0.21428670248595916
        },
        scaledS2: {
          mean: 0.12950420831848175,
          stdDev: 0.15751874574784924
        },
        nPointsChart: {
          mean: 15.761627906976743,
          stdDev: 9.783137376835176
        },
        chartPct: {
          mean: 0.300526358561615,
          stdDev: 0.1927265795559554
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.33318046701370874,
        kernelType: "linear",
        w: [
          0.032315062605570585,
          0.48106580584263436,
          -1.1047252909009055,
          3.7368759283052406,
          -0.6183759573768267,
          0.6939892440180402,
          0.3861182101902436,
          -0.4528094207813589,
          0.19685209857044894,
          0.5317134144006395,
          -0.3268861531591498,
          0.5416909853776097,
          0.11204746654248579,
          -0.042886524593192116,
          0.04725504450122949,
          0.09451185559860642,
          -0.011544267888957445,
          0.17029310632188632
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6349627683741144,
          stdDev: 0.3047569778403939
        },
        nPoints: {
          mean: 13.728882833787466,
          stdDev: 8.419998905023999
        },
        scaledS1: {
          mean: 0.07039535118699393,
          stdDev: 0.06922873611482698
        },
        scaledS2: {
          mean: 0.06255041459772398,
          stdDev: 0.05952611432033109
        },
        nPointsChart: {
          mean: 23.705722070844686,
          stdDev: 11.739000887557054
        },
        chartPct: {
          mean: 0.6095266522529739,
          stdDev: 0.26470522117524425
        },
        runsTest2: {
          mean: 5.129427792915531,
          stdDev: 2.7706078547777717
        },
        runsTest3: {
          mean: 7.603857452118007,
          stdDev: 4.140301994340143
        },
        runsTest4: {
          mean: 1.6191709447588931,
          stdDev: 0.5436847808406448
        },
        runsTest5: {
          mean: 0.32151695128382807,
          stdDev: 0.19159541197646354
        },
        outlierTest1: {
          mean: 2.116230031599242,
          stdDev: 0.5977792703826863
        },
        outlierTest2: {
          mean: 0.09400544959128065,
          stdDev: 0.29203530028780983
        }
      }
    }
  }
};
function zH() {
  return Object.keys(jO).sort();
}
function UH(t) {
  return jO[t ?? zH().at(-1)];
}
var VH = Object.defineProperty, HH = (t, e, r) => e in t ? VH(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, GH = (t, e, r) => (HH(t, e + "", r), r);
const WH = 0.2;
function qH(t, e, r = WH) {
  if (t.length === 3)
    return 1;
  const n = t.points.at(-1).x - t.points[0].x, i = (t.points.at(-1).y - t.points[0].y) / n, s = Math.atan(i), o = Math.cos(s), a = t.points.map((f) => f.y), l = t.slice(1, t.length - 1);
  let c = a.indexOf(Math.min(...a)) - 1;
  (c < 0 || c === l.length) && (c = null);
  let p = a.indexOf(Math.max(...a)) - 1;
  (p < 0 || p === l.length) && (p = null);
  const h = [], d = l.points.map((f) => {
    const E = f.x - t.points[0].x, A = Math.abs(f.y - (i * E + t.points[0].y));
    return h.push(A), A * o;
  }), v = d.indexOf(Math.max(...d));
  let m = !1;
  c !== null && Math.abs(c - v) / (e - 1) <= r && (m = h[c] > d[v]);
  let b = !1;
  return p !== null && Math.abs(p - v) / (e - 1) <= r && (b = h[p] > d[v]), b ? p + 1 : m ? c + 1 : v + 1;
}
let QH = class {
  /**
   * @param model - (Optional) ID of split model to use.
   */
  constructor(e = void 0) {
    GH(this, "models");
    const r = UH(e);
    if (r)
      this.models = {
        small: {
          svm: new r9(),
          stats: r.small.stats
        },
        big: {
          svm: new r9(),
          stats: r.big.stats
        }
      };
    else
      throw new Error(`unknown model ID: '${e}'`);
    this.models.small.svm.fromJSON(r.small.model), this.models.big.svm.fromJSON(r.big.model);
  }
  /**
   * Predict whether a sequence should be split.
   * @param seq - Data points of sequence to evaluate. 
   * @param chartLength - Number of data points in the complete chart
   * of which 'seq' is a part.
   * @returns Whether the sequence should be split.
   */
  shouldSplit(e, r) {
    if (e.length < 3 || e.points.every((a) => a.y === e.points[0].y))
      return !1;
    const n = new FH(), i = e.length < 6 ? "small" : "big", [s] = n.computeMatrix(
      [{ data: e, chartLength: r }],
      this.models[i].stats
    ), [o] = this.models[i].svm.predict([s]);
    return o === 1;
  }
  /**
   * Predict trend sequences a series should be split into.
   * @param series - Data points of series to split.
   * @param yAxis - Displayed chart y-axis bounds; defaults to extreme values of data
   * @param pipCloseness - Max distance (as % of chart length) a sequence-local 
   * min/max point can be from the PIP to be a possible split point.
   * @returns List of index pairs denoting the start and end of each sequence.
   * @remarks
   * As in slices, the end index in a pair is not included in the set of indices
   * included in a sequence.
   * NB: Adjacent sequences share the point where they were split.
   * E.g., a hypothetical set of sequences might look like:
   *   [\{start: 0, end: 5\}, \{start: 4, end: 7\}, \{start: 6, end: 10\}]
   * where the first two sequences share the point at index 4, and the last
   * two share the point at index 6.
   */
  getSequences(e, r, n) {
    const i = e.length;
    e = e.project(void 0, r);
    const s = [], o = (a, l) => {
      const c = e.slice(a, l);
      if (this.shouldSplit(c, e.length)) {
        const p = qH(c, e.length, n) + a;
        o(a, p + 1), o(p, l);
      } else
        s.push({ start: a, end: l });
    };
    return o(0, i), s;
  }
};
var KH = Object.defineProperty, YH = (t, e, r) => e in t ? KH(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, a9 = (t, e, r) => (YH(t, typeof e != "symbol" ? e + "" : e, r), r);
const ZH = [
  [
    -1,
    1,
    "ReversalToRise",
    "PossibleReversalToRise"
    /* PRR */
  ],
  [
    1,
    -1,
    "ReversalToFall",
    "PossibleReversalToFall"
    /* PRF */
  ],
  [
    0,
    1,
    "EmergingRise",
    "PossibleEmergingRise"
    /* PER */
  ],
  [
    0,
    -1,
    "EmergingFall",
    "PossibleEmergingFall"
    /* PEF */
  ],
  [
    1,
    0,
    "RiseToStable",
    "PossibleRiseToStable"
    /* PRS */
  ],
  [
    -1,
    0,
    "FallToStable",
    "PossibleFallToStable"
    /* PFS */
  ]
], JH = [
  [
    1,
    -1,
    1,
    "Rebound",
    "PossibleRebound"
    /* PRB */
  ],
  [
    -1,
    1,
    -1,
    "TemporaryJump",
    "PossibleTemporaryJump"
    /* PTJ */
  ]
], XH = 6, IE = 5, eG = 0.15;
let mu = class {
  constructor(e, r = e.yBounds(), n, ...i) {
    a9(this, "params"), a9(this, "magnitude"), this.category = n, this.params = i, this.magnitude = this.computeMagnitude(e, r);
  }
  computeMagnitude(e, r) {
    const n = e.points.map((i) => i.y).slice(this.params[0], this.params.at(-1));
    return (Math.max(...n) - Math.min(...n)) / (r.end - r.start);
  }
  toString() {
    return `${this.category}(${this.params[0]}-${this.params[this.params.length - 1]})`;
  }
};
function tG(t) {
  const e = Wl(t), r = t.map((n) => n - e);
  return Math.sqrt(r.reduce((n, i) => n + i ** 2, 0));
}
function Cm(t) {
  return Math.sign(t);
}
function ty(t, e = IE, r = e) {
  const n = t.length;
  if (n < 3) {
    let i = (t.points[1].y - t.points[0].y) / (t.points[1].x - t.points[0].x);
    const s = dx(i);
    return Math.abs(s) < r && (i = 0), { classes: [Cm(i)], slope: i, angle: s };
  } else {
    const i = t.bestFit.rss();
    if (n < XH) {
      let h = Cm(t.bestFit.slope);
      return Math.abs(t.bestFit.xAngle) < r && (h = 0), { classes: [h], slope: t.bestFit.slope, angle: t.bestFit.xAngle };
    }
    const s = t.points.map((h) => h.x), o = Math.sqrt(i / (n - 2)) / tG(s), a = 1 - 0.05 / 2, l = new RH(n - 2).invCumulativeProbability(a) * o, c = [t.bestFit.slope - l, t.bestFit.slope + l], p = [];
    return Math.sign(c[0]) !== Math.sign(c[1]) ? (p.push(0), Math.abs(t.bestFit.xAngle) >= e && p.push(Cm(t.bestFit.slope))) : (p.push(Cm(t.bestFit.slope)), Math.abs(t.bestFit.xAngle) < e && t.bestFit.slope && p.push(0)), { classes: p, slope: t.bestFit.slope, angle: t.bestFit.xAngle, moe: l };
  }
}
function rG(t, e, r = eG, n = IE, i = n, s) {
  const o = t.project(void 0, s), a = e[e.length - 1], l = o.slice(a.start, a.end);
  if (l.length < 3)
    return null;
  const c = (m) => {
    const { classes: b } = ty(l.slice(0, m + 1), n, i), { classes: f } = ty(l.slice(m), n, i);
    if (b.length === 1 && f.length === 1 && b[0] !== f[0] || b.length === 1 && !f.includes(b[0]) || f.length === 1 && !b.includes(f[0])) {
      const E = a.start + m;
      return a.end = E + 1, e.push({ start: E, end: t.length }), !0;
    } else
      return !1;
  };
  let p = Math.round(r * t.length);
  if (p < 2)
    return null;
  if (p === 2 || l.length === 3)
    return c(l.length - 2);
  if (l.length < 6)
    return !!(c(2) || l.length === 5 && c(3));
  for (; l.length - p < l.length / 2; )
    p--;
  const h = l.slice(-(p + 3)), { feats: d, debug: v } = $O(h);
  if (d[0] && d[1]) {
    const m = a.end - (p + 3) + v.split;
    return a.end = m + 1, e.push({ start: m, end: t.length }), !0;
  }
  return !1;
}
function nG(t, e, r, n) {
  const i = [];
  let s = -1;
  function o(a) {
    const l = e[s][1], c = e[a - 1][2];
    i.push([
      ty(t.slice(l, c), r, n),
      l,
      c
    ]);
  }
  for (let a = 0; a < e.length; a++) {
    if (e[a][0].classes.length > 1) {
      s !== -1 && o(a), s = a, o(a + 1), s = -1;
      continue;
    }
    s === -1 ? s = a : e[a][0].classes[0] !== e[a - 1][0].classes[0] && (o(a), s = a);
  }
  return s !== -1 && o(e.length), i;
}
function iG(t, e, r = IE, n = r, i, s = !1) {
  const o = t.project(void 0, i);
  let a = e.map(
    ({ start: c, end: p }) => [
      ty(o.slice(c, p), r, n),
      c,
      p
    ]
  );
  s && a.length > 1 && (a = nG(o, a, r, n));
  const l = [];
  for (let c = 0; c < a.length; c++) {
    const [p, h, d] = a[c];
    for (const v of p.classes)
      l.push(new mu(
        t,
        i,
        [
          "Fall",
          "Stable",
          "Rise"
          /* RT */
        ][v + 1],
        h,
        d
      ));
    if (c < a.length - 1) {
      p.classes.includes(1) ? l.push(new mu(t, i, "BigJump", h, d)) : p.classes.includes(-1) && l.push(new mu(t, i, "BigFall", h, d));
      const [v, m, b] = a[c + 1], f = ZH.filter((E) => p.classes.includes(E[0]) && v.classes.includes(E[1]));
      for (const E of f)
        l.push(new mu(t, i, E[2], h, m, b)), c + 1 === a.length - 1 && l.push(new mu(t, i, E[3], h, m, b));
      if (c < a.length - 2) {
        const [E, A, x] = a[c + 2], g = JH.filter(
          (w) => p.classes.includes(w[0]) && v.classes.includes(w[1]) && E.classes.includes(w[2])
        );
        for (const w of g)
          l.push(new mu(t, i, w[3], h, m, A, x)), c + 2 === a.length - 1 && l.push(new mu(t, i, w[4], h, m, A, x));
      }
    }
  }
  return { candidates: l, slopeInfo: a.map(([c, p, h]) => c) };
}
class sG extends Error {
}
function l9(t) {
  const e = [];
  let r = 0;
  for (let n = 0; n < t; n++)
    e[n] = Math.random(), r += e[n];
  for (let n = 0; n < t; n++)
    e[n] = e[n] / r;
  return e;
}
function PE(t, e, r) {
  if (e && e.length > 0) {
    const n = [];
    if (e.length === 1 || r === e.length - 1) {
      const i = e.length === 1 ? 0 : r, s = e[i].values.length;
      for (let o = 0; o < s; o++) {
        const a = l9(t.length);
        n.push(a);
      }
    } else {
      const i = e[r].values.length;
      for (let s = 0; s < i; s++) {
        const o = PE(t, e, r + 1);
        n.push(o);
      }
    }
    return n;
  } else
    return l9(t.length);
}
function oG(t, e, r) {
  const n = PE(t, e, 0);
  return BO(n, r, 0), n;
}
function c9(t) {
  return t.constructor === Array;
}
function aG(t) {
  return !!(c9(t) && t.length > 0 && c9(t[0]));
}
function BO(t, e, r) {
  if (aG(t)) {
    let n = r;
    for (let i = 0; i < t.length; i++)
      n = BO(t[i], e, n);
    return n;
  } else {
    for (let i = 0; i < t.length; i++)
      t[i] = e[r][i];
    return r + 1;
  }
}
function lG(t) {
  const e = [];
  for (let r = 0; r < t.length; r++)
    e.push(FO(t[r]));
  return e;
}
function FO(t) {
  const e = [];
  let r = 0;
  for (let n = 0; n < t.length; n++)
    e[n] = t[n] + 1e-3, r += e[n];
  for (let n = 0; n < t.length; n++)
    e[n] = e[n] / r;
  return e;
}
class cG {
  constructor(e, r) {
    rr(this, "name");
    rr(this, "values");
    rr(this, "_sampledLw");
    rr(this, "wasSampled", !1);
    // keeping parent names here rather than references works better
    // for using worker threads
    rr(this, "parents", []);
    rr(this, "cpt", []);
    rr(this, "value", -1);
    rr(this, "dirty", !1);
    rr(this, "isObserved", !1);
    // XXX better to use Map
    rr(this, "valueIndexMap");
    rr(this, "g");
    this.name = e, this.values = r;
  }
  initSampleLw() {
    this._sampledLw = void 0;
  }
  sampleLw() {
    if (this.wasSampled)
      return 1;
    const e = this.parents.map((i) => this.g.nodeMap[i]);
    let r = 1;
    e.forEach((i) => {
      r *= i.sampleLw();
    }), this.wasSampled = !0;
    let n = this.cpt;
    if (e.forEach((i) => {
      n = n[i.value];
    }), this.value != -1)
      r *= n[this.value];
    else {
      let i = Math.random();
      for (let s = 0; s < n.length; s++)
        if (i -= n[s], i < 0) {
          this.value = s;
          break;
        }
    }
    return r;
  }
  saveSampleLw(e) {
    if (!this._sampledLw) {
      this._sampledLw = new Array(this.values.length);
      for (let r = this.values.length - 1; r >= 0; r--)
        this._sampledLw[r] = 0;
    }
    this._sampledLw[this.value] += e;
  }
  addParent(e) {
    return this.parents.push(e), this.dirty = !0, this;
  }
  valueIndex(e) {
    if (!this.valueIndexMap) {
      this.valueIndexMap = {};
      for (let r = 0; r < this.values.length; r++) {
        const n = this.values[r];
        this.valueIndexMap[n] = r;
      }
    }
    return this.valueIndexMap[e];
  }
  observe(e) {
    const r = this.valueIndex(e);
    r >= 0 ? (this.isObserved = !0, this.value = r) : console.error("could not find value " + e + " for node " + this.name);
  }
  unobserve() {
    this.isObserved = !1, this.value = -1;
  }
  setCpt(e) {
    if (this.parents.length === 0)
      this.cpt = FO(e);
    else {
      if (!this.g)
        throw new sG("must add node to graph before calling setCpt()");
      const r = this.parents.map((n) => this.g.nodeMap[n]);
      this.cpt = oG(this.values, r, lG(e));
    }
  }
  probs() {
    if (!this._sampledLw)
      return [];
    const e = this._sampledLw.reduce((r, n) => r + n, 0);
    return this._sampledLw.map((r) => r / e);
  }
}
function uG() {
  class t {
    constructor(s, o) {
      rr(this, "name");
      rr(this, "values");
      rr(this, "_sampledLw");
      rr(this, "wasSampled", !1);
      rr(this, "parents", []);
      rr(this, "cpt", []);
      rr(this, "value", -1);
      rr(this, "dirty", !1);
      rr(this, "isObserved", !1);
      rr(this, "g");
      this.name = s, this.values = o;
    }
    initSampleLw() {
      this._sampledLw = void 0;
    }
    sampleLw() {
      if (this.wasSampled)
        return 1;
      const s = this.parents.map((l) => this.g.nodeMap[l]);
      let o = 1;
      s.forEach((l) => {
        o *= l.sampleLw();
      }), this.wasSampled = !0;
      let a = this.cpt;
      if (s.forEach((l) => {
        a = a[l.value];
      }), this.value != -1)
        o *= a[this.value];
      else {
        let l = Math.random();
        for (let c = 0; c < a.length; c++)
          if (l -= a[c], l < 0) {
            this.value = c;
            break;
          }
      }
      return o;
    }
    saveSampleLw(s) {
      if (!this._sampledLw) {
        this._sampledLw = new Array(this.values.length);
        for (let o = this.values.length - 1; o >= 0; o--)
          this._sampledLw[o] = 0;
      }
      this._sampledLw[this.value] += s;
    }
  }
  class e {
    constructor() {
      rr(this, "nodes", []);
      rr(this, "nodeMap", {});
    }
    sample(s) {
      for (let a = this.nodes.length - 1; a >= 0; a--)
        this.nodes[a].initSampleLw();
      let o = 0;
      for (let a = 0; a < s; a++) {
        for (let c = this.nodes.length - 1; c >= 0; c--) {
          const p = this.nodes[c];
          p.isObserved || (p.value = -1), p.wasSampled = !1;
        }
        const l = this.nodes.reduceRight((c, p) => c * p.sampleLw(), 1);
        o += l;
        for (let c = this.nodes.length - 1; c >= 0; c--)
          this.nodes[c].saveSampleLw(l);
      }
      return o;
    }
  }
  function r(i) {
    const s = Object.create(e.prototype, Object.getOwnPropertyDescriptors(i.graph)), o = s.nodes.map((a) => {
      const l = Object.create(t.prototype, Object.getOwnPropertyDescriptors(a));
      return l.g = s, s.nodeMap[a.name] = l, l;
    });
    return s.nodes = o, s;
  }
  function n(i) {
    const s = r(i);
    s.sample(i.samples);
    const o = {};
    for (let a = 0; a < s.nodes.length; a++)
      o[s.nodes[a].name] = s.nodes[a];
    self.postMessage(o);
  }
  self.onmessage = function(i) {
    n(i.data);
  };
}
const hG = uG.toString().trim().split(`
`).slice(1, -1).join(`
`), pG = new Blob([hG], { type: "text/javascript" }), dG = URL.createObjectURL(pG);
class fG {
  constructor() {
    rr(this, "nodes", []);
    rr(this, "saveSamples", !1);
    rr(this, "samples", []);
    rr(this, "nodeMap", {});
  }
  reinit() {
    this.nodes.forEach((e) => {
      if (e.dirty === void 0 || e.dirty) {
        const r = e.parents.map((n) => this.nodeMap[n]);
        e.cpt = PE(e.values, r, 0), e.dirty = !1;
      }
    });
  }
  sample(e) {
    this.saveSamples && (this.samples = []);
    for (let n = this.nodes.length - 1; n >= 0; n--)
      this.nodes[n].initSampleLw();
    let r = 0;
    for (let n = 0; n < e; n++) {
      for (let s = this.nodes.length - 1; s >= 0; s--) {
        const o = this.nodes[s];
        o.isObserved || (o.value = -1), o.wasSampled = !1;
      }
      const i = this.nodes.reduceRight((s, o) => s * o.sampleLw(), 1);
      r += i;
      for (let s = this.nodes.length - 1; s >= 0; s--)
        this.nodes[s].saveSampleLw(i);
      if (this.saveSamples) {
        const s = {};
        for (let o = this.nodes.length - 1; o >= 0; o--) {
          const a = this.nodes[o];
          s[a.name] = a.values[a.value];
        }
        this.samples.push(s);
      }
    }
    return r;
  }
  /*private createNodeMap() {
    this.nodeMap = {};
    for (let i = 0; i < this.nodes.length; i++) {
      const node = this.nodes[i];
      this.nodeMap[node.name] = node;
    }
  }*/
  node(e) {
    return this.nodeMap[e];
  }
  observe(e, r) {
    const n = this.node(e);
    n ? n.observe(r) : console.error("could not find node with name " + e);
  }
  unobserve(e) {
    const r = this.node(e);
    r && r.unobserve();
  }
  newNode(e, r) {
    const n = new cG(e, r);
    return this.addNodes(n), n;
  }
  addNodes(...e) {
    e.forEach((r) => {
      r.g = this, this.nodeMap[r.name] = r;
    }), this.nodes.push(...e);
  }
  samplesAsCsv(e) {
    const r = e || {}, n = r.rowDelimiter || `
`, i = r.fieldDelimiter || ",";
    let s = "", o = "";
    for (let a = 0; a < this.nodes.length; a++)
      o += this.nodes[a].name, a < this.nodes.length - 1 && (o += i);
    s += o + n;
    for (let a = 0; a < this.samples.length; a++) {
      const l = this.samples[a];
      o = "";
      for (let c = 0; c < this.nodes.length; c++) {
        const p = this.nodes[c];
        o += l[p.name], c < this.nodes.length - 1 && (o += i);
      }
      s += o, a < this.samples.length - 1 && (s += n);
    }
    return s;
  }
  toWorkerMessage(e) {
    return {
      samples: e,
      graph: this
    };
  }
  async sampleWithWorker(e) {
    return new Promise((r) => {
      const n = new Worker(dG, { type: "module" });
      n.onerror = (i) => {
        console.error(i);
      }, n.onmessage = (i) => {
        const s = i.data;
        this.updateFromWorker(s), r();
      }, n.postMessage(this.toWorkerMessage(e));
    });
  }
  updateFromWorker(e) {
    for (let r = 0; r < this.nodes.length; r++) {
      const n = this.nodes[r], i = e[n.name];
      i && (n.value = i.value, n.wasSampled = i.wasSampled, n._sampledLw = i._sampledLw);
    }
  }
}
var gG = Object.defineProperty, mG = (t, e, r) => e in t ? gG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ri = (t, e, r) => (mG(t, typeof e != "symbol" ? e + "" : e, r), r);
function yG(t, e) {
  const r = t.length, n = t.project(void 0, e);
  if (r < 3) {
    const i = (n.points[1].y - n.points[0].y) / (n.points[1].x - n.points[0].x);
    return dx(i);
  } else {
    const i = kE(t.points.map((s) => [s.x, s.y]));
    return dx(i.m);
  }
}
const zO = {
  /*density: {
    values: ['low', 'med', 'high'],
    fn(series: Point[]) {
      return series.length < 10 ? this.values[0] : series.length < 30 ? this.values[1] : this.values[2];
    }
  },*/
}, UO = {
  percentage: {
    values: ["<20", ">=20", ">=40", ">=60", ">=80", "100"],
    fn(t, e) {
      const r = (t.params[t.params.length - 1] - 1 - t.params[0]) / (e.length - 1);
      return this.values[Math.floor(r * 10 / 2)];
    }
  },
  /*percentage: {
    values: ['<80', '>=80', '100'],
    fn(cand: Candidate, series: Point[]) {
      // cand.params values (indices) are taken from sequence endpoints, which now look like
      // slices, so the final param value will always be 1 greater than the final
      // index of the final sequence.
      const pct = (cand.params[cand.params.length - 1]! - 1 - cand.params[0])/(series.length - 1);
      return pct === 1 ? this.values[2] : pct >= 0.8 ? this.values[1] : this.values[0];
    }
  },*/
  touchEnd: {
    values: ["yes", "no"],
    fn(t, e) {
      return t.params.at(-1) === e.length ? this.values[0] : this.values[1];
    }
  },
  lastLength: {
    values: ["<20", ">=20"],
    fn(t, e) {
      const r = t.params.length;
      return (t.params[r - 1] - 1 - t.params[r - 2]) / (e.length - 1) >= 0.2 ? this.values[1] : this.values[0];
    }
  },
  volatility: {
    values: ["low", "med", "high"],
    fn(t, e) {
      const r = e.points.map((o) => o.y), n = CE(r) - _E(r);
      if (n === 0)
        return this.values[0];
      let i = 0;
      for (let o = 0; o < t.params.length - 1; o++) {
        const a = o < t.params.length - 2 ? e.slice(t.params[o], t.params[o + 1] + 1) : e.slice(t.params[o], t.params[o + 1]);
        a.length > 2 && (i += 2 * Math.sqrt(a.bestFit.rss() / a.length) / n);
      }
      const s = i / (t.params.length - 1);
      return s < 0.1 ? this.values[0] : s < 0.3 ? this.values[1] : this.values[2];
    }
  },
  /*containsMinMax: {
    values: ['yes', 'no'],
    fn(cand: Candidate, series: Point[]) {
      const ys = series.map(p => p[1]);
      const min = Math.min(...ys);
      const max = Math.max(...ys);
      const candYs = ys.slice(cand.params[0], cand.params.at(-1)! + 1);
      return candYs.find(y => y === min || y === max) !== undefined ? this.values[0] : this.values[1];
    }
  },*/
  /*yScale: {
    values: ['<80', '>=80'],
    cats: ['BigJump', 'BigFall'],
    fn(cand: Candidate, series: Point[], chartRanges?: ChartRanges) {
      const ys = series.map(p => p[1]);
      const candYs = ys.slice(cand.params[0], cand.params.at(-1)!);
      const candYRange = Math.max(...candYs) - Math.min(...candYs);
      const chartYRange = chartRanges ? chartRanges.y : getChartRanges(series).y;
      const yScale = candYRange/(chartYRange[1] - chartYRange[0]);
      return yScale >= 0.8 ? this.values[1] : this.values[0];
    }     
  },*/
  yScale: {
    values: ["<20", ">=20", ">=40", ">=60", ">=80", "100"],
    fn(t, e, r = e.yBounds()) {
      const n = e.points.map((o) => o.y).slice(t.params[0], t.params.at(-1)), i = Math.max(...n) - Math.min(...n);
      if (i === 0)
        return this.values[0];
      const s = i / (r.end - r.start);
      return this.values[Math.floor(s * 10 / 2)];
    }
  },
  xDuration: {
    values: ["<25", ">=25"],
    cats: ["BigJump", "BigFall"],
    fn(t, e) {
      return (t.params.at(-1) - 1 - t.params[0]) / (e.length - 1) >= 0.25 ? this.values[1] : this.values[0];
    }
  },
  bigSlope: {
    values: ["<60", ">=60"],
    cats: ["BigJump", "BigFall"],
    fn(t, e, r) {
      const n = e.slice(t.params[0], t.params.at(-1));
      return Math.abs(yG(n, r)) >= 60 ? this.values[1] : this.values[0];
    }
  }
};
function vG(t, e) {
  const r = {};
  for (const [n, i] of Object.entries(zO))
    r[n] = i.fn(t, e);
  return r;
}
function bG(t, e, r) {
  const n = {};
  for (const [i, s] of Object.entries(UO))
    (s.cats === void 0 || s.cats.includes(t.category)) && (n[i] = s.fn(t, e, r));
  return n;
}
function wG(t) {
  const e = {};
  for (const r of t) {
    const n = r.category;
    e[n] || (e[n] = []), e[n].push(r);
  }
  return e;
}
let xG = class {
  constructor(e, r, n, i) {
    Ri(this, "cands"), Ri(this, "net", new fG()), Ri(this, "root"), Ri(this, "catNodes", {}), Ri(this, "hasSugNodes", {}), Ri(this, "candNodes", {}), Ri(this, "genEvidNodes", {}), Ri(this, "candEvidNodes", {}), this.msgEx = e, this.line = r, this.yAxis = i, this.cands = wG(n), this.root = this.net.newNode("root", this.msgEx.cats), this.root.setCpt(this.msgEx.catPriors);
  }
  build() {
    this.createGeneralEvidenceNodes(), this.createCategoryNodes();
    for (const e of this.msgEx.cats) {
      const r = this.net.newNode(`${e}.hasSug`, ["true", "false"]);
      this.hasSugNodes[e] = r, r.addParent(e);
      const n = this.msgEx.catPHasSug[e];
      r.setCpt([
        [1, 0],
        // p(hasSug=T|cat=T), p(hasSug=F|cat=T)
        [n, 1 - n]
        // p(hasSug=T|cat=F), p(hasSug=F|cat=F) 
      ]);
    }
    for (const e of Object.keys(this.cands).sort()) {
      this.createCandidateNodes(e);
      const r = this.candNodes[e];
      this.candEvidNodes[e] = [];
      for (let n = 0; n < r.length; n++)
        this.createCandidateEvidenceNodes(e, n);
    }
  }
  createGeneralEvidenceNodes() {
    for (const [e, r] of Object.entries(zO))
      this.genEvidNodes[e] = this.net.newNode(e, r.values);
    for (const [e, r] of Object.entries(this.genEvidNodes))
      r.addParent(this.root.name), r.setCpt([
        ...this.root.values.map((n) => r.values.map((i) => this.msgEx.catProbs[n].general.density[i]))
        // p(density=val|root=cat)
      ]);
  }
  createCategoryNodes() {
    for (const e of this.msgEx.cats) {
      const r = this.net.newNode(e, ["true", "false"]);
      r.addParent(this.root.name), r.setCpt(this.msgEx.cats.map((n) => n === e ? [1, 0] : [0, 1])), this.catNodes[e] = r;
    }
  }
  createCandidateNodes(e) {
    const r = [];
    this.catNodes[e];
    const n = this.cands[e];
    for (let i = 0; i < n.length; i++) {
      n[i];
      const s = this.net.newNode(`${e}.cand${i}`, ["true", "false"]);
      r.push(s), s.addParent(e);
      for (let l = 0; l < i; l++)
        s.addParent(r[l].name);
      const o = [], a = 2 ** s.parents.length;
      for (let l = 0; l < a; l++)
        l === a / 2 - 1 ? o.push([
          // I'm making the assumption that, given no evidence,
          // all candidates for a particular message are equally likely
          // (given that message=T)
          1 / (n.length - i),
          (n.length - (i + 1)) / (n.length - i)
        ]) : o.push([0, 1]);
      s.setCpt(o);
    }
    this.candNodes[e] = r;
  }
  createCandidateEvidenceNodes(e, r) {
    const n = this.candNodes[e][r], i = {};
    for (const [s, o] of Object.entries(UO))
      (o.cats === void 0 || o.cats.includes(e)) && (i[s] = this.net.newNode(`${e}.cand${r}.${s}`, o.values));
    for (const [s, o] of Object.entries(i)) {
      o.addParent(n.name);
      const a = this.msgEx.catProbs[e].cand[s];
      o.setCpt([
        o.values.map((l) => a[l][0]),
        // p(evid=val|inPlan)
        o.values.map((l) => a[l][1])
        // p(evid=val|notInPlan)
      ]);
    }
    this.candEvidNodes[e].push(i);
  }
  observeEvidence() {
    var e;
    for (const n of this.msgEx.cats)
      this.hasSugNodes[n].observe(this.cands[n] ? "true" : "false"), (e = this.candEvidNodes[n]) == null || e.forEach((i, s) => {
        const o = this.cands[n][s], a = bG(o, this.line, this.yAxis);
        for (const [l, c] of Object.entries(i))
          c.observe(a[l]);
      });
    const r = vG(this.line, this.yAxis);
    for (const [n, i] of Object.entries(this.genEvidNodes))
      i.observe(r[n]);
  }
  async updateProbs(e = !0) {
    e ? await this.net.sampleWithWorker(1e4) : this.net.sample(1e4);
  }
  getSelectedCat() {
    let e = 0, r = 0;
    const n = this.root.probs();
    for (let i = 0; i < this.root.values.length; i++)
      n[i] > e && (e = n[i], r = i);
    return this.root.values[r];
  }
  getSelectedCand(e) {
    const r = this.candNodes[e];
    if (r === void 0)
      return;
    let n = 0, i = 0;
    for (let s = 0; s < r.length; s++) {
      const o = r[s].probs();
      o[0] > n && (n = o[0], i = s);
    }
    return i;
  }
  getPrediction() {
    const e = this.getSelectedCat(), r = this.getSelectedCand(e);
    if (r !== void 0)
      return { cand: this.cands[e][r], idx: r };
  }
}, EG = class {
  /**
   * @param model - Optional statistical data used by the Bayesian network (or ID thereof)
   */
  constructor(e) {
    if (Ri(this, "modelData"), Ri(this, "cats"), Ri(this, "catPriors"), Ri(this, "catPHasSug"), Ri(this, "catProbs"), typeof e == "string" || e === void 0) {
      const r = AG(e);
      if (!r)
        throw new Error(`unknown model ID '${e}'`);
      this.modelData = r;
    } else
      this.modelData = e;
    this.cats = Object.keys(this.modelData).sort(), this.catPriors = this.cats.map((r) => this.modelData[r].prior), this.catPHasSug = Object.fromEntries(this.cats.map((r) => [r, this.modelData[r].hasSug])), this.catProbs = Object.fromEntries(this.cats.map((r) => [r, this.modelData[r].probs]));
  }
  /**
   * Select the most likely (i.e., most important section) of a line.
   * @param line - Line to analyze (in its original coordinate system)
   * @param candidates - All candidate messages (as generated by 
   * chart-message-candidates#genCandidates())
   * @param yAxis - Optional displayed chart y-axis value range;
   * defaults to extreme values of data
   * @param useWorker - Do prediction in a Web Worker
   * @returns Selected candidate object and index of said candidate with
   * respect to all candidates of its type, or undefined if the model
   * failed to make a valid prediction.
   * @remarks
   * The machine learning analysis performed by this method is now
   * offloaded to a worker thread, so the result can be usefully obtained
   * asynchronously via a `.then()` callback on the returned promise.
   */
  async chooseMessage(e, r, n, i = !0) {
    if (r.length === 1)
      return { cand: r[0], idx: 0 };
    const s = new xG(this, e, r, n);
    return s.build(), s.observeEvidence(), await s.updateProbs(i), s.getPrediction();
  }
  /*buildNet(series: number[], candidates: Candidate[]) {
    const net = new BayesNet(this, series, candidates);
    net.build();
    return net;
  }*/
  /*netToTree(net: JGraph): TreeNode {
    const nodes: {[index: string]: TreeNode} = {};
    function newTreeNode(jnode: JNode) {
      const tn: TreeNode = {
        name: jnode.name,
        prob: 0
      };
      if (jnode.values[0] === 'true') {
        tn.values = jnode.values;
        tn.prob = jnode.probs();
      } else {
        tn.values = jnode.values;
        tn.prob = jnode.probs();
      }
      return tn;
    }
    for (const node of net.nodes) {
      if (node.name === 'TempJump') {
        console.log('TempJump', node, node.probs());
      }
      if (!nodes[node.name]) {
        nodes[node.name] = newTreeNode(node);
      }
      const treeNode = nodes[node.name];
      for (const p of node.parents) {
        if (!nodes[p.name]) {
          nodes[p.name] = newTreeNode(p);
        }
        if (!nodes[p.name].children) {
          nodes[p.name].children = [];
        }
        nodes[p.name].children!.push(treeNode);
      }
    }
    return nodes['root'];
  }*/
};
const VO = {
  "18b7ef6b98c": {
    trainDataName: "cm3_reconc_jf",
    model: {
      Rise: {
        prior: 0.05333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.8125,
                0
              ],
              "<20": [
                0,
                0.4180790960451977
              ],
              ">=20": [
                0.125,
                0.3220338983050847
              ],
              ">=40": [
                0,
                0.14689265536723164
              ],
              ">=60": [
                0.0625,
                0.0847457627118644
              ],
              ">=80": [
                0,
                0.02824858757062147
              ]
            },
            touchEnd: {
              yes: [
                0.9375,
                0.2514124293785311
              ],
              no: [
                0.0625,
                0.748587570621469
              ]
            },
            lastLength: {
              "<20": [
                0,
                0.4180790960451977
              ],
              ">=20": [
                1,
                0.5819209039548022
              ]
            },
            volatility: {
              low: [
                0.3125,
                0.5084745762711864
              ],
              med: [
                0.6875,
                0.423728813559322
              ],
              high: [
                0,
                0.06779661016949153
              ]
            },
            yScale: {
              100: [
                0.4375,
                0.0480225988700565
              ],
              "<20": [
                0,
                0.17231638418079095
              ],
              ">=20": [
                0.0625,
                0.2570621468926554
              ],
              ">=40": [
                0.3125,
                0.268361581920904
              ],
              ">=60": [
                0.125,
                0.12146892655367232
              ],
              ">=80": [
                0.0625,
                0.1327683615819209
              ]
            }
          }
        },
        hasSug: 0.7640845070422535
      },
      Fall: {
        prior: 0.07,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.7619047619047619,
                0.005633802816901409
              ],
              "<20": [
                0,
                0.4788732394366197
              ],
              ">=20": [
                0.09523809523809523,
                0.27323943661971833
              ],
              ">=40": [
                0.09523809523809523,
                0.14366197183098592
              ],
              ">=60": [
                0,
                0.05352112676056338
              ],
              ">=80": [
                0.047619047619047616,
                0.04507042253521127
              ]
            },
            touchEnd: {
              yes: [
                0.9523809523809523,
                0.2619718309859155
              ],
              no: [
                0.047619047619047616,
                0.7380281690140845
              ]
            },
            lastLength: {
              "<20": [
                0,
                0.4788732394366197
              ],
              ">=20": [
                1,
                0.5211267605633803
              ]
            },
            volatility: {
              low: [
                0.3333333333333333,
                0.5183098591549296
              ],
              med: [
                0.5714285714285714,
                0.38591549295774646
              ],
              high: [
                0.09523809523809523,
                0.09577464788732394
              ]
            },
            yScale: {
              100: [
                0.5714285714285714,
                0.07323943661971831
              ],
              "<20": [
                0,
                0.17746478873239438
              ],
              ">=20": [
                0.09523809523809523,
                0.29014084507042254
              ],
              ">=40": [
                0.23809523809523808,
                0.23380281690140844
              ],
              ">=60": [
                0.047619047619047616,
                0.11549295774647887
              ],
              ">=80": [
                0.047619047619047616,
                0.10985915492957747
              ]
            }
          }
        },
        hasSug: 0.8028673835125448
      },
      Stable: {
        prior: 0.03333333333333333,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.5,
                0
              ],
              "<20": [
                0,
                0.12962962962962962
              ],
              ">=20": [
                0.2,
                0.2962962962962963
              ],
              ">=40": [
                0,
                0.3194444444444444
              ],
              ">=60": [
                0.2,
                0.14351851851851852
              ],
              ">=80": [
                0.1,
                0.1111111111111111
              ]
            },
            touchEnd: {
              yes: [
                1,
                0.48148148148148145
              ],
              no: [
                0,
                0.5185185185185185
              ]
            },
            lastLength: {
              "<20": [
                0,
                0.12962962962962962
              ],
              ">=20": [
                1,
                0.8703703703703703
              ]
            },
            volatility: {
              low: [
                0.5,
                0.5972222222222222
              ],
              med: [
                0,
                0.37037037037037035
              ],
              high: [
                0.5,
                0.032407407407407406
              ]
            },
            yScale: {
              100: [
                0,
                0.004629629629629629
              ],
              "<20": [
                0.5,
                0.7870370370370371
              ],
              ">=20": [
                0.2,
                0.17592592592592593
              ],
              ">=40": [
                0.3,
                0.027777777777777776
              ],
              ">=60": [
                0,
                0.004629629629629629
              ],
              ">=80": [
                0,
                0
              ]
            }
          }
        },
        hasSug: 0.6206896551724138
      },
      BigJump: {
        prior: 0.006666666666666667,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0
              ],
              "<20": [
                1,
                0.4431818181818182
              ],
              ">=20": [
                0,
                0.32954545454545453
              ],
              ">=40": [
                0,
                0.12878787878787878
              ],
              ">=60": [
                0,
                0.06439393939393939
              ],
              ">=80": [
                0,
                0.03409090909090909
              ]
            },
            touchEnd: {
              yes: [
                0,
                0
              ],
              no: [
                1,
                1
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.4431818181818182
              ],
              ">=20": [
                0,
                0.5568181818181818
              ]
            },
            volatility: {
              low: [
                1,
                0.4659090909090909
              ],
              med: [
                0,
                0.45454545454545453
              ],
              high: [
                0,
                0.07954545454545454
              ]
            },
            yScale: {
              100: [
                0,
                0.06439393939393939
              ],
              "<20": [
                0,
                0.125
              ],
              ">=20": [
                0,
                0.26515151515151514
              ],
              ">=40": [
                0,
                0.2840909090909091
              ],
              ">=60": [
                0,
                0.14393939393939395
              ],
              ">=80": [
                1,
                0.11742424242424243
              ]
            },
            xDuration: {
              "<25": [
                1,
                0.5984848484848485
              ],
              ">=25": [
                0,
                0.4015151515151515
              ]
            },
            bigSlope: {
              "<60": [
                1,
                0.4734848484848485
              ],
              ">=60": [
                0,
                0.5265151515151515
              ]
            }
          }
        },
        hasSug: 0.6442953020134228
      },
      BigFall: {
        prior: 0.02666666666666667,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0
              ],
              "<20": [
                0.75,
                0.5568627450980392
              ],
              ">=20": [
                0.25,
                0.2549019607843137
              ],
              ">=40": [
                0,
                0.13725490196078433
              ],
              ">=60": [
                0,
                0.03529411764705882
              ],
              ">=80": [
                0,
                0.01568627450980392
              ]
            },
            touchEnd: {
              yes: [
                0,
                0
              ],
              no: [
                1,
                1
              ]
            },
            lastLength: {
              "<20": [
                0.75,
                0.5568627450980392
              ],
              ">=20": [
                0.25,
                0.44313725490196076
              ]
            },
            volatility: {
              low: [
                0.5,
                0.47058823529411764
              ],
              med: [
                0.25,
                0.41568627450980394
              ],
              high: [
                0.25,
                0.11372549019607843
              ]
            },
            yScale: {
              100: [
                0.375,
                0.0784313725490196
              ],
              "<20": [
                0,
                0.09019607843137255
              ],
              ">=20": [
                0,
                0.3137254901960784
              ],
              ">=40": [
                0,
                0.25098039215686274
              ],
              ">=60": [
                0,
                0.1411764705882353
              ],
              ">=80": [
                0.625,
                0.12549019607843137
              ]
            },
            xDuration: {
              "<25": [
                0.875,
                0.6627450980392157
              ],
              ">=25": [
                0.125,
                0.33725490196078434
              ]
            },
            bigSlope: {
              "<60": [
                0.5,
                0.5294117647058824
              ],
              ">=60": [
                0.5,
                0.47058823529411764
              ]
            }
          }
        },
        hasSug: 0.6506849315068494
      },
      ReversalToRise: {
        prior: 0.07,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.3333333333333333,
                0.03289473684210526
              ],
              "<20": [
                0.047619047619047616,
                0.125
              ],
              ">=20": [
                0.2857142857142857,
                0.375
              ],
              ">=40": [
                0.09523809523809523,
                0.2565789473684211
              ],
              ">=60": [
                0.047619047619047616,
                0.16447368421052633
              ],
              ">=80": [
                0.19047619047619047,
                0.046052631578947366
              ]
            },
            touchEnd: {
              yes: [
                0.5238095238095238,
                0.32894736842105265
              ],
              no: [
                0.47619047619047616,
                0.6710526315789473
              ]
            },
            lastLength: {
              "<20": [
                0.3333333333333333,
                0.5263157894736842
              ],
              ">=20": [
                0.6666666666666666,
                0.47368421052631576
              ]
            },
            volatility: {
              low: [
                0.3333333333333333,
                0.48026315789473684
              ],
              med: [
                0.5238095238095238,
                0.5131578947368421
              ],
              high: [
                0.14285714285714285,
                0.006578947368421052
              ]
            },
            yScale: {
              100: [
                0.2857142857142857,
                0.15789473684210525
              ],
              "<20": [
                0,
                0.006578947368421052
              ],
              ">=20": [
                0.09523809523809523,
                0.2236842105263158
              ],
              ">=40": [
                0.3333333333333333,
                0.26973684210526316
              ],
              ">=60": [
                0.09523809523809523,
                0.19736842105263158
              ],
              ">=80": [
                0.19047619047619047,
                0.14473684210526316
              ]
            }
          }
        },
        hasSug: 0.4014336917562724
      },
      ReversalToFall: {
        prior: 0.07,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.42857142857142855,
                0.047337278106508875
              ],
              "<20": [
                0.14285714285714285,
                0.11242603550295859
              ],
              ">=20": [
                0.09523809523809523,
                0.38461538461538464
              ],
              ">=40": [
                0.14285714285714285,
                0.27218934911242604
              ],
              ">=60": [
                0.09523809523809523,
                0.13609467455621302
              ],
              ">=80": [
                0.09523809523809523,
                0.047337278106508875
              ]
            },
            touchEnd: {
              yes: [
                0.6666666666666666,
                0.23076923076923078
              ],
              no: [
                0.3333333333333333,
                0.7692307692307693
              ]
            },
            lastLength: {
              "<20": [
                0.23809523809523808,
                0.6035502958579881
              ],
              ">=20": [
                0.7619047619047619,
                0.39644970414201186
              ]
            },
            volatility: {
              low: [
                0.2857142857142857,
                0.4378698224852071
              ],
              med: [
                0.6666666666666666,
                0.5325443786982249
              ],
              high: [
                0.047619047619047616,
                0.029585798816568046
              ]
            },
            yScale: {
              100: [
                0.23809523809523808,
                0.13609467455621302
              ],
              "<20": [
                0,
                0.01775147928994083
              ],
              ">=20": [
                0.14285714285714285,
                0.1952662721893491
              ],
              ">=40": [
                0.3333333333333333,
                0.3136094674556213
              ],
              ">=60": [
                0.09523809523809523,
                0.1952662721893491
              ],
              ">=80": [
                0.19047619047619047,
                0.14201183431952663
              ]
            }
          }
        },
        hasSug: 0.44802867383512546
      },
      EmergingRise: {
        prior: 0.09333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.75,
                0.027777777777777776
              ],
              "<20": [
                0,
                0.08333333333333333
              ],
              ">=20": [
                0,
                0.25
              ],
              ">=40": [
                0.10714285714285714,
                0.3611111111111111
              ],
              ">=60": [
                0.10714285714285714,
                0.25
              ],
              ">=80": [
                0.03571428571428571,
                0.027777777777777776
              ]
            },
            touchEnd: {
              yes: [
                0.9642857142857143,
                0.08333333333333333
              ],
              no: [
                0.03571428571428571,
                0.9166666666666666
              ]
            },
            lastLength: {
              "<20": [
                0.07142857142857142,
                0.5555555555555556
              ],
              ">=20": [
                0.9285714285714286,
                0.4444444444444444
              ]
            },
            volatility: {
              low: [
                0.7142857142857143,
                0.5
              ],
              med: [
                0.2857142857142857,
                0.4722222222222222
              ],
              high: [
                0,
                0.027777777777777776
              ]
            },
            yScale: {
              100: [
                0.35714285714285715,
                0.1111111111111111
              ],
              "<20": [
                0,
                0.05555555555555555
              ],
              ">=20": [
                0.10714285714285714,
                0.16666666666666666
              ],
              ">=40": [
                0.42857142857142855,
                0.25
              ],
              ">=60": [
                0.03571428571428571,
                0.19444444444444445
              ],
              ">=80": [
                0.07142857142857142,
                0.2222222222222222
              ]
            }
          }
        },
        hasSug: 0.11397058823529412
      },
      EmergingFall: {
        prior: 0.05333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.4375,
                0
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.0625,
                0.16129032258064516
              ],
              ">=40": [
                0.1875,
                0.41935483870967744
              ],
              ">=60": [
                0.0625,
                0.22580645161290322
              ],
              ">=80": [
                0.25,
                0.1935483870967742
              ]
            },
            touchEnd: {
              yes: [
                0.875,
                0.1935483870967742
              ],
              no: [
                0.125,
                0.8064516129032258
              ]
            },
            lastLength: {
              "<20": [
                0.1875,
                0.6451612903225806
              ],
              ">=20": [
                0.8125,
                0.3548387096774194
              ]
            },
            volatility: {
              low: [
                0.5,
                0.5483870967741935
              ],
              med: [
                0.5,
                0.45161290322580644
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.125,
                0.22580645161290322
              ],
              "<20": [
                0,
                0.0967741935483871
              ],
              ">=20": [
                0.3125,
                0.22580645161290322
              ],
              ">=40": [
                0.375,
                0.25806451612903225
              ],
              ">=60": [
                0.125,
                0.0967741935483871
              ],
              ">=80": [
                0.0625,
                0.0967741935483871
              ]
            }
          }
        },
        hasSug: 0.1056338028169014
      },
      RiseToStable: {
        prior: 0.07333333333333333,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.45454545454545453,
                0.05263157894736842
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.045454545454545456,
                0.3157894736842105
              ],
              ">=40": [
                0.09090909090909091,
                0.34210526315789475
              ],
              ">=60": [
                0.13636363636363635,
                0.15789473684210525
              ],
              ">=80": [
                0.2727272727272727,
                0.13157894736842105
              ]
            },
            touchEnd: {
              yes: [
                0.9090909090909091,
                0.4473684210526316
              ],
              no: [
                0.09090909090909091,
                0.5526315789473685
              ]
            },
            lastLength: {
              "<20": [
                0.045454545454545456,
                0.23684210526315788
              ],
              ">=20": [
                0.9545454545454546,
                0.7631578947368421
              ]
            },
            volatility: {
              low: [
                0.5,
                0.631578947368421
              ],
              med: [
                0.5,
                0.3684210526315789
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.22727272727272727,
                0.10526315789473684
              ],
              "<20": [
                0.045454545454545456,
                0.05263157894736842
              ],
              ">=20": [
                0.13636363636363635,
                0.34210526315789475
              ],
              ">=40": [
                0.36363636363636365,
                0.3157894736842105
              ],
              ">=60": [
                0.13636363636363635,
                0.10526315789473684
              ],
              ">=80": [
                0.09090909090909091,
                0.07894736842105263
              ]
            }
          }
        },
        hasSug: 0.12589928057553956
      },
      FallToStable: {
        prior: 0.17333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.4807692307692308,
                0.16666666666666666
              ],
              "<20": [
                0,
                0.027777777777777776
              ],
              ">=20": [
                0,
                0.19444444444444445
              ],
              ">=40": [
                0.057692307692307696,
                0.2777777777777778
              ],
              ">=60": [
                0.19230769230769232,
                0.19444444444444445
              ],
              ">=80": [
                0.2692307692307692,
                0.1388888888888889
              ]
            },
            touchEnd: {
              yes: [
                0.9807692307692307,
                0.5833333333333334
              ],
              no: [
                0.019230769230769232,
                0.4166666666666667
              ]
            },
            lastLength: {
              "<20": [
                0.019230769230769232,
                0.1111111111111111
              ],
              ">=20": [
                0.9807692307692307,
                0.8888888888888888
              ]
            },
            volatility: {
              low: [
                0.3269230769230769,
                0.6111111111111112
              ],
              med: [
                0.6730769230769231,
                0.3611111111111111
              ],
              high: [
                0,
                0.027777777777777776
              ]
            },
            yScale: {
              100: [
                0.25,
                0.19444444444444445
              ],
              "<20": [
                0,
                0.08333333333333333
              ],
              ">=20": [
                0.15384615384615385,
                0.3055555555555556
              ],
              ">=40": [
                0.4423076923076923,
                0.16666666666666666
              ],
              ">=60": [
                0.11538461538461539,
                0.1388888888888889
              ],
              ">=80": [
                0.038461538461538464,
                0.1111111111111111
              ]
            }
          }
        },
        hasSug: 0.14112903225806453
      },
      Rebound: {
        prior: 0.10333333333333333,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.22580645161290322,
                0.09090909090909091
              ],
              "<20": [
                0,
                0.015151515151515152
              ],
              ">=20": [
                0.06451612903225806,
                0.22727272727272727
              ],
              ">=40": [
                0.16129032258064516,
                0.3333333333333333
              ],
              ">=60": [
                0.3225806451612903,
                0.24242424242424243
              ],
              ">=80": [
                0.22580645161290322,
                0.09090909090909091
              ]
            },
            touchEnd: {
              yes: [
                0.6774193548387096,
                0.3333333333333333
              ],
              no: [
                0.3225806451612903,
                0.6666666666666666
              ]
            },
            lastLength: {
              "<20": [
                0.2903225806451613,
                0.6515151515151515
              ],
              ">=20": [
                0.7096774193548387,
                0.3484848484848485
              ]
            },
            volatility: {
              low: [
                0.5483870967741935,
                0.42424242424242425
              ],
              med: [
                0.45161290322580644,
                0.5606060606060606
              ],
              high: [
                0,
                0.015151515151515152
              ]
            },
            yScale: {
              100: [
                0.3548387096774194,
                0.2878787878787879
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.10606060606060606
              ],
              ">=40": [
                0.2903225806451613,
                0.25757575757575757
              ],
              ">=60": [
                0.16129032258064516,
                0.16666666666666666
              ],
              ">=80": [
                0.1935483870967742,
                0.18181818181818182
              ]
            }
          }
        },
        hasSug: 0.17472118959107807
      },
      TemporaryJump: {
        prior: 0.056666666666666664,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.35294117647058826,
                0.09230769230769231
              ],
              "<20": [
                0,
                0.046153846153846156
              ],
              ">=20": [
                0.11764705882352941,
                0.2153846153846154
              ],
              ">=40": [
                0.17647058823529413,
                0.3384615384615385
              ],
              ">=60": [
                0.058823529411764705,
                0.16923076923076924
              ],
              ">=80": [
                0.29411764705882354,
                0.13846153846153847
              ]
            },
            touchEnd: {
              yes: [
                0.8823529411764706,
                0.26153846153846155
              ],
              no: [
                0.11764705882352941,
                0.7384615384615385
              ]
            },
            lastLength: {
              "<20": [
                0.23529411764705882,
                0.6153846153846154
              ],
              ">=20": [
                0.7647058823529411,
                0.38461538461538464
              ]
            },
            volatility: {
              low: [
                0.4117647058823529,
                0.4153846153846154
              ],
              med: [
                0.5882352941176471,
                0.5538461538461539
              ],
              high: [
                0,
                0.03076923076923077
              ]
            },
            yScale: {
              100: [
                0.47058823529411764,
                0.3076923076923077
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.12307692307692308
              ],
              ">=40": [
                0.17647058823529413,
                0.2
              ],
              ">=60": [
                0.23529411764705882,
                0.12307692307692308
              ],
              ">=80": [
                0.11764705882352941,
                0.24615384615384617
              ]
            }
          }
        },
        hasSug: 0.16607773851590105
      },
      PossibleReversalToRise: {
        prior: 0.013333333333333334,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.25,
                0.19298245614035087
              ],
              "<20": [
                0.25,
                0.05263157894736842
              ],
              ">=20": [
                0.25,
                0.2631578947368421
              ],
              ">=40": [
                0,
                0.2807017543859649
              ],
              ">=60": [
                0.25,
                0.10526315789473684
              ],
              ">=80": [
                0,
                0.10526315789473684
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                0.75,
                0.3684210526315789
              ],
              ">=20": [
                0.25,
                0.631578947368421
              ]
            },
            volatility: {
              low: [
                0.75,
                0.5087719298245614
              ],
              med: [
                0.25,
                0.45614035087719296
              ],
              high: [
                0,
                0.03508771929824561
              ]
            },
            yScale: {
              100: [
                0,
                0.10526315789473684
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.25,
                0.21052631578947367
              ],
              ">=40": [
                0.5,
                0.3684210526315789
              ],
              ">=60": [
                0.25,
                0.2631578947368421
              ],
              ">=80": [
                0,
                0.05263157894736842
              ]
            }
          }
        },
        hasSug: 0.19256756756756757
      },
      PossibleReversalToFall: {
        prior: 0.02,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                1,
                0.23404255319148937
              ],
              "<20": [
                0,
                0.02127659574468085
              ],
              ">=20": [
                0,
                0.2553191489361702
              ],
              ">=40": [
                0,
                0.2553191489361702
              ],
              ">=60": [
                0,
                0.1276595744680851
              ],
              ">=80": [
                0,
                0.10638297872340426
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                0.8333333333333334,
                0.23404255319148937
              ],
              ">=20": [
                0.16666666666666666,
                0.7659574468085106
              ]
            },
            volatility: {
              low: [
                0.6666666666666666,
                0.48936170212765956
              ],
              med: [
                0.3333333333333333,
                0.5106382978723404
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.16666666666666666,
                0.19148936170212766
              ],
              "<20": [
                0,
                0.02127659574468085
              ],
              ">=20": [
                0,
                0.1702127659574468
              ],
              ">=40": [
                0.6666666666666666,
                0.40425531914893614
              ],
              ">=60": [
                0.16666666666666666,
                0.14893617021276595
              ],
              ">=80": [
                0,
                0.06382978723404255
              ]
            }
          }
        },
        hasSug: 0.1598639455782313
      },
      PossibleEmergingRise: {
        prior: 0.0033333333333333335,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0.7586206896551724
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0
              ],
              ">=40": [
                0,
                0.13793103448275862
              ],
              ">=60": [
                1,
                0.06896551724137931
              ],
              ">=80": [
                0,
                0.034482758620689655
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.06896551724137931
              ],
              ">=20": [
                0,
                0.9310344827586207
              ]
            },
            volatility: {
              low: [
                1,
                0.7241379310344828
              ],
              med: [
                0,
                0.2413793103448276
              ],
              high: [
                0,
                0.034482758620689655
              ]
            },
            yScale: {
              100: [
                0,
                0.3793103448275862
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                1,
                0.10344827586206896
              ],
              ">=40": [
                0,
                0.4482758620689655
              ],
              ">=60": [
                0,
                0.034482758620689655
              ],
              ">=80": [
                0,
                0.034482758620689655
              ]
            }
          }
        },
        hasSug: 0.09698996655518395
      },
      PossibleEmergingFall: {
        prior: 0.006666666666666667,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0,
                0.3888888888888889
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.5,
                0.05555555555555555
              ],
              ">=40": [
                0,
                0.2777777777777778
              ],
              ">=60": [
                0,
                0.1111111111111111
              ],
              ">=80": [
                0.5,
                0.16666666666666666
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.2222222222222222
              ],
              ">=20": [
                0,
                0.7777777777777778
              ]
            },
            volatility: {
              low: [
                1,
                0.6666666666666666
              ],
              med: [
                0,
                0.3333333333333333
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0,
                0.1111111111111111
              ],
              "<20": [
                0.5,
                0.1111111111111111
              ],
              ">=20": [
                0.5,
                0.2777777777777778
              ],
              ">=40": [
                0,
                0.2777777777777778
              ],
              ">=60": [
                0,
                0.16666666666666666
              ],
              ">=80": [
                0,
                0.05555555555555555
              ]
            }
          }
        },
        hasSug: 0.06040268456375839
      },
      PossibleRiseToStable: {
        prior: 0.01,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.3333333333333333,
                0.3235294117647059
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.17647058823529413
              ],
              ">=40": [
                0.3333333333333333,
                0.17647058823529413
              ],
              ">=60": [
                0,
                0.20588235294117646
              ],
              ">=80": [
                0.3333333333333333,
                0.11764705882352941
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                0.3333333333333333,
                0.14705882352941177
              ],
              ">=20": [
                0.6666666666666666,
                0.8529411764705882
              ]
            },
            volatility: {
              low: [
                0.6666666666666666,
                0.5294117647058824
              ],
              med: [
                0.3333333333333333,
                0.47058823529411764
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.3333333333333333,
                0.17647058823529413
              ],
              "<20": [
                0,
                0.029411764705882353
              ],
              ">=20": [
                0.3333333333333333,
                0.20588235294117646
              ],
              ">=40": [
                0,
                0.38235294117647056
              ],
              ">=60": [
                0.3333333333333333,
                0.08823529411764706
              ],
              ">=80": [
                0,
                0.11764705882352941
              ]
            }
          }
        },
        hasSug: 0.11447811447811448
      },
      PossibleFallToStable: {
        prior: 0.0033333333333333335,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                1,
                0.4225352112676056
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.028169014084507043
              ],
              ">=40": [
                0,
                0.11267605633802817
              ],
              ">=60": [
                0,
                0.18309859154929578
              ],
              ">=80": [
                0,
                0.2535211267605634
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.04225352112676056
              ],
              ">=20": [
                0,
                0.9577464788732394
              ]
            },
            volatility: {
              low: [
                1,
                0.4084507042253521
              ],
              med: [
                0,
                0.5774647887323944
              ],
              high: [
                0,
                0.014084507042253521
              ]
            },
            yScale: {
              100: [
                1,
                0.2535211267605634
              ],
              "<20": [
                0,
                0.028169014084507043
              ],
              ">=20": [
                0,
                0.19718309859154928
              ],
              ">=40": [
                0,
                0.36619718309859156
              ],
              ">=60": [
                0,
                0.11267605633802817
              ],
              ">=80": [
                0,
                0.04225352112676056
              ]
            }
          }
        },
        hasSug: 0.23745819397993312
      },
      PossibleRebound: {
        prior: 0.043333333333333335,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.23076923076923078,
                0.3333333333333333
              ],
              "<20": [
                0.07692307692307693,
                0
              ],
              ">=20": [
                0.15384615384615385,
                0.06666666666666667
              ],
              ">=40": [
                0.38461538461538464,
                0.23333333333333334
              ],
              ">=60": [
                0.15384615384615385,
                0.16666666666666666
              ],
              ">=80": [
                0,
                0.2
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.23333333333333334
              ],
              ">=20": [
                0,
                0.7666666666666667
              ]
            },
            volatility: {
              low: [
                0.38461538461538464,
                0.5666666666666667
              ],
              med: [
                0.6153846153846154,
                0.43333333333333335
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.15384615384615385,
                0.3
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.07692307692307693,
                0.03333333333333333
              ],
              ">=40": [
                0.15384615384615385,
                0.3333333333333333
              ],
              ">=60": [
                0.46153846153846156,
                0.16666666666666666
              ],
              ">=80": [
                0.15384615384615385,
                0.16666666666666666
              ]
            }
          }
        },
        hasSug: 0.10452961672473868
      },
      PossibleTemporaryJump: {
        prior: 0.016666666666666666,
        probs: {
          general: {},
          cand: {
            percentage: {
              100: [
                0.2,
                0.4074074074074074
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0.2,
                0.037037037037037035
              ],
              ">=40": [
                0,
                0.2222222222222222
              ],
              ">=60": [
                0.4,
                0.07407407407407407
              ],
              ">=80": [
                0.2,
                0.25925925925925924
              ]
            },
            touchEnd: {
              yes: [
                1,
                1
              ],
              no: [
                0,
                0
              ]
            },
            lastLength: {
              "<20": [
                1,
                0.2222222222222222
              ],
              ">=20": [
                0,
                0.7777777777777778
              ]
            },
            volatility: {
              low: [
                0.2,
                0.5185185185185185
              ],
              med: [
                0.8,
                0.48148148148148145
              ],
              high: [
                0,
                0
              ]
            },
            yScale: {
              100: [
                0.4,
                0.5185185185185185
              ],
              "<20": [
                0,
                0
              ],
              ">=20": [
                0,
                0.037037037037037035
              ],
              ">=40": [
                0.6,
                0.14814814814814814
              ],
              ">=60": [
                0,
                0.14814814814814814
              ],
              ">=80": [
                0,
                0.14814814814814814
              ]
            }
          }
        },
        hasSug: 0.09152542372881356
      }
    }
  }
};
function SG() {
  return Object.keys(VO).sort();
}
function AG(t) {
  return VO[t ?? SG().at(-1)].model;
}
var kG = Object.defineProperty, _G = (t, e, r) => e in t ? kG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, u9 = (t, e, r) => (_G(t, typeof e != "symbol" ? e + "" : e, r), r);
function CG(t) {
  const e = t.points.map((i) => i.y), r = _E(e), n = CE(e);
  return {
    min: {
      value: r,
      labels: h9(t.points, r)
    },
    max: {
      value: n,
      labels: h9(t.points, n)
    },
    range: HO(t),
    mean: Wl(e),
    median: _H(e),
    mode: EH(e)
  };
}
function h9(t, e) {
  return t.filter((r) => r.y === e).map((r) => `${r.x}`);
}
function HO(t) {
  const e = t.points.map((r) => r.y);
  return CE(e) - _E(e);
}
function IG(t, e) {
  return (e.y - t.y) / (e.x - t.x);
}
function ry(t, e, r, n) {
  return n.range === 0 ? 1 : HO(t.slice(e, r)) / n.range;
}
function PG(t, e) {
  const r = Math.min(t.points[e].y, t.points[e + 1].y), n = t.points[e + 1].x - t.points[e].x, i = Math.max(t.points[e].y, t.points[e + 1].y) - r;
  return n * (r + 0.5 * i);
}
function ny(t, e, r, n) {
  if (e >= r)
    return 0;
  const i = t.slice(e, r), s = [];
  for (let A = 0; A < i.points.length; A++)
    s.push([i.points[A].x, i.points[A].y]);
  const o = 1 - bH(s, mH(kE(s))), a = [], l = [], c = i.yBounds().start, p = i.xBounds().start;
  for (let A = 0; A < i.points.length; A++)
    a.push((s[A][0] - p) * (i.points.length - 1) / i.xRange()), l.push((s[A][1] - c) / i.yRange());
  const h = [];
  for (let A = 1; A < s.length - 1; A++)
    h.push(((l[A + 1] - 2 * l[A] + l[A - 1]) / ((a[A] - a[A - 1]) * (a[A + 1] - a[A]))) ** 2);
  const d = h.reduce((A, x) => A + x, 0), v = i.length < 3 ? 0 : Math.atan(d / h.length) * 2 / Math.PI;
  let m = 0;
  for (let A = 0; A < s.length - 2; A++)
    (l[A + 2] - l[A + 1]) * (l[A + 1] - l[A]) < 0 && (m += 1);
  const b = m / (s.length - 2), f = Math.atan(i.length / 20) * 2 / Math.PI, E = [1 / 4, 1, 2, 3 / 4];
  return i.length < 3 ? 0 : (o * E[0] + v * E[1] + b * E[2] + f * E[3]) * i.yRange() / (4 * n.range);
}
function RG(t, e) {
  return t.slice(0, -1).points.map((r, n) => ({
    i: n,
    direction: Math.sign(IG(r, t.points[n + 1])) || 0,
    // convert any -0 to +0
    magnitude: ry(t, n, n + 2, e),
    area: PG(t, n)
  }));
}
function OG(t, e, r) {
  const n = [{ start: 0, direction: r[0].direction }];
  let i = n[0];
  for (let s = 1; s < r.length; s++) {
    const o = r[s].direction;
    o !== i.direction && (i.end = s + 1, i.magnitude = ry(t, i.start, i.end, e), i.volatility = ny(t, i.start, i.end, e), i.area = r.slice(i.start, i.end - 1).reduce((a, l) => a + l.area, 0), i = { start: s, direction: o }, n.push(i));
  }
  return i.end = r.length + 1, i.magnitude = ry(t, i.start, i.end, e), i.volatility = ny(t, i.start, i.end, e), i.area = r.slice(i.start, i.end - 1).reduce((s, o) => s + o.area, 0), n;
}
let TG = class {
  constructor() {
    u9(this, "bd"), u9(this, "mex"), this.bd = new QH(), this.mex = new EG();
  }
  /**
   * Perform all analysis of a time series.
   * @param series - Time series
   * @param opts - Options (optional)
   * @returns Results of the series analysis
   * @remarks
   * The message determination machine learning analysis performed by this 
   * method is now offloaded to a worker thread, so the result can be usefully 
   * obtained asynchronously via a `.then()` callback on the returned promise.
   */
  async analyzeSeries(e, r) {
    const n = CG(e), i = RG(e, n), s = OG(e, n, i), o = async (v, m) => {
      const b = this.bd.getSequences(v, m);
      rG(v, b);
      const { candidates: f, slopeInfo: E } = iG(
        v,
        b,
        r == null ? void 0 : r.candStableAngleCutoff,
        r != null && r.cm2Compat ? 10 : void 0,
        m
      );
      return { msg: await this.mex.chooseMessage(v, f, m, r == null ? void 0 : r.useWorker), seqBounds: b, slopeInfo: E };
    }, { msg: a, seqBounds: l, slopeInfo: c } = await o(e, r == null ? void 0 : r.yAxis), p = a ? a.cand.category : null, h = l.map((v, m) => ({
      start: v.start,
      end: v.end,
      slopeInfo: c[m],
      magnitude: ry(e, v.start, v.end, n),
      volatility: ny(e, v.start, v.end, n),
      area: i.slice(v.start, v.end - 1).reduce((b, f) => b + f.area, 0)
    }));
    if (h.length === 1)
      h[0].message = p, h[0].messageStart = a ? 0 : null, h[0].messageEnd = a ? e.length : null;
    else
      for (const v of h) {
        const { msg: m } = await o(e.slice(v.start, v.end), r == null ? void 0 : r.yAxis);
        m ? (v.message = m.cand.category, v.messageStart = v.start + m.cand.params[0], v.messageEnd = v.start + m.cand.params.at(-1)) : (v.message = null, v.messageStart = null, v.messageEnd = null);
      }
    let d = [];
    if (a) {
      const v = a.cand.params.slice(0, -1);
      d = Array.from(h.keys()).filter(
        (m) => v.includes(h[m].start)
      );
    }
    return {
      stats: n,
      volatility: ny(e, 0, e.length, n),
      area: i.reduce((v, m) => v + m.area, 0),
      message: p,
      messageSeqs: d,
      // will be [] if message === null
      segments: i,
      runs: s,
      sequences: h
    };
  }
};
function yr(t) {
  let e, r, n;
  return e = t, (i, s, o) => {
    if (o.value != null)
      o.value = p9(o.value, e, r, n);
    else if (o.get != null)
      o.get = p9(o.get, e, r, n);
    else
      throw "Only put a Memoize() decorator on a method or get accessor.";
  };
}
const lw = /* @__PURE__ */ new Map();
function p9(t, e, r = 0, n) {
  const i = Symbol("__memoized_map__");
  return function(...s) {
    let o;
    this.hasOwnProperty(i) || Object.defineProperty(this, i, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: /* @__PURE__ */ new Map()
    });
    let a = this[i];
    if (Array.isArray(n))
      for (const l of n)
        lw.has(l) ? lw.get(l).push(a) : lw.set(l, [a]);
    if (e || s.length > 0 || r > 0) {
      let l;
      e === !0 ? l = s.map((h) => h.toString()).join("!") : e ? l = e.apply(this, s) : l = s[0];
      const c = `${l}__timestamp`;
      let p = !1;
      if (r > 0)
        if (!a.has(c))
          p = !0;
        else {
          let h = a.get(c);
          p = Date.now() - h > r;
        }
      a.has(l) && !p ? o = a.get(l) : (o = t.apply(this, s), a.set(l, o), r > 0 && a.set(c, Date.now()));
    } else {
      const l = this;
      a.has(l) ? o = a.get(l) : (o = t.apply(this, s), a.set(l, o));
    }
    return o;
  };
}
var GO = (t) => {
  throw TypeError(t);
}, WO = (t, e, r) => e.has(t) || GO("Cannot " + r), d9 = (t, e, r) => (WO(t, e, "read from private field"), r ? r.call(t) : e.get(t)), f9 = (t, e, r) => e.has(t) ? GO("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), g9 = (t, e, r, n) => (WO(t, e, "write to private field"), e.set(t, r), r);
const iy = "[a-fA-F0-9]", pd = "[a-zA-Z0-9-._~]", Ys = "[!$&'()*+,;=]", Ch = `%${iy}${iy}`, Im = "(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])", RE = `${Im}\\.${Im}\\.${Im}\\.${Im}`, Tr = `${iy}{1,4}`, yu = `(?:${Tr}:${Tr}|${RE})`, LG = `(?:(?:${Tr}:){6}${yu}|::(?:${Tr}:){5}${yu}|(?:${Tr})?::(?:${Tr}:){4}${yu}|(?:(?:${Tr}:){0,1}${Tr})?::(?:${Tr}:){3}${yu}|(?:(?:${Tr}:){0,2}${Tr})?::(?:${Tr}:){2}${yu}|(?:(?:${Tr}:){0,3}${Tr})?::(?:${Tr}:){1}${yu}|(?:(?:${Tr}:){0,4}${Tr})?::${yu}|(?:(?:${Tr}:){0,5}${Tr})?::${Tr}|(?:(?:${Tr}:){0,6}${Tr})?::)`, MG = `v${iy}+\\.(?:${pd}|${Ys}|:)+`, qO = `\\[(?:${LG}|${MG})\\]`, dd = "(?<scheme>[a-zA-Z][a-zA-Z0-9-+.]*)", QO = ":(?<port>\\d*)", NG = `(?:${pd}|${Ch}|${Ys})*?`, DG = `(?<host>${qO}|${RE}|${NG})`, $G = `(?<userinfo>(?:${pd}|${Ch}|${Ys}|:)*)`, OE = `(?:${pd}|${Ch}|${Ys}|:|@)`, KO = `${OE}*?`, YO = `(?:/${KO})*`, TE = `(?<authority>(?:${$G}@)?${DG}(?:${QO})?)`, LE = `(?<path>${YO})`, ME = `(?<path2>${KO}${YO})`, NE = `(?:\\?(?<query>(?:${OE}|/|\\?)*))?`, ZO = `(?:#(?<fragment>(?:${OE}|/|\\?)*))?`, jG = `^${dd}:(?://${TE}${LE}|${ME})${NE}${ZO}$`, BG = `^(?:${dd}:|)(?://${TE}${LE}|${ME})${NE}${ZO}$`, FG = `^${dd}:(?://${TE}${LE}|${ME})${NE}$`, og = "[a-zA-Z0-9-._~\\00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF\\u10000-\\u1FFFD\\u20000-\\u2FFFD\\u30000-\\u3FFFD\\u40000-\\u4FFFD\\u50000-\\u5FFFD\\u60000-\\u6FFFD\\u70000-\\u7FFFD\\u80000-\\u8FFFD\\u90000-\\u9FFFD\\uA0000-\\uAFFFD\\uB0000-\\uBFFFD\\uC0000-\\uCFFFD\\uD0000-\\uDFFFD\\uE1000-\\uEFFFD]", zG = "[\\uE000-\\uF8FF\\uF0000-\\uFFFFD\\u100000-\\u10FFFD]", UG = `(?:${og}|${Ch}|${Ys})*?`, VG = `(?<host>${qO}|${RE}|${UG})`, HG = `(?<userinfo>(?:${og}|${Ch}|${Ys}|:)*)`, DE = `(?:${og}|${Ch}|${Ys}|:|@)`, JO = `${DE}*?`, XO = `(?:/${JO})*`, $E = `(?<authority>(?:${HG}@)?${VG}(?:${QO})?)`, jE = `(?<path>${XO})`, BE = `(?<path2>${JO}${XO})`, FE = `(?:\\?(?<query>(?:${DE}|${zG}|/|\\?)*))?`, eT = `(?:#(?<fragment>(?:${DE}|/|\\?)*))?`, tT = `^${dd}:(?://${$E}${jE}|${BE})${FE}${eT}$`, rT = `^(?:${dd}:|)(?://${$E}${jE}|${BE})${FE}${eT}$`, nT = `^${dd}:(?://${$E}${jE}|${BE})${FE}$`, GG = (t) => (e, r) => {
  const n = (
    /** @type IdentifierComponents */
    t.parseReference(e)
  );
  if (n.scheme === void 0) {
    const i = t.parseAbsolute(r);
    n.scheme = i.scheme, n.authority === void 0 && (n.authority = i.authority, n.path === "" ? (n.path = i.path, n.query === void 0 && (n.query = i.query)) : n.path.startsWith("/") || (n.path = WG(n.path, i)));
  }
  return iT(t, n);
}, WG = (t, e) => {
  if (e.authority && e.path === "")
    return "/" + t;
  {
    const r = e.path.lastIndexOf("/");
    return r === -1 ? t : e.path.slice(0, r + 1) + t;
  }
}, qG = /^\.?\.\/|^\.\.?$/, QG = /^\/\.(?:\/|$)/, KG = /^\/\.\.(?:\/|$)/, YG = (t) => {
  let e = "";
  for (; t.length > 0; )
    if (qG.test(t))
      t = m9(t);
    else if (QG.test(t))
      t = y9(t);
    else if (KG.test(t))
      t = y9(t), e = ZG(e);
    else {
      const r = JG(t);
      t = m9(t), e += r;
    }
  return e;
}, m9 = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "" : "/" + t.slice(e + 1);
}, y9 = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "/" : "/" + t.slice(e + 1);
}, ZG = (t) => {
  const e = t.lastIndexOf("/");
  return e === -1 ? t : t.slice(0, e);
}, JG = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? t : t.slice(0, e);
}, iT = (t, e) => {
  let r = e.scheme.toLowerCase() + ":";
  return r += e.authority === void 0 ? "" : "//" + e.authority.toLowerCase(), r += t.normalizePath(e.path), r += e.query === void 0 ? "" : "?" + t.normalizeQuery(e.query), r += e.fragment === void 0 ? "" : "#" + t.normalizeFragment(e.fragment), r;
}, sT = new RegExp(Ch, "g"), oT = (t) => (e) => {
  const r = parseInt(e.slice(1), 16), n = String.fromCharCode(r);
  return t(n) ? n : e.toUpperCase();
};
RegExp.prototype.test.bind(new RegExp(`${pd}|${Ys}|[:@]`));
const XG = RegExp.prototype.test.bind(new RegExp(`${og}|${Ys}|[:@]`)), eW = (t) => (e) => YG(e).replaceAll(sT, oT(t));
RegExp.prototype.test.bind(new RegExp(`${pd}|${Ys}|[:@/?]`));
const v9 = RegExp.prototype.test.bind(new RegExp(`${og}|${Ys}|[:@/?]`)), b9 = (t) => (e) => e.replaceAll(sT, oT(t));
RegExp.prototype.test.bind(new RegExp(jG));
RegExp.prototype.test.bind(new RegExp(BG));
RegExp.prototype.test.bind(new RegExp(FG));
RegExp.prototype.test.bind(new RegExp(tT));
RegExp.prototype.test.bind(new RegExp(rT));
RegExp.prototype.test.bind(new RegExp(nT));
const zE = (t, e) => (r) => {
  const n = t.exec(r);
  if (n === null)
    throw Error(`Invalid ${e}: ${r}`);
  const i = (
    /** @type Record<string, string> */
    n.groups
  );
  return i.authority === void 0 && (i.path = i.path2), delete i.path2, /** @type A */
  i;
}, UE = (
  /** @type Parser<IdentifierComponents> */
  zE(new RegExp(tT), "IRI")
), aT = (
  /** @type Parser<RelativeIdentifierComponents> */
  zE(new RegExp(rT), "IRI-reference")
), tW = (
  /** @type Parser<AbsoluteIdentifierComponents> */
  zE(new RegExp(nT), "absolute-IRI")
), lT = {
  iri: {
    parseAbsolute: tW,
    parseReference: aT,
    parse: UE,
    normalizePath: eW(XG),
    normalizeQuery: b9(v9),
    normalizeFragment: b9(v9)
  }
}, rW = (t) => (e) => {
  const r = t.parse(e);
  return delete r.fragment, iT(t, r);
}, Hu = rW(lT.iri), l0 = GG(lT.iri), nW = "", fx = function* (t) {
  if (t.length > 0 && t[0] !== "/")
    throw Error("Invalid JSON Pointer");
  let e = 1, r = 0;
  for (; r < t.length; ) {
    const n = t.indexOf("/", e);
    r = n === -1 ? t.length : n;
    const i = t.slice(e, r);
    e = r + 1, yield oW(i);
  }
}, iW = (t, e = void 0) => {
  if (e === void 0) {
    const r = [...fx(t)];
    return (n) => w9(r, n);
  } else
    return w9(fx(t), e);
}, w9 = (t, e) => {
  let r = nW;
  for (const n of t)
    e = lW(e, n, r), r = Xu(n, r);
  return e;
}, Xu = (t, e) => e + "/" + sW(t), sW = (t) => t.toString().replace(/~/g, "~0").replace(/\//g, "~1"), oW = (t) => t.toString().replace(/~1/g, "/").replace(/~0/g, "~"), aW = (t, e) => Array.isArray(t) && e === "-" ? t.length : e, lW = (t, e, r = "") => {
  if (t === void 0)
    throw TypeError(`Value at '${r}' is undefined and does not have property '${e}'`);
  if (t === null)
    throw TypeError(`Value at '${r}' is null and does not have property '${e}'`);
  if (cW(t))
    throw TypeError(`Value at '${r}' is a ${typeof t} and does not have property '${e}'`);
  {
    const n = aW(t, e);
    return t[n];
  }
}, cW = (t) => t === null || typeof t != "object", cT = (t) => {
  const e = typeof t;
  switch (e) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JSON compatible type: ${r}`);
    }
  }
}, uT = (t) => {
  const e = t.indexOf("#"), r = e === -1 ? t.length : e;
  return t.slice(0, r);
}, hT = (t) => decodeURIComponent(aT(t).fragment || ""), sy = {}, U2 = (t) => {
  if (t.indexOf("#") !== -1) {
    const e = uT(t);
    return { ...sy[e], id: t };
  }
  return sy[t];
}, uW = (t, e) => {
  const r = hW(t, e);
  if (!r)
    throw Error(`Encountered unknown keyword '${t}'`);
  const n = U2(r);
  if (!n)
    throw Error(`Encountered unsupported keyword ${t}. You can provide an implementation for the '${r}' keyword using the 'addKeyword' function.`);
  return n;
}, at = (t) => {
  sy[t.id] = t;
}, gx = {}, pc = (t, e) => {
  gx[t] = e;
}, Uf = {}, mx = {}, cw = {}, hW = (t, e) => {
  var r;
  return ((r = pT(e)) == null ? void 0 : r[t]) || (mx[e] || t.startsWith("x-")) && `https://json-schema.org/keyword/unknown#${t}`;
}, Yr = (t, e) => {
  const r = pT(t);
  for (const n in r)
    if (r[n] === e)
      return n;
}, pT = (t) => {
  if (!(t in Uf))
    throw Error(`Encountered unknown dialect '${t}'`);
  return Uf[t];
}, dT = (t, e, r = !1, n = !0) => {
  mx[t] = r, cw[t] = cw[t] || n, Uf[t] = {}, Object.entries(e).forEach(([i, s]) => {
    if (i in gx)
      Object.entries(gx[i]).forEach(([o, a]) => {
        !(a in sy) && !s && (a = `https://json-schema.org/keyword/unknown#${o}`), Uf[t][o] = a;
      });
    else if (!r || s)
      throw delete Uf[t], delete mx[t], delete cw[t], Error(`Unrecognized vocabulary: ${i}. You can define this vocabulary with the 'defineVocabulary' function.`);
  });
};
var x9 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fT(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Pm = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var E9;
function pW() {
  if (E9) return Pm;
  E9 = 1;
  var t = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, e = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, n = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  Pm.format = o, Pm.parse = a;
  function o(h) {
    if (!h || typeof h != "object")
      throw new TypeError("argument obj is required");
    var d = h.parameters, v = h.type;
    if (!v || !s.test(v))
      throw new TypeError("invalid type");
    var m = v;
    if (d && typeof d == "object")
      for (var b, f = Object.keys(d).sort(), E = 0; E < f.length; E++) {
        if (b = f[E], !r.test(b))
          throw new TypeError("invalid parameter name");
        m += "; " + b + "=" + c(d[b]);
      }
    return m;
  }
  function a(h) {
    if (!h)
      throw new TypeError("argument string is required");
    var d = typeof h == "object" ? l(h) : h;
    if (typeof d != "string")
      throw new TypeError("argument string is required to be a string");
    var v = d.indexOf(";"), m = v !== -1 ? d.slice(0, v).trim() : d.trim();
    if (!s.test(m))
      throw new TypeError("invalid media type");
    var b = new p(m.toLowerCase());
    if (v !== -1) {
      var f, E, A;
      for (t.lastIndex = v; E = t.exec(d); ) {
        if (E.index !== v)
          throw new TypeError("invalid parameter format");
        v += E[0].length, f = E[1].toLowerCase(), A = E[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(n, "$1"))), b.parameters[f] = A;
      }
      if (v !== d.length)
        throw new TypeError("invalid parameter format");
    }
    return b;
  }
  function l(h) {
    var d;
    if (typeof h.getHeader == "function" ? d = h.getHeader("content-type") : typeof h.headers == "object" && (d = h.headers && h.headers["content-type"]), typeof d != "string")
      throw new TypeError("content-type header is missing from object");
    return d;
  }
  function c(h) {
    var d = String(h);
    if (r.test(d))
      return d;
    if (d.length > 0 && !e.test(d))
      throw new TypeError("invalid parameter value");
    return '"' + d.replace(i, "\\$1") + '"';
  }
  function p(h) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = h;
  }
  return Pm;
}
var gT = pW();
const dW = /* @__PURE__ */ fT(gT), c0 = {}, mT = (t, e) => {
  c0[t] = e;
}, fW = (t) => {
  const e = t.headers.get("content-type");
  if (e === null)
    throw new wW("The media type of the response could not be determined. Make sure the response includes a 'Content-Type' header.", { cause: t });
  const r = gT.parse(e);
  for (const n in c0)
    if (yW(n, r.type))
      return c0[n].parse(t);
  throw new bW(r.type, `'${r.type}' is not supported. Use the 'addMediaTypePlugin' function to add support for this media type.`, {
    cause: t
  });
}, gW = "A-Za-z", uw = `[!#$%&'*\\-_.^\`|~\\d${gW}]+`, mW = `(?<type>${uw})/(?<subType>${uw}(?:\\+(?<suffix>${uw}))?)`, S9 = new RegExp(mW), yW = (t, e) => {
  var r, n;
  if (t === e)
    return !0;
  const i = (r = S9.exec(t)) == null ? void 0 : r.groups;
  if (!i)
    throw Error(`Unable to parse media-range: ${t}`);
  const s = (n = S9.exec(e)) == null ? void 0 : n.groups;
  if (!s)
    throw Error(`Unable to parse media-type: ${e}`);
  return (i.type === s.type || i.type === "*") && (i.subType === s.subType || i.subType === "*" || i.subType === s.suffix);
}, vW = () => {
  let t = "";
  for (const e in c0)
    t = A9(t, e, c0[e].quality);
  return A9(t, "*/*", "0.001");
}, A9 = (t, e, r) => (t.length > 0 && (t += ", "), t += e, r && (t += `; q=${r}`), t);
let bW = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.mediaType = e;
  }
}, wW = class extends Error {
  constructor(e = void 0) {
    super(e), this.name = this.constructor.name;
  }
};
const xW = (t, e = void 0) => JSON.parse(t, (r, n) => {
  const i = n !== null && typeof n.$ref == "string" ? new Nu(n.$ref) : n;
  return e ? e(r, i) : i;
});
var d1, f1;
let Nu = class {
  constructor(e, r = void 0) {
    f9(this, d1), f9(this, f1), g9(this, d1, e), g9(this, f1, r ?? { $ref: e });
  }
  get href() {
    return d9(this, d1);
  }
  toJSON() {
    return d9(this, f1);
  }
};
d1 = /* @__PURE__ */ new WeakMap(), f1 = /* @__PURE__ */ new WeakMap();
const yT = (t) => {
  const e = typeof t;
  switch (e) {
    case "bigint":
      return "number";
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (t instanceof Nu)
        return "reference";
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype || Object.getPrototypeOf(t) === null)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JRef compatible type: ${r}`);
    }
  }
}, EW = {
  parse: async (t) => ({
    baseUri: t.url,
    root: xW(await t.text()),
    anchorLocation: SW
  }),
  fileMatcher: (t) => /[^/]\.jref$/.test(t)
}, SW = (t) => decodeURI(t || ""), yx = {}, vT = (t, e) => {
  yx[t] = e;
}, AW = (t, e) => {
  t = l0(t, e);
  const { scheme: r } = UE(t);
  if (!(r in yx))
    throw new kW(r, `The '${r}:' URI scheme is not supported. Use the 'addUriSchemePlugin' function to add support for '${r}:' URIs.`);
  return yx[r].retrieve(t, e);
};
let kW = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.scheme = e;
  }
};
const _W = /* @__PURE__ */ new Set([200, 203]), CW = async (t) => {
  const e = await fetch(t, { headers: { Accept: vW() } });
  if (e.status >= 400)
    throw new k9(e, `Failed to retrieve '${t}'`);
  if (!_W.has(e.status))
    throw new k9(e, "Unsupported HTTP response status code");
  return e;
}, bT = { retrieve: CW };
let k9 = class extends Error {
  constructor(e, r = void 0) {
    super(`${e.status} ${e.statusText}${r ? ` -- ${r}` : ""}`), this.name = this.constructor.name, this.response = e;
  }
};
var wT = IW;
function IW(t, e) {
  return function r() {
    e == null && (e = t.length);
    var n = [].slice.call(arguments);
    return n.length >= e ? t.apply(this, n) : function() {
      return r.apply(this, n.concat([].slice.call(arguments)));
    };
  };
}
const PW = () => {
  var t, e;
  return ((e = (t = globalThis.document) == null ? void 0 : t.location) == null ? void 0 : e.toString()) ?? "";
}, V2 = async (t, e = { _cache: {} }) => {
  var r, n, i;
  const s = ((r = e.document) == null ? void 0 : r.baseUri) ?? PW();
  t = l0(t, s);
  const o = Hu(t), { fragment: a } = UE(t), l = e._cache[o] ?? ((i = (n = e.document) == null ? void 0 : n.embedded) == null ? void 0 : i[o]);
  if (l)
    e.document = l, e.uri = t, e.cursor = e.document.anchorLocation(a);
  else {
    try {
      const c = await AW(t, s);
      e.document = await fW(c), e.uri = c.url + (a === void 0 ? "" : `#${a}`), e.cursor = e.document.anchorLocation(a);
    } catch (c) {
      const p = e.uri ? ` Referenced from '${e.uri}'.` : "";
      throw new OW(`Unable to load resource '${t}'.${p}`, c);
    }
    e._cache[o] = e.document;
  }
  return e._value = iW(e.cursor, e.document.root), xT(e);
}, xT = (t) => yT(Ct(t)) === "reference" ? V2(Ct(t).href, t) : t, Ct = (t) => t._value, Oa = (t) => yT(t._value), ET = (t, e) => t in e._value, ST = (t) => t._value.length, Ws = wT((t, e) => xT({
  ...e,
  cursor: Xu(`${t}`, e.cursor),
  _value: e._value[t]
})), dc = async function* (t) {
  for (let e = 0; e < Ct(t).length; e++)
    yield Ws(e, t);
}, vx = function* (t) {
  for (const e in Ct(t))
    yield e;
}, RW = async function* (t) {
  for (const e in Ct(t))
    yield Ws(e, t);
}, eh = async function* (t) {
  for (const e in Ct(t))
    yield [e, await Ws(e, t)];
};
let OW = class extends Error {
  constructor(e, r) {
    super(e, { cause: r }), this.name = this.constructor.name;
  }
};
mT("application/reference+json", EW);
vT("http", bT);
vT("https", bT);
const TW = {
  parse: async (t) => {
    const e = dW.parse(t.headers.get("content-type") ?? ""), r = e.parameters.schema ?? e.parameters.profile;
    return ay(await t.json(), t.url, r);
  },
  fileMatcher: async (t) => /(\.|\/)schema\.json$/.test(t)
}, oy = {}, LW = async (t, e = void 0) => {
  e || (e = { _cache: {} });
  for (const n in oy)
    n in e._cache || (e._cache[n] = oy[n]);
  const r = await V2(t, { ...e });
  if (typeof r.document.dialectId != "string")
    throw Error(`The document at ${r.document.baseUri} is not a schema.`);
  return r;
}, Ua = (t, e, r) => {
  t = structuredClone(t);
  const n = ay(t, e, r);
  if (n.baseUri in oy)
    throw Error(`A schema has already been registered for '${n.baseUri}. You can use 'unregisterSchema' to remove the old schema before registering the new one.`);
  if (n.baseUri.startsWith("file:"))
    throw Error(`Registering a schema with a 'file:' URI scheme is not allowed: ${n.baseUri}`);
  oy[n.baseUri] = n;
}, ay = (t, e, r, n = {}) => {
  if (typeof t.$schema == "string" && (r = t.$schema, delete t.$schema), !r)
    throw Error("Unable to determine a dialect for the schema. The dialect can be declared in a number of ways, but the recommended way is to use the '$schema' keyword in your schema.");
  r = Hu(r);
  const i = Yr(r, "https://json-schema.org/keyword/draft-04/id"), s = Yr(r, "https://json-schema.org/keyword/id") || i;
  if (!t[s] && !e)
    throw Error(`Unable to determine an identifier for the schema. Use the '${s}' keyword or pass a retrievalUri when loading the schema.`);
  const o = l0(t[s] ?? "", e ?? "");
  e = Hu(o), i && o.length > e.length ? t[s] = "#" + hT(o) : delete t[s];
  const a = Yr(r, "https://json-schema.org/keyword/vocabulary");
  if (cT(t[a]) === "object") {
    const h = t[a]["https://json-schema.org/draft/2019-09/vocab/core"] || t[a]["https://json-schema.org/draft/2020-12/vocab/core"];
    dT(e, t[a], h, !1), delete t[a];
  }
  const l = { "": "" }, c = {}, p = Yr(r, "https://json-schema.org/keyword/draft-2019-09/recursiveAnchor");
  return t[p] === !0 && (c[""] = `${e}#`), delete t[p], n[e] = {
    baseUri: e,
    dialectId: r,
    root: bx(t, e, r, "", n, l, c),
    anchorLocation: (h) => {
      if (h === void 0)
        return "";
      if (h = decodeURI(h), h[0] === "/")
        return h;
      if (h in l)
        return l[h];
      throw Error(`No such anchor '${e}#${encodeURI(h)}'`);
    },
    anchors: l,
    dynamicAnchors: c,
    embedded: n
  }, n[e];
}, bx = (t, e, r, n, i, s, o) => {
  if (cT(t) === "object") {
    const a = typeof t.$schema == "string" ? Hu(t.$schema) : r, l = Yr(a, "https://json-schema.org/keyword/id");
    if (typeof t[l] == "string") {
      const m = Hu(l0(t[l], e));
      return t[l] = m, i[m] = ay(t, m, a, i), new Nu(m, {});
    }
    const c = Yr(a, "https://json-schema.org/keyword/draft-04/id");
    if (typeof t[c] == "string")
      if (t[c][0] === "#") {
        const m = decodeURIComponent(t[c].slice(1));
        s[m] = n, delete t[c];
      } else {
        const m = Hu(l0(t[c], e));
        return t[c] = m, i[m] = ay(t, m, a, i), new Nu(m, {});
      }
    const p = Yr(r, "https://json-schema.org/keyword/draft-04/ref");
    if (typeof t[p] == "string")
      return new Nu(t[p], t);
    const h = Yr(r, "https://json-schema.org/keyword/anchor");
    typeof t[h] == "string" && (s[t[h]] = n, delete t[h]);
    const d = Yr(r, "https://json-schema.org/keyword/dynamicAnchor");
    typeof t[d] == "string" && (o[t[d]] = `${e}#${encodeURI(n)}`, delete t[d]);
    const v = Yr(r, "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor");
    typeof t[v] == "string" && (o[t[v]] = `${e}#${encodeURI(n)}`, s[t[v]] = n, delete t[v]);
    for (const m in t) {
      const b = Yr(r, "https://json-schema.org/keyword/ref");
      m === b && typeof t[m] == "string" ? t[m] = new Nu(t[m], t[m]) : t[m] = bx(t[m], e, r, Xu(m, n), i, s, o);
    }
  } else if (Array.isArray(t))
    for (let a = 0; a < t.length; a++)
      t[a] = bx(t[a], e, r, Xu(a, n), i, s, o);
  return t;
}, Bp = (t) => `${t.document.baseUri}#${encodeURI(t.cursor)}`, fd = (
  /** @type API.curry */
  (t) => (...e) => {
    const r = t.length === 1 ? (
      /** @type Extract<typeof fn, (a: any) => any> */
      t(e[0])
    ) : t(e[0], e[1]), n = (
      /** @type I */
      e[t.length]
    );
    return n === void 0 ? r : r(n);
  }
), AT = fd((t) => function* (e) {
  for (const r of e)
    yield t(r);
}), Qn = fd((t) => async function* (e) {
  for await (const r of e)
    yield t(r);
}), kT = fd((t) => function* (e) {
  for (const r of e)
    t(r) && (yield r);
}), MW = fd((t) => function* (e) {
  let r = 0;
  for (const n of e)
    r++ >= t && (yield n);
}), NW = (t) => {
  const e = IT(t).next();
  return e.done ? void 0 : e.value;
}, _T = function* (t, e) {
  for (let r = t; e === void 0; r++)
    yield r;
}, _9 = function* () {
}, VE = function* (t, e) {
  const r = IT(e);
  for (const n of t)
    yield [n, r.next().value];
}, DW = function* (...t) {
  for (const e of t)
    yield* e;
}, CT = (
  /** @type API.reduce */
  fd(
    // eslint-disable-next-line @stylistic/no-extra-parens
    /** @type API.reduce */
    (t, e) => (r) => {
      for (const n of r)
        e = t(
          e,
          /** @type any */
          n
        );
      return e;
    }
  )
), Zs = async (t) => {
  const e = [];
  for await (const r of t)
    e.push(r);
  return e;
}, $W = (t) => {
  const e = /* @__PURE__ */ new Set();
  for (const r of t)
    e.add(r);
  return e;
}, wx = async (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  for await (const [r, n] of t)
    e[r] = n;
  return e;
}, jW = fd((t) => (e) => {
  let r = NW(e) ?? "";
  for (const n of e)
    r += t + n;
  return r;
}), IT = (t) => {
  if (typeof (t == null ? void 0 : t[Symbol.iterator]) == "function")
    return t[Symbol.iterator]();
  throw TypeError("`iter` is not iterable");
}, fn = (
  /** @type (acc: any, ...fns: ((a: any) => any)[]) => any */
  (t, ...e) => CT((r, n) => n(r), t, e)
), g1 = (t, e = "", r = "", n = void 0) => {
  const i = typeof t;
  switch (i) {
    case "number":
    case "string":
    case "boolean":
      return gf(e, r, t, i, [], n);
    case "object":
      if (t === null)
        return gf(e, r, t, "null", [], n);
      if (Array.isArray(t)) {
        const s = gf(e, r, t, "array", [], n);
        return s.children = t.map((o, a) => g1(o, e, Xu(a, r), s)), s;
      } else if (Object.getPrototypeOf(t) === Object.prototype) {
        const s = gf(e, r, t, "object", [], n);
        return s.children = Object.entries(t).map((o) => {
          const a = Xu(o[0], r), l = gf(e, a, void 0, "property", [], s);
          return l.children = o.map((c) => g1(c, e, a, l)), l;
        }), s;
      } else if (t instanceof Nu)
        return g1(t.toJSON(), e, r, n);
    default: {
      const s = i === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : i;
      throw Error(`Not a JSON compatible type: ${s}`);
    }
  }
}, gf = (t, e, r, n, i, s) => {
  const o = {
    baseUri: t ? Hu(t) : "",
    pointer: e,
    value: r,
    type: n,
    children: i,
    parent: s,
    valid: !0,
    errors: {},
    annotations: {}
  };
  return o.root = (s == null ? void 0 : s.root) ?? o, o;
}, BW = (t) => `${t.baseUri}#${encodeURI(t.pointer)}`, Sr = (t) => t.value, Ht = (t) => t.type, Fp = (t, e) => t in e.value, Ih = function* (t) {
  t.type === "array" && (yield* t.children);
}, HE = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      yield e.children[0];
}, FW = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children[1] && (yield e.children[1]);
}, fc = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children.length === 2 && (yield e.children);
}, ag = (t) => {
  if (t.type === "array")
    return t.children.length;
}, xx = function* (t) {
  switch (yield t, Ht(t)) {
    case "object":
      for (const e of FW(t))
        yield* xx(e);
      break;
    case "array":
      for (const e of Ih(t))
        yield* xx(e);
      break;
  }
}, Rp = {};
let zW = 0;
const UW = (t, e) => {
  t in Rp || (Rp[t] = {});
  const r = `pubsub_subscription_${zW++}`;
  return Rp[t][r] = e, r;
}, VW = async (t, e) => {
  const r = [];
  for (const n in Rp)
    if (n === t || t.startsWith(`${n}.`))
      for (const i in Rp[n])
        r.push(Rp[t][i](t, e));
  await Promise.all(r);
};
let PT;
const HW = () => PT, GW = (t) => {
  PT = t;
};
let WW = class extends Error {
  constructor(e) {
    super("Invalid Schema"), this.name = this.constructor.name, this.output = e;
  }
};
const RT = "https://json-schema.org/evaluation/validate", qW = async (t, e) => {
  await VW("validate.metaValidate", t), t.document.baseUri in e.metaData || (e.metaData[t.document.baseUri] = {
    dynamicAnchors: t.document.dynamicAnchors
  });
  const r = Bp(t);
  if (!(r in e)) {
    e[r] = !1;
    const n = Ct(t);
    if (!["object", "boolean"].includes(typeof n))
      throw Error(`No schema found at '${r}'`);
    e[r] = typeof n == "boolean" ? n : await fn(
      eh(t),
      Qn(async ([i, s]) => {
        const o = uW(i, t.document.dialectId), a = await o.compile(s, e, t);
        return [o.id, Xu(i, Bp(t)), a];
      }),
      Zs
    );
  }
  return r;
}, QW = (t, e, r, n, i = !1) => {
  n = { ...r.metaData[uT(t)].dynamicAnchors, ...n };
  let s = !0;
  if (typeof r[t] == "boolean")
    s = r[t];
  else
    for (const [o, a, l] of r[t])
      e.valid = U2(o).interpret(l, e, r, n, i, t), e.valid || (i || (e.errors[a] = o), s = !1);
  return s || (e.errors[t] = RT), e.valid = s, s;
}, KW = /* @__PURE__ */ new Set(), YW = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedProperties")
      continue;
    const l = U2(o), c = "collectEvaluatedProperties" in l ? l.collectEvaluatedProperties(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && KW;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, ZW = /* @__PURE__ */ new Set(), JW = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedItems")
      continue;
    const l = U2(o), c = "collectEvaluatedItems" in l ? l.collectEvaluatedItems(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && ZW;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, Ve = { id: RT, compile: qW, interpret: QW, collectEvaluatedProperties: YW, collectEvaluatedItems: JW }, ly = {}, XW = (t, e) => {
  if (e in ly)
    return ly[e](t);
  throw Error(`The '${e}' error format is not supported`);
};
ly.FLAG = (t) => ({ valid: t.valid });
ly.BASIC = (t) => {
  const e = {
    valid: t.valid
  };
  if (!t.valid) {
    e.errors = [];
    for (const r of xx(t))
      for (const [n, i] of Object.entries(r.errors).reverse())
        i !== "https://json-schema.org/evaluation/validate" && !r.valid && e.errors.unshift({
          keyword: i,
          absoluteKeywordLocation: n,
          instanceLocation: BW(r),
          valid: r.valid
        });
  }
  return e;
};
const OT = "FLAG";
GW(OT);
const eq = async (t) => {
  const e = { metaData: {} }, r = await Ve.compile(t, e);
  return { ast: e, schemaUri: r };
}, tq = wT(({ ast: t, schemaUri: e }, r, n = OT) => (Ve.interpret(e, r, t, {}), XW(r, n))), hw = {};
UW("validate.metaValidate", async (t, e) => {
  if (!e.document.validated) {
    if (e.document.validated = !0, !(e.document.dialectId in hw)) {
      const i = await LW(e.document.dialectId, e), s = await eq(i);
      hw[e.document.dialectId] = tq(s);
    }
    const r = g1(e.document.root, e.document.baseUri), n = hw[e.document.dialectId](r, HW());
    if (!n.valid)
      throw new WW(n);
  }
});
const rq = "https://json-schema.org/keyword/additionalProperties", nq = async (t, e, r) => {
  const n = Yr(t.document.dialectId, "https://json-schema.org/keyword/properties"), i = await Ws(n, r), s = Oa(i) === "object" ? AT((p) => "^" + iq(p) + "$", vx(i)) : _9(), o = Yr(t.document.dialectId, "https://json-schema.org/keyword/patternProperties"), a = await Ws(o, r), l = Oa(a) === "object" ? vx(a) : _9(), c = fn(
    DW(s, l),
    jW("|")
  ) || "(?!)";
  return [new RegExp(c, "u"), await Ve.compile(t, e)];
}, iq = (t) => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), sq = ([t, e], r, n, i, s) => {
  if (Ht(r) !== "object")
    return !0;
  let o = !0;
  for (const [a, l] of fc(r)) {
    const c = Sr(a);
    !t.test(c) && !Ve.interpret(e, l, n, i, s) && (o = !1);
  }
  return o;
}, oq = ([t, e], r, n, i) => {
  if (Ht(r) !== "object")
    return !0;
  const s = /* @__PURE__ */ new Set();
  for (const [o, a] of fc(r)) {
    const l = Sr(o);
    if (!t.test(l)) {
      if (!Ve.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, aq = { id: rq, compile: nq, interpret: sq, collectEvaluatedProperties: oq }, lq = "https://json-schema.org/keyword/allOf", cq = (t, e) => fn(
  dc(t),
  Qn((r) => Ve.compile(r, e)),
  Zs
), uq = (t, e, r, n, i) => {
  let s = !0;
  for (const o of t)
    Ve.interpret(o, e, r, n, i) || (s = !1);
  return s;
}, hq = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = Ve.collectEvaluatedProperties(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, pq = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = Ve.collectEvaluatedItems(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, dq = { id: lq, compile: cq, interpret: uq, collectEvaluatedProperties: hq, collectEvaluatedItems: pq }, fq = { id: "https://json-schema.org/keyword/anchor" }, gq = "https://json-schema.org/keyword/anyOf", mq = (t, e) => fn(
  dc(t),
  Qn((r) => Ve.compile(r, e)),
  Zs
), yq = (t, e, r, n, i) => t.filter((s) => Ve.interpret(s, e, r, n, i)).length > 0, vq = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ve.collectEvaluatedProperties(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, bq = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ve.collectEvaluatedItems(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, wq = { id: gq, compile: mq, interpret: yq, collectEvaluatedProperties: vq, collectEvaluatedItems: bq }, xq = "https://json-schema.org/keyword/conditional", Eq = (t, e) => fn(
  dc(t),
  TT,
  Qn((r) => Ve.compile(r, e)),
  Zs
), Sq = (t, e, r, n, i) => {
  for (let s = 0; s < t.length; s += 2) {
    const o = Ve.interpret(t[s], e, r, n, i);
    if (s + 1 === t.length)
      return o;
    if (o)
      return Ve.interpret(t[s + 1], e, r, n, i);
  }
  return !0;
}, Aq = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = Ve.collectEvaluatedProperties(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return Ve.collectEvaluatedProperties(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, kq = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = Ve.collectEvaluatedItems(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return Ve.collectEvaluatedItems(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, TT = async function* (t, e = 1) {
  for await (const r of t)
    e > 0 && Oa(r) === "array" ? yield* TT(dc(r), e - 1) : yield r;
}, _q = { id: xq, compile: Eq, interpret: Sq, collectEvaluatedProperties: Aq, collectEvaluatedItems: kq };
var C9, I9;
function Cq() {
  return I9 || (I9 = 1, C9 = {
    space: "",
    cycles: !1,
    replacer: (t, e) => e,
    stringify: JSON.stringify
  }), C9;
}
var P9, R9;
function vu() {
  return R9 || (R9 = 1, P9 = {
    isArray: Array.isArray,
    assign: Object.assign,
    isObject: (t) => typeof t == "object",
    isFunction: (t) => typeof t == "function",
    isBoolean: (t) => typeof t == "boolean",
    isRegex: (t) => t instanceof RegExp,
    keys: Object.keys
  }), P9;
}
var pw, O9;
function Iq() {
  if (O9) return pw;
  O9 = 1;
  const t = Cq(), e = vu().isFunction, r = vu().isBoolean, n = vu().isObject, i = vu().isArray, s = vu().isRegex, o = vu().assign, a = vu().keys;
  function l(p) {
    return p == null ? p : s(p) ? p.toString() : p.toJSON ? p.toJSON() : p;
  }
  function c(p, h) {
    h = h || o({}, t), e(h) && (h = { compare: h });
    const d = h.space || t.space, v = r(h.cycles) ? h.cycles : t.cycles, m = h.replacer || t.replacer, b = h.stringify || t.stringify, f = h.compare && /* @__PURE__ */ function(A) {
      return function(x) {
        return function(g, w) {
          const _ = { key: g, value: x[g] }, S = { key: w, value: x[w] };
          return A(_, S);
        };
      };
    }(h.compare);
    v || b(p);
    const E = [];
    return function A(x, g, w, _) {
      const S = d ? `
` + new Array(_ + 1).join(d) : "", R = d ? ": " : ":";
      if (w = l(w), w = m.call(x, g, w), w !== void 0) {
        if (!n(w) || w === null) return b(w);
        if (i(w)) {
          const L = [];
          for (let F = 0; F < w.length; F++) {
            const z = A(w, F, w[F], _ + 1) || b(null);
            L.push(S + d + z);
          }
          return "[" + L.join(",") + S + "]";
        } else {
          if (v) {
            if (E.indexOf(w) !== -1)
              return b("[Circular]");
            E.push(w);
          }
          const L = a(w).sort(f && f(w)), F = [];
          for (let z = 0; z < L.length; z++) {
            const j = L[z], W = A(w, j, w[j], _ + 1);
            if (!W) continue;
            const te = b(j) + R + W;
            F.push(S + d + te);
          }
          return E.splice(E.indexOf(w), 1), "{" + F.join(",") + S + "}";
        }
      }
    }({ "": p }, "", p, 0);
  }
  return pw = c, pw;
}
var Pq = Iq();
const lg = /* @__PURE__ */ fT(Pq), Rq = "https://json-schema.org/keyword/const", Oq = (t) => lg(Ct(t)), Tq = (t, e) => lg(Sr(e)) === t, Lq = { id: Rq, compile: Oq, interpret: Tq }, Mq = "https://json-schema.org/keyword/contains", Nq = async (t, e, r) => {
  const n = await Ve.compile(t, e), i = Yr(t.document.dialectId, "https://json-schema.org/keyword/minContains"), s = await Ws(i, r), o = Oa(s) === "number" ? Ct(s) : 1, a = Yr(t.document.dialectId, "https://json-schema.org/keyword/maxContains"), l = await Ws(a, r), c = Oa(l) === "number" ? Ct(l) : Number.MAX_SAFE_INTEGER;
  return { contains: n, minContains: o, maxContains: c };
}, LT = ({ contains: t, minContains: e, maxContains: r }, n, i, s, o) => {
  const a = Ht(n) !== "array" || fn(
    Ih(n),
    kT((l) => Ve.interpret(t, l, i, s, o)),
    CT((l) => l + 1, 0)
  );
  return a >= e && a <= r;
}, Dq = (t, e, r, n) => LT(t, e, r, n, !0) && Ht(e) === "array" && fn(
  VE(Ih(e), _T(0)),
  kT(([i]) => Ve.interpret(t.contains, i, r, n, !0)),
  AT(([, i]) => i),
  $W
), $q = { id: Mq, compile: Nq, interpret: LT, collectEvaluatedItems: Dq }, jq = "https://json-schema.org/keyword/comment", Bq = () => {
}, Fq = () => !0, zq = { id: jq, compile: Bq, interpret: Fq }, As = (t, e, r, n) => {
  e in t.annotations || (t.annotations[e] = {}), t.annotations[e][r] = n;
}, MT = "https://json-schema.org/keyword/contentEncoding", Uq = (t) => Ct(t), Vq = (t, e, r, n, i, s) => (As(e, MT, s, t), !0), Hq = { id: MT, compile: Uq, interpret: Vq }, NT = "https://json-schema.org/keyword/contentMediaType", Gq = (t) => Ct(t), Wq = (t, e, r, n, i, s) => (As(e, NT, s, t), !0), qq = { id: NT, compile: Gq, interpret: Wq }, DT = "https://json-schema.org/keyword/contentSchema", Qq = (t) => Bp(t), Kq = (t, e, r, n, i, s) => (As(e, DT, s, t), !0), Yq = { id: DT, compile: Qq, interpret: Kq }, $T = "https://json-schema.org/keyword/default", Zq = (t) => Ct(t), Jq = (t, e, r, n, i, s) => (As(e, $T, s, t), !0), Xq = { id: $T, compile: Zq, interpret: Jq }, eQ = "https://json-schema.org/keyword/definitions", tQ = (t, e) => fn(
  RW(t),
  Qn((r) => Ve.compile(r, e)),
  Zs
), rQ = () => !0, nQ = { id: eQ, compile: tQ, interpret: rQ }, iQ = "https://json-schema.org/keyword/dependentRequired", sQ = (t) => fn(
  eh(t),
  Qn(([e, r]) => [e, Ct(r)]),
  Zs
), oQ = (t, e) => {
  if (Ht(e) !== "object")
    return !0;
  let r = !0;
  for (const [n, i] of t)
    Fp(n, e) && !i.every((s) => Fp(s, e)) && (r = !1);
  return r;
}, aQ = { id: iQ, compile: sQ, interpret: oQ }, lQ = "https://json-schema.org/keyword/dependentSchemas", cQ = (t, e) => fn(
  eh(t),
  Qn(async ([r, n]) => [r, await Ve.compile(n, e)]),
  Zs
), uQ = (t, e, r, n, i) => {
  if (Ht(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    Fp(o, e) && !Ve.interpret(a, e, r, n, i) && (s = !1);
  return s;
}, hQ = (t, e, r, n) => {
  if (Ht(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    if (Fp(s, e)) {
      const a = Ve.collectEvaluatedProperties(o, e, r, n);
      if (a === !1)
        return !1;
      a.forEach(Set.prototype.add.bind(i));
    }
  return i;
}, pQ = { id: lQ, compile: cQ, interpret: uQ, collectEvaluatedProperties: hQ }, jT = "https://json-schema.org/keyword/deprecated", dQ = (t) => Ct(t), fQ = (t, e, r, n, i, s) => (As(e, jT, s, t), !0), gQ = { id: jT, compile: dQ, interpret: fQ }, BT = "https://json-schema.org/keyword/description", mQ = (t) => Ct(t), yQ = (t, e, r, n, i, s) => (As(e, BT, s, t), !0), vQ = { id: BT, compile: mQ, interpret: yQ }, bQ = { id: "https://json-schema.org/keyword/dynamicAnchor" }, wQ = "https://json-schema.org/keyword/dynamicRef", xQ = async (t, e) => {
  const r = Ct(t), n = await V2(t.document.baseUri, t);
  return await Ve.compile(n, e), r;
}, GE = (t, e, r, n, i, s) => {
  if (!(e in i))
    throw Error(`No dynamic anchor found for "${e}"`);
  return t(i[e], r, n, i, s);
}, EQ = (...t) => GE(Ve.interpret, ...t), SQ = (...t) => GE(Ve.collectEvaluatedProperties, ...t), AQ = (...t) => GE(Ve.collectEvaluatedItems, ...t), kQ = { id: wQ, compile: xQ, interpret: EQ, collectEvaluatedProperties: SQ, collectEvaluatedItems: AQ }, _Q = "https://json-schema.org/keyword/else", CQ = async (t, e, r) => {
  const n = Yr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (ET(n, r)) {
    const i = await Ws(n, r);
    return [await Ve.compile(i, e), await Ve.compile(t, e)];
  } else
    return [];
}, IQ = ([t, e], r, n, i, s) => t === void 0 || Ve.interpret(t, r, n, i, !0) || Ve.interpret(e, r, n, i, s), PQ = ([t, e], r, n, i) => t === void 0 || Ve.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ve.collectEvaluatedProperties(e, r, n, i), RQ = ([t, e], r, n, i) => t === void 0 || Ve.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ve.collectEvaluatedItems(e, r, n, i), OQ = { id: _Q, compile: CQ, interpret: IQ, collectEvaluatedProperties: PQ, collectEvaluatedItems: RQ }, TQ = "https://json-schema.org/keyword/enum", LQ = (t) => fn(
  dc(t),
  Qn(Ct),
  Qn(lg),
  Zs
), MQ = (t, e) => {
  const r = lg(Sr(e));
  return t.some((n) => r === n);
}, NQ = { id: TQ, compile: LQ, interpret: MQ }, FT = "https://json-schema.org/keyword/examples", DQ = (t) => Ct(t), $Q = (t, e, r, n, i, s) => (As(e, FT, s, t), !0), jQ = { id: FT, compile: DQ, interpret: $Q }, BQ = "https://json-schema.org/keyword/exclusiveMaximum", FQ = (t) => Ct(t), zQ = (t, e) => Ht(e) !== "number" || Sr(e) < t, UQ = { id: BQ, compile: FQ, interpret: zQ }, VQ = "https://json-schema.org/keyword/exclusiveMinimum", HQ = (t) => Ct(t), GQ = (t, e) => Ht(e) !== "number" || Sr(e) > t, WQ = { id: VQ, compile: HQ, interpret: GQ }, zT = "https://json-schema.org/keyword/format", qQ = (t) => Ct(t), QQ = (t, e, r, n, i, s) => (As(e, zT, s, t), !0), KQ = { id: zT, compile: qQ, interpret: QQ }, YQ = { id: "https://json-schema.org/keyword/id" }, ZQ = "https://json-schema.org/keyword/if", JQ = (t, e) => Ve.compile(t, e), XQ = (t, e, r, n) => (Ve.interpret(t, e, r, n, !0), !0), eK = (t, e, r, n) => Ve.collectEvaluatedProperties(t, e, r, n) || [], tK = (t, e, r, n) => Ve.collectEvaluatedItems(t, e, r, n) || /* @__PURE__ */ new Set(), rK = { id: ZQ, compile: JQ, interpret: XQ, collectEvaluatedProperties: eK, collectEvaluatedItems: tK }, nK = () => {
  const t = cs(!1), e = cs(!0);
  return _n(t, e), { start: t, end: e };
}, iK = (t) => {
  const e = cs(!1), r = cs(!0);
  return uK(e, r, t), { start: e, end: r };
}, sK = (t, e) => t === void 0 ? e : (_n(t.end, e.start), t.end.isEnd = !1, { start: t.start, end: e.end }), oK = (t, e) => {
  const r = cs(!1);
  _n(r, t.start), _n(r, e.start);
  const n = cs(!0);
  return _n(t.end, n), t.end.isEnd = !1, _n(e.end, n), e.end.isEnd = !1, { start: r, end: n };
}, aK = (t) => {
  const e = cs(!1), r = cs(!0);
  return _n(e, r), _n(e, t.start), _n(t.end, r), _n(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, lK = (t) => {
  const e = cs(!1), r = cs(!0);
  return _n(e, r), _n(e, t.start), _n(t.end, r), t.end.isEnd = !1, { start: e, end: r };
}, cK = (t) => {
  const e = cs(!1), r = cs(!0);
  return _n(e, t.start), _n(t.end, r), _n(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, _n = (t, e) => {
  t.epsilonTransitions.push(e);
}, uK = (t, e, r) => {
  t.transition[r] = e;
}, cs = (t) => ({
  isEnd: t,
  transition: {},
  epsilonTransitions: []
}), hK = "https://json-schema.org/keyword/itemPattern", UT = async (t, e) => {
  const r = [[]];
  let n = r[0];
  for await (const i of dc(t))
    if (Oa(i) === "string") {
      const s = Ct(i);
      if (s === "*")
        n.push(aK(n.pop()));
      else if (s === "?")
        n.push(lK(n.pop()));
      else if (s === "+")
        n.push(cK(n.pop()));
      else if (s === "|")
        n = [], r.push(n);
      else
        throw Error(`Unsupported pattern syntax: ${s}`);
    } else {
      const s = Oa(i) === "array" ? UT(i, e) : iK(await Ve.compile(i, e));
      n.push(await s);
    }
  return ST(t) === 0 ? nK() : r.map((i) => i.reduce(sK)).reduce(oK);
}, WE = (t) => (e, r, n, i, s) => {
  if (Ht(r) !== "array")
    return !0;
  let o = [];
  Ex(e.start, o, []);
  for (const a of Ih(r)) {
    const l = [];
    for (const c of o) {
      const p = pK(t, c.transition, a, n, i, s);
      p && Ex(p, l, []);
    }
    o = l;
  }
  return !!o.find((a) => a.isEnd);
}, Ex = (t, e, r) => {
  if (t.epsilonTransitions.length)
    for (const n of t.epsilonTransitions)
      r.find((i) => i === n) || (r.push(n), Ex(n, e, r));
  else
    e.push(t);
}, pK = (t, e, r, n, i, s) => {
  for (const o in e)
    if (t(o, r, n, i, s))
      return e[o];
}, dK = WE(Ve.interpret), fK = WE(Ve.collectEvaluatedProperties), gK = WE(Ve.collectEvaluatedItems), mK = { id: hK, compile: UT, interpret: dK, collectEvalatedProperties: fK, collectEvalatedItems: gK }, yK = "https://json-schema.org/keyword/items", vK = async (t, e, r) => {
  const n = Yr(t.document.dialectId, "https://json-schema.org/keyword/prefixItems"), i = await Ws(n, r);
  return [Oa(i) === "array" ? ST(i) : 0, await Ve.compile(t, e)];
}, VT = ([t, e], r, n, i, s) => {
  if (Ht(r) !== "array")
    return !0;
  let o = !0;
  for (const a of MW(t, Ih(r)))
    Ve.interpret(e, a, n, i, s) || (o = !1);
  return o;
}, bK = (t, e, r, n) => {
  if (!VT(t, e, r, n, !0))
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (let s = t[0]; s < ag(e); s++)
    i.add(s);
  return i;
}, wK = { id: yK, compile: vK, interpret: VT, collectEvaluatedItems: bK }, xK = "https://json-schema.org/keyword/maxContains", EK = (t) => Ct(t), SK = () => !0, AK = { id: xK, compile: EK, interpret: SK }, kK = "https://json-schema.org/keyword/maxItems", _K = (t) => Ct(t), CK = (t, e) => Ht(e) !== "array" || ag(e) <= t, IK = { id: kK, compile: _K, interpret: CK }, PK = "https://json-schema.org/keyword/maxLength", RK = (t) => Ct(t), OK = (t, e) => Ht(e) !== "string" || [...Sr(e)].length <= t, TK = { id: PK, compile: RK, interpret: OK }, LK = "https://json-schema.org/keyword/maxProperties", MK = (t) => Ct(t), NK = (t, e) => Ht(e) !== "object" || [...HE(e)].length <= t, DK = { id: LK, compile: MK, interpret: NK }, $K = "https://json-schema.org/keyword/maximum", jK = (t) => Ct(t), BK = (t, e) => Ht(e) !== "number" || Sr(e) <= t, FK = { id: $K, compile: jK, interpret: BK }, zK = "https://json-schema.org/keyword/minContains", UK = (t) => Ct(t), VK = () => !0, HK = { id: zK, compile: UK, interpret: VK }, GK = "https://json-schema.org/keyword/minItems", WK = (t) => Ct(t), qK = (t, e) => Ht(e) !== "array" || ag(e) >= t, QK = { id: GK, compile: WK, interpret: qK }, KK = "https://json-schema.org/keyword/minLength", YK = (t) => Ct(t), ZK = (t, e) => Ht(e) !== "string" || [...Sr(e)].length >= t, JK = { id: KK, compile: YK, interpret: ZK }, XK = "https://json-schema.org/keyword/minProperties", eY = (t) => Ct(t), tY = (t, e) => Ht(e) !== "object" || [...HE(e)].length >= t, rY = { id: XK, compile: eY, interpret: tY }, nY = "https://json-schema.org/keyword/minimum", iY = (t) => Ct(t), sY = (t, e) => Ht(e) !== "number" || Sr(e) >= t, oY = { id: nY, compile: iY, interpret: sY }, aY = "https://json-schema.org/keyword/multipleOf", lY = (t) => Ct(t), cY = (t, e) => {
  if (Ht(e) !== "number")
    return !0;
  const r = Sr(e) % t;
  return T9(0, r) || T9(t, r);
}, T9 = (t, e) => Math.abs(t - e) < 11920929e-14, uY = { id: aY, compile: lY, interpret: cY }, hY = "https://json-schema.org/keyword/not", pY = (...t) => Ve.compile(...t), dY = (...t) => !Ve.interpret(...t), fY = { id: hY, compile: pY, interpret: dY }, gY = "https://json-schema.org/keyword/oneOf", mY = (t, e) => fn(
  dc(t),
  Qn((r) => Ve.compile(r, e)),
  Zs
), yY = (t, e, r, n, i) => {
  let s = 0;
  for (const o of t)
    Ve.interpret(o, e, r, n, i) && s++;
  return s === 1;
}, vY = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ve.collectEvaluatedProperties(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, bY = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ve.collectEvaluatedItems(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, wY = { id: gY, compile: mY, interpret: yY, collectEvaluatedProperties: vY, collectEvaluatedItems: bY }, xY = "https://json-schema.org/keyword/pattern", EY = (t) => new RegExp(Ct(t), "u"), SY = (t, e) => Ht(e) !== "string" || t.test(Sr(e)), AY = { id: xY, compile: EY, interpret: SY }, kY = "https://json-schema.org/keyword/patternProperties", _Y = (t, e) => fn(
  eh(t),
  Qn(async ([r, n]) => [
    new RegExp(r, "u"),
    await Ve.compile(n, e)
  ]),
  Zs
), CY = (t, e, r, n, i) => {
  if (Ht(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    for (const [l, c] of fc(e)) {
      const p = Sr(l);
      o.test(p) && !Ve.interpret(a, c, r, n, i) && (s = !1);
    }
  return s;
}, IY = (t, e, r, n) => {
  if (Ht(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    for (const [a, l] of fc(e)) {
      const c = Sr(a);
      if (s.test(c)) {
        if (!Ve.interpret(o, l, r, n, !0))
          return !1;
        i.add(c);
      }
    }
  return i;
}, PY = { id: kY, compile: _Y, interpret: CY, collectEvaluatedProperties: IY }, RY = "https://json-schema.org/keyword/prefixItems", OY = (t, e) => fn(
  dc(t),
  Qn((r) => Ve.compile(r, e)),
  Zs
), HT = (t, e, r, n, i) => {
  if (Ht(e) !== "array")
    return !0;
  let s = !0, o = 0;
  const a = ag(e);
  for (const [l, c] of VE(t, Ih(e))) {
    if (o >= a)
      break;
    Ve.interpret(l, c, r, n, i) || (s = !1), o++;
  }
  return s;
}, TY = (t, e, r, n) => HT(t, e, r, n, !0) && new Set(t.map((i, s) => s)), LY = { id: RY, compile: OY, interpret: HT, collectEvaluatedItems: TY }, MY = "https://json-schema.org/keyword/properties", NY = (t, e) => fn(
  eh(t),
  Qn(async ([r, n]) => [r, await Ve.compile(n, e)]),
  wx
), DY = (t, e, r, n, i) => {
  if (Ht(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of fc(e)) {
    const l = Sr(o);
    l in t && !Ve.interpret(t[l], a, r, n, i) && (s = !1);
  }
  return s;
}, $Y = (t, e, r, n) => {
  if (Ht(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of fc(e)) {
    const a = Sr(s);
    if (a in t) {
      if (!Ve.interpret(t[a], o, r, n, !0))
        return !1;
      i.add(a);
    }
  }
  return i;
}, jY = { id: MY, compile: NY, interpret: DY, collectEvaluatedProperties: $Y }, BY = "https://json-schema.org/keyword/propertyDependencies", FY = (t, e) => fn(
  eh(t),
  Qn(async ([r, n]) => [r, await fn(
    eh(n),
    Qn(async ([i, s]) => [i, await Ve.compile(s, e)]),
    wx
  )]),
  wx
), zY = (t, e, r, n, i) => {
  if (Ht(e) !== "object")
    return !0;
  let s = !0;
  const o = Sr(e);
  for (const [a, l] of Object.entries(t)) {
    const c = o[a];
    Fp(a, e) && c in l && !Ve.interpret(l[c], e, r, n, i) && (s = !1);
  }
  return s;
}, UY = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s in t) {
    const o = Sr(e)[s], a = t[s];
    if (Fp(s, e) && o in a) {
      const l = Ve.collectEvaluatedProperties(a[o], e, r, n);
      if (!l)
        return !1;
      l.forEach(i.add, i);
    }
  }
  return i;
}, VY = { id: BY, compile: FY, interpret: zY, collectEvaluatedProperties: UY }, HY = "https://json-schema.org/keyword/propertyNames", GY = (t, e) => Ve.compile(t, e), WY = (t, e, r, n) => {
  if (Ht(e) !== "object")
    return !0;
  let i = !0;
  for (const s of HE(e))
    Ve.interpret(t, s, r, n, !0) || (i = !1);
  return i;
}, qY = { id: HY, compile: GY, interpret: WY }, GT = "https://json-schema.org/keyword/readOnly", QY = (t) => Ct(t), KY = (t, e, r, n, i, s) => (As(e, GT, s, t), !0), YY = { id: GT, compile: QY, interpret: KY }, ZY = "https://json-schema.org/keyword/ref", JY = (...t) => Ve.compile(...t), XY = (...t) => Ve.interpret(...t), eZ = (...t) => Ve.collectEvaluatedProperties(...t), tZ = (...t) => Ve.collectEvaluatedItems(...t), rZ = { id: ZY, compile: JY, interpret: XY, collectEvaluatedProperties: eZ, collectEvaluatedItems: tZ }, nZ = "https://json-schema.org/keyword/requireAllExcept", iZ = async (t, e, r) => {
  const n = await Ct(t), i = Yr(t.document.dialectId, "https://json-schema.org/keyword/properties"), s = await Ws(i, r), o = Oa(s) === "object" ? vx(s) : [], a = new Set(o);
  return n.forEach((l) => o.remove(l)), [...a];
}, sZ = (t, e) => Ht(e) !== "object" || t.every((r) => Object.hasOwn(Sr(e), r)), oZ = { id: nZ, compile: iZ, interpret: sZ }, aZ = "https://json-schema.org/keyword/required", lZ = (t) => Ct(t), cZ = (t, e) => Ht(e) !== "object" || t.every((r) => Object.hasOwn(Sr(e), r)), uZ = { id: aZ, compile: lZ, interpret: cZ }, WT = "https://json-schema.org/keyword/title", hZ = (t) => Ct(t), pZ = (t, e, r, n, i, s) => (As(e, WT, s, t), !0), dZ = { id: WT, compile: hZ, interpret: pZ }, fZ = "https://json-schema.org/keyword/then", gZ = async (t, e, r) => {
  const n = Yr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (ET(n, r)) {
    const i = await Ws(n, r);
    return [await Ve.compile(i, e), await Ve.compile(t, e)];
  } else
    return [];
}, mZ = ([t, e], r, n, i, s) => t === void 0 || !Ve.interpret(t, r, n, i, !0) || Ve.interpret(e, r, n, i, s), yZ = ([t, e], r, n, i) => t === void 0 || !Ve.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ve.collectEvaluatedProperties(e, r, n, i), vZ = ([t, e], r, n, i) => t === void 0 || !Ve.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ve.collectEvaluatedItems(e, r, n, i), bZ = { id: fZ, compile: gZ, interpret: mZ, collectEvaluatedProperties: yZ, collectEvaluatedItems: vZ }, wZ = "https://json-schema.org/keyword/type", xZ = (t) => Ct(t), EZ = (t, e) => typeof t == "string" ? L9(e)(t) : t.some(L9(e)), L9 = (t) => (e) => e === "integer" ? Ht(t) === "number" && Number.isInteger(Sr(t)) : Ht(t) === e, SZ = { id: wZ, compile: xZ, interpret: EZ }, AZ = "https://json-schema.org/keyword/unevaluatedItems", kZ = async (t, e, r) => [Bp(r), await Ve.compile(t, e)], _Z = ([t, e], r, n, i, s) => {
  if (Ht(r) !== "array")
    return !0;
  const o = Ve.collectEvaluatedItems(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of VE(Ih(r), _T(0)))
    !o.has(c) && !Ve.interpret(e, l, n, i, s) && (a = !1);
  return a;
}, CZ = (t, e, r, n) => {
  const i = Ve.collectEvaluatedItems(t[0], e, r, n, !0);
  if (!i)
    return !1;
  const s = /* @__PURE__ */ new Set();
  for (let o = 0; o < ag(e); o++)
    i.has(o) || s.add(o);
  return s;
}, IZ = { id: AZ, compile: kZ, interpret: _Z, collectEvaluatedItems: CZ }, PZ = "https://json-schema.org/keyword/unevaluatedProperties", RZ = async (t, e, r) => [Bp(r), await Ve.compile(t, e)], OZ = ([t, e], r, n, i, s) => {
  if (Ht(r) !== "object")
    return !0;
  const o = Ve.collectEvaluatedProperties(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of fc(r)) {
    const p = Sr(l);
    !o.has(p) && !Ve.interpret(e, c, n, i, s) && (a = !1);
  }
  return a;
}, TZ = ([t, e], r, n, i) => {
  if (Ht(r) !== "object")
    return !0;
  const s = Ve.collectEvaluatedProperties(t, r, n, i, !0);
  if (!s)
    return !1;
  for (const [o, a] of fc(r)) {
    const l = Sr(o);
    if (!s.has(l)) {
      if (!Ve.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, LZ = { id: PZ, compile: RZ, interpret: OZ, collectEvaluatedProperties: TZ }, MZ = "https://json-schema.org/keyword/uniqueItems", NZ = (t) => Ct(t), DZ = (t, e) => {
  if (Ht(e) !== "array" || t === !1)
    return !0;
  const r = Sr(e).map(lg);
  return new Set(r).size === r.length;
}, $Z = { id: MZ, compile: NZ, interpret: DZ }, qT = "https://json-schema.org/keyword/unknown", jZ = (t) => [[...fx(t.cursor)].pop(), Ct(t)], BZ = ([t, e], r, n, i, s, o) => {
  const a = `${qT}#${t}`;
  return As(r, a, o, e), !0;
}, FZ = { id: qT, compile: jZ, interpret: BZ }, zZ = { id: "https://json-schema.org/keyword/vocabulary" }, QT = "https://json-schema.org/keyword/writeOnly", UZ = (t) => Ct(t), VZ = (t, e, r, n, i, s) => (As(e, QT, s, t), !0), HZ = { id: QT, compile: UZ, interpret: VZ };
mT("application/schema+json", TW);
at(aq);
at(dq);
at(fq);
at(wq);
at(_q);
at(Lq);
at($q);
at(zq);
at(Hq);
at(qq);
at(Yq);
at(Xq);
at(nQ);
at(aQ);
at(pQ);
at(gQ);
at(vQ);
at(bQ);
at(kQ);
at(OQ);
at(NQ);
at(jQ);
at(UQ);
at(WQ);
at(KQ);
at(YQ);
at(rK);
at(mK);
at(wK);
at(AK);
at(IK);
at(TK);
at(DK);
at(FK);
at(HK);
at(QK);
at(JK);
at(rY);
at(oY);
at(uY);
at(fY);
at(wY);
at(AY);
at(PY);
at(LY);
at(jY);
at(VY);
at(qY);
at(YY);
at(rZ);
at(oZ);
at(uZ);
at(dZ);
at(bZ);
at(SZ);
at(IZ);
at(LZ);
at($Z);
at(FZ);
at(zZ);
at(HZ);
const GZ = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://json-schema.org/draft/2020-12/schema",
  $vocabulary: {
    "https://json-schema.org/draft/2020-12/vocab/core": !0,
    "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
    "https://json-schema.org/draft/2020-12/vocab/validation": !0,
    "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
    "https://json-schema.org/draft/2020-12/vocab/content": !0
  },
  $dynamicAnchor: "meta",
  title: "Core and Validation specifications meta-schema",
  allOf: [
    { $ref: "meta/core" },
    { $ref: "meta/applicator" },
    { $ref: "meta/unevaluated" },
    { $ref: "meta/validation" },
    { $ref: "meta/meta-data" },
    { $ref: "meta/format-annotation" },
    { $ref: "meta/content" }
  ],
  type: ["object", "boolean"],
  properties: {
    definitions: {
      $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    dependencies: {
      $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
      type: "object",
      additionalProperties: {
        anyOf: [
          { $dynamicRef: "#meta" },
          { $ref: "meta/validation#/$defs/stringArray" }
        ]
      }
    }
  }
}, WZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/core",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Core vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    $id: {
      type: "string",
      format: "uri-reference",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $anchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicRef: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicAnchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        type: "string",
        format: "uri"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    }
  }
}, qZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/applicator",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    prefixItems: { $ref: "#/$defs/schemaArray" },
    items: { $dynamicRef: "#meta" },
    contains: { $dynamicRef: "#meta" },
    additionalProperties: { $dynamicRef: "#meta" },
    properties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      propertyNames: { format: "regex" },
      default: {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      }
    },
    propertyNames: { $dynamicRef: "#meta" },
    if: { $dynamicRef: "#meta" },
    then: { $dynamicRef: "#meta" },
    else: { $dynamicRef: "#meta" },
    allOf: { $ref: "#/$defs/schemaArray" },
    anyOf: { $ref: "#/$defs/schemaArray" },
    oneOf: { $ref: "#/$defs/schemaArray" },
    not: { $dynamicRef: "#meta" }
  },
  $defs: {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: { $dynamicRef: "#meta" }
    }
  }
}, QZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/validation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Validation vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: { $ref: "#/$defs/nonNegativeInteger" },
    minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: { $ref: "#/$defs/nonNegativeInteger" },
    minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    uniqueItems: {
      type: "boolean",
      default: !1
    },
    maxContains: { $ref: "#/$defs/nonNegativeInteger" },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 1
    },
    maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
    minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    required: { $ref: "#/$defs/stringArray" },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    },
    const: !0,
    enum: {
      type: "array",
      items: !0
    },
    type: {
      anyOf: [
        { $ref: "#/$defs/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/$defs/simpleTypes" },
          minItems: 1,
          uniqueItems: !0
        }
      ]
    }
  },
  $defs: {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 0
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: []
    }
  }
}, KZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Meta-data vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    default: !0,
    deprecated: {
      type: "boolean",
      default: !1
    },
    readOnly: {
      type: "boolean",
      default: !1
    },
    writeOnly: {
      type: "boolean",
      default: !1
    },
    examples: {
      type: "array",
      items: !0
    }
  }
}, YZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for annotation results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, ZZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-assertion",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for assertion results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, JZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/content",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Content vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    contentSchema: { $dynamicRef: "#meta" }
  }
}, XZ = {
  $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Unevaluated applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    unevaluatedItems: { $dynamicRef: "#meta" },
    unevaluatedProperties: { $dynamicRef: "#meta" }
  }
}, eJ = { id: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor" }, tJ = "https://json-schema.org/keyword/draft-2020-12/dynamicRef", rJ = async (t, e) => {
  const r = hT(Ct(t)), n = await V2(Ct(t), t);
  return await Ve.compile(n, e), [n.document.baseUri, r, Bp(n)];
}, qE = (t, [e, r, n], i, s, o, a) => r in s.metaData[e].dynamicAnchors ? (o = { ...s.metaData[e].dynamicAnchors, ...o }, t(o[r], i, s, o, a)) : t(n, i, s, o, a), nJ = (...t) => qE(Ve.interpret, ...t), iJ = (...t) => qE(Ve.collectEvaluatedProperties, ...t), sJ = (...t) => qE(Ve.collectEvaluatedItems, ...t), oJ = { id: tJ, compile: rJ, interpret: nJ, collectEvaluatedProperties: iJ, collectEvaluatedItems: sJ };
at(oJ);
at(eJ);
pc("https://json-schema.org/draft/2020-12/vocab/core", {
  $anchor: "https://json-schema.org/keyword/anchor",
  $comment: "https://json-schema.org/keyword/comment",
  $defs: "https://json-schema.org/keyword/definitions",
  $dynamicAnchor: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor",
  $dynamicRef: "https://json-schema.org/keyword/draft-2020-12/dynamicRef",
  $id: "https://json-schema.org/keyword/id",
  $ref: "https://json-schema.org/keyword/ref",
  $vocabulary: "https://json-schema.org/keyword/vocabulary"
});
pc("https://json-schema.org/draft/2020-12/vocab/applicator", {
  additionalProperties: "https://json-schema.org/keyword/additionalProperties",
  allOf: "https://json-schema.org/keyword/allOf",
  anyOf: "https://json-schema.org/keyword/anyOf",
  contains: "https://json-schema.org/keyword/contains",
  dependentSchemas: "https://json-schema.org/keyword/dependentSchemas",
  if: "https://json-schema.org/keyword/if",
  then: "https://json-schema.org/keyword/then",
  else: "https://json-schema.org/keyword/else",
  items: "https://json-schema.org/keyword/items",
  not: "https://json-schema.org/keyword/not",
  oneOf: "https://json-schema.org/keyword/oneOf",
  patternProperties: "https://json-schema.org/keyword/patternProperties",
  prefixItems: "https://json-schema.org/keyword/prefixItems",
  properties: "https://json-schema.org/keyword/properties",
  propertyNames: "https://json-schema.org/keyword/propertyNames"
});
pc("https://json-schema.org/draft/2020-12/vocab/validation", {
  const: "https://json-schema.org/keyword/const",
  dependentRequired: "https://json-schema.org/keyword/dependentRequired",
  enum: "https://json-schema.org/keyword/enum",
  exclusiveMaximum: "https://json-schema.org/keyword/exclusiveMaximum",
  exclusiveMinimum: "https://json-schema.org/keyword/exclusiveMinimum",
  maxContains: "https://json-schema.org/keyword/maxContains",
  maxItems: "https://json-schema.org/keyword/maxItems",
  maxLength: "https://json-schema.org/keyword/maxLength",
  maxProperties: "https://json-schema.org/keyword/maxProperties",
  maximum: "https://json-schema.org/keyword/maximum",
  minContains: "https://json-schema.org/keyword/minContains",
  minItems: "https://json-schema.org/keyword/minItems",
  minLength: "https://json-schema.org/keyword/minLength",
  minProperties: "https://json-schema.org/keyword/minProperties",
  minimum: "https://json-schema.org/keyword/minimum",
  multipleOf: "https://json-schema.org/keyword/multipleOf",
  pattern: "https://json-schema.org/keyword/pattern",
  required: "https://json-schema.org/keyword/required",
  type: "https://json-schema.org/keyword/type",
  uniqueItems: "https://json-schema.org/keyword/uniqueItems"
});
pc("https://json-schema.org/draft/2020-12/vocab/meta-data", {
  default: "https://json-schema.org/keyword/default",
  deprecated: "https://json-schema.org/keyword/deprecated",
  description: "https://json-schema.org/keyword/description",
  examples: "https://json-schema.org/keyword/examples",
  readOnly: "https://json-schema.org/keyword/readOnly",
  title: "https://json-schema.org/keyword/title",
  writeOnly: "https://json-schema.org/keyword/writeOnly"
});
pc("https://json-schema.org/draft/2020-12/vocab/format-annotation", {
  format: "https://json-schema.org/keyword/format"
});
pc("https://json-schema.org/draft/2020-12/vocab/format-assertion", {
  format: "https://json-schema.org/keyword/format-assertion"
});
pc("https://json-schema.org/draft/2020-12/vocab/content", {
  contentEncoding: "https://json-schema.org/keyword/contentEncoding",
  contentMediaType: "https://json-schema.org/keyword/contentMediaType",
  contentSchema: "https://json-schema.org/keyword/contentSchema"
});
pc("https://json-schema.org/draft/2020-12/vocab/unevaluated", {
  unevaluatedItems: "https://json-schema.org/keyword/unevaluatedItems",
  unevaluatedProperties: "https://json-schema.org/keyword/unevaluatedProperties"
});
dT("https://json-schema.org/draft/2020-12/schema", {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, !0);
Ua(GZ);
Ua(WZ);
Ua(qZ);
Ua(QZ);
Ua(KZ);
Ua(YZ);
Ua(ZZ);
Ua(JZ);
Ua(XZ);
function Rm(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var M9 = { exports: {} };
/*! jsonpath 1.1.1 */
var N9;
function aJ() {
  return N9 || (N9 = 1, function(t, e) {
    (function(r) {
      t.exports = r();
    })(function() {
      return function r(n, i, s) {
        function o(c, p) {
          if (!i[c]) {
            if (!n[c]) {
              var h = typeof Rm == "function" && Rm;
              if (!p && h) return h(c, !0);
              if (a) return a(c, !0);
              var d = new Error("Cannot find module '" + c + "'");
              throw d.code = "MODULE_NOT_FOUND", d;
            }
            var v = i[c] = { exports: {} };
            n[c][0].call(v.exports, function(m) {
              var b = n[c][1][m];
              return o(b || m);
            }, v, v.exports, r, n, i, s);
          }
          return i[c].exports;
        }
        for (var a = typeof Rm == "function" && Rm, l = 0; l < s.length; l++) o(s[l]);
        return o;
      }({ "./aesprim": [function(r, n, i) {
        (function(s, o) {
          o(typeof i < "u" ? i : s.esprima = {});
        })(this, function(s) {
          var o, a, l, c, p, h, d, v, m, b, f, E, A, x, g, w, _, S;
          o = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
          }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
            "(",
            "{",
            "[",
            "in",
            "typeof",
            "instanceof",
            "new",
            "return",
            "case",
            "delete",
            "throw",
            "void",
            // assignment operators
            "=",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "<<=",
            ">>=",
            ">>>=",
            "&=",
            "|=",
            "^=",
            ",",
            // binary/unary operators
            "+",
            "-",
            "*",
            "/",
            "%",
            "++",
            "--",
            "<<",
            ">>",
            ">>>",
            "&",
            "|",
            "^",
            "!",
            "~",
            "&&",
            "||",
            "?",
            ":",
            "===",
            "==",
            ">=",
            "<=",
            "<",
            ">",
            "!=",
            "!=="
          ], c = {
            AssignmentExpression: "AssignmentExpression",
            ArrayExpression: "ArrayExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            Program: "Program",
            Property: "Property",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SwitchStatement: "SwitchStatement",
            SwitchCase: "SwitchCase",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement"
          }, p = {
            Data: 1,
            Get: 2,
            Set: 4
          }, h = {
            UnexpectedToken: "Unexpected token %0",
            UnexpectedNumber: "Unexpected number",
            UnexpectedString: "Unexpected string",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedEOS: "Unexpected end of input",
            NewlineAfterThrow: "Illegal newline after throw",
            InvalidRegExp: "Invalid regular expression",
            UnterminatedRegExp: "Invalid regular expression: missing /",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NoCatchOrFinally: "Missing catch or finally after try",
            UnknownLabel: "Undefined label '%0'",
            Redeclaration: "%0 '%1' has already been declared",
            IllegalContinue: "Illegal continue statement",
            IllegalBreak: "Illegal break statement",
            IllegalReturn: "Illegal return statement",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
            AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
            AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode"
          }, d = {
            NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
            NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
          };
          function R(u, y) {
            if (!u)
              throw new Error("ASSERT: " + y);
          }
          function L(u) {
            return u >= 48 && u <= 57;
          }
          function F(u) {
            return "0123456789abcdefABCDEF".indexOf(u) >= 0;
          }
          function z(u) {
            return "01234567".indexOf(u) >= 0;
          }
          function j(u) {
            return u === 32 || u === 9 || u === 11 || u === 12 || u === 160 || u >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(u) >= 0;
          }
          function W(u) {
            return u === 10 || u === 13 || u === 8232 || u === 8233;
          }
          function te(u) {
            return u == 64 || u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierStart.test(String.fromCharCode(u));
          }
          function le(u) {
            return u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u >= 48 && u <= 57 || // 0..9
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierPart.test(String.fromCharCode(u));
          }
          function ce(u) {
            switch (u) {
              case "class":
              case "enum":
              case "export":
              case "extends":
              case "import":
              case "super":
                return !0;
              default:
                return !1;
            }
          }
          function Ee(u) {
            switch (u) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return !0;
              default:
                return !1;
            }
          }
          function xe(u) {
            return u === "eval" || u === "arguments";
          }
          function _e(u) {
            if (b && Ee(u))
              return !0;
            switch (u.length) {
              case 2:
                return u === "if" || u === "in" || u === "do";
              case 3:
                return u === "var" || u === "for" || u === "new" || u === "try" || u === "let";
              case 4:
                return u === "this" || u === "else" || u === "case" || u === "void" || u === "with" || u === "enum";
              case 5:
                return u === "while" || u === "break" || u === "catch" || u === "throw" || u === "const" || u === "yield" || u === "class" || u === "super";
              case 6:
                return u === "return" || u === "typeof" || u === "delete" || u === "switch" || u === "export" || u === "import";
              case 7:
                return u === "default" || u === "finally" || u === "extends";
              case 8:
                return u === "function" || u === "continue" || u === "debugger";
              case 10:
                return u === "instanceof";
              default:
                return !1;
            }
          }
          function Ie(u, y, k, T, V) {
            var ne;
            R(typeof k == "number", "Comment must have valid position"), !(_.lastCommentStart >= k) && (_.lastCommentStart = k, ne = {
              type: u,
              value: y
            }, S.range && (ne.range = [k, T]), S.loc && (ne.loc = V), S.comments.push(ne), S.attachComment && (S.leadingComments.push(ne), S.trailingComments.push(ne)));
          }
          function je(u) {
            var y, k, T, V;
            for (y = f - u, k = {
              start: {
                line: E,
                column: f - A - u
              }
            }; f < x; )
              if (T = m.charCodeAt(f), ++f, W(T)) {
                S.comments && (V = m.slice(y + u, f - 1), k.end = {
                  line: E,
                  column: f - A - 1
                }, Ie("Line", V, y, f - 1, k)), T === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f;
                return;
              }
            S.comments && (V = m.slice(y + u, f), k.end = {
              line: E,
              column: f - A
            }, Ie("Line", V, y, f, k));
          }
          function ue() {
            var u, y, k, T;
            for (S.comments && (u = f - 2, y = {
              start: {
                line: E,
                column: f - A - 2
              }
            }); f < x; )
              if (k = m.charCodeAt(f), W(k))
                k === 13 && m.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && fe({}, h.UnexpectedToken, "ILLEGAL");
              else if (k === 42) {
                if (m.charCodeAt(f + 1) === 47) {
                  ++f, ++f, S.comments && (T = m.slice(u + 2, f - 2), y.end = {
                    line: E,
                    column: f - A
                  }, Ie("Block", T, u, f, y));
                  return;
                }
                ++f;
              } else
                ++f;
            fe({}, h.UnexpectedToken, "ILLEGAL");
          }
          function O() {
            var u, y;
            for (y = f === 0; f < x; )
              if (u = m.charCodeAt(f), j(u))
                ++f;
              else if (W(u))
                ++f, u === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f, y = !0;
              else if (u === 47)
                if (u = m.charCodeAt(f + 1), u === 47)
                  ++f, ++f, je(2), y = !0;
                else if (u === 42)
                  ++f, ++f, ue();
                else
                  break;
              else if (y && u === 45)
                if (m.charCodeAt(f + 1) === 45 && m.charCodeAt(f + 2) === 62)
                  f += 3, je(3);
                else
                  break;
              else if (u === 60)
                if (m.slice(f + 1, f + 4) === "!--")
                  ++f, ++f, ++f, ++f, je(4);
                else
                  break;
              else
                break;
          }
          function N(u) {
            var y, k, T, V = 0;
            for (k = u === "u" ? 4 : 2, y = 0; y < k; ++y)
              if (f < x && F(m[f]))
                T = m[f++], V = V * 16 + "0123456789abcdef".indexOf(T.toLowerCase());
              else
                return "";
            return String.fromCharCode(V);
          }
          function J() {
            var u, y;
            for (u = m.charCodeAt(f++), y = String.fromCharCode(u), u === 92 && (m.charCodeAt(f) !== 117 && fe({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !te(u.charCodeAt(0))) && fe({}, h.UnexpectedToken, "ILLEGAL"), y = u); f < x && (u = m.charCodeAt(f), !!le(u)); )
              ++f, y += String.fromCharCode(u), u === 92 && (y = y.substr(0, y.length - 1), m.charCodeAt(f) !== 117 && fe({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !le(u.charCodeAt(0))) && fe({}, h.UnexpectedToken, "ILLEGAL"), y += u);
            return y;
          }
          function re() {
            var u, y;
            for (u = f++; f < x; ) {
              if (y = m.charCodeAt(f), y === 92)
                return f = u, J();
              if (le(y))
                ++f;
              else
                break;
            }
            return m.slice(u, f);
          }
          function oe() {
            var u, y, k;
            return u = f, y = m.charCodeAt(f) === 92 ? J() : re(), y.length === 1 ? k = o.Identifier : _e(y) ? k = o.Keyword : y === "null" ? k = o.NullLiteral : y === "true" || y === "false" ? k = o.BooleanLiteral : k = o.Identifier, {
              type: k,
              value: y,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function ee() {
            var u = f, y = m.charCodeAt(f), k, T = m[f], V, ne, Ce;
            switch (y) {
              case 46:
              case 40:
              case 41:
              case 59:
              case 44:
              case 123:
              case 125:
              case 91:
              case 93:
              case 58:
              case 63:
              case 126:
                return ++f, S.tokenize && (y === 40 ? S.openParenToken = S.tokens.length : y === 123 && (S.openCurlyToken = S.tokens.length)), {
                  type: o.Punctuator,
                  value: String.fromCharCode(y),
                  lineNumber: E,
                  lineStart: A,
                  start: u,
                  end: f
                };
              default:
                if (k = m.charCodeAt(f + 1), k === 61)
                  switch (y) {
                    case 43:
                    case 45:
                    case 47:
                    case 60:
                    case 62:
                    case 94:
                    case 124:
                    case 37:
                    case 38:
                    case 42:
                      return f += 2, {
                        type: o.Punctuator,
                        value: String.fromCharCode(y) + String.fromCharCode(k),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                    case 33:
                    case 61:
                      return f += 2, m.charCodeAt(f) === 61 && ++f, {
                        type: o.Punctuator,
                        value: m.slice(u, f),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                  }
            }
            if (Ce = m.substr(f, 4), Ce === ">>>=")
              return f += 4, {
                type: o.Punctuator,
                value: Ce,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (ne = Ce.substr(0, 3), ne === ">>>" || ne === "<<=" || ne === ">>=")
              return f += 3, {
                type: o.Punctuator,
                value: ne,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (V = ne.substr(0, 2), T === V[1] && "+-<>&|".indexOf(T) >= 0 || V === "=>")
              return f += 2, {
                type: o.Punctuator,
                value: V,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if ("<>=!+-*%&|^/".indexOf(T) >= 0)
              return ++f, {
                type: o.Punctuator,
                value: T,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            fe({}, h.UnexpectedToken, "ILLEGAL");
          }
          function ae(u) {
            for (var y = ""; f < x && F(m[f]); )
              y += m[f++];
            return y.length === 0 && fe({}, h.UnexpectedToken, "ILLEGAL"), te(m.charCodeAt(f)) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt("0x" + y, 16),
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function me(u) {
            for (var y = "0" + m[f++]; f < x && z(m[f]); )
              y += m[f++];
            return (te(m.charCodeAt(f)) || L(m.charCodeAt(f))) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt(y, 8),
              octal: !0,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function H() {
            var u, y, k;
            if (k = m[f], R(
              L(k.charCodeAt(0)) || k === ".",
              "Numeric literal must start with a decimal digit or a decimal point"
            ), y = f, u = "", k !== ".") {
              if (u = m[f++], k = m[f], u === "0") {
                if (k === "x" || k === "X")
                  return ++f, ae(y);
                if (z(k))
                  return me(y);
                k && L(k.charCodeAt(0)) && fe({}, h.UnexpectedToken, "ILLEGAL");
              }
              for (; L(m.charCodeAt(f)); )
                u += m[f++];
              k = m[f];
            }
            if (k === ".") {
              for (u += m[f++]; L(m.charCodeAt(f)); )
                u += m[f++];
              k = m[f];
            }
            if (k === "e" || k === "E")
              if (u += m[f++], k = m[f], (k === "+" || k === "-") && (u += m[f++]), L(m.charCodeAt(f)))
                for (; L(m.charCodeAt(f)); )
                  u += m[f++];
              else
                fe({}, h.UnexpectedToken, "ILLEGAL");
            return te(m.charCodeAt(f)) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseFloat(u),
              lineNumber: E,
              lineStart: A,
              start: y,
              end: f
            };
          }
          function X() {
            var u = "", y, k, T, V, ne, Ce, Me = !1, et, Xe;
            for (et = E, Xe = A, y = m[f], R(
              y === "'" || y === '"',
              "String literal must starts with a quote"
            ), k = f, ++f; f < x; )
              if (T = m[f++], T === y) {
                y = "";
                break;
              } else if (T === "\\")
                if (T = m[f++], !T || !W(T.charCodeAt(0)))
                  switch (T) {
                    case "u":
                    case "x":
                      Ce = f, ne = N(T), ne ? u += ne : (f = Ce, u += T);
                      break;
                    case "n":
                      u += `
`;
                      break;
                    case "r":
                      u += "\r";
                      break;
                    case "t":
                      u += "	";
                      break;
                    case "b":
                      u += "\b";
                      break;
                    case "f":
                      u += "\f";
                      break;
                    case "v":
                      u += "\v";
                      break;
                    default:
                      z(T) ? (V = "01234567".indexOf(T), V !== 0 && (Me = !0), f < x && z(m[f]) && (Me = !0, V = V * 8 + "01234567".indexOf(m[f++]), "0123".indexOf(T) >= 0 && f < x && z(m[f]) && (V = V * 8 + "01234567".indexOf(m[f++]))), u += String.fromCharCode(V)) : u += T;
                      break;
                  }
                else
                  ++E, T === "\r" && m[f] === `
` && ++f, A = f;
              else {
                if (W(T.charCodeAt(0)))
                  break;
                u += T;
              }
            return y !== "" && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.StringLiteral,
              value: u,
              octal: Me,
              startLineNumber: et,
              startLineStart: Xe,
              lineNumber: E,
              lineStart: A,
              start: k,
              end: f
            };
          }
          function Ae(u, y) {
            var k;
            try {
              k = new RegExp(u, y);
            } catch {
              fe({}, h.InvalidRegExp);
            }
            return k;
          }
          function Re() {
            var u, y, k, T, V;
            for (u = m[f], R(u === "/", "Regular expression literal must start with a slash"), y = m[f++], k = !1, T = !1; f < x; )
              if (u = m[f++], y += u, u === "\\")
                u = m[f++], W(u.charCodeAt(0)) && fe({}, h.UnterminatedRegExp), y += u;
              else if (W(u.charCodeAt(0)))
                fe({}, h.UnterminatedRegExp);
              else if (k)
                u === "]" && (k = !1);
              else if (u === "/") {
                T = !0;
                break;
              } else u === "[" && (k = !0);
            return T || fe({}, h.UnterminatedRegExp), V = y.substr(1, y.length - 2), {
              value: V,
              literal: y
            };
          }
          function Fe() {
            var u, y, k, T;
            for (y = "", k = ""; f < x && (u = m[f], !!le(u.charCodeAt(0))); )
              if (++f, u === "\\" && f < x)
                if (u = m[f], u === "u") {
                  if (++f, T = f, u = N("u"), u)
                    for (k += u, y += "\\u"; T < f; ++T)
                      y += m[T];
                  else
                    f = T, k += "u", y += "\\u";
                  ye({}, h.UnexpectedToken, "ILLEGAL");
                } else
                  y += "\\", ye({}, h.UnexpectedToken, "ILLEGAL");
              else
                k += u, y += u;
            return {
              value: k,
              literal: y
            };
          }
          function Te() {
            var u, y, k, T;
            return w = null, O(), u = f, y = Re(), k = Fe(), T = Ae(y.value, k.value), S.tokenize ? {
              type: o.RegularExpression,
              value: T,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            } : {
              literal: y.literal + k.literal,
              value: T,
              start: u,
              end: f
            };
          }
          function qe() {
            var u, y, k, T;
            return O(), u = f, y = {
              start: {
                line: E,
                column: f - A
              }
            }, k = Te(), y.end = {
              line: E,
              column: f - A
            }, S.tokenize || (S.tokens.length > 0 && (T = S.tokens[S.tokens.length - 1], T.range[0] === u && T.type === "Punctuator" && (T.value === "/" || T.value === "/=") && S.tokens.pop()), S.tokens.push({
              type: "RegularExpression",
              value: k.literal,
              range: [u, f],
              loc: y
            })), k;
          }
          function tt(u) {
            return u.type === o.Identifier || u.type === o.Keyword || u.type === o.BooleanLiteral || u.type === o.NullLiteral;
          }
          function Pe() {
            var u, y;
            if (u = S.tokens[S.tokens.length - 1], !u)
              return qe();
            if (u.type === "Punctuator") {
              if (u.value === "]")
                return ee();
              if (u.value === ")")
                return y = S.tokens[S.openParenToken - 1], y && y.type === "Keyword" && (y.value === "if" || y.value === "while" || y.value === "for" || y.value === "with") ? qe() : ee();
              if (u.value === "}") {
                if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 4], !y)
                    return ee();
                } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 5], !y)
                    return qe();
                } else
                  return ee();
                return l.indexOf(y.value) >= 0 ? ee() : qe();
              }
              return qe();
            }
            return u.type === "Keyword" ? qe() : ee();
          }
          function At() {
            var u;
            return O(), f >= x ? {
              type: o.EOF,
              lineNumber: E,
              lineStart: A,
              start: f,
              end: f
            } : (u = m.charCodeAt(f), te(u) ? oe() : u === 40 || u === 41 || u === 59 ? ee() : u === 39 || u === 34 ? X() : u === 46 ? L(m.charCodeAt(f + 1)) ? H() : ee() : L(u) ? H() : S.tokenize && u === 47 ? Pe() : ee());
          }
          function er() {
            var u, y, k;
            return O(), u = {
              start: {
                line: E,
                column: f - A
              }
            }, y = At(), u.end = {
              line: E,
              column: f - A
            }, y.type !== o.EOF && (k = m.slice(y.start, y.end), S.tokens.push({
              type: a[y.type],
              value: k,
              range: [y.start, y.end],
              loc: u
            })), y;
          }
          function ge() {
            var u;
            return u = w, f = u.end, E = u.lineNumber, A = u.lineStart, w = typeof S.tokens < "u" ? er() : At(), f = u.end, E = u.lineNumber, A = u.lineStart, u;
          }
          function ht() {
            var u, y, k;
            u = f, y = E, k = A, w = typeof S.tokens < "u" ? er() : At(), f = u, E = y, A = k;
          }
          function it(u, y) {
            this.line = u, this.column = y;
          }
          function kt(u, y, k, T) {
            this.start = new it(u, y), this.end = new it(k, T);
          }
          v = {
            name: "SyntaxTree",
            processComment: function(u) {
              var y, k;
              if (!(u.type === c.Program && u.body.length > 0)) {
                for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= u.range[1] ? (k = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= u.range[1] && (k = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= u.range[0]; )
                  y = S.bottomRightStack.pop();
                y ? y.leadingComments && y.leadingComments[y.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = y.leadingComments, delete y.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = S.leadingComments, S.leadingComments = []), k && (u.trailingComments = k), S.bottomRightStack.push(u);
              }
            },
            markEnd: function(u, y) {
              return S.range && (u.range = [y.start, f]), S.loc && (u.loc = new kt(
                y.startLineNumber === void 0 ? y.lineNumber : y.startLineNumber,
                y.start - (y.startLineStart === void 0 ? y.lineStart : y.startLineStart),
                E,
                f - A
              ), this.postProcess(u)), S.attachComment && this.processComment(u), u;
            },
            postProcess: function(u) {
              return S.source && (u.loc.source = S.source), u;
            },
            createArrayExpression: function(u) {
              return {
                type: c.ArrayExpression,
                elements: u
              };
            },
            createAssignmentExpression: function(u, y, k) {
              return {
                type: c.AssignmentExpression,
                operator: u,
                left: y,
                right: k
              };
            },
            createBinaryExpression: function(u, y, k) {
              var T = u === "||" || u === "&&" ? c.LogicalExpression : c.BinaryExpression;
              return {
                type: T,
                operator: u,
                left: y,
                right: k
              };
            },
            createBlockStatement: function(u) {
              return {
                type: c.BlockStatement,
                body: u
              };
            },
            createBreakStatement: function(u) {
              return {
                type: c.BreakStatement,
                label: u
              };
            },
            createCallExpression: function(u, y) {
              return {
                type: c.CallExpression,
                callee: u,
                arguments: y
              };
            },
            createCatchClause: function(u, y) {
              return {
                type: c.CatchClause,
                param: u,
                body: y
              };
            },
            createConditionalExpression: function(u, y, k) {
              return {
                type: c.ConditionalExpression,
                test: u,
                consequent: y,
                alternate: k
              };
            },
            createContinueStatement: function(u) {
              return {
                type: c.ContinueStatement,
                label: u
              };
            },
            createDebuggerStatement: function() {
              return {
                type: c.DebuggerStatement
              };
            },
            createDoWhileStatement: function(u, y) {
              return {
                type: c.DoWhileStatement,
                body: u,
                test: y
              };
            },
            createEmptyStatement: function() {
              return {
                type: c.EmptyStatement
              };
            },
            createExpressionStatement: function(u) {
              return {
                type: c.ExpressionStatement,
                expression: u
              };
            },
            createForStatement: function(u, y, k, T) {
              return {
                type: c.ForStatement,
                init: u,
                test: y,
                update: k,
                body: T
              };
            },
            createForInStatement: function(u, y, k) {
              return {
                type: c.ForInStatement,
                left: u,
                right: y,
                body: k,
                each: !1
              };
            },
            createFunctionDeclaration: function(u, y, k, T) {
              return {
                type: c.FunctionDeclaration,
                id: u,
                params: y,
                defaults: k,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createFunctionExpression: function(u, y, k, T) {
              return {
                type: c.FunctionExpression,
                id: u,
                params: y,
                defaults: k,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createIdentifier: function(u) {
              return {
                type: c.Identifier,
                name: u
              };
            },
            createIfStatement: function(u, y, k) {
              return {
                type: c.IfStatement,
                test: u,
                consequent: y,
                alternate: k
              };
            },
            createLabeledStatement: function(u, y) {
              return {
                type: c.LabeledStatement,
                label: u,
                body: y
              };
            },
            createLiteral: function(u) {
              return {
                type: c.Literal,
                value: u.value,
                raw: m.slice(u.start, u.end)
              };
            },
            createMemberExpression: function(u, y, k) {
              return {
                type: c.MemberExpression,
                computed: u === "[",
                object: y,
                property: k
              };
            },
            createNewExpression: function(u, y) {
              return {
                type: c.NewExpression,
                callee: u,
                arguments: y
              };
            },
            createObjectExpression: function(u) {
              return {
                type: c.ObjectExpression,
                properties: u
              };
            },
            createPostfixExpression: function(u, y) {
              return {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !1
              };
            },
            createProgram: function(u) {
              return {
                type: c.Program,
                body: u
              };
            },
            createProperty: function(u, y, k) {
              return {
                type: c.Property,
                key: y,
                value: k,
                kind: u
              };
            },
            createReturnStatement: function(u) {
              return {
                type: c.ReturnStatement,
                argument: u
              };
            },
            createSequenceExpression: function(u) {
              return {
                type: c.SequenceExpression,
                expressions: u
              };
            },
            createSwitchCase: function(u, y) {
              return {
                type: c.SwitchCase,
                test: u,
                consequent: y
              };
            },
            createSwitchStatement: function(u, y) {
              return {
                type: c.SwitchStatement,
                discriminant: u,
                cases: y
              };
            },
            createThisExpression: function() {
              return {
                type: c.ThisExpression
              };
            },
            createThrowStatement: function(u) {
              return {
                type: c.ThrowStatement,
                argument: u
              };
            },
            createTryStatement: function(u, y, k, T) {
              return {
                type: c.TryStatement,
                block: u,
                guardedHandlers: y,
                handlers: k,
                finalizer: T
              };
            },
            createUnaryExpression: function(u, y) {
              return u === "++" || u === "--" ? {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !0
              } : {
                type: c.UnaryExpression,
                operator: u,
                argument: y,
                prefix: !0
              };
            },
            createVariableDeclaration: function(u, y) {
              return {
                type: c.VariableDeclaration,
                declarations: u,
                kind: y
              };
            },
            createVariableDeclarator: function(u, y) {
              return {
                type: c.VariableDeclarator,
                id: u,
                init: y
              };
            },
            createWhileStatement: function(u, y) {
              return {
                type: c.WhileStatement,
                test: u,
                body: y
              };
            },
            createWithStatement: function(u, y) {
              return {
                type: c.WithStatement,
                object: u,
                body: y
              };
            }
          };
          function Ze() {
            var u, y, k, T;
            return u = f, y = E, k = A, O(), T = E !== y, f = u, E = y, A = k, T;
          }
          function fe(u, y) {
            var k, T = Array.prototype.slice.call(arguments, 2), V = y.replace(
              /%(\d)/g,
              function(ne, Ce) {
                return R(Ce < T.length, "Message reference must be in range"), T[Ce];
              }
            );
            throw typeof u.lineNumber == "number" ? (k = new Error("Line " + u.lineNumber + ": " + V), k.index = u.start, k.lineNumber = u.lineNumber, k.column = u.start - A + 1) : (k = new Error("Line " + E + ": " + V), k.index = f, k.lineNumber = E, k.column = f - A + 1), k.description = V, k;
          }
          function ye() {
            try {
              fe.apply(null, arguments);
            } catch (u) {
              if (S.errors)
                S.errors.push(u);
              else
                throw u;
            }
          }
          function Je(u) {
            if (u.type === o.EOF && fe(u, h.UnexpectedEOS), u.type === o.NumericLiteral && fe(u, h.UnexpectedNumber), u.type === o.StringLiteral && fe(u, h.UnexpectedString), u.type === o.Identifier && fe(u, h.UnexpectedIdentifier), u.type === o.Keyword) {
              if (ce(u.value))
                fe(u, h.UnexpectedReserved);
              else if (b && Ee(u.value)) {
                ye(u, h.StrictReservedWord);
                return;
              }
              fe(u, h.UnexpectedToken, u.value);
            }
            fe(u, h.UnexpectedToken, u.value);
          }
          function C(u) {
            var y = ge();
            (y.type !== o.Punctuator || y.value !== u) && Je(y);
          }
          function $(u) {
            var y = ge();
            (y.type !== o.Keyword || y.value !== u) && Je(y);
          }
          function D(u) {
            return w.type === o.Punctuator && w.value === u;
          }
          function se(u) {
            return w.type === o.Keyword && w.value === u;
          }
          function pe() {
            var u;
            return w.type !== o.Punctuator ? !1 : (u = w.value, u === "=" || u === "*=" || u === "/=" || u === "%=" || u === "+=" || u === "-=" || u === "<<=" || u === ">>=" || u === ">>>=" || u === "&=" || u === "^=" || u === "|=");
          }
          function Se() {
            var u;
            if (m.charCodeAt(f) === 59 || D(";")) {
              ge();
              return;
            }
            u = E, O(), E === u && w.type !== o.EOF && !D("}") && Je(w);
          }
          function Le(u) {
            return u.type === c.Identifier || u.type === c.MemberExpression;
          }
          function ot() {
            var u = [], y;
            for (y = w, C("["); !D("]"); )
              D(",") ? (ge(), u.push(null)) : (u.push(q()), D("]") || C(","));
            return ge(), g.markEnd(g.createArrayExpression(u), y);
          }
          function dt(u, y) {
            var k, T, V;
            return k = b, V = w, T = Vn(), y && b && xe(u[0].name) && ye(y, h.StrictParamName), b = k, g.markEnd(g.createFunctionExpression(null, u, [], T), V);
          }
          function St() {
            var u, y;
            return y = w, u = ge(), u.type === o.StringLiteral || u.type === o.NumericLiteral ? (b && u.octal && ye(u, h.StrictOctalLiteral), g.markEnd(g.createLiteral(u), y)) : g.markEnd(g.createIdentifier(u.value), y);
          }
          function rt() {
            var u, y, k, T, V, ne;
            if (u = w, ne = w, u.type === o.Identifier)
              return k = St(), u.value === "get" && !D(":") ? (y = St(), C("("), C(")"), T = dt([]), g.markEnd(g.createProperty("get", y, T), ne)) : u.value === "set" && !D(":") ? (y = St(), C("("), u = w, u.type !== o.Identifier ? (C(")"), ye(u, h.UnexpectedToken, u.value), T = dt([])) : (V = [he()], C(")"), T = dt(V, u)), g.markEnd(g.createProperty("set", y, T), ne)) : (C(":"), T = q(), g.markEnd(g.createProperty("init", k, T), ne));
            if (u.type === o.EOF || u.type === o.Punctuator)
              Je(u);
            else
              return y = St(), C(":"), T = q(), g.markEnd(g.createProperty("init", y, T), ne);
          }
          function zt() {
            var u = [], y, k, T, V, ne = {}, Ce = String, Me;
            for (Me = w, C("{"); !D("}"); )
              y = rt(), y.key.type === c.Identifier ? k = y.key.name : k = Ce(y.key.value), V = y.kind === "init" ? p.Data : y.kind === "get" ? p.Get : p.Set, T = "$" + k, Object.prototype.hasOwnProperty.call(ne, T) ? (ne[T] === p.Data ? b && V === p.Data ? ye({}, h.StrictDuplicateProperty) : V !== p.Data && ye({}, h.AccessorDataProperty) : V === p.Data ? ye({}, h.AccessorDataProperty) : ne[T] & V && ye({}, h.AccessorGetSet), ne[T] |= V) : ne[T] = V, u.push(y), D("}") || C(",");
            return C("}"), g.markEnd(g.createObjectExpression(u), Me);
          }
          function Xt() {
            var u;
            return C("("), u = G(), C(")"), u;
          }
          function tr() {
            var u, y, k, T;
            if (D("("))
              return Xt();
            if (D("["))
              return ot();
            if (D("{"))
              return zt();
            if (u = w.type, T = w, u === o.Identifier)
              k = g.createIdentifier(ge().value);
            else if (u === o.StringLiteral || u === o.NumericLiteral)
              b && w.octal && ye(w, h.StrictOctalLiteral), k = g.createLiteral(ge());
            else if (u === o.Keyword) {
              if (se("function"))
                return uu();
              se("this") ? (ge(), k = g.createThisExpression()) : Je(ge());
            } else u === o.BooleanLiteral ? (y = ge(), y.value = y.value === "true", k = g.createLiteral(y)) : u === o.NullLiteral ? (y = ge(), y.value = null, k = g.createLiteral(y)) : D("/") || D("/=") ? (typeof S.tokens < "u" ? k = g.createLiteral(qe()) : k = g.createLiteral(Te()), ht()) : Je(ge());
            return g.markEnd(k, T);
          }
          function Nr() {
            var u = [];
            if (C("("), !D(")"))
              for (; f < x && (u.push(q()), !D(")")); )
                C(",");
            return C(")"), u;
          }
          function Ai() {
            var u, y;
            return y = w, u = ge(), tt(u) || Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function Zt() {
            return C("."), Ai();
          }
          function Un() {
            var u;
            return C("["), u = G(), C("]"), u;
          }
          function M() {
            var u, y, k;
            return k = w, $("new"), u = K(), y = D("(") ? Nr() : [], g.markEnd(g.createNewExpression(u, y), k);
          }
          function U() {
            var u, y, k, T, V;
            for (V = w, u = _.allowIn, _.allowIn = !0, y = se("new") ? M() : tr(), _.allowIn = u; ; ) {
              if (D("."))
                T = Zt(), y = g.createMemberExpression(".", y, T);
              else if (D("("))
                k = Nr(), y = g.createCallExpression(y, k);
              else if (D("["))
                T = Un(), y = g.createMemberExpression("[", y, T);
              else
                break;
              g.markEnd(y, V);
            }
            return y;
          }
          function K() {
            var u, y, k, T;
            for (T = w, u = _.allowIn, y = se("new") ? M() : tr(), _.allowIn = u; D(".") || D("["); )
              D("[") ? (k = Un(), y = g.createMemberExpression("[", y, k)) : (k = Zt(), y = g.createMemberExpression(".", y, k)), g.markEnd(y, T);
            return y;
          }
          function de() {
            var u, y, k = w;
            return u = U(), w.type === o.Punctuator && (D("++") || D("--")) && !Ze() && (b && u.type === c.Identifier && xe(u.name) && ye({}, h.StrictLHSPostfix), Le(u) || ye({}, h.InvalidLHSInAssignment), y = ge(), u = g.markEnd(g.createPostfixExpression(y.value, u), k)), u;
          }
          function ve() {
            var u, y, k;
            return w.type !== o.Punctuator && w.type !== o.Keyword ? y = de() : D("++") || D("--") ? (k = w, u = ge(), y = ve(), b && y.type === c.Identifier && xe(y.name) && ye({}, h.StrictLHSPrefix), Le(y) || ye({}, h.InvalidLHSInAssignment), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k)) : D("+") || D("-") || D("~") || D("!") ? (k = w, u = ge(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k)) : se("delete") || se("void") || se("typeof") ? (k = w, u = ge(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k), b && y.operator === "delete" && y.argument.type === c.Identifier && ye({}, h.StrictDelete)) : y = de(), y;
          }
          function Z(u, y) {
            var k = 0;
            if (u.type !== o.Punctuator && u.type !== o.Keyword)
              return 0;
            switch (u.value) {
              case "||":
                k = 1;
                break;
              case "&&":
                k = 2;
                break;
              case "|":
                k = 3;
                break;
              case "^":
                k = 4;
                break;
              case "&":
                k = 5;
                break;
              case "==":
              case "!=":
              case "===":
              case "!==":
                k = 6;
                break;
              case "<":
              case ">":
              case "<=":
              case ">=":
              case "instanceof":
                k = 7;
                break;
              case "in":
                k = y ? 7 : 0;
                break;
              case "<<":
              case ">>":
              case ">>>":
                k = 8;
                break;
              case "+":
              case "-":
                k = 9;
                break;
              case "*":
              case "/":
              case "%":
                k = 11;
                break;
            }
            return k;
          }
          function I() {
            var u, y, k, T, V, ne, Ce, Me, et, Xe;
            if (u = w, et = ve(), T = w, V = Z(T, _.allowIn), V === 0)
              return et;
            for (T.prec = V, ge(), y = [u, w], Ce = ve(), ne = [et, T, Ce]; (V = Z(w, _.allowIn)) > 0; ) {
              for (; ne.length > 2 && V <= ne[ne.length - 2].prec; )
                Ce = ne.pop(), Me = ne.pop().value, et = ne.pop(), k = g.createBinaryExpression(Me, et, Ce), y.pop(), u = y[y.length - 1], g.markEnd(k, u), ne.push(k);
              T = ge(), T.prec = V, ne.push(T), y.push(w), k = ve(), ne.push(k);
            }
            for (Xe = ne.length - 1, k = ne[Xe], y.pop(); Xe > 1; )
              k = g.createBinaryExpression(ne[Xe - 1].value, ne[Xe - 2], k), Xe -= 2, u = y.pop(), g.markEnd(k, u);
            return k;
          }
          function B() {
            var u, y, k, T, V;
            return V = w, u = I(), D("?") && (ge(), y = _.allowIn, _.allowIn = !0, k = q(), _.allowIn = y, C(":"), T = q(), u = g.createConditionalExpression(u, k, T), g.markEnd(u, V)), u;
          }
          function q() {
            var u, y, k, T, V;
            return u = w, V = w, T = y = B(), pe() && (Le(y) || ye({}, h.InvalidLHSInAssignment), b && y.type === c.Identifier && xe(y.name) && ye(u, h.StrictLHSAssignment), u = ge(), k = q(), T = g.markEnd(g.createAssignmentExpression(u.value, y, k), V)), T;
          }
          function G() {
            var u, y = w;
            if (u = q(), D(",")) {
              for (u = g.createSequenceExpression([u]); f < x && D(","); )
                ge(), u.expressions.push(q());
              g.markEnd(u, y);
            }
            return u;
          }
          function Y() {
            for (var u = [], y; f < x && !(D("}") || (y = Ir(), typeof y > "u")); )
              u.push(y);
            return u;
          }
          function ie() {
            var u, y;
            return y = w, C("{"), u = Y(), C("}"), g.markEnd(g.createBlockStatement(u), y);
          }
          function he() {
            var u, y;
            return y = w, u = ge(), u.type !== o.Identifier && Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function be(u) {
            var y = null, k, T;
            return T = w, k = he(), b && xe(k.name) && ye({}, h.StrictVarName), u === "const" ? (C("="), y = q()) : D("=") && (ge(), y = q()), g.markEnd(g.createVariableDeclarator(k, y), T);
          }
          function ke(u) {
            var y = [];
            do {
              if (y.push(be(u)), !D(","))
                break;
              ge();
            } while (f < x);
            return y;
          }
          function De() {
            var u;
            return $("var"), u = ke(), Se(), g.createVariableDeclaration(u, "var");
          }
          function $e(u) {
            var y, k;
            return k = w, $(u), y = ke(u), Se(), g.markEnd(g.createVariableDeclaration(y, u), k);
          }
          function Qe() {
            return C(";"), g.createEmptyStatement();
          }
          function ut() {
            var u = G();
            return Se(), g.createExpressionStatement(u);
          }
          function st() {
            var u, y, k;
            return $("if"), C("("), u = G(), C(")"), y = Ot(), se("else") ? (ge(), k = Ot()) : k = null, g.createIfStatement(u, y, k);
          }
          function Rt() {
            var u, y, k;
            return $("do"), k = _.inIteration, _.inIteration = !0, u = Ot(), _.inIteration = k, $("while"), C("("), y = G(), C(")"), D(";") && ge(), g.createDoWhileStatement(u, y);
          }
          function $t() {
            var u, y, k;
            return $("while"), C("("), u = G(), C(")"), k = _.inIteration, _.inIteration = !0, y = Ot(), _.inIteration = k, g.createWhileStatement(u, y);
          }
          function Or() {
            var u, y, k;
            return k = w, u = ge(), y = ke(), g.markEnd(g.createVariableDeclaration(y, u.value), k);
          }
          function an() {
            var u, y, k, T, V, ne, Ce;
            return u = y = k = null, $("for"), C("("), D(";") ? ge() : (se("var") || se("let") ? (_.allowIn = !1, u = Or(), _.allowIn = !0, u.declarations.length === 1 && se("in") && (ge(), T = u, V = G(), u = null)) : (_.allowIn = !1, u = G(), _.allowIn = !0, se("in") && (Le(u) || ye({}, h.InvalidLHSInForIn), ge(), T = u, V = G(), u = null)), typeof T > "u" && C(";")), typeof T > "u" && (D(";") || (y = G()), C(";"), D(")") || (k = G())), C(")"), Ce = _.inIteration, _.inIteration = !0, ne = Ot(), _.inIteration = Ce, typeof T > "u" ? g.createForStatement(u, y, k, ne) : g.createForInStatement(T, V, ne);
          }
          function wo() {
            var u = null, y;
            return $("continue"), m.charCodeAt(f) === 59 ? (ge(), _.inIteration || fe({}, h.IllegalContinue), g.createContinueStatement(null)) : Ze() ? (_.inIteration || fe({}, h.IllegalContinue), g.createContinueStatement(null)) : (w.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(_.labelSet, y) || fe({}, h.UnknownLabel, u.name)), Se(), u === null && !_.inIteration && fe({}, h.IllegalContinue), g.createContinueStatement(u));
          }
          function xo() {
            var u = null, y;
            return $("break"), m.charCodeAt(f) === 59 ? (ge(), _.inIteration || _.inSwitch || fe({}, h.IllegalBreak), g.createBreakStatement(null)) : Ze() ? (_.inIteration || _.inSwitch || fe({}, h.IllegalBreak), g.createBreakStatement(null)) : (w.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(_.labelSet, y) || fe({}, h.UnknownLabel, u.name)), Se(), u === null && !(_.inIteration || _.inSwitch) && fe({}, h.IllegalBreak), g.createBreakStatement(u));
          }
          function ru() {
            var u = null;
            return $("return"), _.inFunctionBody || ye({}, h.IllegalReturn), m.charCodeAt(f) === 32 && te(m.charCodeAt(f + 1)) ? (u = G(), Se(), g.createReturnStatement(u)) : Ze() ? g.createReturnStatement(null) : (D(";") || !D("}") && w.type !== o.EOF && (u = G()), Se(), g.createReturnStatement(u));
          }
          function nu() {
            var u, y;
            return b && (O(), ye({}, h.StrictModeWith)), $("with"), C("("), u = G(), C(")"), y = Ot(), g.createWithStatement(u, y);
          }
          function iu() {
            var u, y = [], k, T;
            for (T = w, se("default") ? (ge(), u = null) : ($("case"), u = G()), C(":"); f < x && !(D("}") || se("default") || se("case")); )
              k = Ot(), y.push(k);
            return g.markEnd(g.createSwitchCase(u, y), T);
          }
          function su() {
            var u, y, k, T, V;
            if ($("switch"), C("("), u = G(), C(")"), C("{"), y = [], D("}"))
              return ge(), g.createSwitchStatement(u, y);
            for (T = _.inSwitch, _.inSwitch = !0, V = !1; f < x && !D("}"); )
              k = iu(), k.test === null && (V && fe({}, h.MultipleDefaultsInSwitch), V = !0), y.push(k);
            return _.inSwitch = T, C("}"), g.createSwitchStatement(u, y);
          }
          function ou() {
            var u;
            return $("throw"), Ze() && fe({}, h.NewlineAfterThrow), u = G(), Se(), g.createThrowStatement(u);
          }
          function au() {
            var u, y, k;
            return k = w, $("catch"), C("("), D(")") && Je(w), u = he(), b && xe(u.name) && ye({}, h.StrictCatchVariable), C(")"), y = ie(), g.markEnd(g.createCatchClause(u, y), k);
          }
          function lu() {
            var u, y = [], k = null;
            return $("try"), u = ie(), se("catch") && y.push(au()), se("finally") && (ge(), k = ie()), y.length === 0 && !k && fe({}, h.NoCatchOrFinally), g.createTryStatement(u, [], y, k);
          }
          function cu() {
            return $("debugger"), Se(), g.createDebuggerStatement();
          }
          function Ot() {
            var u = w.type, y, k, T, V;
            if (u === o.EOF && Je(w), u === o.Punctuator && w.value === "{")
              return ie();
            if (V = w, u === o.Punctuator)
              switch (w.value) {
                case ";":
                  return g.markEnd(Qe(), V);
                case "(":
                  return g.markEnd(ut(), V);
              }
            if (u === o.Keyword)
              switch (w.value) {
                case "break":
                  return g.markEnd(xo(), V);
                case "continue":
                  return g.markEnd(wo(), V);
                case "debugger":
                  return g.markEnd(cu(), V);
                case "do":
                  return g.markEnd(Rt(), V);
                case "for":
                  return g.markEnd(an(), V);
                case "function":
                  return g.markEnd(Ps(), V);
                case "if":
                  return g.markEnd(st(), V);
                case "return":
                  return g.markEnd(ru(), V);
                case "switch":
                  return g.markEnd(su(), V);
                case "throw":
                  return g.markEnd(ou(), V);
                case "try":
                  return g.markEnd(lu(), V);
                case "var":
                  return g.markEnd(De(), V);
                case "while":
                  return g.markEnd($t(), V);
                case "with":
                  return g.markEnd(nu(), V);
              }
            return y = G(), y.type === c.Identifier && D(":") ? (ge(), T = "$" + y.name, Object.prototype.hasOwnProperty.call(_.labelSet, T) && fe({}, h.Redeclaration, "Label", y.name), _.labelSet[T] = !0, k = Ot(), delete _.labelSet[T], g.markEnd(g.createLabeledStatement(y, k), V)) : (Se(), g.markEnd(g.createExpressionStatement(y), V));
          }
          function Vn() {
            var u, y = [], k, T, V, ne, Ce, Me, et, Xe;
            for (Xe = w, C("{"); f < x && !(w.type !== o.StringLiteral || (k = w, u = Ir(), y.push(u), u.expression.type !== c.Literal)); )
              T = m.slice(k.start + 1, k.end - 1), T === "use strict" ? (b = !0, V && ye(V, h.StrictOctalLiteral)) : !V && k.octal && (V = k);
            for (ne = _.labelSet, Ce = _.inIteration, Me = _.inSwitch, et = _.inFunctionBody, _.labelSet = {}, _.inIteration = !1, _.inSwitch = !1, _.inFunctionBody = !0; f < x && !(D("}") || (u = Ir(), typeof u > "u")); )
              y.push(u);
            return C("}"), _.labelSet = ne, _.inIteration = Ce, _.inSwitch = Me, _.inFunctionBody = et, g.markEnd(g.createBlockStatement(y), Xe);
          }
          function Is(u) {
            var y, k = [], T, V, ne, Ce, Me;
            if (C("("), !D(")"))
              for (ne = {}; f < x && (T = w, y = he(), Ce = "$" + T.value, b ? (xe(T.value) && (V = T, Me = h.StrictParamName), Object.prototype.hasOwnProperty.call(ne, Ce) && (V = T, Me = h.StrictParamDupe)) : u || (xe(T.value) ? (u = T, Me = h.StrictParamName) : Ee(T.value) ? (u = T, Me = h.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ne, Ce) && (u = T, Me = h.StrictParamDupe)), k.push(y), ne[Ce] = !0, !D(")")); )
                C(",");
            return C(")"), {
              params: k,
              stricted: V,
              firstRestricted: u,
              message: Me
            };
          }
          function Ps() {
            var u, y = [], k, T, V, ne, Ce, Me, et, Xe;
            return Xe = w, $("function"), T = w, u = he(), b ? xe(T.value) && ye(T, h.StrictFunctionName) : xe(T.value) ? (Ce = T, Me = h.StrictFunctionName) : Ee(T.value) && (Ce = T, Me = h.StrictReservedWord), ne = Is(Ce), y = ne.params, V = ne.stricted, Ce = ne.firstRestricted, ne.message && (Me = ne.message), et = b, k = Vn(), b && Ce && fe(Ce, Me), b && V && ye(V, Me), b = et, g.markEnd(g.createFunctionDeclaration(u, y, [], k), Xe);
          }
          function uu() {
            var u, y = null, k, T, V, ne, Ce = [], Me, et, Xe;
            return Xe = w, $("function"), D("(") || (u = w, y = he(), b ? xe(u.value) && ye(u, h.StrictFunctionName) : xe(u.value) ? (T = u, V = h.StrictFunctionName) : Ee(u.value) && (T = u, V = h.StrictReservedWord)), ne = Is(T), Ce = ne.params, k = ne.stricted, T = ne.firstRestricted, ne.message && (V = ne.message), et = b, Me = Vn(), b && T && fe(T, V), b && k && ye(k, V), b = et, g.markEnd(g.createFunctionExpression(y, Ce, [], Me), Xe);
          }
          function Ir() {
            if (w.type === o.Keyword)
              switch (w.value) {
                case "const":
                case "let":
                  return $e(w.value);
                case "function":
                  return Ps();
                default:
                  return Ot();
              }
            if (w.type !== o.EOF)
              return Ot();
          }
          function hu() {
            for (var u, y = [], k, T, V; f < x && (k = w, !(k.type !== o.StringLiteral || (u = Ir(), y.push(u), u.expression.type !== c.Literal))); )
              T = m.slice(k.start + 1, k.end - 1), T === "use strict" ? (b = !0, V && ye(V, h.StrictOctalLiteral)) : !V && k.octal && (V = k);
            for (; f < x && (u = Ir(), !(typeof u > "u")); )
              y.push(u);
            return y;
          }
          function pu() {
            var u, y;
            return O(), ht(), y = w, b = !1, u = hu(), g.markEnd(g.createProgram(u), y);
          }
          function Rs() {
            var u, y, k, T = [];
            for (u = 0; u < S.tokens.length; ++u)
              y = S.tokens[u], k = {
                type: y.type,
                value: y.value
              }, S.range && (k.range = y.range), S.loc && (k.loc = y.loc), T.push(k);
            S.tokens = T;
          }
          function du(u, y) {
            var k, T, V;
            k = String, typeof u != "string" && !(u instanceof String) && (u = k(u)), g = v, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, y = y || {}, y.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []);
            try {
              if (ht(), w.type === o.EOF)
                return S.tokens;
              for (T = ge(); w.type !== o.EOF; )
                try {
                  T = ge();
                } catch (ne) {
                  if (T = w, S.errors) {
                    S.errors.push(ne);
                    break;
                  } else
                    throw ne;
                }
              Rs(), V = S.tokens, typeof S.comments < "u" && (V.comments = S.comments), typeof S.errors < "u" && (V.errors = S.errors);
            } catch (ne) {
              throw ne;
            } finally {
              S = {};
            }
            return V;
          }
          function fu(u, y) {
            var k, T;
            T = String, typeof u != "string" && !(u instanceof String) && (u = T(u)), g = v, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, typeof y < "u" && (S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, S.attachComment = typeof y.attachComment == "boolean" && y.attachComment, S.loc && y.source !== null && y.source !== void 0 && (S.source = T(y.source)), typeof y.tokens == "boolean" && y.tokens && (S.tokens = []), typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
            try {
              k = pu(), typeof S.comments < "u" && (k.comments = S.comments), typeof S.tokens < "u" && (Rs(), k.tokens = S.tokens), typeof S.errors < "u" && (k.errors = S.errors);
            } catch (V) {
              throw V;
            } finally {
              S = {};
            }
            return k;
          }
          s.version = "1.2.2", s.tokenize = du, s.parse = fu, s.Syntax = function() {
            var u, y = {};
            typeof Object.create == "function" && (y = /* @__PURE__ */ Object.create(null));
            for (u in c)
              c.hasOwnProperty(u) && (y[u] = c[u]);
            return typeof Object.freeze == "function" && Object.freeze(y), y;
          }();
        });
      }, {}], 1: [function(r, n, i) {
        (function(s) {
          var o = function() {
            var a = {
              trace: function() {
              },
              yy: {},
              symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
              terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
              productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
              performAction: function(h, d, v, m, b, f, E) {
                m.ast || (m.ast = l, l.initialize());
                var A = f.length - 1;
                switch (b) {
                  case 1:
                    return m.ast.set({ expression: { type: "root", value: f[A] } }), m.ast.unshift(), m.ast.yield();
                  case 2:
                    return m.ast.set({ expression: { type: "root", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 3:
                    return m.ast.unshift(), m.ast.yield();
                  case 4:
                    return m.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 5:
                    break;
                  case 6:
                    break;
                  case 7:
                    m.ast.set({ operation: "member" }), m.ast.push();
                    break;
                  case 8:
                    m.ast.set({ operation: "subscript" }), m.ast.push();
                    break;
                  case 9:
                    m.ast.set({ scope: "child" });
                    break;
                  case 10:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 11:
                    break;
                  case 12:
                    m.ast.set({ scope: "child", operation: "member" });
                    break;
                  case 13:
                    break;
                  case 14:
                    m.ast.set({ expression: { type: "wildcard", value: f[A] } });
                    break;
                  case 15:
                    m.ast.set({ expression: { type: "identifier", value: f[A] } });
                    break;
                  case 16:
                    m.ast.set({ expression: { type: "script_expression", value: f[A] } });
                    break;
                  case 17:
                    m.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                    break;
                  case 18:
                    break;
                  case 19:
                    m.ast.set({ scope: "child" });
                    break;
                  case 20:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 21:
                    break;
                  case 22:
                    break;
                  case 23:
                    break;
                  case 24:
                    f[A].length > 1 ? m.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                    break;
                  case 25:
                    this.$ = [f[A]];
                    break;
                  case 26:
                    this.$ = f[A - 2].concat(f[A]);
                    break;
                  case 27:
                    this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, m.ast.set(this.$);
                    break;
                  case 28:
                    this.$ = { expression: { type: "string_literal", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 29:
                    this.$ = { expression: { type: "slice", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 30:
                    this.$ = { expression: { type: "wildcard", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 31:
                    this.$ = { expression: { type: "script_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 32:
                    this.$ = { expression: { type: "filter_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 33:
                    this.$ = f[A];
                    break;
                  case 34:
                    this.$ = f[A];
                    break;
                }
              },
              table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
              defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
              parseError: function(h, d) {
                if (d.recoverable)
                  this.trace(h);
                else
                  throw new Error(h);
              },
              parse: function(h) {
                var d = this, v = [0], m = [null], b = [], f = this.table, E = "", A = 0, x = 0, g = 2, w = 1, _ = b.slice.call(arguments, 1);
                this.lexer.setInput(h), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
                var S = this.lexer.yylloc;
                b.push(S);
                var R = this.lexer.options && this.lexer.options.ranges;
                typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
                function L() {
                  var Ie;
                  return Ie = d.lexer.lex() || w, typeof Ie != "number" && (Ie = d.symbols_[Ie] || Ie), Ie;
                }
                for (var F, z, j, W, te = {}, le, ce, Ee, xe; ; ) {
                  if (z = v[v.length - 1], this.defaultActions[z] ? j = this.defaultActions[z] : ((F === null || typeof F > "u") && (F = L()), j = f[z] && f[z][F]), typeof j > "u" || !j.length || !j[0]) {
                    var _e = "";
                    xe = [];
                    for (le in f[z])
                      this.terminals_[le] && le > g && xe.push("'" + this.terminals_[le] + "'");
                    this.lexer.showPosition ? _e = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + xe.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : _e = "Parse error on line " + (A + 1) + ": Unexpected " + (F == w ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(_e, {
                      text: this.lexer.match,
                      token: this.terminals_[F] || F,
                      line: this.lexer.yylineno,
                      loc: S,
                      expected: xe
                    });
                  }
                  if (j[0] instanceof Array && j.length > 1)
                    throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + F);
                  switch (j[0]) {
                    case 1:
                      v.push(F), m.push(this.lexer.yytext), b.push(this.lexer.yylloc), v.push(j[1]), F = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                      break;
                    case 2:
                      if (ce = this.productions_[j[1]][1], te.$ = m[m.length - ce], te._$ = {
                        first_line: b[b.length - (ce || 1)].first_line,
                        last_line: b[b.length - 1].last_line,
                        first_column: b[b.length - (ce || 1)].first_column,
                        last_column: b[b.length - 1].last_column
                      }, R && (te._$.range = [
                        b[b.length - (ce || 1)].range[0],
                        b[b.length - 1].range[1]
                      ]), W = this.performAction.apply(te, [
                        E,
                        x,
                        A,
                        this.yy,
                        j[1],
                        m,
                        b
                      ].concat(_)), typeof W < "u")
                        return W;
                      ce && (v = v.slice(0, -1 * ce * 2), m = m.slice(0, -1 * ce), b = b.slice(0, -1 * ce)), v.push(this.productions_[j[1]][0]), m.push(te.$), b.push(te._$), Ee = f[v[v.length - 2]][v[v.length - 1]], v.push(Ee);
                      break;
                    case 3:
                      return !0;
                  }
                }
                return !0;
              }
            }, l = {
              initialize: function() {
                this._nodes = [], this._node = {}, this._stash = [];
              },
              set: function(h) {
                for (var d in h) this._node[d] = h[d];
                return this._node;
              },
              node: function(h) {
                return arguments.length && (this._node = h), this._node;
              },
              push: function() {
                this._nodes.push(this._node), this._node = {};
              },
              unshift: function() {
                this._nodes.unshift(this._node), this._node = {};
              },
              yield: function() {
                var h = this._nodes;
                return this.initialize(), h;
              }
            }, c = /* @__PURE__ */ function() {
              var h = {
                EOF: 1,
                parseError: function(d, v) {
                  if (this.yy.parser)
                    this.yy.parser.parseError(d, v);
                  else
                    throw new Error(d);
                },
                // resets the lexer, sets new input
                setInput: function(d) {
                  return this._input = d, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                  }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
                },
                // consumes and returns one char from the input
                input: function() {
                  var d = this._input[0];
                  this.yytext += d, this.yyleng++, this.offset++, this.match += d, this.matched += d;
                  var v = d.match(/(?:\r\n?|\n).*/g);
                  return v ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), d;
                },
                // unshifts one char (or a string) into the input
                unput: function(d) {
                  var v = d.length, m = d.split(/(?:\r\n?|\n)/g);
                  this._input = d + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - v - 1), this.offset -= v;
                  var b = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
                  var f = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: m ? (m.length === b.length ? this.yylloc.first_column : 0) + b[b.length - m.length].length - m[0].length : this.yylloc.first_column - v
                  }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - v]), this.yyleng = this.yytext.length, this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function() {
                  return this._more = !0, this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function() {
                  if (this.options.backtrack_lexer)
                    this._backtrack = !0;
                  else
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                      text: "",
                      token: null,
                      line: this.yylineno
                    });
                  return this;
                },
                // retain first n characters of the match
                less: function(d) {
                  this.unput(this.match.slice(d));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function() {
                  var d = this.matched.substr(0, this.matched.length - this.match.length);
                  return (d.length > 20 ? "..." : "") + d.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function() {
                  var d = this.match;
                  return d.length < 20 && (d += this._input.substr(0, 20 - d.length)), (d.substr(0, 20) + (d.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function() {
                  var d = this.pastInput(), v = new Array(d.length + 1).join("-");
                  return d + this.upcomingInput() + `
` + v + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function(d, v) {
                  var m, b, f;
                  if (this.options.backtrack_lexer && (f = {
                    yylineno: this.yylineno,
                    yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                  }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), b = d[0].match(/(?:\r\n?|\n).*/g), b && (this.yylineno += b.length), this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: b ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + d[0].length
                  }, this.yytext += d[0], this.match += d[0], this.matches = d, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(d[0].length), this.matched += d[0], m = this.performAction.call(this, this.yy, this, v, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
                    return m;
                  if (this._backtrack) {
                    for (var E in f)
                      this[E] = f[E];
                    return !1;
                  }
                  return !1;
                },
                // return next match in input
                next: function() {
                  if (this.done)
                    return this.EOF;
                  this._input || (this.done = !0);
                  var d, v, m, b;
                  this._more || (this.yytext = "", this.match = "");
                  for (var f = this._currentRules(), E = 0; E < f.length; E++)
                    if (m = this._input.match(this.rules[f[E]]), m && (!v || m[0].length > v[0].length)) {
                      if (v = m, b = E, this.options.backtrack_lexer) {
                        if (d = this.test_match(m, f[E]), d !== !1)
                          return d;
                        if (this._backtrack) {
                          v = !1;
                          continue;
                        } else
                          return !1;
                      } else if (!this.options.flex)
                        break;
                    }
                  return v ? (d = this.test_match(v, f[b]), d !== !1 ? d : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                },
                // return next match that has a token
                lex: function() {
                  var d = this.next();
                  return d || this.lex();
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function(d) {
                  this.conditionStack.push(d);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function() {
                  var d = this.conditionStack.length - 1;
                  return d > 0 ? this.conditionStack.pop() : this.conditionStack[0];
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function() {
                  return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function(d) {
                  return d = this.conditionStack.length - 1 - Math.abs(d || 0), d >= 0 ? this.conditionStack[d] : "INITIAL";
                },
                // alias for begin(condition)
                pushState: function(d) {
                  this.begin(d);
                },
                // return the number of states currently on the stack
                stateStackSize: function() {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function(d, v, m, b) {
                  switch (m) {
                    case 0:
                      return 4;
                    case 1:
                      return 14;
                    case 2:
                      return 12;
                    case 3:
                      return 15;
                    case 4:
                      return 16;
                    case 5:
                      return 22;
                    case 6:
                      return 24;
                    case 7:
                      return 28;
                    case 8:
                      return 30;
                    case 9:
                      return 18;
                    case 10:
                      return v.yytext = v.yytext.substr(1, v.yyleng - 2), 32;
                    case 11:
                      return v.yytext = v.yytext.substr(1, v.yyleng - 2), 33;
                    case 12:
                      return 17;
                    case 13:
                      return 31;
                  }
                },
                rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
                conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
              };
              return h;
            }();
            a.lexer = c;
            function p() {
              this.yy = {};
            }
            return p.prototype = a, a.Parser = p, new p();
          }();
          typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
            return o.parse.apply(o, arguments);
          }, i.main = function(a) {
            a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
            var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
            return i.parser.parse(l);
          }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
        }).call(this, r("_process"));
      }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
        n.exports = {
          identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
          integer: "-?(?:0|[1-9][0-9]*)",
          qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
          q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
        };
      }, {}], 3: [function(r, n, i) {
        var s = r("./dict"), o = r("fs"), a = {
          lex: {
            macros: {
              esc: "\\\\",
              int: s.integer
            },
            rules: [
              ["\\$", "return 'DOLLAR'"],
              ["\\.\\.", "return 'DOT_DOT'"],
              ["\\.", "return 'DOT'"],
              ["\\*", "return 'STAR'"],
              [s.identifier, "return 'IDENTIFIER'"],
              ["\\[", "return '['"],
              ["\\]", "return ']'"],
              [",", "return ','"],
              ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
              ["{int}", "return 'INTEGER'"],
              [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
              [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
              ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
              ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
            ]
          },
          start: "JSON_PATH",
          bnf: {
            JSON_PATH: [
              ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
              ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
            ],
            PATH_COMPONENTS: [
              ["PATH_COMPONENT", ""],
              ["PATH_COMPONENTS PATH_COMPONENT", ""]
            ],
            PATH_COMPONENT: [
              ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
              ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
            ],
            MEMBER_COMPONENT: [
              ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_MEMBER_COMPONENT: [
              ["DOT MEMBER_EXPRESSION", ""]
            ],
            LEADING_CHILD_MEMBER_EXPRESSION: [
              ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
            ],
            DESCENDANT_MEMBER_COMPONENT: [
              ["DOT_DOT MEMBER_EXPRESSION", ""]
            ],
            MEMBER_EXPRESSION: [
              ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
              ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
              ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
              ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
              ["END", ""]
            ],
            SUBSCRIPT_COMPONENT: [
              ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_SUBSCRIPT_COMPONENT: [
              ["[ SUBSCRIPT ]", ""]
            ],
            DESCENDANT_SUBSCRIPT_COMPONENT: [
              ["DOT_DOT [ SUBSCRIPT ]", ""]
            ],
            SUBSCRIPT: [
              ["SUBSCRIPT_EXPRESSION", ""],
              ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
            ],
            SUBSCRIPT_EXPRESSION_LIST: [
              ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
              ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
            ],
            SUBSCRIPT_EXPRESSION_LISTABLE: [
              ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
              ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
              ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
            ],
            SUBSCRIPT_EXPRESSION: [
              ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
              ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
              ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
            ],
            STRING_LITERAL: [
              ["QQ_STRING", "$$ = $1"],
              ["Q_STRING", "$$ = $1"]
            ]
          }
        };
        o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
      }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
        var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
          return this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.traverse = v(!0), this.descend = v();
        }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
          var g = [x.operation, x.scope, x.expression.type].join("-"), w = this._fns[g];
          if (!w) throw new Error("couldn't resolve key: " + g);
          return w.bind(this);
        }, c.prototype.register = function(x, g) {
          if (!g instanceof Function)
            throw new Error("handler must be a function");
          this._fns[x] = g;
        }, c.prototype._fns = {
          "member-child-identifier": function(x, g) {
            var w = x.expression.value, _ = g.value;
            if (_ instanceof Object && w in _)
              return [{ value: _[w], path: g.path.concat(w) }];
          },
          "member-descendant-identifier": b(function(x, g, w) {
            return x == w;
          }),
          "subscript-child-numeric_literal": m(function(x, g, w) {
            return x === w;
          }),
          "member-child-numeric_literal": m(function(x, g, w) {
            return String(x) === String(w);
          }),
          "subscript-descendant-numeric_literal": b(function(x, g, w) {
            return x === w;
          }),
          "member-child-wildcard": m(function() {
            return !0;
          }),
          "member-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-child-wildcard": m(function() {
            return !0;
          }),
          "subscript-child-slice": function(x, g) {
            if (h(g.value)) {
              var w = x.expression.value.split(":").map(A), _ = g.value.map(function(S, R) {
                return { value: S, path: g.path.concat(R) };
              });
              return o.apply(null, [_].concat(w));
            }
          },
          "subscript-child-union": function(x, g) {
            var w = [];
            return x.expression.value.forEach(function(_) {
              var S = { operation: "subscript", scope: "child", expression: _.expression }, R = this.resolve(S), L = R(S, g);
              L && (w = w.concat(L));
            }, this), E(w);
          },
          "subscript-descendant-union": function(x, g, w) {
            var _ = r(".."), S = this, R = [], L = _.nodes(g, "$..*").slice(1);
            return L.forEach(function(F) {
              R.length >= w || x.expression.value.forEach(function(z) {
                var j = { operation: "subscript", scope: "child", expression: z.expression }, W = S.resolve(j), te = W(j, F);
                R = R.concat(te);
              });
            }), E(R);
          },
          "subscript-child-filter_expression": function(x, g, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.descend(g, null, R, w);
          },
          "subscript-descendant-filter_expression": function(x, g, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.traverse(g, null, R, w);
          },
          "subscript-child-script_expression": function(x, g) {
            var w = x.expression.value.slice(1, -1);
            return p(g, w, "$[{{value}}]");
          },
          "member-child-script_expression": function(x, g) {
            var w = x.expression.value.slice(1, -1);
            return p(g, w, "$.{{value}}");
          },
          "member-descendant-script_expression": function(x, g) {
            var w = x.expression.value.slice(1, -1);
            return p(g, w, "$..value");
          }
        }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
        function p(x, g, w) {
          var _ = r("./index"), S = s.parse(g).body[0].expression, R = f(S, { "@": x.value }), L = w.replace(/\{\{\s*value\s*\}\}/g, R), F = _.nodes(x.value, L);
          return F.forEach(function(z) {
            z.path = x.path.concat(z.path.slice(1));
          }), F;
        }
        function h(x) {
          return Array.isArray(x);
        }
        function d(x) {
          return x && !(x instanceof Array) && x instanceof Object;
        }
        function v(x) {
          return function(g, w, _, S) {
            var R = g.value, L = g.path, F = [], z = (function(j, W) {
              h(j) ? (j.forEach(function(te, le) {
                F.length >= S || _(le, te, w) && F.push({ path: W.concat(le), value: te });
              }), j.forEach(function(te, le) {
                F.length >= S || x && z(te, W.concat(le));
              })) : d(j) && (this.keys(j).forEach(function(te) {
                F.length >= S || _(te, j[te], w) && F.push({ path: W.concat(te), value: j[te] });
              }), this.keys(j).forEach(function(te) {
                F.length >= S || x && z(j[te], W.concat(te));
              }));
            }).bind(this);
            return z(R, L), F;
          };
        }
        function m(x) {
          return function(g, w, _) {
            return this.descend(w, g.expression.value, x, _);
          };
        }
        function b(x) {
          return function(g, w, _) {
            return this.traverse(w, g.expression.value, x, _);
          };
        }
        function f() {
          try {
            return a.apply(this, arguments);
          } catch {
          }
        }
        function E(x) {
          return x = x.filter(function(g) {
            return g;
          }), l(
            x,
            function(g) {
              return g.path.map(function(w) {
                return String(w).replace("-", "--");
              }).join("-");
            }
          );
        }
        function A(x) {
          var g = String(x);
          return g.match(/^-?[0-9]+$/) ? parseInt(g) : null;
        }
        n.exports = c;
      }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
        var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
          this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.parser = new a(), this.handlers = new l();
        }, c.prototype.parse = function(d) {
          return s.ok(p(d), "we need a path"), this.parser.parse(d);
        }, c.prototype.parent = function(d, v) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
          var m = this.nodes(d, v)[0];
          return m.path.pop(), this.value(d, m.path);
        }, c.prototype.apply = function(d, v, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), s.equal(typeof m, "function", "fn needs to be function");
          var b = this.nodes(d, v).sort(function(f, E) {
            return E.path.length - f.path.length;
          });
          return b.forEach(function(f) {
            var E = f.path.pop(), A = this.value(d, this.stringify(f.path)), x = f.value = m.call(d, A[E]);
            A[E] = x;
          }, this), b;
        }, c.prototype.value = function(d, v, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), arguments.length >= 3) {
            var b = this.nodes(d, v).shift();
            if (!b) return this._vivify(d, v, m);
            var f = b.path.slice(-1).shift(), E = this.parent(d, this.stringify(b.path));
            E[f] = m;
          }
          return this.query(d, this.stringify(v), 1).shift();
        }, c.prototype._vivify = function(d, v, m) {
          var b = this;
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
          var f = this.parser.parse(v).map(function(A) {
            return A.expression.value;
          }), E = function(A, x) {
            var g = A.pop(), w = b.value(d, A);
            w || (E(A.concat(), typeof g == "string" ? {} : []), w = b.value(d, A)), w[g] = x;
          };
          return E(f, m), this.query(d, v)[0];
        }, c.prototype.query = function(d, v, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(p(v), "we need a path");
          var b = this.nodes(d, v, m).map(function(f) {
            return f.value;
          });
          return b;
        }, c.prototype.paths = function(d, v, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
          var b = this.nodes(d, v, m).map(function(f) {
            return f.path;
          });
          return b;
        }, c.prototype.nodes = function(d, v, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), m === 0) return [];
          var b = this.parser.parse(v), f = this.handlers, E = [{ path: ["$"], value: d }], A = [];
          return b.length && b[0].expression.type == "root" && b.shift(), b.length ? (b.forEach(function(x, g) {
            if (!(A.length >= m)) {
              var w = f.resolve(x), _ = [];
              E.forEach(function(S) {
                if (!(A.length >= m)) {
                  var R = w(x, S, m);
                  g == b.length - 1 ? A = A.concat(R || []) : _ = _.concat(R || []);
                }
              }), E = _;
            }
          }), m ? A.slice(0, m) : A) : E;
        }, c.prototype.stringify = function(d) {
          s.ok(d, "we need a path");
          var v = "$", m = {
            "descendant-member": "..{{value}}",
            "child-member": ".{{value}}",
            "descendant-subscript": "..[{{value}}]",
            "child-subscript": "[{{value}}]"
          };
          return d = this._normalize(d), d.forEach(function(b) {
            if (b.expression.type != "root") {
              var f = [b.scope, b.operation].join("-"), E = m[f], A;
              if (b.expression.type == "string_literal" ? A = JSON.stringify(b.expression.value) : A = b.expression.value, !E) throw new Error("couldn't find template " + f);
              v += E.replace(/{{value}}/, A);
            }
          }), v;
        }, c.prototype._normalize = function(d) {
          if (s.ok(d, "we need a path"), typeof d == "string")
            return this.parser.parse(d);
          if (Array.isArray(d) && typeof d[0] == "string") {
            var v = [{ expression: { type: "root", value: "$" } }];
            return d.forEach(function(m, b) {
              if (!(m == "$" && b === 0))
                if (typeof m == "string" && m.match("^" + o.identifier + "$"))
                  v.push({
                    operation: "member",
                    scope: "child",
                    expression: { value: m, type: "identifier" }
                  });
                else {
                  var f = typeof m == "number" ? "numeric_literal" : "string_literal";
                  v.push({
                    operation: "subscript",
                    scope: "child",
                    expression: { value: m, type: f }
                  });
                }
            }), v;
          } else if (Array.isArray(d) && typeof d[0] == "object")
            return d;
          throw new Error("couldn't understand path " + d);
        };
        function p(d) {
          return Object.prototype.toString.call(d) == "[object String]";
        }
        c.Handlers = l, c.Parser = a;
        var h = new c();
        h.JSONPath = c, n.exports = h;
      }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
        var s = r("./grammar"), o = r("../generated/parser"), a = function() {
          var l = new o.Parser(), c = l.parseError;
          return l.yy.parseError = function() {
            l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
          }, l;
        };
        a.grammar = s, n.exports = a;
      }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
        n.exports = function(o, a, l, c) {
          if (typeof a == "string") throw new Error("start cannot be a string");
          if (typeof l == "string") throw new Error("end cannot be a string");
          if (typeof c == "string") throw new Error("step cannot be a string");
          var p = o.length;
          if (c === 0) throw new Error("step cannot be zero");
          if (c = c ? s(c) : 1, a = a < 0 ? p + a : a, l = l < 0 ? p + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : p - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? p : -1)), a = c > 0 ? Math.max(0, a) : Math.min(p, a), l = c > 0 ? Math.min(l, p) : Math.max(-1, l), c > 0 && l <= a) return [];
          if (c < 0 && a <= l) return [];
          for (var h = [], d = a; d != l && !(c < 0 && d <= l || c > 0 && d >= l); d += c)
            h.push(o[d]);
          return h;
        };
        function s(o) {
          return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
        }
      }, {}], 8: [function(r, n, i) {
        var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = v;
        l.AssertionError = function(g) {
          this.name = "AssertionError", this.actual = g.actual, this.expected = g.expected, this.operator = g.operator, g.message ? (this.message = g.message, this.generatedMessage = !1) : (this.message = h(this), this.generatedMessage = !0);
          var w = g.stackStartFunction || d;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, w);
          else {
            var _ = new Error();
            if (_.stack) {
              var S = _.stack, R = w.name, L = S.indexOf(`
` + R);
              if (L >= 0) {
                var F = S.indexOf(`
`, L + 1);
                S = S.substring(F + 1);
              }
              this.stack = S;
            }
          }
        }, s.inherits(l.AssertionError, Error);
        function c(g, w) {
          return s.isUndefined(w) ? "" + w : s.isNumber(w) && !isFinite(w) || s.isFunction(w) || s.isRegExp(w) ? w.toString() : w;
        }
        function p(g, w) {
          return s.isString(g) ? g.length < w ? g : g.slice(0, w) : g;
        }
        function h(g) {
          return p(JSON.stringify(g.actual, c), 128) + " " + g.operator + " " + p(JSON.stringify(g.expected, c), 128);
        }
        function d(g, w, _, S, R) {
          throw new l.AssertionError({
            message: _,
            actual: g,
            expected: w,
            operator: S,
            stackStartFunction: R
          });
        }
        l.fail = d;
        function v(g, w) {
          g || d(g, !0, w, "==", l.ok);
        }
        l.ok = v, l.equal = function(g, w, _) {
          g != w && d(g, w, _, "==", l.equal);
        }, l.notEqual = function(g, w, _) {
          g == w && d(g, w, _, "!=", l.notEqual);
        }, l.deepEqual = function(g, w, _) {
          m(g, w) || d(g, w, _, "deepEqual", l.deepEqual);
        };
        function m(g, w) {
          if (g === w)
            return !0;
          if (s.isBuffer(g) && s.isBuffer(w)) {
            if (g.length != w.length) return !1;
            for (var _ = 0; _ < g.length; _++)
              if (g[_] !== w[_]) return !1;
            return !0;
          } else return s.isDate(g) && s.isDate(w) ? g.getTime() === w.getTime() : s.isRegExp(g) && s.isRegExp(w) ? g.source === w.source && g.global === w.global && g.multiline === w.multiline && g.lastIndex === w.lastIndex && g.ignoreCase === w.ignoreCase : !s.isObject(g) && !s.isObject(w) ? g == w : f(g, w);
        }
        function b(g) {
          return Object.prototype.toString.call(g) == "[object Arguments]";
        }
        function f(g, w) {
          if (s.isNullOrUndefined(g) || s.isNullOrUndefined(w) || g.prototype !== w.prototype) return !1;
          if (s.isPrimitive(g) || s.isPrimitive(w))
            return g === w;
          var _ = b(g), S = b(w);
          if (_ && !S || !_ && S)
            return !1;
          if (_)
            return g = o.call(g), w = o.call(w), m(g, w);
          var R = x(g), L = x(w), F, z;
          if (R.length != L.length)
            return !1;
          for (R.sort(), L.sort(), z = R.length - 1; z >= 0; z--)
            if (R[z] != L[z])
              return !1;
          for (z = R.length - 1; z >= 0; z--)
            if (F = R[z], !m(g[F], w[F])) return !1;
          return !0;
        }
        l.notDeepEqual = function(g, w, _) {
          m(g, w) && d(g, w, _, "notDeepEqual", l.notDeepEqual);
        }, l.strictEqual = function(g, w, _) {
          g !== w && d(g, w, _, "===", l.strictEqual);
        }, l.notStrictEqual = function(g, w, _) {
          g === w && d(g, w, _, "!==", l.notStrictEqual);
        };
        function E(g, w) {
          return !g || !w ? !1 : Object.prototype.toString.call(w) == "[object RegExp]" ? w.test(g) : g instanceof w ? !0 : w.call({}, g) === !0;
        }
        function A(g, w, _, S) {
          var R;
          s.isString(_) && (S = _, _ = null);
          try {
            w();
          } catch (L) {
            R = L;
          }
          if (S = (_ && _.name ? " (" + _.name + ")." : ".") + (S ? " " + S : "."), g && !R && d(R, _, "Missing expected exception" + S), !g && E(R, _) && d(R, _, "Got unwanted exception" + S), g && R && _ && !E(R, _) || !g && R)
            throw R;
        }
        l.throws = function(g, w, _) {
          A.apply(this, [!0].concat(o.call(arguments)));
        }, l.doesNotThrow = function(g, w) {
          A.apply(this, [!1].concat(o.call(arguments)));
        }, l.ifError = function(g) {
          if (g)
            throw g;
        };
        var x = Object.keys || function(g) {
          var w = [];
          for (var _ in g)
            a.call(g, _) && w.push(_);
          return w;
        };
      }, { "util/": 11 }], 9: [function(r, n, i) {
        typeof Object.create == "function" ? n.exports = function(s, o) {
          s.super_ = o, s.prototype = Object.create(o.prototype, {
            constructor: {
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : n.exports = function(s, o) {
          s.super_ = o;
          var a = function() {
          };
          a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
        };
      }, {}], 10: [function(r, n, i) {
        n.exports = function(s) {
          return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
        };
      }, {}], 11: [function(r, n, i) {
        (function(s, o) {
          var a = /%[sdj%]/g;
          i.format = function(O) {
            if (!L(O)) {
              for (var N = [], J = 0; J < arguments.length; J++)
                N.push(p(arguments[J]));
              return N.join(" ");
            }
            for (var J = 1, re = arguments, oe = re.length, ee = String(O).replace(a, function(H) {
              if (H === "%%") return "%";
              if (J >= oe) return H;
              switch (H) {
                case "%s":
                  return String(re[J++]);
                case "%d":
                  return Number(re[J++]);
                case "%j":
                  try {
                    return JSON.stringify(re[J++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return H;
              }
            }), ae = re[J]; J < oe; ae = re[++J])
              _(ae) || !W(ae) ? ee += " " + ae : ee += " " + p(ae);
            return ee;
          }, i.deprecate = function(O, N) {
            if (z(o.process))
              return function() {
                return i.deprecate(O, N).apply(this, arguments);
              };
            if (s.noDeprecation === !0)
              return O;
            var J = !1;
            function re() {
              if (!J) {
                if (s.throwDeprecation)
                  throw new Error(N);
                s.traceDeprecation ? console.trace(N) : console.error(N), J = !0;
              }
              return O.apply(this, arguments);
            }
            return re;
          };
          var l = {}, c;
          i.debuglog = function(O) {
            if (z(c) && (c = s.env.NODE_DEBUG || ""), O = O.toUpperCase(), !l[O])
              if (new RegExp("\\b" + O + "\\b", "i").test(c)) {
                var N = s.pid;
                l[O] = function() {
                  var J = i.format.apply(i, arguments);
                  console.error("%s %d: %s", O, N, J);
                };
              } else
                l[O] = function() {
                };
            return l[O];
          };
          function p(O, N) {
            var J = {
              seen: [],
              stylize: d
            };
            return arguments.length >= 3 && (J.depth = arguments[2]), arguments.length >= 4 && (J.colors = arguments[3]), w(N) ? J.showHidden = N : N && i._extend(J, N), z(J.showHidden) && (J.showHidden = !1), z(J.depth) && (J.depth = 2), z(J.colors) && (J.colors = !1), z(J.customInspect) && (J.customInspect = !0), J.colors && (J.stylize = h), m(J, O, J.depth);
          }
          i.inspect = p, p.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, p.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function h(O, N) {
            var J = p.styles[N];
            return J ? "\x1B[" + p.colors[J][0] + "m" + O + "\x1B[" + p.colors[J][1] + "m" : O;
          }
          function d(O, N) {
            return O;
          }
          function v(O) {
            var N = {};
            return O.forEach(function(J, re) {
              N[J] = !0;
            }), N;
          }
          function m(O, N, J) {
            if (O.customInspect && N && ce(N.inspect) && // Filter out the util module, it's inspect function is special
            N.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
            !(N.constructor && N.constructor.prototype === N)) {
              var re = N.inspect(J, O);
              return L(re) || (re = m(O, re, J)), re;
            }
            var oe = b(O, N);
            if (oe)
              return oe;
            var ee = Object.keys(N), ae = v(ee);
            if (O.showHidden && (ee = Object.getOwnPropertyNames(N)), le(N) && (ee.indexOf("message") >= 0 || ee.indexOf("description") >= 0))
              return f(N);
            if (ee.length === 0) {
              if (ce(N)) {
                var me = N.name ? ": " + N.name : "";
                return O.stylize("[Function" + me + "]", "special");
              }
              if (j(N))
                return O.stylize(RegExp.prototype.toString.call(N), "regexp");
              if (te(N))
                return O.stylize(Date.prototype.toString.call(N), "date");
              if (le(N))
                return f(N);
            }
            var H = "", X = !1, Ae = ["{", "}"];
            if (g(N) && (X = !0, Ae = ["[", "]"]), ce(N)) {
              var Re = N.name ? ": " + N.name : "";
              H = " [Function" + Re + "]";
            }
            if (j(N) && (H = " " + RegExp.prototype.toString.call(N)), te(N) && (H = " " + Date.prototype.toUTCString.call(N)), le(N) && (H = " " + f(N)), ee.length === 0 && (!X || N.length == 0))
              return Ae[0] + H + Ae[1];
            if (J < 0)
              return j(N) ? O.stylize(RegExp.prototype.toString.call(N), "regexp") : O.stylize("[Object]", "special");
            O.seen.push(N);
            var Fe;
            return X ? Fe = E(O, N, J, ae, ee) : Fe = ee.map(function(Te) {
              return A(O, N, J, ae, Te, X);
            }), O.seen.pop(), x(Fe, H, Ae);
          }
          function b(O, N) {
            if (z(N))
              return O.stylize("undefined", "undefined");
            if (L(N)) {
              var J = "'" + JSON.stringify(N).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return O.stylize(J, "string");
            }
            if (R(N))
              return O.stylize("" + N, "number");
            if (w(N))
              return O.stylize("" + N, "boolean");
            if (_(N))
              return O.stylize("null", "null");
          }
          function f(O) {
            return "[" + Error.prototype.toString.call(O) + "]";
          }
          function E(O, N, J, re, oe) {
            for (var ee = [], ae = 0, me = N.length; ae < me; ++ae)
              ue(N, String(ae)) ? ee.push(A(
                O,
                N,
                J,
                re,
                String(ae),
                !0
              )) : ee.push("");
            return oe.forEach(function(H) {
              H.match(/^\d+$/) || ee.push(A(
                O,
                N,
                J,
                re,
                H,
                !0
              ));
            }), ee;
          }
          function A(O, N, J, re, oe, ee) {
            var ae, me, H;
            if (H = Object.getOwnPropertyDescriptor(N, oe) || { value: N[oe] }, H.get ? H.set ? me = O.stylize("[Getter/Setter]", "special") : me = O.stylize("[Getter]", "special") : H.set && (me = O.stylize("[Setter]", "special")), ue(re, oe) || (ae = "[" + oe + "]"), me || (O.seen.indexOf(H.value) < 0 ? (_(J) ? me = m(O, H.value, null) : me = m(O, H.value, J - 1), me.indexOf(`
`) > -1 && (ee ? me = me.split(`
`).map(function(X) {
              return "  " + X;
            }).join(`
`).substr(2) : me = `
` + me.split(`
`).map(function(X) {
              return "   " + X;
            }).join(`
`))) : me = O.stylize("[Circular]", "special")), z(ae)) {
              if (ee && oe.match(/^\d+$/))
                return me;
              ae = JSON.stringify("" + oe), ae.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ae = ae.substr(1, ae.length - 2), ae = O.stylize(ae, "name")) : (ae = ae.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ae = O.stylize(ae, "string"));
            }
            return ae + ": " + me;
          }
          function x(O, N, J) {
            var re = O.reduce(function(oe, ee) {
              return ee.indexOf(`
`) >= 0, oe + ee.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return re > 60 ? J[0] + (N === "" ? "" : N + `
 `) + " " + O.join(`,
  `) + " " + J[1] : J[0] + N + " " + O.join(", ") + " " + J[1];
          }
          function g(O) {
            return Array.isArray(O);
          }
          i.isArray = g;
          function w(O) {
            return typeof O == "boolean";
          }
          i.isBoolean = w;
          function _(O) {
            return O === null;
          }
          i.isNull = _;
          function S(O) {
            return O == null;
          }
          i.isNullOrUndefined = S;
          function R(O) {
            return typeof O == "number";
          }
          i.isNumber = R;
          function L(O) {
            return typeof O == "string";
          }
          i.isString = L;
          function F(O) {
            return typeof O == "symbol";
          }
          i.isSymbol = F;
          function z(O) {
            return O === void 0;
          }
          i.isUndefined = z;
          function j(O) {
            return W(O) && xe(O) === "[object RegExp]";
          }
          i.isRegExp = j;
          function W(O) {
            return typeof O == "object" && O !== null;
          }
          i.isObject = W;
          function te(O) {
            return W(O) && xe(O) === "[object Date]";
          }
          i.isDate = te;
          function le(O) {
            return W(O) && (xe(O) === "[object Error]" || O instanceof Error);
          }
          i.isError = le;
          function ce(O) {
            return typeof O == "function";
          }
          i.isFunction = ce;
          function Ee(O) {
            return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || // ES6 symbol
            typeof O > "u";
          }
          i.isPrimitive = Ee, i.isBuffer = r("./support/isBuffer");
          function xe(O) {
            return Object.prototype.toString.call(O);
          }
          function _e(O) {
            return O < 10 ? "0" + O.toString(10) : O.toString(10);
          }
          var Ie = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function je() {
            var O = /* @__PURE__ */ new Date(), N = [
              _e(O.getHours()),
              _e(O.getMinutes()),
              _e(O.getSeconds())
            ].join(":");
            return [O.getDate(), Ie[O.getMonth()], N].join(" ");
          }
          i.log = function() {
            console.log("%s - %s", je(), i.format.apply(i, arguments));
          }, i.inherits = r("inherits"), i._extend = function(O, N) {
            if (!N || !W(N)) return O;
            for (var J = Object.keys(N), re = J.length; re--; )
              O[J[re]] = N[J[re]];
            return O;
          };
          function ue(O, N) {
            return Object.prototype.hasOwnProperty.call(O, N);
          }
        }).call(this, r("_process"), typeof x9 < "u" ? x9 : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
      }, {}], 13: [function(r, n, i) {
        (function(s) {
          function o(p, h) {
            for (var d = 0, v = p.length - 1; v >= 0; v--) {
              var m = p[v];
              m === "." ? p.splice(v, 1) : m === ".." ? (p.splice(v, 1), d++) : d && (p.splice(v, 1), d--);
            }
            if (h)
              for (; d--; d)
                p.unshift("..");
            return p;
          }
          i.resolve = function() {
            for (var p = "", h = !1, d = arguments.length - 1; d >= -1 && !h; d--) {
              var v = d >= 0 ? arguments[d] : s.cwd();
              if (typeof v != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              v && (p = v + "/" + p, h = v.charAt(0) === "/");
            }
            return p = o(l(p.split("/"), function(m) {
              return !!m;
            }), !h).join("/"), (h ? "/" : "") + p || ".";
          }, i.normalize = function(p) {
            var h = i.isAbsolute(p), d = c(p, -1) === "/";
            return p = o(l(p.split("/"), function(v) {
              return !!v;
            }), !h).join("/"), !p && !h && (p = "."), p && d && (p += "/"), (h ? "/" : "") + p;
          }, i.isAbsolute = function(p) {
            return p.charAt(0) === "/";
          }, i.join = function() {
            var p = Array.prototype.slice.call(arguments, 0);
            return i.normalize(l(p, function(h, d) {
              if (typeof h != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return h;
            }).join("/"));
          }, i.relative = function(p, h) {
            p = i.resolve(p).substr(1), h = i.resolve(h).substr(1);
            function d(x) {
              for (var g = 0; g < x.length && x[g] === ""; g++)
                ;
              for (var w = x.length - 1; w >= 0 && x[w] === ""; w--)
                ;
              return g > w ? [] : x.slice(g, w - g + 1);
            }
            for (var v = d(p.split("/")), m = d(h.split("/")), b = Math.min(v.length, m.length), f = b, E = 0; E < b; E++)
              if (v[E] !== m[E]) {
                f = E;
                break;
              }
            for (var A = [], E = f; E < v.length; E++)
              A.push("..");
            return A = A.concat(m.slice(f)), A.join("/");
          }, i.sep = "/", i.delimiter = ":", i.dirname = function(p) {
            if (typeof p != "string" && (p = p + ""), p.length === 0) return ".";
            for (var h = p.charCodeAt(0), d = h === 47, v = -1, m = !0, b = p.length - 1; b >= 1; --b)
              if (h = p.charCodeAt(b), h === 47) {
                if (!m) {
                  v = b;
                  break;
                }
              } else
                m = !1;
            return v === -1 ? d ? "/" : "." : d && v === 1 ? "/" : p.slice(0, v);
          };
          function a(p) {
            typeof p != "string" && (p = p + "");
            var h = 0, d = -1, v = !0, m;
            for (m = p.length - 1; m >= 0; --m)
              if (p.charCodeAt(m) === 47) {
                if (!v) {
                  h = m + 1;
                  break;
                }
              } else d === -1 && (v = !1, d = m + 1);
            return d === -1 ? "" : p.slice(h, d);
          }
          i.basename = function(p, h) {
            var d = a(p);
            return h && d.substr(-1 * h.length) === h && (d = d.substr(0, d.length - h.length)), d;
          }, i.extname = function(p) {
            typeof p != "string" && (p = p + "");
            for (var h = -1, d = 0, v = -1, m = !0, b = 0, f = p.length - 1; f >= 0; --f) {
              var E = p.charCodeAt(f);
              if (E === 47) {
                if (!m) {
                  d = f + 1;
                  break;
                }
                continue;
              }
              v === -1 && (m = !1, v = f + 1), E === 46 ? h === -1 ? h = f : b !== 1 && (b = 1) : h !== -1 && (b = -1);
            }
            return h === -1 || v === -1 || // We saw a non-dot character immediately before the dot
            b === 0 || // The (right-most) trimmed path component is exactly '..'
            b === 1 && h === v - 1 && h === d + 1 ? "" : p.slice(h, v);
          };
          function l(p, h) {
            if (p.filter) return p.filter(h);
            for (var d = [], v = 0; v < p.length; v++)
              h(p[v], v, p) && d.push(p[v]);
            return d;
          }
          var c = "ab".substr(-1) === "b" ? function(p, h, d) {
            return p.substr(h, d);
          } : function(p, h, d) {
            return h < 0 && (h = p.length + h), p.substr(h, d);
          };
        }).call(this, r("_process"));
      }, { _process: 14 }], 14: [function(r, n, i) {
        var s = n.exports = {}, o, a;
        function l() {
          throw new Error("setTimeout has not been defined");
        }
        function c() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? o = setTimeout : o = l;
          } catch {
            o = l;
          }
          try {
            typeof clearTimeout == "function" ? a = clearTimeout : a = c;
          } catch {
            a = c;
          }
        })();
        function p(g) {
          if (o === setTimeout)
            return setTimeout(g, 0);
          if ((o === l || !o) && setTimeout)
            return o = setTimeout, setTimeout(g, 0);
          try {
            return o(g, 0);
          } catch {
            try {
              return o.call(null, g, 0);
            } catch {
              return o.call(this, g, 0);
            }
          }
        }
        function h(g) {
          if (a === clearTimeout)
            return clearTimeout(g);
          if ((a === c || !a) && clearTimeout)
            return a = clearTimeout, clearTimeout(g);
          try {
            return a(g);
          } catch {
            try {
              return a.call(null, g);
            } catch {
              return a.call(this, g);
            }
          }
        }
        var d = [], v = !1, m, b = -1;
        function f() {
          !v || !m || (v = !1, m.length ? d = m.concat(d) : b = -1, d.length && E());
        }
        function E() {
          if (!v) {
            var g = p(f);
            v = !0;
            for (var w = d.length; w; ) {
              for (m = d, d = []; ++b < w; )
                m && m[b].run();
              b = -1, w = d.length;
            }
            m = null, v = !1, h(g);
          }
        }
        s.nextTick = function(g) {
          var w = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var _ = 1; _ < arguments.length; _++)
              w[_ - 1] = arguments[_];
          d.push(new A(g, w)), d.length === 1 && !v && p(E);
        };
        function A(g, w) {
          this.fun = g, this.array = w;
        }
        A.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
        function x() {
        }
        s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(g) {
          return [];
        }, s.binding = function(g) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(g) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 15: [function(r, n, i) {
        var s = r("escodegen").generate;
        n.exports = function(o, a) {
          a || (a = {});
          var l = {}, c = function p(h, d) {
            if (h.type === "Literal")
              return h.value;
            if (h.type === "UnaryExpression") {
              var v = p(h.argument);
              return h.operator === "+" ? +v : h.operator === "-" ? -v : h.operator === "~" ? ~v : h.operator === "!" ? !v : l;
            } else if (h.type === "ArrayExpression") {
              for (var m = [], b = 0, f = h.elements.length; b < f; b++) {
                var E = p(h.elements[b]);
                if (E === l) return l;
                m.push(E);
              }
              return m;
            } else if (h.type === "ObjectExpression") {
              for (var A = {}, b = 0; b < h.properties.length; b++) {
                var x = h.properties[b], g = x.value === null ? x.value : p(x.value);
                if (g === l) return l;
                A[x.key.value || x.key.name] = g;
              }
              return A;
            } else if (h.type === "BinaryExpression" || h.type === "LogicalExpression") {
              var f = p(h.left);
              if (f === l) return l;
              var w = p(h.right);
              if (w === l) return l;
              var _ = h.operator;
              return _ === "==" ? f == w : _ === "===" ? f === w : _ === "!=" ? f != w : _ === "!==" ? f !== w : _ === "+" ? f + w : _ === "-" ? f - w : _ === "*" ? f * w : _ === "/" ? f / w : _ === "%" ? f % w : _ === "<" ? f < w : _ === "<=" ? f <= w : _ === ">" ? f > w : _ === ">=" ? f >= w : _ === "|" ? f | w : _ === "&" ? f & w : _ === "^" ? f ^ w : _ === "&&" ? f && w : _ === "||" ? f || w : l;
            } else {
              if (h.type === "Identifier")
                return {}.hasOwnProperty.call(a, h.name) ? a[h.name] : l;
              if (h.type === "ThisExpression")
                return {}.hasOwnProperty.call(a, "this") ? a.this : l;
              if (h.type === "CallExpression") {
                var S = p(h.callee);
                if (S === l || typeof S != "function") return l;
                var R = h.callee.object ? p(h.callee.object) : l;
                R === l && (R = null);
                for (var L = [], b = 0, f = h.arguments.length; b < f; b++) {
                  var E = p(h.arguments[b]);
                  if (E === l) return l;
                  L.push(E);
                }
                return S.apply(R, L);
              } else if (h.type === "MemberExpression") {
                var A = p(h.object);
                if (A === l || typeof A == "function")
                  return l;
                if (h.property.type === "Identifier")
                  return A[h.property.name];
                var x = p(h.property);
                return x === l ? l : A[x];
              } else if (h.type === "ConditionalExpression") {
                var v = p(h.test);
                return v === l ? l : p(v ? h.consequent : h.alternate);
              } else if (h.type === "ExpressionStatement") {
                var v = p(h.expression);
                return v === l ? l : v;
              } else {
                if (h.type === "ReturnStatement")
                  return p(h.argument);
                if (h.type === "FunctionExpression") {
                  var F = h.body.body, z = {};
                  Object.keys(a).forEach(function(Ie) {
                    z[Ie] = a[Ie];
                  });
                  for (var b = 0; b < h.params.length; b++) {
                    var j = h.params[b];
                    if (j.type == "Identifier")
                      a[j.name] = null;
                    else return l;
                  }
                  for (var b in F)
                    if (p(F[b]) === l)
                      return l;
                  a = z;
                  var W = Object.keys(a), te = W.map(function(Ie) {
                    return a[Ie];
                  });
                  return Function(W.join(", "), "return " + s(h)).apply(null, te);
                } else if (h.type === "TemplateLiteral") {
                  for (var le = "", b = 0; b < h.expressions.length; b++)
                    le += p(h.quasis[b]), le += p(h.expressions[b]);
                  return le += p(h.quasis[b]), le;
                } else if (h.type === "TaggedTemplateExpression") {
                  var ce = p(h.tag), Ee = h.quasi, xe = Ee.quasis.map(p), _e = Ee.expressions.map(p);
                  return ce.apply(null, [xe].concat(_e));
                } else return h.type === "TemplateElement" ? h.value.cooked : l;
              }
            }
          }(o);
          return c === l ? void 0 : c;
        };
      }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
        n.exports = r("./lib/index");
      }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
    });
  }(M9)), M9.exports;
}
aJ();
function lJ(t) {
  return t.replace(/\W+/g, "_").toLowerCase();
}
const Sx = {
  line: "line",
  stepline: "line",
  bar: "bar",
  column: "bar",
  lollipop: "bar",
  histogram: "histogram",
  scatter: "scatter",
  heatmap: "scatter",
  pie: "pastry",
  donut: "pastry",
  graph: "graph"
};
(() => {
  const t = {
    line: [],
    bar: [],
    pastry: [],
    scatter: [],
    histogram: [],
    graph: []
  };
  for (let e of Object.keys(Sx))
    t[Sx[e]].push(e);
  return t;
})();
function cJ(t) {
  var e, r, n = t.length;
  if (n === 1)
    e = 0, r = t[0][1];
  else {
    for (var i = 0, s = 0, o = 0, a = 0, l, c, p, h = 0; h < n; h++)
      l = t[h], c = l[0], p = l[1], i += c, s += p, o += c * c, a += c * p;
    e = (n * a - i * s) / (n * o - i * i), r = s / n - e * i / n;
  }
  return {
    m: e,
    b: r
  };
}
function uJ(t) {
  if (t.length === 0)
    throw new Error("min requires at least one data point");
  for (var e = t[0], r = 1; r < t.length; r++)
    t[r] < e && (e = t[r]);
  return e;
}
function hJ(t) {
  if (t.length === 0)
    throw new Error("max requires at least one data point");
  for (var e = t[0], r = 1; r < t.length; r++)
    t[r] > e && (e = t[r]);
  return e;
}
var pJ = Object.defineProperty, dJ = (t, e, r) => e in t ? pJ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Op = (t, e, r) => (dJ(t, typeof e != "symbol" ? e + "" : e, r), r);
let fJ = class extends Error {
  constructor(e) {
    super(`line must have at least ${e} points`);
  }
}, gJ = class extends Error {
  constructor() {
    super("The first array in a zipped array must not be longer than the second.");
  }
};
const mJ = { width: 3, height: 1 };
function yJ(t, e, r, n) {
  let { start: i, end: s } = r;
  return i === s && (i -= 1, s += 1), {
    x: (t.x - e.start) * n.width / (e.end - e.start),
    y: (t.y - i) * n.height / (s - i)
  };
}
function Vf(t) {
  return Math.atan(t) * 180 / Math.PI;
}
function Gu(t, e) {
  const r = [];
  for (let n = 0; n < t; n++)
    r.push(e(n));
  return r;
}
function vJ(t, e) {
  if (t.length > e.length)
    throw new gJ();
  return t.map(function(r, n) {
    return [r, e[n]];
  });
}
let u0 = class xp {
  /**
   * @param points - The line's points.
   * @param key - Optional string key for identifying the line.
   */
  constructor(e, r) {
    Op(this, "computedBestFit"), this.points = e, this.key = r;
  }
  /**
   * Create a new Line from an array of y-values.
   * @param values - Y-values.
   * @param key - Optional string key for identifying the line.
   * @returns New Line.
   */
  static fromValues(e, r) {
    return new xp(e.map((n, i) => ({ x: i, y: n })), r);
  }
  /**
   * Generate a straight line given starting and ending y-values.
   * @param y1 - Starting y-value.
   * @param y2 - Ending y-value.
   * @param n - Number of points.
   * @param startX - Optional starting x-value.
   * @param xStep - Optional x step value.
   * @param key - Optional string key for identifying the line.
   * @returns New Line.
   */
  static generate(e, r, n, i = 0, s = 1, o) {
    const a = (r - e) / (n - 1), l = [{ x: i, y: e }];
    for (let c = 1; c < n - 1; c++)
      l.push({ x: i + c * s, y: e + c * a });
    return l.push({ x: i + l.length * s, y: r }), new xp(l, o);
  }
  /**
   * Number of points in the line.
   */
  get length() {
    return this.points.length;
  }
  /**
   * Get a sub-sequence of the line.
   * @param start - As in Array.prototype.slice().
   * @param end - As in Array.prototype.slice().
   * @returns The slice.
   */
  slice(e, r) {
    return new xp(this.points.slice(e, r));
  }
  /**
   * Create a new line by concatenating the line with another line.
   * @param line - The other line.
   * @returns The new line.
   */
  concat(e) {
    return new xp(this.points.concat(e.points));
  }
  /**
   * Inserts new points at the start of the line.
   * @param points - New points.
   * @returns New number of points in the line.
   */
  unshift(...e) {
    return e.length ? (this.computedBestFit = void 0, this.points.unshift(...e)) : this.points.length;
  }
  /**
   * Removes the first point of the line.
   * @returns The removed point.
   */
  shift() {
    return this.computedBestFit = void 0, this.points.shift();
  }
  /**
   * Inserts new points at the end of the line.
   * @param points - New points.
   * @returns New number of points in the line.
   */
  push(...e) {
    return e.length ? (this.computedBestFit = void 0, this.points.push(...e)) : this.points.length;
  }
  /**
   * Removes the last point of the line.
   * @returns The removed point.
   */
  pop() {
    return this.computedBestFit = void 0, this.points.pop();
  }
  /**
   * Extract a section of the line within an x-value interval.
   * If one or both interval bounds fall between existing points,
   * (a) new endpoint(s) will be produced via interpolation. 
   * @param interval - The x-value interval of the line section to extract.
   * @returns The extracted line section.
   */
  extractSection(e) {
    if (e.end < e.start || e.start > this.points.at(-1).x || e.start < this.points[0].x || e.end < this.points[0].x || e.end > this.points.at(-1).x)
      return;
    const r = this.points.findIndex((l) => l.x >= e.start);
    let n = this.points.findIndex((l) => l.x > e.end) - 1;
    n === -2 && (n = this.points.length - 1);
    const i = this.slice(r, n + 1), s = this.points[r].x > e.start, o = this.points[n].x < e.end;
    if (!s && !o)
      return i;
    const a = this.points[1].x - this.points[0].x;
    if (s) {
      const l = (e.start - this.points[r - 1].x) / a;
      i.unshift({
        x: e.start,
        y: this.points[r - 1].y + (this.points[r].y - this.points[r - 1].y) * l
      });
    }
    if (o && e.start !== e.end) {
      const l = (e.end - this.points[n].x) / a;
      i.push({
        x: e.end,
        y: this.points[n].y + (this.points[n + 1].y - this.points[n].y) * l
      });
    }
    return i;
  }
  /**
   * Project line into another coordinate system.
   * @param xAxis - Source chart display x-axis bounds.
   * @param yAxis - Source chart display y-axis bounds.
   * @param destSize - Destination coordinate system size (default: the shared training coord sys).
   * @returns Projected line.
   */
  project(e, r, n = mJ) {
    return new xp(this.points.map((i) => yJ(i, e ?? this.xBounds(), r ?? this.yBounds(), n)));
  }
  /**
   * Compute line's min and max x-values.
   * @returns X bounds.
   */
  xBounds() {
    return { start: this.points[0].x, end: this.points.at(-1).x };
  }
  /**
   * Compute line's min and max y-values.
   * @returns Y bounds.
   */
  yBounds() {
    const e = this.points.map((r) => r.y);
    return { start: uJ(e), end: hJ(e) };
  }
  /**
   * Compute the magnitude of the x-value range covered by the line.
   * @returns X-value range.
   */
  xRange() {
    const e = this.xBounds();
    return e.end - e.start;
  }
  /**
   * Compute the magnitude of the y-value range covered by the line.
   * @returns Y-value range.
   */
  yRange() {
    const e = this.yBounds();
    return e.end - e.start;
  }
  /**
   * Extract the line segments comprising the line.
   * @returns The line segments.
   */
  getSegments() {
    return this.points.slice(0, -1).map((e, r) => new KT({ start: e, end: this.points[r + 1] }));
  }
  /**
   * Get the best-fit straight line approximating this line. 
   * @returns Best-fit line.
   */
  get bestFit() {
    return this.computedBestFit || (this.computedBestFit = new bJ(this)), this.computedBestFit;
  }
}, KT = class {
  /**
   * @param endpoints - Endpoints of the segment.
   */
  constructor(e) {
    Op(this, "computedSlope"), Op(this, "computedAngle"), this.endpoints = e;
  }
  /**
   * Slope of the segment.
   */
  get slope() {
    return this.computedSlope === void 0 && (this.computedSlope = (this.endpoints.end.y - this.endpoints.start.y) / (this.endpoints.end.x - this.endpoints.start.x)), this.computedSlope;
  }
  /** Angle of the segment with the x-axis. */
  get xAngle() {
    return this.computedAngle === void 0 && (this.computedAngle = Vf(this.slope)), this.computedAngle;
  }
}, bJ = class extends KT {
  /**
   * @param line - Line to approximate.
   */
  constructor(e) {
    if (e.length < 3)
      throw new fJ(3);
    const r = cJ(e.points.map((i) => [i.x, i.y])), n = e.points.map((i) => ({ x: i.x, y: r.m * i.x + r.b }));
    super({ start: n[0], end: n.at(-1) }), Op(this, "intercept"), Op(this, "points"), Op(this, "residuals"), this.line = e, this.computedSlope = r.m, this.intercept = r.b, this.points = n, this.residuals = e.points.map((i, s) => i.y - n[s].y);
  }
  /**
   * Compute the residual sum of squares.
   * @returns Residual sum of squares.
   */
  rss() {
    return this.residuals.map((e) => e ** 2).reduce((e, r) => e + r);
  }
};
function Oi(t, e, r, n, i) {
  return Ta(e, ((s, o) => {
    const a = s[o];
    if (a === void 0)
      throw new TypeError(z6(o));
    return a;
  })(t, e), r, n, i);
}
function Ta(t, e, r, n, i, s) {
  const o = p0(e, r, n);
  if (i && e !== o)
    throw new RangeError(cM(t, e, r, n, s));
  return o;
}
function gi(t) {
  return t !== null && /object|function/.test(typeof t);
}
function us(t, e = Map) {
  const r = new e();
  return (n, ...i) => {
    if (r.has(n))
      return r.get(n);
    const s = t(n, ...i);
    return r.set(n, s), s;
  };
}
function h0(t) {
  return zp({
    name: t
  }, 1);
}
function zp(t, e) {
  return La((r) => ({
    value: r,
    configurable: 1,
    writable: !e
  }), t);
}
function wJ(t) {
  return La((e) => ({
    get: e,
    configurable: 1
  }), t);
}
function QE(t) {
  return {
    [Symbol.toStringTag]: {
      value: t,
      configurable: 1
    }
  };
}
function gd(t, e) {
  const r = {};
  let n = t.length;
  for (const i of e)
    r[t[--n]] = i;
  return r;
}
function La(t, e, r) {
  const n = {};
  for (const i in e)
    n[i] = t(e[i], i, r);
  return n;
}
function H2(t, e, r) {
  const n = {};
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    n[s] = t(s, i, r);
  }
  return n;
}
function YT(t, e, r) {
  const n = {};
  for (let i = 0; i < t.length; i++)
    n[e[i]] = r[t[i]];
  return n;
}
function Js(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const n of t)
    r[n] = e[n];
  return r;
}
function D9(t, e) {
  for (const r of e)
    if (r in t)
      return 1;
  return 0;
}
function ZT(t, e, r) {
  for (const n of t)
    if (e[n] !== r[n])
      return 0;
  return 1;
}
function JT(t, e, r) {
  const n = {
    ...r
  };
  for (let i = 0; i < e; i++)
    n[t[i]] = 0;
  return n;
}
function nr(t, ...e) {
  return (...r) => t(...e, ...r);
}
function $9(t) {
  return t[0].toUpperCase() + t.substring(1);
}
function cg(t) {
  return t.slice().sort();
}
function cy(t, e) {
  return String(e).padStart(t, "0");
}
function Dl(t, e) {
  return Math.sign(t - e);
}
function p0(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
function ba(t, e) {
  return [Math.floor(t / e), Hf(t, e)];
}
function Hf(t, e) {
  return (t % e + e) % e;
}
function ql(t, e) {
  return [G2(t, e), KE(t, e)];
}
function G2(t, e) {
  return Math.trunc(t / e) || 0;
}
function KE(t, e) {
  return t % e || 0;
}
function Om(t) {
  return Math.abs(t % 1) === 0.5;
}
function XT(t, e, r) {
  let n = 0, i = 0;
  for (let a = 0; a <= e; a++) {
    const l = t[r[a]], c = zo[a], p = jr / c, [h, d] = ql(l, p);
    n += d * c, i += h;
  }
  const [s, o] = ql(n, jr);
  return [i + s, o];
}
function W2(t, e, r) {
  const n = {};
  for (let i = e; i >= 0; i--) {
    const s = zo[i];
    n[r[i]] = G2(t, s), t = KE(t, s);
  }
  return n;
}
function xJ(t) {
  if (t !== void 0)
    return Jn(t);
}
function EJ(t) {
  if (t !== void 0)
    return ha(t);
}
function eL(t) {
  if (t !== void 0)
    return YE(t);
}
function ha(t) {
  return nL(YE(t));
}
function YE(t) {
  return rL(Tee(t));
}
function tL(t, e) {
  if (e == null)
    throw new RangeError(z6(t));
  return e;
}
function ug(t) {
  if (!gi(t))
    throw new TypeError(nee);
  return t;
}
function ZE(t, e, r = t) {
  if (typeof e !== t)
    throw new TypeError(wc(r, e));
  return e;
}
function rL(t, e = "number") {
  if (!Number.isInteger(t))
    throw new RangeError(ZX(e, t));
  return t || 0;
}
function nL(t, e = "number") {
  if (t <= 0)
    throw new RangeError(JX(e, t));
  return t;
}
function JE(t) {
  if (typeof t == "symbol")
    throw new TypeError(ree);
  return String(t);
}
function m1(t, e) {
  return gi(t) ? String(t) : Jn(t, e);
}
function XE(t) {
  if (typeof t == "string")
    return BigInt(t);
  if (typeof t != "bigint")
    throw new TypeError(tee(t));
  return t;
}
function iL(t, e = "number") {
  if (typeof t == "bigint")
    throw new TypeError(eee(e));
  if (t = Number(t), !Number.isFinite(t))
    throw new RangeError(XX(e, t));
  return t;
}
function ii(t, e) {
  return Math.trunc(iL(t, e)) || 0;
}
function e6(t, e) {
  return rL(iL(t, e), e);
}
function j9(t, e) {
  return nL(ii(t, e), e);
}
function t6(t, e) {
  let [r, n] = ql(e, jr), i = t + r;
  const s = Math.sign(i);
  return s && s === -Math.sign(n) && (i -= s, n += s * jr), [i, n];
}
function Up(t, e, r = 1) {
  return t6(t[0] + e[0] * r, t[1] + e[1] * r);
}
function th(t, e) {
  return t6(t[0], t[1] + e);
}
function Bo(t, e) {
  return Up(e, t, -1);
}
function hs(t, e) {
  return Dl(t[0], e[0]) || Dl(t[1], e[1]);
}
function sL(t, e, r) {
  return hs(t, e) === -1 || hs(t, r) === 1;
}
function r6(t, e = 1) {
  const r = BigInt(jr / e);
  return [Number(t / r), Number(t % r) * e];
}
function uy(t, e = 1) {
  const r = jr / e, [n, i] = ql(t, r);
  return [n, i * e];
}
function Fo(t, e = 1, r) {
  const [n, i] = t, [s, o] = ql(i, e);
  return n * (jr / e) + (s + (r ? o / e : 0));
}
function n6(t, e, r = ba) {
  const [n, i] = t, [s, o] = r(i, e);
  return [n * (jr / e) + s, o];
}
function i6(t) {
  return Oi(t, "isoYear", v0, y0, 1), t.isoYear === v0 ? Oi(t, "isoMonth", 4, 12, 1) : t.isoYear === y0 && Oi(t, "isoMonth", 1, 9, 1), t;
}
function $s(t) {
  return zi({
    ...t,
    ...Ui,
    isoHour: 12
  }), t;
}
function zi(t) {
  const e = Oi(t, "isoYear", v0, y0, 1), r = e === v0 ? 1 : e === y0 ? -1 : 0;
  return r && Jo(Pn({
    ...t,
    isoDay: t.isoDay + r,
    isoNanosecond: t.isoNanosecond - r
  })), t;
}
function Jo(t) {
  if (!t || sL(t, Fee, Bee))
    throw new RangeError(xc);
  return t;
}
function Ql(t) {
  return XT(t, 5, to)[1];
}
function q2(t) {
  const [e, r] = ba(t, jr);
  return [W2(r, 5, to), e];
}
function B9(t) {
  return n6(t, No);
}
function ai(t) {
  return md(t.isoYear, t.isoMonth, t.isoDay, t.isoHour, t.isoMinute, t.isoSecond, t.isoMillisecond);
}
function Pn(t) {
  const e = ai(t);
  if (e !== void 0) {
    const [r, n] = ql(e, ji);
    return [r, n * Ga + (t.isoMicrosecond || 0) * yg + (t.isoNanosecond || 0)];
  }
}
function s6(t, e) {
  const [r, n] = q2(Ql(t) - e);
  return Jo(Pn({
    ...t,
    isoDay: t.isoDay + n,
    ...r
  }));
}
function hy(...t) {
  return md(...t) / vM;
}
function md(...t) {
  const [e, r] = oL(...t), n = e.valueOf();
  if (!isNaN(n))
    return n - r * ji;
}
function oL(t, e = 1, r = 1, n = 0, i = 0, s = 0, o = 0) {
  const a = t === v0 ? 1 : t === y0 ? -1 : 0, l = /* @__PURE__ */ new Date();
  return l.setUTCHours(n, i, s, o), l.setUTCFullYear(t, e - 1, r + a), [l, a];
}
function yd(t, e) {
  let [r, n] = th(t, e);
  n < 0 && (n += jr, r -= 1);
  const [i, s] = ba(n, Ga), [o, a] = ba(s, yg);
  return Q2(r * ji + i, o, a);
}
function Q2(t, e = 0, r = 0) {
  const n = Math.ceil(Math.max(0, Math.abs(t) - jee) / ji) * Math.sign(t), i = new Date(t - n * ji);
  return gd(gv, [i.getUTCFullYear(), i.getUTCMonth() + 1, i.getUTCDate() + n, i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds(), e, r]);
}
function o6(t, e) {
  if (e < -864e13)
    throw new RangeError(xc);
  const r = t.formatToParts(e), n = {};
  for (const i of r)
    n[i.type] = i.value;
  return n;
}
function a6(t) {
  return [t.isoYear, t.isoMonth, t.isoDay];
}
function aL(t, e) {
  return [e, 0];
}
function lL() {
  return hl;
}
function cL(t, e) {
  switch (e) {
    case 2:
      return l6(t) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function uL(t) {
  return l6(t) ? 366 : 365;
}
function l6(t) {
  return t % 4 == 0 && (t % 100 != 0 || t % 400 == 0);
}
function hL(t) {
  const [e, r] = oL(t.isoYear, t.isoMonth, t.isoDay);
  return Hf(e.getUTCDay() - r, 7) || 7;
}
function pL(t) {
  return this.id === kd ? (({ isoYear: e }) => e < 1 ? ["gregory-inverse", 1 - e] : ["gregory", e])(t) : this.id === Zl ? Vee(t) : [];
}
function SJ(t) {
  const e = ai(t);
  if (e < Uee) {
    const { isoYear: s } = t;
    return s < 1 ? ["japanese-inverse", 1 - s] : ["japanese", s];
  }
  const r = o6(a5(Zl), e), { era: n, eraYear: i } = JL(r, Zl);
  return [n, i];
}
function K2(t) {
  return Ph(t), vd(t, 1), t;
}
function Ph(t) {
  return dL(t, 1), t;
}
function F9(t) {
  return ZT(Y6, t, dL(t));
}
function dL(t, e) {
  const { isoYear: r } = t, n = Oi(t, "isoMonth", 1, lL(), e);
  return {
    isoYear: r,
    isoMonth: n,
    isoDay: Oi(t, "isoDay", 1, cL(r, n), e)
  };
}
function vd(t, e) {
  return gd(to, [Oi(t, "isoHour", 0, 23, e), Oi(t, "isoMinute", 0, 59, e), Oi(t, "isoSecond", 0, 59, e), Oi(t, "isoMillisecond", 0, 999, e), Oi(t, "isoMicrosecond", 0, 999, e), Oi(t, "isoNanosecond", 0, 999, e)]);
}
function fr(t) {
  return t === void 0 ? 0 : MM(ug(t));
}
function Y2(t, e = 0) {
  t = Xo(t);
  const r = NM(t), n = Xee(t, e);
  return [MM(t), n, r];
}
function bd(t, e, r, n = 9, i = 0, s = 4) {
  e = Xo(e);
  let o = LM(e, n, i), a = h6(e), l = wg(e, s);
  const c = bg(e, n, i, 1);
  return o == null ? o = Math.max(r, c) : yL(o, c), a = p6(a, c, 1), t && (l = ((p) => p < 4 ? (p + 2) % 4 : p)(l)), [o, c, a, l];
}
function Z2(t, e = 6, r) {
  let n = h6(t = J2(t, yy));
  const i = wg(t, 7);
  let s = bg(t, e);
  return s = tL(yy, s), n = p6(n, s, void 0, r), [s, n, i];
}
function c6(t) {
  return J6(Xo(t));
}
function fL(t, e) {
  return u6(Xo(t), e);
}
function AJ(t) {
  const e = J2(t, ww), r = gc(ww, Zee, e, 0);
  if (!r)
    throw new RangeError(wc(ww, r));
  return r;
}
function u6(t, e = 4) {
  const r = mL(t);
  return [wg(t, 4), ...gL(bg(t, e), r)];
}
function gL(t, e) {
  return t != null ? [zo[t], t < 4 ? 9 - 3 * t : -1] : [e === void 0 ? 1 : 10 ** (9 - e), e];
}
function h6(t) {
  const e = t[Gf];
  return e === void 0 ? 1 : ii(e, Gf);
}
function p6(t, e, r, n) {
  const i = n ? jr : zo[e + 1];
  if (i) {
    const s = zo[e];
    if (i % ((t = Ta(Gf, t, 1, i / s - (n ? 0 : 1), 1)) * s))
      throw new RangeError(wc(Gf, t));
  } else
    t = Ta(Gf, t, 1, r ? 10 ** 9 : 1, 1);
  return t;
}
function mL(t) {
  let e = t[bw];
  if (e !== void 0) {
    if (typeof e != "number") {
      if (JE(e) === "auto")
        return;
      throw new RangeError(wc(bw, e));
    }
    e = Ta(bw, Math.floor(e), 0, 9, 1);
  }
  return e;
}
function Xo(t) {
  return t === void 0 ? {} : ug(t);
}
function J2(t, e) {
  return typeof t == "string" ? {
    [e]: t
  } : ug(t);
}
function X2(t) {
  return {
    overflow: Hee[t]
  };
}
function d6(t, e, r = 9, n = 0, i) {
  let s = e[t];
  if (s === void 0)
    return i ? n : void 0;
  if (s = JE(s), s === "auto")
    return i ? n : null;
  let o = Cx[s];
  if (o === void 0 && (o = Nee[s]), o === void 0)
    throw new RangeError(hM(t, s, Cx));
  return Ta(t, o, n, r, 1, U6), o;
}
function gc(t, e, r, n = 0) {
  const i = r[t];
  if (i === void 0)
    return n;
  const s = JE(i), o = e[s];
  if (o === void 0)
    throw new RangeError(hM(t, s, e));
  return o;
}
function yL(t, e) {
  if (e > t)
    throw new RangeError(Aee);
}
function Va(t) {
  return {
    branding: r5,
    epochNanoseconds: t
  };
}
function Xs(t, e, r) {
  return {
    branding: Ec,
    calendar: r,
    timeZone: e,
    epochNanoseconds: t
  };
}
function eo(t, e = t.calendar) {
  return {
    branding: _d,
    calendar: e,
    ...Js(Dee, t)
  };
}
function Ha(t, e = t.calendar) {
  return {
    branding: xg,
    calendar: e,
    ...Js(Z6, t)
  };
}
function d0(t, e = t.calendar) {
  return {
    branding: X6,
    calendar: e,
    ...Js(Z6, t)
  };
}
function py(t, e = t.calendar) {
  return {
    branding: e5,
    calendar: e,
    ...Js(Z6, t)
  };
}
function ea(t) {
  return {
    branding: t5,
    ...Js(IM, t)
  };
}
function gn(t) {
  return {
    branding: n5,
    sign: mc(t),
    ...Js(q6, t)
  };
}
function f6(t) {
  return n6(t.epochNanoseconds, Ga)[0];
}
function kJ(t) {
  return ((e, r = 1) => {
    const [n, i] = e, s = Math.floor(i / r), o = jr / r;
    return BigInt(n) * BigInt(o) + BigInt(s);
  })(t.epochNanoseconds);
}
function vL(t) {
  return t.epochNanoseconds;
}
function _J(t, e, r, n, i) {
  const s = rh(n), [o, a] = ((E, A) => {
    const x = A((E = J2(E, Rx))[OM]);
    let g = Jee(E);
    return g = tL(Rx, g), [g, x];
  })(i, t), l = Math.max(o, s);
  if (!a && g0(l, a))
    return z9(n, o);
  if (!a)
    throw new RangeError(pv);
  if (!n.sign)
    return 0;
  const [c, p, h] = iv(e, r, a), d = S6(h), v = sv(h), m = A6(h), b = v(p, c, n);
  Vp(a) || (zi(c), zi(b));
  const f = m(p, c, b, o);
  return g0(o, a) ? z9(f, o) : ((E, A, x, g, w, _, S) => {
    const R = mc(E), [L, F] = g6(g, K6(x, E), x, R, w, _, S), z = m6(A, L, F);
    return E[br[x]] + z * R;
  })(f, d(b), o, p, c, d, v);
}
function z9(t, e) {
  return Fo(Tn(t), zo[e], 1);
}
function g6(t, e, r, n, i, s, o) {
  const a = br[r], l = {
    ...e,
    [a]: e[a] + n
  }, c = o(t, i, e), p = o(t, i, l);
  return [s(c), s(p)];
}
function m6(t, e, r) {
  const n = Fo(Bo(e, r));
  if (!n)
    throw new RangeError(Ad);
  return Fo(Bo(e, t)) / n;
}
function CJ(t, e) {
  const [r, n, i] = Z2(e, 5, 1);
  return Va(tv(t.epochNanoseconds, r, n, i, 1));
}
function IJ(t, e, r) {
  let { epochNanoseconds: n, timeZone: i, calendar: s } = e;
  const [o, a, l] = Z2(r);
  if (o === 0 && a === 1)
    return e;
  const c = t(i);
  if (o === 6)
    n = ((p, h, d, v) => {
      const m = ds(d, h), [b, f] = p(m), E = d.epochNanoseconds, A = Yl(h, b), x = Yl(h, f);
      if (sL(E, A, x))
        throw new RangeError(Ad);
      return SL(m6(E, A, x), v) ? x : A;
    })(xL, c, e, l);
  else {
    const p = c.R(n);
    n = wd(c, bL(yd(n, p), o, a, l), p, 2, 0, 1);
  }
  return Xs(n, i, s);
}
function PJ(t, e) {
  return eo(bL(t, ...Z2(e)), t.calendar);
}
function RJ(t, e) {
  const [r, n, i] = Z2(e, 5);
  var s;
  return ea((s = i, y6(t, hg(r, n), s)[0]));
}
function OJ(t, e) {
  const r = t(e.timeZone), n = ds(e, r), [i, s] = xL(n), o = Fo(Bo(Yl(r, i), Yl(r, s)), fv, 1);
  if (o <= 0)
    throw new RangeError(Ad);
  return o;
}
function TJ(t, e) {
  const { timeZone: r, calendar: n } = e, i = ((s, o, a) => Yl(o, s(ds(a, o))))(EL, t(r), e);
  return Xs(i, r, n);
}
function bL(t, e, r, n) {
  return wL(t, hg(e, r), n);
}
function wL(t, e, r) {
  const [n, i] = y6(t, e, r);
  return zi({
    ...Rh(t, i),
    ...n
  });
}
function y6(t, e, r) {
  return q2(Kl(Ql(t), e, r));
}
function dy(t) {
  return Kl(t, dv, 7);
}
function hg(t, e) {
  return zo[t] * e;
}
function xL(t) {
  const e = EL(t);
  return [e, Rh(e, 1)];
}
function EL(t) {
  return $ee(6, t);
}
function LJ(t, e, r) {
  const n = Math.min(rh(t), 6);
  return xd(rv(Tn(t, n), e, r), n);
}
function ev(t, e, r, n, i, s, o, a, l, c) {
  if (n === 0 && i === 1)
    return t;
  const p = g0(n, a) ? Vp(a) && n < 6 && r >= 6 ? NJ : MJ : DJ;
  let [h, d, v] = p(t, e, r, n, i, s, o, a, l, c);
  return v && n !== 7 && (h = ((m, b, f, E, A, x, g, w) => {
    const _ = mc(m);
    for (let S = E + 1; S <= f; S++) {
      if (S === 7 && f !== 7)
        continue;
      const R = K6(S, m);
      R[br[S]] += _;
      const L = Fo(Bo(g(w(A, x, R)), b));
      if (L && Math.sign(L) !== _)
        break;
      m = R;
    }
    return m;
  })(h, d, r, Math.max(6, n), o, a, l, c)), h;
}
function tv(t, e, r, n, i) {
  if (e === 6) {
    const s = ((o) => o[0] + o[1] / jr)(t);
    return [Kl(s, r, n), 0];
  }
  return rv(t, hg(e, r), n, i);
}
function rv(t, e, r, n) {
  let [i, s] = t;
  n && s < 0 && (s += jr, i -= 1);
  const [o, a] = ba(Kl(s, e, r), jr);
  return t6(i + o, a);
}
function Kl(t, e, r) {
  return SL(t / e, r) * e;
}
function SL(t, e) {
  return rte[e](t);
}
function MJ(t, e, r, n, i, s) {
  const o = mc(t), a = Tn(t), l = tv(a, n, i, s), c = Bo(a, l), p = Math.sign(l[0] - a[0]) === o, h = xd(l, Math.min(r, 6));
  return [{
    ...t,
    ...h
  }, Up(e, c), p];
}
function NJ(t, e, r, n, i, s, o, a, l, c) {
  const p = mc(t) || 1, h = Fo(Tn(t, 5)), d = hg(n, i);
  let v = Kl(h, d, s);
  const [m, b] = g6(o, {
    ...t,
    ...Q6
  }, 6, p, a, l, c), f = v - Fo(Bo(m, b));
  let E = 0;
  f && Math.sign(f) !== p ? e = th(m, v) : (E += p, v = Kl(f, d, s), e = th(b, v));
  const A = ov(v);
  return [{
    ...t,
    ...A,
    days: t.days + E
  }, e, !!E];
}
function DJ(t, e, r, n, i, s, o, a, l, c) {
  const p = mc(t), h = br[n], d = K6(n, t);
  n === 7 && (t = {
    ...t,
    weeks: t.weeks + Math.trunc(t.days / 7)
  });
  const v = G2(t[h], i) * i;
  d[h] = v;
  const [m, b] = g6(o, d, n, i * p, a, l, c), f = v + m6(e, m, b) * p * i, E = Kl(f, i, s), A = Math.sign(E - f) === p;
  return d[h] = E, [d, A ? b : m, A];
}
function U9(t, e, r, n) {
  const [i, s, o, a] = ((c) => {
    const p = u6(c = Xo(c));
    return [c.timeZone, ...p];
  })(n), l = i !== void 0;
  return ((c, p, h, d, v, m) => {
    h = rv(h, v, d, 1);
    const b = p.R(h);
    return v6(yd(h, b), m) + (c ? pg(dy(b)) : "Z");
  })(l, e(l ? t(i) : Mh), r.epochNanoseconds, s, o, a);
}
function V9(t, e, r) {
  const [n, i, s, o, a, l] = ((c) => {
    c = Xo(c);
    const p = J6(c), h = mL(c), d = tte(c), v = wg(c, 4), m = bg(c, 4);
    return [p, ete(c), d, v, ...gL(m, h)];
  })(r);
  return ((c, p, h, d, v, m, b, f, E, A) => {
    d = rv(d, E, f, 1);
    const x = c(h).R(d);
    return v6(yd(d, x), A) + pg(dy(x), b) + ((g, w) => w !== 1 ? "[" + (w === 2 ? "!" : "") + g + "]" : "")(h, m) + b6(p, v);
  })(t, e.calendar, e.timeZone, e.epochNanoseconds, n, i, s, o, a, l);
}
function H9(t, e) {
  const [r, n, i, s] = ((c) => (c = Xo(c), [J6(c), ...u6(c)]))(e);
  return o = t.calendar, a = r, l = s, v6(wL(t, i, n), l) + b6(o, a);
  var o, a, l;
}
function G9(t, e) {
  return r = t.calendar, n = t, i = c6(e), fy(n) + b6(r, i);
  var r, n, i;
}
function W9(t, e) {
  return AL(t.calendar, kL, t, c6(e));
}
function q9(t, e) {
  return AL(t.calendar, $J, t, c6(e));
}
function Q9(t, e) {
  const [r, n, i] = fL(e);
  return s = i, _L(y6(t, n, r)[0], s);
  var s;
}
function dw(t, e) {
  const [r, n, i] = fL(e, 3);
  return n > 1 && Oh(t = {
    ...t,
    ...LJ(t, n, r)
  }), ((s, o) => {
    const { sign: a } = s, l = a === -1 ? mi(s) : s, { hours: c, minutes: p } = l, [h, d] = n6(Tn(l, 3), No, ql);
    RL(h);
    const v = w6(d, o), m = o >= 0 || !a || v;
    return (a < 0 ? "-" : "") + "P" + K9({
      Y: bu(l.years),
      M: bu(l.months),
      W: bu(l.weeks),
      D: bu(l.days)
    }) + (c || p || h || m ? "T" + K9({
      H: bu(c),
      M: bu(p),
      S: bu(h, m) + v
    }) : "");
  })(t, i);
}
function AL(t, e, r, n) {
  const i = n > 1 || n === 0 && t !== cr;
  return n === 1 ? t === cr ? e(r) : fy(r) : i ? fy(r) + CL(t, n === 2) : e(r);
}
function K9(t) {
  const e = [];
  for (const r in t) {
    const n = t[r];
    n && e.push(n, r);
  }
  return e.join("");
}
function v6(t, e) {
  return fy(t) + "T" + _L(t, e);
}
function fy(t) {
  return kL(t) + "-" + js(t.isoDay);
}
function kL(t) {
  const { isoYear: e } = t;
  return (e < 0 || e > 9999 ? IL(e) + cy(6, Math.abs(e)) : cy(4, e)) + "-" + js(t.isoMonth);
}
function $J(t) {
  return js(t.isoMonth) + "-" + js(t.isoDay);
}
function _L(t, e) {
  const r = [js(t.isoHour), js(t.isoMinute)];
  return e !== -1 && r.push(js(t.isoSecond) + ((n, i, s, o) => w6(n * Ga + i * yg + s, o))(t.isoMillisecond, t.isoMicrosecond, t.isoNanosecond, e)), r.join(":");
}
function pg(t, e = 0) {
  if (e === 1)
    return "";
  const [r, n] = ba(Math.abs(t), fv), [i, s] = ba(n, dv), [o, a] = ba(s, No);
  return IL(t) + js(r) + ":" + js(i) + (o || a ? ":" + js(o) + w6(a) : "");
}
function b6(t, e) {
  return e !== 1 && (e > 1 || e === 0 && t !== cr) ? CL(t, e === 2) : "";
}
function CL(t, e) {
  return "[" + (e ? "!" : "") + "u-ca=" + t + "]";
}
function w6(t, e) {
  let r = cy(9, t);
  return r = e === void 0 ? r.replace(ste, "") : r.slice(0, e), r ? "." + r : "";
}
function IL(t) {
  return t < 0 ? "-" : "+";
}
function bu(t, e) {
  return t || e ? t.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function jJ(t, e) {
  const { epochNanoseconds: r } = t, n = (e.R ? e : e(t.timeZone)).R(r), i = yd(r, n);
  return {
    calendar: t.calendar,
    ...i,
    offsetNanoseconds: n
  };
}
function wd(t, e, r, n = 0, i = 0, s, o) {
  if (r !== void 0 && n === 1 && (n === 1 || o))
    return s6(e, r);
  const a = t.I(e);
  if (r !== void 0 && n !== 3) {
    const l = ((c, p, h, d) => {
      const v = Pn(p);
      d && (h = dy(h));
      for (const m of c) {
        let b = Fo(Bo(m, v));
        if (d && (b = dy(b)), b === h)
          return m;
      }
    })(a, e, r, s);
    if (l !== void 0)
      return l;
    if (n === 0)
      throw new RangeError(vee);
  }
  return o ? Pn(e) : dg(t, e, i, a);
}
function dg(t, e, r = 0, n = t.I(e)) {
  if (n.length === 1)
    return n[0];
  if (r === 1)
    throw new RangeError(bee);
  if (n.length)
    return n[r === 3 ? 1 : 0];
  const i = Pn(e), s = ((a, l) => {
    const c = a.R(th(l, -864e11));
    return ((p) => {
      if (p > jr)
        throw new RangeError(yee);
      return p;
    })(a.R(th(l, jr)) - c);
  })(t, i), o = s * (r === 2 ? -1 : 1);
  return (n = t.I(yd(i, o)))[r === 2 ? 0 : n.length - 1];
}
function Yl(t, e) {
  const r = t.I(e);
  if (r.length)
    return r[0];
  const n = th(Pn(e), -864e11);
  return t.O(n, 1);
}
function Y9(t, e, r) {
  return Va(Jo(Up(e.epochNanoseconds, ((n) => {
    if (OL(n))
      throw new RangeError(Eee);
    return Tn(n, 5);
  })(t ? mi(r) : r))));
}
function Z9(t, e, r, n, i, s = /* @__PURE__ */ Object.create(null)) {
  const o = e(n.timeZone), a = t(n.calendar);
  return {
    ...n,
    ...x6(o, a, n, r ? mi(i) : i, s)
  };
}
function J9(t, e, r, n, i = /* @__PURE__ */ Object.create(null)) {
  const { calendar: s } = r;
  return eo(E6(t(s), r, e ? mi(n) : n, i), s);
}
function X9(t, e, r, n, i) {
  const { calendar: s } = r;
  return Ha(nv(t(s), r, e ? mi(n) : n, i), s);
}
function e7(t, e, r, n, i) {
  const s = r.calendar, o = t(s);
  let a = $s(f0(o, r));
  e && (n = k6(n)), n.sign < 0 && (a = o.P(a, {
    ...Ln,
    months: 1
  }), a = Rh(a, -1));
  const l = o.P(a, n, i);
  return d0(f0(o, l), s);
}
function t7(t, e, r) {
  return ea(PL(e, t ? mi(r) : r)[0]);
}
function x6(t, e, r, n, i) {
  const s = Tn(n, 5);
  let o = r.epochNanoseconds;
  if (OL(n)) {
    const a = ds(r, t);
    o = Up(dg(t, {
      ...nv(e, a, {
        ...n,
        ...Q6
      }, i),
      ...Js(to, a)
    }), s);
  } else
    o = Up(o, s), fr(i);
  return {
    epochNanoseconds: Jo(o)
  };
}
function E6(t, e, r, n) {
  const [i, s] = PL(e, r);
  return zi({
    ...nv(t, e, {
      ...r,
      ...Q6,
      days: r.days + s
    }, n),
    ...i
  });
}
function nv(t, e, r, n) {
  if (r.years || r.months || r.weeks)
    return t.P(e, r, n);
  fr(n);
  const i = r.days + Tn(r, 5)[0];
  return i ? $s(Rh(e, i)) : e;
}
function f0(t, e, r = 1) {
  return Rh(e, r - t.day(e));
}
function PL(t, e) {
  const [r, n] = Tn(e, 5), [i, s] = q2(Ql(t) + n);
  return [i, r + s];
}
function Rh(t, e) {
  return e ? {
    ...t,
    ...Q2(ai(t) + e * ji)
  } : t;
}
function iv(t, e, r) {
  const n = t(r.calendar);
  return Vp(r) ? [r, n, e(r.timeZone)] : [{
    ...r,
    ...Ui
  }, n];
}
function S6(t) {
  return t ? vL : Pn;
}
function sv(t) {
  return t ? nr(x6, t) : E6;
}
function A6(t) {
  return t ? nr(lX, t) : cX;
}
function Vp(t) {
  return t && t.epochNanoseconds;
}
function g0(t, e) {
  return t <= 6 - (Vp(e) ? 1 : 0);
}
function r7(t, e, r, n, i, s, o) {
  const a = t(Xo(o).relativeTo), l = Math.max(rh(i), rh(s));
  if (g0(l, a))
    return gn(Oh(((b, f, E, A) => {
      const x = Up(Tn(b), Tn(f), A ? -1 : 1);
      if (!Number.isFinite(x[0]))
        throw new RangeError(xc);
      return {
        ...Ln,
        ...xd(x, E)
      };
    })(i, s, l, n)));
  if (!a)
    throw new RangeError(pv);
  n && (s = mi(s));
  const [c, p, h] = iv(e, r, a), d = sv(h), v = A6(h), m = d(p, c, i);
  return gn(v(p, c, d(p, m, s), l));
}
function BJ(t, e, r, n, i) {
  const s = rh(n), [o, a, l, c, p] = ((_, S, R) => {
    _ = J2(_, yy);
    let L = LM(_);
    const F = R(_[OM]);
    let z = h6(_);
    const j = wg(_, 7);
    let W = bg(_);
    if (L === void 0 && W === void 0)
      throw new RangeError(See);
    if (W == null && (W = 0), L == null && (L = Math.max(W, S)), yL(L, W), z = p6(z, W, 1), z > 1 && W > 5 && L !== W)
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    return [L, W, z, j, F];
  })(i, s, t), h = Math.max(s, o);
  if (!p && h <= 6)
    return gn(Oh(((_, S, R, L, F) => {
      const z = tv(Tn(_), R, L, F);
      return {
        ...Ln,
        ...xd(z, S)
      };
    })(n, o, a, l, c)));
  if (!Vp(p) && !n.sign)
    return n;
  if (!p)
    throw new RangeError(pv);
  const [d, v, m] = iv(e, r, p), b = S6(m), f = sv(m), E = A6(m), A = f(v, d, n);
  Vp(p) || (zi(d), zi(A));
  let x = E(v, d, A, o);
  const g = n.sign, w = mc(x);
  if (g && w && g !== w)
    throw new RangeError(Ad);
  return x = ev(x, b(A), o, a, l, c, v, d, b, f), gn(x);
}
function FJ(t) {
  return t.sign === -1 ? k6(t) : t;
}
function k6(t) {
  return gn(mi(t));
}
function mi(t) {
  const e = {};
  for (const r of br)
    e[r] = -1 * t[r] || 0;
  return e;
}
function zJ(t) {
  return !t.sign;
}
function mc(t, e = br) {
  let r = 0;
  for (const n of e) {
    const i = Math.sign(t[n]);
    if (i) {
      if (r && r !== i)
        throw new RangeError(xee);
      r = i;
    }
  }
  return r;
}
function Oh(t) {
  for (const e of Mee)
    Ta(e, t[e], -4294967295, ote, 1);
  return RL(Fo(Tn(t), No)), t;
}
function RL(t) {
  if (!Number.isSafeInteger(t))
    throw new RangeError(wee);
}
function Tn(t, e = 6) {
  return XT(t, e, br);
}
function xd(t, e = 6) {
  const [r, n] = t, i = W2(n, e, br);
  if (i[br[e]] += r * (jr / zo[e]), !Number.isFinite(i[br[e]]))
    throw new RangeError(xc);
  return i;
}
function ov(t, e = 5) {
  return W2(t, e, br);
}
function OL(t) {
  return !!mc(t, CM);
}
function rh(t) {
  let e = 9;
  for (; e > 0 && !t[br[e]]; e--)
    ;
  return e;
}
function UJ(t, e) {
  return [t, e];
}
function n7(t) {
  const e = Math.floor(t / v1) * v1;
  return [e, e + v1];
}
function VJ(t) {
  const e = yc(t = m1(t));
  if (!e)
    throw new RangeError(Mi(t));
  let r;
  if (e.j)
    r = 0;
  else {
    if (!e.offset)
      throw new RangeError(Mi(t));
    r = Th(e.offset);
  }
  return e.timeZone && R6(e.timeZone, 1), Va(s6(K2(e), r));
}
function HJ(t) {
  const e = yc(Jn(t));
  if (!e)
    throw new RangeError(Mi(t));
  if (e.timeZone)
    return TL(e, e.offset ? Th(e.offset) : void 0);
  if (e.j)
    throw new RangeError(Mi(t));
  return ML(e);
}
function GJ(t, e) {
  const r = yc(Jn(t));
  if (!r || !r.timeZone)
    throw new RangeError(Mi(t));
  const { offset: n } = r, i = n ? Th(n) : void 0, [, s, o] = Y2(e);
  return TL(r, i, s, o);
}
function Th(t) {
  const e = R6(t);
  if (e === void 0)
    throw new RangeError(Mi(t));
  return e;
}
function WJ(t) {
  const e = yc(Jn(t));
  if (!e || e.j)
    throw new RangeError(Mi(t));
  return eo(LL(e));
}
function _6(t, e, r) {
  let n = yc(Jn(t));
  if (!n || n.j)
    throw new RangeError(Mi(t));
  return e ? n.calendar === cr && (n = n.isoYear === -271821 && n.isoMonth === 4 ? {
    ...n,
    isoDay: 20,
    ...Ui
  } : {
    ...n,
    isoDay: 1,
    ...Ui
  }) : r && n.calendar === cr && (n = {
    ...n,
    isoYear: xa
  }), Ha(n.C ? LL(n) : ML(n));
}
function qJ(t, e) {
  const r = I6(Jn(e));
  if (r)
    return C6(r), d0(i6(Ph(r)));
  const n = _6(e, 1);
  return d0(f0(t(n.calendar), n));
}
function C6(t) {
  if (t.calendar !== cr)
    throw new RangeError(wa(t.calendar));
}
function QJ(t, e) {
  const r = P6(Jn(e));
  if (r)
    return C6(r), py(Ph(r));
  const n = _6(e, 0, 1), { calendar: i } = n, s = t(i), [o, a, l] = s.v(n), [c, p] = s.q(o, a), [h, d] = s.G(c, p, l);
  return py($s(s.V(h, d, l)), i);
}
function KJ(t) {
  let e, r = ((n) => {
    const i = dte.exec(n);
    return i ? (av(i[10]), $L(i)) : void 0;
  })(Jn(t));
  if (!r) {
    if (r = yc(t), !r)
      throw new RangeError(Mi(t));
    if (!r.C)
      throw new RangeError(Mi(t));
    if (r.j)
      throw new RangeError(wa("Z"));
    C6(r);
  }
  if ((e = I6(t)) && F9(e))
    throw new RangeError(Mi(t));
  if ((e = P6(t)) && F9(e))
    throw new RangeError(Mi(t));
  return ea(vd(r, 1));
}
function YJ(t) {
  const e = ((r) => {
    const n = mte.exec(r);
    return n ? ((i) => {
      function s(p, h, d) {
        let v = 0, m = 0;
        if (d && ([v, l] = ba(l, zo[d])), p !== void 0) {
          if (a)
            throw new RangeError(wa(p));
          m = ((b) => {
            const f = parseInt(b);
            if (!Number.isFinite(f))
              throw new RangeError(wa(b));
            return f;
          })(p), o = 1, h && (l = O6(h) * (zo[d] / No), a = 1);
        }
        return v + m;
      }
      let o = 0, a = 0, l = 0, c = {
        ...gd(br, [s(i[2]), s(i[3]), s(i[4]), s(i[5]), s(i[6], i[7], 5), s(i[8], i[9], 4), s(i[10], i[11], 3)]),
        ...W2(l, 2, br)
      };
      if (!o)
        throw new RangeError(uM(br));
      return T6(i[1]) < 0 && (c = mi(c)), c;
    })(n) : void 0;
  })(Jn(t));
  if (!e)
    throw new RangeError(Mi(t));
  return gn(Oh(e));
}
function ZJ(t) {
  const e = yc(t) || I6(t) || P6(t);
  return e ? e.calendar : t;
}
function JJ(t) {
  const e = yc(t);
  return e && (e.timeZone || e.j && Mh || e.offset) || t;
}
function TL(t, e, r = 0, n = 0) {
  const i = L6(t.timeZone), s = Qt(i);
  let o;
  return K2(t), o = t.C ? wd(s, t, e, r, n, !s.$, t.j) : Yl(s, t), Xs(o, i, hv(t.calendar));
}
function LL(t) {
  return NL(zi(K2(t)));
}
function ML(t) {
  return NL($s(Ph(t)));
}
function NL(t) {
  return {
    ...t,
    calendar: hv(t.calendar)
  };
}
function yc(t) {
  const e = pte.exec(t);
  return e ? ((r) => {
    const n = r[10], i = (n || "").toUpperCase() === "Z";
    return {
      isoYear: DL(r),
      isoMonth: parseInt(r[4]),
      isoDay: parseInt(r[5]),
      ...$L(r.slice(5)),
      ...av(r[16]),
      C: !!r[6],
      j: i,
      offset: i ? void 0 : n
    };
  })(e) : void 0;
}
function I6(t) {
  const e = ute.exec(t);
  return e ? ((r) => ({
    isoYear: DL(r),
    isoMonth: parseInt(r[4]),
    isoDay: 1,
    ...av(r[5])
  }))(e) : void 0;
}
function P6(t) {
  const e = hte.exec(t);
  return e ? ((r) => ({
    isoYear: xa,
    isoMonth: parseInt(r[1]),
    isoDay: parseInt(r[2]),
    ...av(r[3])
  }))(e) : void 0;
}
function R6(t, e) {
  const r = fte.exec(t);
  return r ? ((n, i) => {
    const s = n[4] || n[5];
    if (i && s)
      throw new RangeError(wa(s));
    return ((o) => {
      if (Math.abs(o) >= jr)
        throw new RangeError(mee);
      return o;
    })((Tp(n[2]) * fv + Tp(n[3]) * dv + Tp(n[4]) * No + O6(n[5] || "")) * T6(n[1]));
  })(r, e) : void 0;
}
function DL(t) {
  const e = T6(t[1]), r = parseInt(t[2] || t[3]);
  if (e < 0 && !r)
    throw new RangeError(wa(-0));
  return e * r;
}
function $L(t) {
  const e = Tp(t[3]);
  return {
    ...q2(O6(t[4] || ""))[0],
    isoHour: Tp(t[1]),
    isoMinute: Tp(t[2]),
    isoSecond: e === 60 ? 59 : e
  };
}
function av(t) {
  let e, r;
  const n = [];
  if (t.replace(gte, (i, s, o) => {
    const a = !!s, [l, c] = o.split("=").reverse();
    if (c) {
      if (c === "u-ca")
        n.push(l), e || (e = a);
      else if (a || /[A-Z]/.test(c))
        throw new RangeError(wa(i));
    } else {
      if (r)
        throw new RangeError(wa(i));
      r = l;
    }
    return "";
  }), n.length > 1 && e)
    throw new RangeError(wa(t));
  return {
    timeZone: r,
    calendar: n[0] || cr
  };
}
function O6(t) {
  return parseInt(t.padEnd(9, "0"));
}
function Ed(t) {
  return new RegExp(`^${t}$`, "i");
}
function T6(t) {
  return t && t !== "+" ? -1 : 1;
}
function Tp(t) {
  return t === void 0 ? 0 : parseInt(t);
}
function XJ(t) {
  return L6(Jn(t));
}
function L6(t) {
  const e = M6(t);
  return typeof e == "number" ? pg(e) : e ? ((r) => {
    if (bte.test(r))
      throw new RangeError(gM(r));
    if (vte.test(r))
      throw new RangeError(gee);
    return r.toLowerCase().split("/").map((n, i) => (n.length <= 3 || /\d/.test(n)) && !/etc|yap/.test(n) ? n.toUpperCase() : n.replace(/baja|dumont|[a-z]+/g, (s, o) => s.length <= 2 && !i || s === "in" || s === "chat" ? s.toUpperCase() : s.length > 2 || !o ? $9(s).replace(/island|noronha|murdo|rivadavia|urville/, $9) : s)).join("/");
  })(t) : Mh;
}
function i7(t) {
  const e = M6(t);
  return typeof e == "number" ? e : e ? e.resolvedOptions().timeZone : Mh;
}
function M6(t) {
  const e = R6(t = t.toUpperCase(), 1);
  return e !== void 0 ? e : t !== Mh ? yte(t) : void 0;
}
function jL(t, e) {
  return hs(t.epochNanoseconds, e.epochNanoseconds);
}
function BL(t, e) {
  return hs(t.epochNanoseconds, e.epochNanoseconds);
}
function eX(t, e, r, n, i, s) {
  const o = t(Xo(s).relativeTo), a = Math.max(rh(n), rh(i));
  if (ZT(br, n, i))
    return 0;
  if (g0(a, o))
    return hs(Tn(n), Tn(i));
  if (!o)
    throw new RangeError(pv);
  const [l, c, p] = iv(e, r, o), h = S6(p), d = sv(p);
  return hs(h(d(c, l, n)), h(d(c, l, i)));
}
function FL(t, e) {
  return Sd(t, e) || N6(t, e);
}
function Sd(t, e) {
  return Dl(ai(t), ai(e));
}
function N6(t, e) {
  return Dl(Ql(t), Ql(e));
}
function tX(t, e) {
  return !jL(t, e);
}
function rX(t, e) {
  return !BL(t, e) && !!zL(t.timeZone, e.timeZone) && t.calendar === e.calendar;
}
function nX(t, e) {
  return !FL(t, e) && t.calendar === e.calendar;
}
function iX(t, e) {
  return !Sd(t, e) && t.calendar === e.calendar;
}
function sX(t, e) {
  return !Sd(t, e) && t.calendar === e.calendar;
}
function oX(t, e) {
  return !Sd(t, e) && t.calendar === e.calendar;
}
function aX(t, e) {
  return !N6(t, e);
}
function zL(t, e) {
  if (t === e)
    return 1;
  try {
    return i7(t) === i7(e);
  } catch {
  }
}
function s7(t, e, r, n) {
  const i = bd(t, n, 3, 5), s = lv(e.epochNanoseconds, r.epochNanoseconds, ...i);
  return gn(t ? mi(s) : s);
}
function o7(t, e, r, n, i, s) {
  const o = uv(n.calendar, i.calendar), [a, l, c, p] = bd(r, s, 5), h = n.epochNanoseconds, d = i.epochNanoseconds, v = hs(d, h);
  let m;
  if (v)
    if (a < 6)
      m = lv(h, d, a, l, c, p);
    else {
      const b = e(((E, A) => {
        if (!zL(E, A))
          throw new RangeError(mM);
        return E;
      })(n.timeZone, i.timeZone)), f = t(o);
      m = VL(f, b, n, i, v, a, s), m = ev(m, d, a, l, c, p, f, n, vL, nr(x6, b));
    }
  else
    m = Ln;
  return gn(r ? mi(m) : m);
}
function a7(t, e, r, n, i) {
  const s = uv(r.calendar, n.calendar), [o, a, l, c] = bd(e, i, 6), p = Pn(r), h = Pn(n), d = hs(h, p);
  let v;
  if (d)
    if (o <= 6)
      v = lv(p, h, o, a, l, c);
    else {
      const m = t(s);
      v = HL(m, r, n, d, o, i), v = ev(v, h, o, a, l, c, m, r, Pn, E6);
    }
  else
    v = Ln;
  return gn(e ? mi(v) : v);
}
function l7(t, e, r, n, i) {
  const s = uv(r.calendar, n.calendar);
  return UL(e, () => t(s), r, n, ...bd(e, i, 6, 9, 6));
}
function c7(t, e, r, n, i) {
  const s = uv(r.calendar, n.calendar), o = bd(e, i, 9, 9, 8), a = t(s), l = f0(a, r), c = f0(a, n);
  return l.isoYear === c.isoYear && l.isoMonth === c.isoMonth && l.isoDay === c.isoDay ? gn(Ln) : UL(e, () => a, $s(l), $s(c), ...o, 8);
}
function UL(t, e, r, n, i, s, o, a, l = 6) {
  const c = Pn(r), p = Pn(n);
  if (c === void 0 || p === void 0)
    throw new RangeError(xc);
  let h;
  if (hs(p, c))
    if (i === 6)
      h = lv(c, p, i, s, o, a);
    else {
      const d = e();
      h = d.N(r, n, i), s === l && o === 1 || (h = ev(h, p, i, s, o, a, d, r, Pn, nv));
    }
  else
    h = Ln;
  return gn(t ? mi(h) : h);
}
function u7(t, e, r, n) {
  const [i, s, o, a] = bd(t, n, 5, 5), l = Kl(D6(e, r), hg(s, o), a), c = {
    ...Ln,
    ...ov(l, i)
  };
  return gn(t ? mi(c) : c);
}
function lX(t, e, r, n, i, s) {
  const o = hs(n.epochNanoseconds, r.epochNanoseconds);
  return o ? i < 6 ? GL(r.epochNanoseconds, n.epochNanoseconds, i) : VL(e, t, r, n, o, i, s) : Ln;
}
function cX(t, e, r, n, i) {
  const s = Pn(e), o = Pn(r), a = hs(o, s);
  return a ? n <= 6 ? GL(s, o, n) : HL(t, e, r, a, n, i) : Ln;
}
function VL(t, e, r, n, i, s, o) {
  const [a, l, c] = ((d, v, m, b) => {
    function f() {
      return S = {
        ...Rh(x, w++ * -b),
        ...A
      }, R = dg(d, S), hs(g, R) === -b;
    }
    const E = ds(v, d), A = Js(to, E), x = ds(m, d), g = m.epochNanoseconds;
    let w = 0;
    const _ = D6(E, x);
    let S, R;
    if (Math.sign(_) === -b && w++, f() && (b === -1 || f()))
      throw new RangeError(Ad);
    const L = Fo(Bo(R, g));
    return [E, S, L];
  })(e, r, n, i);
  var p, h;
  return {
    ...s === 6 ? (p = a, h = l, {
      ...Ln,
      days: WL(p, h)
    }) : t.N(a, l, s, o),
    ...ov(c)
  };
}
function HL(t, e, r, n, i, s) {
  const [o, a, l] = ((c, p, h) => {
    let d = p, v = D6(c, p);
    return Math.sign(v) === -h && (d = Rh(p, -h), v += jr * h), [c, d, v];
  })(e, r, n);
  return {
    ...t.N(o, a, i, s),
    ...ov(l)
  };
}
function lv(t, e, r, n, i, s) {
  return {
    ...Ln,
    ...xd(tv(Bo(t, e), n, i, s), r)
  };
}
function GL(t, e, r) {
  return {
    ...Ln,
    ...xd(Bo(t, e), r)
  };
}
function WL(t, e) {
  return cv(ai(t), ai(e));
}
function cv(t, e) {
  return Math.trunc((e - t) / ji);
}
function D6(t, e) {
  return Ql(e) - Ql(t);
}
function uv(t, e) {
  if (t !== e)
    throw new RangeError(fM);
  return t;
}
function qL(t) {
  return this.m(t)[0];
}
function QL(t) {
  return this.m(t)[1];
}
function $6(t) {
  const [e] = this.v(t);
  return cv(this.p(e), ai(t)) + 1;
}
function j6(t) {
  const e = wte.exec(t);
  if (!e)
    throw new RangeError(dee(t));
  return [parseInt(e[1]), !!e[2]];
}
function fg(t, e) {
  return "M" + js(t) + (e ? "L" : "");
}
function gy(t, e, r) {
  return t + (e || r && t >= r ? 1 : 0);
}
function B6(t, e) {
  return t - (e && t >= e ? 1 : 0);
}
function KL(t, e) {
  return (e + t) * (Math.sign(e) || 1) || 0;
}
function Ax(t) {
  return kM[ZL(t)];
}
function YL(t) {
  return Ree[ZL(t)];
}
function ZL(t) {
  return nh(t.id || cr);
}
function uX(t) {
  function e(i) {
    return ((s, o) => ({
      ...JL(s, o),
      o: s.month,
      day: parseInt(s.day)
    }))(o6(r, i), n);
  }
  const r = a5(t), n = nh(t);
  return {
    id: t,
    h: hX(e),
    l: pX(e)
  };
}
function hX(t) {
  return us((e) => {
    const r = ai(e);
    return t(r);
  }, WeakMap);
}
function pX(t) {
  const e = t(0).year - zee;
  return us((r) => {
    let n, i = md(r - e), s = 0;
    const o = [], a = [];
    do
      i += 400 * ji;
    while ((n = t(i)).year <= r);
    do
      if (i += (1 - n.day) * ji, n.year === r && (o.push(i), a.push(n.o)), i -= ji, ++s > 100 || i < -864e13)
        throw new RangeError(Ad);
    while ((n = t(i)).year >= r);
    return {
      i: o.reverse(),
      u: yM(a.reverse())
    };
  });
}
function JL(t, e) {
  let r, n, i = XL(t);
  if (t.era) {
    const s = kM[e], o = _M[e] || {};
    s !== void 0 && (r = e === "islamic" ? "ah" : t.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), r === "bc" || r === "b" ? r = "bce" : r === "ad" || r === "a" ? r = "ce" : r === "beforeroc" && (r = "broc"), r = o[r] || r, n = i, i = KL(n, s[r] || 0));
  }
  return {
    era: r,
    eraYear: n,
    year: i
  };
}
function XL(t) {
  return parseInt(t.relatedYear || t.year);
}
function my(t) {
  const { year: e, o: r, day: n } = this.h(t), { u: i } = this.l(e);
  return [e, i[r] + 1, n];
}
function m0(t, e = 1, r = 1) {
  return this.l(t).i[e - 1] + (r - 1) * ji;
}
function eM(t, e) {
  const r = y1.call(this, t);
  return [B6(e, r), r === e];
}
function y1(t) {
  const e = p7(this, t), r = p7(this, t - 1), n = e.length;
  if (n > r.length) {
    const i = YL(this);
    if (i < 0)
      return -i;
    for (let s = 0; s < n; s++)
      if (e[s] !== r[s])
        return s + 1;
  }
}
function Tm(t) {
  return cv(m0.call(this, t), m0.call(this, t + 1));
}
function h7(t, e) {
  const { i: r } = this.l(t);
  let n = e + 1, i = r;
  return n > r.length && (n = 1, i = this.l(t + 1).i), cv(r[e - 1], i[n - 1]);
}
function Lm(t) {
  return this.l(t).i.length;
}
function tM(t) {
  const e = this.h(t);
  return [e.era, e.eraYear];
}
function p7(t, e) {
  return Object.keys(t.l(e).u);
}
function gg(t) {
  return hv(Jn(t));
}
function hv(t) {
  if ((t = t.toLowerCase()) !== cr && t !== kd) {
    const e = a5(t).resolvedOptions().calendar;
    if (nh(t) !== nh(e))
      throw new RangeError(dM(t));
    return e;
  }
  return t;
}
function nh(t) {
  return t === "islamicc" && (t = "islamic"), t.split("-")[0];
}
function rM(t, e) {
  return (r) => r === cr ? t : r === kd || r === Zl ? Object.assign(Object.create(t), {
    id: r
  }) : Object.assign(Object.create(e), xte(r));
}
function dX(t, e, r, n) {
  const i = vc(r, n, qa, [], xM);
  if (i.timeZone !== void 0) {
    const s = r.F(i), o = mg(i), a = t(i.timeZone);
    return {
      epochNanoseconds: wd(e(a), {
        ...s,
        ...o
      }, i.offset !== void 0 ? Th(i.offset) : void 0),
      timeZone: a
    };
  }
  return {
    ...r.F(i),
    ...Ui
  };
}
function fX(t, e, r, n, i, s) {
  const o = vc(r, i, qa, bM, xM), a = t(o.timeZone), [l, c, p] = Y2(s), h = r.F(o, X2(l)), d = mg(o, l);
  return Xs(wd(e(a), {
    ...h,
    ...d
  }, o.offset !== void 0 ? Th(o.offset) : void 0, c, p), a, n);
}
function gX(t, e, r) {
  const n = vc(t, e, qa, [], Wa), i = fr(r);
  return eo(zi({
    ...t.F(n, X2(i)),
    ...mg(n, i)
  }));
}
function mX(t, e, r, n = []) {
  const i = vc(t, e, qa, n);
  return t.F(i, r);
}
function yX(t, e, r, n) {
  const i = vc(t, e, W6, n);
  return t.K(i, r);
}
function vX(t, e, r, n) {
  const i = vc(t, r, qa, vg);
  return e && i.month !== void 0 && i.monthCode === void 0 && i.year === void 0 && (i.year = xa), t._(i, n);
}
function bX(t, e) {
  return ea(mg(ps(t, Ix, [], 1), fr(e)));
}
function wX(t) {
  const e = ps(t, q6);
  return gn(Oh({
    ...Ln,
    ...e
  }));
}
function vc(t, e, r, n = [], i = []) {
  return ps(e, [...t.fields(r), ...i].sort(), n);
}
function ps(t, e, r, n = !r) {
  const i = {};
  let s, o = 0;
  for (const a of e) {
    if (a === s)
      throw new RangeError(see(a));
    if (a === "constructor" || a === "__proto__")
      throw new RangeError(iee(a));
    let l = t[a];
    if (l !== void 0)
      o = 1, d7[a] && (l = d7[a](l, a)), i[a] = l;
    else if (r) {
      if (r.includes(a))
        throw new TypeError(z6(a));
      i[a] = AM[a];
    }
    s = a;
  }
  if (n && !o)
    throw new TypeError(uM(e));
  return i;
}
function mg(t, e) {
  return vd(l5({
    ...AM,
    ...t
  }), e);
}
function xX(t, e, r, n, i) {
  const { calendar: s, timeZone: o } = r, a = t(s), l = e(o), c = [...a.fields(qa), ...wM].sort(), p = ((E) => {
    const A = ds(E, Qt), x = pg(A.offsetNanoseconds), g = yv(E.calendar), [w, _, S] = g.v(A), [R, L] = g.q(w, _), F = fg(R, L);
    return {
      ...Pte(A),
      year: w,
      monthCode: F,
      day: S,
      offset: x
    };
  })(r), h = ps(n, c), d = a.k(p, h), v = {
    ...p,
    ...h
  }, [m, b, f] = Y2(i, 2);
  return Xs(wd(l, {
    ...a.F(d, X2(m)),
    ...vd(l5(v), m)
  }, Th(v.offset), b, f), o, s);
}
function EX(t, e, r, n) {
  const i = t(e.calendar), s = [...i.fields(qa), ...Wa].sort(), o = {
    ...iM(a = e),
    hour: a.isoHour,
    minute: a.isoMinute,
    second: a.isoSecond,
    millisecond: a.isoMillisecond,
    microsecond: a.isoMicrosecond,
    nanosecond: a.isoNanosecond
  };
  var a;
  const l = ps(r, s), c = fr(n), p = i.k(o, l), h = {
    ...o,
    ...l
  };
  return eo(zi({
    ...i.F(p, X2(c)),
    ...vd(l5(h), c)
  }));
}
function SX(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(qa).sort(), o = iM(e), a = ps(r, s), l = i.k(o, a);
  return i.F(l, n);
}
function AX(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(W6).sort(), o = ((c) => {
    const p = yv(c.calendar), [h, d] = p.v(c), [v, m] = p.q(h, d);
    return {
      year: h,
      monthCode: fg(v, m)
    };
  })(e), a = ps(r, s), l = i.k(o, a);
  return i.K(l, n);
}
function kX(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(qa).sort(), o = ((c) => {
    const p = yv(c.calendar), [h, d, v] = p.v(c), [m, b] = p.q(h, d);
    return {
      monthCode: fg(m, b),
      day: v
    };
  })(e), a = ps(r, s), l = i.k(o, a);
  return i._(l, n);
}
function _X(t, e, r) {
  return ea(((n, i, s) => mg({
    ...Js(Ix, n),
    ...ps(i, Ix)
  }, fr(s)))(t, e, r));
}
function CX(t, e) {
  return gn((r = t, n = e, Oh({
    ...r,
    ...ps(n, q6)
  })));
  var r, n;
}
function nM(t, e, r, n, i) {
  e = Js(r = t.fields(r), e), n = ps(n, i = t.fields(i), []);
  let s = t.k(e, n);
  return s = ps(s, [...r, ...i].sort(), []), t.F(s);
}
function fw(t, e) {
  const r = Ax(t), n = _M[t.id || ""] || {};
  let { era: i, eraYear: s, year: o } = e;
  if (i !== void 0 || s !== void 0) {
    if (i === void 0 || s === void 0)
      throw new TypeError(cee);
    if (!r)
      throw new RangeError(lee);
    const a = r[n[i] || i];
    if (a === void 0)
      throw new RangeError(hee(i));
    const l = KL(s, a);
    if (o !== void 0 && o !== l)
      throw new RangeError(uee);
    o = l;
  } else if (o === void 0)
    throw new TypeError(pee(r));
  return o;
}
function Mm(t, e, r, n) {
  let { month: i, monthCode: s } = e;
  if (s !== void 0) {
    const o = ((a, l, c, p) => {
      const h = a.L(c), [d, v] = j6(l);
      let m = gy(d, v, h);
      if (v) {
        const b = YL(a);
        if (b === void 0)
          throw new RangeError(yf);
        if (b > 0) {
          if (m > b)
            throw new RangeError(yf);
          if (h === void 0) {
            if (p === 1)
              throw new RangeError(yf);
            m--;
          }
        } else {
          if (m !== -b)
            throw new RangeError(yf);
          if (h === void 0 && p === 1)
            throw new RangeError(yf);
        }
      }
      return m;
    })(t, s, r, n);
    if (i !== void 0 && i !== o)
      throw new RangeError(fee);
    i = o, n = 1;
  } else if (i === void 0)
    throw new TypeError(pM);
  return Ta("month", i, 1, t.B(r), n);
}
function gw(t, e, r, n, i) {
  return Oi(e, "day", 1, t.U(n, r), i);
}
function mw(t, e, r, n) {
  let i = 0;
  const s = [];
  for (const o of r)
    e[o] !== void 0 ? i = 1 : s.push(o);
  if (Object.assign(t, e), i)
    for (const o of n || s)
      delete t[o];
}
function iM(t) {
  const e = yv(t.calendar), [r, n, i] = e.v(t), [s, o] = e.q(r, n);
  return {
    year: r,
    monthCode: fg(s, o),
    day: i
  };
}
function IX(t) {
  return Va(Jo(r6(XE(t))));
}
function PX(t, e, r, n, i = cr) {
  return Xs(Jo(r6(XE(r))), e(n), t(i));
}
function RX(t, e, r, n, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, p = cr) {
  return eo(zi(K2(La(ii, gd(gv, [e, r, n, i, s, o, a, l, c])))), t(p));
}
function OX(t, e, r, n, i = cr) {
  return Ha($s(Ph(La(ii, {
    isoYear: e,
    isoMonth: r,
    isoDay: n
  }))), t(i));
}
function TX(t, e, r, n = cr, i = 1) {
  const s = ii(e), o = ii(r), a = t(n);
  return d0(i6(Ph({
    isoYear: s,
    isoMonth: o,
    isoDay: ii(i)
  })), a);
}
function LX(t, e, r, n = cr, i = xa) {
  const s = ii(e), o = ii(r), a = t(n);
  return py($s(Ph({
    isoYear: ii(i),
    isoMonth: s,
    isoDay: o
  })), a);
}
function MX(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0) {
  return ea(vd(La(ii, gd(to, [t, e, r, n, i, s])), 1));
}
function NX(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0) {
  return gn(Oh(La(e6, gd(br, [t, e, r, n, i, s, o, a, l, c]))));
}
function DX(t, e, r = cr) {
  return Xs(t.epochNanoseconds, e, r);
}
function $X(t) {
  return Va(t.epochNanoseconds);
}
function sM(t, e) {
  return eo(ds(e, t));
}
function oM(t, e) {
  return Ha(ds(e, t));
}
function aM(t, e) {
  return ea(ds(e, t));
}
function jX(t, e, r, n) {
  const i = ((s, o, a, l) => {
    const c = ((p) => NM(Xo(p)))(l);
    return dg(s(o), a, c);
  })(t, r, e, n);
  return Xs(Jo(i), r, e.calendar);
}
function BX(t, e, r, n, i) {
  const s = t(i.timeZone), o = i.plainTime, a = o !== void 0 ? e(o) : void 0, l = r(s);
  let c;
  return c = a ? dg(l, {
    ...n,
    ...a
  }) : Yl(l, {
    ...n,
    ...Ui
  }), Xs(c, s, n.calendar);
}
function FX(t, e = Ui) {
  return eo(zi({
    ...t,
    ...e
  }));
}
function zX(t, e, r) {
  return ((n, i) => {
    const s = vc(n, i, EM);
    return n.K(s, void 0);
  })(t(e.calendar), r);
}
function UX(t, e, r) {
  return ((n, i) => {
    const s = vc(n, i, SM);
    return n._(s);
  })(t(e.calendar), r);
}
function VX(t, e, r, n) {
  return ((i, s, o) => nM(i, s, EM, ug(o), vg))(t(e.calendar), r, n);
}
function HX(t, e, r, n) {
  return ((i, s, o) => nM(i, s, SM, ug(o), V6))(t(e.calendar), r, n);
}
function GX(t) {
  return Va(Jo(uy(e6(t), Ga)));
}
function WX(t) {
  return Va(Jo(r6(XE(t))));
}
function Lh(t, e, r) {
  const n = new Set(r);
  return (i, s) => {
    const o = r && D9(i, r);
    if (!D9(i = ((a, l) => {
      const c = {};
      for (const p in l)
        a.has(p) || (c[p] = l[p]);
      return c;
    })(n, i), t)) {
      if (s && o)
        throw new TypeError("Invalid formatting options");
      i = {
        ...e,
        ...i
      };
    }
    return r && (i.timeZone = Mh, ["full", "long"].includes(i.J) && (i.J = "medium")), i;
  };
}
function bc(t, e = lM, r = 0) {
  const [n, , , i] = t;
  return (s, o = Qte, ...a) => {
    const l = e(i && i(...a), s, o, n, r), c = l.resolvedOptions();
    return [l, ...qX(t, c, a)];
  };
}
function lM(t, e, r, n, i) {
  if (r = n(r, i), t) {
    if (r.timeZone !== void 0)
      throw new TypeError(_ee);
    r.timeZone = t;
  }
  return new $l(e, r);
}
function qX(t, e, r) {
  const [, n, i] = t;
  return r.map((s) => (s.calendar && ((o, a, l) => {
    if ((l || o !== cr) && o !== a)
      throw new RangeError(fM);
  })(s.calendar, e.calendar, i), n(s, e)));
}
function QX(t, e, r) {
  const n = e.timeZone, i = t(n), s = {
    ...ds(e, i),
    ...r || Ui
  };
  let o;
  return o = r ? wd(i, s, s.offsetNanoseconds, 2) : Yl(i, s), Xs(o, n, e.calendar);
}
function KX(t, e = Ui) {
  return eo(zi({
    ...t,
    ...e
  }));
}
function F6(t, e) {
  return {
    ...t,
    calendar: e
  };
}
function YX(t, e) {
  return {
    ...t,
    timeZone: e
  };
}
function yw(t) {
  const e = kx();
  return yd(e, t.R(e));
}
function kx() {
  return uy(Date.now(), Ga);
}
function mf() {
  return f7 || (f7 = new $l().resolvedOptions().timeZone);
}
const ZX = (t, e) => `Non-integer ${t}: ${e}`, JX = (t, e) => `Non-positive ${t}: ${e}`, XX = (t, e) => `Non-finite ${t}: ${e}`, eee = (t) => `Cannot convert bigint to ${t}`, tee = (t) => `Invalid bigint: ${t}`, ree = "Cannot convert Symbol to string", nee = "Invalid object", cM = (t, e, r, n, i) => i ? cM(t, i[e], i[r], i[n]) : wc(t, e) + `; must be between ${r}-${n}`, wc = (t, e) => `Invalid ${t}: ${e}`, z6 = (t) => `Missing ${t}`, iee = (t) => `Invalid field ${t}`, see = (t) => `Duplicate field ${t}`, uM = (t) => "No valid fields: " + t.join(), oee = "Invalid bag", hM = (t, e, r) => wc(t, e) + "; must be " + Object.keys(r).join(), aee = "Cannot use valueOf", _x = "Invalid calling context", lee = "Forbidden era/eraYear", cee = "Mismatching era/eraYear", uee = "Mismatching year/eraYear", hee = (t) => `Invalid era: ${t}`, pee = (t) => "Missing year" + (t ? "/era/eraYear" : ""), dee = (t) => `Invalid monthCode: ${t}`, fee = "Mismatching month/monthCode", pM = "Missing month/monthCode", yf = "Invalid leap month", Ad = "Invalid protocol results", dM = (t) => wc("Calendar", t), fM = "Mismatching Calendars", gM = (t) => wc("TimeZone", t), mM = "Mismatching TimeZones", gee = "Forbidden ICU TimeZone", mee = "Out-of-bounds offset", yee = "Out-of-bounds TimeZone gap", vee = "Invalid TimeZone offset", bee = "Ambiguous offset", xc = "Out-of-bounds date", wee = "Out-of-bounds duration", xee = "Cannot mix duration signs", pv = "Missing relativeTo", Eee = "Cannot use large units", See = "Required smallestUnit or largestUnit", Aee = "smallestUnit > largestUnit", Mi = (t) => `Cannot parse: ${t}`, wa = (t) => `Invalid substring: ${t}`, kee = (t) => `Cannot format ${t}`, vw = "Mismatching types for formatting", _ee = "Cannot specify TimeZone", yM = /* @__PURE__ */ nr(H2, (t, e) => e), Hp = /* @__PURE__ */ nr(H2, (t, e, r) => r), js = /* @__PURE__ */ nr(cy, 2), Cx = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, U6 = /* @__PURE__ */ Object.keys(Cx), ji = 864e5, vM = 1e3, yg = 1e3, Ga = 1e6, No = 1e9, dv = 6e10, fv = 36e11, jr = 864e11, zo = [1, yg, Ga, No, dv, fv, jr], Wa = /* @__PURE__ */ U6.slice(0, 6), Ix = /* @__PURE__ */ cg(Wa), Cee = ["offset"], bM = ["timeZone"], wM = /* @__PURE__ */ Wa.concat(Cee), xM = /* @__PURE__ */ wM.concat(bM), Px = ["era", "eraYear"], Iee = /* @__PURE__ */ Px.concat(["year"]), V6 = ["year"], H6 = ["monthCode"], G6 = /* @__PURE__ */ ["month"].concat(H6), vg = ["day"], W6 = /* @__PURE__ */ G6.concat(V6), EM = /* @__PURE__ */ H6.concat(V6), qa = /* @__PURE__ */ vg.concat(W6), Pee = /* @__PURE__ */ vg.concat(G6), SM = /* @__PURE__ */ vg.concat(H6), AM = /* @__PURE__ */ Hp(Wa, 0), cr = "iso8601", kd = "gregory", Zl = "japanese", kM = {
  [kd]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [Zl]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, _M = {
  [kd]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [Zl]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
}, Ree = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, Jn = /* @__PURE__ */ nr(ZE, "string"), Oee = /* @__PURE__ */ nr(ZE, "boolean"), Tee = /* @__PURE__ */ nr(ZE, "number"), br = /* @__PURE__ */ U6.map((t) => t + "s"), q6 = /* @__PURE__ */ cg(br), Lee = /* @__PURE__ */ br.slice(0, 6), CM = /* @__PURE__ */ br.slice(6), Mee = /* @__PURE__ */ CM.slice(1), Nee = /* @__PURE__ */ yM(br), Ln = /* @__PURE__ */ Hp(br, 0), Q6 = /* @__PURE__ */ Hp(Lee, 0), K6 = /* @__PURE__ */ nr(JT, br), to = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"], Y6 = ["isoDay", "isoMonth", "isoYear"], gv = /* @__PURE__ */ to.concat(Y6), Z6 = /* @__PURE__ */ cg(Y6), IM = /* @__PURE__ */ cg(to), Dee = /* @__PURE__ */ cg(gv), Ui = /* @__PURE__ */ Hp(IM, 0), $ee = /* @__PURE__ */ nr(JT, gv), PM = 1e8, jee = PM * ji, Bee = [PM, 0], Fee = [-1e8, 0], y0 = 275760, v0 = -271821, $l = Intl.DateTimeFormat, RM = "en-GB", zee = 1970, xa = 1972, hl = 12, Uee = /* @__PURE__ */ md(1868, 9, 8), Vee = /* @__PURE__ */ us(SJ, WeakMap), yy = "smallestUnit", Rx = "unit", Gf = "roundingIncrement", bw = "fractionalSecondDigits", OM = "relativeTo", ww = "direction", TM = {
  constrain: 0,
  reject: 1
}, Hee = /* @__PURE__ */ Object.keys(TM), Gee = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}, Wee = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}, qee = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}, Qee = {
  auto: 0,
  never: 1,
  critical: 2
}, Kee = {
  auto: 0,
  never: 1
}, Yee = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}, Zee = {
  previous: -1,
  next: 1
}, bg = /* @__PURE__ */ nr(d6, yy), LM = /* @__PURE__ */ nr(d6, "largestUnit"), Jee = /* @__PURE__ */ nr(d6, Rx), MM = /* @__PURE__ */ nr(gc, "overflow", TM), NM = /* @__PURE__ */ nr(gc, "disambiguation", Gee), Xee = /* @__PURE__ */ nr(gc, "offset", Wee), J6 = /* @__PURE__ */ nr(gc, "calendarName", qee), ete = /* @__PURE__ */ nr(gc, "timeZoneName", Qee), tte = /* @__PURE__ */ nr(gc, "offset", Kee), wg = /* @__PURE__ */ nr(gc, "roundingMode", Yee), X6 = "PlainYearMonth", e5 = "PlainMonthDay", xg = "PlainDate", _d = "PlainDateTime", t5 = "PlainTime", Ec = "ZonedDateTime", r5 = "Instant", n5 = "Duration", rte = [Math.floor, (t) => Om(t) ? Math.floor(t) : Math.round(t), Math.ceil, (t) => Om(t) ? Math.ceil(t) : Math.round(t), Math.trunc, (t) => Om(t) ? Math.trunc(t) || 0 : Math.round(t), (t) => t < 0 ? Math.floor(t) : Math.ceil(t), (t) => Math.sign(t) * Math.round(Math.abs(t)) || 0, (t) => Om(t) ? (t = Math.trunc(t) || 0) + t % 2 : Math.round(t)], Mh = "UTC", v1 = 5184e3, nte = /* @__PURE__ */ hy(1847), ite = /* @__PURE__ */ hy(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10), ste = /0+$/, ds = /* @__PURE__ */ us(jJ, WeakMap), ote = 2 ** 32 - 1, Qt = /* @__PURE__ */ us((t) => {
  const e = M6(t);
  return typeof e == "object" ? new lte(e) : new ate(e || 0);
});
class ate {
  constructor(e) {
    this.$ = e;
  }
  R() {
    return this.$;
  }
  I(e) {
    return ((r) => {
      const n = Pn({
        ...r,
        ...Ui
      });
      if (!n || Math.abs(n[0]) > 1e8)
        throw new RangeError(xc);
    })(e), [s6(e, this.$)];
  }
  O() {
  }
}
class lte {
  constructor(e) {
    this.nn = ((r) => {
      function n(c) {
        const p = p0(c, a, l), [h, d] = n7(p), v = s(h), m = s(d);
        return v === m ? v : i(o(h, d), v, m, c);
      }
      function i(c, p, h, d) {
        let v, m;
        for (; (d === void 0 || (v = d < c[0] ? p : d >= c[1] ? h : void 0) === void 0) && (m = c[1] - c[0]); ) {
          const b = c[0] + Math.floor(m / 2);
          r(b) === h ? c[1] = b : c[0] = b + 1;
        }
        return v;
      }
      const s = us(r), o = us(UJ);
      let a = nte, l = ite;
      return {
        tn(c) {
          const p = n(c - 86400), h = n(c + 86400), d = c - p, v = c - h;
          if (p === h)
            return [d];
          const m = n(d);
          return m === n(v) ? [c - m] : p > h ? [d, v] : [];
        },
        rn: n,
        O(c, p) {
          const h = p0(c, a, l);
          let [d, v] = n7(h);
          const m = v1 * p, b = p < 0 ? () => v > a || (a = h, 0) : () => d < l || (l = h, 0);
          for (; b(); ) {
            const f = s(d), E = s(v);
            if (f !== E) {
              const A = o(d, v);
              i(A, f, E);
              const x = A[0];
              if ((Dl(x, c) || 1) === p)
                return x;
            }
            d += m, v += m;
          }
        }
      };
    })(/* @__PURE__ */ ((r) => (n) => {
      const i = o6(r, n * vM);
      return hy(XL(i), parseInt(i.month), parseInt(i.day), parseInt(i.hour), parseInt(i.minute), parseInt(i.second)) - n;
    })(e));
  }
  R(e) {
    return this.nn.rn(((r) => B9(r)[0])(e)) * No;
  }
  I(e) {
    const [r, n] = [hy((i = e).isoYear, i.isoMonth, i.isoDay, i.isoHour, i.isoMinute, i.isoSecond), i.isoMillisecond * Ga + i.isoMicrosecond * yg + i.isoNanosecond];
    var i;
    return this.nn.tn(r).map((s) => Jo(th(uy(s, No), n)));
  }
  O(e, r) {
    const [n, i] = B9(e), s = this.nn.O(n + (r > 0 || i ? 1 : 0), r);
    if (s !== void 0)
      return uy(s, No);
  }
}
const i5 = "([+-])", b1 = "(?:[.,](\\d{1,9}))?", DM = `(?:(?:${i5}(\\d{6}))|(\\d{4}))-?(\\d{2})`, s5 = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + b1 + ")?)?", o5 = i5 + s5, cte = DM + "-?(\\d{2})(?:[T ]" + s5 + "(Z|" + o5 + ")?)?", $M = "\\[(!?)([^\\]]*)\\]", mv = `((?:${$M}){0,9})`, ute = /* @__PURE__ */ Ed(DM + mv), hte = /* @__PURE__ */ Ed("(?:--)?(\\d{2})-?(\\d{2})" + mv), pte = /* @__PURE__ */ Ed(cte + mv), dte = /* @__PURE__ */ Ed("T?" + s5 + "(?:" + o5 + ")?" + mv), fte = /* @__PURE__ */ Ed(o5), gte = /* @__PURE__ */ new RegExp($M, "g"), mte = /* @__PURE__ */ Ed(`${i5}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${b1}H)?(?:(\\d+)${b1}M)?(?:(\\d+)${b1}S)?)?`), yte = /* @__PURE__ */ us((t) => new $l(RM, {
  timeZone: t,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
})), vte = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, bte = /[^\w\/:+-]+/, wte = /^M(\d{2})(L?)$/, xte = /* @__PURE__ */ us(uX), a5 = /* @__PURE__ */ us((t) => new $l(RM, {
  calendar: t,
  timeZone: Mh,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
})), jM = {
  P(t, e, r) {
    const n = fr(r);
    let i, { years: s, months: o, weeks: a, days: l } = e;
    if (l += Tn(e, 5)[0], s || o)
      i = ((c, p, h, d, v) => {
        let [m, b, f] = c.v(p);
        if (h) {
          const [E, A] = c.q(m, b);
          m += h, b = gy(E, A, c.L(m)), b = Ta("month", b, 1, c.B(m), v);
        }
        return d && ([m, b] = c.un(m, b, d)), f = Ta("day", f, 1, c.U(m, b), v), c.p(m, b, f);
      })(this, t, s, o, n);
    else {
      if (!a && !l)
        return t;
      i = ai(t);
    }
    if (i === void 0)
      throw new RangeError(xc);
    return i += (7 * a + l) * ji, $s(Q2(i));
  },
  N(t, e, r) {
    if (r <= 7) {
      let l = 0, c = WL({
        ...t,
        ...Ui
      }, {
        ...e,
        ...Ui
      });
      return r === 7 && ([l, c] = ql(c, 7)), {
        ...Ln,
        weeks: l,
        days: c
      };
    }
    const n = this.v(t), i = this.v(e);
    let [s, o, a] = ((l, c, p, h, d, v, m) => {
      let b = d - c, f = v - p, E = m - h;
      if (b || f) {
        const A = Math.sign(b || f);
        let x = l.U(d, v), g = 0;
        if (Math.sign(E) === -A) {
          const w = x;
          [d, v] = l.un(d, v, -A), b = d - c, f = v - p, x = l.U(d, v), g = A < 0 ? -w : x;
        }
        if (E = m - Math.min(h, x) + g, b) {
          const [w, _] = l.q(c, p), [S, R] = l.q(d, v);
          if (f = S - w || Number(R) - Number(_), Math.sign(f) === -A) {
            const L = A < 0 && -l.B(d);
            b = (d -= A) - c, f = v - gy(w, _, l.L(d)) + (L || l.B(d));
          }
        }
      }
      return [b, f, E];
    })(this, ...n, ...i);
    return r === 8 && (o += this.cn(s, n[0]), s = 0), {
      ...Ln,
      years: s,
      months: o,
      days: a
    };
  },
  F(t, e) {
    const r = fr(e), n = fw(this, t), i = Mm(this, t, n, r), s = gw(this, t, i, n, r);
    return Ha($s(this.V(n, i, s)), this.id || cr);
  },
  K(t, e) {
    const r = fr(e), n = fw(this, t), i = Mm(this, t, n, r);
    return d0(i6(this.V(n, i, 1)), this.id || cr);
  },
  _(t, e) {
    const r = fr(e);
    let n, i, s, o = t.eraYear !== void 0 || t.year !== void 0 ? fw(this, t) : void 0;
    const a = !this.id;
    if (o === void 0 && a && (o = xa), o !== void 0) {
      const h = Mm(this, t, o, r);
      n = gw(this, t, h, o, r);
      const d = this.L(o);
      i = B6(h, d), s = h === d;
    } else {
      if (t.monthCode === void 0)
        throw new TypeError(pM);
      if ([i, s] = j6(t.monthCode), this.id && this.id !== kd && this.id !== Zl)
        if (this.id && nh(this.id) === "coptic" && r === 0) {
          const h = s || i !== 13 ? 30 : 6;
          n = t.day, n = p0(n, 1, h);
        } else if (this.id && nh(this.id) === "chinese" && r === 0) {
          const h = !s || i !== 1 && i !== 9 && i !== 10 && i !== 11 && i !== 12 ? 30 : 29;
          n = t.day, n = p0(n, 1, h);
        } else
          n = t.day;
      else
        n = gw(this, t, Mm(this, t, xa, r), xa, r);
    }
    const l = this.G(i, s, n);
    if (!l)
      throw new RangeError("Cannot guess year");
    const [c, p] = l;
    return py($s(this.V(c, p, n)), this.id || cr);
  },
  fields(t) {
    return Ax(this) && t.includes("year") ? [...t, ...Px] : t;
  },
  k(t, e) {
    const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
    return mw(r, e, G6), Ax(this) && (mw(r, e, Iee), this.id === Zl && mw(r, e, Pee, Px)), r;
  },
  inLeapYear(t) {
    const [e] = this.v(t);
    return this.sn(e);
  },
  monthsInYear(t) {
    const [e] = this.v(t);
    return this.B(e);
  },
  daysInMonth(t) {
    const [e, r] = this.v(t);
    return this.U(e, r);
  },
  daysInYear(t) {
    const [e] = this.v(t);
    return this.fn(e);
  },
  dayOfYear: $6,
  era(t) {
    return this.hn(t)[0];
  },
  eraYear(t) {
    return this.hn(t)[1];
  },
  monthCode(t) {
    const [e, r] = this.v(t), [n, i] = this.q(e, r);
    return fg(n, i);
  },
  dayOfWeek: hL,
  daysInWeek() {
    return 7;
  }
}, Ete = {
  v: a6,
  hn: pL,
  q: aL
}, Ste = {
  dayOfYear: $6,
  v: a6,
  p: md
}, Ate = /* @__PURE__ */ Object.assign({}, Ste, {
  weekOfYear: qL,
  yearOfWeek: QL,
  m(t) {
    function e(v) {
      return (7 - v < n ? 7 : 0) - v;
    }
    function r(v) {
      const m = uL(d + v), b = v || 1, f = e(Hf(l + m * b, 7));
      return p = (m + (f - c) * b) / 7;
    }
    const n = this.id ? 1 : 4, i = hL(t), s = this.dayOfYear(t), o = Hf(i - 1, 7), a = s - 1, l = Hf(o - a, 7), c = e(l);
    let p, h = Math.floor((a - c) / 7) + 1, d = t.isoYear;
    return h ? h > r(0) && (h = 1, d++) : (h = r(-1), d--), [h, d, p];
  }
}), kte = /* @__PURE__ */ Object.assign({}, jM, Ate, {
  v: a6,
  hn: pL,
  q: aL,
  G(t, e) {
    if (!e)
      return [xa, t];
  },
  sn: l6,
  L() {
  },
  B: lL,
  cn: (t) => t * hl,
  U: cL,
  fn: uL,
  V: (t, e, r) => ({
    isoYear: t,
    isoMonth: e,
    isoDay: r
  }),
  p: md,
  un: (t, e, r) => (t += G2(r, hl), (e += KE(r, hl)) < 1 ? (t--, e += hl) : e > hl && (t++, e -= hl), [t, e]),
  year(t) {
    return t.isoYear;
  },
  month(t) {
    return t.isoMonth;
  },
  day: (t) => t.isoDay
}), _te = {
  v: my,
  hn: tM,
  q: eM
}, Cte = {
  dayOfYear: $6,
  v: my,
  p: m0,
  weekOfYear: qL,
  yearOfWeek: QL,
  m() {
    return [];
  }
}, Ite = /* @__PURE__ */ Object.assign({}, jM, Cte, {
  v: my,
  hn: tM,
  q: eM,
  G(t, e, r) {
    const n = this.id && nh(this.id) === "chinese" ? ((c, p, h) => {
      if (p)
        switch (c) {
          case 1:
            return 1651;
          case 2:
            return h < 30 ? 1947 : 1765;
          case 3:
            return h < 30 ? 1966 : 1955;
          case 4:
            return h < 30 ? 1963 : 1944;
          case 5:
            return h < 30 ? 1971 : 1952;
          case 6:
            return h < 30 ? 1960 : 1941;
          case 7:
            return h < 30 ? 1968 : 1938;
          case 8:
            return h < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      return 1972;
    })(t, e, r) : xa;
    let [i, s, o] = my.call(this, {
      isoYear: n,
      isoMonth: hl,
      isoDay: 31
    });
    const a = y1.call(this, i), l = s === a;
    (Dl(t, B6(s, a)) || Dl(Number(e), Number(l)) || Dl(r, o)) === 1 && i--;
    for (let c = 0; c < 100; c++) {
      const p = i - c, h = y1.call(this, p), d = gy(t, e, h);
      if (e === (d === h) && r <= h7.call(this, p, d))
        return [p, d];
    }
  },
  sn(t) {
    const e = Tm.call(this, t);
    return e > Tm.call(this, t - 1) && e > Tm.call(this, t + 1);
  },
  L: y1,
  B: Lm,
  cn(t, e) {
    const r = e + t, n = Math.sign(t), i = n < 0 ? -1 : 0;
    let s = 0;
    for (let o = e; o !== r; o += n)
      s += Lm.call(this, o + i);
    return s;
  },
  U: h7,
  fn: Tm,
  V(t, e, r) {
    return Q2(m0.call(this, t, e, r));
  },
  p: m0,
  un(t, e, r) {
    if (r) {
      if (e += r, !Number.isSafeInteger(e))
        throw new RangeError(xc);
      if (r < 0)
        for (; e < 1; )
          e += Lm.call(this, --t);
      else {
        let n;
        for (; e > (n = Lm.call(this, t)); )
          e -= n, t++;
      }
    }
    return [t, e];
  },
  year(t) {
    return this.h(t).year;
  },
  month(t) {
    const { year: e, o: r } = this.h(t), { u: n } = this.l(e);
    return n[r] + 1;
  },
  day(t) {
    return this.h(t).day;
  }
}), yv = /* @__PURE__ */ rM(Ete, _te), jt = /* @__PURE__ */ rM(kte, Ite), d7 = {
  era: m1,
  eraYear: ii,
  year: ii,
  month: j9,
  monthCode(t) {
    const e = m1(t);
    return j6(e), e;
  },
  day: j9,
  .../* @__PURE__ */ Hp(Wa, ii),
  .../* @__PURE__ */ Hp(br, e6),
  offset(t) {
    const e = m1(t);
    return Th(e), e;
  }
}, l5 = /* @__PURE__ */ nr(YT, Wa, to), Pte = /* @__PURE__ */ nr(YT, to, Wa), jl = "numeric", Eg = ["timeZoneName"], BM = {
  month: jl,
  day: jl
}, c5 = {
  year: jl,
  month: jl
}, u5 = /* @__PURE__ */ Object.assign({}, c5, {
  day: jl
}), h5 = {
  hour: jl,
  minute: jl,
  second: jl
}, p5 = /* @__PURE__ */ Object.assign({}, u5, h5), Rte = /* @__PURE__ */ Object.assign({}, p5, {
  timeZoneName: "short"
}), Ote = /* @__PURE__ */ Object.keys(c5), Tte = /* @__PURE__ */ Object.keys(BM), Lte = /* @__PURE__ */ Object.keys(u5), Mte = /* @__PURE__ */ Object.keys(h5), d5 = ["dateStyle"], Nte = /* @__PURE__ */ Ote.concat(d5), Dte = /* @__PURE__ */ Tte.concat(d5), f5 = /* @__PURE__ */ Lte.concat(d5, ["weekday"]), Sg = /* @__PURE__ */ Mte.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]), g5 = /* @__PURE__ */ f5.concat(Sg), $te = /* @__PURE__ */ Eg.concat(Sg), jte = /* @__PURE__ */ Eg.concat(f5), Bte = /* @__PURE__ */ Eg.concat(["day", "weekday"], Sg), Fte = /* @__PURE__ */ Eg.concat(["year", "weekday"], Sg), zte = /* @__PURE__ */ Lh(g5, p5), Ute = /* @__PURE__ */ Lh(g5, Rte), Vte = /* @__PURE__ */ Lh(g5, p5, Eg), Hte = /* @__PURE__ */ Lh(f5, u5, $te), Gte = /* @__PURE__ */ Lh(Sg, h5, jte), Wte = /* @__PURE__ */ Lh(Nte, c5, Bte), qte = /* @__PURE__ */ Lh(Dte, BM, Fte), Qte = {}, FM = new $l(void 0, {
  calendar: cr
}).resolvedOptions().calendar === cr, zM = [zte, f6], Kte = [Ute, f6, 0, (t, e) => {
  const r = t.timeZone;
  if (e && e.timeZone !== r)
    throw new RangeError(mM);
  return r;
}], UM = [Vte, ai], VM = [Hte, ai], HM = [Gte, (t) => Ql(t) / Ga], GM = [Wte, ai, FM], WM = [qte, ai, FM];
let f7;
function Sc(t, e, r, n, i) {
  function s(...l) {
    if (!(this instanceof s))
      throw new TypeError(_x);
    y7(this, e(...l));
  }
  function o(l, c) {
    return Object.defineProperties(function(...p) {
      return l.call(this, a(this), ...p);
    }, h0(c));
  }
  function a(l) {
    const c = yi(l);
    if (!c || c.branding !== t)
      throw new TypeError(_x);
    return c;
  }
  return Object.defineProperties(s.prototype, {
    ...wJ(La(o, r)),
    ...zp(La(o, n)),
    ...QE("Temporal." + t)
  }), Object.defineProperties(s, {
    ...zp(i),
    ...h0(t)
  }), [s, (l) => {
    const c = Object.create(s.prototype);
    return y7(c, l), c;
  }, a];
}
function Cd(t) {
  if (yi(t) || t.calendar !== void 0 || t.timeZone !== void 0)
    throw new TypeError(oee);
  return t;
}
function Ag(t) {
  return qM(t) || cr;
}
function qM(t) {
  const { calendar: e } = t;
  if (e !== void 0)
    return vv(e);
}
function vv(t) {
  if (gi(t)) {
    const { calendar: e } = yi(t) || {};
    if (!e)
      throw new TypeError(dM(t));
    return e;
  }
  return ((e) => hv(ZJ(Jn(e))))(t);
}
function m5(t) {
  const e = {};
  for (const r in t)
    e[r] = (n) => {
      const { calendar: i } = n;
      return jt(i)[r](n);
    };
  return e;
}
function Ac() {
  throw new TypeError(aee);
}
function ss(t) {
  if (gi(t)) {
    const { timeZone: e } = yi(t) || {};
    if (!e)
      throw new TypeError(gM(t));
    return e;
  }
  return ((e) => L6(JJ(Jn(e))))(t);
}
function ln(t) {
  if (gi(t)) {
    const e = yi(t);
    return e && e.branding === n5 ? e : wX(t);
  }
  return YJ(t);
}
function vf(t) {
  if (t !== void 0) {
    if (gi(t)) {
      const e = yi(t) || {};
      switch (e.branding) {
        case Ec:
        case xg:
          return e;
        case _d:
          return Ha(e);
      }
      const r = Ag(t);
      return {
        ...dX(ss, Qt, jt(r), t),
        calendar: r
      };
    }
    return HJ(t);
  }
}
function pl(t, e) {
  if (gi(t)) {
    const n = yi(t) || {};
    switch (n.branding) {
      case t5:
        return fr(e), n;
      case _d:
        return fr(e), ea(n);
      case Ec:
        return fr(e), aM(Qt, n);
    }
    return bX(t, e);
  }
  const r = KJ(t);
  return fr(e), r;
}
function y5(t) {
  return t === void 0 ? void 0 : pl(t);
}
function Xh(t, e) {
  if (gi(t)) {
    const n = yi(t) || {};
    switch (n.branding) {
      case _d:
        return fr(e), n;
      case xg:
        return fr(e), eo({
          ...n,
          ...Ui
        });
      case Ec:
        return fr(e), sM(Qt, n);
    }
    return gX(jt(Ag(t)), t, e);
  }
  const r = WJ(t);
  return fr(e), r;
}
function g7(t, e) {
  if (gi(t)) {
    const n = yi(t);
    if (n && n.branding === e5)
      return fr(e), n;
    const i = qM(t);
    return vX(jt(i || cr), !i, t, e);
  }
  const r = QJ(jt, t);
  return fr(e), r;
}
function ep(t, e) {
  if (gi(t)) {
    const n = yi(t);
    return n && n.branding === X6 ? (fr(e), n) : yX(jt(Ag(t)), t, e);
  }
  const r = qJ(jt, t);
  return fr(e), r;
}
function tp(t, e) {
  if (gi(t)) {
    const n = yi(t) || {};
    switch (n.branding) {
      case xg:
        return fr(e), n;
      case _d:
        return fr(e), Ha(n);
      case Ec:
        return fr(e), oM(Qt, n);
    }
    return mX(jt(Ag(t)), t, e);
  }
  const r = _6(t);
  return fr(e), r;
}
function rp(t, e) {
  if (gi(t)) {
    const r = yi(t);
    if (r && r.branding === Ec)
      return Y2(e), r;
    const n = Ag(t);
    return fX(ss, Qt, jt(n), n, t, e);
  }
  return GJ(t, e);
}
function m7(t) {
  return La((e) => (r) => e(Ox(r)), t);
}
function Ox(t) {
  return ds(t, Qt);
}
function np(t) {
  if (gi(t)) {
    const e = yi(t);
    if (e)
      switch (e.branding) {
        case r5:
          return e;
        case Ec:
          return Va(e.epochNanoseconds);
      }
  }
  return VJ(t);
}
function Yte() {
  function t(s, o) {
    return new e(s, o);
  }
  function e(s, o = /* @__PURE__ */ Object.create(null)) {
    by.set(this, ((a, l) => {
      const c = new $l(a, l), p = c.resolvedOptions(), h = p.locale, d = Js(Object.keys(l), p), v = us(Xte), m = (b, ...f) => {
        if (b) {
          if (f.length !== 2)
            throw new TypeError(vw);
          for (const g of f)
            if (g === void 0)
              throw new TypeError(vw);
        }
        b || f[0] !== void 0 || (f = []);
        const E = f.map((g) => yi(g) || Number(g));
        let A, x = 0;
        for (const g of E) {
          const w = typeof g == "object" ? g.branding : void 0;
          if (x++ && w !== A)
            throw new TypeError(vw);
          A = w;
        }
        return A ? v(A)(h, d, ...E) : [c, ...E];
      };
      return m.X = c, m;
    })(s, o));
  }
  const r = $l.prototype, n = Object.getOwnPropertyDescriptors(r), i = Object.getOwnPropertyDescriptors($l);
  for (const s in n) {
    const o = n[s], a = s.startsWith("format") && Zte(s);
    typeof o.value == "function" ? o.value = s === "constructor" ? t : a || Jte(s) : a && (o.get = function() {
      if (!by.has(this))
        throw new TypeError(_x);
      return (...l) => a.apply(this, l);
    }, Object.defineProperties(o.get, h0(`get ${s}`)));
  }
  return i.prototype.value = e.prototype = Object.create({}, n), Object.defineProperties(t, i), t;
}
function Zte(t) {
  return Object.defineProperties(function(...e) {
    const r = by.get(this), [n, ...i] = r(t.includes("Range"), ...e);
    return n[t](...i);
  }, h0(t));
}
function Jte(t) {
  return Object.defineProperties(function(...e) {
    return by.get(this).X[t](...e);
  }, h0(t));
}
function Xte(t) {
  const e = sre[t];
  if (!e)
    throw new TypeError(kee(t));
  return bc(e, us(lM), 1);
}
const vy = /* @__PURE__ */ new WeakMap(), yi = /* @__PURE__ */ vy.get.bind(vy), y7 = /* @__PURE__ */ vy.set.bind(vy), QM = {
  era: xJ,
  eraYear: eL,
  year: YE,
  month: ha,
  daysInMonth: ha,
  daysInYear: ha,
  inLeapYear: Oee,
  monthsInYear: ha
}, v5 = {
  monthCode: Jn
}, KM = {
  day: ha
}, ere = {
  dayOfWeek: ha,
  dayOfYear: ha,
  weekOfYear: EJ,
  yearOfWeek: eL,
  daysInWeek: ha
}, b5 = /* @__PURE__ */ m5(/* @__PURE__ */ Object.assign({}, QM, v5, KM, ere)), tre = /* @__PURE__ */ m5({
  ...QM,
  ...v5
}), rre = /* @__PURE__ */ m5({
  ...v5,
  ...KM
}), kg = {
  calendarId: (t) => t.calendar
}, nre = /* @__PURE__ */ H2((t) => (e) => e[t], br.concat("sign")), w5 = /* @__PURE__ */ H2((t, e) => (r) => r[to[e]], Wa), YM = {
  epochMilliseconds: f6,
  epochNanoseconds: kJ
}, [ire, Zr, LCe] = Sc(n5, NX, {
  ...nre,
  blank: zJ
}, {
  with: (t, e) => Zr(CX(t, e)),
  negated: (t) => Zr(k6(t)),
  abs: (t) => Zr(FJ(t)),
  add: (t, e, r) => Zr(r7(vf, jt, Qt, 0, t, ln(e), r)),
  subtract: (t, e, r) => Zr(r7(vf, jt, Qt, 1, t, ln(e), r)),
  round: (t, e) => Zr(BJ(vf, jt, Qt, t, e)),
  total: (t, e) => _J(vf, jt, Qt, t, e),
  toLocaleString(t, e, r) {
    return Intl.DurationFormat ? new Intl.DurationFormat(e, r).format(this) : dw(t);
  },
  toString: dw,
  toJSON: (t) => dw(t),
  valueOf: Ac
}, {
  from: (t) => Zr(ln(t)),
  compare: (t, e, r) => eX(vf, jt, Qt, ln(t), ln(e), r)
}), sre = {
  Instant: zM,
  PlainDateTime: UM,
  PlainDate: VM,
  PlainTime: HM,
  PlainYearMonth: GM,
  PlainMonthDay: WM
}, ore = /* @__PURE__ */ bc(zM), are = /* @__PURE__ */ bc(Kte), lre = /* @__PURE__ */ bc(UM), cre = /* @__PURE__ */ bc(VM), ure = /* @__PURE__ */ bc(HM), hre = /* @__PURE__ */ bc(GM), pre = /* @__PURE__ */ bc(WM), [dre, kl] = Sc(t5, MX, w5, {
  with(t, e, r) {
    return kl(_X(this, Cd(e), r));
  },
  add: (t, e) => kl(t7(0, t, ln(e))),
  subtract: (t, e) => kl(t7(1, t, ln(e))),
  until: (t, e, r) => Zr(u7(0, t, pl(e), r)),
  since: (t, e, r) => Zr(u7(1, t, pl(e), r)),
  round: (t, e) => kl(RJ(t, e)),
  equals: (t, e) => aX(t, pl(e)),
  toLocaleString(t, e, r) {
    const [n, i] = ure(e, r, t);
    return n.format(i);
  },
  toString: Q9,
  toJSON: (t) => Q9(t),
  valueOf: Ac
}, {
  from: (t, e) => kl(pl(t, e)),
  compare: (t, e) => N6(pl(t), pl(e))
}), [fre, Eo] = Sc(_d, nr(RX, gg), {
  ...kg,
  ...b5,
  ...w5
}, {
  with: (t, e, r) => Eo(EX(jt, t, Cd(e), r)),
  withCalendar: (t, e) => Eo(F6(t, vv(e))),
  withPlainTime: (t, e) => Eo(KX(t, y5(e))),
  add: (t, e, r) => Eo(J9(jt, 0, t, ln(e), r)),
  subtract: (t, e, r) => Eo(J9(jt, 1, t, ln(e), r)),
  until: (t, e, r) => Zr(a7(jt, 0, t, Xh(e), r)),
  since: (t, e, r) => Zr(a7(jt, 1, t, Xh(e), r)),
  round: (t, e) => Eo(PJ(t, e)),
  equals: (t, e) => nX(t, Xh(e)),
  toZonedDateTime: (t, e, r) => ti(jX(Qt, t, ss(e), r)),
  toPlainDate: (t) => Io(Ha(t)),
  toPlainTime: (t) => kl(ea(t)),
  toLocaleString(t, e, r) {
    const [n, i] = lre(e, r, t);
    return n.format(i);
  },
  toString: H9,
  toJSON: (t) => H9(t),
  valueOf: Ac
}, {
  from: (t, e) => Eo(Xh(t, e)),
  compare: (t, e) => FL(Xh(t), Xh(e))
}), [gre, Tx, MCe] = Sc(e5, nr(LX, gg), {
  ...kg,
  ...rre
}, {
  with: (t, e, r) => Tx(kX(jt, t, Cd(e), r)),
  equals: (t, e) => oX(t, g7(e)),
  toPlainDate(t, e) {
    return Io(HX(jt, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = pre(e, r, t);
    return n.format(i);
  },
  toString: q9,
  toJSON: (t) => q9(t),
  valueOf: Ac
}, {
  from: (t, e) => Tx(g7(t, e))
}), [mre, Of, NCe] = Sc(X6, nr(TX, gg), {
  ...kg,
  ...tre
}, {
  with: (t, e, r) => Of(AX(jt, t, Cd(e), r)),
  add: (t, e, r) => Of(e7(jt, 0, t, ln(e), r)),
  subtract: (t, e, r) => Of(e7(jt, 1, t, ln(e), r)),
  until: (t, e, r) => Zr(c7(jt, 0, t, ep(e), r)),
  since: (t, e, r) => Zr(c7(jt, 1, t, ep(e), r)),
  equals: (t, e) => sX(t, ep(e)),
  toPlainDate(t, e) {
    return Io(VX(jt, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = hre(e, r, t);
    return n.format(i);
  },
  toString: W9,
  toJSON: (t) => W9(t),
  valueOf: Ac
}, {
  from: (t, e) => Of(ep(t, e)),
  compare: (t, e) => Sd(ep(t), ep(e))
}), [yre, Io, DCe] = Sc(xg, nr(OX, gg), {
  ...kg,
  ...b5
}, {
  with: (t, e, r) => Io(SX(jt, t, Cd(e), r)),
  withCalendar: (t, e) => Io(F6(t, vv(e))),
  add: (t, e, r) => Io(X9(jt, 0, t, ln(e), r)),
  subtract: (t, e, r) => Io(X9(jt, 1, t, ln(e), r)),
  until: (t, e, r) => Zr(l7(jt, 0, t, tp(e), r)),
  since: (t, e, r) => Zr(l7(jt, 1, t, tp(e), r)),
  equals: (t, e) => iX(t, tp(e)),
  toZonedDateTime(t, e) {
    const r = gi(e) ? e : {
      timeZone: e
    };
    return ti(BX(ss, pl, Qt, t, r));
  },
  toPlainDateTime: (t, e) => Eo(FX(t, y5(e))),
  toPlainYearMonth(t) {
    return Of(zX(jt, t, this));
  },
  toPlainMonthDay(t) {
    return Tx(UX(jt, t, this));
  },
  toLocaleString(t, e, r) {
    const [n, i] = cre(e, r, t);
    return n.format(i);
  },
  toString: G9,
  toJSON: (t) => G9(t),
  valueOf: Ac
}, {
  from: (t, e) => Io(tp(t, e)),
  compare: (t, e) => Sd(tp(t), tp(e))
}), [vre, ti] = Sc(Ec, nr(PX, gg, XJ), {
  ...YM,
  ...kg,
  ...m7(b5),
  ...m7(w5),
  offset: (t) => pg(Ox(t).offsetNanoseconds),
  offsetNanoseconds: (t) => Ox(t).offsetNanoseconds,
  timeZoneId: (t) => t.timeZone,
  hoursInDay: (t) => OJ(Qt, t)
}, {
  with: (t, e, r) => ti(xX(jt, Qt, t, Cd(e), r)),
  withCalendar: (t, e) => ti(F6(t, vv(e))),
  withTimeZone: (t, e) => ti(YX(t, ss(e))),
  withPlainTime: (t, e) => ti(QX(Qt, t, y5(e))),
  add: (t, e, r) => ti(Z9(jt, Qt, 0, t, ln(e), r)),
  subtract: (t, e, r) => ti(Z9(jt, Qt, 1, t, ln(e), r)),
  until: (t, e, r) => Zr(gn(o7(jt, Qt, 0, t, rp(e), r))),
  since: (t, e, r) => Zr(gn(o7(jt, Qt, 1, t, rp(e), r))),
  round: (t, e) => ti(IJ(Qt, t, e)),
  startOfDay: (t) => ti(TJ(Qt, t)),
  equals: (t, e) => rX(t, rp(e)),
  toInstant: (t) => dl($X(t)),
  toPlainDateTime: (t) => Eo(sM(Qt, t)),
  toPlainDate: (t) => Io(oM(Qt, t)),
  toPlainTime: (t) => kl(aM(Qt, t)),
  toLocaleString(t, e, r = {}) {
    const [n, i] = are(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => V9(Qt, t, e),
  toJSON: (t) => V9(Qt, t),
  valueOf: Ac,
  getTimeZoneTransition(t, e) {
    const { timeZone: r, epochNanoseconds: n } = t, i = AJ(e), s = Qt(r).O(n, i);
    return s ? ti({
      ...t,
      epochNanoseconds: s
    }) : null;
  }
}, {
  from: (t, e) => ti(rp(t, e)),
  compare: (t, e) => BL(rp(t), rp(e))
}), [bre, dl, $Ce] = Sc(r5, IX, YM, {
  add: (t, e) => dl(Y9(0, t, ln(e))),
  subtract: (t, e) => dl(Y9(1, t, ln(e))),
  until: (t, e, r) => Zr(s7(0, t, np(e), r)),
  since: (t, e, r) => Zr(s7(1, t, np(e), r)),
  round: (t, e) => dl(CJ(t, e)),
  equals: (t, e) => tX(t, np(e)),
  toZonedDateTimeISO: (t, e) => ti(DX(t, ss(e))),
  toLocaleString(t, e, r) {
    const [n, i] = ore(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => U9(ss, Qt, t, e),
  toJSON: (t) => U9(ss, Qt, t),
  valueOf: Ac
}, {
  from: (t) => dl(np(t)),
  fromEpochMilliseconds: (t) => dl(GX(t)),
  fromEpochNanoseconds: (t) => dl(WX(t)),
  compare: (t, e) => jL(np(t), np(e))
}), wre = /* @__PURE__ */ Object.defineProperties({}, {
  ...QE("Temporal.Now"),
  ...zp({
    timeZoneId: () => mf(),
    instant: () => dl(Va(kx())),
    zonedDateTimeISO: (t = mf()) => ti(Xs(kx(), ss(t), cr)),
    plainDateTimeISO: (t = mf()) => Eo(eo(yw(Qt(ss(t))), cr)),
    plainDateISO: (t = mf()) => Io(Ha(yw(Qt(ss(t))), cr)),
    plainTimeISO: (t = mf()) => kl(ea(yw(Qt(ss(t)))))
  })
}), Lx = /* @__PURE__ */ Object.defineProperties({}, {
  ...QE("Temporal"),
  ...zp({
    PlainYearMonth: mre,
    PlainMonthDay: gre,
    PlainDate: yre,
    PlainTime: dre,
    PlainDateTime: fre,
    ZonedDateTime: vre,
    Instant: bre,
    Duration: ire,
    Now: wre
  })
}), xre = /* @__PURE__ */ Yte(), by = /* @__PURE__ */ new WeakMap();
zp({
  DateTimeFormat: xre
});
let v7 = class extends Error {
  constructor(e) {
    super(`[ParaModel]: ${e}`);
  }
};
function Wn(t) {
  const e = [];
  let r = 0;
  for (const n of t)
    e.push([n, r]), r++;
  return e;
}
function ZM(t, e, r) {
  if (e.length !== r.length)
    return !1;
  for (const [n, i] of vJ(e, r))
    if (!t(n, i))
      return !1;
  return !0;
}
function Wf(t) {
  return Lx.Instant.fromEpochMilliseconds(t).toZonedDateTimeISO("UTC").toPlainDateTime();
}
let Mx = class {
  constructor(e) {
    this.points = [e];
  }
  add(e) {
    this.points.push(e);
  }
};
function Ere(t, e) {
  if (t.length <= 1)
    return t;
  const r = [];
  e(t[0], t[1]) ? r.push(new Mx(t[0])) : r.push(t[0]);
  for (let n = 1; n < t.length - 1; n++)
    e(t[n - 1], t[n]) ? r.at(-1).add(t[n]) : e(t[n], t[n + 1]) ? r.push(new Mx(t[n])) : r.push(t[n]);
  return e(t.at(-2), t.at(-1)) ? r.at(-1).add(t.at(-1)) : r.push(t.at(-1)), r;
}
function Nx(t) {
  return t === "number" || t === "date";
}
let x5 = class {
  constructor(e) {
    this.raw = e, this.value = this.convertRaw(e);
  }
};
class Sre extends x5 {
  convertRaw(e) {
    const r = parseFloat(e);
    if (isNaN(r))
      throw new Error("x values in Numeric Datapoints must be numbers");
    return r;
  }
  isNumber() {
    return !0;
  }
  isString() {
    return !1;
  }
  isDate() {
    return !1;
  }
  isEqual(e) {
    return this.value === e.value;
  }
  isNumberLike() {
    return !0;
  }
  asNumber() {
    return this.value;
  }
  datatype() {
    return "number";
  }
}
class Are extends x5 {
  convertRaw(e) {
    return e;
  }
  isNumber() {
    return !1;
  }
  isString() {
    return !0;
  }
  isDate() {
    return !1;
  }
  isEqual(e) {
    return this.value === e.value;
  }
  isNumberLike() {
    return !1;
  }
  asNumber() {
    return null;
  }
  datatype() {
    return "string";
  }
}
const kre = ["01", "04", "07", "10"];
function _re(t) {
  let e = parseFloat(t), r = 0;
  return t[0] === "Q" && (r = parseInt(t[1]) - 1, t[3] === "'" ? e = parseInt(t.substring(4)) + 2e3 : e = parseInt(t.substring(3))), Number.isNaN(e) || Number.isNaN(r) ? null : `${e}${kre[r]}01`;
}
class Cre extends x5 {
  convertRaw(e) {
    const r = _re(e);
    if (r === null)
      throw new v7(`Raw date string "${e}" could not be parsed.`);
    try {
      return Lx.PlainDateTime.from(r);
    } catch (n) {
      throw new v7(`RFC9557 date string "${r}" could not be parsed. Parsing error: ${n}`);
    }
  }
  isNumber() {
    return !1;
  }
  isString() {
    return !1;
  }
  isDate() {
    return !0;
  }
  isEqual(e) {
    return Lx.PlainDateTime.compare(this.value, e.value) === 0;
  }
  isNumberLike() {
    return !0;
  }
  // Temporal requires PlaneDateTimes be converted to ZonedDateTimes to get their milliseconds since
  //   the epoch (1/1/1970). We convert PlaneDateTimes to an arbitrary time zone here (UTC, i.e. 
  //   Greenwich mean time) as we are only concerned with the relative differences between PlaneDateTimes
  asNumber() {
    return this.value.toZonedDateTime("UTC").epochMilliseconds;
  }
  datatype() {
    return "date";
  }
}
const Ire = {
  string: Are,
  number: Sre,
  date: Cre
};
let JM = class {
  constructor() {
    this.boxes = [];
  }
  get values() {
    return this.boxes;
  }
  has(e) {
    return this.boxes.some((r) => e.isEqual(r));
  }
  add(e) {
    this.has(e) || this.boxes.push(e);
  }
  merge(e) {
    e.forEach((r) => this.add(r));
  }
};
function Pre(t) {
  if (t.length === 0)
    return 0;
  var e = t[0], r = 0, n;
  if (typeof e != "number")
    return Number.NaN;
  for (var i = 1; i < t.length; i++) {
    if (typeof t[i] != "number")
      return Number.NaN;
    n = e + t[i], Math.abs(e) >= Math.abs(t[i]) ? r += e - n + t[i] : r += t[i] - n + e, e = n;
  }
  return e + r;
}
function Uo(t) {
  if (t.length === 0)
    throw new Error("mean requires at least one data point");
  return Pre(t) / t.length;
}
function Rre(t, e) {
  var r = Uo(t), n = 0, i, s;
  for (s = 0; s < t.length; s++)
    i = t[s] - r, n += i * i;
  return n;
}
function Ore(t) {
  if (t.length === 0)
    throw new Error("mode requires at least one data point");
  if (t.length === 1)
    return t[0];
  for (var e = t[0], r = Number.NaN, n = 0, i = 1, s = 1; s < t.length + 1; s++)
    t[s] !== e ? (i > n && (n = i, r = e), i = 1, e = t[s]) : i++;
  return r;
}
function Tre(t) {
  return t.slice().sort(function(e, r) {
    return e - r;
  });
}
function Lre(t) {
  return Ore(Tre(t));
}
function b7(t, e) {
  var r = t.length * e;
  if (t.length === 0)
    throw new Error("quantile requires at least one data point.");
  if (e < 0 || e > 1)
    throw new Error("quantiles must be between 0 and 1");
  return e === 1 ? t[t.length - 1] : e === 0 ? t[0] : r % 1 !== 0 ? t[Math.ceil(r) - 1] : t.length % 2 === 0 ? (t[r - 1] + t[r]) / 2 : t[r];
}
function w1(t, e, r, n) {
  for (r = r || 0, n = n || t.length - 1; n > r; ) {
    if (n - r > 600) {
      var i = n - r + 1, s = e - r + 1, o = Math.log(i), a = 0.5 * Math.exp(2 * o / 3), l = 0.5 * Math.sqrt(o * a * (i - a) / i);
      s - i / 2 < 0 && (l *= -1);
      var c = Math.max(r, Math.floor(e - s * a / i + l)), p = Math.min(
        n,
        Math.floor(e + (i - s) * a / i + l)
      );
      w1(t, e, c, p);
    }
    var h = t[e], d = r, v = n;
    for (bf(t, r, e), t[n] > h && bf(t, r, n); d < v; ) {
      for (bf(t, d, v), d++, v--; t[d] < h; )
        d++;
      for (; t[v] > h; )
        v--;
    }
    t[r] === h ? bf(t, r, v) : (v++, bf(t, v, n)), v <= e && (r = v + 1), e <= v && (n = v - 1);
  }
}
function bf(t, e, r) {
  var n = t[e];
  t[e] = t[r], t[r] = n;
}
function Mre(t, e) {
  var r = t.slice();
  if (Array.isArray(e)) {
    Nre(r, e);
    for (var n = [], i = 0; i < e.length; i++)
      n[i] = b7(r, e[i]);
    return n;
  } else {
    var s = eN(r.length, e);
    return XM(r, s, 0, r.length - 1), b7(r, e);
  }
}
function XM(t, e, r, n) {
  e % 1 === 0 ? w1(t, e, r, n) : (e = Math.floor(e), w1(t, e, r, n), w1(t, e + 1, e + 1, n));
}
function Nre(t, e) {
  for (var r = [0], n = 0; n < e.length; n++)
    r.push(eN(t.length, e[n]));
  r.push(t.length - 1), r.sort(Dre);
  for (var i = [0, r.length - 1]; i.length; ) {
    var s = Math.ceil(i.pop()), o = Math.floor(i.pop());
    if (!(s - o <= 1)) {
      var a = Math.floor((o + s) / 2);
      XM(
        t,
        r[a],
        Math.floor(r[o]),
        Math.ceil(r[s])
      ), i.push(o, a, a, s);
    }
  }
}
function Dre(t, e) {
  return t - e;
}
function eN(t, e) {
  var r = t * e;
  return e === 1 ? t - 1 : e === 0 ? 0 : r % 1 !== 0 ? Math.ceil(r) - 1 : t % 2 === 0 ? r - 0.5 : r;
}
function $re(t) {
  return +Mre(t, 0.5);
}
function jre(t, e) {
  if (t.length !== e.length)
    throw new Error("sampleCovariance requires samples with equal lengths");
  if (t.length < 2)
    throw new Error(
      "sampleCovariance requires at least two data points in each sample"
    );
  for (var r = Uo(t), n = Uo(e), i = 0, s = 0; s < t.length; s++)
    i += (t[s] - r) * (e[s] - n);
  var o = t.length - 1;
  return i / o;
}
function Bre(t) {
  if (t.length < 2)
    throw new Error("sampleVariance requires at least two data points");
  var e = Rre(t), r = t.length - 1;
  return e / r;
}
function Dx(t) {
  var e = Bre(t);
  return Math.sqrt(e);
}
function Fre(t, e) {
  var r = jre(t, e), n = Dx(t), i = Dx(e);
  return r / n / i;
}
var $x = 9e15, kc = 1e9, jx = "0123456789abcdef", wy = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", xy = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", Bx = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -9e15,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: $x,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, tN, pa, Lt = !0, bv = "[DecimalError] ", ih = bv + "Invalid argument: ", rN = bv + "Precision limit exceeded", nN = bv + "crypto unavailable", Mn = Math.floor, Sn = Math.pow, zre = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, Ure = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, Vre = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, Hre = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Bs = 1e7, bt = 7, Gre = 9007199254740991, Wre = wy.length - 1, Fx = xy.length - 1, ze = { name: "[object Decimal]" };
ze.absoluteValue = ze.abs = function() {
  var t = new this.constructor(this);
  return t.s < 0 && (t.s = 1), gt(t);
};
ze.ceil = function() {
  return gt(new this.constructor(this), this.e + 1, 2);
};
ze.comparedTo = ze.cmp = function(t) {
  var e, r, n, i, s = this, o = s.d, a = (t = new s.constructor(t)).d, l = s.s, c = t.s;
  if (!o || !a)
    return !l || !c ? NaN : l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? l : a[0] ? -c : 0;
  if (l !== c) return l;
  if (s.e !== t.e) return s.e > t.e ^ l < 0 ? 1 : -1;
  for (n = o.length, i = a.length, e = 0, r = n < i ? n : i; e < r; ++e)
    if (o[e] !== a[e]) return o[e] > a[e] ^ l < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
};
ze.cosine = ze.cos = function() {
  var t, e, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + bt, n.rounding = 1, r = qre(n, lN(n, r)), n.precision = t, n.rounding = e, gt(pa == 2 || pa == 3 ? r.neg() : r, t, e, !0)) : new n(1) : new n(NaN);
};
ze.cubeRoot = ze.cbrt = function() {
  var t, e, r, n, i, s, o, a, l, c, p = this, h = p.constructor;
  if (!p.isFinite() || p.isZero()) return new h(p);
  for (Lt = !1, s = p.s * Math.pow(p.s * p, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = hn(p.d), t = p.e, (s = (t - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Math.pow(r, 1 / 3), t = Mn((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + t : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + t), n = new h(r), n.s = p.s) : n = new h(s.toString()), o = (t = h.precision) + 3; ; )
    if (a = n, l = a.times(a).times(a), c = l.plus(p), n = or(c.plus(p).times(a), c.plus(l), o + 2, 1), hn(a.d).slice(0, o) === (r = hn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (gt(a, t + 1, 0), a.times(a).times(a).eq(p))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (gt(n, t + 1, 1), e = !n.times(n).times(n).eq(p));
        break;
      }
  return Lt = !0, gt(n, t, h.rounding, e);
};
ze.decimalPlaces = ze.dp = function() {
  var t, e = this.d, r = NaN;
  if (e) {
    if (t = e.length - 1, r = (t - Mn(this.e / bt)) * bt, t = e[t], t) for (; t % 10 == 0; t /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
ze.dividedBy = ze.div = function(t) {
  return or(this, new this.constructor(t));
};
ze.dividedToIntegerBy = ze.divToInt = function(t) {
  var e = this, r = e.constructor;
  return gt(or(e, new r(t), 0, 1, 1), r.precision, r.rounding);
};
ze.equals = ze.eq = function(t) {
  return this.cmp(t) === 0;
};
ze.floor = function() {
  return gt(new this.constructor(this), this.e + 1, 3);
};
ze.greaterThan = ze.gt = function(t) {
  return this.cmp(t) > 0;
};
ze.greaterThanOrEqualTo = ze.gte = function(t) {
  var e = this.cmp(t);
  return e == 1 || e === 0;
};
ze.hyperbolicCosine = ze.cosh = function() {
  var t, e, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (t = Math.ceil(i / 3), e = Math.pow(4, -t).toString()) : (t = 16, e = "2.3283064365386962890625e-10"), s = Gp(o, 1, s.times(e), new o(1), !0);
  for (var l, c = t, p = new o(8); c--; )
    l = s.times(s), s = a.minus(l.times(p.minus(l.times(p))));
  return gt(s, o.precision = r, o.rounding = n, !0);
};
ze.hyperbolicSine = ze.sinh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero()) return new s(i);
  if (e = s.precision, r = s.rounding, s.precision = e + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = Gp(s, 2, i, i, !0);
  else {
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, i = i.times(Math.pow(5, -t)), i = Gp(s, 2, i, i, !0);
    for (var o, a = new s(5), l = new s(16), c = new s(20); t--; )
      o = i.times(i), i = i.times(a.plus(o.times(l.times(o).plus(c))));
  }
  return s.precision = e, s.rounding = r, gt(i, e, r, !0);
};
ze.hyperbolicTangent = ze.tanh = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 7, n.rounding = 1, or(r.sinh(), r.cosh(), n.precision = t, n.rounding = e)) : new n(r.s);
};
ze.inverseCosine = ze.acos = function() {
  var t, e = this, r = e.constructor, n = e.abs().cmp(1), i = r.precision, s = r.rounding;
  return n !== -1 ? n === 0 ? e.isNeg() ? Ls(r, i, s) : new r(0) : new r(NaN) : e.isZero() ? Ls(r, i + 4, s).times(0.5) : (r.precision = i + 6, r.rounding = 1, e = e.asin(), t = Ls(r, i + 4, s).times(0.5), r.precision = i, r.rounding = s, t.minus(e));
};
ze.inverseHyperbolicCosine = ze.acosh = function() {
  var t, e, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, Lt = !1, r = r.times(r).minus(1).sqrt().plus(r), Lt = !0, n.precision = t, n.rounding = e, r.ln()) : new n(r);
};
ze.inverseHyperbolicSine = ze.asinh = function() {
  var t, e, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, Lt = !1, r = r.times(r).plus(1).sqrt().plus(r), Lt = !0, n.precision = t, n.rounding = e, r.ln());
};
ze.inverseHyperbolicTangent = ze.atanh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (t = s.precision, e = s.rounding, n = i.sd(), Math.max(n, t) < 2 * -i.e - 1 ? gt(new s(i), t, e, !0) : (s.precision = r = n - i.e, i = or(i.plus(1), new s(1).minus(i), r + t, 1), s.precision = t + 4, s.rounding = 1, i = i.ln(), s.precision = t, s.rounding = e, i.times(0.5))) : new s(NaN);
};
ze.inverseSine = ze.asin = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (e = i.abs().cmp(1), r = s.precision, n = s.rounding, e !== -1 ? e === 0 ? (t = Ls(s, r + 4, n).times(0.5), t.s = i.s, t) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
ze.inverseTangent = ze.atan = function() {
  var t, e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new p(c);
    if (c.abs().eq(1) && h + 4 <= Fx)
      return o = Ls(p, h + 4, d).times(0.25), o.s = c.s, o;
  } else {
    if (!c.s) return new p(NaN);
    if (h + 4 <= Fx)
      return o = Ls(p, h + 4, d).times(0.5), o.s = c.s, o;
  }
  for (p.precision = a = h + 10, p.rounding = 1, r = Math.min(28, a / bt + 2 | 0), t = r; t; --t) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (Lt = !1, e = Math.ceil(a / bt), n = 1, l = c.times(c), o = new p(c), i = c; t !== -1; )
    if (i = i.times(l), s = o.minus(i.div(n += 2)), i = i.times(l), o = s.plus(i.div(n += 2)), o.d[e] !== void 0) for (t = e; o.d[t] === s.d[t] && t--; ) ;
  return r && (o = o.times(2 << r - 1)), Lt = !0, gt(o, p.precision = h, p.rounding = d, !0);
};
ze.isFinite = function() {
  return !!this.d;
};
ze.isInteger = ze.isInt = function() {
  return !!this.d && Mn(this.e / bt) > this.d.length - 2;
};
ze.isNaN = function() {
  return !this.s;
};
ze.isNegative = ze.isNeg = function() {
  return this.s < 0;
};
ze.isPositive = ze.isPos = function() {
  return this.s > 0;
};
ze.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
ze.lessThan = ze.lt = function(t) {
  return this.cmp(t) < 0;
};
ze.lessThanOrEqualTo = ze.lte = function(t) {
  return this.cmp(t) < 1;
};
ze.logarithm = ze.log = function(t) {
  var e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding, v = 5;
  if (t == null)
    t = new p(10), e = !0;
  else {
    if (t = new p(t), r = t.d, t.s < 0 || !r || !r[0] || t.eq(1)) return new p(NaN);
    e = t.eq(10);
  }
  if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1))
    return new p(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (e)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      s = i !== 1;
    }
  if (Lt = !1, a = h + v, o = Rl(c, a), n = e ? Ey(p, a + 10) : Rl(t, a), l = or(o, n, a, 1), b0(l.d, i = h, d))
    do
      if (a += 10, o = Rl(c, a), n = e ? Ey(p, a + 10) : Rl(t, a), l = or(o, n, a, 1), !s) {
        +hn(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = gt(l, h + 1, 0));
        break;
      }
    while (b0(l.d, i += 10, d));
  return Lt = !0, gt(l, h, d);
};
ze.minus = ze.sub = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, v = this, m = v.constructor;
  if (t = new m(t), !v.d || !t.d)
    return !v.s || !t.s ? t = new m(NaN) : v.d ? t.s = -t.s : t = new m(t.d || v.s !== t.s ? v : NaN), t;
  if (v.s != t.s)
    return t.s = -t.s, v.plus(t);
  if (c = v.d, d = t.d, a = m.precision, l = m.rounding, !c[0] || !d[0]) {
    if (d[0]) t.s = -t.s;
    else if (c[0]) t = new m(v);
    else return new m(l === 3 ? -0 : 0);
    return Lt ? gt(t, a, l) : t;
  }
  if (r = Mn(t.e / bt), p = Mn(v.e / bt), c = c.slice(), s = p - r, s) {
    for (h = s < 0, h ? (e = c, s = -s, o = d.length) : (e = d, r = p, o = c.length), n = Math.max(Math.ceil(a / bt), o) + 2, s > n && (s = n, e.length = 1), e.reverse(), n = s; n--; ) e.push(0);
    e.reverse();
  } else {
    for (n = c.length, o = d.length, h = n < o, h && (o = n), n = 0; n < o; n++)
      if (c[n] != d[n]) {
        h = c[n] < d[n];
        break;
      }
    s = 0;
  }
  for (h && (e = c, c = d, d = e, t.s = -t.s), o = c.length, n = d.length - o; n > 0; --n) c[o++] = 0;
  for (n = d.length; n > s; ) {
    if (c[--n] < d[n]) {
      for (i = n; i && c[--i] === 0; ) c[i] = Bs - 1;
      --c[i], c[n] += Bs;
    }
    c[n] -= d[n];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --r;
  return c[0] ? (t.d = c, t.e = wv(c, r), Lt ? gt(t, a, l) : t) : new m(l === 3 ? -0 : 0);
};
ze.modulo = ze.mod = function(t) {
  var e, r = this, n = r.constructor;
  return t = new n(t), !r.d || !t.s || t.d && !t.d[0] ? new n(NaN) : !t.d || r.d && !r.d[0] ? gt(new n(r), n.precision, n.rounding) : (Lt = !1, n.modulo == 9 ? (e = or(r, t.abs(), 0, 3, 1), e.s *= t.s) : e = or(r, t, 0, n.modulo, 1), e = e.times(t), Lt = !0, r.minus(e));
};
ze.naturalExponential = ze.exp = function() {
  return zx(this);
};
ze.naturalLogarithm = ze.ln = function() {
  return Rl(this);
};
ze.negated = ze.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s, gt(t);
};
ze.plus = ze.add = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h = this, d = h.constructor;
  if (t = new d(t), !h.d || !t.d)
    return !h.s || !t.s ? t = new d(NaN) : h.d || (t = new d(t.d || h.s === t.s ? h : NaN)), t;
  if (h.s != t.s)
    return t.s = -t.s, h.minus(t);
  if (c = h.d, p = t.d, a = d.precision, l = d.rounding, !c[0] || !p[0])
    return p[0] || (t = new d(h)), Lt ? gt(t, a, l) : t;
  if (s = Mn(h.e / bt), n = Mn(t.e / bt), c = c.slice(), i = s - n, i) {
    for (i < 0 ? (r = c, i = -i, o = p.length) : (r = p, n = s, o = c.length), s = Math.ceil(a / bt), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = c.length, i = p.length, o - i < 0 && (i = o, r = p, p = c, c = r), e = 0; i; )
    e = (c[--i] = c[i] + p[i] + e) / Bs | 0, c[i] %= Bs;
  for (e && (c.unshift(e), ++n), o = c.length; c[--o] == 0; ) c.pop();
  return t.d = c, t.e = wv(c, n), Lt ? gt(t, a, l) : t;
};
ze.precision = ze.sd = function(t) {
  var e, r = this;
  if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(ih + t);
  return r.d ? (e = iN(r.d), t && r.e + 1 > e && (e = r.e + 1)) : e = NaN, e;
};
ze.round = function() {
  var t = this, e = t.constructor;
  return gt(new e(t), t.e + 1, e.rounding);
};
ze.sine = ze.sin = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + bt, n.rounding = 1, r = Kre(n, lN(n, r)), n.precision = t, n.rounding = e, gt(pa > 2 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
ze.squareRoot = ze.sqrt = function() {
  var t, e, r, n, i, s, o = this, a = o.d, l = o.e, c = o.s, p = o.constructor;
  if (c !== 1 || !a || !a[0])
    return new p(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (Lt = !1, c = Math.sqrt(+o), c == 0 || c == 1 / 0 ? (e = hn(a), (e.length + l) % 2 == 0 && (e += "0"), c = Math.sqrt(e), l = Mn((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? e = "1e" + l : (e = c.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + l), n = new p(e)) : n = new p(c.toString()), r = (l = p.precision) + 3; ; )
    if (s = n, n = s.plus(or(o, s, r + 2, 1)).times(0.5), hn(s.d).slice(0, r) === (e = hn(n.d)).slice(0, r))
      if (e = e.slice(r - 3, r + 1), e == "9999" || !i && e == "4999") {
        if (!i && (gt(s, l + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (gt(n, l + 1, 1), t = !n.times(n).eq(o));
        break;
      }
  return Lt = !0, gt(n, l, p.rounding, t);
};
ze.tangent = ze.tan = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = or(r, new n(1).minus(r.times(r)).sqrt(), t + 10, 0), n.precision = t, n.rounding = e, gt(pa == 2 || pa == 4 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
ze.times = ze.mul = function(t) {
  var e, r, n, i, s, o, a, l, c, p = this, h = p.constructor, d = p.d, v = (t = new h(t)).d;
  if (t.s *= p.s, !d || !d[0] || !v || !v[0])
    return new h(!t.s || d && !d[0] && !v || v && !v[0] && !d ? NaN : !d || !v ? t.s / 0 : t.s * 0);
  for (r = Mn(p.e / bt) + Mn(t.e / bt), l = d.length, c = v.length, l < c && (s = d, d = v, v = s, o = l, l = c, c = o), s = [], o = l + c, n = o; n--; ) s.push(0);
  for (n = c; --n >= 0; ) {
    for (e = 0, i = l + n; i > n; )
      a = s[i] + v[n] * d[i - n - 1] + e, s[i--] = a % Bs | 0, e = a / Bs | 0;
    s[i] = (s[i] + e) % Bs | 0;
  }
  for (; !s[--o]; ) s.pop();
  return e ? ++r : s.shift(), t.d = s, t.e = wv(s, r), Lt ? gt(t, h.precision, h.rounding) : t;
};
ze.toBinary = function(t, e) {
  return E5(this, 2, t, e);
};
ze.toDecimalPlaces = ze.toDP = function(t, e) {
  var r = this, n = r.constructor;
  return r = new n(r), t === void 0 ? r : (li(t, 0, kc), e === void 0 ? e = n.rounding : li(e, 0, 8), gt(r, t + r.e + 1, e));
};
ze.toExponential = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Vo(n, !0) : (li(t, 0, kc), e === void 0 ? e = i.rounding : li(e, 0, 8), n = gt(new i(n), t + 1, e), r = Vo(n, !0, t + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
ze.toFixed = function(t, e) {
  var r, n, i = this, s = i.constructor;
  return t === void 0 ? r = Vo(i) : (li(t, 0, kc), e === void 0 ? e = s.rounding : li(e, 0, 8), n = gt(new s(i), t + i.e + 1, e), r = Vo(n, !1, t + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
ze.toFraction = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, v = this, m = v.d, b = v.constructor;
  if (!m) return new b(v);
  if (c = r = new b(1), n = l = new b(0), e = new b(n), s = e.e = iN(m) - v.e - 1, o = s % bt, e.d[0] = Sn(10, o < 0 ? bt + o : o), t == null)
    t = s > 0 ? e : c;
  else {
    if (a = new b(t), !a.isInt() || a.lt(c)) throw Error(ih + a);
    t = a.gt(e) ? s > 0 ? e : c : a;
  }
  for (Lt = !1, a = new b(hn(m)), p = b.precision, b.precision = s = m.length * bt * 2; h = or(a, e, 0, 1, 1), i = r.plus(h.times(n)), i.cmp(t) != 1; )
    r = n, n = i, i = c, c = l.plus(h.times(i)), l = i, i = e, e = a.minus(h.times(i)), a = i;
  return i = or(t.minus(r), n, 0, 1, 1), l = l.plus(i.times(c)), r = r.plus(i.times(n)), l.s = c.s = v.s, d = or(c, n, s, 1).minus(v).abs().cmp(or(l, r, s, 1).minus(v).abs()) < 1 ? [c, n] : [l, r], b.precision = p, Lt = !0, d;
};
ze.toHexadecimal = ze.toHex = function(t, e) {
  return E5(this, 16, t, e);
};
ze.toNearest = function(t, e) {
  var r = this, n = r.constructor;
  if (r = new n(r), t == null) {
    if (!r.d) return r;
    t = new n(1), e = n.rounding;
  } else {
    if (t = new n(t), e === void 0 ? e = n.rounding : li(e, 0, 8), !r.d) return t.s ? r : t;
    if (!t.d)
      return t.s && (t.s = r.s), t;
  }
  return t.d[0] ? (Lt = !1, r = or(r, t, 0, e, 1).times(t), Lt = !0, gt(r)) : (t.s = r.s, r = t), r;
};
ze.toNumber = function() {
  return +this;
};
ze.toOctal = function(t, e) {
  return E5(this, 8, t, e);
};
ze.toPower = ze.pow = function(t) {
  var e, r, n, i, s, o, a = this, l = a.constructor, c = +(t = new l(t));
  if (!a.d || !t.d || !a.d[0] || !t.d[0]) return new l(Sn(+a, c));
  if (a = new l(a), a.eq(1)) return a;
  if (n = l.precision, s = l.rounding, t.eq(1)) return gt(a, n, s);
  if (e = Mn(t.e / bt), e >= t.d.length - 1 && (r = c < 0 ? -c : c) <= Gre)
    return i = sN(l, a, r, n), t.s < 0 ? new l(1).div(i) : gt(i, n, s);
  if (o = a.s, o < 0) {
    if (e < t.d.length - 1) return new l(NaN);
    if (!(t.d[e] & 1) && (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = Sn(+a, c), e = r == 0 || !isFinite(r) ? Mn(c * (Math.log("0." + hn(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, e > l.maxE + 1 || e < l.minE - 1 ? new l(e > 0 ? o / 0 : 0) : (Lt = !1, l.rounding = a.s = 1, r = Math.min(12, (e + "").length), i = zx(t.times(Rl(a, n + r)), n), i.d && (i = gt(i, n + 5, 1), b0(i.d, n, s) && (e = n + 10, i = gt(zx(t.times(Rl(a, e + r)), e), e + 5, 1), +hn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = gt(i, n + 1, 0)))), i.s = o, Lt = !0, l.rounding = s, gt(i, n, s));
};
ze.toPrecision = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Vo(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (li(t, 1, kc), e === void 0 ? e = i.rounding : li(e, 0, 8), n = gt(new i(n), t, e), r = Vo(n, t <= n.e || n.e <= i.toExpNeg, t)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
ze.toSignificantDigits = ze.toSD = function(t, e) {
  var r = this, n = r.constructor;
  return t === void 0 ? (t = n.precision, e = n.rounding) : (li(t, 1, kc), e === void 0 ? e = n.rounding : li(e, 0, 8)), gt(new n(r), t, e);
};
ze.toString = function() {
  var t = this, e = t.constructor, r = Vo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() && !t.isZero() ? "-" + r : r;
};
ze.truncated = ze.trunc = function() {
  return gt(new this.constructor(this), this.e + 1, 1);
};
ze.valueOf = ze.toJSON = function() {
  var t = this, e = t.constructor, r = Vo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() ? "-" + r : r;
};
function hn(t) {
  var e, r, n, i = t.length - 1, s = "", o = t[0];
  if (i > 0) {
    for (s += o, e = 1; e < i; e++)
      n = t[e] + "", r = bt - n.length, r && (s += fl(r)), s += n;
    o = t[e], n = o + "", r = bt - n.length, r && (s += fl(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function li(t, e, r) {
  if (t !== ~~t || t < e || t > r)
    throw Error(ih + t);
}
function b0(t, e, r, n) {
  var i, s, o, a;
  for (s = t[0]; s >= 10; s /= 10) --e;
  return --e < 0 ? (e += bt, i = 0) : (i = Math.ceil((e + 1) / bt), e %= bt), s = Sn(10, bt - e), a = t[i] % s | 0, n == null ? e < 3 ? (e == 0 ? a = a / 100 | 0 : e == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 100 | 0) == Sn(10, e - 2) - 1 || (a == s / 2 || a == 0) && (t[i + 1] / s / 100 | 0) == 0 : e < 4 ? (e == 0 ? a = a / 1e3 | 0 : e == 1 ? a = a / 100 | 0 : e == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 1e3 | 0) == Sn(10, e - 3) - 1, o;
}
function x1(t, e, r) {
  for (var n, i = [0], s, o = 0, a = t.length; o < a; ) {
    for (s = i.length; s--; ) i[s] *= e;
    for (i[0] += jx.indexOf(t.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function qre(t, e) {
  var r, n, i = e.d.length;
  i < 32 ? (r = Math.ceil(i / 3), n = Math.pow(4, -r).toString()) : (r = 16, n = "2.3283064365386962890625e-10"), t.precision += r, e = Gp(t, 1, e.times(n), new t(1));
  for (var s = r; s--; ) {
    var o = e.times(e);
    e = o.times(o).minus(o).times(8).plus(1);
  }
  return t.precision -= r, e;
}
var or = /* @__PURE__ */ function() {
  function t(n, i, s) {
    var o, a = 0, l = n.length;
    for (n = n.slice(); l--; )
      o = n[l] * i + a, n[l] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function e(n, i, s, o) {
    var a, l;
    if (s != o)
      l = s > o ? 1 : -1;
    else
      for (a = l = 0; a < s; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, o, a, l) {
    var c, p, h, d, v, m, b, f, E, A, x, g, w, _, S, R, L, F, z, j, W = n.constructor, te = n.s == i.s ? 1 : -1, le = n.d, ce = i.d;
    if (!le || !le[0] || !ce || !ce[0])
      return new W(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (le ? ce && le[0] == ce[0] : !ce) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          le && le[0] == 0 || !ce ? te * 0 : te / 0
        )
      );
    for (l ? (v = 1, p = n.e - i.e) : (l = Bs, v = bt, p = Mn(n.e / v) - Mn(i.e / v)), z = ce.length, L = le.length, E = new W(te), A = E.d = [], h = 0; ce[h] == (le[h] || 0); h++) ;
    if (ce[h] > (le[h] || 0) && p--, s == null ? (_ = s = W.precision, o = W.rounding) : a ? _ = s + (n.e - i.e) + 1 : _ = s, _ < 0)
      A.push(1), m = !0;
    else {
      if (_ = _ / v + 2 | 0, h = 0, z == 1) {
        for (d = 0, ce = ce[0], _++; (h < L || d) && _--; h++)
          S = d * l + (le[h] || 0), A[h] = S / ce | 0, d = S % ce | 0;
        m = d || h < L;
      } else {
        for (d = l / (ce[0] + 1) | 0, d > 1 && (ce = t(ce, d, l), le = t(le, d, l), z = ce.length, L = le.length), R = z, x = le.slice(0, z), g = x.length; g < z; ) x[g++] = 0;
        j = ce.slice(), j.unshift(0), F = ce[0], ce[1] >= l / 2 && ++F;
        do
          d = 0, c = e(ce, x, z, g), c < 0 ? (w = x[0], z != g && (w = w * l + (x[1] || 0)), d = w / F | 0, d > 1 ? (d >= l && (d = l - 1), b = t(ce, d, l), f = b.length, g = x.length, c = e(b, x, f, g), c == 1 && (d--, r(b, z < f ? j : ce, f, l))) : (d == 0 && (c = d = 1), b = ce.slice()), f = b.length, f < g && b.unshift(0), r(x, b, g, l), c == -1 && (g = x.length, c = e(ce, x, z, g), c < 1 && (d++, r(x, z < g ? j : ce, g, l))), g = x.length) : c === 0 && (d++, x = [0]), A[h++] = d, c && x[0] ? x[g++] = le[R] || 0 : (x = [le[R]], g = 1);
        while ((R++ < L || x[0] !== void 0) && _--);
        m = x[0] !== void 0;
      }
      A[0] || A.shift();
    }
    if (v == 1)
      E.e = p, tN = m;
    else {
      for (h = 1, d = A[0]; d >= 10; d /= 10) h++;
      E.e = h + p * v - 1, gt(E, a ? s + E.e + 1 : s, o, m);
    }
    return E;
  };
}();
function gt(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, v = t.constructor;
  e: if (e != null) {
    if (h = t.d, !h) return t;
    for (i = 1, a = h[0]; a >= 10; a /= 10) i++;
    if (s = e - i, s < 0)
      s += bt, o = e, p = h[d = 0], l = p / Sn(10, i - o - 1) % 10 | 0;
    else if (d = Math.ceil((s + 1) / bt), a = h.length, d >= a)
      if (n) {
        for (; a++ <= d; ) h.push(0);
        p = l = 0, i = 1, s %= bt, o = s - bt + 1;
      } else
        break e;
    else {
      for (p = a = h[d], i = 1; a >= 10; a /= 10) i++;
      s %= bt, o = s - bt + i, l = o < 0 ? 0 : p / Sn(10, i - o - 1) % 10 | 0;
    }
    if (n = n || e < 0 || h[d + 1] !== void 0 || (o < 0 ? p : p % Sn(10, i - o - 1)), c = r < 4 ? (l || n) && (r == 0 || r == (t.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? p / Sn(10, i - o) : 0 : h[d - 1]) % 10 & 1 || r == (t.s < 0 ? 8 : 7)), e < 1 || !h[0])
      return h.length = 0, c ? (e -= t.e + 1, h[0] = Sn(10, (bt - e % bt) % bt), t.e = -e || 0) : h[0] = t.e = 0, t;
    if (s == 0 ? (h.length = d, a = 1, d--) : (h.length = d + 1, a = Sn(10, bt - s), h[d] = o > 0 ? (p / Sn(10, i - o) % Sn(10, o) | 0) * a : 0), c)
      for (; ; )
        if (d == 0) {
          for (s = 1, o = h[0]; o >= 10; o /= 10) s++;
          for (o = h[0] += a, a = 1; o >= 10; o /= 10) a++;
          s != a && (t.e++, h[0] == Bs && (h[0] = 1));
          break;
        } else {
          if (h[d] += a, h[d] != Bs) break;
          h[d--] = 0, a = 1;
        }
    for (s = h.length; h[--s] === 0; ) h.pop();
  }
  return Lt && (t.e > v.maxE ? (t.d = null, t.e = NaN) : t.e < v.minE && (t.e = 0, t.d = [0])), t;
}
function Vo(t, e, r) {
  if (!t.isFinite()) return aN(t);
  var n, i = t.e, s = hn(t.d), o = s.length;
  return e ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + fl(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (t.e < 0 ? "e" : "e+") + t.e) : i < 0 ? (s = "0." + fl(-i - 1) + s, r && (n = r - o) > 0 && (s += fl(n))) : i >= o ? (s += fl(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + fl(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += fl(n))), s;
}
function wv(t, e) {
  var r = t[0];
  for (e *= bt; r >= 10; r /= 10) e++;
  return e;
}
function Ey(t, e, r) {
  if (e > Wre)
    throw Lt = !0, r && (t.precision = r), Error(rN);
  return gt(new t(wy), e, 1, !0);
}
function Ls(t, e, r) {
  if (e > Fx) throw Error(rN);
  return gt(new t(xy), e, r, !0);
}
function iN(t) {
  var e = t.length - 1, r = e * bt + 1;
  if (e = t[e], e) {
    for (; e % 10 == 0; e /= 10) r--;
    for (e = t[0]; e >= 10; e /= 10) r++;
  }
  return r;
}
function fl(t) {
  for (var e = ""; t--; ) e += "0";
  return e;
}
function sN(t, e, r, n) {
  var i, s = new t(1), o = Math.ceil(n / bt + 4);
  for (Lt = !1; ; ) {
    if (r % 2 && (s = s.times(e), E7(s.d, o) && (i = !0)), r = Mn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    e = e.times(e), E7(e.d, o);
  }
  return Lt = !0, s;
}
function w7(t) {
  return t.d[t.d.length - 1] & 1;
}
function oN(t, e, r) {
  for (var n, i = new t(e[0]), s = 0; ++s < e.length; )
    if (n = new t(e[s]), n.s)
      i[r](n) && (i = n);
    else {
      i = n;
      break;
    }
  return i;
}
function zx(t, e) {
  var r, n, i, s, o, a, l, c = 0, p = 0, h = 0, d = t.constructor, v = d.rounding, m = d.precision;
  if (!t.d || !t.d[0] || t.e > 17)
    return new d(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
  for (e == null ? (Lt = !1, l = m) : l = e, a = new d(0.03125); t.e > -2; )
    t = t.times(a), h += 5;
  for (n = Math.log(Sn(2, h)) / Math.LN10 * 2 + 5 | 0, l += n, r = s = o = new d(1), d.precision = l; ; ) {
    if (s = gt(s.times(t), l, 1), r = r.times(++p), a = o.plus(or(s, r, l, 1)), hn(a.d).slice(0, l) === hn(o.d).slice(0, l)) {
      for (i = h; i--; ) o = gt(o.times(o), l, 1);
      if (e == null)
        if (c < 3 && b0(o.d, l - n, v, c))
          d.precision = l += 10, r = s = a = new d(1), p = 0, c++;
        else
          return gt(o, d.precision = m, v, Lt = !0);
      else
        return d.precision = m, o;
    }
    o = a;
  }
}
function Rl(t, e) {
  var r, n, i, s, o, a, l, c, p, h, d, v = 1, m = 10, b = t, f = b.d, E = b.constructor, A = E.rounding, x = E.precision;
  if (b.s < 0 || !f || !f[0] || !b.e && f[0] == 1 && f.length == 1)
    return new E(f && !f[0] ? -1 / 0 : b.s != 1 ? NaN : f ? 0 : b);
  if (e == null ? (Lt = !1, p = x) : p = e, E.precision = p += m, r = hn(f), n = r.charAt(0), Math.abs(s = b.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      b = b.times(t), r = hn(b.d), n = r.charAt(0), v++;
    s = b.e, n > 1 ? (b = new E("0." + r), s++) : b = new E(n + "." + r.slice(1));
  } else
    return c = Ey(E, p + 2, x).times(s + ""), b = Rl(new E(n + "." + r.slice(1)), p - m).plus(c), E.precision = x, e == null ? gt(b, x, A, Lt = !0) : b;
  for (h = b, l = o = b = or(b.minus(1), b.plus(1), p, 1), d = gt(b.times(b), p, 1), i = 3; ; ) {
    if (o = gt(o.times(d), p, 1), c = l.plus(or(o, new E(i), p, 1)), hn(c.d).slice(0, p) === hn(l.d).slice(0, p))
      if (l = l.times(2), s !== 0 && (l = l.plus(Ey(E, p + 2, x).times(s + ""))), l = or(l, new E(v), p, 1), e == null)
        if (b0(l.d, p - m, A, a))
          E.precision = p += m, c = o = b = or(h.minus(1), h.plus(1), p, 1), d = gt(b.times(b), p, 1), i = a = 1;
        else
          return gt(l, E.precision = x, A, Lt = !0);
      else
        return E.precision = x, l;
    l = c, i += 2;
  }
}
function aN(t) {
  return String(t.s * t.s / 0);
}
function x7(t, e) {
  var r, n, i;
  for ((r = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (r = e.length), n = 0; e.charCodeAt(n) === 48; n++) ;
  for (i = e.length; e.charCodeAt(i - 1) === 48; --i) ;
  if (e = e.slice(n, i), e) {
    if (i -= n, t.e = r = r - n - 1, t.d = [], n = (r + 1) % bt, r < 0 && (n += bt), n < i) {
      for (n && t.d.push(+e.slice(0, n)), i -= bt; n < i; ) t.d.push(+e.slice(n, n += bt));
      e = e.slice(n), n = bt - e.length;
    } else
      n -= i;
    for (; n--; ) e += "0";
    t.d.push(+e), Lt && (t.e > t.constructor.maxE ? (t.d = null, t.e = NaN) : t.e < t.constructor.minE && (t.e = 0, t.d = [0]));
  } else
    t.e = 0, t.d = [0];
  return t;
}
function Qre(t, e) {
  var r, n, i, s, o, a, l, c, p;
  if (e === "Infinity" || e === "NaN")
    return +e || (t.s = NaN), t.e = NaN, t.d = null, t;
  if (Ure.test(e))
    r = 16, e = e.toLowerCase();
  else if (zre.test(e))
    r = 2;
  else if (Vre.test(e))
    r = 8;
  else
    throw Error(ih + e);
  for (s = e.search(/p/i), s > 0 ? (l = +e.slice(s + 1), e = e.substring(2, s)) : e = e.slice(2), s = e.indexOf("."), o = s >= 0, n = t.constructor, o && (e = e.replace(".", ""), a = e.length, s = a - s, i = sN(n, new n(r), s, s * 2)), c = x1(e, r, Bs), p = c.length - 1, s = p; c[s] === 0; --s) c.pop();
  return s < 0 ? new n(t.s * 0) : (t.e = wv(c, p), t.d = c, Lt = !1, o && (t = or(t, i, a * 4)), l && (t = t.times(Math.abs(l) < 54 ? Math.pow(2, l) : _g.pow(2, l))), Lt = !0, t);
}
function Kre(t, e) {
  var r, n = e.d.length;
  if (n < 3) return Gp(t, 2, e, e);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, e = e.times(Math.pow(5, -r)), e = Gp(t, 2, e, e);
  for (var i, s = new t(5), o = new t(16), a = new t(20); r--; )
    i = e.times(e), e = e.times(s.plus(i.times(o.times(i).minus(a))));
  return e;
}
function Gp(t, e, r, n, i) {
  var s, o, a, l, c = t.precision, p = Math.ceil(c / bt);
  for (Lt = !1, l = r.times(r), a = new t(n); ; ) {
    if (o = or(a.times(l), new t(e++ * e++), c, 1), a = i ? n.plus(o) : n.minus(o), n = or(o.times(l), new t(e++ * e++), c, 1), o = a.plus(n), o.d[p] !== void 0) {
      for (s = p; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = n, n = o, o = s;
  }
  return Lt = !0, o.d.length = p + 1, o;
}
function lN(t, e) {
  var r, n = e.s < 0, i = Ls(t, t.precision, 1), s = i.times(0.5);
  if (e = e.abs(), e.lte(s))
    return pa = n ? 4 : 1, e;
  if (r = e.divToInt(i), r.isZero())
    pa = n ? 3 : 2;
  else {
    if (e = e.minus(r.times(i)), e.lte(s))
      return pa = w7(r) ? n ? 2 : 3 : n ? 4 : 1, e;
    pa = w7(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return e.minus(i).abs();
}
function E5(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, v = t.constructor, m = r !== void 0;
  if (m ? (li(r, 1, kc), n === void 0 ? n = v.rounding : li(n, 0, 8)) : (r = v.precision, n = v.rounding), !t.isFinite())
    p = aN(t);
  else {
    for (p = Vo(t), o = p.indexOf("."), m ? (i = 2, e == 16 ? r = r * 4 - 3 : e == 8 && (r = r * 3 - 2)) : i = e, o >= 0 && (p = p.replace(".", ""), d = new v(1), d.e = p.length - o, d.d = x1(Vo(d), 10, i), d.e = d.d.length), h = x1(p, 10, i), s = l = h.length; h[--l] == 0; ) h.pop();
    if (!h[0])
      p = m ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (t = new v(t), t.d = h, t.e = s, t = or(t, d, r, n, 0, i), h = t.d, s = t.e, c = tN), o = h[r], a = i / 2, c = c || h[r + 1] !== void 0, c = n < 4 ? (o !== void 0 || c) && (n === 0 || n === (t.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || c || n === 6 && h[r - 1] & 1 || n === (t.s < 0 ? 8 : 7)), h.length = r, c)
        for (; ++h[--r] > i - 1; )
          h[r] = 0, r || (++s, h.unshift(1));
      for (l = h.length; !h[l - 1]; --l) ;
      for (o = 0, p = ""; o < l; o++) p += jx.charAt(h[o]);
      if (m) {
        if (l > 1)
          if (e == 16 || e == 8) {
            for (o = e == 16 ? 4 : 3, --l; l % o; l++) p += "0";
            for (h = x1(p, i, e), l = h.length; !h[l - 1]; --l) ;
            for (o = 1, p = "1."; o < l; o++) p += jx.charAt(h[o]);
          } else
            p = p.charAt(0) + "." + p.slice(1);
        p = p + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) p = "0" + p;
        p = "0." + p;
      } else if (++s > l) for (s -= l; s--; ) p += "0";
      else s < l && (p = p.slice(0, s) + "." + p.slice(s));
    }
    p = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + p;
  }
  return t.s < 0 ? "-" + p : p;
}
function E7(t, e) {
  if (t.length > e)
    return t.length = e, !0;
}
function Yre(t) {
  return new this(t).abs();
}
function Zre(t) {
  return new this(t).acos();
}
function Jre(t) {
  return new this(t).acosh();
}
function Xre(t, e) {
  return new this(t).plus(e);
}
function ene(t) {
  return new this(t).asin();
}
function tne(t) {
  return new this(t).asinh();
}
function rne(t) {
  return new this(t).atan();
}
function nne(t) {
  return new this(t).atanh();
}
function ine(t, e) {
  t = new this(t), e = new this(e);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !t.s || !e.s ? r = new this(NaN) : !t.d && !e.d ? (r = Ls(this, s, 1).times(e.s > 0 ? 0.25 : 0.75), r.s = t.s) : !e.d || t.isZero() ? (r = e.s < 0 ? Ls(this, n, i) : new this(0), r.s = t.s) : !t.d || e.isZero() ? (r = Ls(this, s, 1).times(0.5), r.s = t.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(or(t, e, s, 1)), e = Ls(this, s, 1), this.precision = n, this.rounding = i, r = t.s < 0 ? r.minus(e) : r.plus(e)) : r = this.atan(or(t, e, s, 1)), r;
}
function sne(t) {
  return new this(t).cbrt();
}
function one(t) {
  return gt(t = new this(t), t.e + 1, 2);
}
function ane(t) {
  if (!t || typeof t != "object") throw Error(bv + "Object expected");
  var e, r, n, i = t.defaults === !0, s = [
    "precision",
    1,
    kc,
    "rounding",
    0,
    8,
    "toExpNeg",
    -9e15,
    0,
    "toExpPos",
    0,
    $x,
    "maxE",
    0,
    $x,
    "minE",
    -9e15,
    0,
    "modulo",
    0,
    9
  ];
  for (e = 0; e < s.length; e += 3)
    if (r = s[e], i && (this[r] = Bx[r]), (n = t[r]) !== void 0)
      if (Mn(n) === n && n >= s[e + 1] && n <= s[e + 2]) this[r] = n;
      else throw Error(ih + r + ": " + n);
  if (r = "crypto", i && (this[r] = Bx[r]), (n = t[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(nN);
      else
        this[r] = !1;
    else
      throw Error(ih + r + ": " + n);
  return this;
}
function lne(t) {
  return new this(t).cos();
}
function cne(t) {
  return new this(t).cosh();
}
function cN(t) {
  var e, r, n;
  function i(s) {
    var o, a, l, c = this;
    if (!(c instanceof i)) return new i(s);
    if (c.constructor = i, s instanceof i) {
      c.s = s.s, c.e = s.e, c.d = (s = s.d) ? s.slice() : s;
      return;
    }
    if (l = typeof s, l === "number") {
      if (s === 0) {
        c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        c.e = o, c.d = [s];
        return;
      } else if (s * 0 !== 0) {
        s || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return x7(c, s.toString());
    } else if (l !== "string")
      throw Error(ih + s);
    return s.charCodeAt(0) === 45 ? (s = s.slice(1), c.s = -1) : c.s = 1, Hre.test(s) ? x7(c, s) : Qre(c, s);
  }
  if (i.prototype = ze, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = ane, i.clone = cN, i.isDecimal = fne, i.abs = Yre, i.acos = Zre, i.acosh = Jre, i.add = Xre, i.asin = ene, i.asinh = tne, i.atan = rne, i.atanh = nne, i.atan2 = ine, i.cbrt = sne, i.ceil = one, i.cos = lne, i.cosh = cne, i.div = une, i.exp = hne, i.floor = pne, i.hypot = dne, i.ln = gne, i.log = mne, i.log10 = vne, i.log2 = yne, i.max = bne, i.min = wne, i.mod = xne, i.mul = Ene, i.pow = Sne, i.random = Ane, i.round = kne, i.sign = _ne, i.sin = Cne, i.sinh = Ine, i.sqrt = Pne, i.sub = Rne, i.tan = One, i.tanh = Tne, i.trunc = Lne, t === void 0 && (t = {}), t && t.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; ) t.hasOwnProperty(r = n[e++]) || (t[r] = this[r]);
  return i.config(t), i;
}
function une(t, e) {
  return new this(t).div(e);
}
function hne(t) {
  return new this(t).exp();
}
function pne(t) {
  return gt(t = new this(t), t.e + 1, 3);
}
function dne() {
  var t, e, r = new this(0);
  for (Lt = !1, t = 0; t < arguments.length; )
    if (e = new this(arguments[t++]), e.d)
      r.d && (r = r.plus(e.times(e)));
    else {
      if (e.s)
        return Lt = !0, new this(1 / 0);
      r = e;
    }
  return Lt = !0, r.sqrt();
}
function fne(t) {
  return t instanceof _g || t && t.name === "[object Decimal]" || !1;
}
function gne(t) {
  return new this(t).ln();
}
function mne(t, e) {
  return new this(t).log(e);
}
function yne(t) {
  return new this(t).log(2);
}
function vne(t) {
  return new this(t).log(10);
}
function bne() {
  return oN(this, arguments, "lt");
}
function wne() {
  return oN(this, arguments, "gt");
}
function xne(t, e) {
  return new this(t).mod(e);
}
function Ene(t, e) {
  return new this(t).mul(e);
}
function Sne(t, e) {
  return new this(t).pow(e);
}
function Ane(t) {
  var e, r, n, i, s = 0, o = new this(1), a = [];
  if (t === void 0 ? t = this.precision : li(t, 1, kc), n = Math.ceil(t / bt), this.crypto)
    if (crypto.getRandomValues)
      for (e = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = e[s], i >= 429e7 ? e[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (e = crypto.randomBytes(n *= 4); s < n; )
        i = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((e[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(nN);
  else for (; s < n; ) a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], t %= bt, n && t && (i = Sn(10, bt - t), a[s] = (n / i | 0) * i); a[s] === 0; s--) a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= bt) a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
    n < bt && (r -= bt - n);
  }
  return o.e = r, o.d = a, o;
}
function kne(t) {
  return gt(t = new this(t), t.e + 1, this.rounding);
}
function _ne(t) {
  return t = new this(t), t.d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN;
}
function Cne(t) {
  return new this(t).sin();
}
function Ine(t) {
  return new this(t).sinh();
}
function Pne(t) {
  return new this(t).sqrt();
}
function Rne(t, e) {
  return new this(t).sub(e);
}
function One(t) {
  return new this(t).tan();
}
function Tne(t) {
  return new this(t).tanh();
}
function Lne(t) {
  return gt(t = new this(t), t.e + 1, 1);
}
var _g = cN(Bx);
wy = new _g(wy);
xy = new _g(xy);
function Mne(t) {
  let e = 0.01;
  switch (!0) {
    case t.gte(1e12):
      e = 1e12;
      break;
    case t.gte(1e9):
      e = 1e9;
      break;
    case t.gte(1e6):
      e = 1e6;
      break;
    case t.gte(1e3):
      e = 1e3;
      break;
    case t.gte(1):
      e = 1;
      break;
  }
  return { number: t.div(e).toNumber(), scale: e };
}
function Nne(t) {
  if (t.length < 2)
    return t.length;
  const e = [];
  e: for (const r of t) {
    for (const n of e)
      if (r.equals(n))
        continue e;
    e.push(r);
  }
  return e.length;
}
function Dne(t, e) {
  return t.cmp(e);
}
function $ne(t) {
  const e = t.map((a) => a.number * a.scale), r = new Set(e).size, n = e.map((a) => new _g(a));
  let i = !0, s = 3, o = [];
  for (; i; ) {
    o = n.map((l) => l.toSD(s));
    const a = Nne(o);
    r === a ? i = !1 : s++, s === 10 && (i = !1);
  }
  return o.map((a, l) => ({ ...Mne(a), roundingDirection: Dne(a, n[l]) }));
}
function uN(t, e) {
  const r = e.map((a) => a.facetValueAsNumber(t)), n = Math.min(...r), i = Math.max(...r), s = e.filter((a) => a.facetValueAsNumber(t) === n), o = e.filter((a) => a.facetValueAsNumber(t) === i);
  return {
    min: { value: n, datapoints: s },
    max: { value: i, datapoints: o },
    range: i - n,
    mean: Uo(r),
    median: $re(r),
    mode: Lre(r)
  };
}
function jne(t, e) {
  const r = e.map((n) => ({ number: n, scale: t }));
  return $ne(r);
}
function Bne(t, e, r) {
  const n = [], i = [];
  for (const d of t) {
    n.push(...d.datapoints.map((m) => m.facetValue("y")));
    const v = d.getFacetStats("y");
    i.push(
      d.datapoints[0].facetValue("y"),
      d.datapoints.at(-1).facetValue("y"),
      v.max.value,
      v.min.value
    );
  }
  const s = n.concat(i);
  s.push(...e.map((d) => d.value));
  const o = jne(r ?? 1, s);
  let a = t[0].length;
  const l = {};
  for (let d = 0; d < t.length; d++) {
    const v = t[d];
    l[v.key] = o.slice(d * a, d + 1 * a);
  }
  let c = t.length * a;
  a = 4;
  const p = {};
  for (let d = 0; d < t.length; d++) {
    const v = t[d];
    p[v.key] = {
      start: o[d * a + c],
      end: o[d * a + c + 1],
      max: o[d * a + c + 2],
      min: o[d * a + c + 3]
    };
  }
  c += t.length * 4;
  const h = o.slice(c);
  return [l, p, h];
}
function Fne(t, e) {
  if (!ZM((r, n) => r === n, Object.keys(t), Object.keys(e)))
    return !1;
  for (const r in t)
    if (!t[r].isEqual(e[r]))
      return !1;
  return !0;
}
class zne {
  constructor(e) {
    if (this.facets = e, this.facetKeyIndexMap = {}, this.facets.length === 0)
      throw new Error("dataframes must have at least 1 column");
    this.columns = Gu(this.facets.length, (r) => []), this.facets.forEach((r, n) => {
      this.facetKeyIndexMap[r.key] = n;
    });
  }
  addDatapoint(e) {
    const r = Object.keys(e).length;
    if (r !== this.nColumns)
      throw new Error(`datapoint ${e} cannot be added to dataframe. This dataframe has ${this.nColumns} columns, but this datapoint as ${r} facets`);
    Gu(this.nColumns, (n) => {
      const i = this.facets[n], s = e[i.key];
      if (s === void 0)
        throw new Error(`datapoint ${e} is missing the facet ${i.key}`);
      this.columns[n].push(new Ire[i.datatype](s));
    });
  }
  get nRows() {
    return this.columns[0].length;
  }
  get nColumns() {
    return this.columns.length;
  }
  get rows() {
    return Gu(this.nRows, (e) => {
      const r = {};
      return this.columns.forEach((n, i) => {
        r[this.facets[i].key] = n[e];
      }), r;
    });
  }
  facet(e) {
    return this.columns[this.facetKeyIndexMap[e]] ?? null;
  }
  /** Iterate over the rows, producing DataFrames of one row. */
  /* *[Symbol.iterator]() {
    for (let i = 0; i < this.nRows; i++) {
      yield [i, this.slice(i, i + 1)] as [number, DataFrame];
    }
  }*/
  /** Iterate over the columns, producing Series. */
  /*get iterCols() {
      return new ColumnIterable(this.data);
    }
  
    private checkRowBounds(row: number) {
      if (row < 0) {
        if (row < -this.nRows) {
          throw new Error(`row index '${row}' out of bounds`);
        }
        row = this.data[0].length + row;
      } else if (row >= this.nRows) {
        throw new Error(`row index '${row}' out of bounds`);
      }
    }*/
  /**
   * Retrieve the row at the given index as a series.
   * @param row - The row.
   * @remarks
   * Will fail if all columns are not of the same type.
   */
  /*row(row: number) {
      this.checkRowBounds(row);
      if (this.data.length === 0) {
        throw new Error('data frame has no columns');
      }
      const type = this.data[0].dtype;
      this.data.slice(1).forEach(series => {
        if (series.dtype !== type) {
          throw new Error(`all columns must have type '${type}'`);
        }
      }); 
      return new seriesTypes[type](this.data.map(series => series.at(row)) as ScalarArray);
    }
  
    col(name: string) {
      const series = this.data.find(series => series.name === name);
      if (!series) {  
        throw new Error(`no column with name '${name}'`);
      }
      return series;
    }
  
    slice(start?: number, end?: number) {
      return new DataFrame(
        this.data.map(series => series.slice(start, end)));
    }
  
    at(row: number, col: string) {
      this.checkRowBounds(row);
      const series = this.data.find(series => series.name === col);
      if (!series) {
        throw new Error(`no column with name '${col}'`);
      }
      return series.atBoxed(row);
    }
  
    private assertColsExist(colNames: string[]) {
      const existingColNames = this.data.map(series => series.name!);
      colNames.forEach(name => {
        if (!existingColNames.includes(name)) {
          throw new Error(`no such column '${name}'`);
        }
      });
    }
  
    takeCols(colNames: string[]) {
      this.assertColsExist(colNames);
      return new DataFrame(colNames.map(name => this.col(name)!));
    }
  
    dropCols(colNames: string[]) {
      this.assertColsExist(colNames);
      const existingColNames = this.data.map(series => series.name!);
      return new DataFrame(
        existingColNames
          .filter(name => !colNames.includes(name))
          .map(name => this.col(name)!));
    }
  
    map<T>(fn: (el: DataFrame, index: number) => T): T[] {
      const out: T[] = [];
      for (const [i, row] of this) {
        out.push(fn(row, i));
      }
      return out;
    }
  
    mapCols<T>(fn: (el: Series<Scalar>, index: number) => T): T[] {
      const out: T[] = [];
      for (const [i, col] of this.iterCols) {
        out.push(fn(col, i));
      }
      return out;
    }*/
}
var Une = Object.defineProperty, Vne = Object.getOwnPropertyDescriptor, xv = (t, e, r, n) => {
  for (var i = Vne(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && Une(e, r, i), i;
};
let Id = class {
  constructor(e, r, n) {
    this.data = e, this.seriesKey = r, this.datapointIndex = n;
  }
  entries() {
    return Object.entries(this.data)[Symbol.iterator]();
  }
  facetBox(e) {
    return this.data[e] ?? null;
  }
  facetValue(e) {
    return this.data[e].value ?? null;
  }
  facetValueAsNumber(e) {
    const r = this.data[e];
    return r === void 0 || !r.isNumberLike() ? null : r.asNumber();
  }
  facetValueNumericized(e) {
    const r = this.data[e];
    return r === void 0 ? null : r.isNumber() ? r.value : r.isDate() ? r.asNumber() : this.datapointIndex;
  }
  convertFacetValuesToXYForLine(e, r) {
    const n = this.facetValueNumericized(e), i = this.facetValueNumericized(r);
    return n === null || i === null ? null : { x: n, y: i };
  }
  equals(e) {
    return Fne(this.data, e.data) && this.seriesKey === e.seriesKey && this.datapointIndex === e.datapointIndex;
  }
  getNavcode() {
    return `datapoint-${this.seriesKey}-${this.datapointIndex}`;
  }
};
xv([
  yr()
], Id.prototype, "facetValueAsNumber");
xv([
  yr()
], Id.prototype, "facetValueNumericized");
xv([
  yr()
], Id.prototype, "convertFacetValuesToXYForLine");
xv([
  yr()
], Id.prototype, "getNavcode");
class Hne extends Id {
  constructor(e, r, n, i, s) {
    if (super(e, r, n), this.indepKey = i, this.depKey = s, !(i in e))
      throw new Error(`'PlaneDatapoint' is missing the '${i}' independent axis facet value`);
    if (!(s in e))
      throw new Error(`'PlaneDatapoint' is missing the '${s}' dependent axis facet value`);
  }
  get indepBox() {
    return this.data[this.indepKey];
  }
  get depBox() {
    return this.data[this.depKey];
  }
  // TODO: Is this needed any more with PlaneSeries?
  convertToActualXYForLine() {
    return this.convertFacetValuesToXYForLine(this.indepKey, this.depKey);
  }
}
var Gne = Object.defineProperty, Wne = Object.getOwnPropertyDescriptor, Qa = (t, e, r, n) => {
  for (var i = Wne(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && Gne(e, r, i), i;
};
let ta = class {
  constructor(e, r, n, i, s) {
    this.manifest = e, this.rawData = r, this.facetSignatures = n, this.indepKey = i, this.depKey = s, this.datapoints = [], this.facetKeys = [], this._uniqueValuesForFacetMappedByKey = {}, this._facetDatatypeMappedByKey = {}, this.originalKey = this.manifest.key, this.key = lJ(this.originalKey), this.label = this.manifest.label ?? this.originalKey, this.facetSignatures.forEach((o) => {
      this.facetKeys.push(o.key), this._uniqueValuesForFacetMappedByKey[o.key] = new JM(), this._facetDatatypeMappedByKey[o.key] = o.datatype;
    }), this._dataframe = new zne(n), this.length = this.rawData.length, this.rawData.forEach((o) => this._dataframe.addDatapoint(o)), this._dataframe.rows.forEach((o, a) => {
      const l = this.constructDatapoint(o, this.key, a);
      this[a] = l, this.datapoints.push(l), Object.keys(o).forEach(
        (c) => this._uniqueValuesForFacetMappedByKey[c].add(o[c])
      );
    });
  }
  constructDatapoint(e, r, n) {
    return new Id(e, r, n);
  }
  facetBoxes(e) {
    return this._dataframe.facet(e);
  }
  allFacetValues(e) {
    var r;
    return ((r = this._uniqueValuesForFacetMappedByKey[e]) == null ? void 0 : r.values) ?? null;
  }
  getFacetDatatype(e) {
    return this._facetDatatypeMappedByKey[e] ?? null;
  }
  createLineFromFacets(e, r) {
    if (!this.facetKeys.includes(e) || !this.facetKeys.includes(r))
      return null;
    const n = this.datapoints.map((i) => i.convertFacetValuesToXYForLine(e, r));
    return new u0(n, this.key);
  }
  facetAverage(e) {
    const r = this._facetDatatypeMappedByKey[e];
    return Nx(r) ? Uo(this.datapoints.map((n) => n.facetValueAsNumber(e))) : null;
  }
  getFacetStats(e) {
    const r = this._facetDatatypeMappedByKey[e];
    return Nx(r) ? uN(e, this.datapoints) : null;
  }
  [Symbol.iterator]() {
    return this.datapoints[Symbol.iterator]();
  }
  // Assumes at most one datapoint at that value at that facet
  datapointAt(e, r) {
    const n = this._facetDatatypeMappedByKey[e];
    if (n === void 0 || r.datatype() !== n)
      return null;
    for (const i of this.datapoints)
      if (i.facetBox(e).isEqual(r))
        return i;
    return null;
  }
  getLabel() {
    return this.label ? this.label : this.key;
  }
};
Qa([
  yr()
], ta.prototype, "facetBoxes");
Qa([
  yr()
], ta.prototype, "allFacetValues");
Qa([
  yr()
], ta.prototype, "getFacetDatatype");
Qa([
  yr()
], ta.prototype, "createLineFromFacets");
Qa([
  yr()
], ta.prototype, "facetAverage");
Qa([
  yr()
], ta.prototype, "getFacetStats");
Qa([
  yr()
], ta.prototype, "getLabel");
let Ev = class extends ta {
  /*protected xMap: Map<ScalarMap[X], number[]>;
  private yMap: Map<number, ScalarMap[X][]>;*/
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), console.assert(this.facetKeys.includes(i), `[ParaModel/Internal]: PlaneSeries constructed with unknown indepKey ${i}`), console.assert(this.facetKeys.includes(s), `[ParaModel/Internal]: PlaneSeries constructed with unknown depKey ${s}`), console.assert(Nx(this.getFacetDatatype(s)), `[ParaModel/Internal]: PlaneSeries depKey ${s} has non-number-like ${this.getFacetDatatype(s)} datatype`);
  }
  constructDatapoint(e, r, n) {
    return new Hne(e, r, n, this.indepKey, this.depKey);
  }
  getActualLine() {
    return this.createLineFromFacets(this.indepKey, this.depKey);
  }
  getIndepAverage() {
    return this.facetAverage(this.indepKey);
  }
  // TODO: Add This
  /*@Memoize()
  public getAnalyzer(): SingleSeriesMetadataAnalyzer {
    return new BasicSingleSeriesAnalyzer(this.createActualLine());
  }*/
  /*atX(x: ScalarMap[X]): number[] | null {
      return this.xMap.get(x) ?? null;
    }
  
    atY(y: number): ScalarMap[X][] | null {
      return this.yMap.get(y) ?? null;
    }*/
};
Qa([
  yr()
], Ev.prototype, "getActualLine");
Qa([
  yr()
], Ev.prototype, "getIndepAverage");
function qne(t, e) {
  if (!t.records)
    throw new Error("only series manifests with inline data can use this method.");
  return new ta(t, t.records, e);
}
function Qne(t, e, r, n) {
  if (!t.records)
    throw new Error("only series manifests with inline data can use this method.");
  return new Ev(
    t,
    t.records,
    e,
    r,
    n
  );
}
const Wu = {
  numPointsNotEqual: 0,
  segStartNotBeforeEnd: 1,
  seriesWithoutKey: 2
}, Kne = {
  [Wu.numPointsNotEqual]: "number of points in each time series must be equal",
  [Wu.segStartNotBeforeEnd]: "The start x value of a segment must be less than the end x value of the segment.",
  [Wu.seriesWithoutKey]: "Every series must have a key"
};
let Sy = class extends Error {
  /**
   * Constructs the Err class
   * @param code - The code of the error
   */
  constructor(e) {
    super(Kne[e]), this.code = e;
  }
};
function S7(t, e) {
  return { start: t.points[e], end: t.points[e + 1] };
}
let hN = class {
  constructor(e, r, n) {
    if (this.series1 = e, this.series2 = r, e.length !== r.length)
      throw new Sy(Wu.numPointsNotEqual);
    this.allSegPairProps = Gu(
      e.length - 1,
      (o) => this.checkIntersection(S7(e, o), S7(r, o), n, o)
    ), this.intersectingSegPairs = this.getIntersections(), this.parallelSegPairs = this.getParallelSegPairs();
    const { dominant: i, timeOnTop: s } = this.findDominant();
    this.dominant = i, this.timeOnTop = s, this.averageGap = e.points.map((o, a) => Math.abs(o.y - r.points[a].y)).reduce((o, a) => o + a, 0) / e.length;
  }
  // This is public only for testing
  getIntersections() {
    return this.allSegPairProps.filter((e) => e.intersection !== "None");
  }
  getParallelSegPairs() {
    return this.allSegPairProps.filter(
      (e) => e.relationship === 3 || e.relationship === 4
      /* FunctionallyParallel */
    );
  }
  findDominant() {
    const e = this.series1.points[1].x - this.series1.points[0].x;
    let r = 0;
    this.allSegPairProps.forEach((i, s) => {
      const o = i.segs;
      if (i.relationship === 0) {
        const a = i.intersection;
        a.crosspoint.x === o[0].start.x ? o[0].end.y > o[1].end.y && (r += e) : a.crosspoint.x === o[0].end.x ? o[0].start.y > o[1].start.y && (r += e) : o[0].start.y > o[1].start.y ? r += a.crosspoint.x - o[0].start.x : r += o[0].end.x - a.crosspoint.x;
      } else i.relationship !== 2 && o[0].start.y > o[1].start.y && (r += e);
    }), r /= this.series1.points.at(-1).x - this.series1.points[0].x;
    const n = r > 0.5 ? 1 : r < 0.5 ? 2 : -1;
    return { dominant: n, timeOnTop: n === 1 ? r : 1 - r };
  }
  /**
   * Check for the relationship between two lines. 
   * Uses a vector cross-product approach described on StackOverflow:
   * http://stackoverflow.com/a/565282/786339
   */
  // This is only public for testing
  checkIntersection(e, r, n, i) {
    const s = this.findSlope(e, n), o = this.findSlope(r, n);
    let a = {
      i,
      segs: [e, r],
      relationship: 1,
      slopes: {
        a: s,
        b: o
      },
      category: "",
      //TODO: add categories?
      intersection: "None"
    };
    return Math.max(e.start.y, e.end.y) < Math.min(r.start.y, r.end.y) || Math.min(e.start.y, e.end.y) > Math.max(r.start.y, r.end.y) ? a.relationship = this.getParallelApproximation(a.slopes.a, a.slopes.b) : e.start.y === r.start.y || e.end.y === r.end.y ? e.end.y !== r.end.y || e.start.y !== r.start.y ? (a.relationship = 0, a.intersection = {
      crosspoint: e.end.y !== r.end.y ? e.start : e.end,
      angle: this.findAngle(s, o),
      atRecord: !0
    }) : (a.relationship = 2, a.intersection = "Overlap") : this.calculateLineIntersectionPoints(e, r, a), a;
  }
  /**
   * Check for the relationship between two lines. 
   * Uses a vector cross-product approach described on StackOverflow:
   * http://stackoverflow.com/a/565282/786339
   *  
   * The formula expressed in this module takes advantage of vector representations for number lines. 
   * A typical numberline is expressed in start and end points on an x, y plane or axis.Example line:
   * 
   * p (1,2) as the startpoint
   * p2 (3,6) as the endpoint 
   * 
   * Points on a number line can also be expressed as a 2 x 1 vector
   *  p = |1|
   *      |2|
   * 
   * And therefore line segments are expressed by vector addition: 
   * p + r where 
   * p = original point on the number line.
   * r = the transformation. This can de thought of as the difference, or change between point p and point p2.
   * 
   * this means r = p2 - p.    
   * 
   * so in the above points r = (2, 3) of r = |2|
   *                                          |3|
   *   
   * p in this case is the same as the above. It is the startpoint of the number line.
   * 
   * The rest of this function references the above formula fairly closely. 
   */
  calculateLineIntersectionPoints(e, r, n) {
    const i = this.subtractPoints(e.end, e.start), s = this.subtractPoints(r.end, r.start), o = this.crossProduct(this.subtractPoints(r.start, e.start), i), a = this.crossProduct(i, s);
    if (a === 0 && o !== 0)
      n.relationship = 3;
    else {
      const l = o / a, c = this.crossProduct(this.subtractPoints(r.start, e.start), i) / a;
      if (c >= 0 && c <= 1 && l >= 0 && l <= 1) {
        let p = { x: i.x * c, y: i.y * c };
        const h = this.addPoints(p, e.start);
        n.relationship = 0, n.intersection = {
          crosspoint: h,
          //NOTE: the left and right angles here will be the same
          angle: this.findAngle(n.slopes.a, n.slopes.b),
          atRecord: !1
        };
      } else
        this.getParallelApproximation(n.slopes.a, n.slopes.b);
    }
  }
  /**
   */
  getParallelApproximation(e, r) {
    const n = Vf(e), i = Vf(r), s = 5, o = Math.abs(n - i);
    return n === i ? 3 : o < s ? 4 : 1;
  }
  /**
   * Find the apparent slope/gradient of a segment, scaled to the x and y ranges that the graph displays.
   *   NOTE:  run can always be considered 1, as the two points of a segment are adjacent.
   *   NOTE: Horizontal lines are 0. Verticle lines are impossible, as x1 must be strictly greater than x2.
   * @returns the slope as a float.
   */
  findSlope(e, r) {
    if (e.end.x <= e.start.x)
      throw new Sy(Wu.segStartNotBeforeEnd);
    const n = (e.end.y - e.start.y) * r;
    return n === 0 ? 0 : n / 1;
  }
  /**
   * Calculate the cross product of two points.
   * @param point1 - point object with x and y coordinates
   * @param point2 - point object with x and y coordinates
   * @returns The cross product result as a float
   */
  crossProduct(e, r) {
    return e.x * r.y - e.y * r.x;
  }
  /**
   * Subtracts the second point from the first.
   * @param point1 - point object with x and y coordinates
   * @param point2 - point object with x and y coordinates
   * @returns The subtraction result as a point object
   */
  subtractPoints(e, r) {
    return { x: e.x - r.x, y: e.y - r.y };
  }
  /**
   * Add two points.
   * @param point1 - point object with x and y coordinates
   * @param point2 - point object with x and y coordinates
   * @returns The addition result as a point object
   */
  addPoints(e, r) {
    return {
      x: Number((e.x + r.x).toFixed(3)),
      y: Number((e.y + r.y).toFixed(3))
    };
  }
  getSlopeClass(e) {
    return e > 0 ? "positive" : e < 0 ? "negative" : "zero";
  }
  oppositeSlopes(e, r) {
    return e === "positive" && r === "negative" || r === "positive" && e === "negative";
  }
  // NOTE: if lineAt45DegreesY == startTopY then acuteAngle == obtuseAngle == 90
  findAngle(e, r) {
    const n = this.findLineIntersectionAngle(e, r), i = this.getSlopeClass(e), s = this.getSlopeClass(r);
    if (this.oppositeSlopes(i, s)) {
      const [o, a] = i === "positive" ? [e, r] : [r, e], l = -1 / a;
      if (o > l)
        return 180 - n;
    }
    return n;
  }
  /**
   * Finds the acute angle of intersection between two line segments, using their slopes. 
   *   Note that parallel and colinear lines will return an angle of 0.
   * @param m1 - the numeric value of the first slope.
   * @param m2 - the numeric value of the second slope.
   * @returns the acute angle of intersection in degrees.
   */
  findLineIntersectionAngle(e, r) {
    const n = Math.abs((r - e) / (1 + e * r));
    return Vf(n);
  }
}, pN = class {
  //screenCoordSysSize: [xScreenSize, yScreenSize], only ratio matters
  constructor(e, r, n, i) {
    const s = r[0] / r[1], o = e[0].length - 1;
    n = n ?? 0, i = i ?? Math.max(...e.map((c) => c.yBounds().end));
    const a = o / (i - n);
    this.yScale = a * s, this.intersections = [], this.overlaps = [], this.parallels = [], this.pairs = [], this.trackingGroups = [], this.trackingZones = [], this.clusters = [], this.clusterOutliers = [];
    const l = e.length;
    if (l !== 1)
      for (let c = 0; c < l - 1; c++) {
        const p = e[c];
        if (p.key === void 0)
          throw new Sy(Wu.seriesWithoutKey);
        for (let h = c + 1; h < l; h++) {
          const d = e[h];
          if (d.key === void 0)
            throw new Sy(Wu.seriesWithoutKey);
          const v = [p.key, d.key], m = new hN(p, d, this.yScale), b = m.intersectingSegPairs;
          for (let _ = 0; _ < b.length; _++) {
            const S = b[_];
            if (S.relationship === 2)
              continue;
            const R = S.intersection;
            let L;
            const F = this.generateAngleDetails(S, v, "start");
            let z, j, W;
            if (R.atRecord) {
              if (_ < b.length - 1 && b[_ + 1].relationship === 2 || _ > 0 && b[_ - 1].relationship === 2)
                continue;
              if (L = {
                // the exact record the intersection took place at
                labelValue: R.crosspoint.x,
                beforeValue: null,
                afterValue: null
              }, R.crosspoint.x === p.points[0].x)
                z = null, j = F, W = this.getTransversal(S.segs, v, "start");
              else if (R.crosspoint.x === p.points.at(-1).x)
                z = F, j = null, W = this.getTransversal(S.segs, v, "end");
              else {
                _++;
                const te = b[_];
                z = F, j = {
                  top: this.getTop(te.segs, v, "end"),
                  angle: te.intersection.angle,
                  //TODO: explain cast
                  slope: {
                    [p.key]: te.slopes.a,
                    [d.key]: te.slopes.b
                  }
                }, W = this.getTransversalOnRecord(S.segs, te.segs, v);
              }
            } else
              L = {
                labelValue: null,
                // the intersection occurred between two record indexes, therefore the prior and post record labels are populated
                beforeValue: S.segs[0].start.x,
                afterValue: S.segs[0].end.x
              }, z = F, j = F, j.top = this.getTop(S.segs, v, "end"), W = this.getTransversal(S.segs, v, "middle");
            this.intersections.push({
              // the record labels for the intersection
              record: L,
              // the value of the intersection point, in y-axis units
              value: S.intersection.crosspoint.y,
              // TODO: explain cast
              // the list of series labels for all the series that participated in the intersection
              series: v,
              incomingAngle: this.generateAngleMetadata(z, v),
              outgoingAngle: this.generateAngleMetadata(j, v),
              transversality: W
            });
          }
          let f = this.blankOverlap(v), E = !1;
          for (let _ = 0; _ < b.length; _++) {
            const S = b[_];
            if (S.relationship === 2) {
              const R = S.segs[0].start, L = S.segs[0].end;
              E ? f.datapoints.push([L.x.toString(), L.y]) : (f.incomingAngle = _ === 0 ? null : this.generateAngleMetadata(this.generateAngleDetails(
                b[_ - 1],
                v,
                "start"
              ), v), f.datapoints.push([R.x.toString(), R.y]), f.datapoints.push([L.x.toString(), L.y]), E = !0);
            } else
              E && (f.outgoingAngle = this.generateAngleMetadata(
                this.generateAngleDetails(b[_], v, "end"),
                v
              ), this.overlaps.push(structuredClone(f)), f = this.blankOverlap(v), E = !1);
          }
          E && this.overlaps.push(f);
          const A = m.allSegPairProps;
          let x = this.blankParallel(v), g = !1, w = 0;
          for (let _ = 0; _ < A.length; _++) {
            const S = A[_];
            if (S.relationship === 3 || S.relationship === 4) {
              const R = S.segs[0].start, L = S.segs[0].end;
              w++, S.relationship === 4 && (x.kind = "functional"), g ? x.records.push({ label: L.x.toString() }) : (x.incomingDirection = _ === 0 ? null : this.determineDirection(A[_ - 1], "start"), x.records.push({ label: R.x.toString() }), x.records.push({ label: L.x.toString() }), g = !0);
            } else
              g && (x.outgoingDirection = _ === A.length - 1 ? null : this.determineDirection(A[_ + 1], "end"), this.parallels.push(structuredClone(x)), x = this.blankParallel(v), g = !1);
          }
          g && this.parallels.push(x), this.pairs.push({
            series: v,
            dominant: m.dominant === -1 ? null : v[m.dominant - 1],
            dominantPercent: m.timeOnTop,
            parallelPercent: w / A.length * 100
          });
        }
      }
  }
  getIntersections() {
    return this.intersections;
  }
  getOverlaps() {
    return this.overlaps;
  }
  getParallels() {
    return this.parallels;
  }
  getPairs() {
    return this.pairs;
  }
  getTrackingGroups() {
    return this.trackingGroups;
  }
  getTrackingZones() {
    return this.trackingZones;
  }
  getClusters() {
    return this.clusters;
  }
  getClusterOutliers() {
    return this.clusterOutliers;
  }
  generateAngleDetails(e, r, n) {
    return {
      top: this.getTop(e.segs, r, n),
      angle: e.intersection.angle,
      //TODO: explain cast
      slope: {
        [r[0]]: e.slopes.a,
        [r[1]]: e.slopes.b
      }
    };
  }
  generateAngleMetadata(e, r) {
    return e === null ? null : {
      [r[0]]: {
        [r[1]]: e
      },
      [r[1]]: {
        [r[0]]: e
      }
    };
  }
  blankOverlap(e) {
    return {
      datapoints: [],
      series: e,
      incomingAngle: null,
      outgoingAngle: null
    };
  }
  blankParallel(e) {
    return {
      records: [],
      series: e,
      incomingDirection: null,
      outgoingDirection: null,
      kind: "perfect"
    };
  }
  getTop(e, r, n) {
    const i = this.getTopIndex(e, n);
    return i === null ? null : r[i];
  }
  getTopIndex(e, r) {
    const n = e[0][r].y, i = e[1][r].y;
    return n > i ? 0 : n < i ? 1 : null;
  }
  determineDirection(e, r) {
    const n = Math.abs(e.segs[0].start.y - e.segs[1].start.y), i = Math.abs(e.segs[0].end.y - e.segs[1].end.y);
    return (r === "start" ? i : n) < (r === "start" ? n : i) ? "converge" : "diverge";
  }
  getTransversal(e, r, n) {
    let i, s;
    if (n !== "middle") {
      i = "edge";
      const a = n === "start" ? "end" : "start";
      s = this.getTopIndex(e, a);
    } else {
      s = this.getTopIndex(e, "start");
      const a = this.getTopIndex(e, "end");
      s === a ? i = "touch" : i = "cross";
    }
    const o = +(s === 0);
    return i === "cross" ? {
      kind: i,
      topToBottom: r[s],
      bottomToTop: r[o]
    } : {
      kind: i,
      top: r[s],
      bottom: r[o]
    };
  }
  getTransversalOnRecord(e, r, n) {
    const i = this.getTopIndex(e, "start"), s = this.getTopIndex(r, "end");
    if (i === s) {
      const o = +(i === 0);
      return {
        kind: "touch",
        top: n[i],
        bottom: n[o]
      };
    } else
      return {
        kind: "cross",
        topToBottom: n[i],
        bottomToTop: n[s]
      };
  }
};
function Yne(t) {
  return t === "" ? "" : t[0].toLowerCase() + t.slice(1);
}
function dN(t, e) {
  let r = Yne(t);
  return e === "proportion" && r.startsWith("proportion of ") && (r = r.slice(14)), { baseQuantity: r, baseKind: e };
}
function Zne(t) {
  if (!t.multi)
    return t.getSeriesTheme(t.seriesKeys[0]);
  const e = t.family === "pastry" ? "proportion" : "number";
  return dN(t.title ?? "value", e);
}
function Jne(t, e) {
  if (!e.multi && e.hasExplictChartTheme())
    return e.getChartTheme();
  const r = e.family === "pastry" ? "proportion" : "number";
  return dN(e.atKey(t).label, r);
}
var Xne = Object.defineProperty, eie = Object.getOwnPropertyDescriptor, es = (t, e, r, n) => {
  for (var i = eie(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && Xne(e, r, i), i;
};
let ro = class {
  constructor(e, r) {
    if (this.series = e, this.facetKeys = [], this.dependentFacetKeys = [], this.independentFacetKeys = [], this.seriesKeys = [], this.originalSeriesKeys = [], this.allPoints = [], this._facetMap = {}, this._facetDatatypeMap = {}, this._facetDisplayTypeMap = {}, this._uniqueValuesForFacet = {}, this._axisFacetKeys = [], this._seriesMap = {}, this._seriesThemeMap = {}, this.series.length === 0)
      throw new Error("models must have at least one series");
    this.multi = this.series.length > 1, this._dataset = r.datasets[0], this.title = this._dataset.title, this.description = this._dataset.description, this.type = this._dataset.type, this.family = Sx[this.type], this._theme = this._dataset.chartTheme, this.facetSignatures = this.series[0].facetSignatures, this.facetSignatures.forEach((n) => {
      this.facetKeys.push(n.key), this._uniqueValuesForFacet[n.key] = new JM(), this._facetDatatypeMap[n.key] = n.datatype;
    }), this.facetKeys.forEach((n) => {
      const i = this._dataset.facets[n];
      this._facetDisplayTypeMap[n] = i.displayType, this._facetMap[n] = i, i.variableType === "dependent" && this.dependentFacetKeys.push(n), i.variableType === "independent" && this.independentFacetKeys.push(n);
    }), this.numSeries = this.series.length;
    for (const [n, i] of Wn(this.series)) {
      if (this.seriesKeys.includes(n.key))
        throw new Error("every series in a model must have a unique key");
      if (!ZM(
        (s, o) => s.key === o.key && s.datatype === o.datatype,
        n.facetSignatures,
        this.facetSignatures
      ))
        throw new Error("every series in a model must have the same facets");
      this.seriesKeys.push(n.key), this.originalSeriesKeys.push(n.originalKey), this[i] = n, this._seriesMap[n.key] = n, this.allPoints.push(...n), Object.keys(this._uniqueValuesForFacet).forEach((s) => {
        this._uniqueValuesForFacet[s].merge(n.allFacetValues(s));
      }), this._seriesThemeMap[n.key] = n.manifest.theme;
    }
  }
  atKey(e) {
    return this._seriesMap[e] ?? null;
  }
  atKeyAndIndex(e, r) {
    var n;
    return ((n = this.atKey(e)) == null ? void 0 : n[r]) ?? null;
  }
  allFacetValues(e) {
    var r;
    return ((r = this._uniqueValuesForFacet[e]) == null ? void 0 : r.values) ?? null;
  }
  getFacetStats(e) {
    return this._facetDatatypeMap[e] !== "number" ? null : uN(e, this.allPoints);
  }
  getFacetInterval(e) {
    const r = this.getFacetStats(e);
    return r ? { start: r.min.value, end: r.max.value } : null;
  }
  getFacet(e) {
    return this._facetMap[e] ?? null;
  }
  hasExplictChartTheme() {
    return this._theme !== void 0;
  }
  getChartTheme() {
    return this._theme ?? Zne(this);
  }
  getSeriesTheme(e) {
    return this.atKey(e) === null ? null : this._seriesThemeMap[e] ?? Jne(e, this);
  }
  isPlaneModel() {
    return !1;
  }
  prevDatapoint(e) {
    const r = this.atKey(e.seriesKey);
    return r === null ? null : r.datapoints.at(e.datapointIndex - 1) ?? null;
  }
  nextDatapoint(e) {
    const r = this.atKey(e.seriesKey);
    return r === null ? null : r.datapoints.at(e.datapointIndex + 1) ?? null;
  }
};
es([
  yr()
], ro.prototype, "atKey");
es([
  yr()
], ro.prototype, "allFacetValues");
es([
  yr()
], ro.prototype, "getFacetStats");
es([
  yr()
], ro.prototype, "getFacetInterval");
es([
  yr()
], ro.prototype, "getFacet");
es([
  yr()
], ro.prototype, "hasExplictChartTheme");
es([
  yr()
], ro.prototype, "getChartTheme");
es([
  yr()
], ro.prototype, "getSeriesTheme");
let _c = class extends ro {
  /*public readonly xs: ScalarMap[X][];
  public readonly ys: number[];*/
  constructor(e, r, n, i = pN, s = !0) {
    var o;
    if (super(e, r), this.seriesAnalyzerConstructor = n, this.pairAnalyzerConstructor = i, this._useWorker = s, this.intersections = [], this.clusters = [], this.clusterOutliers = [], this.trackingGroups = [], this.trackingZones = [], this._seriesPairAnalyzer = null, this._seriesLineMap = {}, this._seriesAnalysisDone = !1, this.grouped = this._dataset.seriesRelations === "grouped", this.facetKeys.forEach((a) => {
      const l = this._dataset.facets[a];
      l.displayType.type === "axis" && (l.displayType.orientation === "horizontal" ? this.horizontalAxisKey = a : l.displayType.orientation === "vertical" && (this.verticalAxisKey = a));
    }), this.dependentAxisKey = this.dependentFacetKeys[0], this.independentAxisKey = this.independentFacetKeys[0], (this.horizontalAxisKey === void 0 || this.verticalAxisKey === void 0) && (this.horizontalAxisKey = this.independentAxisKey, this.verticalAxisKey = this.dependentAxisKey), this.family === "line" || this.family === "bar" || this.family === "histogram") {
      for (const a of this.series)
        this._seriesLineMap[a.key] = a.getActualLine();
      if (this.multi) {
        const a = this.getAxisInterval(this.getAxisOrientation("dependent"));
        this._seriesPairAnalyzer = new this.pairAnalyzerConstructor(
          Object.values(this._seriesLineMap),
          [1, 1],
          //FIXME: get actual screen size
          a.start,
          a.end
        ), this.intersections = this._seriesPairAnalyzer.getIntersections(), this.clusters = this._seriesPairAnalyzer.getClusters(), this.clusterOutliers = this._seriesPairAnalyzer.getClusterOutliers(), this.trackingGroups = this._seriesPairAnalyzer.getTrackingGroups(), this.trackingZones = this._seriesPairAnalyzer.getTrackingZones();
      }
      [this.seriesScaledValues, this.seriesStatsScaledValues, this.intersectionScaledValues] = Bne(this.series, this.intersections, (o = this.getAxisFacet("vert")) == null ? void 0 : o.multiplier);
    }
  }
  async generateSeriesAnalyses() {
    if (this._seriesAnalysisDone)
      return;
    const e = new this.seriesAnalyzerConstructor();
    this._seriesAnalysisMap = {};
    for (const r in this._seriesLineMap)
      this._seriesAnalysisMap[r] = await e.analyzeSeries(
        this._seriesLineMap[r],
        {
          useWorker: this._useWorker,
          yAxis: this.getAxisInterval(this.getAxisOrientation("dependent"))
        }
      );
    this._seriesAnalysisDone = !0;
  }
  atKey(e) {
    return super.atKey(e);
  }
  getAxisFacet(e) {
    return e === "horiz" ? this.horizontalAxisKey ? this._facetMap[this.horizontalAxisKey] : null : this.verticalAxisKey ? this._facetMap[this.verticalAxisKey] : null;
  }
  getAxisOrientation(e) {
    return (e === "dependent" ? this.dependentAxisKey : this.independentAxisKey) === this.verticalAxisKey ? "vert" : "horiz";
  }
  getAxisInterval(e) {
    var r, n, i, s, o, a;
    const l = e === "horiz" ? this.horizontalAxisKey : this.verticalAxisKey, c = this.getFacetInterval(l);
    if (!c)
      return null;
    let { start: p, end: h } = c;
    const d = ((i = (n = (r = this._dataset.settings) == null ? void 0 : r.axis) == null ? void 0 : n[l]) == null ? void 0 : i.minValue) ?? "unset", v = ((a = (o = (s = this._dataset.settings) == null ? void 0 : s.axis) == null ? void 0 : o[l]) == null ? void 0 : a.maxValue) ?? "unset";
    return d !== "unset" && (p = d), v !== "unset" && (h = v), { start: p, end: h };
  }
  async getSeriesAnalysis(e) {
    return this.type === "scatter" || !this.seriesAnalyzerConstructor || !this.seriesKeys.includes(e) ? null : (await this.generateSeriesAnalyses(), this._seriesAnalysisMap[e]);
  }
  isPlaneModel() {
    return !0;
  }
  getChordAt(e, r) {
    const n = this._facetDatatypeMap[e];
    return n === void 0 || r.datatype() !== n ? null : this.series.map((i) => i.datapointAt(e, r)).filter((i) => i !== null);
  }
};
es([
  yr()
], _c.prototype, "atKey");
es([
  yr()
], _c.prototype, "getAxisFacet");
es([
  yr()
], _c.prototype, "getAxisOrientation");
es([
  yr()
], _c.prototype, "getAxisInterval");
es([
  yr()
], _c.prototype, "getSeriesAnalysis");
function Cg(t) {
  return Object.keys(t.facets).map((e) => ({ key: e, datatype: t.facets[e].datatype }));
}
function fN(t) {
  const e = Object.entries(t.facets).filter(([n, i]) => i.displayType.type === "axis").filter(([n, i]) => i.variableType === "independent").map(([n, i]) => n).at(0), r = Object.entries(t.facets).filter(([n, i]) => i.displayType.type === "axis").filter(([n, i]) => i.variableType === "dependent").map(([n, i]) => n).at(0);
  return { independentAxisKey: e, dependentAxisKey: r };
}
function tie(t) {
  const e = t.datasets[0];
  if (e.data.source !== "inline")
    throw new Error("only manifests with inline data can use this method.");
  const r = Cg(e), n = e.series.map(
    (i) => qne(i, r)
  );
  return new ro(n, t);
}
function rie(t, e) {
  const r = Cg(e.datasets[0]), n = Object.keys(t).map((i) => {
    const s = e.datasets[0].series.filter((o) => o.key === i)[0];
    return new ta(s, t[i], r);
  });
  return new ro(n, e);
}
function nie(t, e, r, n) {
  const i = t.datasets[0];
  if (i.data.source !== "inline")
    throw new Error("only manifests with inline data can use this function.");
  const { independentAxisKey: s, dependentAxisKey: o } = fN(i);
  if (!s || !o)
    throw new Error("only manifests with 2D axes can use this function.");
  const a = Cg(i), l = i.series.map(
    (c) => Qne(c, a, s, o)
  );
  return new _c(l, t, e, r, n);
}
function iie(t, e, r, n, i) {
  const s = e.datasets[0], { independentAxisKey: o, dependentAxisKey: a } = fN(s);
  if (!o || !a)
    throw new Error("only manifests with 2D axes can use this function.");
  const l = Cg(s), c = Object.keys(t).map((p) => {
    const h = s.series.filter((d) => d.key === p)[0];
    return new Ev(h, t[p], l, o, a);
  });
  return new _c(c, e, r, n, i);
}
let A7 = class {
  /**
   * Constructor
   * @param {*} options 
   * @constructor
   */
  constructor(e) {
    this._options = e;
  }
  /**
   * Initializes the module and calls the different methods in order.
   * @private
   * @memberOf module:@fizz/svmjs
   */
  async _init() {
  }
  // data is NxD array of floats. labels are 1 or -1.
  train(e, r, n) {
    this.data = e, this.labels = r, n = n || {};
    const i = n.C || 1, s = n.tol || 1e-4, o = n.alphatol || 1e-7, a = n.maxiter || 1e4, l = n.numpasses || 10;
    let c = xw;
    if (this.kernelType = "linear", "kernel" in n)
      if (typeof n.kernel == "string") {
        if (n.kernel === "linear" && (this.kernelType = "linear", c = xw), n.kernel === "rbf") {
          const m = n.rbfsigma || 0.5;
          this.rbfSigma = m, this.kernelType = "rbf", c = k7(m);
        }
      } else
        this.kernelType = "custom", c = n.kernel;
    this.kernel = c, this.N = e.length;
    const p = this.N;
    if (this.D = e[0].length, this.D, this.alpha = oie(p), this.b = 0, this.usew_ = !1, n.memoize) {
      this.kernelResults = new Array(p);
      for (let m = 0; m < p; m++) {
        this.kernelResults[m] = new Array(p);
        for (let b = 0; b < p; b++)
          this.kernelResults[m][b] = c(e[m], e[b]);
      }
    }
    let h = 0, d = 0;
    for (; d < l && h < a; ) {
      let m = 0;
      for (let b = 0; b < p; b++) {
        const f = this.marginOne(e[b]) - r[b];
        if (r[b] * f < -s && this.alpha[b] < i || r[b] * f > s && this.alpha[b] > 0) {
          let E = b;
          for (; E === b; ) E = sie(0, this.N);
          const A = this.marginOne(e[E]) - r[E];
          let x = this.alpha[b], g = this.alpha[E], w = 0, _ = i;
          if (r[b] === r[E] ? (w = Math.max(0, x + g - i), _ = Math.min(i, x + g)) : (w = Math.max(0, g - x), _ = Math.min(i, i + g - x)), Math.abs(w - _) < 1e-4) continue;
          const S = 2 * this.kernelResult(b, E) - this.kernelResult(b, b) - this.kernelResult(E, E);
          if (S >= 0) continue;
          let R = g - r[E] * (f - A) / S;
          if (R > _ && (R = _), R < w && (R = w), Math.abs(g - R) < 1e-4) continue;
          this.alpha[E] = R;
          const L = x + r[b] * r[E] * (g - R);
          this.alpha[b] = L;
          const F = this.b - f - r[b] * (L - x) * this.kernelResult(b, b) - r[E] * (R - g) * this.kernelResult(b, E), z = this.b - A - r[b] * (L - x) * this.kernelResult(b, E) - r[E] * (R - g) * this.kernelResult(E, E);
          this.b = 0.5 * (F + z), L > 0 && L < i && (this.b = F), R > 0 && R < i && (this.b = z), m++;
        }
      }
      h++, m == 0 ? d++ : d = 0;
    }
    if (this.kernelType === "linear") {
      this.w = new Array(this.D);
      for (let m = 0; m < this.D; m++) {
        let b = 0;
        for (let f = 0; f < this.N; f++)
          b += this.alpha[f] * r[f] * e[f][m];
        this.w[m] = b, this.usew_ = !0;
      }
    } else {
      const m = [], b = [], f = [];
      for (let E = 0; E < this.N; E++)
        this.alpha[E] > o && (m.push(this.data[E]), b.push(this.labels[E]), f.push(this.alpha[E]));
      this.data = m, this.labels = b, this.alpha = f, this.N = this.data.length;
    }
    const v = {};
    return v.iters = h, v;
  }
  // inst is an array of length D. Returns margin of given example
  // this is the core prediction function. All others are for convenience mostly
  // and end up calling this one somehow.
  marginOne(e) {
    let r = this.b;
    if (this.usew_)
      for (let n = 0; n < this.D; n++)
        r += e[n] * this.w[n];
    else
      for (let n = 0; n < this.N; n++)
        r += this.alpha[n] * this.labels[n] * this.kernel(e, this.data[n]);
    return r;
  }
  predictOne(e) {
    return this.marginOne(e) > 0 ? 1 : -1;
  }
  // data is an NxD array. Returns array of margins.
  margins(e) {
    const r = e.length, n = new Array(r);
    for (let i = 0; i < r; i++)
      n[i] = this.marginOne(e[i]);
    return n;
  }
  kernelResult(e, r) {
    return this.kernelResults ? this.kernelResults[e][r] : this.kernel(this.data[e], this.data[r]);
  }
  // data is NxD array. Returns array of 1 or -1, predictions
  predict(e) {
    const r = this.margins(e);
    for (let n = 0; n < r.length; n++)
      r[n] = r[n] > 0 ? 1 : -1;
    return r;
  }
  // THIS FUNCTION IS NOW DEPRECATED. WORKS FINE BUT NO NEED TO USE ANYMORE. 
  // LEAVING IT HERE JUST FOR BACKWARDS COMPATIBILITY FOR A WHILE.
  // if we trained a linear svm, it is possible to calculate just the weights and the offset
  // prediction is then yhat = sign(X * w + b)
  getWeights() {
    const e = new Array(this.D);
    for (let r = 0; r < this.D; r++) {
      let n = 0;
      for (let i = 0; i < this.N; i++)
        n += this.alpha[i] * this.labels[i] * this.data[i][r];
      e[r] = n;
    }
    return { w: e, b: this.b };
  }
  toJSON() {
    if (this.kernelType === "custom")
      return console.log("Can't save this SVM because it's using custom, unsupported kernel..."), {};
    const e = {};
    return e.N = this.N, e.D = this.D, e.b = this.b, e.kernelType = this.kernelType, this.kernelType === "linear" && (e.w = this.w), this.kernelType === "rbf" && (e.rbfSigma = this.rbfSigma, e.data = this.data, e.labels = this.labels, e.alpha = this.alpha), e;
  }
  fromJSON(e) {
    this.N = e.N, this.D = e.D, this.b = e.b, this.kernelType = e.kernelType, this.kernelType === "linear" ? (this.w = e.w, this.usew_ = !0, this.kernel = xw) : this.kernelType == "rbf" ? (this.rbfSigma = e.rbfSigma, this.kernel = k7(this.rbfSigma), this.data = e.data, this.labels = e.labels, this.alpha = e.alpha) : console.log("ERROR! unrecognized kernel type." + this.kernelType);
  }
};
function k7(t) {
  return function(e, r) {
    let n = 0;
    for (let i = 0; i < e.length; i++)
      n += (e[i] - r[i]) * (e[i] - r[i]);
    return Math.exp(-n / (2 * t * t));
  };
}
function xw(t, e) {
  let r = 0;
  for (let n = 0; n < t.length; n++)
    r += t[n] * e[n];
  return r;
}
function sie(t, e) {
  return Math.floor(Math.random() * (e - t) + t);
}
function oie(t) {
  const e = new Array(t);
  for (let r = 0; r < t; r++)
    e[r] = 0;
  return e;
}
class aie {
  constructor(e) {
    e && (this.df = e);
  }
  LogGamma(e) {
    const r = 1 + 76.18009173 / e - 86.50532033 / (e + 1) + 24.01409822 / (e + 2) - 1.231739516 / (e + 3) + 0.00120858003 / (e + 4) - 536382e-11 / (e + 5);
    return (e - 0.5) * Math.log(e + 4.5) - (e + 4.5) + Math.log(r * 2.50662827465);
  }
  Betinc(e, r, n) {
    let i = 0, s = 1, o = 1, a = 1, l = 0, c = 0, p;
    for (; Math.abs((o - c) / o) > 1e-5; )
      c = o, p = -(r + l) * (r + n + l) * e / (r + 2 * l) / (r + 2 * l + 1), i = o + p * i, s = a + p * s, l = l + 1, p = l * (n - l) * e / (r + 2 * l - 1) / (r + 2 * l), o = i + p * o, a = s + p * a, i = i / a, s = s / a, o = o / a, a = 1;
    return o / r;
  }
  cumulativeProbability(e, r) {
    r || (r = this.df);
    let n;
    if (r <= 0)
      console.error("Degrees of freedom must be positive");
    else {
      const i = r / 2, s = i + 0.5, o = r / (r + e * e), a = Math.exp(this.LogGamma(s) - this.LogGamma(0.5) - this.LogGamma(i) + i * Math.log(o) + 0.5 * Math.log(1 - o));
      let l;
      o < (i + 1) / (s + 2) ? l = a * this.Betinc(o, i, 0.5) : l = 1 - a * this.Betinc(1 - o, 0.5, i), e < 0 ? n = l / 2 : n = 1 - l / 2;
    }
    return n = Math.round(n * 1e5) / 1e5, n;
  }
  invCumulativeProbability(e, r) {
    if (r || (r = this.df), e >= 0.5) {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(o, r) >= e); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(n + o / 100) >= e); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(i + o / 1e4) >= e); o += 1)
        s = i + o / 1e4;
      return s;
    } else {
      let n = 0;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-o, r) <= e); o++)
        n = o;
      let i = n;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-n - o / 100) <= e); o += 1)
        i = n + o / 100;
      let s = i;
      for (let o = 0; o < 100 && !(this.cumulativeProbability(-i - o / 1e4) <= e); o += 1)
        s = i + o / 1e4;
      return -s;
    }
  }
}
class lie {
  constructor(e, r) {
    this.df1 = e, this.df2 = r, this.EPSILON = 1e-10;
  }
  L504(e, r, n, i) {
    const s = e * r / (e * r + n), o = Math.sqrt(s), a = Math.log(o), l = Math.sqrt(1 - s), c = Math.log(l);
    let p = 1 - 2 * Math.atan(o / Math.sqrt(-o * o + 1)) / Math.PI, h = 0;
    if (n != 1) {
      const d = Math.log(2 * o / Math.PI);
      if (p -= Math.exp(d + c), n != 3) {
        const v = Math.floor((n - 3) / 2);
        for (let m = 1; m <= v; m++) {
          const b = 2 * m + 1;
          h += Math.log((b - 1) / b);
          const f = h + c * b + d;
          f > -78.4 && (p -= Math.exp(f));
        }
      }
    }
    if (e != 1) {
      let d = h;
      if (n > 1 && (d += Math.log(n - 1)), d += Math.log(2 / Math.PI) + a + c * n, d > -78.4 && (p += Math.exp(d)), e != 3) {
        const v = Math.floor((e - 3) / 2);
        h = 0;
        for (let m = 1; m <= v; m++) {
          const b = m * 2 + 1;
          h += Math.log((n + b - 2) / b);
          const f = h + a * (b - 1) + d;
          f > -78.4 && (p += Math.exp(f));
        }
      }
    }
    return p;
  }
  L401(e, r, n, i) {
    const s = e * r / (e * r + n), o = Math.log(s);
    let a = 0;
    const l = Math.log(1 - s) * n / 2;
    if (l > -78.4 && (a = Math.exp(l)), e != 2) {
      const c = Math.floor(e / 2 - 1);
      let p = 0;
      for (let h = 1; h <= c; h++) {
        const d = 2 * h;
        p += Math.log(n + d - 2) - Math.log(d) + o, p + l > -78.4 && (a += Math.exp(p + l));
      }
    }
    return i == 1 && (a = 1 - a), a;
  }
  ProbF(e, r, n) {
    let i = n, s = e, o = r, a = 0;
    return Math.floor(s / 2) * 2 == s ? this.L401(s, i, o, a) : Math.floor(o / 2) * 2 != o ? this.L504(s, i, o, a) : (i = 1 / i, s = r, o = e, a = 1, this.L401(s, i, o, a));
  }
  cumulativeProbability(e) {
    if (this.df1 > 0.01 && this.df2 > 0.01 && e > this.EPSILON)
      return 1 - this.ProbF(this.df1, this.df2, e);
    console.error("df1, df2, and F must be numbers greater than 0.");
  }
}
const _7 = [
  1.4142024783770517,
  1.7285350177358225,
  1.975558322080508,
  2.165309701618668,
  2.3223314597870495,
  2.43666896580902,
  2.539575597098922,
  2.629725259756139,
  2.6946351910160824,
  2.7571690989287108,
  2.82429436007275,
  2.86976990061697,
  2.911181488216127,
  2.9562785307147474,
  2.991043137459134,
  3.031892332910388,
  3.0390882779033968,
  3.084150339177206,
  3.1068126593538534,
  3.1377944664764175,
  3.1526730795266236,
  3.1856353298858746,
  3.1923941584623616,
  3.2232152987382205,
  3.2423279731889063,
  3.2672678614514434,
  3.28815589678312,
  3.306598538588182,
  3.3169876930034423,
  3.3426537588982366,
  3.338808432731316,
  3.3551800156910674,
  3.3677857453596176,
  3.3801704122612546,
  3.3894353098402292,
  3.4103476461664384,
  3.420758782190955,
  3.4234022273067235,
  3.4377591100482245,
  3.4495251663075597,
  3.45784133640642,
  3.4655169406594553,
  3.499664208072353,
  3.5075228374867624,
  3.4963470841468247,
  3.5194522982765517,
  3.50887461478777,
  3.517883433127914,
  3.527130862311399,
  3.5478465903324174,
  3.5524335509017972,
  3.5453727082671342,
  3.556173872494318,
  3.557087103502499,
  3.589369632641309,
  3.5859140345184524,
  3.572323092223869,
  3.6004177405174853,
  3.6100996977289306,
  3.601519301860006,
  3.606430559116003,
  3.623484959486857,
  3.6110156117453704,
  3.6398254610166214,
  3.6485762129590045,
  3.6369984456518214,
  3.6420217039991707,
  3.6515502039986543,
  3.6534596174533878,
  3.6659253039539754,
  3.678204062277477,
  3.673013776537585,
  3.6873396028854244,
  3.677549442478252,
  3.672393117945697,
  3.694338890356745,
  3.698559967922895,
  3.7088383298959364,
  3.6960214124422732,
  3.6962804693332054,
  3.7259363906151113,
  3.6945941836261005,
  3.7123614650012637,
  3.7266182166220743,
  3.726433940762783,
  3.7262288936328507,
  3.73068538678121,
  3.7464587039431216,
  3.734498500854471,
  3.7666496106093086,
  3.7577811376185797,
  3.755885408241557,
  3.7653220485067256,
  3.759612302718265,
  3.750000422234468,
  3.776893666562007,
  3.7656945047078376
], cie = [
  [
    12.92876788710003,
    18.669362102797844,
    20.708185574014465
  ],
  [
    12.893379950402329,
    17.838738753100234,
    20.009145166260716
  ],
  [
    12.567620517329296,
    17.39284624657391,
    19.327403214291675
  ],
  [
    12.44012368783225,
    17.159725181804923,
    19.031999514734718
  ],
  [
    12.258810404004157,
    16.643626920880678,
    18.520644599539708
  ],
  [
    12.490936102639248,
    17.07031258707699,
    19.26763537042604
  ],
  [
    12.230582644506537,
    16.8611702133535,
    19.04138451550924
  ],
  [
    12.285890759032673,
    16.72028694459538,
    18.998686524252154
  ],
  [
    12.265830882960202,
    16.861313711298223,
    19.01741086021432
  ],
  [
    12.221592293386445,
    16.856569952690425,
    18.679522968116675
  ],
  [
    12.207863926087379,
    16.466760433982508,
    18.327798576854196
  ],
  [
    12.23047144884862,
    16.604698640112442,
    18.778749913667404
  ],
  [
    12.310880515319493,
    16.75477031068603,
    18.61887265606582
  ],
  [
    12.09088910593483,
    16.680683526842817,
    19.10909766756724
  ],
  [
    12.28969274656454,
    16.494346369998592,
    18.555323182091747
  ],
  [
    12.351479909044647,
    17.231085800266705,
    19.12315903511468
  ],
  [
    12.232654018508402,
    17.03319706813043,
    19.36238761950663
  ],
  [
    12.24175327982118,
    17.01249507542771,
    19.29261479388184
  ],
  [
    12.240819762926595,
    16.958668959199564,
    18.703343358289676
  ],
  [
    12.325576191647679,
    16.741637280941735,
    18.706270613293825
  ],
  [
    12.29079270883332,
    16.83580567418819,
    18.885633182327588
  ],
  [
    12.105579742321321,
    16.801481191805877,
    18.74917129995002
  ],
  [
    12.241506985184987,
    16.421107838741005,
    18.51907643327747
  ],
  [
    12.22772321442409,
    16.76637698315794,
    18.59944945667253
  ],
  [
    12.146827427372807,
    16.504491710455042,
    18.624893334253915
  ],
  [
    12.099825423105056,
    16.517727777727934,
    18.389759370770282
  ],
  [
    12.241793182544008,
    16.69983166753318,
    18.199273554649118
  ],
  [
    12.133827646762477,
    16.937161124066893,
    18.865979715097055
  ],
  [
    12.014897172400497,
    16.64164656731907,
    18.52796800753582
  ],
  [
    12.03194886183511,
    16.448427247716083,
    18.360165754021324
  ],
  [
    12.060576333659972,
    16.972556324548336,
    18.909884009510286
  ],
  [
    12.130919558394593,
    16.846538605893603,
    18.974105413083418
  ],
  [
    12.167013704292577,
    16.962535224497064,
    18.952800614645692
  ],
  [
    12.307745895005242,
    16.69776947316106,
    18.73020815902911
  ],
  [
    12.03703814065202,
    16.744259233990512,
    19.40987043616083
  ],
  [
    12.23158902787162,
    16.992381220472012,
    19.23258888861058
  ],
  [
    12.30313545083327,
    16.80175925410746,
    18.88639508508212
  ],
  [
    12.216506652052612,
    16.95978747527697,
    19.07369251354378
  ],
  [
    12.289633178985905,
    17.037358965358983,
    18.978000598844293
  ],
  [
    12.114391564747471,
    16.353909897952686,
    18.35011390560238
  ],
  [
    12.208213936084457,
    16.12841887472018,
    18.239736208276152
  ],
  [
    12.326886082604242,
    16.87043068171149,
    18.900551155302647
  ],
  [
    12.24602935198574,
    16.740078446411406,
    18.57610242578182
  ],
  [
    12.154508067768113,
    16.70375179351137,
    18.84458221820561
  ],
  [
    12.053162931004179,
    16.63616478058826,
    18.764716631834734
  ],
  [
    12.242031428895839,
    16.870439498648583,
    18.946299240629287
  ],
  [
    12.172676093456305,
    16.57616403586386,
    18.901254056077153
  ],
  [
    12.234873290793098,
    16.849691971911838,
    19.020953521536004
  ],
  [
    12.307356477970162,
    17.070904468883104,
    19.124634537613513
  ],
  [
    12.258316325281726,
    16.98236293001686,
    19.362641577913156
  ],
  [
    12.236258781616636,
    16.835948685325945,
    18.872615556171525
  ],
  [
    12.218214829379882,
    16.72052856570416,
    18.576319895769533
  ],
  [
    12.266452802779268,
    17.001974682521503,
    19.397512454689892
  ],
  [
    12.142229768023105,
    16.760040761542093,
    18.73221439686166
  ],
  [
    12.362128316602698,
    16.779263655428466,
    18.690631800055144
  ],
  [
    12.23248525532616,
    16.78957578482738,
    19.290187946573045
  ],
  [
    12.194978246692179,
    16.66872414977679,
    18.38065055971982
  ],
  [
    12.364346090585878,
    16.78308783969924,
    18.787944141467552
  ],
  [
    12.213523054233821,
    16.745070120633624,
    18.779462580096293
  ],
  [
    12.120562728816676,
    16.72947148909386,
    18.540581750860838
  ],
  [
    12.147441684285011,
    16.362711939455345,
    18.5928909502196
  ],
  [
    12.349013958141011,
    17.115157968739332,
    19.074081167238724
  ],
  [
    12.169896474381117,
    16.779107284309674,
    19.095614865501265
  ],
  [
    12.212332899050487,
    17.15220159015151,
    19.18433312800504
  ],
  [
    12.427266331944576,
    17.19802901185036,
    19.08282870552354
  ],
  [
    12.208415329256482,
    16.698611123996386,
    18.437039290733527
  ],
  [
    12.150857540075965,
    16.747967767000077,
    18.522105916017864
  ],
  [
    12.185133777587764,
    16.716543085287885,
    18.75368115517968
  ],
  [
    12.202518998568662,
    16.695350960024488,
    18.766605345681214
  ],
  [
    12.293516845096802,
    16.848652152520355,
    18.73818931670063
  ],
  [
    12.264328782539446,
    16.898700733974184,
    18.91736903501125
  ],
  [
    12.283442238272498,
    16.79113139749197,
    18.762641899116595
  ],
  [
    12.288571666812464,
    16.947956362708894,
    19.26608413111616
  ],
  [
    12.199938820517241,
    16.73882101164454,
    18.649824259785902
  ],
  [
    12.281399931209005,
    16.74455321404603,
    18.993644280454557
  ],
  [
    11.978508088635845,
    16.751385791647305,
    19.067980524092103
  ],
  [
    12.352190443412464,
    17.002035355108024,
    18.910150024775536
  ],
  [
    12.11299191492474,
    16.85211409238294,
    19.21553533835868
  ],
  [
    12.252946905996852,
    16.77267825853487,
    18.758060103809566
  ],
  [
    12.253428278525488,
    17.05117162481038,
    19.437396636388712
  ],
  [
    12.365555609949542,
    17.217797222036967,
    19.557725250431925
  ],
  [
    12.446856234792692,
    17.13219895129848,
    19.189823799758685
  ],
  [
    12.378913383861864,
    16.69420382596318,
    18.614200176451167
  ],
  [
    12.209646506057828,
    17.049298470931937,
    19.21471558598783
  ],
  [
    12.07451389049845,
    16.52146599860598,
    18.646538442813565
  ],
  [
    12.242992826481506,
    17.118044327693312,
    19.109033882498373
  ],
  [
    12.031588638774476,
    16.440292876584916,
    18.365137461548116
  ],
  [
    12.256327863966023,
    16.937124809805663,
    19.055448755862216
  ],
  [
    12.152502866561859,
    16.51661734703226,
    18.292867488178068
  ],
  [
    12.240166584135661,
    17.01144955716148,
    19.269980514360167
  ],
  [
    12.288087364649998,
    16.9124768573556,
    18.78496409520197
  ],
  [
    12.261031067472498,
    17.080660923120398,
    18.993376274931116
  ],
  [
    12.149516099981419,
    16.429960356660846,
    18.693814658804264
  ],
  [
    12.189972968413274,
    16.360091390089806,
    18.372140642711813
  ],
  [
    12.247713311640034,
    16.85901876289993,
    18.747152105084417
  ],
  [
    12.235996387439796,
    16.719425800548546,
    18.73463631602104
  ]
], qu = {
  minLen3: 0,
  minLen6: 1,
  tooManyPoints: 2
}, uie = {
  [qu.minLen3]: "line must have at least 3 points",
  [qu.minLen6]: "line must have at least 6 points",
  [qu.tooManyPoints]: "line contains too many points"
};
let Sv = class extends Error {
  constructor(e) {
    super(uie[e]), this.code = e;
  }
};
function hie(t, e, r) {
  return t.map((n) => n - e).map((n) => n / r);
}
function Ew(t) {
  const e = t.bestFit, r = e.rss();
  return {
    se: Math.sqrt(r / t.length),
    rss: r,
    resid: e.residuals,
    slope: e.slope,
    inter: e.intercept
  };
}
function pie(t) {
  if (t.length < 3)
    throw new Sv(qu.minLen3);
  const e = Fre(t.points.map((r) => r.x), t.points.map((r) => r.y));
  return Number.isNaN(e) ? 1 : Math.abs(e);
}
function die(t) {
  const e = t.length;
  if (e < 6)
    throw new Sv(qu.minLen6);
  const { se: r } = Ew(t);
  if (r === 0)
    return { feats: [0, 0, 0] };
  const n = cie[e - 6], i = [];
  for (let a = 2; a < e - 3; a++) {
    const l = a + 1, { se: c } = Ew(t.slice(0, l)), { se: p } = Ew(t.slice(l));
    i.push(c ** l * p ** (e - l) / r ** e);
  }
  const s = Math.min(...i), o = -Math.log(s);
  return {
    feats: n.map((a) => o > a ? 1 : 0),
    logLambda: o,
    t: i.indexOf(s) + 2
  };
}
function fie(t) {
  const e = t.length;
  if (e < 6)
    throw new Sv(qu.minLen6);
  const r = t.bestFit.rss(), n = [0, 0];
  if (r === 0)
    return { feats: n };
  const i = [], s = t.points.map((f) => f.x), o = t.points.map((f) => f.y), a = (f) => f.reduce((E, A) => E + A), l = (f, E) => a(f.map((A, x) => A * E[x])), c = [], p = [];
  for (let f = 2; f < e - 3; f++) {
    const E = s.slice(0, f + 1), A = o.slice(0, f + 1), x = a(E), g = a(A), w = l(E, A), _ = a(E.map((oe) => oe ** 2)), S = w - x * g / (f + 1), R = _ - x ** 2 / (f + 1), L = S / R, F = Uo(A) - L * Uo(E), z = s[f], j = F + L * z, W = s.slice(f + 1), te = o.slice(f + 1), le = a(W), ce = a(te), Ee = l(W, te), xe = a(W.map((oe) => oe ** 2)), _e = ce - (t.length - (f + 1)) * j, Ie = le - (t.length - (f + 1)) * z, je = _e / Ie, ue = Ee / le - je * xe / le, O = E.map((oe) => F + L * oe), N = a(E.map((oe, ee) => (A[ee] - O[ee]) ** 2)), J = W.map((oe) => ue + je * oe), re = a(W.map((oe, ee) => (te[ee] - J[ee]) ** 2));
    i.push(N + re), c.push({ a1: F, b1: L, a2: ue, b2: je }), p.push(O.concat(J));
  }
  const h = Math.min(...i);
  let d, v = (r - h) / 2 / (h / (e - 4));
  v <= 0 && (v = 1e-3), v === 1 / 0 ? d = 0 : d = 1 - new lie(2, e - 4).cumulativeProbability(v);
  const m = i.indexOf(h) + 2, b = { rssMin: h, rssl: r, F: v, p: d, split: m, params: c[m - 2], yhats: p[m - 2] };
  return d < 0.1 && (n[0] = 1), d < 0.05 && (n[1] = 1), { feats: n, debug: b };
}
function gie(t) {
  const e = t.bestFit.residuals.map(Math.sign), { r, nminus: n, nplus: i } = e.reduce(
    (a, l, c) => (c && l !== e[c - 1] && a.r++, l || (l = 1), a[l === 1 ? "nplus" : "nminus"]++, a),
    { r: 1, nminus: 0, nplus: 0 }
  ), s = 2 * i * n / (i + n) + 1, o = Math.abs(Math.sqrt(
    2 * i * n * (2 * i * n - i - n) / (Math.pow(i + n, 2) * (i + n - 1))
  ));
  return { feats: [r < s - o / 2 ? 1 : r > s + o / 2 ? -1 : 0, r, s, o, Math.abs(r - s) / s] };
}
function mie(t) {
  const e = t.length;
  if (e > _7.length + 4)
    throw new Sv(qu.tooManyPoints);
  const r = t.bestFit.residuals, n = Math.sqrt(
    r.map((d) => d ** 2 / (e - 2)).reduce((d, v) => d + v)
  );
  if (n === 0)
    return [-1, 0];
  const i = t.points.map((d) => d.x), s = Uo(i), o = i.map((d) => (d - s) ** 2), a = o.reduce((d, v) => d + v), l = o.map((d) => n * Math.sqrt(1 - 1 / e - d / a)), c = r.map((d, v) => d / l[v]).map((d) => Math.abs(d)), p = Math.max(...c), h = _7[e - 4];
  return [p, c.filter((d) => d > h).length];
}
function yie(t) {
  const e = t.bestFit.rss(), r = t.points.at(-1).x - t.points[0].x, n = Math.sqrt(e / t.length) / r, i = Math.atan(t.bestFit.slope);
  return [n, n * Math.cos(i) ** 2];
}
class vie {
  /**
   * Compute non-standardized feature columns from examples.
   * @param examples - Training examples
   * @returns Feature columns
   */
  computeFeatures(e) {
    function r(i, s) {
      const o = i[0].length, a = {};
      for (let l = 0; l < o; l++)
        a[`${s}${l + 1}`] = [];
      for (const l of i)
        l.forEach((c, p) => a[`${s}${p + 1}`].push(c));
      return a;
    }
    const n = {
      absCorrCoeff: e.map((i) => pie(i.data)),
      nPoints: e.map((i) => i.data.length),
      ...r(e.map((i) => yie(i.data)), "scaledS"),
      nPointsChart: e.map((i) => i.chartLength),
      chartPct: e.map((i) => (i.data.length - 1) / (i.chartLength - 1))
    };
    return e[0].data.length >= 6 && Object.assign(
      n,
      r(e.map((i) => die(i.data).feats), "qTest"),
      r(e.map((i) => fie(i.data).feats), "fTest"),
      r(e.map((i) => gie(i.data).feats), "runsTest"),
      r(e.map((i) => mie(i.data)), "outlierTest")
    ), n;
  }
  /**
   * Standardize feature columns.
   * @param featCols - Non-standardized feature columns
   * @param featStats - Feature column statistics
   * @returns Standardized feature columns
   */
  standardizeFeatures(e, r) {
    const n = {};
    for (const [i, s] of Object.entries(e)) {
      const o = r[i];
      n[i] = o ? hie(s, o.mean, o.stdDev) : s;
    }
    return n;
  }
  /**
   * Assemble feature matrix from standardized feature columns.
   * @param stdFeatCols - Standardized feature columns.
   * @returns Feature matrix (array of example rows)
   */
  assembleMatrix(e) {
    const r = Object.values(e)[0].length, n = Gu(r, (i) => []);
    for (const [i, s] of Object.entries(e))
      s.forEach((o, a) => n[a].push(o));
    return n;
  }
  /**
   * Compute feature matrix from examples.
   * @param examples - Training examples
   * @param featStats - Feature column statistics
   * @returns Feature matrix (array of example rows)
   */
  computeMatrix(e, r) {
    const n = this.computeFeatures(e), i = this.standardizeFeatures(n, r);
    return this.assembleMatrix(i);
  }
}
const gN = {
  "188b757048e": {
    breaks: "breaks_JF_CM3",
    small: {
      model: {
        N: 216,
        D: 6,
        b: 1.0301052191704447,
        kernelType: "linear",
        w: [
          -0.3670377924881308,
          0.24109852608042484,
          0.10770417080350453,
          3.7309289892912494,
          -0.24351287768173968,
          0.1773538767010703
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6613098596026764,
          stdDev: 0.32645241503938466
        },
        nPoints: {
          mean: 4.027777777777778,
          stdDev: 0.79484775003546
        },
        scaledS1: {
          mean: 0.2738191427566398,
          stdDev: 0.31274618795081666
        },
        scaledS2: {
          mean: 0.16552447256379144,
          stdDev: 0.22401114065292482
        },
        nPointsChart: {
          mean: 18.88425925925926,
          stdDev: 11.50047652834366
        },
        chartPct: {
          mean: 0.24575562721992683,
          stdDev: 0.17658868716036033
        }
      }
    },
    big: {
      model: {
        N: 818,
        D: 18,
        b: -0.5949603608497636,
        kernelType: "linear",
        w: [
          -0.4977108970919176,
          0.7541270816821308,
          0.9144109510673445,
          1.6047203771838476,
          -1.4368172642074537,
          -0.21592712823176308,
          0.07644318713996778,
          0.014636523739875784,
          0.1763324579259402,
          1.106707575171747,
          -0.47385129596321995,
          0.45987873914033983,
          0.35112878139332787,
          -0.6236067182671058,
          0.9485075089484734,
          0.19163220544936868,
          0.20546829454342905,
          -0.06915930322456987
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6452237813470705,
          stdDev: 0.3240018443609284
        },
        nPoints: {
          mean: 14.583129584352077,
          stdDev: 8.99604477133496
        },
        scaledS1: {
          mean: 0.10594325137217282,
          stdDev: 0.09177436527475356
        },
        scaledS2: {
          mean: 0.08668479622616888,
          stdDev: 0.07415105573907281
        },
        nPointsChart: {
          mean: 27.0880195599022,
          stdDev: 12.696709863610126
        },
        chartPct: {
          mean: 0.5831555684741223,
          stdDev: 0.28777669079271473
        },
        runsTest2: {
          mean: 5.10757946210269,
          stdDev: 2.511304431521282
        },
        runsTest3: {
          mean: 8.050945471288665,
          stdDev: 4.446028922152818
        },
        runsTest4: {
          mean: 1.6812783091074126,
          stdDev: 0.5646901163167827
        },
        runsTest5: {
          mean: 0.337916669549109,
          stdDev: 0.20151780352623566
        },
        outlierTest1: {
          mean: 2.100035193879811,
          stdDev: 0.5296286424653459
        },
        outlierTest2: {
          mean: 0.05867970660146699,
          stdDev: 0.2351680408679939
        }
      }
    }
  },
  "18afd2f54c7": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3380856560371651,
        kernelType: "linear",
        w: [
          -0.756517811722315,
          0.37069999610745497,
          0.21673055797213336,
          1.1244975473636247,
          0.035519868943893806,
          0.6975781903311828
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6866332461949628,
          stdDev: 0.3229548134968895
        },
        nPoints: {
          mean: 4.069767441860465,
          stdDev: 0.8050959803624481
        },
        scaledS1: {
          mean: 0.03965686197121996,
          stdDev: 0.0338017466328698
        },
        scaledS2: {
          mean: 0.038745499336644146,
          stdDev: 0.033324943757710994
        },
        nPointsChart: {
          mean: 15.078488372093023,
          stdDev: 8.898337515306299
        },
        chartPct: {
          mean: 0.2979532652417984,
          stdDev: 0.1884678355817908
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.22042056305341218,
        kernelType: "linear",
        w: [
          -0.3280468854878086,
          -0.11665058369931192,
          -0.0022542536097451466,
          2.219103384778342,
          0.0342024760983941,
          0.4293989826596215,
          0.2975608661999607,
          -0.6077251584818741,
          0.4000527465309003,
          0.4042384593088002,
          0.001186586425212074,
          0.5190085928118862,
          -0.23537053975123523,
          0.0715945226988598,
          0.033154145420287044,
          -0.06347880606856209,
          0.1850990704458409,
          -0.001228864486559927
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6223429821764429,
          stdDev: 0.3110591999188207
        },
        nPoints: {
          mean: 13.731607629427794,
          stdDev: 8.370686093707965
        },
        scaledS1: {
          mean: 0.03544093688268208,
          stdDev: 0.026611386439376005
        },
        scaledS2: {
          mean: 0.03455363316854854,
          stdDev: 0.026077505679786228
        },
        nPointsChart: {
          mean: 23.768392370572208,
          stdDev: 11.730176258926388
        },
        chartPct: {
          mean: 0.6094307363719895,
          stdDev: 0.26692294365220165
        },
        runsTest2: {
          mean: 5.151226158038147,
          stdDev: 2.6793673522936645
        },
        runsTest3: {
          mean: 7.583581141916727,
          stdDev: 4.081715945141601
        },
        runsTest4: {
          mean: 1.6148756585462214,
          stdDev: 0.5411094264297078
        },
        runsTest5: {
          mean: 0.3153327018423893,
          stdDev: 0.19626169453505887
        },
        outlierTest1: {
          mean: 2.118980108638941,
          stdDev: 0.6300714899329056
        },
        outlierTest2: {
          mean: 0.09128065395095368,
          stdDev: 0.2882041970351209
        }
      }
    }
  },
  "18b1686ceb4": {
    breaks: "chartmob3_reconc_breaks.json",
    small: {
      model: {
        N: 344,
        D: 6,
        b: 0.3309416402875685,
        kernelType: "linear",
        w: [
          -0.20000267112106263,
          0.42809635761540643,
          0.46656203058966117,
          1.841671684760453,
          -0.6434524674952959,
          0.49143545422517687
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6764124363859395,
          stdDev: 0.3236057116921364
        },
        nPoints: {
          mean: 4.116279069767442,
          stdDev: 0.8069465847859293
        },
        scaledS1: {
          mean: 0.1858035195675879,
          stdDev: 0.21428670248595916
        },
        scaledS2: {
          mean: 0.12950420831848175,
          stdDev: 0.15751874574784924
        },
        nPointsChart: {
          mean: 15.761627906976743,
          stdDev: 9.783137376835176
        },
        chartPct: {
          mean: 0.300526358561615,
          stdDev: 0.1927265795559554
        }
      }
    },
    big: {
      model: {
        N: 734,
        D: 18,
        b: -0.33318046701370874,
        kernelType: "linear",
        w: [
          0.032315062605570585,
          0.48106580584263436,
          -1.1047252909009055,
          3.7368759283052406,
          -0.6183759573768267,
          0.6939892440180402,
          0.3861182101902436,
          -0.4528094207813589,
          0.19685209857044894,
          0.5317134144006395,
          -0.3268861531591498,
          0.5416909853776097,
          0.11204746654248579,
          -0.042886524593192116,
          0.04725504450122949,
          0.09451185559860642,
          -0.011544267888957445,
          0.17029310632188632
        ]
      },
      stats: {
        absCorrCoeff: {
          mean: 0.6349627683741144,
          stdDev: 0.3047569778403939
        },
        nPoints: {
          mean: 13.728882833787466,
          stdDev: 8.419998905023999
        },
        scaledS1: {
          mean: 0.07039535118699393,
          stdDev: 0.06922873611482698
        },
        scaledS2: {
          mean: 0.06255041459772398,
          stdDev: 0.05952611432033109
        },
        nPointsChart: {
          mean: 23.705722070844686,
          stdDev: 11.739000887557054
        },
        chartPct: {
          mean: 0.6095266522529739,
          stdDev: 0.26470522117524425
        },
        runsTest2: {
          mean: 5.129427792915531,
          stdDev: 2.7706078547777717
        },
        runsTest3: {
          mean: 7.603857452118007,
          stdDev: 4.140301994340143
        },
        runsTest4: {
          mean: 1.6191709447588931,
          stdDev: 0.5436847808406448
        },
        runsTest5: {
          mean: 0.32151695128382807,
          stdDev: 0.19159541197646354
        },
        outlierTest1: {
          mean: 2.116230031599242,
          stdDev: 0.5977792703826863
        },
        outlierTest2: {
          mean: 0.09400544959128065,
          stdDev: 0.29203530028780983
        }
      }
    }
  }
};
function bie() {
  return Object.keys(gN).sort();
}
function wie(t) {
  return gN[t ?? bie().at(-1)];
}
var xie = Object.defineProperty, Eie = (t, e, r) => e in t ? xie(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Sie = (t, e, r) => (Eie(t, e + "", r), r);
const Aie = 0.2;
function mN(t, e, r = Aie) {
  if (t.length === 3)
    return 1;
  const n = t.points.at(-1).x - t.points[0].x, i = (t.points.at(-1).y - t.points[0].y) / n, s = Math.atan(i), o = Math.cos(s), a = t.points.map((f) => f.y), l = t.slice(1, t.length - 1);
  let c = a.indexOf(Math.min(...a)) - 1;
  (c < 0 || c === l.length) && (c = null);
  let p = a.indexOf(Math.max(...a)) - 1;
  (p < 0 || p === l.length) && (p = null);
  const h = [], d = l.points.map((f) => {
    const E = f.x - t.points[0].x, A = Math.abs(f.y - (i * E + t.points[0].y));
    return h.push(A), A * o;
  }), v = d.indexOf(Math.max(...d));
  let m = !1;
  c !== null && Math.abs(c - v) / (e - 1) <= r && (m = h[c] > d[v]);
  let b = !1;
  return p !== null && Math.abs(p - v) / (e - 1) <= r && (b = h[p] > d[v]), b ? p + 1 : m ? c + 1 : v + 1;
}
class kie {
  /**
   * @param model - (Optional) ID of split model to use.
   */
  constructor(e = void 0) {
    Sie(this, "models");
    const r = wie(e);
    if (r)
      this.models = {
        small: {
          svm: new A7(),
          stats: r.small.stats
        },
        big: {
          svm: new A7(),
          stats: r.big.stats
        }
      };
    else
      throw new Error(`unknown model ID: '${e}'`);
    this.models.small.svm.fromJSON(r.small.model), this.models.big.svm.fromJSON(r.big.model);
  }
  /**
   * Predict whether a sequence should be split.
   * @param seq - Data points of sequence to evaluate. 
   * @param chartLength - Number of data points in the complete chart
   * of which 'seq' is a part.
   * @returns Whether the sequence should be split.
   */
  shouldSplit(e, r) {
    if (e.length < 3 || e.points.every((a) => a.y === e.points[0].y))
      return !1;
    const n = new vie(), i = e.length < 6 ? "small" : "big", [s] = n.computeMatrix(
      [{ data: e, chartLength: r }],
      this.models[i].stats
    ), [o] = this.models[i].svm.predict([s]);
    return o === 1;
  }
  /**
   * Predict trend sequences a series should be split into.
   * @param series - Data points of series to split.
   * @param yAxis - Displayed chart y-axis bounds; defaults to extreme values of data
   * @param pipCloseness - Max distance (as % of chart length) a sequence-local 
   * min/max point can be from the PIP to be a possible split point.
   * @returns List of index pairs denoting the start and end of each sequence.
   * @remarks
   * As in slices, the end index in a pair is not included in the set of indices
   * included in a sequence.
   * NB: Adjacent sequences share the point where they were split.
   * E.g., a hypothetical set of sequences might look like:
   *   [\{start: 0, end: 5\}, \{start: 4, end: 7\}, \{start: 6, end: 10\}]
   * where the first two sequences share the point at index 4, and the last
   * two share the point at index 6.
   */
  getSequences(e, r, n) {
    const i = e.length;
    e = e.project(void 0, r);
    const s = [], o = (a, l) => {
      const c = e.slice(a, l);
      if (this.shouldSplit(c, e.length)) {
        const p = mN(c, e.length, n) + a;
        o(a, p + 1), o(p, l);
      } else
        s.push({ start: a, end: l });
    };
    return o(0, i), s;
  }
}
const _ie = 6, Cie = 5;
function Iie(t) {
  const e = Uo(t), r = t.map((n) => n - e);
  return Math.sqrt(r.reduce((n, i) => n + i ** 2, 0));
}
function Nm(t) {
  return Math.sign(t);
}
function Pie(t, e = Cie, r = e) {
  const n = t.length;
  if (n < 3) {
    let i = (t.points[1].y - t.points[0].y) / (t.points[1].x - t.points[0].x);
    const s = Vf(i);
    return Math.abs(s) < r && (i = 0), { classes: [Nm(i)], slope: i, angle: s };
  } else {
    const i = t.bestFit.rss();
    if (n < _ie) {
      let h = Nm(t.bestFit.slope);
      return Math.abs(t.bestFit.xAngle) < r && (h = 0), { classes: [h], slope: t.bestFit.slope, angle: t.bestFit.xAngle };
    }
    const s = t.points.map((h) => h.x), o = Math.sqrt(i / (n - 2)) / Iie(s), a = 1 - 0.05 / 2, l = new aie(n - 2).invCumulativeProbability(a) * o, c = [t.bestFit.slope - l, t.bestFit.slope + l], p = [];
    return Math.sign(c[0]) !== Math.sign(c[1]) ? (p.push(0), Math.abs(t.bestFit.xAngle) >= e && p.push(Nm(t.bestFit.slope))) : (p.push(Nm(t.bestFit.slope)), Math.abs(t.bestFit.xAngle) < e && t.bestFit.slope && p.push(0)), { classes: p, slope: t.bestFit.slope, angle: t.bestFit.xAngle, moe: l };
  }
}
function Rie(t, e) {
  return t.size !== e.size ? !1 : Array.from(t).every((r) => e.has(r));
}
function Oie(t) {
  const e = [];
  for (let r = 0; r < t.length; r++)
    for (let n = r + 1; n < t.length; n++)
      e.push([t[r], t[n]]);
  return e;
}
function Tie(t, e) {
  return {
    start: Math.min(t.start, e.start),
    end: Math.max(t.end, e.end)
  };
}
function Lie(t, e) {
  return t.start === e.start && t.end === e.end;
}
function Mie(t, e) {
  return t.start >= e.start && t.start <= e.end || e.start >= t.start && e.start <= e.end;
}
function Nie(t, e) {
  const r = [t.points[0].x, ...e, t.points.at(-1).x], n = [];
  for (let i = 1; i < r.length; i++)
    n.push({ start: r[i - 1], end: r[i] });
  return n;
}
let Ux = class ul {
  /**
   * Do not use; call TrackingGroup.getGroups() to create tracking groups.
   * @internal
   */
  constructor(e, r, n) {
    this.keys = e, this.interval = r, this.seriesByKey = n;
  }
  /**
   * Compute tracking groups for the set of series of a chart.
   * @param allSeries - All series of a chart.
   * @param minSize - Value between 0 and 1 determining the minimum size of a 
   * tracking group (as a percentage of chart width).
   * @param closeness - Value between 0 and 1 determining the degree of tracking
   * closeness required for lines to pair/group.
   * @returns The tracking groups.
   */
  static getGroups(e, r = 0.25, n = 0.9) {
    const i = /* @__PURE__ */ new Map();
    e.forEach((p) => i.set(p.key, p));
    const s = Oie(e).map(([p, h]) => [p.key, h.key]);
    let o = [];
    const a = Math.min(...e.map((p) => p.yBounds().start)), l = {
      start: 0,
      end: Math.max(...e.map((p) => p.yBounds().end)) - a
    };
    for (const p of s) {
      const h = new zie(
        i.get(p[0]),
        i.get(p[1]),
        0.5
      ).getRelativeTrajectories(l).filter((d) => d.type === "tracking" && d.interval.end - d.interval.start >= e[0].xRange() * r && d.degree >= n).map((d) => ({ keyPair: p, interval: d.interval }));
      o = o.concat(h);
    }
    let c = ul.createGroupsFromPairs(o, i);
    return c = ul.normalizeGroups(c), c.reverse(), c;
  }
  static createGroupsFromPairs(e, r) {
    const n = [];
    function i(l) {
      return n.findIndex((c) => c.start === l.start && c.end === l.end);
    }
    for (const l of e)
      i(l.interval) === -1 && n.push(l.interval);
    const s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
    for (const { keyPair: l, interval: c } of e) {
      const p = i(c);
      let h = s.get(p);
      h || (h = [], s.set(p, h)), h.push(l);
      let d = o.get(p);
      d || (d = [], o.set(p, d));
      for (const v of l)
        d.includes(v) || d.push(v);
    }
    const a = [];
    for (const [l, c] of o) {
      const p = s.get(l);
      let h = [];
      for (const d of p) {
        const v = h.find((b) => b.has(d[0])), m = h.find((b) => b.has(d[1]));
        !v && !m ? h.push(new Set(d)) : v && m && v !== m ? (m.forEach((b) => v.add(b)), h = h.filter((b) => b !== m)) : v ? v.add(d[1]) : m.add(d[0]);
      }
      for (const d of h)
        a.push(new ul(d, n[l], r));
    }
    return a;
  }
  /**
   * Supplement smaller tracking groups contained entirely within larger ones.
   * Line groups are updated in-place.
   * @internal
   */
  static suppleteGroups(e) {
    let r = !1;
    e.sort((n, i) => {
      const s = n.interval.end - n.interval.start, o = i.interval.end - i.interval.start;
      return Math.sign(o - s);
    });
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      for (let s = n + 1; s < e.length; s++) {
        const o = e[s];
        if (!(i.interval.start > o.interval.start || i.interval.end < o.interval.end))
          if (i.interval.end - i.interval.start === o.interval.end - o.interval.start) {
            const a = i.supplete(o), l = o.supplete(i);
            r || (r = a || l);
          } else {
            const a = i.supplete(o);
            r || (r = a);
          }
      }
    }
    return r;
  }
  /**
   * Supplete group 'other' in-place.
   */
  supplete(e) {
    let r = !1;
    if (Array.from(this.keys).some((n) => e.keys.has(n)))
      for (const n of this.keys)
        e.keys.has(n) || (e.keys.add(n), r = !0);
    return r;
  }
  /**
   * Create a new array of tracking groups by merging any groups
   * that overlap (or abut) and consist of the same set of lines.
   * @param groups - Original array of tracking groups
   * @returns New array of tracking groups
   * @internal
   */
  static mergeGroups(e) {
    if (e.length) {
      let r;
      do {
        r = [];
        const n = [];
        e:
          for (let i = 0; i < e.length; i++) {
            const s = e[i];
            for (let o = i + 1; o < e.length; o++) {
              const a = e[o];
              if (Mie(s.interval, a.interval) && Rie(s.keys, a.keys)) {
                r.push(new ul(
                  s.keys,
                  Tie(s.interval, a.interval),
                  s.seriesByKey
                )), n.push(s, a);
                break e;
              }
            }
          }
        e = e.filter((i) => !n.includes(i)).concat(r);
      } while (r.length);
    }
    return e;
  }
  /**
   * Iteratively supplete and merge a set of tracking groups until
   * we can't supplete any group further.
   * @internal
   */
  static normalizeGroups(e) {
    let r = ul.suppleteGroups(e);
    do
      e = ul.mergeGroups(e), r = ul.suppleteGroups(e);
    while (r);
    return e;
  }
  /**
   * Get series not included in the tracking group.
   * @returns The outlier line keys relative to the group.
   */
  outliers() {
    return Array.from(this.seriesByKey.keys()).filter((e) => !this.keys.has(e)).sort();
  }
  /**
   * Compute the line of averaged values from the lines in the tracking group.
   * @returns The average line.
   */
  averageLine() {
    const e = Array.from(this.keys).map((n) => this.seriesByKey.get(n).extractSection(this.interval)), r = e.length;
    return new u0(Gu(e[0].length, (n) => ({
      x: e[0].points[n].x,
      y: Gu(r, (i) => e[i].points[n].y).reduce((i, s) => i + s) / r
    })));
  }
}, Die = class yN {
  /**
   * Do not use; call TrackingZone.getZones() to create tracking zones.
   */
  constructor(e, r) {
    this.trackingGroups = e, this.interval = r;
  }
  /**
   * Compute tracking zones from a set of tracking groups.
   * @param trackingGroups - Tracking groups of the chart.
   * @returns The list of tracking zones.
   * @public
   */
  static getZones(e) {
    const r = /* @__PURE__ */ new Set();
    e.forEach((o) => {
      r.add(o.interval.start), r.add(o.interval.end);
    });
    const n = Array.from(r).sort().slice(1, -1), i = Nie(
      e[0].seriesByKey.values().next().value,
      n
    ), s = [];
    for (const o of i) {
      let a = !1;
      for (const l of e)
        if (l.interval.start <= o.start && l.interval.end >= o.end) {
          const c = s.find((h) => Lie(o, h.interval)), p = new Ux(new Set(l.keys), o, l.seriesByKey);
          c ? c.trackingGroups.push(p) : (s.push(new yN([p], o)), a = !0);
        }
      if (a) {
        const l = s.at(-1);
        l.trackingGroups = Ux.normalizeGroups(l.trackingGroups);
      }
    }
    return s;
  }
};
const $ie = 2, Vx = -1;
function jie(t, e, r) {
  const n = r.map((i) => Math.abs(e - i));
  return n.sort((i, s) => Math.sign(i - s)), n[t];
}
function Bie(t, e, r, n) {
  let i = -1;
  const s = /* @__PURE__ */ new Map();
  for (const o of t) {
    if (s.get(o) !== void 0)
      continue;
    const a = C7(t, e, o, r);
    if (a.length < n) {
      s.set(o, Vx);
      continue;
    }
    i++, s.set(o, i);
    const l = new Set(Array.from(a).filter((c) => c !== o));
    for (const c of l) {
      if (s.get(c) === Vx && s.set(c, i), s.get(c) !== void 0)
        continue;
      s.set(c, i);
      const p = C7(t, e, c, r);
      if (p.length >= n)
        for (const h of p)
          l.add(h);
    }
  }
  return s;
}
function C7(t, e, r, n) {
  return t.filter((i) => e(r, i) <= n);
}
class Fie {
  /**
   * @param allSeries - All series of a chart.
   * @param minPts - Optional min neighbors (including itself) a point must have
   * to be considered a core point.
   */
  constructor(e, r = $ie) {
    this.clusters = [], this.noise = [];
    const n = e.map((h) => Uo(h.points.map((d) => d.y))), i = n.map((h) => jie(1, h, n)).toSorted((h, d) => -Math.sign(h - d)), s = u0.fromValues(i), o = mN(s, s.length), a = Math.min(...e.map((h) => h.yBounds().start)), l = (Math.max(...e.map((h) => h.yBounds().end)) - a) / 10, c = Math.max(i[o], l), p = Bie(n, (h, d) => Math.abs(h - d), c, r);
    for (let h = 0; h < n.length; h++) {
      const d = p.get(n[h]);
      if (d === Vx)
        this.noise.push(e[h]);
      else {
        let v = this.clusters[d];
        v || (this.clusters[d] = v = []), v.push(e[h]);
      }
    }
  }
}
class zie extends hN {
  constructor(e, r, n) {
    super(e, r, n), this.differentialLine = this.computeDifferentialLine();
  }
  computeDifferentialLine() {
    let e = new u0(this.series1.points.map(
      (n, i) => ({ x: n.x, y: Math.abs(n.y - this.series2.points[i].y) })
    ));
    const r = this.intersectingSegPairs.filter((n) => n.intersection !== "Overlap").filter((n) => !n.intersection.atRecord).map((n) => n.intersection.crosspoint);
    for (const n of r) {
      const i = e.points.findLastIndex((o) => n.x > o.x), s = Array.from(e.points);
      s.splice(i + 1, 0, { x: n.x, y: 0 }), e = new u0(s);
    }
    return e;
  }
  /**
   * 
   * @param yAxis - Interval from 0 to the y-range of the chart, representing
   * the minimum and maximum possible y-value differences between records of two series.
   * @returns 
   */
  getRelativeTrajectories(e) {
    const r = [], n = new kie().getSequences(this.differentialLine, e), i = this.differentialLine.project(void 0, e), s = n.map(
      ({ start: a, end: l }) => Pie(i.slice(a, l))
    );
    for (let a = 0; a < n.length; a++) {
      const l = s[a];
      if (l.classes.length === 2 && Math.abs(l.moe) < Math.abs(l.slope)) {
        const p = l.classes.indexOf(0);
        Math.abs(l.angle) < 5 ? l.classes.splice(1 - p, 1) : l.classes.splice(p, 1);
      }
      const c = {
        start: this.differentialLine.points[n[a].start].x,
        end: this.differentialLine.points[n[a].end - 1].x
      };
      l.classes[0] === 0 ? r.push({
        interval: c,
        type: "tracking",
        degree: 1 - Dx(
          this.differentialLine.slice(n[a].start, n[a].end).points.map((p) => p.y)
        ) / e.end
      }) : r.push({
        interval: c,
        type: l.classes[0] === 1 ? "diverging" : "converging",
        degree: Math.abs(l.angle / 90)
      });
    }
    const o = [];
    if (r.length) {
      o.push(r[0]);
      for (let a = 1; a < r.length; a++)
        r[a].type === r[a - 1].type ? o.at(-1).interval.end = r[a].interval.end : o.push(r[a]);
    }
    return o;
  }
}
let Uie = class extends pN {
  constructor(e, r, n, i) {
    super(e, r, n, i);
    const s = Ux.getGroups(e, void 0, 0.9);
    this.trackingGroups = s.map((a) => this.generateTrackingGroupMetadata(a)), s.length && (this.trackingZones = Die.getZones(s).map((a) => this.generateTrackingZoneMetadata(a)));
    const o = new Fie(e);
    this.clusters = o.clusters.map((a) => a.map((l) => l.key)), this.clusterOutliers = o.noise.map((a) => a.key);
  }
  generateTrackingGroupMetadata(e) {
    return {
      keys: Array.from(e.keys),
      outliers: e.outliers(),
      valueInterval: [e.interval.start, e.interval.end],
      averageLine: e.averageLine().points.map((r) => [r.x, r.y])
    };
  }
  generateTrackingZoneMetadata(e) {
    return {
      groups: e.trackingGroups.map((r) => this.generateTrackingGroupMetadata(r)),
      valueInterval: [e.interval.start, e.interval.end]
    };
  }
};
var Vie = /* @__PURE__ */ ((t) => (t[t.NONE = 0] = "NONE", t[t.SOME = 1] = "SOME", t[t.MOST = 2] = "MOST", t[t.ALL = 3] = "ALL", t))(Vie || {});
let vN = 2;
function XCe(t) {
  vN = t;
}
class Hie {
  constructor(e, r) {
    this.name = e, this.level = r;
  }
  /**
   * Log an info message. Only prints if level is ALL.
   * @param data - The data to log.
   */
  info(...e) {
    this.level === 3 && console.log(`[${this.name}]`, ...e);
  }
  /**
   * Log a warning message. Prints if level is MOST or ALL.
   * @param data - The data to log.
   */
  warn(...e) {
    this.level >= 2 && console.warn(`[${this.name}]`, ...e);
  }
  /**
   * Log an error message. Prints if level is SOME, MOST, or ALL.
   * @param data - The data to log.
   */
  error(...e) {
    this.level >= 1 && console.error(`[${this.name}]`, ...e);
  }
}
function qt(t) {
  return new Hie(t, vN);
}
function Gie(t) {
  return typeof t == "function" ? t() : t;
}
const $2 = class $2 extends Event {
  /**
   * @param  {string} key of the state that has changed
   * @param  {unknown} value for the changed key
   */
  constructor(e, r, n) {
    super($2.eventName, {
      cancelable: !1
    }), this.key = e, this.value = r, this.state = n;
  }
};
$2.eventName = "lit-state-changed";
let Qu = $2;
const Wie = (t, e) => e !== t && (e === e || t === t), zk = class zk extends EventTarget {
  static initPropertyMap() {
    this.propertyMap || (this.propertyMap = /* @__PURE__ */ new Map());
  }
  get propertyMap() {
    return this.constructor.propertyMap;
  }
  get stateValue() {
    return Object.fromEntries([...this.propertyMap].map(([e]) => [e, this[e]]));
  }
  constructor() {
    super(), this.hookMap = /* @__PURE__ */ new Map(), this.constructor.finalize(), this.propertyMap && [...this.propertyMap].forEach(([e, r]) => {
      if (r.initialValue !== void 0) {
        const n = Gie(r.initialValue);
        this[e] = n, r.value = n;
      }
    });
  }
  static finalize() {
    if (this.finalized)
      return !1;
    this.finalized = !0;
    const e = Object.keys(this.properties || {});
    for (const r of e)
      this.createProperty(r, this.properties[r]);
    return !0;
  }
  static createProperty(e, r) {
    this.finalize();
    const n = typeof e == "symbol" ? Symbol() : `__${e}`, i = this.getPropertyDescriptor(String(e), n, r);
    Object.defineProperty(this.prototype, e, i);
  }
  static getPropertyDescriptor(e, r, n) {
    const i = (n == null ? void 0 : n.hasChanged) || Wie;
    return {
      get() {
        return this[r];
      },
      set(s) {
        const o = this[e];
        this[r] = s, i(s, o) === !0 && this.dispatchStateEvent(e, s, this);
      },
      configurable: !0,
      enumerable: !0
    };
  }
  /**
   * Reset the state to its original values, skipping
   * properties marked as skipReset
   */
  reset() {
    this.hookMap.forEach((e) => e.reset()), [...this.propertyMap].filter(([e, r]) => !(r.skipReset === !0 || r.resetValue === void 0)).forEach(([e, r]) => {
      this[e] = r.resetValue;
    });
  }
  /**
   * subscribe to state change event. The callback will be called anytime
   * a state property change if `nameOrNames` is undefined, or only for matching
   * property values specified by `nameOrNames`
   * @param callback the callback function to call
   * @param nameOrNames
   * @returns a unsubscribe function.
   */
  subscribe(e, r, n) {
    r && !Array.isArray(r) && (r = [r]);
    const i = (s) => {
      (!r || r.includes(s.key)) && e(s.key, s.value, this);
    };
    return this.addEventListener(Qu.eventName, i, n), () => this.removeEventListener(Qu.eventName, i);
  }
  dispatchStateEvent(e, r, n) {
    this.dispatchEvent(new Qu(e, r, n));
  }
};
zk.finalized = !1;
let Ay = zk;
class S5 {
  constructor(e, r, n) {
    this.host = e, this.state = r, this.callback = n || (() => this.host.requestUpdate()), this.host.addController(this);
  }
  dispose() {
    this.state.removeEventListener(Qu.eventName, this.callback);
  }
  hostConnected() {
    this.state.addEventListener(Qu.eventName, this.callback), this.callback();
  }
  hostDisconnected() {
    this.dispose();
  }
}
function Ar(t) {
  return (e, r) => {
    if (Object.getOwnPropertyDescriptor(e, r))
      throw new Error("@property must be called before all state decorators");
    const n = e.constructor;
    n.initPropertyMap();
    const i = e.hasOwnProperty(r);
    return n.propertyMap.set(r, {
      ...t,
      initialValue: t == null ? void 0 : t.value,
      resetValue: t == null ? void 0 : t.value
    }), n.createProperty(r, t), i ? Object.getOwnPropertyDescriptor(e, r) : void 0;
  };
}
new URL(location.href);
class ts extends $r {
  get store() {
    return this._store;
  }
  set store(e) {
    this._store = e, this._storeState = new S5(this, e);
  }
  extractStyles(e) {
    const r = this.shadowRoot.adoptedStyleSheets, n = [];
    for (const i of r) {
      const s = i.cssRules;
      for (let o = 0; o < s.length; o++) {
        const a = s.item(o);
        n.push(a.cssText.replace(/^:host/, `#${e}`));
      }
    }
    return n.join(`
`);
  }
}
class qie {
  constructor(e) {
    this._store = e, this._voice = null, this._lang = "en-US", this._rate = 1, this._volume = 1, this._pitch = 1, this._utterance = null, this._highlightIndex = null, this._speakingCount = 0, this.log = qt("Voicing"), this._voice = window.speechSynthesis, this._voice || this.log.warn("Speech Synthesis unsupported");
  }
  get highlightIndex() {
    return this._highlightIndex;
  }
  get isSpeaking() {
    return this._speakingCount > 0;
  }
  speak(e, r, n = 0) {
    if (this._voice) {
      this.shutUp(), this._utterance = this.speakText(e), this._speakingCount++;
      const i = (s) => r.findIndex((o) => s >= o.start && s < o.end);
      this._utterance.onboundary = (s) => {
        const o = i(s.charIndex);
        if (o === -1) {
          this._highlightIndex = null;
          return;
        }
        this._highlightIndex = o;
        const a = r[this._highlightIndex];
        this._store.paraChart.postNotice("utteranceBoundary", a);
      }, this._utterance.onend = (s) => {
        this._store.paraChart.postNotice("utteranceEnd", null), this._speakingCount--;
      };
    }
  }
  speakText(e) {
    return this._utterance = new SpeechSynthesisUtterance(e), this._utterance.rate = this._rate, this._utterance.lang = this._lang, this._utterance.pitch = this._pitch, this._utterance.volume = this._volume, this._voice.speak(this._utterance), this._utterance;
  }
  pause() {
    var e;
    (e = this._voice) == null || e.pause();
  }
  resume() {
    var e;
    (e = this._voice) == null || e.resume();
  }
  togglePaused() {
    this.isPaused ? this.resume() : this.pause();
  }
  get isPaused() {
    var e;
    return (e = this._voice) == null ? void 0 : e.paused;
  }
  shutUp() {
    this._voice && this._voice.speaking && (this._voice.cancel(), this._highlightIndex = null);
  }
  get lang() {
    return this._lang;
  }
  set lang(e) {
    this._lang = e;
  }
  get rate() {
    return this._rate;
  }
  set rate(e) {
    this._rate = e;
  }
  get volume() {
    return this._volume;
  }
  set volume(e) {
    this._volume = e;
  }
  get pitch() {
    return this._pitch;
  }
  set pitch(e) {
    this._pitch = e;
  }
}
const A5 = Nt`
  :host,
  :root {
    --axis-line-color: hsl(0, 0%, 0%);
    --label-color: hsl(0, 0%, 0%);
    --tick-grid-color: hsl(270, 50%, 50%);
    --background-color: white;
    --theme-color: var(--fizz-theme-color, purple);
    --theme-color-light: var(--fizz-theme-color-light, hsl(275.4, 100%, 88%));
    --theme-contrast-color: white;
    --fizz-theme-color: var(--paracharts-theme-color, navy);
    --fizz-theme-color-light: var(--paracharts-theme-color-light, hsl(210.5, 100%, 88%));
    /*--visited-color: red;*/
    --selected-color: var(--label-color);
    --datapoint-centroid: 50% 50%;
    --focus-animation: all 0.5s ease-in-out;
    --chart-cursor: pointer;
    --data-cursor: cell;

    /* default color palette */
    --color-palette-series-0: hsl(225, 30%, 52%);
    --color-palette-series-1: hsl(12, 69%, 35%);
    --color-palette-series-2: hsl(75, 43%, 45%);
    --color-palette-series-3: hsl(40, 100%, 49%);
    --color-palette-series-4: hsl(215, 37%, 66%);
    --color-palette-series-5: hsl(63, 100%, 23%);
    --color-palette-series-6: hsl(34, 57%, 46%);
    --color-palette-series-7: hsl(51, 56%, 64%);
    --color-palette-series-8: hsl(253, 26%, 43%);
    --color-palette-series-9: hsl(85, 65%, 36%);

    --focus-shadow-color: gray;
    --focus-shadow: drop-shadow(0px 0px 4px var(--focus-shadow-color));
  }

  .hidden { display: none !important; }

  /* https://kittygiraudel.com/snippets/sr-only-class/ */
  .sr-only {
    border: 0 !important;
    clip: rect(1px, 1px, 1px, 1px) !important;
    -webkit-clip-path: inset(50%) !important;
    clip-path: inset(50%) !important;
    height: 1px !important;
    overflow: hidden !important;
    margin: -1px !important;
    padding: 0 !important;
    position: absolute !important;
    width: 1px !important;
    white-space: nowrap !important;
  }

  * {
    font-family: "Trebuchet MS", Helvetica, sans-serif;
  }
  #y-axis-line {
    fill: none;
    stroke: var(--axis-line-color);
    stroke-width: 2px;
    stroke-linecap: round;
  }
  #x-axis-line {
    fill: none;
    stroke: var(--axis-line-color);
    opacity: 1;
    stroke-width: 2px;
    stroke-linecap: round;
  }
  .chart-title {
    font-size: 1.25rem;
  }
  /*.chart-title .middle {
    text-anchor: middle;
  }
  .chart-title .end {
    text-anchor: end;
  }*/
  .label {
    display: block;
    fill: var(--label-color);
  }
  .axis-title {
    text-anchor: middle;
  }
  .tick-label {
    fill: var(--label-color);
  }
  /*.tick-label.horiz {
    text-anchor: middle;
  }
  .tick-label.horiz.rotated {
    text-anchor: end;
  }
  .tick-label.horiz.rotated.north {
    text-anchor: start;
  }
  .tick-label.vert {
    text-anchor: end;
  }
  .tick-label.vert.east {
    text-anchor: start;
  }*/
  .tickmark-y {
    opacity: 0.2;
  }
  .tickmark-y-0 {
    fill: var(--tick-grid-color);
    stroke: var(--tick-grid-color);
    opacity: 1;
    stroke-width: 2px;
    stroke-linecap: round;
  }
  .tick-group-y:hover, .tick-group-y:hover .tickmark-y {
    font-weight: bold;
    opacity: 1;
  }
  .tickmark-x {
    opacity: 0.2;
  }
  .tickmark-x-0 {
    fill: var(--tick-grid-color);
    stroke: var(--tick-grid-color);
    opacity: 1;
    stroke-width: 2px;
    stroke-linecap: round;
  }
  .tick-group-x:hover, .tick-group-x:hover .tickmark_x {
    font-weight: bold;
    opacity: 1;
  }
  rect#data-backdrop {
    stroke: none;
    fill: none;
    pointer-events: all;
  }
  .stack {
    stroke-width: 0;
  }
  .bar:hover, .bar:focus {
    fill: hsl(270, 50%, 65%);
    outline: 2px auto -webkit-focus-ring-color;
  }
  .datapoint_background {
    fill: none;
    stroke: none;
    pointer-events: all;
    outline: none;
  }
  .datapoint_background:hover,
  .datapoint_background:focus {
    outline: 2px auto -webkit-focus-ring-color;
    box-shadow: none;
  }
  .data-line {
    fill: none;
    /*stroke-width: 3px;*/
    stroke-linecap: round;
  }
  .data_area {
    stroke: hsl(270, 50%, 50%);
    stroke-width: 3px;
    stroke-linecap: round;
    fill: none;
  }
  .data_area_background {
    stroke: none;
    fill: hsl(270, 50%, 50%);
    fill-opacity: 0.8;
  }
  .trendline {
    stroke: red;
    stroke-width: 3px;
    fill: none;
  }
  .center_label > tspan.subtext {
    font-size: 2rem;
    text-anchor: middle;
  }
  /*g.datapoint {
    transform-origin: var(--datapoint-centroid);
  }*/
  g.datapoint g.datapoint_popup rect {
    fill: hsl(0, 0%, 25%);
  }
  g.datapoint g.datapoint_popup text {
    fill: white;
    font-size: 1rem;
    text-anchor: middle;
  }
  g.datapoint g.datapoint_popup {
    stroke: none;
    opacity: 0.0;
    transition: opacity 0.3s ease-in-out;
  }
  g.datapoint:focus g.datapoint_popup, g.datapoint:hover g.datapoint_popup {
    opacity: 1.0;
    transition: opacity 0.3s ease-in-out;
  }
  g.datapoint g.datapoint_popup .desc {
    opacity: 0.0;
  }
  g.datapoint:focus g.datapoint_popup .desc, g.datapoint:hover g.datapoint_popup .desc {
    opacity: 1.0;
    transition: opacity 0.3s ease-in-out 2s;
  }
  g.datapoint.visited {
    fill: var(--visited-color, red);
    stroke: var(--visited-color, red);
    transform-box: fill-box;
/*    transition: var(--focus-animation); */
  }
  g.datapoint.visited:focus {
    /*outline: none;
    box-shadow: none;*/
    transition: var(--focus-animation);
    filter: var(--focus-shadow);
    /*animation: pulse-animation 2s infinite;*/
  }

  [data-charttype="stepline"] g.datapoint.visited {
    fill: var(--visited-color, red);
    stroke: var(--visited-color, red);
    transform: none;
/*    transition: var(--focus-animation); */
  }

  /* use#visited-mark {
    fill: inherit;
    stroke: inherit;
    transition: inherit;
  } */
  use.visited-mark {
    pointer-events: none;
  }
  @keyframes pulse-animation {
    0% {
      filter: drop-shadow(0px 0px 0px gray);
    }
    100% {
      filter: drop-shadow(0px 0px 12px gray);
    }
  }
  /*[data-charttype="line"] g.datapoint.visited {
    transform: scale(1.5);
  }
  [data-charttype="bar"] g.datapoint.visited {
    transform: scaleX(1.15);
  }*/
  .selected-datapoint-marker {
    fill: transparent;
    stroke: var(--selected-color);
    stroke-width: 3px;
    /*opacity: 0.5;*/
    pointer-events: none;
    stroke-linejoin: round;
  }
  .symbol {
    /*stroke-width: 2;*/
    stroke-linejoin: round;
  }
  .symbol.outline {
    fill: white;
  }
  .slice path {
    stroke: none;
    /*opacity: 0.5;*/
  }
  .slice text {
    fill: black;
    stroke: black;
    text-anchor: middle;
  }

  :fullscreen,
  ::backdrop {
    background-color: var(--background-color);
  }

  /* COLOR PALETTES */

  .theme-diva {
    --color-palette-series-0: hsl(225, 30%, 52%);
    --color-palette-series-1: hsl(12, 69%, 35%);
    --color-palette-series-2: hsl(75, 43%, 45%);
    --color-palette-series-3: hsl(40, 100%, 49%);
    --color-palette-series-4: hsl(215, 37%, 66%);
    --color-palette-series-5: hsl(63, 100%, 23%);
    --color-palette-series-6: hsl(34, 57%, 46%);
    --color-palette-series-7: hsl(51, 56%, 64%);
    --color-palette-series-8: hsl(253, 26%, 43%);
    --color-palette-series-9: hsl(85, 65%, 36%);
  }

  /* NOTE: not real deutan color palette! Replace after research */
  .theme-deutan {
    --color-palette-series-0: #800080;
    --color-palette-series-1: #ff00ff;
    --color-palette-series-2: #ca0088;
    --color-palette-series-3: #fa0080;
    --color-palette-series-4: #b400b4;
    --color-palette-series-5: #4477AA;
    --color-palette-series-6: #EE6677;
    --color-palette-series-7: #228833;
    --color-palette-series-8: #CCBB44;
    --color-palette-series-9: #66CCEE;
    --color-palette-series-10: #AA3377;
  }

  /* NOTE: not real protan color palette! Replace after research */
  .theme-protan {
    --color-palette-series-0: hsl(39, 70%, 54%);
    --color-palette-series-1: hsl(206, 68%, 66%);
    --color-palette-series-2: hsl(154, 39%, 44%);
    --color-palette-series-3: hsl(56, 81%, 66%);
    --color-palette-series-4: hsl(209, 57%, 43%);
    --color-palette-series-5: hsl(24, 68%, 46%);
    --color-palette-series-6: hsl(324, 35%, 62%);
  }

  /* NOTE: not real tritan color palette! Replace after research */
  .theme-tritan {
    --color-palette-series-0: #77AADD;
    --color-palette-series-1: #99DDFF;
    --color-palette-series-2: #44BB99;
    --color-palette-series-3: #BBCC33;
    --color-palette-series-4: #AAAAOO;
    --color-palette-series-5: #EEDD88;
    --color-palette-series-6: #FFAABB;
  }

  /* NOTE: not real grayscale color palette! Replace after research */
  .theme-grayscale {
    --color-palette-series-0: #262626;
    --color-palette-series-1: #595959;
    --color-palette-series-2: #7f7f7f;
    --color-palette-series-3: #a1a1a1;
    --color-palette-series-4: #bababa;
    --color-palette-series-5: #d4d4d4;
    --color-palette-series-6: #ededed;
  }

  .series-0 {
    fill: var(--color-palette-series-0);
    stroke: var(--color-palette-series-0);
  }
  .series-1 {
    fill: var(--color-palette-series-1);
    stroke: var(--color-palette-series-1);
  }
  .series-2 {
    fill: var(--color-palette-series-2);
    stroke: var(--color-palette-series-2);
  }
  .series-3 {
    fill: var(--color-palette-series-3);
    stroke: var(--color-palette-series-3);
  }
  .series-4 {
    fill: var(--color-palette-series-4);
    stroke: var(--color-palette-series-4);
  }
  .series-5 {
    fill: var(--color-palette-series-5);
    stroke: var(--color-palette-series-5);
  }
  .series-6 {
    fill: var(--color-palette-series-6);
    stroke: var(--color-palette-series-6);
  }
  .series-7 {
    fill: var(--color-palette-series-7);
    stroke: var(--color-palette-series-7);
  }
  .series-8 {
    fill: var(--color-palette-series-8);
    stroke: var(--color-palette-series-8);
  }
  .series-9 {
    fill: var(--color-palette-series-9);
    stroke: var(--color-palette-series-9);
  }

  .range-highlights {
    fill: pink;
    stroke: pink;
    fill-opacity: 0.25;
    stroke-width: 4px;
    stroke-opacity: 0.5;
  }
  .range-highlights rect[data-id="0"] {
    fill: orange;
    stroke: orange;
  }
  .range-highlights rect[data-id="1"] {
    fill: cyan;
    stroke: cyan;
  }
  .linebreaker[data-state=active] .linebreaker-marker {
    stroke: dodgerblue;
    stroke-width: 3px;
  }
  .best_fit_line[data-state=active] {
    display: inline;
    fill: none;
    stroke: hsl(315, 89%, 46%);
    stroke-width: 8px;
    stroke-linecap: butt;
    stroke-dasharray: 12 12;
    stroke-opacity: 0.5;
  }
  .best_fit_line[data-state=inactive] {
    display: none;
  }

  .setting-views {
    display: flex;
    gap: 1rem;
  }

  .setting-views+.setting-views {
    margin-top: 0.5rem;
  }

  figure {
    display: inline-block;
  }

  svg {
    display: block;
  }


  /* details box styles*/

  .tab-content {
    display: flex;
    flex-direction: row;
    gap: 1rem;
    align-items: center;
    justify-content: space-between;
    padding: 0.2rem;
  }

  .tab-content.stacked {
    flex-direction: column;
    gap: 0.1rem;
    align-items: flex-start;
    justify-content: space-between;
    padding: 0.5rem 0.2rem;
  }

  #chart-colors-presets {
    border: none;
    padding: 0;
    margin: 0;
  }

  #chart-colors-presets label {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
  }

  #chart-colors-presets label span {
    text-align: center;
    word-spacing: 20em;
  }

  /* dialog styles */

  #output_dialog {
    margin: 0 auto;
  }

  #output-dialog::backdrop {
    background: repeating-linear-gradient(
      45deg,
      rgba(128,0,128, 0.2),
      rgba(128,0,128, 0.2) 1px,
      rgba(128,0,128, 0.3) 1px,
      rgba(128,0,128, 0.3) 20px
    );
  }

  #output-dialog button {
    color: white;
    background-color: var(--theme-color);
    border: 1px solid var(--theme-color);
  }

  #output-dialog h1 {
    color: black;
    font-size: 1.3rem;
    font-weight: normal;
  }

  /* Tab Page styles */

  button {
    margin: 0.2rem;
    background-color: var(--theme-color);
    color: var(--theme-contrast-color);
    border: thin solid var(--theme-color);
    border-radius: 0.2em;
    padding: 0.2em;
  }

  #status_split {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }

  [role="graphics-document"] {
    cursor: var(--chart-cursor);
  }

  #chart-layers {
    cursor: var(--data-cursor);
  }
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Qie = (t) => t.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Av = { ATTRIBUTE: 1, CHILD: 2 }, kv = (t) => (...e) => ({ _$litDirective$: t, values: e });
let _v = class {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, r, n) {
    this._$Ct = e, this._$AM = r, this._$Ci = n;
  }
  _$AS(e, r) {
    return this.update(e, r);
  }
  update(e, r) {
    return this.render(...r);
  }
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const qf = (t, e) => {
  var n;
  const r = t._$AN;
  if (r === void 0) return !1;
  for (const i of r) (n = i._$AO) == null || n.call(i, e, !1), qf(i, e);
  return !0;
}, ky = (t) => {
  let e, r;
  do {
    if ((e = t._$AM) === void 0) break;
    r = e._$AN, r.delete(t), t = e;
  } while ((r == null ? void 0 : r.size) === 0);
}, bN = (t) => {
  for (let e; e = t._$AM; t = e) {
    let r = e._$AN;
    if (r === void 0) e._$AN = r = /* @__PURE__ */ new Set();
    else if (r.has(t)) break;
    r.add(t), Zie(e);
  }
};
function Kie(t) {
  this._$AN !== void 0 ? (ky(this), this._$AM = t, bN(this)) : this._$AM = t;
}
function Yie(t, e = !1, r = 0) {
  const n = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0) if (e) if (Array.isArray(n)) for (let s = r; s < n.length; s++) qf(n[s], !1), ky(n[s]);
  else n != null && (qf(n, !1), ky(n));
  else qf(this, t);
}
const Zie = (t) => {
  t.type == Av.CHILD && (t._$AP ?? (t._$AP = Yie), t._$AQ ?? (t._$AQ = Kie));
};
class Jie extends _v {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(e, r, n) {
    super._$AT(e, r, n), bN(this), this.isConnected = e._$AU;
  }
  _$AO(e, r = !0) {
    var n, i;
    e !== this.isConnected && (this.isConnected = e, e ? (n = this.reconnected) == null || n.call(this) : (i = this.disconnected) == null || i.call(this)), r && (qf(this, e), ky(this));
  }
  setValue(e) {
    if (Qie(this._$Ct)) this._$Ct._$AI(e, this);
    else {
      const r = [...this._$Ct._$AH];
      r[this._$Ci] = e, this._$Ct._$AI(r, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Et = () => new Xie();
class Xie {
}
const Sw = /* @__PURE__ */ new WeakMap(), yt = kv(class extends Jie {
  render(t) {
    return Ne;
  }
  update(t, [e]) {
    var n;
    const r = e !== this.G;
    return r && this.G !== void 0 && this.rt(void 0), (r || this.lt !== this.ct) && (this.G = e, this.ht = (n = t.options) == null ? void 0 : n.host, this.rt(this.ct = t.element)), Ne;
  }
  rt(t) {
    if (this.isConnected || (t = void 0), typeof this.G == "function") {
      const e = this.ht ?? globalThis;
      let r = Sw.get(e);
      r === void 0 && (r = /* @__PURE__ */ new WeakMap(), Sw.set(e, r)), r.get(this.G) !== void 0 && this.G.call(this.ht, void 0), r.set(this.G, t), t !== void 0 && this.G.call(this.ht, t);
    } else this.G.value = t;
  }
  get lt() {
    var t, e;
    return typeof this.G == "function" ? (t = Sw.get(this.ht ?? globalThis)) == null ? void 0 : t.get(this.G) : (e = this.G) == null ? void 0 : e.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Dt = (t) => (e, r) => {
  r !== void 0 ? r.addInitializer(() => {
    customElements.define(t, e);
  }) : customElements.define(t, e);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ese = { attribute: !0, type: String, converter: X1, reflect: !1, hasChanged: EE }, tse = (t = ese, e, r) => {
  const { kind: n, metadata: i } = r;
  let s = globalThis.litPropertyMetadata.get(i);
  if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = /* @__PURE__ */ new Map()), n === "setter" && ((t = Object.create(t)).wrapped = !0), s.set(r.name, t), n === "accessor") {
    const { name: o } = r;
    return { set(a) {
      const l = e.get.call(this);
      e.set.call(this, a), this.requestUpdate(o, l, t);
    }, init(a) {
      return a !== void 0 && this.C(o, void 0, t, a), a;
    } };
  }
  if (n === "setter") {
    const { name: o } = r;
    return function(a) {
      const l = this[o];
      e.call(this, a), this.requestUpdate(o, l, t);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function Ke(t) {
  return (e, r) => typeof r == "object" ? tse(t, e, r) : ((n, i, s) => {
    const o = i.hasOwnProperty(s);
    return i.constructor.createProperty(s, n), o ? Object.getOwnPropertyDescriptor(i, s) : void 0;
  })(t, e, r);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Ur(t) {
  return Ke({ ...t, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const wN = (t, e, r) => (r.configurable = !0, r.enumerable = !0, Reflect.decorate && typeof e != "object" && Object.defineProperty(t, e, r), r);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Ig(t) {
  return (e, r) => {
    const { slot: n, selector: i } = t ?? {}, s = "slot" + (n ? `[name=${n}]` : ":not([name])");
    return wN(e, r, { get() {
      var l;
      const o = (l = this.renderRoot) == null ? void 0 : l.querySelector(s), a = (o == null ? void 0 : o.assignedElements(t)) ?? [];
      return i === void 0 ? a : a.filter((c) => c.matches(i));
    } });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function rse(t) {
  return (e, r) => {
    const { slot: n } = {}, i = "slot" + (n ? `[name=${n}]` : ":not([name])");
    return wN(e, r, { get() {
      var o;
      const s = (o = this.renderRoot) == null ? void 0 : o.querySelector(i);
      return (s == null ? void 0 : s.assignedNodes(t)) ?? [];
    } });
  };
}
const Sl = class Sl {
  /**
   * Create a ScreenReaderBridge instance.
   * @param captionElement - the "caption" element, typically a span or div element
   */
  constructor(e) {
    this._maxNumPaddingCharacters = 3, this._numPaddingCharacters = 0, this._element = e, this._lastCreatedElement = null;
  }
  /**
   * Add the required aria attributes to an element for screen readers to properly work.
   * In order for the greatest number of screen reader and browser combinations to work, the following attributes must
   * be set on the element:
   * aria-live: assertive
   * roll: status
   * aria-atomic: true
   * aria-relevant: additions text
   * For the aria-live attribute, "polite" may also work, but that will create a queue of messages for the screen
   * reader to read out one after another which is probably not what you want.
   * @param element - the "caption" element which will host the messages for the screen reader to speak
   * @param [ariaLive] - the politeness of the aria-live attribute, one of "off", "assertive", or "polite"
   * @static
   */
  static addAriaAttributes(e, r = "assertive") {
    e.setAttribute("aria-live", r), e.setAttribute("role", "status"), e.setAttribute("aria-relevant", "additions text");
  }
  /**
   * The last created child element of the "caption" element.
   */
  get lastCreatedElement() {
    return this._lastCreatedElement;
  }
  /**
   * Clear the contents of the live region
   */
  clear() {
    this._element.innerHTML = "";
  }
  /**
   * Insert the provided text into the aria-live region.
   * @param text - the text to inserts
   */
  render(e) {
    const r = this._createPaddedText(e), n = document.createElement("div");
    n.textContent = r, n.setAttribute(
      Sl.ORIGINAL_TEXT_ATTRIBUTE,
      e
    ), n.setAttribute("data-created", Date.now().toString()), this.lastCreatedElement && (this._removeOldElements(), this.lastCreatedElement.style.display = "none"), this._element.appendChild(n), this._lastCreatedElement = n;
  }
  /**
   * Pad the provided text with the padding character.
   * Padding the text tricks screen readers into speaking it, even if they think it should be suppressed.
   * @param text - the text to pad
   * @private
   */
  _createPaddedText(e) {
    let r = "";
    for (let n = 0; n < this._numPaddingCharacters; n++)
      r += Sl.PADDING_CHARACTER;
    return this._numPaddingCharacters = (this._numPaddingCharacters + 1) % this._maxNumPaddingCharacters, e + r;
  }
  /**
   * Remove any hidden elements that were hidden longer than the set milliseconds.
   * We wait to remove those elements even though they are hidden because some screen readers don't like the DOM
   * changing that much.
   * @private
   */
  _removeOldElements() {
    const e = Date.now();
    Array.from(this._element.children).forEach((r) => {
      const n = Number(r.getAttribute("data-time"));
      e - n > Sl.REMOVAL_DELAY && this._element.removeChild(r);
    });
  }
};
Sl.PADDING_CHARACTER = "", Sl.REMOVAL_DELAY = 25, Sl.ORIGINAL_TEXT_ATTRIBUTE = "data-original-text";
let w0 = Sl;
const j2 = class j2 extends w0 {
  /**
   * Insert the provided text & highlights into the aria-live region.
   * @param text - the text to insert
   * @param highlights - the highlights to insert
   */
  renderHighlights(e, r) {
    super.render(e), this._lastCreatedElement.setAttribute(
      j2.ORIGINAL_HIGHLIGHT_ATTRIBUTE,
      JSON.stringify(r)
    );
  }
};
j2.ORIGINAL_HIGHLIGHT_ATTRIBUTE = "data-original-highlight";
let _y = j2;
var nse = Object.defineProperty, ise = Object.getOwnPropertyDescriptor, xN = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? ise(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && nse(e, r, i), i;
};
let Cy = class extends ts {
  constructor() {
    super(...arguments), this.announcement = { text: "", html: "", highlights: [], startFrom: 0 }, this._ariaLiveRef = Et(), this._history = [], this._historyDialogRef = Et();
  }
  get voicing() {
    return this._voicing;
  }
  // @simonvarey: I added this so that `Voicing` could receive `store` and `shadowRoot` for highlighting.
  //   In theory, it should have been possible to add this to `_initAriaLiveRegion`, but that
  //   caused errors when I tried.
  connectedCallback() {
    super.connectedCallback(), this._voicing = new qie(this.store);
  }
  _setHistory(t) {
    this._history = t, this._historyDialogRef.value.history = t;
  }
  willUpdate(t) {
    t.has("announcement") && this.announcement.text && (this.announcement.clear && this._srb.clear(), this._srb.renderHighlights(this.announcement.text, this.announcement.highlights));
  }
  firstUpdated(t) {
    var e;
    this._initAriaLiveRegion((e = this.shadowRoot) == null ? void 0 : e.querySelector("div"));
  }
  _initAriaLiveRegion(t) {
    w0.addAriaAttributes(t), t.setAttribute("lang", "en"), this._srb = new _y(t), new MutationObserver((r) => {
      r.forEach((n) => {
        if (n.addedNodes.length === 0)
          return;
        const i = n.addedNodes[0], s = i.getAttribute(w0.ORIGINAL_TEXT_ATTRIBUTE), o = i.getAttribute(_y.ORIGINAL_HIGHLIGHT_ATTRIBUTE);
        this._setHistory([...this._history, s ?? ""]), s && this._store.settings.ui.isVoicingEnabled && this._store.settings.ui.isAnnouncementEnabled && this._voicing.speak(s, JSON.parse(o), this.announcement.startFrom);
      });
    }).observe(t, {
      childList: !0
    });
  }
  showHistoryDialog() {
    this._historyDialogRef.value.show();
  }
  clear() {
    this._srb.clear();
  }
  get lastAnnouncement() {
    var t;
    return (t = this._srb.lastCreatedElement) == null ? void 0 : t.textContent;
  }
  replay() {
    const t = this.lastAnnouncement;
    t && this._store.announce(t);
  }
  render() {
    return this._voicing.rate = this._store.settings.ui.speechRate, We`
      <div
        ${yt(this._ariaLiveRef)}
        class="sr-only"
        data-testid="sr-status"
      ></div>
      <para-aria-live-history-dialog
        ${yt(this._historyDialogRef)}
      ></para-aria-live-history-dialog>
    `;
  }
};
Cy.styles = [
  A5,
  Nt`
      div {
        white-space: pre-line;
      }
    `
];
xN([
  Ke({ type: Object })
], Cy.prototype, "announcement", 2);
Cy = xN([
  Dt("para-aria-live-region")
], Cy);
var sse = Object.defineProperty, ose = Object.getOwnPropertyDescriptor, k5 = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? ose(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && sse(e, r, i), i;
};
let x0 = class extends ts {
  constructor() {
    super(...arguments), this._dialogRef = Et(), this.btnText = "Okay", this.history = [];
  }
  render() {
    const t = [{ tag: "cancel", text: this.btnText }];
    return We`
      <fizz-dialog
        ${yt(this._dialogRef)} 
        title="History" 
        .buttons=${t}
      >
        <ul class="history"
        >
          ${this.history.map((e) => We`
              <li>${e}</li>
            `)}
        </ul>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
x0.styles = Nt`
    .history {
      align-self: stretch;
    }
  `;
k5([
  Ke()
], x0.prototype, "btnText", 2);
k5([
  Ke({ type: Array })
], x0.prototype, "history", 2);
x0 = k5([
  Dt("para-aria-live-history-dialog")
], x0);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const EN = "important", ase = " !" + EN, mn = kv(class extends _v {
  constructor(t) {
    var e;
    if (super(t), t.type !== Av.ATTRIBUTE || t.name !== "style" || ((e = t.strings) == null ? void 0 : e.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t) {
    return Object.keys(t).reduce((e, r) => {
      const n = t[r];
      return n == null ? e : e + `${r = r.includes("-") ? r : r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${n};`;
    }, "");
  }
  update(t, [e]) {
    const { style: r } = t.element;
    if (this.ft === void 0) return this.ft = new Set(Object.keys(e)), this.render(e);
    for (const n of this.ft) e[n] == null && (this.ft.delete(n), n.includes("-") ? r.removeProperty(n) : r[n] = null);
    for (const n in e) {
      const i = e[n];
      if (i != null) {
        this.ft.add(n);
        const s = typeof i == "string" && i.endsWith(ase);
        n.includes("-") || s ? r.setProperty(n, s ? i.slice(0, -11) : i, s ? EN : "") : r[n] = i;
      }
    }
    return Ra;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Br = kv(class extends _v {
  constructor(t) {
    var e;
    if (super(t), t.type !== Av.ATTRIBUTE || t.name !== "class" || ((e = t.strings) == null ? void 0 : e.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t) {
    return " " + Object.keys(t).filter((e) => t[e]).join(" ") + " ";
  }
  update(t, [e]) {
    var n, i;
    if (this.st === void 0) {
      this.st = /* @__PURE__ */ new Set(), t.strings !== void 0 && (this.nt = new Set(t.strings.join(" ").split(/\s/).filter((s) => s !== "")));
      for (const s in e) e[s] && !((n = this.nt) != null && n.has(s)) && this.st.add(s);
      return this.render(e);
    }
    const r = t.element.classList;
    for (const s of this.st) s in e || (r.remove(s), this.st.delete(s));
    for (const s in e) {
      const o = !!e[s];
      o === this.st.has(s) || (i = this.nt) != null && i.has(s) || (o ? (r.add(s), this.st.add(s)) : (r.remove(s), this.st.delete(s)));
    }
    return Ra;
  }
}), ra = Nt`
  :host {
    --theme-color: var(--fizz-theme-color, purple);
    --theme-contrast-color: var(--fizz-theme-contrast-color, ghostwhite);
    --theme-extra-color: var(--fizz-theme-extra-color, ghostwhite);
    --theme-color-light: var(--fizz-theme-color-light, hsl(275.4, 100%, 88%));
    --theme-text-color: var(--fizz-theme-text-color, var(--theme-color, black));
    --theme-unselected-text-color: var(--fizz-theme-unselected-text-color, var(--theme-contrast-color, black));
    --theme-selected-text-decoration: var(--fizz-theme-selected-text-decoration, none);
    --control-panel-icon-color: var(--theme-unselected-text-color, ghostwhite);
    --contents-overflow: hidden;
  }

  /* * {
    background: var(--background, var(--theme-contrast-color));
  }*/
  .hidden {
    display: none !important;
  }

  .sr-only {
    width:1px;
    height:1px;
    overflow:hidden;
  }

`;
var lse = Object.defineProperty, cse = Object.getOwnPropertyDescriptor, zn = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? cse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && lse(e, r, i), i;
};
let sh = class extends $r {
  constructor() {
    super(...arguments), this.inline = !1, this.mode = "labels", this.tabs = [], this.icons = [], this.tabListRef = Et(), this.tabRefs = [];
  }
  set panelGroup(e) {
    if (this._panelGroup)
      throw new Error("panel group element is already set");
    this._panelGroup = e;
  }
  set currentPanel(e) {
    this.tabRefs.forEach((r, n) => {
      r.value.selected = n === e;
    }), this._panelGroup.currentPanel = e;
  }
  connectedCallback() {
    super.connectedCallback(), this.inline && (this.style.display = "inline-block");
  }
  updated(e) {
    e.get("tabs") && (this.currentPanel = 0);
  }
  keyListener(e) {
    console.log("keyListener", e.detail.key), console.log("target", e.target), console.log("currentTarget", e.currentTarget);
  }
  // @keydown=${this.keyListener}
  render() {
    const e = {
      background: "none",
      padding: "0",
      "flex-grow": 1
    };
    return We`
      <ul
        ${yt(this.tabListRef)}
        role="tablist"
        class="tablist"
        style=${this.inline ? mn(e) : Ne}
        @tabclick=${(r) => {
      this.currentPanel = r.detail;
    }}
        @keynav=${(r) => {
      this.keyListener(r);
    }}
      >
        ${this.tabs.map((r, n) => {
      var i;
      return (i = this.tabRefs)[n] ?? (i[n] = Et()), We`
              <fizz-tab
                ${yt(this.tabRefs[n])}
                .mode=${this.mode}
                .icon=${this.icons[n]}
                index=${n}
              >
                <span>${r}</span>
              </fizz-tab>
            `;
    })}
      </ul>
    `;
  }
};
sh.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      .tablist {
        display: flex;
        background: var(--background, var(--theme-color));
        padding: var(--padding, 0.25rem 0.25rem 0 0.25rem);
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
        gap: var(--tab-gap, 0);
        font-size: var(--tab-font-size, unset);
        font-weight: var(--tab-font-weight, unset);
        margin: 0;
      }
    `
];
zn([
  Ke({ type: Boolean })
], sh.prototype, "inline", 2);
zn([
  Ke()
], sh.prototype, "mode", 2);
zn([
  Ur()
], sh.prototype, "tabs", 2);
zn([
  Ur()
], sh.prototype, "icons", 2);
sh = zn([
  Dt("fizz-tab-list")
], sh);
let Iy = class extends $r {
  constructor() {
    super(...arguments), this._currentPanel = 0;
  }
  get numPanels() {
    return this.panelEls.length;
  }
  get currentPanel() {
    return this._currentPanel;
  }
  set currentPanel(e) {
    this._currentPanel = e, this.panelEls.forEach(
      (r, n) => r.setSelected(n === this._currentPanel)
    );
  }
  connectedCallback() {
    super.connectedCallback(), this.tabListEl = this.findTabList(), this.tabListEl.panelGroup = this;
  }
  findTabList() {
    let e = this.parentElement;
    for (; e; ) {
      const r = e.querySelector("fizz-tab-list");
      if (r)
        return r;
      e = e.parentElement;
    }
    throw new Error("unable to locate tab list");
  }
  render() {
    return We`
      <div class="panels">
        <slot @slotchange=${(e) => {
      var r;
      this.tabListEl.tabs = this.panelEls.map((n) => n.tabLabel), (r = this.panelEls[0]) != null && r.icon && (this.tabListEl.icons = this.panelEls.map((n) => {
        if (n.icon)
          return n.icon;
        throw new Error(`panel '${n.tabLabel}' icon missing`);
      }));
    }}></slot>
      </div>
    `;
  }
};
Iy.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      .panels {
        border-radius: var(--border-radius, 0 0 0.15rem 0.15rem);
      }
    `
];
zn([
  Ig()
], Iy.prototype, "panelEls", 2);
Iy = zn([
  Dt("fizz-tab-panel-group")
], Iy);
let oh = class extends $r {
  constructor() {
    super(...arguments), this.tabLabel = "TAB", this.visible = !1, this.panelRef = Et();
  }
  // get slottedNodes() {
  //   return this.slotRef.value!.assignedNodes();
  // }
  firstUpdated(e) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  render() {
    return We`
      <div
        ${yt(this.panelRef)}
        role="tabpanel"
        tabindex="0"
        class="panel"
        ?hidden=${!this.visible}
      >
        <slot></slot>
      </div>
    `;
  }
  setSelected(e) {
    this.visible = e;
  }
};
oh.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      .panel {
        border-radius: var(--border-radius, 0 0 0.15rem 0.15rem);
      }
    `
];
zn([
  Ke()
], oh.prototype, "tabLabel", 2);
zn([
  Ke()
], oh.prototype, "icon", 2);
zn([
  rse()
], oh.prototype, "contentNodes", 2);
zn([
  Ur()
], oh.prototype, "visible", 2);
oh = zn([
  Dt("fizz-tab-panel")
], oh);
let Wp = class extends $r {
  constructor() {
    super(...arguments), this.selected = !1, this.ref = Et();
  }
  activate(e) {
    e.preventDefault(), e.stopPropagation(), this.dispatchEvent(
      new CustomEvent(
        "tabclick",
        {
          bubbles: !0,
          composed: !0,
          detail: this.index
        }
      )
    );
  }
  keyListener(e) {
    e.preventDefault(), e.stopPropagation(), this.dispatchEvent(
      new CustomEvent(
        "keynav",
        {
          bubbles: !0,
          composed: !0,
          detail: e
        }
      )
    );
  }
  render() {
    const e = {
      hidden: this.mode === "icons" || this.mode === "icons-current-label" && !this.selected
    }, r = {
      icon: this.mode !== "labels"
    }, n = {
      mask: this.icon ? `url("${this.icon}") no-repeat 50% 50%` : void 0,
      "mask-size": "cover"
    };
    return We`
      <li
        role="presentation"
      >
        <button
          ${yt(this.ref)}
          role="tab"
          id="tab${this.index}"
          tabindex=${this.selected ? Ne : "-1"}
          aria-selected=${this.selected ? "true" : "false"}
          class="tab"
          @keydown=${(i) => {
      this.keyListener(i);
    }}
          @click=${(i) => this.activate(i)}
        >
          ${this.icon ? We`
            <span
              class=${Br(r)}
              style=${mn(n)}
            >
            </span>
          ` : ""}
          <slot class=${Br(e)}>
            TAB LABEL
          </slot>
        </button>
      </li>
    `;
  }
};
Wp.styles = [
  ra,
  Nt`
      :host {
        background: none !important;
      }
      li {
        list-style-type: none;
      }
      .tab {
        padding: var(--padding, 0.25rem 0.4rem);
        cursor: pointer;
        border: none;
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
      }
      [role='tab'] {
        color: var(--background-selected, var(--theme-unselected-text-color, var(--theme-extra-color)));
        background: none;
      }
      [role='tab'][aria-selected='true'] {
        background: var(--background-selected, var(--theme-extra-color));
        color: var(--theme-text-color, var(--color-selected, var(--theme-color)));
        text-decoration: var(--theme-selected-text-decoration) var(--theme-text-color);
        text-underline-offset: 0.25rem;
      }
      .icon {
        height: 1.2rem;
        width: 1.2rem;
        vertical-align: middle;
        background-color: currentColor;
        display: inline-block;
        margin-top: -0.5rem;
      }
      [role='tab-delete'] {
        background: var(--color, var(--theme-color));
      }
    `
];
zn([
  Ke({ type: Number })
], Wp.prototype, "index", 2);
zn([
  Ur()
], Wp.prototype, "selected", 2);
zn([
  Ur()
], Wp.prototype, "mode", 2);
Wp = zn([
  Dt("fizz-tab")
], Wp);
const use = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2016.9%2016.9'%3e%3cg%20id='layer1'%3e%3ccircle%20style='fill:%23ffffff;%20stroke-width:0.3;'%20id='path1'%20cx='8.5'%20cy='8.5'%20r='8.5'%20/%3e%3cpath%20id='path2'%20style='fill:%23040404;%20stroke-width:0.3'%20d='M%204.2,5.3%205.3,4.2%208.5,7.4%2011.6,4.2%2012.7,5.3%209.5,8.5%2012.7,11.6%2011.6,12.7%208.5,9.5%205.3,12.7%204.2,11.6%207.4,8.5%20Z'%20/%3e%3c/g%3e%3c/svg%3e";
var hse = Object.defineProperty, pse = Object.getOwnPropertyDescriptor, Vr = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? pse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && hse(e, r, i), i;
};
let Vi = class extends $r {
  constructor() {
    super(), this.dialogRef = Et(), this.xButtonRef = Et(), this.cancel = { key: !0, button: !0, click: !0 }, this.modal = !1, this.x = "0", this.y = "0", this.tx = 0, this.ty = 0, this.open = !1, this.title = "", this.onDocumentClick = (e) => {
      this.isWithinRect(e.clientX, e.clientY, this.dialogRef.value.getBoundingClientRect()) || this.didCancel(e);
    };
  }
  isWithinRect(e, r, n) {
    return !(e < n.left || e > n.right || r < n.top || r > n.bottom);
  }
  render() {
    const e = this.modal ? { translate: `${this.tx}px ${this.ty}px;` } : {
      left: this.x,
      top: this.y,
      margin: 0
    };
    return this.width && (e.width = this.width), this.height && (e.height = this.height), We`
      <dialog
        ${yt(this.dialogRef)}
        @cancel=${this.didCancel}
        style=${mn(e)}
		aria-label = ${this.title}
      >
        <div class="content">
          ${this.cancel.button ? We`
              <button type="button" class="close-x" @click=${this.didCancel}>
                <img src=${use} alt="Dialog close button">
                <span>Close</span>
              </button>
              ` : ""}
          <slot></slot>
        </div>
      </dialog>
    `;
  }
  firstUpdated(e) {
    this.open && this.show(), this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  async didCancel(e) {
    if (e.preventDefault(), !(e.type === "cancel" && !this.cancel.key || e.type === "click" && e.target === this.xButtonRef.value && !this.cancel.button))
      if (this.onCancel) {
        const r = await this.onCancel();
        r.close && this.close(r.value);
      } else
        this.close();
  }
  /**
   * Show the overlay.
   * @param afterShow - A function that will be called immediately after showing the overlay.
   * Can be useful if awaiting this method.
   * @returns Promise of string return value (typically the tag of the button
   * that caused the closure).
   * @remarks
   * This method can be awaited until the overlay is closed.
   */
  show(e) {
    return this.dialogRef.value.open ? this.promise : (this.modal ? this.dialogRef.value.showModal() : this.dialogRef.value.show(), this.cancel.click && setTimeout(() => document.addEventListener("click", this.onDocumentClick)), this.promise = new Promise((r) => {
      this.resolve = r, this.xButtonRef.value.focus(), e == null || e();
    }), this.promise);
  }
  /**
   * Close the overlay.
   * @param value - Value to resolve the promise with.
   */
  close(e = "ui_default_close") {
    this.dialogRef.value.close(), this.cancel.click && document.removeEventListener("click", this.onDocumentClick), this.resolve(e);
  }
};
Vi.styles = Nt`
    dialog {
      padding: 0;
      border: none;
      box-shadow: 0 0 40px rgb(127, 127, 127);
      border-radius: var(--border-radius, 0.15rem);
      border: none;
    }
    dialog .content {
      position: relative;
      background: var(--theme-color-constrast, ghostwhite);
      border: solid var(--theme-color) 1px;
      border-radius: var(--border-radius, 0.15rem);
      min-width: 15rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
    }
    button.close-x {
      position: absolute;
      right: 0.25rem;
      top: 0.25rem;
      /*height: calc(100% - 0.5rem); // titlebar height minus padding */
      padding: 0;
      background: transparent;
      border: 0;
    }
    button.close-x img {
      height: 1.3em;
    }
    button.close-x span {
      display: none;
    }
  `;
Vr([
  Ke({ type: Object })
], Vi.prototype, "cancel", 2);
Vr([
  Ke({ type: Boolean })
], Vi.prototype, "modal", 2);
Vr([
  Ke()
], Vi.prototype, "x", 2);
Vr([
  Ke()
], Vi.prototype, "y", 2);
Vr([
  Ke()
], Vi.prototype, "width", 2);
Vr([
  Ke()
], Vi.prototype, "height", 2);
Vr([
  Ke({ type: Number })
], Vi.prototype, "tx", 2);
Vr([
  Ke({ type: Number })
], Vi.prototype, "ty", 2);
Vr([
  Ke({ type: Boolean })
], Vi.prototype, "open", 2);
Vr([
  Ke()
], Vi.prototype, "title", 2);
Vi = Vr([
  Dt("fizz-overlay")
], Vi);
let E0 = class extends $r {
  constructor() {
    super(), this.prevX = 0, this.prevY = 0, this.tx = 0, this.ty = 0, this.title = "TITLE", this.buttons = [
      { tag: "cancel", text: "Cancel" },
      { tag: "okay", text: "Okay" }
    ], this.moveListener = this.move.bind(this);
  }
  render() {
    const e = JSON.stringify({ key: !0, button: !0, click: !1 });
    return We`
      <fizz-overlay modal cancel=${e} title = ${this.title}>
        <div
          class="title"
          @pointerdown=${this.titlebarPointerDown}
          @pointerup=${this.titlebarPointerUp}
        >
          ${this.title}
        </div>
        <slot></slot>
        <div class="buttons">
          ${this.buttons.map((r) => We`
            <button id=${r.tag} ?disabled=${r.disabled} @click=${this.btnClicked}>
              ${r.text}
            </button>
            `)}
        </div>
      </fizz-overlay>
    `;
  }
  firstUpdated(e) {
    this.titlebar = this.renderRoot.querySelector(".title"), this.btnsWrapper = this.renderRoot.querySelector(".buttons"), this.overlay = this.renderRoot.querySelector("fizz-overlay"), this.overlay.onCancel = async () => await this.didCancel();
  }
  titlebarPointerDown(e) {
    this.prevX = e.clientX, this.prevY = e.clientY, this.titlebar.addEventListener("pointermove", this.moveListener), this.titlebar.setPointerCapture(e.pointerId);
  }
  titlebarPointerUp(e) {
    this.titlebar.removeEventListener("pointermove", this.moveListener), this.titlebar.releasePointerCapture(e.pointerId);
  }
  move(e) {
    this.tx += e.clientX - this.prevX, this.prevX = e.clientX, this.ty += e.clientY - this.prevY, this.prevY = e.clientY, this.overlay.tx = this.tx, this.overlay.ty = this.ty;
  }
  async didCancel() {
    const e = this.buttonInfo("cancel");
    if (e) {
      const r = e.closeHook;
      return { close: r ? await r("cancel") : !0, value: "cancel" };
    } else
      return { close: !0 };
  }
  /**
   * Get the disabled state of all buttons.
   * @returns Mapping of button tags to disabled states.
   */
  getButtonsDisabled() {
    const e = {};
    for (const { tag: r } of this.buttons)
      e[r] = this.renderRoot.querySelector(`#${r}`).disabled;
    return e;
  }
  /**
   * Set the disabled state of specific buttons.
   * @param state - Mapping of button tags to desired disabled values.
   * All buttons will be disabled if this is omitted.
   * @returns Previous button disabled states if called with no argument.
   */
  setButtonsDisabled(e) {
    if (e)
      for (const [r, n] of Object.entries(e))
        this.renderRoot.querySelector(`#${r}`).disabled = n;
    else {
      const r = this.getButtonsDisabled();
      return this.renderRoot.querySelectorAll("button").forEach((n) => {
        n.disabled = !0;
      }), r;
    }
  }
  buttonInfo(e) {
    return this.buttons.find((r) => r.tag === e);
  }
  /**
   * Get the button corresponding to a specific tag..
   * @param tag - Button tag.
   * @returns Button element (or null).
   */
  button(e) {
    return this.renderRoot.querySelector(`#${e}`);
  }
  async btnClicked(e) {
    const r = this.setButtonsDisabled(), n = this.buttonInfo(e.target.id);
    (!n.closeHook || await n.closeHook(n.tag)) && this.overlay.close(n.tag), this.setButtonsDisabled(r);
  }
  /**
   * Show the dialog.
   * @param afterShow - A function that will be called immediately after showing the dialog.
   * Can be useful if awaiting this method.
   * @returns Promise of string return value (typically the tag of the button
   * that caused the closure).
   * @remarks
   * This method can be awaited until the dialog is closed.
   */
  show(e) {
    for (const { tag: r, disabled: n } of this.buttons)
      this.renderRoot.querySelector(`#${r}`).disabled = !!n;
    return this.overlay.tx = 0, this.overlay.ty = 0, this.tx = 0, this.ty = 0, this.prevX = 0, this.prevY = 0, this.overlay.show(e);
  }
};
E0.styles = Nt`
    .title {
      /*background: darkblue;
      color: white;*/
      font-weight: bold;
      align-self: stretch;
      text-align: center;
      padding: 0.25rem;
      margin-bottom: 0.5rem;
      border-radius: var(--border-radius, 0.15rem);
      /* If I leave this out, the title content area ends up every so slightly
         taller than the button image.*/
      height: 1rlh;
    }
    .buttons {
      padding: 0.5rem;
      display: flex;
      gap: 0.5rem;
    }


    .buttons button {
      --theme-color: purple;
      --theme-contrast-color: ghostwhite;

      margin: 0.2rem;
      background-color: var(--theme-color);
      color: var(--theme-contrast-color);
      border: thin solid var(--theme-color);
      border-radius: 0.2em;
      padding: 0.2em 0.4em;
    }
  `;
Vr([
  Ke()
], E0.prototype, "title", 2);
Vr([
  Ke({ type: Array })
], E0.prototype, "buttons", 2);
E0 = Vr([
  Dt("fizz-dialog")
], E0);
let Py = class extends $r {
  constructor() {
    super(...arguments), this.btnText = "Okay", this.text = "Your message here";
  }
  render() {
    const e = JSON.stringify([{ tag: "cancel", text: this.btnText }]);
    return We`
      <fizz-dialog title="Message" buttons=${e}>
        <div class="text">${this.text}</div>
      </fizz-dialog>
    `;
  }
  firstUpdated(e) {
    this.dialog = this.renderRoot.querySelector("fizz-dialog");
  }
  /**
   * Show the dialog
   * @param text - Optional message text.
   */
  async show(e) {
    e && (this.text = e), await this.dialog.show(() => this.dialog.button("cancel").focus());
  }
};
Vr([
  Ke()
], Py.prototype, "btnText", 2);
Vr([
  Ke()
], Py.prototype, "text", 2);
Py = Vr([
  Dt("fizz-msg-dialog")
], Py);
let S0 = class extends $r {
  constructor() {
    super(...arguments), this.cancelText = "Cancel", this.okayText = "Okay", this.text = "Text";
  }
  render() {
    const e = JSON.stringify([
      { tag: "cancel", text: this.cancelText },
      { tag: "okay", text: this.okayText }
    ]);
    return We`
      <fizz-dialog title="Confirm" buttons=${e}>
        <div class="text">${this.text}</div>
      </fizz-dialog>
    `;
  }
  firstUpdated(e) {
    this.dialog = this.renderRoot.querySelector("fizz-dialog");
  }
  /**
   * Show the dialog.
   * @param text - Message text.
   * @param cancelText - Cancel button text.
   * @param okayText - Confirm (okay) button text.
   * @returns Promise of boolean indicating whether the user confirmed or cancelled.
   */
  async show(e, r, n) {
    return e && (this.text = e), r && (this.cancelText = r), n && (this.okayText = n), await this.dialog.show(() => this.dialog.button("okay").focus()) === "okay";
  }
};
Vr([
  Ke()
], S0.prototype, "cancelText", 2);
Vr([
  Ke()
], S0.prototype, "okayText", 2);
Vr([
  Ke()
], S0.prototype, "text", 2);
S0 = Vr([
  Dt("fizz-conf-dialog")
], S0);
var dse = Object.defineProperty, fse = Object.getOwnPropertyDescriptor, SN = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? fse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && dse(e, r, i), i;
};
let Ry = class extends $r {
  constructor() {
    super(...arguments), this.inputDescriptors = {};
  }
  /*private ref(key: string) {
    console.log(`this.ref("${key}")`);
    if (this.refs.has(key)) {
      console.log('found ref');
      return this.refs.get(key);
    } else {
      const r = createRef<HTMLInputElement>();
      console.log('new ref:', r);
      this.refs.set(key, r);
      return r;
    }
  }*/
  firstUpdated(e) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  render() {
    return We`
      <fieldset>
        <legend>
          <slot name="legend"></slot>
        </legend>
        <slot name="before"></slot>
        ${Object.entries(this.inputDescriptors).map(([e, r]) => We`
            <label for=${e.toLowerCase()}>
              ${r.label}
              <input
                id=${e.toLowerCase()}
                type=${r.type ?? "text"}
                value=${r.value ?? Ne}
                placeholder=${r.placeholder ?? Ne}
                size=${r.size ?? Ne}
                min=${r.min ?? Ne}
                max=${r.max ?? Ne}
                @input=${(n) => this.dispatchEvent(
      new CustomEvent("edit", { bubbles: !0, composed: !0 })
    )}
                @change=${(n) => this.dispatchEvent(
      new CustomEvent("commit", { bubbles: !0, composed: !0 })
    )}
              />
            </label>
          `)}
        <slot name="after"></slot>
      </fieldset>
    `;
  }
  getInputs() {
    const e = {};
    for (const r of Object.keys(this.inputDescriptors))
      e[r] = this.renderRoot.querySelector(`#${r.toLowerCase()}`);
    return e;
  }
  /**
   * Determine whether all text fields are set to a value or not.
   * @returns Whether all fields have non-empty values.
   */
  isAllFieldsSet() {
    return Object.values(this.getInputs()).every((e) => e.value);
  }
  /**
   * Retrieve the current values of all text fields.
   * @returns Mapping of field keys to string values.
   */
  fieldValues() {
    const e = {};
    for (const [r, n] of Object.entries(this.getInputs()))
      e[r] = n.value;
    return e;
  }
  /**
   * Set the values of all text fields.
   * @param values - Mapping of field keys to new values.
   */
  setFieldValues(e) {
    const r = this.getInputs();
    for (const [n, i] of Object.entries(e))
      r[n].value = i;
  }
};
Ry.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      fieldset {
        display: flex;
        flex-direction: column;
        border-radius: var(--border-radius, 0.15rem);
        border-style: solid;
        border-width: 1px;
        border-color: var(--fieldset-border-color, var(--theme-color));
        color: var(--color, black);
        padding: 1rem;
        align-items: stretch;
      }
      legend {
        border-radius: var(--legend-border-radius, 0.15rem);
        padding: 0.25rem 0.5rem;
        background: var(--legend-background, var(--theme-color));
        color: var(--legend-color, var(--theme-extra-color));
      }
      label {
        display: flex;
        flex-direction: column;
        font-size: 0.75rem;
      }
      input {
        margin-left: 0;
        background: var(--input-background, white);
      }
    `
];
SN([
  Ke({ type: Object })
], Ry.prototype, "inputDescriptors", 2);
Ry = SN([
  Dt("fizz-textfieldset")
], Ry);
const gse = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2016.93%2016.93'%3e%3cdefs%20id='defs1'%20/%3e%3cg%20id='layer1'%3e%3ccircle%20style='fill:%23000000;stroke-width:0.36;fill-opacity:1'%20id='circle'%20cx='8.5'%20cy='8.5'%20r='8.5'%20/%3e%3cpath%20style='fill:%23ffffff;stroke-width:0.26;'%20d='m%207.4,9.4%20q%200,-0.6%200.25,-0.9%20Q%207.9,8.1%208.5,7.6%208.97,7.3%209.2,7%20q%200.25,-0.3%200.25,-0.6%200,-0.4%20-0.3,-0.54%20Q%208.88,5.66%208.41,5.66%207.93,5.66%207.47,5.80%207.01,5.95%206.52,6.20%20L%205.92,4.99%20Q%206.47,4.69%207.12,4.49%207.76,4.30%208.53,4.30%20q%201.17,0%201.81,0.6%200.65,0.6%200.65,1.43%200,0.46%20-0.14,0.80%20-0.14,0.33%20-0.44,0.63%20Q%2010.12,8.02%209.68,8.34%209.35,8.58%209.17,8.75%208.99,8.92%208.92,9.08%208.87,9.23%208.87,9.47%20V%209.80%20H%207.4%20Z%20m%20-0.18,2.29%20q%200,-0.51%200.28,-0.72%200.28,-0.21%200.68,-0.21%200.39,0%200.67,0.21%200.28,0.20%200.28,0.72%200,0.49%20-0.28,0.72%20-0.28,0.21%20-0.67,0.21%20-0.40,0%20-0.68,-0.21%20-0.28,-0.25%20-0.28,-0.72%20z'%20id='questionmark'%20aria-label='?'%20/%3e%3c/g%3e%3c/svg%3e";
var mse = (t, e, r, n) => {
  for (var i = e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let Hx = class extends $r {
  render() {
    return We`
      <button type="button" class="icon" @click=${this.onIconClick}>
        <img src=${gse} alt="Info pop-up icon">
        <span>Get info about this item</span>
      </button>
      <fizz-overlay>
        <slot></slot>
      </fizz-overlay>
    `;
  }
  firstUpdated(e) {
    this.overlay = this.renderRoot.querySelector("fizz-overlay"), this.icon = this.renderRoot.querySelector(".icon"), this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  onIconClick(e) {
    const r = this.icon.getBoundingClientRect();
    this.overlay.x = `calc(${r.x}px + 0.5rem)`, this.overlay.y = `calc(${r.y}px + 0.5rem)`, this.overlay.show();
  }
};
Hx.styles = Nt`
    button.icon {
      padding: 0;
      background: none;
      color: white;
      padding: 0;
      border: 0;
    }
    button.icon img {
      height: 1rem;
      vertical-align: bottom;
    }
    button.icon:hover {
    }
    button.icon span {
        display: none;
    }
  `;
Hx = mse([
  Dt("fizz-infopopup")
], Hx);
const _5 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMS4yNXJlbSIgaGVpZ2h0PSIxLjI1cmVtIiB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGNpcmNsZSBzdHlsZT0ic3Ryb2tlOmdob3N0d2hpdGU7IHN0cm9rZS13aWR0aDoxLjhweDsgZmlsbDpub25lOyIgY3g9IjEwIiBjeT0iMTAiIHI9IjkiLz48dGV4dCB4PSIxMCIgeT0iMTYiIHN0eWxlPSJmaWxsOmdob3N0d2hpdGU7IGZvbnQ6Ym9sZCAxOHB4ICdUaW1lcyBOZXcgUm9tYW4nLFRpbWVzLHNlcmlmOyB0ZXh0LWFuY2hvcjptaWRkbGU7Ij5pPC90ZXh0Pgo8L3N2Zz4K";
var yse = Object.defineProperty, vse = Object.getOwnPropertyDescriptor, C5 = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? vse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && yse(e, r, i), i;
};
let A0 = class extends $r {
  constructor() {
    super(...arguments), this.open = !1;
  }
  render() {
    return We`
      <details ?open=${this.open} @toggle=${() => this.dispatchEvent(new CustomEvent(
      this.details.open ? "open" : "close",
      { bubbles: !0, composed: !0 }
    ))}>
        <summary>
          <slot name="summary">Label</slot>
        </summary>
        <div class="content">
          <slot name="content">Contents</slot>
        </div>
      </details>
    `;
  }
  firstUpdated(e) {
    this.details = this.renderRoot.querySelector("details"), this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  /**
   * Replace the contents with the given elements.
   * @param newElements - Elements.
   */
  setContents(...e) {
    this.contents.forEach((r) => r.remove()), e.forEach((r) => {
      r.slot = "contents", this.append(r);
    });
  }
};
A0.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      details {
        /* Only shows up at the corners of the content area */
        background: var(--background, var(--theme-color));
        border-radius: var(--border-radius, 0.15rem);
        border: 1px solid var(--background, var(--border, var(--theme-color)));
      }
      summary {
        background: var(--background, var(--theme-color));
        color: var(--color, var(--theme-contrast-color));
        padding: 0;
        padding-top: 2px;
        padding-left: 2px;
        list-style-type: none;
      }
      summary::before {
        display: inline-block;
        width: var(--summary-marker-size, 1.1rem);
        height: var(--summary-marker-size, 1.1rem);
        margin-left: 2px;
        margin-top: 1px;
        margin-right: 2px;
        content: '';
        background-color: var(--summary-marker-color, var(--theme-contrast-color));
        mask-image: var(--summary-marker, url(${Zu(_5)}));
        mask-size: cover;
        cursor: pointer;
      }
      .content {
        background: var(--content-background, var(--theme-contrast-color));
        color: var(--content-color, black);
        padding: var(--content-padding, 0 0.25rem);
        border-radius: var(--border-radius, 0.15rem);
        overflow: var(--content-overflow, hidden);
      }
    `
];
C5([
  Ke({ type: Boolean })
], A0.prototype, "open", 2);
C5([
  Ig({ slot: "contents" })
], A0.prototype, "contents", 2);
A0 = C5([
  Dt("fizz-details")
], A0);
var bse = Object.defineProperty, wse = Object.getOwnPropertyDescriptor, Pg = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? wse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && bse(e, r, i), i;
};
let ah = class extends $r {
  constructor() {
    super(...arguments), this.label = "LABEL", this.options = [], this.selectRef = Et();
  }
  connectedCallback() {
    super.connectedCallback(), this.selected === void 0 && (this.selected = this.placeholder !== void 0 ? -1 : 0);
  }
  /*protected firstUpdated(_changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>) {
    this.dispatchEvent(new CustomEvent('dropdownfirstupdate', {bubbles: true, composed: true}));
  }*/
  optionSelected(e) {
    this.dispatchEvent(
      new CustomEvent("select", {
        detail: e,
        bubbles: !0,
        composed: !0
      })
    );
  }
  render() {
    return We`
      <label>
        ${this.label}
        <select 
          ${yt(this.selectRef)}
          autocomplete="off"
          @change=${(e) => {
      const r = e.target.value;
      this.optionSelected(r === "" ? -1 : +r.slice(3));
    }}>
          ${this.placeholder ? We`
              <option value="">${this.placeholder}</option>
            ` : ""}
          ${this.options.map((e, r) => We`
              <option 
                value="opt${r}" 
                .selected=${r === this.selected}
              >
                ${e}
              </option>
            `)}
        </select>
      </label>
    `;
  }
  get selectedIndex() {
    return this.placeholder !== void 0 ? this.selectRef.value.selectedIndex - 1 : this.selectRef.value.selectedIndex;
  }
  /**
   * Select a specific option by index.
   * @param index - Index of option to select.
   * @remarks
   * If a placeholder is set, passing -1 as the index will select it.
   */
  select(e) {
    const r = this.placeholder ? -1 : 0;
    if (e < r || e >= this.options.length)
      throw new Error(`invalid selection index '${e}'`);
    this.selectRef.value.selectedIndex = this.placeholder !== void 0 ? e + 1 : e, this.optionSelected(e);
  }
};
ah.styles = Nt`
  `;
Pg([
  Ke()
], ah.prototype, "label", 2);
Pg([
  Ke()
], ah.prototype, "placeholder", 2);
Pg([
  Ke({ type: Array })
], ah.prototype, "options", 2);
Pg([
  Ke({ type: Number })
], ah.prototype, "selected", 2);
ah = Pg([
  Dt("fizz-dropdown")
], ah);
var xse = Object.defineProperty, Ese = Object.getOwnPropertyDescriptor, ks = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Ese(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && xse(e, r, i), i;
};
let ci = class extends $r {
  constructor() {
    super(...arguments), this.label = "LABEL", this.key = "slider", this.showValue = !1, this.compact = !1, this.min = 0, this.max = 100, this.step = 1, this.percent = !1, this.inputRef = Et(), this._value = 50;
  }
  set value(e) {
    this._value = e;
  }
  get value() {
    return this._value;
  }
  connectedCallback() {
    super.connectedCallback(), this.lowBound ?? (this.lowBound = this.min), this.highBound ?? (this.highBound = this.max);
  }
  formatLabel() {
    const e = this.value;
    return this.percent ? `${Math.round(e * 100)}%` : `${e}`;
  }
  // protected firstUpdated(_changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>): void {
  //   this.dispatchEvent(
  //     new CustomEvent('sliderfirstupdate', {
  //       bubbles: true,
  //       composed: true
  //     }));
  // }
  /*protected updated(changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>) {
    if (changedProperties.has('value')) {
      this.inputRef.value!.value = this.value.toString();
    }
  }*/
  render() {
    return We`
      <div
        class=${this.compact ? "compact" : Ne}
      >
        <span>
          <label for=${this.key}>${this.label}:</label>
          ${this.showValue && this.compact ? We`
            <output for=${this.key}>
              ${this.formatLabel()}
            </output>
          ` : ""}
        </span>
        <input
          ${yt(this.inputRef)}
          id=${this.key}
          type="range"
          min=${this.min} max=${this.max} step=${this.step}
          .value=${this.value}
          @input=${() => {
      const e = +this.inputRef.value.value;
      e < this.lowBound || e > this.highBound ? this.inputRef.value.value = this._value.toString() : (this._value = +this.inputRef.value.value, this.dispatchEvent(new CustomEvent(
        "update",
        { bubbles: !0, composed: !0, detail: this._value }
      )), this.requestUpdate());
    }}
        >
        ${this.showValue && !this.compact ? We`
            <output for=${this.key}>
              ${this.formatLabel()}
            </output>
          ` : ""}
      </div>
    `;
  }
};
ci.styles = [
  ra,
  Nt`
      div {
        display: flex;
        flex-direction: row;
        gap: 0.5rem;
        align-items: flex-start;
      }
      div.compact {
        flex-direction: column;
        gap: 0;
      }
      input {
        width: var(--width, unset);
      }
    `
];
ks([
  Ke()
], ci.prototype, "label", 2);
ks([
  Ke({ type: String })
], ci.prototype, "key", 2);
ks([
  Ke({ type: Number })
], ci.prototype, "value", 1);
ks([
  Ke({ type: Boolean })
], ci.prototype, "showValue", 2);
ks([
  Ke({ type: Boolean })
], ci.prototype, "compact", 2);
ks([
  Ke({ type: Number })
], ci.prototype, "min", 2);
ks([
  Ke({ type: Number })
], ci.prototype, "max", 2);
ks([
  Ke({ type: Number })
], ci.prototype, "lowBound", 2);
ks([
  Ke({ type: Number })
], ci.prototype, "highBound", 2);
ks([
  Ke({ type: Number })
], ci.prototype, "step", 2);
ks([
  Ke({ type: Boolean })
], ci.prototype, "percent", 2);
ci = ks([
  Dt("fizz-slider")
], ci);
var Sse = Object.defineProperty, Ase = Object.getOwnPropertyDescriptor, Rg = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Ase(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && Sse(e, r, i), i;
};
let AN = class {
  constructor(e, r, n, i, s) {
    this.key = e, this.descriptor = r, this.checked = n, this.type = i, this.group = s, this._inputRef = Et();
  }
  get input() {
    return this._inputRef.value;
  }
  classMap() {
    return { [this.type]: !0 };
  }
  render() {
    return We`
      <label class=${Br(this.classMap())} title=${this.descriptor.title ?? Ne} for=${this.key}>
        <input
          ${yt(this._inputRef)}
          id=${this.key}
          type="radio"
          name="radio"
          .checked=${this.checked}
          @change=${(e) => this.group.dispatchEvent(
      new CustomEvent("select", { bubbles: !0, composed: !0, detail: this.key })
    )}
        />
        ${this.content()}
      </label>
    `;
  }
};
const kN = class extends AN {
  constructor(e, r, n, i) {
    super(e, r, n, "plain", i);
  }
  classMap() {
    const e = super.classMap();
    return e[`layout-${this.group.layout}`] = !0, e;
  }
  content() {
    return We`
      <span class="main">
        ${this.descriptor.label}
      </span>
      ${this.descriptor.subLabel ? We`
        <span class="sub">${this.descriptor.subLabel}</span>
      ` : ""}
    `;
  }
};
kN.styles = Nt`
    label.plain {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
    }
    label.plain.layout-compress {
      flex-direction: column;
      gap: 0;
    }
    label.plain span {
      text-align: center;
    }
  `;
let _N = kN;
const CN = class extends AN {
  constructor(e, r, n, i) {
    super(e, r, n, "icon", i);
  }
  content() {
    return We`
      <div class="tile">
        ${this.descriptor.icon ? We`
          <img src=${this.descriptor.icon} alt="">
        ` : ""}
        <span>
          ${this.descriptor.label}
          ${this.descriptor.subLabel ? We`<br>${this.descriptor.subLabel}` : ""}
        </span>
      </div>
    `;
  }
};
CN.styles = Nt`
    label.icon {
      position: relative;
      height: 4rem;
      width: 4rem;
    }
    img {
      width: 3.2rem;
      background: inherit;
    }
    label.icon input {
      opacity: 0;
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
      margin: 0;
      cursor: pointer;
    }
    .tile {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
      width: 100%;
      height: 100%;
      border: 2px solid var(--theme-color-light, unset);
      border-radius: 5px;
      padding: 0.5rem;
      transition: transform 300ms ease;
    }
    label.icon span {
      text-align: center;
      font-size: 0.7rem;
      font-weight: 550;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--theme-text-color, unset);
    }
    label.icon input:checked + .tile {
      background-color: var(--theme-color-light, unset);
      border: 2px solid var(--theme-color-light, unset);
      color: var(--theme-text-color, unset);
      font-weight: 700;
      transform: scale(1.1, 1.1);
    }
    label.icon input:checked + .tile span {
      color: var(--theme-text-color, unset);
      background-color: var(--theme-color-light, unset);
    }
  `;
let IN = CN, lh = class extends $r {
  constructor() {
    super(...arguments), this.buttons = {}, this.layout = "horiz", this.wrap = !1, this.radios = {};
  }
  /*protected firstUpdated(_changedProperties: PropertyValueMap<any> | Map<PropertyKey, unknown>): void {
    this.dispatchEvent(
      new CustomEvent('radiofirstupdate', {
        bubbles: true,
        composed: true
      }));
  }*/
  connectedCallback() {
    super.connectedCallback(), this.selected ?? (this.selected = Object.keys(this.buttons)[0]);
  }
  updated(e) {
    if (e.has("selected"))
      for (const [r, n] of Object.entries(this.radios))
        n.input.checked = r === this.selected;
  }
  render() {
    const e = this.buttons[Object.keys(this.buttons)[0]].icon ? IN : _N;
    this.radios = {};
    for (const [n, i] of Object.entries(this.buttons))
      this.radios[n] = new e(n, i, n === this.selected, this);
    const r = {
      wrapper: !0,
      [this.layout]: !0,
      wrap: this.wrap
    };
    return We`
      <fieldset>
        <legend>
          <slot name="legend"></slot>
        </legend>
        <div class=${Br(r)}>
          ${Object.entries(this.radios).map(([n, i]) => i.render())}
        </div>
      </fieldset>
    `;
  }
};
lh.styles = [
  ra,
  Nt`
      :host * {
        box-sizing: border-box;
      }
      .wrapper {
        display: flex;
        justify-content: center;
        gap: 0.5rem;
      }
      .wrapper.vert {
        flex-direction: column;
        align-items: flex-start;
        width: min-content;
        margin-left: auto;
        margin-right: auto;
      }
      .wrapper.wrap {
        flex-wrap: wrap;
      }
      fieldset {
        border: var(--border, none);
        padding: 0;
        margin: 0;
      }
      legend {
        border-radius: var(--legend-border-radius, 0.15rem);
        padding: 0.25rem 0.5rem;
        margin-left: auto;
        margin-right: auto;
        background: var(--legend-background, unset);
        color: var(--legend-color, unset);
      }
    `,
  _N.styles,
  IN.styles
];
Rg([
  Ke({ type: Object })
], lh.prototype, "buttons", 2);
Rg([
  Ke()
], lh.prototype, "selected", 2);
Rg([
  Ke()
], lh.prototype, "layout", 2);
Rg([
  Ke({ type: Boolean })
], lh.prototype, "wrap", 2);
lh = Rg([
  Dt("fizz-radiogroup")
], lh);
var kse = Object.defineProperty, _se = Object.getOwnPropertyDescriptor, no = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? _se(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && kse(e, r, i), i;
};
let Hi = class extends $r {
  constructor() {
    super(...arguments), this.open = !1, this.default = 0, this.tabLabelMode = "labels", this.openButtonAriaLabel = "Open or close tabbed interface", this.tabListAriaLabel = "Tabs", this.tabLabels = [], this._tabIcons = [], this._hiddenTabs = [], this._detailsRef = Et(), this._tabRefs = [], this._panelsWrapperRef = Et(), this._allPanelContents = [], this._ready = !1;
  }
  set selectedTab(e) {
    this._selectedTab = e, this._tabRefs[e].value.focus();
  }
  get selectedTab() {
    return this._selectedTab;
  }
  connectedCallback() {
    super.connectedCallback(), this._selectedTab = this.default;
  }
  firstUpdated(e) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  updated(e) {
    var r;
    e.get("tabLabels") && this.tabLabels.length, this._tabRefs.length && ((r = this._tabRefs[this.selectedTab].value) == null || r.scrollIntoView({ behavior: "smooth", block: "nearest" })), this._allPanelContents.length && !this._ready && (this._ready = !0, this.dispatchEvent(new CustomEvent("ready", { bubbles: !0, composed: !0 })));
  }
  hide(e) {
    if (this.tabLabels.indexOf(e) === -1)
      throw new Error(`no tab with label '${e}'`);
    this._hiddenTabs.includes(e) || (this._hiddenTabs = [...this._hiddenTabs, e]);
  }
  show(e) {
    if (!this.tabLabels.includes(e))
      throw new Error(`no tab with label '${e}'`);
    const r = this._hiddenTabs.indexOf(e);
    r !== -1 && (this._hiddenTabs = this._hiddenTabs.toSpliced(r, 1));
  }
  _activateTab(e, r) {
    e.preventDefault(), e.stopPropagation(), this.selectedTab = r;
  }
  _renderTab(e, r) {
    var n;
    if ((n = this._tabRefs)[r] ?? (n[r] = Et()), this._hiddenTabs.includes(e))
      return We``;
    const i = this.selectedTab === r, s = {
      hidden: this.tabLabelMode === "icons" || this.tabLabelMode === "icons-current-label" && !i
    }, o = {
      icon: this.tabLabelMode !== "labels"
    }, a = {
      mask: this._tabIcons[r] ? `url("${this._tabIcons[r]}") no-repeat 50% 50%` : void 0,
      "mask-size": "cover"
    };
    return We`
      <li
        role="presentation"
      >
        <button
          ${yt(this._tabRefs[r])}
          role="tab"
          id="tab${r}"
          tabindex=${i ? Ne : -1}
          aria-selected=${i ? "true" : "false"}
          aria-controls="panel${r}"
          class="tab"
          @keydown=${(l) => {
      l.key === "ArrowLeft" || l.key === "ArrowUp" ? this._activateTab(l, r === 0 ? this.tabLabels.length - 1 : r - 1) : (l.key === "ArrowRight" || l.key === "ArrowDown") && this._activateTab(l, (r + 1) % this.tabLabels.length);
    }}
          @click=${(l) => this._activateTab(l, r)}
        >
          ${this._tabIcons[r] ? We`
            <span
              class=${Br(o)}
              style=${mn(a)}
            >
            </span>
          ` : ""}
          <span class=${Br(s)}>
            ${e}
          </span>
        </button>
      </li>
    `;
  }
  _absorbPanels() {
    this._allPanelContents = this._panelEls.map((e) => e.contentNodes), this._panelEls.forEach((e) => e.remove()), this.requestUpdate();
  }
  render() {
    return We`
      <details
        ${yt(this._detailsRef)}
        ?open=${this.open}
        @toggle=${() => {
      this.dispatchEvent(new CustomEvent(
        this.open ? "open" : "close",
        { bubbles: !0, composed: !0 }
      ));
    }}>
        <summary
          tabindex="0"
          aria-label=${this.openButtonAriaLabel}
          @click=${(e) => {
      e.preventDefault(), this.open = !this._detailsRef.value.open;
    }}
        >
          <menu
            role="tablist"
            class="tablist ${this.open ? "" : "hidden"}"
            aria-label=${this.tabListAriaLabel}
          >
            ${this.tabLabels.map((e, r) => this._renderTab(e, r))}
          </menu>
        </summary>
        <div class="panels"
          ${yt(this._panelsWrapperRef)}
        >
          ${this._allPanelContents.map((e, r) => We`
              <section
                id="panel${r}"
                ?hidden=${this._hiddenTabs.includes(this.tabLabels[r])}
                tabindex="0"
                role="tabpanel"
                aria-labelledby="tab${r}"
                class="panel ${this.selectedTab === r ? "" : "hidden"}"
              >
                ${e}
              </section>
            `)}
          <slot @slotchange=${(e) => {
      var r;
      if (!this.tabLabels.length)
        if (this.tabLabels = this._panelEls.map((n) => n.tabLabel), (r = this._panelEls[0]) != null && r.icon && (this._tabIcons = this._panelEls.map((n, i) => {
          if (n.id = `panel${i}`, n.icon)
            return n.icon;
          throw new Error(`panel '${n.tabLabel}' icon missing`);
        })), this._panelEls.forEach((n) => {
          n.hidden && this.hide(n.tabLabel);
        }), this._panelEls.map((n) => n.hasUpdated).every((n) => n))
          this._absorbPanels();
        else {
          const n = this._panelEls.filter((i) => !i.hasUpdated);
          n.forEach((i) => i.addEventListener("firstupdate", (s) => {
            s.stopPropagation(), n.map((o) => o.hasUpdated).every((o) => o) && this._absorbPanels();
          }, { once: !0 }));
        }
    }}></slot>
        </div>
      </details>
    `;
  }
};
Hi.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }
      details {
        background: var(--background, var(--theme-contrast-color));
        color: var(--color, black);
        border-radius: var(--border-radius, 0.15rem);
      }

      summary {
        background: var(--summary-background, var(--theme-color));
        border-radius: var(--summary-border-radius, 0);
        padding: 0;
        padding-top: 2px;
        padding-left: 2px;
        list-style-type: none;
      }
      summary::before {
        display: inline-block;
        width: var(--summary-marker-size, 1.1rem);
        height: var(--summary-marker-size, 1.1rem);
        margin-left: 2px;
        margin-top: 2px;
        margin-right: 2px;
        padding: 1px;
        content: '';
        background-color: var(--summary-marker-color, ghostwhite);
        mask-image: var(--summary-marker-icon, url(${Zu(_5)}));
        mask-size: cover;
        cursor: pointer;
        z-index: 1;
      }

      details {
        border: var(--border, 1px solid var(--theme-color));
      }
      details[open] summary {
        border-radius: var(--summary-border-radius-open, 0);
      }
      details:not([open]) {
        /*
          marker width + marker margins + marker padding + summary left padding
          + summary left padding added on the right
        */
        width: calc(1.1rem + 4px + 2px + 2px + 2px);
        background: none;
        /*
          Keep the icon from moving by making the border transparent
          rather than removing it
        */
        border: 1px solid transparent;
      }
      details:not([open]) summary::before {
        background-color: var(--theme-color, ghostwhite);
      }
      details:not([open]) summary {
        background: none;
      }
      .panels {
        background: var(--contents-background, var(--theme-contrast-color));
        padding: var(--contents-padding, 0 0.25rem);
        margin: var(--contents-margin, 0);
        overflow: var(--contents-overflow, hidden);
        border-radius: var(--border-radius, 0 0 0.15rem 0.15rem);
        z-index: 3;
      }
      .tablist {
        display: inline-flex;
        padding: 0;
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
        gap: var(--tab-gap, 0);
        font-size: var(--tab-font-size, unset);
        font-weight: var(--tab-font-weight, unset);
        margin: 0;
        background: none;
        flex-grow: 1;
        width: calc(100% - 2rem);
      }
      li {
        list-style-type: none;
      }
      .tab {
        padding: var(--padding, 0.25rem 0.4rem);
        cursor: pointer;
        border: none;
        border-radius: var(--border-radius, 0.15rem 0.15rem 0 0);
      }
      [role='tab'] {
        color: var(--background-selected, var(--theme-unselected-text-color, var(--theme-extra-color)));
        background: none;
      }
      [role='tab'][aria-selected='true'] {
        background: var(--background-selected, var(--theme-extra-color));
        color: var(--theme-text-color, var(--color-selected, var(--theme-color)));
        text-decoration: var(--theme-selected-text-decoration) var(--theme-text-color);
        text-underline-offset: 0.25rem;
      }
      .icon {
        height: 1rem;
        width: 1rem;
        vertical-align: middle;
        background-color: currentColor;
        display: inline-block;
      }
      @media screen and (max-width: 600px) {
        .tablist {
          flex-direction: column;
          overflow-y: scroll;
          height: 3.5rem;
          /*gap: 0.1rem;*/
        }
        .tab {
          width: 100%;
        }
      }
    `
];
no([
  Ke({ type: Boolean })
], Hi.prototype, "open", 2);
no([
  Ke({ type: Number })
], Hi.prototype, "default", 2);
no([
  Ke()
], Hi.prototype, "tabLabelMode", 2);
no([
  Ke()
], Hi.prototype, "openButtonAriaLabel", 2);
no([
  Ke()
], Hi.prototype, "tabListAriaLabel", 2);
no([
  Ur()
], Hi.prototype, "tabLabels", 2);
no([
  Ur()
], Hi.prototype, "_tabIcons", 2);
no([
  Ur()
], Hi.prototype, "_hiddenTabs", 2);
no([
  Ur()
], Hi.prototype, "selectedTab", 1);
no([
  Ig()
], Hi.prototype, "_panelEls", 2);
Hi = no([
  Dt("fizz-tab-details")
], Hi);
var Cse = Object.defineProperty, Ise = Object.getOwnPropertyDescriptor, io = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Ise(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && Cse(e, r, i), i;
};
let Gi = class extends $r {
  constructor() {
    super(...arguments), this.open = !1, this.default = 0, this.tabLabelMode = "labels", this.tabListAriaLabel = "Tabs", this.openButtonAriaLabel = "Toggle tab panel", this._tabLabels = [], this._tabIcons = [], this._hiddenTabs = [], this._tabRefs = [], this._panelsWrapperRef = Et(), this._allPanelContents = [], this._ready = !1;
  }
  set selectedTab(e) {
    this._selectedTab = e, this._tabRefs[e].value.focus();
  }
  get selectedTab() {
    return this._selectedTab;
  }
  connectedCallback() {
    super.connectedCallback(), this._selectedTab = this.default;
  }
  firstUpdated(e) {
    this.dispatchEvent(new CustomEvent("firstupdate", { bubbles: !0, composed: !0 }));
  }
  updated(e) {
    var r;
    this._tabRefs.length && ((r = this._tabRefs[this.selectedTab].value) == null || r.scrollIntoView({ behavior: "smooth", block: "nearest" })), this._allPanelContents.length && !this._ready && (this._ready = !0, this.dispatchEvent(new CustomEvent("ready", { bubbles: !0, composed: !0 })));
  }
  hide(e) {
    if (this._tabLabels.indexOf(e) === -1)
      throw new Error(`no tab with label '${e}'`);
    this._hiddenTabs.includes(e) || (this._hiddenTabs = [...this._hiddenTabs, e]);
  }
  show(e) {
    if (!this._tabLabels.includes(e))
      throw new Error(`no tab with label '${e}'`);
    const r = this._hiddenTabs.indexOf(e);
    r !== -1 && (this._hiddenTabs = this._hiddenTabs.toSpliced(r, 1));
  }
  _activateTab(e, r) {
    e.preventDefault(), e.stopPropagation(), this.selectedTab = r;
  }
  _renderTab(e, r) {
    var n;
    if ((n = this._tabRefs)[r] ?? (n[r] = Et()), this._hiddenTabs.includes(e))
      return We``;
    const i = this.selectedTab === r, s = {
      mask: this._tabIcons[r] ? `url("${this._tabIcons[r]}") no-repeat 50% 50%` : void 0,
      "mask-size": "cover"
    }, o = this.tabLabelMode === "icons" || this.tabLabelMode === "icons-labels" || this.tabLabelMode === "icons-current-label" && i, a = this.tabLabelMode === "labels" || this.tabLabelMode === "icons-labels" || this.tabLabelMode === "icons-current-label" && i;
    return We`
      <li role="presentation">
        <button
          ${yt(this._tabRefs[r])}
          role="tab"
          id="tab${r}"
          tabindex=${i ? Ne : -1}
          aria-selected=${i ? "true" : "false"}
          aria-controls="panel${r}"
          class="tab"
          @keydown=${(l) => {
      l.key === "ArrowLeft" || l.key === "ArrowUp" ? this._activateTab(l, r === 0 ? this._tabLabels.length - 1 : r - 1) : (l.key === "ArrowRight" || l.key === "ArrowDown") && this._activateTab(l, (r + 1) % this._tabLabels.length);
    }}
          @click=${(l) => this._activateTab(l, r)}
        >
          ${o && this._tabIcons[r] ? We`<span class="icon" style=${mn(s)}></span>` : Ne}
          ${a ? We`<span>${e}</span>` : Ne}
        </button>
      </li>
    `;
  }
  _absorbPanels() {
    this._allPanelContents = this._panelEls.map((e) => e.contentNodes), this._panelEls.forEach((e) => e.remove()), this.requestUpdate();
  }
  render() {
    const e = We`
      <button
        class="toggle"
        @click=${() => {
      this.open = !this.open, this.dispatchEvent(new CustomEvent(
        this.open ? "open" : "close",
        { bubbles: !0, composed: !0 }
      ));
    }}
		aria-label=${this.openButtonAriaLabel}
		aria-expanded=${this.open}
        aria-controls="tabs-container"
      ></button>
    `;
    return We`
      <div id="tabs-container" class=${this.open ? "open" : ""}>
        ${this.open ? We`
          <div class="tablist-wrapper">
            ${e}
            <ul
              role="tablist"
              class="tablist"
              aria-label=${this.tabListAriaLabel}
            >
              ${this._tabLabels.map((r, n) => this._renderTab(r, n))}
            </ul>
          </div>

          <div class="panels" ${yt(this._panelsWrapperRef)}>
            ${this._allPanelContents.map((r, n) => We`
              <section
                id="panel${n}"
                ?hidden=${this._hiddenTabs.includes(this._tabLabels[n])}
                tabindex="0"
                role="tabpanel"
                aria-labelledby="tab${n}"
                class="panel ${this.selectedTab === n ? "" : "hidden"}"
              >
                ${r}
              </section>
            `)}
            <slot @slotchange=${(r) => {
      var n;
      if (!this._tabLabels.length)
        if (this._tabLabels = this._panelEls.map((i) => i.tabLabel), (n = this._panelEls[0]) != null && n.icon && (this._tabIcons = this._panelEls.map((i, s) => {
          if (i.id = `panel${s}`, i.icon) return i.icon;
          throw new Error(`panel '${i.tabLabel}' icon missing`);
        })), this._panelEls.forEach((i) => {
          i.hidden && this.hide(i.tabLabel);
        }), this._panelEls.map((i) => i.hasUpdated).every((i) => i))
          this._absorbPanels();
        else {
          const i = this._panelEls.filter((s) => !s.hasUpdated);
          i.forEach(
            (s) => s.addEventListener("firstupdate", (o) => {
              o.stopPropagation(), i.map((a) => a.hasUpdated).every((a) => a) && this._absorbPanels();
            }, { once: !0 })
          );
        }
    }}></slot>
          </div>` : We`
          ${e}
        `}
      </div>
    `;
  }
};
Gi.styles = [
  ra,
  Nt`
      :host {
        display: block;
      }

      #tabs-container {
        display: grid;
        border-radius: var(--border-radius, 0.15rem);
      }
      #tabs-container.open {
        border: 1px solid var(--theme-color);
      }

      button.toggle {
        width: var(--toggle-button-size, 1.1rem);
        height: var(--toggle-button-size, 1.1rem);
        background-color: var(--toggle-button-color, ghostwhite);
        mask-image: var(--toggle-button-icon, url(${Zu(_5)}));
        mask-size: cover;
        border: none;
        cursor: pointer;
        vertical-align: text-top;
        padding: 0 0.25rem;
      }
      #tabs-container.open button.toggle {
        justify-self: center;
        align-self: center;
      }
      #tabs-container:not(.open) button.toggle {
        background-color: var(--theme-color, ghostwhite);
      }

      .tablist-wrapper {
        display: grid;
        grid-template-columns: 1.5rem 1fr;
        background: var(--tablist-background, var(--theme-color));
        margin: 0;
      }

      .tablist {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 0;
        margin: 0;
        padding: 0;
      }

      li {
        display: contents;
        list-style-type: none;
        margin: 0;
      }

      .tab {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: var(--tab-padding, 0.25rem 0.4rem);
        border: none;
        border-radius: var(--border-radius, 0.1rem) var(--border-radius, 0.1rem) 0 0;
        cursor: pointer;
        background: none;
        font-size: var(--tab-font-size);
        font-weight: var(--tab-font-weight);
        margin: 0;
      }

      [role='tab'] {
        color: var(--theme-unselected-text-color);
      }

      [role='tab'][aria-selected='true'] {
        background: var(--theme-extra-color);
        color: var(--theme-text-color);
        text-decoration: var(--theme-selected-text-decoration);
        text-underline-offset: 0.25rem;
      }

      .icon {
        height: 1rem;
        width: 1rem;
        vertical-align: middle;
        background-color: currentColor;
        display: inline-block;
      }

      .panels {
        background: var(--theme-contrast-color);
        padding: var(--contents-padding);
        margin: 0;
        border-radius: 0 0 var(--border-radius, 0.1rem) var(--border-radius, 0.1rem);
      }

      @media screen and (max-width: 600px) {
        .tablist {
          flex-direction: column;
          overflow-y: auto;
          height: 3.5rem;
        }

        .tab {
          width: 100%;
        }
      }
    `
];
io([
  Ke({ type: Boolean, reflect: !0, useDefault: !0 })
], Gi.prototype, "open", 2);
io([
  Ke({ type: Number })
], Gi.prototype, "default", 2);
io([
  Ke()
], Gi.prototype, "tabLabelMode", 2);
io([
  Ke()
], Gi.prototype, "tabListAriaLabel", 2);
io([
  Ke({ type: String, attribute: "openbuttonarialabel" })
], Gi.prototype, "openButtonAriaLabel", 2);
io([
  Ur()
], Gi.prototype, "_tabLabels", 2);
io([
  Ur()
], Gi.prototype, "_tabIcons", 2);
io([
  Ur()
], Gi.prototype, "_hiddenTabs", 2);
io([
  Ur()
], Gi.prototype, "selectedTab", 1);
io([
  Ig()
], Gi.prototype, "_panelEls", 2);
Gi = io([
  Dt("fizz-tabs")
], Gi);
var Pse = Object.defineProperty, Rse = Object.getOwnPropertyDescriptor, Og = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? Rse(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && Pse(e, r, i), i;
};
let ch = class extends ts {
  constructor() {
    super(...arguments), this.title = "", this.btnText = "Close", this.contentArray = [], this._dialogRef = Et();
  }
  render() {
    const t = [{ tag: "cancel", text: this.btnText }];
    return We`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="${this.title}"
        .buttons=${t}
      >
        ${this._content}
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   * @param contentArray - status bar display contentArray.
   */
  // async show(title: string, contentArray: string[]) {
  async show(t, e = We``) {
    this.title = t, this._content = e, await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
ch.styles = Nt`
    .contentArray {
      align-self: stretch;
    }

    button {
      margin: 0.2rem;
      background-color: var(--theme-color);
      color: var(--theme-contrast-color);
      border: thin solid var(--theme-color);
      border-radius: 0.2em;
      padding: 0.2em;
    }


    pre {
      height: 60vh;
      width: 80vw;
      padding: 1rem;
      overflow-y:
      scroll; background-color:
      black; color: white;
    }

    table {
      border-collapse: collapse;
      margin: 0 2rem;
    }

    th, td {
      border-bottom: 1px solid hsl(0, 0%, 75%);
      padding: 0.35em 2.5em;
      text-align: left;
    }

    tbody th {
      font-weight: normal;
      padding-left: 0;
    }

    td:last-of-type {
      padding-right: 0;
    }
  `;
Og([
  Ke()
], ch.prototype, "title", 2);
Og([
  Ke()
], ch.prototype, "btnText", 2);
Og([
  Ke({ type: Array })
], ch.prototype, "contentArray", 2);
Og([
  Ur()
], ch.prototype, "_content", 2);
ch = Og([
  Dt("para-dialog")
], ch);
var Ose = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tse(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var PN = { exports: {} };
/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/
(function(t, e) {
  ((r, n) => {
    t.exports = n();
  })(Ose, function r() {
    var n = typeof self < "u" ? self : typeof window < "u" ? window : n !== void 0 ? n : {}, i, s = !n.document && !!n.postMessage, o = n.IS_PAPA_WORKER || !1, a = {}, l = 0, c = {};
    function p(R) {
      this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = { data: [], errors: [], meta: {} }, (function(L) {
        var F = w(L);
        F.chunkSize = parseInt(F.chunkSize), L.step || L.chunk || (F.chunkSize = null), this._handle = new b(F), (this._handle.streamer = this)._config = F;
      }).call(this, R), this.parseChunk = function(L, F) {
        var z = parseInt(this._config.skipFirstNLines) || 0;
        if (this.isFirstChunk && 0 < z) {
          let W = this._config.newline;
          W || (j = this._config.quoteChar || '"', W = this._handle.guessLineEndings(L, j)), L = [...L.split(W).slice(z)].join(W);
        }
        this.isFirstChunk && S(this._config.beforeFirstChunk) && (j = this._config.beforeFirstChunk(L)) !== void 0 && (L = j), this.isFirstChunk = !1, this._halted = !1;
        var z = this._partialLine + L, j = (this._partialLine = "", this._handle.parse(z, this._baseIndex, !this._finished));
        if (!this._handle.paused() && !this._handle.aborted()) {
          if (L = j.meta.cursor, z = (this._finished || (this._partialLine = z.substring(L - this._baseIndex), this._baseIndex = L), j && j.data && (this._rowCount += j.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview), o) n.postMessage({ results: j, workerId: c.WORKER_ID, finished: z });
          else if (S(this._config.chunk) && !F) {
            if (this._config.chunk(j, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = !0);
            this._completeResults = j = void 0;
          }
          return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(j.data), this._completeResults.errors = this._completeResults.errors.concat(j.errors), this._completeResults.meta = j.meta), this._completed || !z || !S(this._config.complete) || j && j.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), z || j && j.meta.paused || this._nextChunk(), j;
        }
        this._halted = !0;
      }, this._sendError = function(L) {
        S(this._config.error) ? this._config.error(L) : o && this._config.error && n.postMessage({ workerId: c.WORKER_ID, error: L, finished: !1 });
      };
    }
    function h(R) {
      var L;
      (R = R || {}).chunkSize || (R.chunkSize = c.RemoteChunkSize), p.call(this, R), this._nextChunk = s ? function() {
        this._readChunk(), this._chunkLoaded();
      } : function() {
        this._readChunk();
      }, this.stream = function(F) {
        this._input = F, this._nextChunk();
      }, this._readChunk = function() {
        if (this._finished) this._chunkLoaded();
        else {
          if (L = new XMLHttpRequest(), this._config.withCredentials && (L.withCredentials = this._config.withCredentials), s || (L.onload = _(this._chunkLoaded, this), L.onerror = _(this._chunkError, this)), L.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !s), this._config.downloadRequestHeaders) {
            var F, z = this._config.downloadRequestHeaders;
            for (F in z) L.setRequestHeader(F, z[F]);
          }
          var j;
          this._config.chunkSize && (j = this._start + this._config.chunkSize - 1, L.setRequestHeader("Range", "bytes=" + this._start + "-" + j));
          try {
            L.send(this._config.downloadRequestBody);
          } catch (W) {
            this._chunkError(W.message);
          }
          s && L.status === 0 && this._chunkError();
        }
      }, this._chunkLoaded = function() {
        L.readyState === 4 && (L.status < 200 || 400 <= L.status ? this._chunkError() : (this._start += this._config.chunkSize || L.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((F) => (F = F.getResponseHeader("Content-Range")) !== null ? parseInt(F.substring(F.lastIndexOf("/") + 1)) : -1)(L), this.parseChunk(L.responseText)));
      }, this._chunkError = function(F) {
        F = L.statusText || F, this._sendError(new Error(F));
      };
    }
    function d(R) {
      (R = R || {}).chunkSize || (R.chunkSize = c.LocalChunkSize), p.call(this, R);
      var L, F, z = typeof FileReader < "u";
      this.stream = function(j) {
        this._input = j, F = j.slice || j.webkitSlice || j.mozSlice, z ? ((L = new FileReader()).onload = _(this._chunkLoaded, this), L.onerror = _(this._chunkError, this)) : L = new FileReaderSync(), this._nextChunk();
      }, this._nextChunk = function() {
        this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
      }, this._readChunk = function() {
        var j = this._input, W = (this._config.chunkSize && (W = Math.min(this._start + this._config.chunkSize, this._input.size), j = F.call(j, this._start, W)), L.readAsText(j, this._config.encoding));
        z || this._chunkLoaded({ target: { result: W } });
      }, this._chunkLoaded = function(j) {
        this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(j.target.result);
      }, this._chunkError = function() {
        this._sendError(L.error);
      };
    }
    function v(R) {
      var L;
      p.call(this, R = R || {}), this.stream = function(F) {
        return L = F, this._nextChunk();
      }, this._nextChunk = function() {
        var F, z;
        if (!this._finished) return F = this._config.chunkSize, L = F ? (z = L.substring(0, F), L.substring(F)) : (z = L, ""), this._finished = !L, this.parseChunk(z);
      };
    }
    function m(R) {
      p.call(this, R = R || {});
      var L = [], F = !0, z = !1;
      this.pause = function() {
        p.prototype.pause.apply(this, arguments), this._input.pause();
      }, this.resume = function() {
        p.prototype.resume.apply(this, arguments), this._input.resume();
      }, this.stream = function(j) {
        this._input = j, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
      }, this._checkIsFinished = function() {
        z && L.length === 1 && (this._finished = !0);
      }, this._nextChunk = function() {
        this._checkIsFinished(), L.length ? this.parseChunk(L.shift()) : F = !0;
      }, this._streamData = _(function(j) {
        try {
          L.push(typeof j == "string" ? j : j.toString(this._config.encoding)), F && (F = !1, this._checkIsFinished(), this.parseChunk(L.shift()));
        } catch (W) {
          this._streamError(W);
        }
      }, this), this._streamError = _(function(j) {
        this._streamCleanUp(), this._sendError(j);
      }, this), this._streamEnd = _(function() {
        this._streamCleanUp(), z = !0, this._streamData("");
      }, this), this._streamCleanUp = _(function() {
        this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
      }, this);
    }
    function b(R) {
      var L, F, z, j, W = Math.pow(2, 53), te = -W, le = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, ce = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, Ee = this, xe = 0, _e = 0, Ie = !1, je = !1, ue = [], O = { data: [], errors: [], meta: {} };
      function N(ee) {
        return R.skipEmptyLines === "greedy" ? ee.join("").trim() === "" : ee.length === 1 && ee[0].length === 0;
      }
      function J() {
        if (O && z && (oe("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + c.DefaultDelimiter + "'"), z = !1), R.skipEmptyLines && (O.data = O.data.filter(function(H) {
          return !N(H);
        })), re()) {
          let H = function(X, Ae) {
            S(R.transformHeader) && (X = R.transformHeader(X, Ae)), ue.push(X);
          };
          if (O) if (Array.isArray(O.data[0])) {
            for (var ee = 0; re() && ee < O.data.length; ee++) O.data[ee].forEach(H);
            O.data.splice(0, 1);
          } else O.data.forEach(H);
        }
        function ae(H, X) {
          for (var Ae = R.header ? {} : [], Re = 0; Re < H.length; Re++) {
            var Fe = Re, Te = H[Re], Te = ((qe, tt) => ((Pe) => (R.dynamicTypingFunction && R.dynamicTyping[Pe] === void 0 && (R.dynamicTyping[Pe] = R.dynamicTypingFunction(Pe)), (R.dynamicTyping[Pe] || R.dynamicTyping) === !0))(qe) ? tt === "true" || tt === "TRUE" || tt !== "false" && tt !== "FALSE" && (((Pe) => {
              if (le.test(Pe) && (Pe = parseFloat(Pe), te < Pe && Pe < W))
                return 1;
            })(tt) ? parseFloat(tt) : ce.test(tt) ? new Date(tt) : tt === "" ? null : tt) : tt)(Fe = R.header ? Re >= ue.length ? "__parsed_extra" : ue[Re] : Fe, Te = R.transform ? R.transform(Te, Fe) : Te);
            Fe === "__parsed_extra" ? (Ae[Fe] = Ae[Fe] || [], Ae[Fe].push(Te)) : Ae[Fe] = Te;
          }
          return R.header && (Re > ue.length ? oe("FieldMismatch", "TooManyFields", "Too many fields: expected " + ue.length + " fields but parsed " + Re, _e + X) : Re < ue.length && oe("FieldMismatch", "TooFewFields", "Too few fields: expected " + ue.length + " fields but parsed " + Re, _e + X)), Ae;
        }
        var me;
        O && (R.header || R.dynamicTyping || R.transform) && (me = 1, !O.data.length || Array.isArray(O.data[0]) ? (O.data = O.data.map(ae), me = O.data.length) : O.data = ae(O.data, 0), R.header && O.meta && (O.meta.fields = ue), _e += me);
      }
      function re() {
        return R.header && ue.length === 0;
      }
      function oe(ee, ae, me, H) {
        ee = { type: ee, code: ae, message: me }, H !== void 0 && (ee.row = H), O.errors.push(ee);
      }
      S(R.step) && (j = R.step, R.step = function(ee) {
        O = ee, re() ? J() : (J(), O.data.length !== 0 && (xe += ee.data.length, R.preview && xe > R.preview ? F.abort() : (O.data = O.data[0], j(O, Ee))));
      }), this.parse = function(ee, ae, me) {
        var H = R.quoteChar || '"', H = (R.newline || (R.newline = this.guessLineEndings(ee, H)), z = !1, R.delimiter ? S(R.delimiter) && (R.delimiter = R.delimiter(ee), O.meta.delimiter = R.delimiter) : ((H = ((X, Ae, Re, Fe, Te) => {
          var qe, tt, Pe, At;
          Te = Te || [",", "	", "|", ";", c.RECORD_SEP, c.UNIT_SEP];
          for (var er = 0; er < Te.length; er++) {
            for (var ge, ht = Te[er], it = 0, kt = 0, Ze = 0, fe = (Pe = void 0, new E({ comments: Fe, delimiter: ht, newline: Ae, preview: 10 }).parse(X)), ye = 0; ye < fe.data.length; ye++) Re && N(fe.data[ye]) ? Ze++ : (ge = fe.data[ye].length, kt += ge, Pe === void 0 ? Pe = ge : 0 < ge && (it += Math.abs(ge - Pe), Pe = ge));
            0 < fe.data.length && (kt /= fe.data.length - Ze), (tt === void 0 || it <= tt) && (At === void 0 || At < kt) && 1.99 < kt && (tt = it, qe = ht, At = kt);
          }
          return { successful: !!(R.delimiter = qe), bestDelimiter: qe };
        })(ee, R.newline, R.skipEmptyLines, R.comments, R.delimitersToGuess)).successful ? R.delimiter = H.bestDelimiter : (z = !0, R.delimiter = c.DefaultDelimiter), O.meta.delimiter = R.delimiter), w(R));
        return R.preview && R.header && H.preview++, L = ee, F = new E(H), O = F.parse(L, ae, me), J(), Ie ? { meta: { paused: !0 } } : O || { meta: { paused: !1 } };
      }, this.paused = function() {
        return Ie;
      }, this.pause = function() {
        Ie = !0, F.abort(), L = S(R.chunk) ? "" : L.substring(F.getCharIndex());
      }, this.resume = function() {
        Ee.streamer._halted ? (Ie = !1, Ee.streamer.parseChunk(L, !0)) : setTimeout(Ee.resume, 3);
      }, this.aborted = function() {
        return je;
      }, this.abort = function() {
        je = !0, F.abort(), O.meta.aborted = !0, S(R.complete) && R.complete(O), L = "";
      }, this.guessLineEndings = function(X, H) {
        X = X.substring(0, 1048576);
        var H = new RegExp(f(H) + "([^]*?)" + f(H), "gm"), me = (X = X.replace(H, "")).split("\r"), H = X.split(`
`), X = 1 < H.length && H[0].length < me[0].length;
        if (me.length === 1 || X) return `
`;
        for (var Ae = 0, Re = 0; Re < me.length; Re++) me[Re][0] === `
` && Ae++;
        return Ae >= me.length / 2 ? `\r
` : "\r";
      };
    }
    function f(R) {
      return R.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function E(R) {
      var L = (R = R || {}).delimiter, F = R.newline, z = R.comments, j = R.step, W = R.preview, te = R.fastMode, le = null, ce = !1, Ee = R.quoteChar == null ? '"' : R.quoteChar, xe = Ee;
      if (R.escapeChar !== void 0 && (xe = R.escapeChar), (typeof L != "string" || -1 < c.BAD_DELIMITERS.indexOf(L)) && (L = ","), z === L) throw new Error("Comment character same as delimiter");
      z === !0 ? z = "#" : (typeof z != "string" || -1 < c.BAD_DELIMITERS.indexOf(z)) && (z = !1), F !== `
` && F !== "\r" && F !== `\r
` && (F = `
`);
      var _e = 0, Ie = !1;
      this.parse = function(je, ue, O) {
        if (typeof je != "string") throw new Error("Input must be a string");
        var N = je.length, J = L.length, re = F.length, oe = z.length, ee = S(j), ae = [], me = [], H = [], X = _e = 0;
        if (!je) return it();
        if (te || te !== !1 && je.indexOf(Ee) === -1) {
          for (var Ae = je.split(F), Re = 0; Re < Ae.length; Re++) {
            if (H = Ae[Re], _e += H.length, Re !== Ae.length - 1) _e += F.length;
            else if (O) return it();
            if (!z || H.substring(0, oe) !== z) {
              if (ee) {
                if (ae = [], At(H.split(L)), kt(), Ie) return it();
              } else At(H.split(L));
              if (W && W <= Re) return ae = ae.slice(0, W), it(!0);
            }
          }
          return it();
        }
        for (var Fe = je.indexOf(L, _e), Te = je.indexOf(F, _e), qe = new RegExp(f(xe) + f(Ee), "g"), tt = je.indexOf(Ee, _e); ; ) if (je[_e] === Ee) for (tt = _e, _e++; ; ) {
          if ((tt = je.indexOf(Ee, tt + 1)) === -1) return O || me.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: ae.length, index: _e }), ge();
          if (tt === N - 1) return ge(je.substring(_e, tt).replace(qe, Ee));
          if (Ee === xe && je[tt + 1] === xe) tt++;
          else if (Ee === xe || tt === 0 || je[tt - 1] !== xe) {
            Fe !== -1 && Fe < tt + 1 && (Fe = je.indexOf(L, tt + 1));
            var Pe = er((Te = Te !== -1 && Te < tt + 1 ? je.indexOf(F, tt + 1) : Te) === -1 ? Fe : Math.min(Fe, Te));
            if (je.substr(tt + 1 + Pe, J) === L) {
              H.push(je.substring(_e, tt).replace(qe, Ee)), je[_e = tt + 1 + Pe + J] !== Ee && (tt = je.indexOf(Ee, _e)), Fe = je.indexOf(L, _e), Te = je.indexOf(F, _e);
              break;
            }
            if (Pe = er(Te), je.substring(tt + 1 + Pe, tt + 1 + Pe + re) === F) {
              if (H.push(je.substring(_e, tt).replace(qe, Ee)), ht(tt + 1 + Pe + re), Fe = je.indexOf(L, _e), tt = je.indexOf(Ee, _e), ee && (kt(), Ie)) return it();
              if (W && ae.length >= W) return it(!0);
              break;
            }
            me.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: ae.length, index: _e }), tt++;
          }
        }
        else if (z && H.length === 0 && je.substring(_e, _e + oe) === z) {
          if (Te === -1) return it();
          _e = Te + re, Te = je.indexOf(F, _e), Fe = je.indexOf(L, _e);
        } else if (Fe !== -1 && (Fe < Te || Te === -1)) H.push(je.substring(_e, Fe)), _e = Fe + J, Fe = je.indexOf(L, _e);
        else {
          if (Te === -1) break;
          if (H.push(je.substring(_e, Te)), ht(Te + re), ee && (kt(), Ie)) return it();
          if (W && ae.length >= W) return it(!0);
        }
        return ge();
        function At(Ze) {
          ae.push(Ze), X = _e;
        }
        function er(Ze) {
          var fe = 0;
          return fe = Ze !== -1 && (Ze = je.substring(tt + 1, Ze)) && Ze.trim() === "" ? Ze.length : fe;
        }
        function ge(Ze) {
          return O || (Ze === void 0 && (Ze = je.substring(_e)), H.push(Ze), _e = N, At(H), ee && kt()), it();
        }
        function ht(Ze) {
          _e = Ze, At(H), H = [], Te = je.indexOf(F, _e);
        }
        function it(Ze) {
          if (R.header && !ue && ae.length && !ce) {
            var fe = ae[0], ye = /* @__PURE__ */ Object.create(null), Je = new Set(fe);
            let C = !1;
            for (let $ = 0; $ < fe.length; $++) {
              let D = fe[$];
              if (ye[D = S(R.transformHeader) ? R.transformHeader(D, $) : D]) {
                let se, pe = ye[D];
                for (; se = D + "_" + pe, pe++, Je.has(se); ) ;
                Je.add(se), fe[$] = se, ye[D]++, C = !0, (le = le === null ? {} : le)[se] = D;
              } else ye[D] = 1, fe[$] = D;
              Je.add(D);
            }
            C && console.warn("Duplicate headers found and renamed."), ce = !0;
          }
          return { data: ae, errors: me, meta: { delimiter: L, linebreak: F, aborted: Ie, truncated: !!Ze, cursor: X + (ue || 0), renamedHeaders: le } };
        }
        function kt() {
          j(it()), ae = [], me = [];
        }
      }, this.abort = function() {
        Ie = !0;
      }, this.getCharIndex = function() {
        return _e;
      };
    }
    function A(R) {
      var L = R.data, F = a[L.workerId], z = !1;
      if (L.error) F.userError(L.error, L.file);
      else if (L.results && L.results.data) {
        var j = { abort: function() {
          z = !0, x(L.workerId, { data: [], errors: [], meta: { aborted: !0 } });
        }, pause: g, resume: g };
        if (S(F.userStep)) {
          for (var W = 0; W < L.results.data.length && (F.userStep({ data: L.results.data[W], errors: L.results.errors, meta: L.results.meta }, j), !z); W++) ;
          delete L.results;
        } else S(F.userChunk) && (F.userChunk(L.results, j, L.file), delete L.results);
      }
      L.finished && !z && x(L.workerId, L.results);
    }
    function x(R, L) {
      var F = a[R];
      S(F.userComplete) && F.userComplete(L), F.terminate(), delete a[R];
    }
    function g() {
      throw new Error("Not implemented.");
    }
    function w(R) {
      if (typeof R != "object" || R === null) return R;
      var L, F = Array.isArray(R) ? [] : {};
      for (L in R) F[L] = w(R[L]);
      return F;
    }
    function _(R, L) {
      return function() {
        R.apply(L, arguments);
      };
    }
    function S(R) {
      return typeof R == "function";
    }
    return c.parse = function(R, L) {
      var F = (L = L || {}).dynamicTyping || !1;
      if (S(F) && (L.dynamicTypingFunction = F, F = {}), L.dynamicTyping = F, L.transform = !!S(L.transform) && L.transform, !L.worker || !c.WORKERS_SUPPORTED) return F = null, c.NODE_STREAM_INPUT, typeof R == "string" ? (R = ((z) => z.charCodeAt(0) !== 65279 ? z : z.slice(1))(R), F = new (L.download ? h : v)(L)) : R.readable === !0 && S(R.read) && S(R.on) ? F = new m(L) : (n.File && R instanceof File || R instanceof Object) && (F = new d(L)), F.stream(R);
      (F = (() => {
        var z;
        return !!c.WORKERS_SUPPORTED && (z = (() => {
          var j = n.URL || n.webkitURL || null, W = r.toString();
          return c.BLOB_URL || (c.BLOB_URL = j.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", W, ")();"], { type: "text/javascript" })));
        })(), (z = new n.Worker(z)).onmessage = A, z.id = l++, a[z.id] = z);
      })()).userStep = L.step, F.userChunk = L.chunk, F.userComplete = L.complete, F.userError = L.error, L.step = S(L.step), L.chunk = S(L.chunk), L.complete = S(L.complete), L.error = S(L.error), delete L.worker, F.postMessage({ input: R, config: L, workerId: F.id });
    }, c.unparse = function(R, L) {
      var F = !1, z = !0, j = ",", W = `\r
`, te = '"', le = te + te, ce = !1, Ee = null, xe = !1, _e = ((() => {
        if (typeof L == "object") {
          if (typeof L.delimiter != "string" || c.BAD_DELIMITERS.filter(function(ue) {
            return L.delimiter.indexOf(ue) !== -1;
          }).length || (j = L.delimiter), typeof L.quotes != "boolean" && typeof L.quotes != "function" && !Array.isArray(L.quotes) || (F = L.quotes), typeof L.skipEmptyLines != "boolean" && typeof L.skipEmptyLines != "string" || (ce = L.skipEmptyLines), typeof L.newline == "string" && (W = L.newline), typeof L.quoteChar == "string" && (te = L.quoteChar), typeof L.header == "boolean" && (z = L.header), Array.isArray(L.columns)) {
            if (L.columns.length === 0) throw new Error("Option columns is empty");
            Ee = L.columns;
          }
          L.escapeChar !== void 0 && (le = L.escapeChar + te), L.escapeFormulae instanceof RegExp ? xe = L.escapeFormulae : typeof L.escapeFormulae == "boolean" && L.escapeFormulae && (xe = /^[=+\-@\t\r].*$/);
        }
      })(), new RegExp(f(te), "g"));
      if (typeof R == "string" && (R = JSON.parse(R)), Array.isArray(R)) {
        if (!R.length || Array.isArray(R[0])) return Ie(null, R, ce);
        if (typeof R[0] == "object") return Ie(Ee || Object.keys(R[0]), R, ce);
      } else if (typeof R == "object") return typeof R.data == "string" && (R.data = JSON.parse(R.data)), Array.isArray(R.data) && (R.fields || (R.fields = R.meta && R.meta.fields || Ee), R.fields || (R.fields = Array.isArray(R.data[0]) ? R.fields : typeof R.data[0] == "object" ? Object.keys(R.data[0]) : []), Array.isArray(R.data[0]) || typeof R.data[0] == "object" || (R.data = [R.data])), Ie(R.fields || [], R.data || [], ce);
      throw new Error("Unable to serialize unrecognized input");
      function Ie(ue, O, N) {
        var J = "", re = (typeof ue == "string" && (ue = JSON.parse(ue)), typeof O == "string" && (O = JSON.parse(O)), Array.isArray(ue) && 0 < ue.length), oe = !Array.isArray(O[0]);
        if (re && z) {
          for (var ee = 0; ee < ue.length; ee++) 0 < ee && (J += j), J += je(ue[ee], ee);
          0 < O.length && (J += W);
        }
        for (var ae = 0; ae < O.length; ae++) {
          var me = (re ? ue : O[ae]).length, H = !1, X = re ? Object.keys(O[ae]).length === 0 : O[ae].length === 0;
          if (N && !re && (H = N === "greedy" ? O[ae].join("").trim() === "" : O[ae].length === 1 && O[ae][0].length === 0), N === "greedy" && re) {
            for (var Ae = [], Re = 0; Re < me; Re++) {
              var Fe = oe ? ue[Re] : Re;
              Ae.push(O[ae][Fe]);
            }
            H = Ae.join("").trim() === "";
          }
          if (!H) {
            for (var Te = 0; Te < me; Te++) {
              0 < Te && !X && (J += j);
              var qe = re && oe ? ue[Te] : Te;
              J += je(O[ae][qe], Te);
            }
            ae < O.length - 1 && (!N || 0 < me && !X) && (J += W);
          }
        }
        return J;
      }
      function je(ue, O) {
        var N, J;
        return ue == null ? "" : ue.constructor === Date ? JSON.stringify(ue).slice(1, 25) : (J = !1, xe && typeof ue == "string" && xe.test(ue) && (ue = "'" + ue, J = !0), N = ue.toString().replace(_e, le), (J = J || F === !0 || typeof F == "function" && F(ue, O) || Array.isArray(F) && F[O] || ((re, oe) => {
          for (var ee = 0; ee < oe.length; ee++) if (-1 < re.indexOf(oe[ee])) return !0;
          return !1;
        })(N, c.BAD_DELIMITERS) || -1 < N.indexOf(j) || N.charAt(0) === " " || N.charAt(N.length - 1) === " ") ? te + N + te : N);
      }
    }, c.RECORD_SEP = "", c.UNIT_SEP = "", c.BYTE_ORDER_MARK = "\uFEFF", c.BAD_DELIMITERS = ["\r", `
`, '"', c.BYTE_ORDER_MARK], c.WORKERS_SUPPORTED = !s && !!n.Worker, c.NODE_STREAM_INPUT = 1, c.LocalChunkSize = 10485760, c.RemoteChunkSize = 5242880, c.DefaultDelimiter = ",", c.Parser = E, c.ParserHandle = b, c.NetworkStreamer = h, c.FileStreamer = d, c.StringStreamer = v, c.ReadableStreamStreamer = m, n.jQuery && ((i = n.jQuery).fn.parse = function(R) {
      var L = R.config || {}, F = [];
      return this.each(function(W) {
        if (!(i(this).prop("tagName").toUpperCase() === "INPUT" && i(this).attr("type").toLowerCase() === "file" && n.FileReader) || !this.files || this.files.length === 0) return !0;
        for (var te = 0; te < this.files.length; te++) F.push({ file: this.files[te], inputElem: this, instanceConfig: i.extend({}, L) });
      }), z(), this;
      function z() {
        if (F.length === 0) S(R.complete) && R.complete();
        else {
          var W, te, le, ce, Ee = F[0];
          if (S(R.before)) {
            var xe = R.before(Ee.file, Ee.inputElem);
            if (typeof xe == "object") {
              if (xe.action === "abort") return W = "AbortError", te = Ee.file, le = Ee.inputElem, ce = xe.reason, void (S(R.error) && R.error({ name: W }, te, le, ce));
              if (xe.action === "skip") return void j();
              typeof xe.config == "object" && (Ee.instanceConfig = i.extend(Ee.instanceConfig, xe.config));
            } else if (xe === "skip") return void j();
          }
          var _e = Ee.instanceConfig.complete;
          Ee.instanceConfig.complete = function(Ie) {
            S(_e) && _e(Ie, Ee.file, Ee.inputElem), j();
          }, c.parse(Ee.file, Ee.instanceConfig);
        }
      }
      function j() {
        F.splice(0, 1), z();
      }
    }), o && (n.onmessage = function(R) {
      R = R.data, c.WORKER_ID === void 0 && R && (c.WORKER_ID = R.workerId), typeof R.input == "string" ? n.postMessage({ workerId: c.WORKER_ID, results: c.parse(R.input, R.config), finished: !0 }) : (n.File && R.input instanceof File || R.input instanceof Object) && (R = c.parse(R.input, R.config)) && n.postMessage({ workerId: c.WORKER_ID, results: R, finished: !0 });
    }), (h.prototype = Object.create(p.prototype)).constructor = h, (d.prototype = Object.create(p.prototype)).constructor = d, (v.prototype = Object.create(v.prototype)).constructor = v, (m.prototype = Object.create(p.prototype)).constructor = m, c;
  });
})(PN);
var Lse = PN.exports;
const RN = /* @__PURE__ */ Tse(Lse);
var I5 = Symbol.for("immer-nothing"), Qf = Symbol.for("immer-draftable"), Wi = Symbol.for("immer-state"), ON = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(t) {
    return `The plugin for '${t}' has not been loaded into Immer. To enable the plugin, import and call \`enable${t}()\` when initializing your application.`;
  },
  function(t) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${t}'`;
  },
  "This object has been frozen and should not be mutated",
  function(t) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + t;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(t) {
    return `'current' expects a draft, got: ${t}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(t) {
    return `'original' expects a draft, got: ${t}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function rn(t, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const r = ON[t], n = typeof r == "function" ? r.apply(null, e) : r;
    throw new Error(`[Immer] ${n}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var uh = Object.getPrototypeOf;
function hh(t) {
  return !!t && !!t[Wi];
}
function Jl(t) {
  var e;
  return t ? TN(t) || Array.isArray(t) || !!t[Qf] || !!((e = t.constructor) != null && e[Qf]) || Tg(t) || Lg(t) : !1;
}
var Mse = Object.prototype.constructor.toString();
function TN(t) {
  if (!t || typeof t != "object")
    return !1;
  const e = uh(t);
  if (e === null)
    return !0;
  const r = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return r === Object ? !0 : typeof r == "function" && Function.toString.call(r) === Mse;
}
function k0(t, e) {
  ph(t) === 0 ? Reflect.ownKeys(t).forEach((r) => {
    e(r, t[r], t);
  }) : t.forEach((r, n) => e(n, r, t));
}
function ph(t) {
  const e = t[Wi];
  return e ? e.type_ : Array.isArray(t) ? 1 : Tg(t) ? 2 : Lg(t) ? 3 : 0;
}
function _0(t, e) {
  return ph(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function Aw(t, e) {
  return ph(t) === 2 ? t.get(e) : t[e];
}
function LN(t, e, r) {
  const n = ph(t);
  n === 2 ? t.set(e, r) : n === 3 ? t.add(r) : t[e] = r;
}
function Nse(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function Tg(t) {
  return t instanceof Map;
}
function Lg(t) {
  return t instanceof Set;
}
function Ru(t) {
  return t.copy_ || t.base_;
}
function Gx(t, e) {
  if (Tg(t))
    return new Map(t);
  if (Lg(t))
    return new Set(t);
  if (Array.isArray(t))
    return Array.prototype.slice.call(t);
  const r = TN(t);
  if (e === !0 || e === "class_only" && !r) {
    const n = Object.getOwnPropertyDescriptors(t);
    delete n[Wi];
    let i = Reflect.ownKeys(n);
    for (let s = 0; s < i.length; s++) {
      const o = i[s], a = n[o];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (n[o] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: t[o]
      });
    }
    return Object.create(uh(t), n);
  } else {
    const n = uh(t);
    if (n !== null && r)
      return { ...t };
    const i = Object.create(n);
    return Object.assign(i, t);
  }
}
function P5(t, e = !1) {
  return Cv(t) || hh(t) || !Jl(t) || (ph(t) > 1 && (t.set = t.add = t.clear = t.delete = Dse), Object.freeze(t), e && Object.entries(t).forEach(([r, n]) => P5(n, !0))), t;
}
function Dse() {
  rn(2);
}
function Cv(t) {
  return Object.isFrozen(t);
}
var Wx = {};
function dh(t) {
  const e = Wx[t];
  return e || rn(0, t), e;
}
function $se(t, e) {
  Wx[t] || (Wx[t] = e);
}
var C0;
function MN() {
  return C0;
}
function jse(t, e) {
  return {
    drafts_: [],
    parent_: t,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function I7(t, e) {
  e && (dh("Patches"), t.patches_ = [], t.inversePatches_ = [], t.patchListener_ = e);
}
function qx(t) {
  Qx(t), t.drafts_.forEach(Bse), t.drafts_ = null;
}
function Qx(t) {
  t === C0 && (C0 = t.parent_);
}
function P7(t) {
  return C0 = jse(C0, t);
}
function Bse(t) {
  const e = t[Wi];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function R7(t, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const r = e.drafts_[0];
  return t !== void 0 && t !== r ? (r[Wi].modified_ && (qx(e), rn(4)), Jl(t) && (t = Oy(e, t), e.parent_ || Ty(e, t)), e.patches_ && dh("Patches").generateReplacementPatches_(
    r[Wi].base_,
    t,
    e.patches_,
    e.inversePatches_
  )) : t = Oy(e, r, []), qx(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), t !== I5 ? t : void 0;
}
function Oy(t, e, r) {
  if (Cv(e))
    return e;
  const n = e[Wi];
  if (!n)
    return k0(
      e,
      (i, s) => O7(t, n, e, i, s, r)
    ), e;
  if (n.scope_ !== t)
    return e;
  if (!n.modified_)
    return Ty(t, n.base_, !0), n.base_;
  if (!n.finalized_) {
    n.finalized_ = !0, n.scope_.unfinalizedDrafts_--;
    const i = n.copy_;
    let s = i, o = !1;
    n.type_ === 3 && (s = new Set(i), i.clear(), o = !0), k0(
      s,
      (a, l) => O7(t, n, i, a, l, r, o)
    ), Ty(t, i, !1), r && t.patches_ && dh("Patches").generatePatches_(
      n,
      r,
      t.patches_,
      t.inversePatches_
    );
  }
  return n.copy_;
}
function O7(t, e, r, n, i, s, o) {
  if (process.env.NODE_ENV !== "production" && i === r && rn(5), hh(i)) {
    const a = s && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !_0(e.assigned_, n) ? s.concat(n) : void 0, l = Oy(t, i, a);
    if (LN(r, n, l), hh(l))
      t.canAutoFreeze_ = !1;
    else
      return;
  } else o && r.add(i);
  if (Jl(i) && !Cv(i)) {
    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1)
      return;
    Oy(t, i), (!e || !e.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(r, n) && Ty(t, i);
  }
}
function Ty(t, e, r = !1) {
  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && P5(e, r);
}
function Fse(t, e) {
  const r = Array.isArray(t), n = {
    type_: r ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : MN(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: t,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = n, s = R5;
  r && (i = [n], s = I0);
  const { revoke: o, proxy: a } = Proxy.revocable(i, s);
  return n.draft_ = a, n.revoke_ = o, a;
}
var R5 = {
  get(t, e) {
    if (e === Wi)
      return t;
    const r = Ru(t);
    if (!_0(r, e))
      return zse(t, r, e);
    const n = r[e];
    return t.finalized_ || !Jl(n) ? n : n === kw(t.base_, e) ? (_w(t), t.copy_[e] = Yx(n, t)) : n;
  },
  has(t, e) {
    return e in Ru(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(Ru(t));
  },
  set(t, e, r) {
    const n = NN(Ru(t), e);
    if (n != null && n.set)
      return n.set.call(t.draft_, r), !0;
    if (!t.modified_) {
      const i = kw(Ru(t), e), s = i == null ? void 0 : i[Wi];
      if (s && s.base_ === r)
        return t.copy_[e] = r, t.assigned_[e] = !1, !0;
      if (Nse(r, i) && (r !== void 0 || _0(t.base_, e)))
        return !0;
      _w(t), Kx(t);
    }
    return t.copy_[e] === r && // special case: handle new props with value 'undefined'
    (r !== void 0 || e in t.copy_) || // special case: NaN
    Number.isNaN(r) && Number.isNaN(t.copy_[e]) || (t.copy_[e] = r, t.assigned_[e] = !0), !0;
  },
  deleteProperty(t, e) {
    return kw(t.base_, e) !== void 0 || e in t.base_ ? (t.assigned_[e] = !1, _w(t), Kx(t)) : delete t.assigned_[e], t.copy_ && delete t.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(t, e) {
    const r = Ru(t), n = Reflect.getOwnPropertyDescriptor(r, e);
    return n && {
      writable: !0,
      configurable: t.type_ !== 1 || e !== "length",
      enumerable: n.enumerable,
      value: r[e]
    };
  },
  defineProperty() {
    rn(11);
  },
  getPrototypeOf(t) {
    return uh(t.base_);
  },
  setPrototypeOf() {
    rn(12);
  }
}, I0 = {};
k0(R5, (t, e) => {
  I0[t] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
I0.deleteProperty = function(t, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && rn(13), I0.set.call(this, t, e, void 0);
};
I0.set = function(t, e, r) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && rn(14), R5.set.call(this, t[0], e, r, t[0]);
};
function kw(t, e) {
  const r = t[Wi];
  return (r ? Ru(r) : t)[e];
}
function zse(t, e, r) {
  var i;
  const n = NN(e, r);
  return n ? "value" in n ? n.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = n.get) == null ? void 0 : i.call(t.draft_)
  ) : void 0;
}
function NN(t, e) {
  if (!(e in t))
    return;
  let r = uh(t);
  for (; r; ) {
    const n = Object.getOwnPropertyDescriptor(r, e);
    if (n)
      return n;
    r = uh(r);
  }
}
function Kx(t) {
  t.modified_ || (t.modified_ = !0, t.parent_ && Kx(t.parent_));
}
function _w(t) {
  t.copy_ || (t.copy_ = Gx(
    t.base_,
    t.scope_.immer_.useStrictShallowCopy_
  ));
}
var Use = class {
  constructor(t) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, r, n) => {
      if (typeof e == "function" && typeof r != "function") {
        const s = r;
        r = e;
        const o = this;
        return function(l = s, ...c) {
          return o.produce(l, (p) => r.call(this, p, ...c));
        };
      }
      typeof r != "function" && rn(6), n !== void 0 && typeof n != "function" && rn(7);
      let i;
      if (Jl(e)) {
        const s = P7(this), o = Yx(e, void 0);
        let a = !0;
        try {
          i = r(o), a = !1;
        } finally {
          a ? qx(s) : Qx(s);
        }
        return I7(s, n), R7(i, s);
      } else if (!e || typeof e != "object") {
        if (i = r(e), i === void 0 && (i = e), i === I5 && (i = void 0), this.autoFreeze_ && P5(i, !0), n) {
          const s = [], o = [];
          dh("Patches").generateReplacementPatches_(e, i, s, o), n(s, o);
        }
        return i;
      } else
        rn(1, e);
    }, this.produceWithPatches = (e, r) => {
      if (typeof e == "function")
        return (o, ...a) => this.produceWithPatches(o, (l) => e(l, ...a));
      let n, i;
      return [this.produce(e, r, (o, a) => {
        n = o, i = a;
      }), n, i];
    }, typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze), typeof (t == null ? void 0 : t.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(t.useStrictShallowCopy);
  }
  createDraft(t) {
    Jl(t) || rn(8), hh(t) && (t = Vse(t));
    const e = P7(this), r = Yx(t, void 0);
    return r[Wi].isManual_ = !0, Qx(e), r;
  }
  finishDraft(t, e) {
    const r = t && t[Wi];
    (!r || !r.isManual_) && rn(9);
    const { scope_: n } = r;
    return I7(n, e), R7(void 0, n);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(t) {
    this.autoFreeze_ = t;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(t) {
    this.useStrictShallowCopy_ = t;
  }
  applyPatches(t, e) {
    let r;
    for (r = e.length - 1; r >= 0; r--) {
      const i = e[r];
      if (i.path.length === 0 && i.op === "replace") {
        t = i.value;
        break;
      }
    }
    r > -1 && (e = e.slice(r + 1));
    const n = dh("Patches").applyPatches_;
    return hh(t) ? n(t, e) : this.produce(
      t,
      (i) => n(i, e)
    );
  }
};
function Yx(t, e) {
  const r = Tg(t) ? dh("MapSet").proxyMap_(t, e) : Lg(t) ? dh("MapSet").proxySet_(t, e) : Fse(t, e);
  return (e ? e.scope_ : MN()).drafts_.push(r), r;
}
function Vse(t) {
  return hh(t) || rn(10, t), DN(t);
}
function DN(t) {
  if (!Jl(t) || Cv(t))
    return t;
  const e = t[Wi];
  let r;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, r = Gx(t, e.scope_.immer_.useStrictShallowCopy_);
  } else
    r = Gx(t, !0);
  return k0(r, (n, i) => {
    LN(r, n, DN(i));
  }), e && (e.finalized_ = !1), r;
}
function Hse() {
  process.env.NODE_ENV !== "production" && ON.push(
    'Sets cannot have "replace" patches.',
    function(d) {
      return "Unsupported patch operation: " + d;
    },
    function(d) {
      return "Cannot apply patch, path doesn't resolve: " + d;
    },
    "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
  );
  const e = "replace", r = "add", n = "remove";
  function i(d, v, m, b) {
    switch (d.type_) {
      case 0:
      case 2:
        return o(
          d,
          v,
          m,
          b
        );
      case 1:
        return s(d, v, m, b);
      case 3:
        return a(
          d,
          v,
          m,
          b
        );
    }
  }
  function s(d, v, m, b) {
    let { base_: f, assigned_: E } = d, A = d.copy_;
    A.length < f.length && ([f, A] = [A, f], [m, b] = [b, m]);
    for (let x = 0; x < f.length; x++)
      if (E[x] && A[x] !== f[x]) {
        const g = v.concat([x]);
        m.push({
          op: e,
          path: g,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: h(A[x])
        }), b.push({
          op: e,
          path: g,
          value: h(f[x])
        });
      }
    for (let x = f.length; x < A.length; x++) {
      const g = v.concat([x]);
      m.push({
        op: r,
        path: g,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: h(A[x])
      });
    }
    for (let x = A.length - 1; f.length <= x; --x) {
      const g = v.concat([x]);
      b.push({
        op: n,
        path: g
      });
    }
  }
  function o(d, v, m, b) {
    const { base_: f, copy_: E } = d;
    k0(d.assigned_, (A, x) => {
      const g = Aw(f, A), w = Aw(E, A), _ = x ? _0(f, A) ? e : r : n;
      if (g === w && _ === e)
        return;
      const S = v.concat(A);
      m.push(_ === n ? { op: _, path: S } : { op: _, path: S, value: w }), b.push(
        _ === r ? { op: n, path: S } : _ === n ? { op: r, path: S, value: h(g) } : { op: e, path: S, value: h(g) }
      );
    });
  }
  function a(d, v, m, b) {
    let { base_: f, copy_: E } = d, A = 0;
    f.forEach((x) => {
      if (!E.has(x)) {
        const g = v.concat([A]);
        m.push({
          op: n,
          path: g,
          value: x
        }), b.unshift({
          op: r,
          path: g,
          value: x
        });
      }
      A++;
    }), A = 0, E.forEach((x) => {
      if (!f.has(x)) {
        const g = v.concat([A]);
        m.push({
          op: r,
          path: g,
          value: x
        }), b.unshift({
          op: n,
          path: g,
          value: x
        });
      }
      A++;
    });
  }
  function l(d, v, m, b) {
    m.push({
      op: e,
      path: [],
      value: v === I5 ? void 0 : v
    }), b.push({
      op: e,
      path: [],
      value: d
    });
  }
  function c(d, v) {
    return v.forEach((m) => {
      const { path: b, op: f } = m;
      let E = d;
      for (let w = 0; w < b.length - 1; w++) {
        const _ = ph(E);
        let S = b[w];
        typeof S != "string" && typeof S != "number" && (S = "" + S), (_ === 0 || _ === 1) && (S === "__proto__" || S === "constructor") && rn(19), typeof E == "function" && S === "prototype" && rn(19), E = Aw(E, S), typeof E != "object" && rn(18, b.join("/"));
      }
      const A = ph(E), x = p(m.value), g = b[b.length - 1];
      switch (f) {
        case e:
          switch (A) {
            case 2:
              return E.set(g, x);
            case 3:
              rn(16);
            default:
              return E[g] = x;
          }
        case r:
          switch (A) {
            case 1:
              return g === "-" ? E.push(x) : E.splice(g, 0, x);
            case 2:
              return E.set(g, x);
            case 3:
              return E.add(x);
            default:
              return E[g] = x;
          }
        case n:
          switch (A) {
            case 1:
              return E.splice(g, 1);
            case 2:
              return E.delete(g);
            case 3:
              return E.delete(m.value);
            default:
              return delete E[g];
          }
        default:
          rn(17, f);
      }
    }), d;
  }
  function p(d) {
    if (!Jl(d))
      return d;
    if (Array.isArray(d))
      return d.map(p);
    if (Tg(d))
      return new Map(
        Array.from(d.entries()).map(([m, b]) => [m, p(b)])
      );
    if (Lg(d))
      return new Set(Array.from(d).map(p));
    const v = Object.create(uh(d));
    for (const m in d)
      v[m] = p(d[m]);
    return _0(d, Qf) && (v[Qf] = d[Qf]), v;
  }
  function h(d) {
    return hh(d) ? p(d) : d;
  }
  $se("Patches", {
    applyPatches_: c,
    generatePatches_: i,
    generateReplacementPatches_: l
  });
}
var qi = new Use(), Gse = qi.produce, Wse = qi.produceWithPatches.bind(
  qi
);
qi.setAutoFreeze.bind(qi);
qi.setUseStrictShallowCopy.bind(qi);
qi.applyPatches.bind(qi);
qi.createDraft.bind(qi);
qi.finishDraft.bind(qi);
var $N = (t) => {
  throw TypeError(t);
}, jN = (t, e, r) => e.has(t) || $N("Cannot " + r), T7 = (t, e, r) => (jN(t, e, "read from private field"), r ? r.call(t) : e.get(t)), L7 = (t, e, r) => e.has(t) ? $N("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), M7 = (t, e, r, n) => (jN(t, e, "write to private field"), e.set(t, r), r);
const Ly = "[a-fA-F0-9]", Pd = "[a-zA-Z0-9-._~]", so = "[!$&'()*+,;=]", Nh = `%${Ly}${Ly}`, Dm = "(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])", O5 = `${Dm}\\.${Dm}\\.${Dm}\\.${Dm}`, Lr = `${Ly}{1,4}`, wu = `(?:${Lr}:${Lr}|${O5})`, qse = `(?:(?:${Lr}:){6}${wu}|::(?:${Lr}:){5}${wu}|(?:${Lr})?::(?:${Lr}:){4}${wu}|(?:(?:${Lr}:){0,1}${Lr})?::(?:${Lr}:){3}${wu}|(?:(?:${Lr}:){0,2}${Lr})?::(?:${Lr}:){2}${wu}|(?:(?:${Lr}:){0,3}${Lr})?::(?:${Lr}:){1}${wu}|(?:(?:${Lr}:){0,4}${Lr})?::${wu}|(?:(?:${Lr}:){0,5}${Lr})?::${Lr}|(?:(?:${Lr}:){0,6}${Lr})?::)`, Qse = `v${Ly}+\\.(?:${Pd}|${so}|:)+`, BN = `\\[(?:${qse}|${Qse})\\]`, Rd = "(?<scheme>[a-zA-Z][a-zA-Z0-9-+.]*)", FN = ":(?<port>\\d*)", Kse = `(?:${Pd}|${Nh}|${so})*?`, Yse = `(?<host>${BN}|${O5}|${Kse})`, Zse = `(?<userinfo>(?:${Pd}|${Nh}|${so}|:)*)`, T5 = `(?:${Pd}|${Nh}|${so}|:|@)`, zN = `${T5}*?`, UN = `(?:/${zN})*`, L5 = `(?<authority>(?:${Zse}@)?${Yse}(?:${FN})?)`, M5 = `(?<path>${UN})`, N5 = `(?<path2>${zN}${UN})`, D5 = `(?:\\?(?<query>(?:${T5}|/|\\?)*))?`, VN = `(?:#(?<fragment>(?:${T5}|/|\\?)*))?`, Jse = `^${Rd}:(?://${L5}${M5}|${N5})${D5}${VN}$`, Xse = `^(?:${Rd}:|)(?://${L5}${M5}|${N5})${D5}${VN}$`, eoe = `^${Rd}:(?://${L5}${M5}|${N5})${D5}$`, Mg = "[a-zA-Z0-9-._~\\00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF\\u10000-\\u1FFFD\\u20000-\\u2FFFD\\u30000-\\u3FFFD\\u40000-\\u4FFFD\\u50000-\\u5FFFD\\u60000-\\u6FFFD\\u70000-\\u7FFFD\\u80000-\\u8FFFD\\u90000-\\u9FFFD\\uA0000-\\uAFFFD\\uB0000-\\uBFFFD\\uC0000-\\uCFFFD\\uD0000-\\uDFFFD\\uE1000-\\uEFFFD]", toe = "[\\uE000-\\uF8FF\\uF0000-\\uFFFFD\\u100000-\\u10FFFD]", roe = `(?:${Mg}|${Nh}|${so})*?`, noe = `(?<host>${BN}|${O5}|${roe})`, ioe = `(?<userinfo>(?:${Mg}|${Nh}|${so}|:)*)`, $5 = `(?:${Mg}|${Nh}|${so}|:|@)`, HN = `${$5}*?`, GN = `(?:/${HN})*`, j5 = `(?<authority>(?:${ioe}@)?${noe}(?:${FN})?)`, B5 = `(?<path>${GN})`, F5 = `(?<path2>${HN}${GN})`, z5 = `(?:\\?(?<query>(?:${$5}|${toe}|/|\\?)*))?`, WN = `(?:#(?<fragment>(?:${$5}|/|\\?)*))?`, qN = `^${Rd}:(?://${j5}${B5}|${F5})${z5}${WN}$`, QN = `^(?:${Rd}:|)(?://${j5}${B5}|${F5})${z5}${WN}$`, KN = `^${Rd}:(?://${j5}${B5}|${F5})${z5}$`, soe = (t) => (e, r) => {
  const n = (
    /** @type IdentifierComponents */
    t.parseReference(e)
  );
  if (n.scheme === void 0) {
    const i = t.parseAbsolute(r);
    n.scheme = i.scheme, n.authority === void 0 && (n.authority = i.authority, n.path === "" ? (n.path = i.path, n.query === void 0 && (n.query = i.query)) : n.path.startsWith("/") || (n.path = ooe(n.path, i)));
  }
  return YN(t, n);
}, ooe = (t, e) => {
  if (e.authority && e.path === "")
    return "/" + t;
  {
    const r = e.path.lastIndexOf("/");
    return r === -1 ? t : e.path.slice(0, r + 1) + t;
  }
}, aoe = /^\.?\.\/|^\.\.?$/, loe = /^\/\.(?:\/|$)/, coe = /^\/\.\.(?:\/|$)/, uoe = (t) => {
  let e = "";
  for (; t.length > 0; )
    if (aoe.test(t))
      t = N7(t);
    else if (loe.test(t))
      t = D7(t);
    else if (coe.test(t))
      t = D7(t), e = hoe(e);
    else {
      const r = poe(t);
      t = N7(t), e += r;
    }
  return e;
}, N7 = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "" : "/" + t.slice(e + 1);
}, D7 = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "/" : "/" + t.slice(e + 1);
}, hoe = (t) => {
  const e = t.lastIndexOf("/");
  return e === -1 ? t : t.slice(0, e);
}, poe = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? t : t.slice(0, e);
}, YN = (t, e) => {
  let r = e.scheme.toLowerCase() + ":";
  return r += e.authority === void 0 ? "" : "//" + e.authority.toLowerCase(), r += t.normalizePath(e.path), r += e.query === void 0 ? "" : "?" + t.normalizeQuery(e.query), r += e.fragment === void 0 ? "" : "#" + t.normalizeFragment(e.fragment), r;
}, ZN = new RegExp(Nh, "g"), JN = (t) => (e) => {
  const r = parseInt(e.slice(1), 16), n = String.fromCharCode(r);
  return t(n) ? n : e.toUpperCase();
};
RegExp.prototype.test.bind(new RegExp(`${Pd}|${so}|[:@]`));
const doe = RegExp.prototype.test.bind(new RegExp(`${Mg}|${so}|[:@]`)), foe = (t) => (e) => uoe(e).replaceAll(ZN, JN(t));
RegExp.prototype.test.bind(new RegExp(`${Pd}|${so}|[:@/?]`));
const $7 = RegExp.prototype.test.bind(new RegExp(`${Mg}|${so}|[:@/?]`)), j7 = (t) => (e) => e.replaceAll(ZN, JN(t));
RegExp.prototype.test.bind(new RegExp(Jse));
RegExp.prototype.test.bind(new RegExp(Xse));
RegExp.prototype.test.bind(new RegExp(eoe));
RegExp.prototype.test.bind(new RegExp(qN));
RegExp.prototype.test.bind(new RegExp(QN));
RegExp.prototype.test.bind(new RegExp(KN));
const U5 = (t, e) => (r) => {
  const n = t.exec(r);
  if (n === null)
    throw Error(`Invalid ${e}: ${r}`);
  const i = (
    /** @type Record<string, string> */
    n.groups
  );
  return i.authority === void 0 && (i.path = i.path2), delete i.path2, /** @type A */
  i;
}, V5 = (
  /** @type Parser<IdentifierComponents> */
  U5(new RegExp(qN), "IRI")
), XN = (
  /** @type Parser<RelativeIdentifierComponents> */
  U5(new RegExp(QN), "IRI-reference")
), goe = (
  /** @type Parser<AbsoluteIdentifierComponents> */
  U5(new RegExp(KN), "absolute-IRI")
), eD = {
  iri: {
    parseAbsolute: goe,
    parseReference: XN,
    parse: V5,
    normalizePath: foe(doe),
    normalizeQuery: j7($7),
    normalizeFragment: j7($7)
  }
}, moe = (t) => (e) => {
  const r = t.parse(e);
  return delete r.fragment, YN(t, r);
}, Ku = moe(eD.iri), P0 = soe(eD.iri), yoe = "", Zx = function* (t) {
  if (t.length > 0 && t[0] !== "/")
    throw Error("Invalid JSON Pointer");
  let e = 1, r = 0;
  for (; r < t.length; ) {
    const n = t.indexOf("/", e);
    r = n === -1 ? t.length : n;
    const i = t.slice(e, r);
    e = r + 1, yield woe(i);
  }
}, voe = (t, e = void 0) => {
  if (e === void 0) {
    const r = [...Zx(t)];
    return (n) => B7(r, n);
  } else
    return B7(Zx(t), e);
}, B7 = (t, e) => {
  let r = yoe;
  for (const n of t)
    e = Eoe(e, n, r), r = fh(n, r);
  return e;
}, fh = (t, e) => e + "/" + boe(t), boe = (t) => t.toString().replace(/~/g, "~0").replace(/\//g, "~1"), woe = (t) => t.toString().replace(/~1/g, "/").replace(/~0/g, "~"), xoe = (t, e) => Array.isArray(t) && e === "-" ? t.length : e, Eoe = (t, e, r = "") => {
  if (t === void 0)
    throw TypeError(`Value at '${r}' is undefined and does not have property '${e}'`);
  if (t === null)
    throw TypeError(`Value at '${r}' is null and does not have property '${e}'`);
  if (Soe(t))
    throw TypeError(`Value at '${r}' is a ${typeof t} and does not have property '${e}'`);
  {
    const n = xoe(t, e);
    return t[n];
  }
}, Soe = (t) => t === null || typeof t != "object", tD = (t) => {
  const e = typeof t;
  switch (e) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JSON compatible type: ${r}`);
    }
  }
}, rD = (t) => {
  const e = t.indexOf("#"), r = e === -1 ? t.length : e;
  return t.slice(0, r);
}, nD = (t) => decodeURIComponent(XN(t).fragment || ""), My = {}, Iv = (t) => {
  if (t.indexOf("#") !== -1) {
    const e = rD(t);
    return { ...My[e], id: t };
  }
  return My[t];
}, Aoe = (t, e) => {
  const r = koe(t, e);
  if (!r)
    throw Error(`Encountered unknown keyword '${t}'`);
  const n = Iv(r);
  if (!n)
    throw Error(`Encountered unsupported keyword ${t}. You can provide an implementation for the '${r}' keyword using the 'addKeyword' function.`);
  return n;
}, lt = (t) => {
  My[t.id] = t;
}, Jx = {}, Cc = (t, e) => {
  Jx[t] = e;
}, Kf = {}, Xx = {}, Cw = {}, koe = (t, e) => {
  var r;
  return ((r = iD(e)) == null ? void 0 : r[t]) || (Xx[e] || t.startsWith("x-")) && `https://json-schema.org/keyword/unknown#${t}`;
}, Jr = (t, e) => {
  const r = iD(t);
  for (const n in r)
    if (r[n] === e)
      return n;
}, iD = (t) => {
  if (!(t in Kf))
    throw Error(`Encountered unknown dialect '${t}'`);
  return Kf[t];
}, sD = (t, e, r = !1, n = !0) => {
  Xx[t] = r, Cw[t] = Cw[t] || n, Kf[t] = {}, Object.entries(e).forEach(([i, s]) => {
    if (i in Jx)
      Object.entries(Jx[i]).forEach(([o, a]) => {
        !(a in My) && !s && (a = `https://json-schema.org/keyword/unknown#${o}`), Kf[t][o] = a;
      });
    else if (!r || s)
      throw delete Kf[t], delete Xx[t], delete Cw[t], Error(`Unrecognized vocabulary: ${i}. You can define this vocabulary with the 'defineVocabulary' function.`);
  });
};
var F7 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function oD(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var $m = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var z7;
function _oe() {
  if (z7) return $m;
  z7 = 1;
  var t = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, e = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, n = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  $m.format = o, $m.parse = a;
  function o(h) {
    if (!h || typeof h != "object")
      throw new TypeError("argument obj is required");
    var d = h.parameters, v = h.type;
    if (!v || !s.test(v))
      throw new TypeError("invalid type");
    var m = v;
    if (d && typeof d == "object")
      for (var b, f = Object.keys(d).sort(), E = 0; E < f.length; E++) {
        if (b = f[E], !r.test(b))
          throw new TypeError("invalid parameter name");
        m += "; " + b + "=" + c(d[b]);
      }
    return m;
  }
  function a(h) {
    if (!h)
      throw new TypeError("argument string is required");
    var d = typeof h == "object" ? l(h) : h;
    if (typeof d != "string")
      throw new TypeError("argument string is required to be a string");
    var v = d.indexOf(";"), m = v !== -1 ? d.slice(0, v).trim() : d.trim();
    if (!s.test(m))
      throw new TypeError("invalid media type");
    var b = new p(m.toLowerCase());
    if (v !== -1) {
      var f, E, A;
      for (t.lastIndex = v; E = t.exec(d); ) {
        if (E.index !== v)
          throw new TypeError("invalid parameter format");
        v += E[0].length, f = E[1].toLowerCase(), A = E[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(n, "$1"))), b.parameters[f] = A;
      }
      if (v !== d.length)
        throw new TypeError("invalid parameter format");
    }
    return b;
  }
  function l(h) {
    var d;
    if (typeof h.getHeader == "function" ? d = h.getHeader("content-type") : typeof h.headers == "object" && (d = h.headers && h.headers["content-type"]), typeof d != "string")
      throw new TypeError("content-type header is missing from object");
    return d;
  }
  function c(h) {
    var d = String(h);
    if (r.test(d))
      return d;
    if (d.length > 0 && !e.test(d))
      throw new TypeError("invalid parameter value");
    return '"' + d.replace(i, "\\$1") + '"';
  }
  function p(h) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = h;
  }
  return $m;
}
var aD = _oe();
const Coe = /* @__PURE__ */ oD(aD), R0 = {}, lD = (t, e) => {
  R0[t] = e;
}, Ioe = (t) => {
  const e = t.headers.get("content-type");
  if (e === null)
    throw new Moe("The media type of the response could not be determined. Make sure the response includes a 'Content-Type' header.", { cause: t });
  const r = aD.parse(e);
  for (const n in R0)
    if (Ooe(n, r.type))
      return R0[n].parse(t);
  throw new Loe(r.type, `'${r.type}' is not supported. Use the 'addMediaTypePlugin' function to add support for this media type.`, {
    cause: t
  });
}, Poe = "A-Za-z", Iw = `[!#$%&'*\\-_.^\`|~\\d${Poe}]+`, Roe = `(?<type>${Iw})/(?<subType>${Iw}(?:\\+(?<suffix>${Iw}))?)`, U7 = new RegExp(Roe), Ooe = (t, e) => {
  var r, n;
  if (t === e)
    return !0;
  const i = (r = U7.exec(t)) == null ? void 0 : r.groups;
  if (!i)
    throw Error(`Unable to parse media-range: ${t}`);
  const s = (n = U7.exec(e)) == null ? void 0 : n.groups;
  if (!s)
    throw Error(`Unable to parse media-type: ${e}`);
  return (i.type === s.type || i.type === "*") && (i.subType === s.subType || i.subType === "*" || i.subType === s.suffix);
}, Toe = () => {
  let t = "";
  for (const e in R0)
    t = V7(t, e, R0[e].quality);
  return V7(t, "*/*", "0.001");
}, V7 = (t, e, r) => (t.length > 0 && (t += ", "), t += e, r && (t += `; q=${r}`), t);
let Loe = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.mediaType = e;
  }
}, Moe = class extends Error {
  constructor(e = void 0) {
    super(e), this.name = this.constructor.name;
  }
};
const Noe = (t, e = void 0) => JSON.parse(t, (r, n) => {
  const i = n !== null && typeof n.$ref == "string" ? new Du(n.$ref) : n;
  return e ? e(r, i) : i;
});
var E1, S1;
let Du = class {
  constructor(e, r = void 0) {
    L7(this, E1), L7(this, S1), M7(this, E1, e), M7(this, S1, r ?? { $ref: e });
  }
  get href() {
    return T7(this, E1);
  }
  toJSON() {
    return T7(this, S1);
  }
};
E1 = /* @__PURE__ */ new WeakMap(), S1 = /* @__PURE__ */ new WeakMap();
const cD = (t) => {
  const e = typeof t;
  switch (e) {
    case "bigint":
      return "number";
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (t instanceof Du)
        return "reference";
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype || Object.getPrototypeOf(t) === null)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JRef compatible type: ${r}`);
    }
  }
}, Doe = {
  parse: async (t) => ({
    baseUri: t.url,
    root: Noe(await t.text()),
    anchorLocation: $oe
  }),
  fileMatcher: (t) => /[^/]\.jref$/.test(t)
}, $oe = (t) => decodeURI(t || ""), e4 = {}, uD = (t, e) => {
  e4[t] = e;
}, joe = (t, e) => {
  t = P0(t, e);
  const { scheme: r } = V5(t);
  if (!(r in e4))
    throw new Boe(r, `The '${r}:' URI scheme is not supported. Use the 'addUriSchemePlugin' function to add support for '${r}:' URIs.`);
  return e4[r].retrieve(t, e);
};
let Boe = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.scheme = e;
  }
};
const Foe = /* @__PURE__ */ new Set([200, 203]), zoe = async (t) => {
  const e = await fetch(t, { headers: { Accept: Toe() } });
  if (e.status >= 400)
    throw new H7(e, `Failed to retrieve '${t}'`);
  if (!Foe.has(e.status))
    throw new H7(e, "Unsupported HTTP response status code");
  return e;
}, hD = { retrieve: zoe };
let H7 = class extends Error {
  constructor(e, r = void 0) {
    super(`${e.status} ${e.statusText}${r ? ` -- ${r}` : ""}`), this.name = this.constructor.name, this.response = e;
  }
};
var pD = Uoe;
function Uoe(t, e) {
  return function r() {
    e == null && (e = t.length);
    var n = [].slice.call(arguments);
    return n.length >= e ? t.apply(this, n) : function() {
      return r.apply(this, n.concat([].slice.call(arguments)));
    };
  };
}
const Voe = () => {
  var t, e;
  return ((e = (t = globalThis.document) == null ? void 0 : t.location) == null ? void 0 : e.toString()) ?? "";
}, Pv = async (t, e = { _cache: {} }) => {
  var r, n, i;
  const s = ((r = e.document) == null ? void 0 : r.baseUri) ?? Voe();
  t = P0(t, s);
  const o = Ku(t), { fragment: a } = V5(t), l = e._cache[o] ?? ((i = (n = e.document) == null ? void 0 : n.embedded) == null ? void 0 : i[o]);
  if (l)
    e.document = l, e.uri = t, e.cursor = e.document.anchorLocation(a);
  else {
    try {
      const c = await joe(t, s);
      e.document = await Ioe(c), e.uri = c.url + (a === void 0 ? "" : `#${a}`), e.cursor = e.document.anchorLocation(a);
    } catch (c) {
      const p = e.uri ? ` Referenced from '${e.uri}'.` : "";
      throw new Goe(`Unable to load resource '${t}'.${p}`, c);
    }
    e._cache[o] = e.document;
  }
  return e._value = voe(e.cursor, e.document.root), dD(e);
}, dD = (t) => cD(It(t)) === "reference" ? Pv(It(t).href, t) : t, It = (t) => t._value, Ma = (t) => cD(t._value), fD = (t, e) => t in e._value, gD = (t) => t._value.length, qs = pD((t, e) => dD({
  ...e,
  cursor: fh(`${t}`, e.cursor),
  _value: e._value[t]
})), Ic = async function* (t) {
  for (let e = 0; e < It(t).length; e++)
    yield qs(e, t);
}, t4 = function* (t) {
  for (const e in It(t))
    yield e;
}, Hoe = async function* (t) {
  for (const e in It(t))
    yield qs(e, t);
}, gh = async function* (t) {
  for (const e in It(t))
    yield [e, await qs(e, t)];
};
let Goe = class extends Error {
  constructor(e, r) {
    super(e, { cause: r }), this.name = this.constructor.name;
  }
};
lD("application/reference+json", Doe);
uD("http", hD);
uD("https", hD);
const Woe = {
  parse: async (t) => {
    const e = Coe.parse(t.headers.get("content-type") ?? ""), r = e.parameters.schema ?? e.parameters.profile;
    return Dy(await t.json(), t.url, r);
  },
  fileMatcher: async (t) => /(\.|\/)schema\.json$/.test(t)
}, Ny = {}, qoe = async (t, e = void 0) => {
  e || (e = { _cache: {} });
  for (const n in Ny)
    n in e._cache || (e._cache[n] = Ny[n]);
  const r = await Pv(t, { ...e });
  if (typeof r.document.dialectId != "string")
    throw Error(`The document at ${r.document.baseUri} is not a schema.`);
  return r;
}, Ka = (t, e, r) => {
  t = structuredClone(t);
  const n = Dy(t, e, r);
  if (n.baseUri in Ny)
    throw Error(`A schema has already been registered for '${n.baseUri}. You can use 'unregisterSchema' to remove the old schema before registering the new one.`);
  if (n.baseUri.startsWith("file:"))
    throw Error(`Registering a schema with a 'file:' URI scheme is not allowed: ${n.baseUri}`);
  Ny[n.baseUri] = n;
}, Dy = (t, e, r, n = {}) => {
  if (typeof t.$schema == "string" && (r = t.$schema, delete t.$schema), !r)
    throw Error("Unable to determine a dialect for the schema. The dialect can be declared in a number of ways, but the recommended way is to use the '$schema' keyword in your schema.");
  r = Ku(r);
  const i = Jr(r, "https://json-schema.org/keyword/draft-04/id"), s = Jr(r, "https://json-schema.org/keyword/id") || i;
  if (!t[s] && !e)
    throw Error(`Unable to determine an identifier for the schema. Use the '${s}' keyword or pass a retrievalUri when loading the schema.`);
  const o = P0(t[s] ?? "", e ?? "");
  e = Ku(o), i && o.length > e.length ? t[s] = "#" + nD(o) : delete t[s];
  const a = Jr(r, "https://json-schema.org/keyword/vocabulary");
  if (tD(t[a]) === "object") {
    const h = t[a]["https://json-schema.org/draft/2019-09/vocab/core"] || t[a]["https://json-schema.org/draft/2020-12/vocab/core"];
    sD(e, t[a], h, !1), delete t[a];
  }
  const l = { "": "" }, c = {}, p = Jr(r, "https://json-schema.org/keyword/draft-2019-09/recursiveAnchor");
  return t[p] === !0 && (c[""] = `${e}#`), delete t[p], n[e] = {
    baseUri: e,
    dialectId: r,
    root: r4(t, e, r, "", n, l, c),
    anchorLocation: (h) => {
      if (h === void 0)
        return "";
      if (h = decodeURI(h), h[0] === "/")
        return h;
      if (h in l)
        return l[h];
      throw Error(`No such anchor '${e}#${encodeURI(h)}'`);
    },
    anchors: l,
    dynamicAnchors: c,
    embedded: n
  }, n[e];
}, r4 = (t, e, r, n, i, s, o) => {
  if (tD(t) === "object") {
    const a = typeof t.$schema == "string" ? Ku(t.$schema) : r, l = Jr(a, "https://json-schema.org/keyword/id");
    if (typeof t[l] == "string") {
      const m = Ku(P0(t[l], e));
      return t[l] = m, i[m] = Dy(t, m, a, i), new Du(m, {});
    }
    const c = Jr(a, "https://json-schema.org/keyword/draft-04/id");
    if (typeof t[c] == "string")
      if (t[c][0] === "#") {
        const m = decodeURIComponent(t[c].slice(1));
        s[m] = n, delete t[c];
      } else {
        const m = Ku(P0(t[c], e));
        return t[c] = m, i[m] = Dy(t, m, a, i), new Du(m, {});
      }
    const p = Jr(r, "https://json-schema.org/keyword/draft-04/ref");
    if (typeof t[p] == "string")
      return new Du(t[p], t);
    const h = Jr(r, "https://json-schema.org/keyword/anchor");
    typeof t[h] == "string" && (s[t[h]] = n, delete t[h]);
    const d = Jr(r, "https://json-schema.org/keyword/dynamicAnchor");
    typeof t[d] == "string" && (o[t[d]] = `${e}#${encodeURI(n)}`, delete t[d]);
    const v = Jr(r, "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor");
    typeof t[v] == "string" && (o[t[v]] = `${e}#${encodeURI(n)}`, s[t[v]] = n, delete t[v]);
    for (const m in t) {
      const b = Jr(r, "https://json-schema.org/keyword/ref");
      m === b && typeof t[m] == "string" ? t[m] = new Du(t[m], t[m]) : t[m] = r4(t[m], e, r, fh(m, n), i, s, o);
    }
  } else if (Array.isArray(t))
    for (let a = 0; a < t.length; a++)
      t[a] = r4(t[a], e, r, fh(a, n), i, s, o);
  return t;
}, qp = (t) => `${t.document.baseUri}#${encodeURI(t.cursor)}`, Od = (
  /** @type API.curry */
  (t) => (...e) => {
    const r = t.length === 1 ? (
      /** @type Extract<typeof fn, (a: any) => any> */
      t(e[0])
    ) : t(e[0], e[1]), n = (
      /** @type I */
      e[t.length]
    );
    return n === void 0 ? r : r(n);
  }
), mD = Od((t) => function* (e) {
  for (const r of e)
    yield t(r);
}), Kn = Od((t) => async function* (e) {
  for await (const r of e)
    yield t(r);
}), yD = Od((t) => function* (e) {
  for (const r of e)
    t(r) && (yield r);
}), Qoe = Od((t) => function* (e) {
  let r = 0;
  for (const n of e)
    r++ >= t && (yield n);
}), Koe = (t) => {
  const e = wD(t).next();
  return e.done ? void 0 : e.value;
}, vD = function* (t, e) {
  for (let r = t; e === void 0; r++)
    yield r;
}, G7 = function* () {
}, H5 = function* (t, e) {
  const r = wD(e);
  for (const n of t)
    yield [n, r.next().value];
}, Yoe = function* (...t) {
  for (const e of t)
    yield* e;
}, bD = (
  /** @type API.reduce */
  Od(
    // eslint-disable-next-line @stylistic/no-extra-parens
    /** @type API.reduce */
    (t, e) => (r) => {
      for (const n of r)
        e = t(
          e,
          /** @type any */
          n
        );
      return e;
    }
  )
), oo = async (t) => {
  const e = [];
  for await (const r of t)
    e.push(r);
  return e;
}, Zoe = (t) => {
  const e = /* @__PURE__ */ new Set();
  for (const r of t)
    e.add(r);
  return e;
}, n4 = async (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  for await (const [r, n] of t)
    e[r] = n;
  return e;
}, Joe = Od((t) => (e) => {
  let r = Koe(e) ?? "";
  for (const n of e)
    r += t + n;
  return r;
}), wD = (t) => {
  if (typeof (t == null ? void 0 : t[Symbol.iterator]) == "function")
    return t[Symbol.iterator]();
  throw TypeError("`iter` is not iterable");
}, yn = (
  /** @type (acc: any, ...fns: ((a: any) => any)[]) => any */
  (t, ...e) => bD((r, n) => n(r), t, e)
), A1 = (t, e = "", r = "", n = void 0) => {
  const i = typeof t;
  switch (i) {
    case "number":
    case "string":
    case "boolean":
      return wf(e, r, t, i, [], n);
    case "object":
      if (t === null)
        return wf(e, r, t, "null", [], n);
      if (Array.isArray(t)) {
        const s = wf(e, r, t, "array", [], n);
        return s.children = t.map((o, a) => A1(o, e, fh(a, r), s)), s;
      } else if (Object.getPrototypeOf(t) === Object.prototype) {
        const s = wf(e, r, t, "object", [], n);
        return s.children = Object.entries(t).map((o) => {
          const a = fh(o[0], r), l = wf(e, a, void 0, "property", [], s);
          return l.children = o.map((c) => A1(c, e, a, l)), l;
        }), s;
      } else if (t instanceof Du)
        return A1(t.toJSON(), e, r, n);
    default: {
      const s = i === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : i;
      throw Error(`Not a JSON compatible type: ${s}`);
    }
  }
}, wf = (t, e, r, n, i, s) => {
  const o = {
    baseUri: t ? Ku(t) : "",
    pointer: e,
    value: r,
    type: n,
    children: i,
    parent: s,
    valid: !0,
    errors: {},
    annotations: {}
  };
  return o.root = (s == null ? void 0 : s.root) ?? o, o;
}, Xoe = (t) => `${t.baseUri}#${encodeURI(t.pointer)}`, kr = (t) => t.value, Gt = (t) => t.type, Qp = (t, e) => t in e.value, Dh = function* (t) {
  t.type === "array" && (yield* t.children);
}, G5 = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      yield e.children[0];
}, eae = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children[1] && (yield e.children[1]);
}, Pc = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children.length === 2 && (yield e.children);
}, Ng = (t) => {
  if (t.type === "array")
    return t.children.length;
}, i4 = function* (t) {
  switch (yield t, Gt(t)) {
    case "object":
      for (const e of eae(t))
        yield* i4(e);
      break;
    case "array":
      for (const e of Dh(t))
        yield* i4(e);
      break;
  }
}, Lp = {};
let tae = 0;
const rae = (t, e) => {
  t in Lp || (Lp[t] = {});
  const r = `pubsub_subscription_${tae++}`;
  return Lp[t][r] = e, r;
}, nae = async (t, e) => {
  const r = [];
  for (const n in Lp)
    if (n === t || t.startsWith(`${n}.`))
      for (const i in Lp[n])
        r.push(Lp[t][i](t, e));
  await Promise.all(r);
};
let xD;
const iae = () => xD, sae = (t) => {
  xD = t;
};
let oae = class extends Error {
  constructor(e) {
    super("Invalid Schema"), this.name = this.constructor.name, this.output = e;
  }
};
const ED = "https://json-schema.org/evaluation/validate", aae = async (t, e) => {
  await nae("validate.metaValidate", t), t.document.baseUri in e.metaData || (e.metaData[t.document.baseUri] = {
    dynamicAnchors: t.document.dynamicAnchors
  });
  const r = qp(t);
  if (!(r in e)) {
    e[r] = !1;
    const n = It(t);
    if (!["object", "boolean"].includes(typeof n))
      throw Error(`No schema found at '${r}'`);
    e[r] = typeof n == "boolean" ? n : await yn(
      gh(t),
      Kn(async ([i, s]) => {
        const o = Aoe(i, t.document.dialectId), a = await o.compile(s, e, t);
        return [o.id, fh(i, qp(t)), a];
      }),
      oo
    );
  }
  return r;
}, lae = (t, e, r, n, i = !1) => {
  n = { ...r.metaData[rD(t)].dynamicAnchors, ...n };
  let s = !0;
  if (typeof r[t] == "boolean")
    s = r[t];
  else
    for (const [o, a, l] of r[t])
      e.valid = Iv(o).interpret(l, e, r, n, i, t), e.valid || (i || (e.errors[a] = o), s = !1);
  return s || (e.errors[t] = ED), e.valid = s, s;
}, cae = /* @__PURE__ */ new Set(), uae = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedProperties")
      continue;
    const l = Iv(o), c = "collectEvaluatedProperties" in l ? l.collectEvaluatedProperties(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && cae;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, hae = /* @__PURE__ */ new Set(), pae = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedItems")
      continue;
    const l = Iv(o), c = "collectEvaluatedItems" in l ? l.collectEvaluatedItems(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && hae;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, He = { id: ED, compile: aae, interpret: lae, collectEvaluatedProperties: uae, collectEvaluatedItems: pae }, $y = {}, dae = (t, e) => {
  if (e in $y)
    return $y[e](t);
  throw Error(`The '${e}' error format is not supported`);
};
$y.FLAG = (t) => ({ valid: t.valid });
$y.BASIC = (t) => {
  const e = {
    valid: t.valid
  };
  if (!t.valid) {
    e.errors = [];
    for (const r of i4(t))
      for (const [n, i] of Object.entries(r.errors).reverse())
        i !== "https://json-schema.org/evaluation/validate" && !r.valid && e.errors.unshift({
          keyword: i,
          absoluteKeywordLocation: n,
          instanceLocation: Xoe(r),
          valid: r.valid
        });
  }
  return e;
};
const SD = "FLAG";
sae(SD);
const fae = async (t) => {
  const e = { metaData: {} }, r = await He.compile(t, e);
  return { ast: e, schemaUri: r };
}, gae = pD(({ ast: t, schemaUri: e }, r, n = SD) => (He.interpret(e, r, t, {}), dae(r, n))), Pw = {};
rae("validate.metaValidate", async (t, e) => {
  if (!e.document.validated) {
    if (e.document.validated = !0, !(e.document.dialectId in Pw)) {
      const i = await qoe(e.document.dialectId, e), s = await fae(i);
      Pw[e.document.dialectId] = gae(s);
    }
    const r = A1(e.document.root, e.document.baseUri), n = Pw[e.document.dialectId](r, iae());
    if (!n.valid)
      throw new oae(n);
  }
});
const mae = "https://json-schema.org/keyword/additionalProperties", yae = async (t, e, r) => {
  const n = Jr(t.document.dialectId, "https://json-schema.org/keyword/properties"), i = await qs(n, r), s = Ma(i) === "object" ? mD((p) => "^" + vae(p) + "$", t4(i)) : G7(), o = Jr(t.document.dialectId, "https://json-schema.org/keyword/patternProperties"), a = await qs(o, r), l = Ma(a) === "object" ? t4(a) : G7(), c = yn(
    Yoe(s, l),
    Joe("|")
  ) || "(?!)";
  return [new RegExp(c, "u"), await He.compile(t, e)];
}, vae = (t) => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), bae = ([t, e], r, n, i, s) => {
  if (Gt(r) !== "object")
    return !0;
  let o = !0;
  for (const [a, l] of Pc(r)) {
    const c = kr(a);
    !t.test(c) && !He.interpret(e, l, n, i, s) && (o = !1);
  }
  return o;
}, wae = ([t, e], r, n, i) => {
  if (Gt(r) !== "object")
    return !0;
  const s = /* @__PURE__ */ new Set();
  for (const [o, a] of Pc(r)) {
    const l = kr(o);
    if (!t.test(l)) {
      if (!He.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, xae = { id: mae, compile: yae, interpret: bae, collectEvaluatedProperties: wae }, Eae = "https://json-schema.org/keyword/allOf", Sae = (t, e) => yn(
  Ic(t),
  Kn((r) => He.compile(r, e)),
  oo
), Aae = (t, e, r, n, i) => {
  let s = !0;
  for (const o of t)
    He.interpret(o, e, r, n, i) || (s = !1);
  return s;
}, kae = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = He.collectEvaluatedProperties(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, _ae = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = He.collectEvaluatedItems(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, Cae = { id: Eae, compile: Sae, interpret: Aae, collectEvaluatedProperties: kae, collectEvaluatedItems: _ae }, Iae = { id: "https://json-schema.org/keyword/anchor" }, Pae = "https://json-schema.org/keyword/anyOf", Rae = (t, e) => yn(
  Ic(t),
  Kn((r) => He.compile(r, e)),
  oo
), Oae = (t, e, r, n, i) => t.filter((s) => He.interpret(s, e, r, n, i)).length > 0, Tae = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = He.collectEvaluatedProperties(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, Lae = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = He.collectEvaluatedItems(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, Mae = { id: Pae, compile: Rae, interpret: Oae, collectEvaluatedProperties: Tae, collectEvaluatedItems: Lae }, Nae = "https://json-schema.org/keyword/conditional", Dae = (t, e) => yn(
  Ic(t),
  AD,
  Kn((r) => He.compile(r, e)),
  oo
), $ae = (t, e, r, n, i) => {
  for (let s = 0; s < t.length; s += 2) {
    const o = He.interpret(t[s], e, r, n, i);
    if (s + 1 === t.length)
      return o;
    if (o)
      return He.interpret(t[s + 1], e, r, n, i);
  }
  return !0;
}, jae = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = He.collectEvaluatedProperties(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return He.collectEvaluatedProperties(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, Bae = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = He.collectEvaluatedItems(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return He.collectEvaluatedItems(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, AD = async function* (t, e = 1) {
  for await (const r of t)
    e > 0 && Ma(r) === "array" ? yield* AD(Ic(r), e - 1) : yield r;
}, Fae = { id: Nae, compile: Dae, interpret: $ae, collectEvaluatedProperties: jae, collectEvaluatedItems: Bae };
var W7, q7;
function zae() {
  return q7 || (q7 = 1, W7 = {
    space: "",
    cycles: !1,
    replacer: (t, e) => e,
    stringify: JSON.stringify
  }), W7;
}
var Q7, K7;
function xu() {
  return K7 || (K7 = 1, Q7 = {
    isArray: Array.isArray,
    assign: Object.assign,
    isObject: (t) => typeof t == "object",
    isFunction: (t) => typeof t == "function",
    isBoolean: (t) => typeof t == "boolean",
    isRegex: (t) => t instanceof RegExp,
    keys: Object.keys
  }), Q7;
}
var Rw, Y7;
function Uae() {
  if (Y7) return Rw;
  Y7 = 1;
  const t = zae(), e = xu().isFunction, r = xu().isBoolean, n = xu().isObject, i = xu().isArray, s = xu().isRegex, o = xu().assign, a = xu().keys;
  function l(p) {
    return p == null ? p : s(p) ? p.toString() : p.toJSON ? p.toJSON() : p;
  }
  function c(p, h) {
    h = h || o({}, t), e(h) && (h = { compare: h });
    const d = h.space || t.space, v = r(h.cycles) ? h.cycles : t.cycles, m = h.replacer || t.replacer, b = h.stringify || t.stringify, f = h.compare && /* @__PURE__ */ function(A) {
      return function(x) {
        return function(g, w) {
          const _ = { key: g, value: x[g] }, S = { key: w, value: x[w] };
          return A(_, S);
        };
      };
    }(h.compare);
    v || b(p);
    const E = [];
    return function A(x, g, w, _) {
      const S = d ? `
` + new Array(_ + 1).join(d) : "", R = d ? ": " : ":";
      if (w = l(w), w = m.call(x, g, w), w !== void 0) {
        if (!n(w) || w === null) return b(w);
        if (i(w)) {
          const L = [];
          for (let F = 0; F < w.length; F++) {
            const z = A(w, F, w[F], _ + 1) || b(null);
            L.push(S + d + z);
          }
          return "[" + L.join(",") + S + "]";
        } else {
          if (v) {
            if (E.indexOf(w) !== -1)
              return b("[Circular]");
            E.push(w);
          }
          const L = a(w).sort(f && f(w)), F = [];
          for (let z = 0; z < L.length; z++) {
            const j = L[z], W = A(w, j, w[j], _ + 1);
            if (!W) continue;
            const te = b(j) + R + W;
            F.push(S + d + te);
          }
          return E.splice(E.indexOf(w), 1), "{" + F.join(",") + S + "}";
        }
      }
    }({ "": p }, "", p, 0);
  }
  return Rw = c, Rw;
}
var Vae = Uae();
const Dg = /* @__PURE__ */ oD(Vae), Hae = "https://json-schema.org/keyword/const", Gae = (t) => Dg(It(t)), Wae = (t, e) => Dg(kr(e)) === t, qae = { id: Hae, compile: Gae, interpret: Wae }, Qae = "https://json-schema.org/keyword/contains", Kae = async (t, e, r) => {
  const n = await He.compile(t, e), i = Jr(t.document.dialectId, "https://json-schema.org/keyword/minContains"), s = await qs(i, r), o = Ma(s) === "number" ? It(s) : 1, a = Jr(t.document.dialectId, "https://json-schema.org/keyword/maxContains"), l = await qs(a, r), c = Ma(l) === "number" ? It(l) : Number.MAX_SAFE_INTEGER;
  return { contains: n, minContains: o, maxContains: c };
}, kD = ({ contains: t, minContains: e, maxContains: r }, n, i, s, o) => {
  const a = Gt(n) !== "array" || yn(
    Dh(n),
    yD((l) => He.interpret(t, l, i, s, o)),
    bD((l) => l + 1, 0)
  );
  return a >= e && a <= r;
}, Yae = (t, e, r, n) => kD(t, e, r, n, !0) && Gt(e) === "array" && yn(
  H5(Dh(e), vD(0)),
  yD(([i]) => He.interpret(t.contains, i, r, n, !0)),
  mD(([, i]) => i),
  Zoe
), Zae = { id: Qae, compile: Kae, interpret: kD, collectEvaluatedItems: Yae }, Jae = "https://json-schema.org/keyword/comment", Xae = () => {
}, ele = () => !0, tle = { id: Jae, compile: Xae, interpret: ele }, _s = (t, e, r, n) => {
  e in t.annotations || (t.annotations[e] = {}), t.annotations[e][r] = n;
}, _D = "https://json-schema.org/keyword/contentEncoding", rle = (t) => It(t), nle = (t, e, r, n, i, s) => (_s(e, _D, s, t), !0), ile = { id: _D, compile: rle, interpret: nle }, CD = "https://json-schema.org/keyword/contentMediaType", sle = (t) => It(t), ole = (t, e, r, n, i, s) => (_s(e, CD, s, t), !0), ale = { id: CD, compile: sle, interpret: ole }, ID = "https://json-schema.org/keyword/contentSchema", lle = (t) => qp(t), cle = (t, e, r, n, i, s) => (_s(e, ID, s, t), !0), ule = { id: ID, compile: lle, interpret: cle }, PD = "https://json-schema.org/keyword/default", hle = (t) => It(t), ple = (t, e, r, n, i, s) => (_s(e, PD, s, t), !0), dle = { id: PD, compile: hle, interpret: ple }, fle = "https://json-schema.org/keyword/definitions", gle = (t, e) => yn(
  Hoe(t),
  Kn((r) => He.compile(r, e)),
  oo
), mle = () => !0, yle = { id: fle, compile: gle, interpret: mle }, vle = "https://json-schema.org/keyword/dependentRequired", ble = (t) => yn(
  gh(t),
  Kn(([e, r]) => [e, It(r)]),
  oo
), wle = (t, e) => {
  if (Gt(e) !== "object")
    return !0;
  let r = !0;
  for (const [n, i] of t)
    Qp(n, e) && !i.every((s) => Qp(s, e)) && (r = !1);
  return r;
}, xle = { id: vle, compile: ble, interpret: wle }, Ele = "https://json-schema.org/keyword/dependentSchemas", Sle = (t, e) => yn(
  gh(t),
  Kn(async ([r, n]) => [r, await He.compile(n, e)]),
  oo
), Ale = (t, e, r, n, i) => {
  if (Gt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    Qp(o, e) && !He.interpret(a, e, r, n, i) && (s = !1);
  return s;
}, kle = (t, e, r, n) => {
  if (Gt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    if (Qp(s, e)) {
      const a = He.collectEvaluatedProperties(o, e, r, n);
      if (a === !1)
        return !1;
      a.forEach(Set.prototype.add.bind(i));
    }
  return i;
}, _le = { id: Ele, compile: Sle, interpret: Ale, collectEvaluatedProperties: kle }, RD = "https://json-schema.org/keyword/deprecated", Cle = (t) => It(t), Ile = (t, e, r, n, i, s) => (_s(e, RD, s, t), !0), Ple = { id: RD, compile: Cle, interpret: Ile }, OD = "https://json-schema.org/keyword/description", Rle = (t) => It(t), Ole = (t, e, r, n, i, s) => (_s(e, OD, s, t), !0), Tle = { id: OD, compile: Rle, interpret: Ole }, Lle = { id: "https://json-schema.org/keyword/dynamicAnchor" }, Mle = "https://json-schema.org/keyword/dynamicRef", Nle = async (t, e) => {
  const r = It(t), n = await Pv(t.document.baseUri, t);
  return await He.compile(n, e), r;
}, W5 = (t, e, r, n, i, s) => {
  if (!(e in i))
    throw Error(`No dynamic anchor found for "${e}"`);
  return t(i[e], r, n, i, s);
}, Dle = (...t) => W5(He.interpret, ...t), $le = (...t) => W5(He.collectEvaluatedProperties, ...t), jle = (...t) => W5(He.collectEvaluatedItems, ...t), Ble = { id: Mle, compile: Nle, interpret: Dle, collectEvaluatedProperties: $le, collectEvaluatedItems: jle }, Fle = "https://json-schema.org/keyword/else", zle = async (t, e, r) => {
  const n = Jr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (fD(n, r)) {
    const i = await qs(n, r);
    return [await He.compile(i, e), await He.compile(t, e)];
  } else
    return [];
}, Ule = ([t, e], r, n, i, s) => t === void 0 || He.interpret(t, r, n, i, !0) || He.interpret(e, r, n, i, s), Vle = ([t, e], r, n, i) => t === void 0 || He.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : He.collectEvaluatedProperties(e, r, n, i), Hle = ([t, e], r, n, i) => t === void 0 || He.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : He.collectEvaluatedItems(e, r, n, i), Gle = { id: Fle, compile: zle, interpret: Ule, collectEvaluatedProperties: Vle, collectEvaluatedItems: Hle }, Wle = "https://json-schema.org/keyword/enum", qle = (t) => yn(
  Ic(t),
  Kn(It),
  Kn(Dg),
  oo
), Qle = (t, e) => {
  const r = Dg(kr(e));
  return t.some((n) => r === n);
}, Kle = { id: Wle, compile: qle, interpret: Qle }, TD = "https://json-schema.org/keyword/examples", Yle = (t) => It(t), Zle = (t, e, r, n, i, s) => (_s(e, TD, s, t), !0), Jle = { id: TD, compile: Yle, interpret: Zle }, Xle = "https://json-schema.org/keyword/exclusiveMaximum", ece = (t) => It(t), tce = (t, e) => Gt(e) !== "number" || kr(e) < t, rce = { id: Xle, compile: ece, interpret: tce }, nce = "https://json-schema.org/keyword/exclusiveMinimum", ice = (t) => It(t), sce = (t, e) => Gt(e) !== "number" || kr(e) > t, oce = { id: nce, compile: ice, interpret: sce }, LD = "https://json-schema.org/keyword/format", ace = (t) => It(t), lce = (t, e, r, n, i, s) => (_s(e, LD, s, t), !0), cce = { id: LD, compile: ace, interpret: lce }, uce = { id: "https://json-schema.org/keyword/id" }, hce = "https://json-schema.org/keyword/if", pce = (t, e) => He.compile(t, e), dce = (t, e, r, n) => (He.interpret(t, e, r, n, !0), !0), fce = (t, e, r, n) => He.collectEvaluatedProperties(t, e, r, n) || [], gce = (t, e, r, n) => He.collectEvaluatedItems(t, e, r, n) || /* @__PURE__ */ new Set(), mce = { id: hce, compile: pce, interpret: dce, collectEvaluatedProperties: fce, collectEvaluatedItems: gce }, yce = () => {
  const t = fs(!1), e = fs(!0);
  return Cn(t, e), { start: t, end: e };
}, vce = (t) => {
  const e = fs(!1), r = fs(!0);
  return Ace(e, r, t), { start: e, end: r };
}, bce = (t, e) => t === void 0 ? e : (Cn(t.end, e.start), t.end.isEnd = !1, { start: t.start, end: e.end }), wce = (t, e) => {
  const r = fs(!1);
  Cn(r, t.start), Cn(r, e.start);
  const n = fs(!0);
  return Cn(t.end, n), t.end.isEnd = !1, Cn(e.end, n), e.end.isEnd = !1, { start: r, end: n };
}, xce = (t) => {
  const e = fs(!1), r = fs(!0);
  return Cn(e, r), Cn(e, t.start), Cn(t.end, r), Cn(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, Ece = (t) => {
  const e = fs(!1), r = fs(!0);
  return Cn(e, r), Cn(e, t.start), Cn(t.end, r), t.end.isEnd = !1, { start: e, end: r };
}, Sce = (t) => {
  const e = fs(!1), r = fs(!0);
  return Cn(e, t.start), Cn(t.end, r), Cn(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, Cn = (t, e) => {
  t.epsilonTransitions.push(e);
}, Ace = (t, e, r) => {
  t.transition[r] = e;
}, fs = (t) => ({
  isEnd: t,
  transition: {},
  epsilonTransitions: []
}), kce = "https://json-schema.org/keyword/itemPattern", MD = async (t, e) => {
  const r = [[]];
  let n = r[0];
  for await (const i of Ic(t))
    if (Ma(i) === "string") {
      const s = It(i);
      if (s === "*")
        n.push(xce(n.pop()));
      else if (s === "?")
        n.push(Ece(n.pop()));
      else if (s === "+")
        n.push(Sce(n.pop()));
      else if (s === "|")
        n = [], r.push(n);
      else
        throw Error(`Unsupported pattern syntax: ${s}`);
    } else {
      const s = Ma(i) === "array" ? MD(i, e) : vce(await He.compile(i, e));
      n.push(await s);
    }
  return gD(t) === 0 ? yce() : r.map((i) => i.reduce(bce)).reduce(wce);
}, q5 = (t) => (e, r, n, i, s) => {
  if (Gt(r) !== "array")
    return !0;
  let o = [];
  s4(e.start, o, []);
  for (const a of Dh(r)) {
    const l = [];
    for (const c of o) {
      const p = _ce(t, c.transition, a, n, i, s);
      p && s4(p, l, []);
    }
    o = l;
  }
  return !!o.find((a) => a.isEnd);
}, s4 = (t, e, r) => {
  if (t.epsilonTransitions.length)
    for (const n of t.epsilonTransitions)
      r.find((i) => i === n) || (r.push(n), s4(n, e, r));
  else
    e.push(t);
}, _ce = (t, e, r, n, i, s) => {
  for (const o in e)
    if (t(o, r, n, i, s))
      return e[o];
}, Cce = q5(He.interpret), Ice = q5(He.collectEvaluatedProperties), Pce = q5(He.collectEvaluatedItems), Rce = { id: kce, compile: MD, interpret: Cce, collectEvalatedProperties: Ice, collectEvalatedItems: Pce }, Oce = "https://json-schema.org/keyword/items", Tce = async (t, e, r) => {
  const n = Jr(t.document.dialectId, "https://json-schema.org/keyword/prefixItems"), i = await qs(n, r);
  return [Ma(i) === "array" ? gD(i) : 0, await He.compile(t, e)];
}, ND = ([t, e], r, n, i, s) => {
  if (Gt(r) !== "array")
    return !0;
  let o = !0;
  for (const a of Qoe(t, Dh(r)))
    He.interpret(e, a, n, i, s) || (o = !1);
  return o;
}, Lce = (t, e, r, n) => {
  if (!ND(t, e, r, n, !0))
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (let s = t[0]; s < Ng(e); s++)
    i.add(s);
  return i;
}, Mce = { id: Oce, compile: Tce, interpret: ND, collectEvaluatedItems: Lce }, Nce = "https://json-schema.org/keyword/maxContains", Dce = (t) => It(t), $ce = () => !0, jce = { id: Nce, compile: Dce, interpret: $ce }, Bce = "https://json-schema.org/keyword/maxItems", Fce = (t) => It(t), zce = (t, e) => Gt(e) !== "array" || Ng(e) <= t, Uce = { id: Bce, compile: Fce, interpret: zce }, Vce = "https://json-schema.org/keyword/maxLength", Hce = (t) => It(t), Gce = (t, e) => Gt(e) !== "string" || [...kr(e)].length <= t, Wce = { id: Vce, compile: Hce, interpret: Gce }, qce = "https://json-schema.org/keyword/maxProperties", Qce = (t) => It(t), Kce = (t, e) => Gt(e) !== "object" || [...G5(e)].length <= t, Yce = { id: qce, compile: Qce, interpret: Kce }, Zce = "https://json-schema.org/keyword/maximum", Jce = (t) => It(t), Xce = (t, e) => Gt(e) !== "number" || kr(e) <= t, eue = { id: Zce, compile: Jce, interpret: Xce }, tue = "https://json-schema.org/keyword/minContains", rue = (t) => It(t), nue = () => !0, iue = { id: tue, compile: rue, interpret: nue }, sue = "https://json-schema.org/keyword/minItems", oue = (t) => It(t), aue = (t, e) => Gt(e) !== "array" || Ng(e) >= t, lue = { id: sue, compile: oue, interpret: aue }, cue = "https://json-schema.org/keyword/minLength", uue = (t) => It(t), hue = (t, e) => Gt(e) !== "string" || [...kr(e)].length >= t, pue = { id: cue, compile: uue, interpret: hue }, due = "https://json-schema.org/keyword/minProperties", fue = (t) => It(t), gue = (t, e) => Gt(e) !== "object" || [...G5(e)].length >= t, mue = { id: due, compile: fue, interpret: gue }, yue = "https://json-schema.org/keyword/minimum", vue = (t) => It(t), bue = (t, e) => Gt(e) !== "number" || kr(e) >= t, wue = { id: yue, compile: vue, interpret: bue }, xue = "https://json-schema.org/keyword/multipleOf", Eue = (t) => It(t), Sue = (t, e) => {
  if (Gt(e) !== "number")
    return !0;
  const r = kr(e) % t;
  return Z7(0, r) || Z7(t, r);
}, Z7 = (t, e) => Math.abs(t - e) < 11920929e-14, Aue = { id: xue, compile: Eue, interpret: Sue }, kue = "https://json-schema.org/keyword/not", _ue = (...t) => He.compile(...t), Cue = (...t) => !He.interpret(...t), Iue = { id: kue, compile: _ue, interpret: Cue }, Pue = "https://json-schema.org/keyword/oneOf", Rue = (t, e) => yn(
  Ic(t),
  Kn((r) => He.compile(r, e)),
  oo
), Oue = (t, e, r, n, i) => {
  let s = 0;
  for (const o of t)
    He.interpret(o, e, r, n, i) && s++;
  return s === 1;
}, Tue = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = He.collectEvaluatedProperties(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, Lue = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = He.collectEvaluatedItems(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, Mue = { id: Pue, compile: Rue, interpret: Oue, collectEvaluatedProperties: Tue, collectEvaluatedItems: Lue }, Nue = "https://json-schema.org/keyword/pattern", Due = (t) => new RegExp(It(t), "u"), $ue = (t, e) => Gt(e) !== "string" || t.test(kr(e)), jue = { id: Nue, compile: Due, interpret: $ue }, Bue = "https://json-schema.org/keyword/patternProperties", Fue = (t, e) => yn(
  gh(t),
  Kn(async ([r, n]) => [
    new RegExp(r, "u"),
    await He.compile(n, e)
  ]),
  oo
), zue = (t, e, r, n, i) => {
  if (Gt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    for (const [l, c] of Pc(e)) {
      const p = kr(l);
      o.test(p) && !He.interpret(a, c, r, n, i) && (s = !1);
    }
  return s;
}, Uue = (t, e, r, n) => {
  if (Gt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    for (const [a, l] of Pc(e)) {
      const c = kr(a);
      if (s.test(c)) {
        if (!He.interpret(o, l, r, n, !0))
          return !1;
        i.add(c);
      }
    }
  return i;
}, Vue = { id: Bue, compile: Fue, interpret: zue, collectEvaluatedProperties: Uue }, Hue = "https://json-schema.org/keyword/prefixItems", Gue = (t, e) => yn(
  Ic(t),
  Kn((r) => He.compile(r, e)),
  oo
), DD = (t, e, r, n, i) => {
  if (Gt(e) !== "array")
    return !0;
  let s = !0, o = 0;
  const a = Ng(e);
  for (const [l, c] of H5(t, Dh(e))) {
    if (o >= a)
      break;
    He.interpret(l, c, r, n, i) || (s = !1), o++;
  }
  return s;
}, Wue = (t, e, r, n) => DD(t, e, r, n, !0) && new Set(t.map((i, s) => s)), que = { id: Hue, compile: Gue, interpret: DD, collectEvaluatedItems: Wue }, Que = "https://json-schema.org/keyword/properties", Kue = (t, e) => yn(
  gh(t),
  Kn(async ([r, n]) => [r, await He.compile(n, e)]),
  n4
), Yue = (t, e, r, n, i) => {
  if (Gt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of Pc(e)) {
    const l = kr(o);
    l in t && !He.interpret(t[l], a, r, n, i) && (s = !1);
  }
  return s;
}, Zue = (t, e, r, n) => {
  if (Gt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of Pc(e)) {
    const a = kr(s);
    if (a in t) {
      if (!He.interpret(t[a], o, r, n, !0))
        return !1;
      i.add(a);
    }
  }
  return i;
}, Jue = { id: Que, compile: Kue, interpret: Yue, collectEvaluatedProperties: Zue }, Xue = "https://json-schema.org/keyword/propertyDependencies", ehe = (t, e) => yn(
  gh(t),
  Kn(async ([r, n]) => [r, await yn(
    gh(n),
    Kn(async ([i, s]) => [i, await He.compile(s, e)]),
    n4
  )]),
  n4
), the = (t, e, r, n, i) => {
  if (Gt(e) !== "object")
    return !0;
  let s = !0;
  const o = kr(e);
  for (const [a, l] of Object.entries(t)) {
    const c = o[a];
    Qp(a, e) && c in l && !He.interpret(l[c], e, r, n, i) && (s = !1);
  }
  return s;
}, rhe = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s in t) {
    const o = kr(e)[s], a = t[s];
    if (Qp(s, e) && o in a) {
      const l = He.collectEvaluatedProperties(a[o], e, r, n);
      if (!l)
        return !1;
      l.forEach(i.add, i);
    }
  }
  return i;
}, nhe = { id: Xue, compile: ehe, interpret: the, collectEvaluatedProperties: rhe }, ihe = "https://json-schema.org/keyword/propertyNames", she = (t, e) => He.compile(t, e), ohe = (t, e, r, n) => {
  if (Gt(e) !== "object")
    return !0;
  let i = !0;
  for (const s of G5(e))
    He.interpret(t, s, r, n, !0) || (i = !1);
  return i;
}, ahe = { id: ihe, compile: she, interpret: ohe }, $D = "https://json-schema.org/keyword/readOnly", lhe = (t) => It(t), che = (t, e, r, n, i, s) => (_s(e, $D, s, t), !0), uhe = { id: $D, compile: lhe, interpret: che }, hhe = "https://json-schema.org/keyword/ref", phe = (...t) => He.compile(...t), dhe = (...t) => He.interpret(...t), fhe = (...t) => He.collectEvaluatedProperties(...t), ghe = (...t) => He.collectEvaluatedItems(...t), mhe = { id: hhe, compile: phe, interpret: dhe, collectEvaluatedProperties: fhe, collectEvaluatedItems: ghe }, yhe = "https://json-schema.org/keyword/requireAllExcept", vhe = async (t, e, r) => {
  const n = await It(t), i = Jr(t.document.dialectId, "https://json-schema.org/keyword/properties"), s = await qs(i, r), o = Ma(s) === "object" ? t4(s) : [], a = new Set(o);
  return n.forEach((l) => o.remove(l)), [...a];
}, bhe = (t, e) => Gt(e) !== "object" || t.every((r) => Object.hasOwn(kr(e), r)), whe = { id: yhe, compile: vhe, interpret: bhe }, xhe = "https://json-schema.org/keyword/required", Ehe = (t) => It(t), She = (t, e) => Gt(e) !== "object" || t.every((r) => Object.hasOwn(kr(e), r)), Ahe = { id: xhe, compile: Ehe, interpret: She }, jD = "https://json-schema.org/keyword/title", khe = (t) => It(t), _he = (t, e, r, n, i, s) => (_s(e, jD, s, t), !0), Che = { id: jD, compile: khe, interpret: _he }, Ihe = "https://json-schema.org/keyword/then", Phe = async (t, e, r) => {
  const n = Jr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (fD(n, r)) {
    const i = await qs(n, r);
    return [await He.compile(i, e), await He.compile(t, e)];
  } else
    return [];
}, Rhe = ([t, e], r, n, i, s) => t === void 0 || !He.interpret(t, r, n, i, !0) || He.interpret(e, r, n, i, s), Ohe = ([t, e], r, n, i) => t === void 0 || !He.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : He.collectEvaluatedProperties(e, r, n, i), The = ([t, e], r, n, i) => t === void 0 || !He.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : He.collectEvaluatedItems(e, r, n, i), Lhe = { id: Ihe, compile: Phe, interpret: Rhe, collectEvaluatedProperties: Ohe, collectEvaluatedItems: The }, Mhe = "https://json-schema.org/keyword/type", Nhe = (t) => It(t), Dhe = (t, e) => typeof t == "string" ? J7(e)(t) : t.some(J7(e)), J7 = (t) => (e) => e === "integer" ? Gt(t) === "number" && Number.isInteger(kr(t)) : Gt(t) === e, $he = { id: Mhe, compile: Nhe, interpret: Dhe }, jhe = "https://json-schema.org/keyword/unevaluatedItems", Bhe = async (t, e, r) => [qp(r), await He.compile(t, e)], Fhe = ([t, e], r, n, i, s) => {
  if (Gt(r) !== "array")
    return !0;
  const o = He.collectEvaluatedItems(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of H5(Dh(r), vD(0)))
    !o.has(c) && !He.interpret(e, l, n, i, s) && (a = !1);
  return a;
}, zhe = (t, e, r, n) => {
  const i = He.collectEvaluatedItems(t[0], e, r, n, !0);
  if (!i)
    return !1;
  const s = /* @__PURE__ */ new Set();
  for (let o = 0; o < Ng(e); o++)
    i.has(o) || s.add(o);
  return s;
}, Uhe = { id: jhe, compile: Bhe, interpret: Fhe, collectEvaluatedItems: zhe }, Vhe = "https://json-schema.org/keyword/unevaluatedProperties", Hhe = async (t, e, r) => [qp(r), await He.compile(t, e)], Ghe = ([t, e], r, n, i, s) => {
  if (Gt(r) !== "object")
    return !0;
  const o = He.collectEvaluatedProperties(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of Pc(r)) {
    const p = kr(l);
    !o.has(p) && !He.interpret(e, c, n, i, s) && (a = !1);
  }
  return a;
}, Whe = ([t, e], r, n, i) => {
  if (Gt(r) !== "object")
    return !0;
  const s = He.collectEvaluatedProperties(t, r, n, i, !0);
  if (!s)
    return !1;
  for (const [o, a] of Pc(r)) {
    const l = kr(o);
    if (!s.has(l)) {
      if (!He.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, qhe = { id: Vhe, compile: Hhe, interpret: Ghe, collectEvaluatedProperties: Whe }, Qhe = "https://json-schema.org/keyword/uniqueItems", Khe = (t) => It(t), Yhe = (t, e) => {
  if (Gt(e) !== "array" || t === !1)
    return !0;
  const r = kr(e).map(Dg);
  return new Set(r).size === r.length;
}, Zhe = { id: Qhe, compile: Khe, interpret: Yhe }, BD = "https://json-schema.org/keyword/unknown", Jhe = (t) => [[...Zx(t.cursor)].pop(), It(t)], Xhe = ([t, e], r, n, i, s, o) => {
  const a = `${BD}#${t}`;
  return _s(r, a, o, e), !0;
}, epe = { id: BD, compile: Jhe, interpret: Xhe }, tpe = { id: "https://json-schema.org/keyword/vocabulary" }, FD = "https://json-schema.org/keyword/writeOnly", rpe = (t) => It(t), npe = (t, e, r, n, i, s) => (_s(e, FD, s, t), !0), ipe = { id: FD, compile: rpe, interpret: npe };
lD("application/schema+json", Woe);
lt(xae);
lt(Cae);
lt(Iae);
lt(Mae);
lt(Fae);
lt(qae);
lt(Zae);
lt(tle);
lt(ile);
lt(ale);
lt(ule);
lt(dle);
lt(yle);
lt(xle);
lt(_le);
lt(Ple);
lt(Tle);
lt(Lle);
lt(Ble);
lt(Gle);
lt(Kle);
lt(Jle);
lt(rce);
lt(oce);
lt(cce);
lt(uce);
lt(mce);
lt(Rce);
lt(Mce);
lt(jce);
lt(Uce);
lt(Wce);
lt(Yce);
lt(eue);
lt(iue);
lt(lue);
lt(pue);
lt(mue);
lt(wue);
lt(Aue);
lt(Iue);
lt(Mue);
lt(jue);
lt(Vue);
lt(que);
lt(Jue);
lt(nhe);
lt(ahe);
lt(uhe);
lt(mhe);
lt(whe);
lt(Ahe);
lt(Che);
lt(Lhe);
lt($he);
lt(Uhe);
lt(qhe);
lt(Zhe);
lt(epe);
lt(tpe);
lt(ipe);
const spe = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://json-schema.org/draft/2020-12/schema",
  $vocabulary: {
    "https://json-schema.org/draft/2020-12/vocab/core": !0,
    "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
    "https://json-schema.org/draft/2020-12/vocab/validation": !0,
    "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
    "https://json-schema.org/draft/2020-12/vocab/content": !0
  },
  $dynamicAnchor: "meta",
  title: "Core and Validation specifications meta-schema",
  allOf: [
    { $ref: "meta/core" },
    { $ref: "meta/applicator" },
    { $ref: "meta/unevaluated" },
    { $ref: "meta/validation" },
    { $ref: "meta/meta-data" },
    { $ref: "meta/format-annotation" },
    { $ref: "meta/content" }
  ],
  type: ["object", "boolean"],
  properties: {
    definitions: {
      $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    dependencies: {
      $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
      type: "object",
      additionalProperties: {
        anyOf: [
          { $dynamicRef: "#meta" },
          { $ref: "meta/validation#/$defs/stringArray" }
        ]
      }
    }
  }
}, ope = {
  $id: "https://json-schema.org/draft/2020-12/meta/core",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Core vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    $id: {
      type: "string",
      format: "uri-reference",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $anchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicRef: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicAnchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        type: "string",
        format: "uri"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    }
  }
}, ape = {
  $id: "https://json-schema.org/draft/2020-12/meta/applicator",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    prefixItems: { $ref: "#/$defs/schemaArray" },
    items: { $dynamicRef: "#meta" },
    contains: { $dynamicRef: "#meta" },
    additionalProperties: { $dynamicRef: "#meta" },
    properties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      propertyNames: { format: "regex" },
      default: {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      }
    },
    propertyNames: { $dynamicRef: "#meta" },
    if: { $dynamicRef: "#meta" },
    then: { $dynamicRef: "#meta" },
    else: { $dynamicRef: "#meta" },
    allOf: { $ref: "#/$defs/schemaArray" },
    anyOf: { $ref: "#/$defs/schemaArray" },
    oneOf: { $ref: "#/$defs/schemaArray" },
    not: { $dynamicRef: "#meta" }
  },
  $defs: {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: { $dynamicRef: "#meta" }
    }
  }
}, lpe = {
  $id: "https://json-schema.org/draft/2020-12/meta/validation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Validation vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: { $ref: "#/$defs/nonNegativeInteger" },
    minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: { $ref: "#/$defs/nonNegativeInteger" },
    minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    uniqueItems: {
      type: "boolean",
      default: !1
    },
    maxContains: { $ref: "#/$defs/nonNegativeInteger" },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 1
    },
    maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
    minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    required: { $ref: "#/$defs/stringArray" },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    },
    const: !0,
    enum: {
      type: "array",
      items: !0
    },
    type: {
      anyOf: [
        { $ref: "#/$defs/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/$defs/simpleTypes" },
          minItems: 1,
          uniqueItems: !0
        }
      ]
    }
  },
  $defs: {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 0
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: []
    }
  }
}, cpe = {
  $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Meta-data vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    default: !0,
    deprecated: {
      type: "boolean",
      default: !1
    },
    readOnly: {
      type: "boolean",
      default: !1
    },
    writeOnly: {
      type: "boolean",
      default: !1
    },
    examples: {
      type: "array",
      items: !0
    }
  }
}, upe = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for annotation results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, hpe = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-assertion",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for assertion results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, ppe = {
  $id: "https://json-schema.org/draft/2020-12/meta/content",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Content vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    contentSchema: { $dynamicRef: "#meta" }
  }
}, dpe = {
  $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Unevaluated applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    unevaluatedItems: { $dynamicRef: "#meta" },
    unevaluatedProperties: { $dynamicRef: "#meta" }
  }
}, fpe = { id: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor" }, gpe = "https://json-schema.org/keyword/draft-2020-12/dynamicRef", mpe = async (t, e) => {
  const r = nD(It(t)), n = await Pv(It(t), t);
  return await He.compile(n, e), [n.document.baseUri, r, qp(n)];
}, Q5 = (t, [e, r, n], i, s, o, a) => r in s.metaData[e].dynamicAnchors ? (o = { ...s.metaData[e].dynamicAnchors, ...o }, t(o[r], i, s, o, a)) : t(n, i, s, o, a), ype = (...t) => Q5(He.interpret, ...t), vpe = (...t) => Q5(He.collectEvaluatedProperties, ...t), bpe = (...t) => Q5(He.collectEvaluatedItems, ...t), wpe = { id: gpe, compile: mpe, interpret: ype, collectEvaluatedProperties: vpe, collectEvaluatedItems: bpe };
lt(wpe);
lt(fpe);
Cc("https://json-schema.org/draft/2020-12/vocab/core", {
  $anchor: "https://json-schema.org/keyword/anchor",
  $comment: "https://json-schema.org/keyword/comment",
  $defs: "https://json-schema.org/keyword/definitions",
  $dynamicAnchor: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor",
  $dynamicRef: "https://json-schema.org/keyword/draft-2020-12/dynamicRef",
  $id: "https://json-schema.org/keyword/id",
  $ref: "https://json-schema.org/keyword/ref",
  $vocabulary: "https://json-schema.org/keyword/vocabulary"
});
Cc("https://json-schema.org/draft/2020-12/vocab/applicator", {
  additionalProperties: "https://json-schema.org/keyword/additionalProperties",
  allOf: "https://json-schema.org/keyword/allOf",
  anyOf: "https://json-schema.org/keyword/anyOf",
  contains: "https://json-schema.org/keyword/contains",
  dependentSchemas: "https://json-schema.org/keyword/dependentSchemas",
  if: "https://json-schema.org/keyword/if",
  then: "https://json-schema.org/keyword/then",
  else: "https://json-schema.org/keyword/else",
  items: "https://json-schema.org/keyword/items",
  not: "https://json-schema.org/keyword/not",
  oneOf: "https://json-schema.org/keyword/oneOf",
  patternProperties: "https://json-schema.org/keyword/patternProperties",
  prefixItems: "https://json-schema.org/keyword/prefixItems",
  properties: "https://json-schema.org/keyword/properties",
  propertyNames: "https://json-schema.org/keyword/propertyNames"
});
Cc("https://json-schema.org/draft/2020-12/vocab/validation", {
  const: "https://json-schema.org/keyword/const",
  dependentRequired: "https://json-schema.org/keyword/dependentRequired",
  enum: "https://json-schema.org/keyword/enum",
  exclusiveMaximum: "https://json-schema.org/keyword/exclusiveMaximum",
  exclusiveMinimum: "https://json-schema.org/keyword/exclusiveMinimum",
  maxContains: "https://json-schema.org/keyword/maxContains",
  maxItems: "https://json-schema.org/keyword/maxItems",
  maxLength: "https://json-schema.org/keyword/maxLength",
  maxProperties: "https://json-schema.org/keyword/maxProperties",
  maximum: "https://json-schema.org/keyword/maximum",
  minContains: "https://json-schema.org/keyword/minContains",
  minItems: "https://json-schema.org/keyword/minItems",
  minLength: "https://json-schema.org/keyword/minLength",
  minProperties: "https://json-schema.org/keyword/minProperties",
  minimum: "https://json-schema.org/keyword/minimum",
  multipleOf: "https://json-schema.org/keyword/multipleOf",
  pattern: "https://json-schema.org/keyword/pattern",
  required: "https://json-schema.org/keyword/required",
  type: "https://json-schema.org/keyword/type",
  uniqueItems: "https://json-schema.org/keyword/uniqueItems"
});
Cc("https://json-schema.org/draft/2020-12/vocab/meta-data", {
  default: "https://json-schema.org/keyword/default",
  deprecated: "https://json-schema.org/keyword/deprecated",
  description: "https://json-schema.org/keyword/description",
  examples: "https://json-schema.org/keyword/examples",
  readOnly: "https://json-schema.org/keyword/readOnly",
  title: "https://json-schema.org/keyword/title",
  writeOnly: "https://json-schema.org/keyword/writeOnly"
});
Cc("https://json-schema.org/draft/2020-12/vocab/format-annotation", {
  format: "https://json-schema.org/keyword/format"
});
Cc("https://json-schema.org/draft/2020-12/vocab/format-assertion", {
  format: "https://json-schema.org/keyword/format-assertion"
});
Cc("https://json-schema.org/draft/2020-12/vocab/content", {
  contentEncoding: "https://json-schema.org/keyword/contentEncoding",
  contentMediaType: "https://json-schema.org/keyword/contentMediaType",
  contentSchema: "https://json-schema.org/keyword/contentSchema"
});
Cc("https://json-schema.org/draft/2020-12/vocab/unevaluated", {
  unevaluatedItems: "https://json-schema.org/keyword/unevaluatedItems",
  unevaluatedProperties: "https://json-schema.org/keyword/unevaluatedProperties"
});
sD("https://json-schema.org/draft/2020-12/schema", {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, !0);
Ka(spe);
Ka(ope);
Ka(ape);
Ka(lpe);
Ka(cpe);
Ka(upe);
Ka(hpe);
Ka(ppe);
Ka(dpe);
function jm(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var X7 = { exports: {} };
/*! jsonpath 1.1.1 */
var e_;
function xpe() {
  return e_ || (e_ = 1, function(t, e) {
    (function(r) {
      t.exports = r();
    })(function() {
      return function r(n, i, s) {
        function o(c, p) {
          if (!i[c]) {
            if (!n[c]) {
              var h = typeof jm == "function" && jm;
              if (!p && h) return h(c, !0);
              if (a) return a(c, !0);
              var d = new Error("Cannot find module '" + c + "'");
              throw d.code = "MODULE_NOT_FOUND", d;
            }
            var v = i[c] = { exports: {} };
            n[c][0].call(v.exports, function(m) {
              var b = n[c][1][m];
              return o(b || m);
            }, v, v.exports, r, n, i, s);
          }
          return i[c].exports;
        }
        for (var a = typeof jm == "function" && jm, l = 0; l < s.length; l++) o(s[l]);
        return o;
      }({ "./aesprim": [function(r, n, i) {
        (function(s, o) {
          o(typeof i < "u" ? i : s.esprima = {});
        })(this, function(s) {
          var o, a, l, c, p, h, d, v, m, b, f, E, A, x, g, w, _, S;
          o = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
          }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
            "(",
            "{",
            "[",
            "in",
            "typeof",
            "instanceof",
            "new",
            "return",
            "case",
            "delete",
            "throw",
            "void",
            // assignment operators
            "=",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "<<=",
            ">>=",
            ">>>=",
            "&=",
            "|=",
            "^=",
            ",",
            // binary/unary operators
            "+",
            "-",
            "*",
            "/",
            "%",
            "++",
            "--",
            "<<",
            ">>",
            ">>>",
            "&",
            "|",
            "^",
            "!",
            "~",
            "&&",
            "||",
            "?",
            ":",
            "===",
            "==",
            ">=",
            "<=",
            "<",
            ">",
            "!=",
            "!=="
          ], c = {
            AssignmentExpression: "AssignmentExpression",
            ArrayExpression: "ArrayExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            Program: "Program",
            Property: "Property",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SwitchStatement: "SwitchStatement",
            SwitchCase: "SwitchCase",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement"
          }, p = {
            Data: 1,
            Get: 2,
            Set: 4
          }, h = {
            UnexpectedToken: "Unexpected token %0",
            UnexpectedNumber: "Unexpected number",
            UnexpectedString: "Unexpected string",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedEOS: "Unexpected end of input",
            NewlineAfterThrow: "Illegal newline after throw",
            InvalidRegExp: "Invalid regular expression",
            UnterminatedRegExp: "Invalid regular expression: missing /",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NoCatchOrFinally: "Missing catch or finally after try",
            UnknownLabel: "Undefined label '%0'",
            Redeclaration: "%0 '%1' has already been declared",
            IllegalContinue: "Illegal continue statement",
            IllegalBreak: "Illegal break statement",
            IllegalReturn: "Illegal return statement",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
            AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
            AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode"
          }, d = {
            NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
            NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
          };
          function R(u, y) {
            if (!u)
              throw new Error("ASSERT: " + y);
          }
          function L(u) {
            return u >= 48 && u <= 57;
          }
          function F(u) {
            return "0123456789abcdefABCDEF".indexOf(u) >= 0;
          }
          function z(u) {
            return "01234567".indexOf(u) >= 0;
          }
          function j(u) {
            return u === 32 || u === 9 || u === 11 || u === 12 || u === 160 || u >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(u) >= 0;
          }
          function W(u) {
            return u === 10 || u === 13 || u === 8232 || u === 8233;
          }
          function te(u) {
            return u == 64 || u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierStart.test(String.fromCharCode(u));
          }
          function le(u) {
            return u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u >= 48 && u <= 57 || // 0..9
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierPart.test(String.fromCharCode(u));
          }
          function ce(u) {
            switch (u) {
              case "class":
              case "enum":
              case "export":
              case "extends":
              case "import":
              case "super":
                return !0;
              default:
                return !1;
            }
          }
          function Ee(u) {
            switch (u) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return !0;
              default:
                return !1;
            }
          }
          function xe(u) {
            return u === "eval" || u === "arguments";
          }
          function _e(u) {
            if (b && Ee(u))
              return !0;
            switch (u.length) {
              case 2:
                return u === "if" || u === "in" || u === "do";
              case 3:
                return u === "var" || u === "for" || u === "new" || u === "try" || u === "let";
              case 4:
                return u === "this" || u === "else" || u === "case" || u === "void" || u === "with" || u === "enum";
              case 5:
                return u === "while" || u === "break" || u === "catch" || u === "throw" || u === "const" || u === "yield" || u === "class" || u === "super";
              case 6:
                return u === "return" || u === "typeof" || u === "delete" || u === "switch" || u === "export" || u === "import";
              case 7:
                return u === "default" || u === "finally" || u === "extends";
              case 8:
                return u === "function" || u === "continue" || u === "debugger";
              case 10:
                return u === "instanceof";
              default:
                return !1;
            }
          }
          function Ie(u, y, k, T, V) {
            var ne;
            R(typeof k == "number", "Comment must have valid position"), !(_.lastCommentStart >= k) && (_.lastCommentStart = k, ne = {
              type: u,
              value: y
            }, S.range && (ne.range = [k, T]), S.loc && (ne.loc = V), S.comments.push(ne), S.attachComment && (S.leadingComments.push(ne), S.trailingComments.push(ne)));
          }
          function je(u) {
            var y, k, T, V;
            for (y = f - u, k = {
              start: {
                line: E,
                column: f - A - u
              }
            }; f < x; )
              if (T = m.charCodeAt(f), ++f, W(T)) {
                S.comments && (V = m.slice(y + u, f - 1), k.end = {
                  line: E,
                  column: f - A - 1
                }, Ie("Line", V, y, f - 1, k)), T === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f;
                return;
              }
            S.comments && (V = m.slice(y + u, f), k.end = {
              line: E,
              column: f - A
            }, Ie("Line", V, y, f, k));
          }
          function ue() {
            var u, y, k, T;
            for (S.comments && (u = f - 2, y = {
              start: {
                line: E,
                column: f - A - 2
              }
            }); f < x; )
              if (k = m.charCodeAt(f), W(k))
                k === 13 && m.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && fe({}, h.UnexpectedToken, "ILLEGAL");
              else if (k === 42) {
                if (m.charCodeAt(f + 1) === 47) {
                  ++f, ++f, S.comments && (T = m.slice(u + 2, f - 2), y.end = {
                    line: E,
                    column: f - A
                  }, Ie("Block", T, u, f, y));
                  return;
                }
                ++f;
              } else
                ++f;
            fe({}, h.UnexpectedToken, "ILLEGAL");
          }
          function O() {
            var u, y;
            for (y = f === 0; f < x; )
              if (u = m.charCodeAt(f), j(u))
                ++f;
              else if (W(u))
                ++f, u === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f, y = !0;
              else if (u === 47)
                if (u = m.charCodeAt(f + 1), u === 47)
                  ++f, ++f, je(2), y = !0;
                else if (u === 42)
                  ++f, ++f, ue();
                else
                  break;
              else if (y && u === 45)
                if (m.charCodeAt(f + 1) === 45 && m.charCodeAt(f + 2) === 62)
                  f += 3, je(3);
                else
                  break;
              else if (u === 60)
                if (m.slice(f + 1, f + 4) === "!--")
                  ++f, ++f, ++f, ++f, je(4);
                else
                  break;
              else
                break;
          }
          function N(u) {
            var y, k, T, V = 0;
            for (k = u === "u" ? 4 : 2, y = 0; y < k; ++y)
              if (f < x && F(m[f]))
                T = m[f++], V = V * 16 + "0123456789abcdef".indexOf(T.toLowerCase());
              else
                return "";
            return String.fromCharCode(V);
          }
          function J() {
            var u, y;
            for (u = m.charCodeAt(f++), y = String.fromCharCode(u), u === 92 && (m.charCodeAt(f) !== 117 && fe({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !te(u.charCodeAt(0))) && fe({}, h.UnexpectedToken, "ILLEGAL"), y = u); f < x && (u = m.charCodeAt(f), !!le(u)); )
              ++f, y += String.fromCharCode(u), u === 92 && (y = y.substr(0, y.length - 1), m.charCodeAt(f) !== 117 && fe({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !le(u.charCodeAt(0))) && fe({}, h.UnexpectedToken, "ILLEGAL"), y += u);
            return y;
          }
          function re() {
            var u, y;
            for (u = f++; f < x; ) {
              if (y = m.charCodeAt(f), y === 92)
                return f = u, J();
              if (le(y))
                ++f;
              else
                break;
            }
            return m.slice(u, f);
          }
          function oe() {
            var u, y, k;
            return u = f, y = m.charCodeAt(f) === 92 ? J() : re(), y.length === 1 ? k = o.Identifier : _e(y) ? k = o.Keyword : y === "null" ? k = o.NullLiteral : y === "true" || y === "false" ? k = o.BooleanLiteral : k = o.Identifier, {
              type: k,
              value: y,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function ee() {
            var u = f, y = m.charCodeAt(f), k, T = m[f], V, ne, Ce;
            switch (y) {
              case 46:
              case 40:
              case 41:
              case 59:
              case 44:
              case 123:
              case 125:
              case 91:
              case 93:
              case 58:
              case 63:
              case 126:
                return ++f, S.tokenize && (y === 40 ? S.openParenToken = S.tokens.length : y === 123 && (S.openCurlyToken = S.tokens.length)), {
                  type: o.Punctuator,
                  value: String.fromCharCode(y),
                  lineNumber: E,
                  lineStart: A,
                  start: u,
                  end: f
                };
              default:
                if (k = m.charCodeAt(f + 1), k === 61)
                  switch (y) {
                    case 43:
                    case 45:
                    case 47:
                    case 60:
                    case 62:
                    case 94:
                    case 124:
                    case 37:
                    case 38:
                    case 42:
                      return f += 2, {
                        type: o.Punctuator,
                        value: String.fromCharCode(y) + String.fromCharCode(k),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                    case 33:
                    case 61:
                      return f += 2, m.charCodeAt(f) === 61 && ++f, {
                        type: o.Punctuator,
                        value: m.slice(u, f),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                  }
            }
            if (Ce = m.substr(f, 4), Ce === ">>>=")
              return f += 4, {
                type: o.Punctuator,
                value: Ce,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (ne = Ce.substr(0, 3), ne === ">>>" || ne === "<<=" || ne === ">>=")
              return f += 3, {
                type: o.Punctuator,
                value: ne,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (V = ne.substr(0, 2), T === V[1] && "+-<>&|".indexOf(T) >= 0 || V === "=>")
              return f += 2, {
                type: o.Punctuator,
                value: V,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if ("<>=!+-*%&|^/".indexOf(T) >= 0)
              return ++f, {
                type: o.Punctuator,
                value: T,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            fe({}, h.UnexpectedToken, "ILLEGAL");
          }
          function ae(u) {
            for (var y = ""; f < x && F(m[f]); )
              y += m[f++];
            return y.length === 0 && fe({}, h.UnexpectedToken, "ILLEGAL"), te(m.charCodeAt(f)) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt("0x" + y, 16),
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function me(u) {
            for (var y = "0" + m[f++]; f < x && z(m[f]); )
              y += m[f++];
            return (te(m.charCodeAt(f)) || L(m.charCodeAt(f))) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt(y, 8),
              octal: !0,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function H() {
            var u, y, k;
            if (k = m[f], R(
              L(k.charCodeAt(0)) || k === ".",
              "Numeric literal must start with a decimal digit or a decimal point"
            ), y = f, u = "", k !== ".") {
              if (u = m[f++], k = m[f], u === "0") {
                if (k === "x" || k === "X")
                  return ++f, ae(y);
                if (z(k))
                  return me(y);
                k && L(k.charCodeAt(0)) && fe({}, h.UnexpectedToken, "ILLEGAL");
              }
              for (; L(m.charCodeAt(f)); )
                u += m[f++];
              k = m[f];
            }
            if (k === ".") {
              for (u += m[f++]; L(m.charCodeAt(f)); )
                u += m[f++];
              k = m[f];
            }
            if (k === "e" || k === "E")
              if (u += m[f++], k = m[f], (k === "+" || k === "-") && (u += m[f++]), L(m.charCodeAt(f)))
                for (; L(m.charCodeAt(f)); )
                  u += m[f++];
              else
                fe({}, h.UnexpectedToken, "ILLEGAL");
            return te(m.charCodeAt(f)) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseFloat(u),
              lineNumber: E,
              lineStart: A,
              start: y,
              end: f
            };
          }
          function X() {
            var u = "", y, k, T, V, ne, Ce, Me = !1, et, Xe;
            for (et = E, Xe = A, y = m[f], R(
              y === "'" || y === '"',
              "String literal must starts with a quote"
            ), k = f, ++f; f < x; )
              if (T = m[f++], T === y) {
                y = "";
                break;
              } else if (T === "\\")
                if (T = m[f++], !T || !W(T.charCodeAt(0)))
                  switch (T) {
                    case "u":
                    case "x":
                      Ce = f, ne = N(T), ne ? u += ne : (f = Ce, u += T);
                      break;
                    case "n":
                      u += `
`;
                      break;
                    case "r":
                      u += "\r";
                      break;
                    case "t":
                      u += "	";
                      break;
                    case "b":
                      u += "\b";
                      break;
                    case "f":
                      u += "\f";
                      break;
                    case "v":
                      u += "\v";
                      break;
                    default:
                      z(T) ? (V = "01234567".indexOf(T), V !== 0 && (Me = !0), f < x && z(m[f]) && (Me = !0, V = V * 8 + "01234567".indexOf(m[f++]), "0123".indexOf(T) >= 0 && f < x && z(m[f]) && (V = V * 8 + "01234567".indexOf(m[f++]))), u += String.fromCharCode(V)) : u += T;
                      break;
                  }
                else
                  ++E, T === "\r" && m[f] === `
` && ++f, A = f;
              else {
                if (W(T.charCodeAt(0)))
                  break;
                u += T;
              }
            return y !== "" && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.StringLiteral,
              value: u,
              octal: Me,
              startLineNumber: et,
              startLineStart: Xe,
              lineNumber: E,
              lineStart: A,
              start: k,
              end: f
            };
          }
          function Ae(u, y) {
            var k;
            try {
              k = new RegExp(u, y);
            } catch {
              fe({}, h.InvalidRegExp);
            }
            return k;
          }
          function Re() {
            var u, y, k, T, V;
            for (u = m[f], R(u === "/", "Regular expression literal must start with a slash"), y = m[f++], k = !1, T = !1; f < x; )
              if (u = m[f++], y += u, u === "\\")
                u = m[f++], W(u.charCodeAt(0)) && fe({}, h.UnterminatedRegExp), y += u;
              else if (W(u.charCodeAt(0)))
                fe({}, h.UnterminatedRegExp);
              else if (k)
                u === "]" && (k = !1);
              else if (u === "/") {
                T = !0;
                break;
              } else u === "[" && (k = !0);
            return T || fe({}, h.UnterminatedRegExp), V = y.substr(1, y.length - 2), {
              value: V,
              literal: y
            };
          }
          function Fe() {
            var u, y, k, T;
            for (y = "", k = ""; f < x && (u = m[f], !!le(u.charCodeAt(0))); )
              if (++f, u === "\\" && f < x)
                if (u = m[f], u === "u") {
                  if (++f, T = f, u = N("u"), u)
                    for (k += u, y += "\\u"; T < f; ++T)
                      y += m[T];
                  else
                    f = T, k += "u", y += "\\u";
                  ye({}, h.UnexpectedToken, "ILLEGAL");
                } else
                  y += "\\", ye({}, h.UnexpectedToken, "ILLEGAL");
              else
                k += u, y += u;
            return {
              value: k,
              literal: y
            };
          }
          function Te() {
            var u, y, k, T;
            return w = null, O(), u = f, y = Re(), k = Fe(), T = Ae(y.value, k.value), S.tokenize ? {
              type: o.RegularExpression,
              value: T,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            } : {
              literal: y.literal + k.literal,
              value: T,
              start: u,
              end: f
            };
          }
          function qe() {
            var u, y, k, T;
            return O(), u = f, y = {
              start: {
                line: E,
                column: f - A
              }
            }, k = Te(), y.end = {
              line: E,
              column: f - A
            }, S.tokenize || (S.tokens.length > 0 && (T = S.tokens[S.tokens.length - 1], T.range[0] === u && T.type === "Punctuator" && (T.value === "/" || T.value === "/=") && S.tokens.pop()), S.tokens.push({
              type: "RegularExpression",
              value: k.literal,
              range: [u, f],
              loc: y
            })), k;
          }
          function tt(u) {
            return u.type === o.Identifier || u.type === o.Keyword || u.type === o.BooleanLiteral || u.type === o.NullLiteral;
          }
          function Pe() {
            var u, y;
            if (u = S.tokens[S.tokens.length - 1], !u)
              return qe();
            if (u.type === "Punctuator") {
              if (u.value === "]")
                return ee();
              if (u.value === ")")
                return y = S.tokens[S.openParenToken - 1], y && y.type === "Keyword" && (y.value === "if" || y.value === "while" || y.value === "for" || y.value === "with") ? qe() : ee();
              if (u.value === "}") {
                if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 4], !y)
                    return ee();
                } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 5], !y)
                    return qe();
                } else
                  return ee();
                return l.indexOf(y.value) >= 0 ? ee() : qe();
              }
              return qe();
            }
            return u.type === "Keyword" ? qe() : ee();
          }
          function At() {
            var u;
            return O(), f >= x ? {
              type: o.EOF,
              lineNumber: E,
              lineStart: A,
              start: f,
              end: f
            } : (u = m.charCodeAt(f), te(u) ? oe() : u === 40 || u === 41 || u === 59 ? ee() : u === 39 || u === 34 ? X() : u === 46 ? L(m.charCodeAt(f + 1)) ? H() : ee() : L(u) ? H() : S.tokenize && u === 47 ? Pe() : ee());
          }
          function er() {
            var u, y, k;
            return O(), u = {
              start: {
                line: E,
                column: f - A
              }
            }, y = At(), u.end = {
              line: E,
              column: f - A
            }, y.type !== o.EOF && (k = m.slice(y.start, y.end), S.tokens.push({
              type: a[y.type],
              value: k,
              range: [y.start, y.end],
              loc: u
            })), y;
          }
          function ge() {
            var u;
            return u = w, f = u.end, E = u.lineNumber, A = u.lineStart, w = typeof S.tokens < "u" ? er() : At(), f = u.end, E = u.lineNumber, A = u.lineStart, u;
          }
          function ht() {
            var u, y, k;
            u = f, y = E, k = A, w = typeof S.tokens < "u" ? er() : At(), f = u, E = y, A = k;
          }
          function it(u, y) {
            this.line = u, this.column = y;
          }
          function kt(u, y, k, T) {
            this.start = new it(u, y), this.end = new it(k, T);
          }
          v = {
            name: "SyntaxTree",
            processComment: function(u) {
              var y, k;
              if (!(u.type === c.Program && u.body.length > 0)) {
                for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= u.range[1] ? (k = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= u.range[1] && (k = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= u.range[0]; )
                  y = S.bottomRightStack.pop();
                y ? y.leadingComments && y.leadingComments[y.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = y.leadingComments, delete y.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = S.leadingComments, S.leadingComments = []), k && (u.trailingComments = k), S.bottomRightStack.push(u);
              }
            },
            markEnd: function(u, y) {
              return S.range && (u.range = [y.start, f]), S.loc && (u.loc = new kt(
                y.startLineNumber === void 0 ? y.lineNumber : y.startLineNumber,
                y.start - (y.startLineStart === void 0 ? y.lineStart : y.startLineStart),
                E,
                f - A
              ), this.postProcess(u)), S.attachComment && this.processComment(u), u;
            },
            postProcess: function(u) {
              return S.source && (u.loc.source = S.source), u;
            },
            createArrayExpression: function(u) {
              return {
                type: c.ArrayExpression,
                elements: u
              };
            },
            createAssignmentExpression: function(u, y, k) {
              return {
                type: c.AssignmentExpression,
                operator: u,
                left: y,
                right: k
              };
            },
            createBinaryExpression: function(u, y, k) {
              var T = u === "||" || u === "&&" ? c.LogicalExpression : c.BinaryExpression;
              return {
                type: T,
                operator: u,
                left: y,
                right: k
              };
            },
            createBlockStatement: function(u) {
              return {
                type: c.BlockStatement,
                body: u
              };
            },
            createBreakStatement: function(u) {
              return {
                type: c.BreakStatement,
                label: u
              };
            },
            createCallExpression: function(u, y) {
              return {
                type: c.CallExpression,
                callee: u,
                arguments: y
              };
            },
            createCatchClause: function(u, y) {
              return {
                type: c.CatchClause,
                param: u,
                body: y
              };
            },
            createConditionalExpression: function(u, y, k) {
              return {
                type: c.ConditionalExpression,
                test: u,
                consequent: y,
                alternate: k
              };
            },
            createContinueStatement: function(u) {
              return {
                type: c.ContinueStatement,
                label: u
              };
            },
            createDebuggerStatement: function() {
              return {
                type: c.DebuggerStatement
              };
            },
            createDoWhileStatement: function(u, y) {
              return {
                type: c.DoWhileStatement,
                body: u,
                test: y
              };
            },
            createEmptyStatement: function() {
              return {
                type: c.EmptyStatement
              };
            },
            createExpressionStatement: function(u) {
              return {
                type: c.ExpressionStatement,
                expression: u
              };
            },
            createForStatement: function(u, y, k, T) {
              return {
                type: c.ForStatement,
                init: u,
                test: y,
                update: k,
                body: T
              };
            },
            createForInStatement: function(u, y, k) {
              return {
                type: c.ForInStatement,
                left: u,
                right: y,
                body: k,
                each: !1
              };
            },
            createFunctionDeclaration: function(u, y, k, T) {
              return {
                type: c.FunctionDeclaration,
                id: u,
                params: y,
                defaults: k,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createFunctionExpression: function(u, y, k, T) {
              return {
                type: c.FunctionExpression,
                id: u,
                params: y,
                defaults: k,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createIdentifier: function(u) {
              return {
                type: c.Identifier,
                name: u
              };
            },
            createIfStatement: function(u, y, k) {
              return {
                type: c.IfStatement,
                test: u,
                consequent: y,
                alternate: k
              };
            },
            createLabeledStatement: function(u, y) {
              return {
                type: c.LabeledStatement,
                label: u,
                body: y
              };
            },
            createLiteral: function(u) {
              return {
                type: c.Literal,
                value: u.value,
                raw: m.slice(u.start, u.end)
              };
            },
            createMemberExpression: function(u, y, k) {
              return {
                type: c.MemberExpression,
                computed: u === "[",
                object: y,
                property: k
              };
            },
            createNewExpression: function(u, y) {
              return {
                type: c.NewExpression,
                callee: u,
                arguments: y
              };
            },
            createObjectExpression: function(u) {
              return {
                type: c.ObjectExpression,
                properties: u
              };
            },
            createPostfixExpression: function(u, y) {
              return {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !1
              };
            },
            createProgram: function(u) {
              return {
                type: c.Program,
                body: u
              };
            },
            createProperty: function(u, y, k) {
              return {
                type: c.Property,
                key: y,
                value: k,
                kind: u
              };
            },
            createReturnStatement: function(u) {
              return {
                type: c.ReturnStatement,
                argument: u
              };
            },
            createSequenceExpression: function(u) {
              return {
                type: c.SequenceExpression,
                expressions: u
              };
            },
            createSwitchCase: function(u, y) {
              return {
                type: c.SwitchCase,
                test: u,
                consequent: y
              };
            },
            createSwitchStatement: function(u, y) {
              return {
                type: c.SwitchStatement,
                discriminant: u,
                cases: y
              };
            },
            createThisExpression: function() {
              return {
                type: c.ThisExpression
              };
            },
            createThrowStatement: function(u) {
              return {
                type: c.ThrowStatement,
                argument: u
              };
            },
            createTryStatement: function(u, y, k, T) {
              return {
                type: c.TryStatement,
                block: u,
                guardedHandlers: y,
                handlers: k,
                finalizer: T
              };
            },
            createUnaryExpression: function(u, y) {
              return u === "++" || u === "--" ? {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !0
              } : {
                type: c.UnaryExpression,
                operator: u,
                argument: y,
                prefix: !0
              };
            },
            createVariableDeclaration: function(u, y) {
              return {
                type: c.VariableDeclaration,
                declarations: u,
                kind: y
              };
            },
            createVariableDeclarator: function(u, y) {
              return {
                type: c.VariableDeclarator,
                id: u,
                init: y
              };
            },
            createWhileStatement: function(u, y) {
              return {
                type: c.WhileStatement,
                test: u,
                body: y
              };
            },
            createWithStatement: function(u, y) {
              return {
                type: c.WithStatement,
                object: u,
                body: y
              };
            }
          };
          function Ze() {
            var u, y, k, T;
            return u = f, y = E, k = A, O(), T = E !== y, f = u, E = y, A = k, T;
          }
          function fe(u, y) {
            var k, T = Array.prototype.slice.call(arguments, 2), V = y.replace(
              /%(\d)/g,
              function(ne, Ce) {
                return R(Ce < T.length, "Message reference must be in range"), T[Ce];
              }
            );
            throw typeof u.lineNumber == "number" ? (k = new Error("Line " + u.lineNumber + ": " + V), k.index = u.start, k.lineNumber = u.lineNumber, k.column = u.start - A + 1) : (k = new Error("Line " + E + ": " + V), k.index = f, k.lineNumber = E, k.column = f - A + 1), k.description = V, k;
          }
          function ye() {
            try {
              fe.apply(null, arguments);
            } catch (u) {
              if (S.errors)
                S.errors.push(u);
              else
                throw u;
            }
          }
          function Je(u) {
            if (u.type === o.EOF && fe(u, h.UnexpectedEOS), u.type === o.NumericLiteral && fe(u, h.UnexpectedNumber), u.type === o.StringLiteral && fe(u, h.UnexpectedString), u.type === o.Identifier && fe(u, h.UnexpectedIdentifier), u.type === o.Keyword) {
              if (ce(u.value))
                fe(u, h.UnexpectedReserved);
              else if (b && Ee(u.value)) {
                ye(u, h.StrictReservedWord);
                return;
              }
              fe(u, h.UnexpectedToken, u.value);
            }
            fe(u, h.UnexpectedToken, u.value);
          }
          function C(u) {
            var y = ge();
            (y.type !== o.Punctuator || y.value !== u) && Je(y);
          }
          function $(u) {
            var y = ge();
            (y.type !== o.Keyword || y.value !== u) && Je(y);
          }
          function D(u) {
            return w.type === o.Punctuator && w.value === u;
          }
          function se(u) {
            return w.type === o.Keyword && w.value === u;
          }
          function pe() {
            var u;
            return w.type !== o.Punctuator ? !1 : (u = w.value, u === "=" || u === "*=" || u === "/=" || u === "%=" || u === "+=" || u === "-=" || u === "<<=" || u === ">>=" || u === ">>>=" || u === "&=" || u === "^=" || u === "|=");
          }
          function Se() {
            var u;
            if (m.charCodeAt(f) === 59 || D(";")) {
              ge();
              return;
            }
            u = E, O(), E === u && w.type !== o.EOF && !D("}") && Je(w);
          }
          function Le(u) {
            return u.type === c.Identifier || u.type === c.MemberExpression;
          }
          function ot() {
            var u = [], y;
            for (y = w, C("["); !D("]"); )
              D(",") ? (ge(), u.push(null)) : (u.push(q()), D("]") || C(","));
            return ge(), g.markEnd(g.createArrayExpression(u), y);
          }
          function dt(u, y) {
            var k, T, V;
            return k = b, V = w, T = Vn(), y && b && xe(u[0].name) && ye(y, h.StrictParamName), b = k, g.markEnd(g.createFunctionExpression(null, u, [], T), V);
          }
          function St() {
            var u, y;
            return y = w, u = ge(), u.type === o.StringLiteral || u.type === o.NumericLiteral ? (b && u.octal && ye(u, h.StrictOctalLiteral), g.markEnd(g.createLiteral(u), y)) : g.markEnd(g.createIdentifier(u.value), y);
          }
          function rt() {
            var u, y, k, T, V, ne;
            if (u = w, ne = w, u.type === o.Identifier)
              return k = St(), u.value === "get" && !D(":") ? (y = St(), C("("), C(")"), T = dt([]), g.markEnd(g.createProperty("get", y, T), ne)) : u.value === "set" && !D(":") ? (y = St(), C("("), u = w, u.type !== o.Identifier ? (C(")"), ye(u, h.UnexpectedToken, u.value), T = dt([])) : (V = [he()], C(")"), T = dt(V, u)), g.markEnd(g.createProperty("set", y, T), ne)) : (C(":"), T = q(), g.markEnd(g.createProperty("init", k, T), ne));
            if (u.type === o.EOF || u.type === o.Punctuator)
              Je(u);
            else
              return y = St(), C(":"), T = q(), g.markEnd(g.createProperty("init", y, T), ne);
          }
          function zt() {
            var u = [], y, k, T, V, ne = {}, Ce = String, Me;
            for (Me = w, C("{"); !D("}"); )
              y = rt(), y.key.type === c.Identifier ? k = y.key.name : k = Ce(y.key.value), V = y.kind === "init" ? p.Data : y.kind === "get" ? p.Get : p.Set, T = "$" + k, Object.prototype.hasOwnProperty.call(ne, T) ? (ne[T] === p.Data ? b && V === p.Data ? ye({}, h.StrictDuplicateProperty) : V !== p.Data && ye({}, h.AccessorDataProperty) : V === p.Data ? ye({}, h.AccessorDataProperty) : ne[T] & V && ye({}, h.AccessorGetSet), ne[T] |= V) : ne[T] = V, u.push(y), D("}") || C(",");
            return C("}"), g.markEnd(g.createObjectExpression(u), Me);
          }
          function Xt() {
            var u;
            return C("("), u = G(), C(")"), u;
          }
          function tr() {
            var u, y, k, T;
            if (D("("))
              return Xt();
            if (D("["))
              return ot();
            if (D("{"))
              return zt();
            if (u = w.type, T = w, u === o.Identifier)
              k = g.createIdentifier(ge().value);
            else if (u === o.StringLiteral || u === o.NumericLiteral)
              b && w.octal && ye(w, h.StrictOctalLiteral), k = g.createLiteral(ge());
            else if (u === o.Keyword) {
              if (se("function"))
                return uu();
              se("this") ? (ge(), k = g.createThisExpression()) : Je(ge());
            } else u === o.BooleanLiteral ? (y = ge(), y.value = y.value === "true", k = g.createLiteral(y)) : u === o.NullLiteral ? (y = ge(), y.value = null, k = g.createLiteral(y)) : D("/") || D("/=") ? (typeof S.tokens < "u" ? k = g.createLiteral(qe()) : k = g.createLiteral(Te()), ht()) : Je(ge());
            return g.markEnd(k, T);
          }
          function Nr() {
            var u = [];
            if (C("("), !D(")"))
              for (; f < x && (u.push(q()), !D(")")); )
                C(",");
            return C(")"), u;
          }
          function Ai() {
            var u, y;
            return y = w, u = ge(), tt(u) || Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function Zt() {
            return C("."), Ai();
          }
          function Un() {
            var u;
            return C("["), u = G(), C("]"), u;
          }
          function M() {
            var u, y, k;
            return k = w, $("new"), u = K(), y = D("(") ? Nr() : [], g.markEnd(g.createNewExpression(u, y), k);
          }
          function U() {
            var u, y, k, T, V;
            for (V = w, u = _.allowIn, _.allowIn = !0, y = se("new") ? M() : tr(), _.allowIn = u; ; ) {
              if (D("."))
                T = Zt(), y = g.createMemberExpression(".", y, T);
              else if (D("("))
                k = Nr(), y = g.createCallExpression(y, k);
              else if (D("["))
                T = Un(), y = g.createMemberExpression("[", y, T);
              else
                break;
              g.markEnd(y, V);
            }
            return y;
          }
          function K() {
            var u, y, k, T;
            for (T = w, u = _.allowIn, y = se("new") ? M() : tr(), _.allowIn = u; D(".") || D("["); )
              D("[") ? (k = Un(), y = g.createMemberExpression("[", y, k)) : (k = Zt(), y = g.createMemberExpression(".", y, k)), g.markEnd(y, T);
            return y;
          }
          function de() {
            var u, y, k = w;
            return u = U(), w.type === o.Punctuator && (D("++") || D("--")) && !Ze() && (b && u.type === c.Identifier && xe(u.name) && ye({}, h.StrictLHSPostfix), Le(u) || ye({}, h.InvalidLHSInAssignment), y = ge(), u = g.markEnd(g.createPostfixExpression(y.value, u), k)), u;
          }
          function ve() {
            var u, y, k;
            return w.type !== o.Punctuator && w.type !== o.Keyword ? y = de() : D("++") || D("--") ? (k = w, u = ge(), y = ve(), b && y.type === c.Identifier && xe(y.name) && ye({}, h.StrictLHSPrefix), Le(y) || ye({}, h.InvalidLHSInAssignment), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k)) : D("+") || D("-") || D("~") || D("!") ? (k = w, u = ge(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k)) : se("delete") || se("void") || se("typeof") ? (k = w, u = ge(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k), b && y.operator === "delete" && y.argument.type === c.Identifier && ye({}, h.StrictDelete)) : y = de(), y;
          }
          function Z(u, y) {
            var k = 0;
            if (u.type !== o.Punctuator && u.type !== o.Keyword)
              return 0;
            switch (u.value) {
              case "||":
                k = 1;
                break;
              case "&&":
                k = 2;
                break;
              case "|":
                k = 3;
                break;
              case "^":
                k = 4;
                break;
              case "&":
                k = 5;
                break;
              case "==":
              case "!=":
              case "===":
              case "!==":
                k = 6;
                break;
              case "<":
              case ">":
              case "<=":
              case ">=":
              case "instanceof":
                k = 7;
                break;
              case "in":
                k = y ? 7 : 0;
                break;
              case "<<":
              case ">>":
              case ">>>":
                k = 8;
                break;
              case "+":
              case "-":
                k = 9;
                break;
              case "*":
              case "/":
              case "%":
                k = 11;
                break;
            }
            return k;
          }
          function I() {
            var u, y, k, T, V, ne, Ce, Me, et, Xe;
            if (u = w, et = ve(), T = w, V = Z(T, _.allowIn), V === 0)
              return et;
            for (T.prec = V, ge(), y = [u, w], Ce = ve(), ne = [et, T, Ce]; (V = Z(w, _.allowIn)) > 0; ) {
              for (; ne.length > 2 && V <= ne[ne.length - 2].prec; )
                Ce = ne.pop(), Me = ne.pop().value, et = ne.pop(), k = g.createBinaryExpression(Me, et, Ce), y.pop(), u = y[y.length - 1], g.markEnd(k, u), ne.push(k);
              T = ge(), T.prec = V, ne.push(T), y.push(w), k = ve(), ne.push(k);
            }
            for (Xe = ne.length - 1, k = ne[Xe], y.pop(); Xe > 1; )
              k = g.createBinaryExpression(ne[Xe - 1].value, ne[Xe - 2], k), Xe -= 2, u = y.pop(), g.markEnd(k, u);
            return k;
          }
          function B() {
            var u, y, k, T, V;
            return V = w, u = I(), D("?") && (ge(), y = _.allowIn, _.allowIn = !0, k = q(), _.allowIn = y, C(":"), T = q(), u = g.createConditionalExpression(u, k, T), g.markEnd(u, V)), u;
          }
          function q() {
            var u, y, k, T, V;
            return u = w, V = w, T = y = B(), pe() && (Le(y) || ye({}, h.InvalidLHSInAssignment), b && y.type === c.Identifier && xe(y.name) && ye(u, h.StrictLHSAssignment), u = ge(), k = q(), T = g.markEnd(g.createAssignmentExpression(u.value, y, k), V)), T;
          }
          function G() {
            var u, y = w;
            if (u = q(), D(",")) {
              for (u = g.createSequenceExpression([u]); f < x && D(","); )
                ge(), u.expressions.push(q());
              g.markEnd(u, y);
            }
            return u;
          }
          function Y() {
            for (var u = [], y; f < x && !(D("}") || (y = Ir(), typeof y > "u")); )
              u.push(y);
            return u;
          }
          function ie() {
            var u, y;
            return y = w, C("{"), u = Y(), C("}"), g.markEnd(g.createBlockStatement(u), y);
          }
          function he() {
            var u, y;
            return y = w, u = ge(), u.type !== o.Identifier && Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function be(u) {
            var y = null, k, T;
            return T = w, k = he(), b && xe(k.name) && ye({}, h.StrictVarName), u === "const" ? (C("="), y = q()) : D("=") && (ge(), y = q()), g.markEnd(g.createVariableDeclarator(k, y), T);
          }
          function ke(u) {
            var y = [];
            do {
              if (y.push(be(u)), !D(","))
                break;
              ge();
            } while (f < x);
            return y;
          }
          function De() {
            var u;
            return $("var"), u = ke(), Se(), g.createVariableDeclaration(u, "var");
          }
          function $e(u) {
            var y, k;
            return k = w, $(u), y = ke(u), Se(), g.markEnd(g.createVariableDeclaration(y, u), k);
          }
          function Qe() {
            return C(";"), g.createEmptyStatement();
          }
          function ut() {
            var u = G();
            return Se(), g.createExpressionStatement(u);
          }
          function st() {
            var u, y, k;
            return $("if"), C("("), u = G(), C(")"), y = Ot(), se("else") ? (ge(), k = Ot()) : k = null, g.createIfStatement(u, y, k);
          }
          function Rt() {
            var u, y, k;
            return $("do"), k = _.inIteration, _.inIteration = !0, u = Ot(), _.inIteration = k, $("while"), C("("), y = G(), C(")"), D(";") && ge(), g.createDoWhileStatement(u, y);
          }
          function $t() {
            var u, y, k;
            return $("while"), C("("), u = G(), C(")"), k = _.inIteration, _.inIteration = !0, y = Ot(), _.inIteration = k, g.createWhileStatement(u, y);
          }
          function Or() {
            var u, y, k;
            return k = w, u = ge(), y = ke(), g.markEnd(g.createVariableDeclaration(y, u.value), k);
          }
          function an() {
            var u, y, k, T, V, ne, Ce;
            return u = y = k = null, $("for"), C("("), D(";") ? ge() : (se("var") || se("let") ? (_.allowIn = !1, u = Or(), _.allowIn = !0, u.declarations.length === 1 && se("in") && (ge(), T = u, V = G(), u = null)) : (_.allowIn = !1, u = G(), _.allowIn = !0, se("in") && (Le(u) || ye({}, h.InvalidLHSInForIn), ge(), T = u, V = G(), u = null)), typeof T > "u" && C(";")), typeof T > "u" && (D(";") || (y = G()), C(";"), D(")") || (k = G())), C(")"), Ce = _.inIteration, _.inIteration = !0, ne = Ot(), _.inIteration = Ce, typeof T > "u" ? g.createForStatement(u, y, k, ne) : g.createForInStatement(T, V, ne);
          }
          function wo() {
            var u = null, y;
            return $("continue"), m.charCodeAt(f) === 59 ? (ge(), _.inIteration || fe({}, h.IllegalContinue), g.createContinueStatement(null)) : Ze() ? (_.inIteration || fe({}, h.IllegalContinue), g.createContinueStatement(null)) : (w.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(_.labelSet, y) || fe({}, h.UnknownLabel, u.name)), Se(), u === null && !_.inIteration && fe({}, h.IllegalContinue), g.createContinueStatement(u));
          }
          function xo() {
            var u = null, y;
            return $("break"), m.charCodeAt(f) === 59 ? (ge(), _.inIteration || _.inSwitch || fe({}, h.IllegalBreak), g.createBreakStatement(null)) : Ze() ? (_.inIteration || _.inSwitch || fe({}, h.IllegalBreak), g.createBreakStatement(null)) : (w.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(_.labelSet, y) || fe({}, h.UnknownLabel, u.name)), Se(), u === null && !(_.inIteration || _.inSwitch) && fe({}, h.IllegalBreak), g.createBreakStatement(u));
          }
          function ru() {
            var u = null;
            return $("return"), _.inFunctionBody || ye({}, h.IllegalReturn), m.charCodeAt(f) === 32 && te(m.charCodeAt(f + 1)) ? (u = G(), Se(), g.createReturnStatement(u)) : Ze() ? g.createReturnStatement(null) : (D(";") || !D("}") && w.type !== o.EOF && (u = G()), Se(), g.createReturnStatement(u));
          }
          function nu() {
            var u, y;
            return b && (O(), ye({}, h.StrictModeWith)), $("with"), C("("), u = G(), C(")"), y = Ot(), g.createWithStatement(u, y);
          }
          function iu() {
            var u, y = [], k, T;
            for (T = w, se("default") ? (ge(), u = null) : ($("case"), u = G()), C(":"); f < x && !(D("}") || se("default") || se("case")); )
              k = Ot(), y.push(k);
            return g.markEnd(g.createSwitchCase(u, y), T);
          }
          function su() {
            var u, y, k, T, V;
            if ($("switch"), C("("), u = G(), C(")"), C("{"), y = [], D("}"))
              return ge(), g.createSwitchStatement(u, y);
            for (T = _.inSwitch, _.inSwitch = !0, V = !1; f < x && !D("}"); )
              k = iu(), k.test === null && (V && fe({}, h.MultipleDefaultsInSwitch), V = !0), y.push(k);
            return _.inSwitch = T, C("}"), g.createSwitchStatement(u, y);
          }
          function ou() {
            var u;
            return $("throw"), Ze() && fe({}, h.NewlineAfterThrow), u = G(), Se(), g.createThrowStatement(u);
          }
          function au() {
            var u, y, k;
            return k = w, $("catch"), C("("), D(")") && Je(w), u = he(), b && xe(u.name) && ye({}, h.StrictCatchVariable), C(")"), y = ie(), g.markEnd(g.createCatchClause(u, y), k);
          }
          function lu() {
            var u, y = [], k = null;
            return $("try"), u = ie(), se("catch") && y.push(au()), se("finally") && (ge(), k = ie()), y.length === 0 && !k && fe({}, h.NoCatchOrFinally), g.createTryStatement(u, [], y, k);
          }
          function cu() {
            return $("debugger"), Se(), g.createDebuggerStatement();
          }
          function Ot() {
            var u = w.type, y, k, T, V;
            if (u === o.EOF && Je(w), u === o.Punctuator && w.value === "{")
              return ie();
            if (V = w, u === o.Punctuator)
              switch (w.value) {
                case ";":
                  return g.markEnd(Qe(), V);
                case "(":
                  return g.markEnd(ut(), V);
              }
            if (u === o.Keyword)
              switch (w.value) {
                case "break":
                  return g.markEnd(xo(), V);
                case "continue":
                  return g.markEnd(wo(), V);
                case "debugger":
                  return g.markEnd(cu(), V);
                case "do":
                  return g.markEnd(Rt(), V);
                case "for":
                  return g.markEnd(an(), V);
                case "function":
                  return g.markEnd(Ps(), V);
                case "if":
                  return g.markEnd(st(), V);
                case "return":
                  return g.markEnd(ru(), V);
                case "switch":
                  return g.markEnd(su(), V);
                case "throw":
                  return g.markEnd(ou(), V);
                case "try":
                  return g.markEnd(lu(), V);
                case "var":
                  return g.markEnd(De(), V);
                case "while":
                  return g.markEnd($t(), V);
                case "with":
                  return g.markEnd(nu(), V);
              }
            return y = G(), y.type === c.Identifier && D(":") ? (ge(), T = "$" + y.name, Object.prototype.hasOwnProperty.call(_.labelSet, T) && fe({}, h.Redeclaration, "Label", y.name), _.labelSet[T] = !0, k = Ot(), delete _.labelSet[T], g.markEnd(g.createLabeledStatement(y, k), V)) : (Se(), g.markEnd(g.createExpressionStatement(y), V));
          }
          function Vn() {
            var u, y = [], k, T, V, ne, Ce, Me, et, Xe;
            for (Xe = w, C("{"); f < x && !(w.type !== o.StringLiteral || (k = w, u = Ir(), y.push(u), u.expression.type !== c.Literal)); )
              T = m.slice(k.start + 1, k.end - 1), T === "use strict" ? (b = !0, V && ye(V, h.StrictOctalLiteral)) : !V && k.octal && (V = k);
            for (ne = _.labelSet, Ce = _.inIteration, Me = _.inSwitch, et = _.inFunctionBody, _.labelSet = {}, _.inIteration = !1, _.inSwitch = !1, _.inFunctionBody = !0; f < x && !(D("}") || (u = Ir(), typeof u > "u")); )
              y.push(u);
            return C("}"), _.labelSet = ne, _.inIteration = Ce, _.inSwitch = Me, _.inFunctionBody = et, g.markEnd(g.createBlockStatement(y), Xe);
          }
          function Is(u) {
            var y, k = [], T, V, ne, Ce, Me;
            if (C("("), !D(")"))
              for (ne = {}; f < x && (T = w, y = he(), Ce = "$" + T.value, b ? (xe(T.value) && (V = T, Me = h.StrictParamName), Object.prototype.hasOwnProperty.call(ne, Ce) && (V = T, Me = h.StrictParamDupe)) : u || (xe(T.value) ? (u = T, Me = h.StrictParamName) : Ee(T.value) ? (u = T, Me = h.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ne, Ce) && (u = T, Me = h.StrictParamDupe)), k.push(y), ne[Ce] = !0, !D(")")); )
                C(",");
            return C(")"), {
              params: k,
              stricted: V,
              firstRestricted: u,
              message: Me
            };
          }
          function Ps() {
            var u, y = [], k, T, V, ne, Ce, Me, et, Xe;
            return Xe = w, $("function"), T = w, u = he(), b ? xe(T.value) && ye(T, h.StrictFunctionName) : xe(T.value) ? (Ce = T, Me = h.StrictFunctionName) : Ee(T.value) && (Ce = T, Me = h.StrictReservedWord), ne = Is(Ce), y = ne.params, V = ne.stricted, Ce = ne.firstRestricted, ne.message && (Me = ne.message), et = b, k = Vn(), b && Ce && fe(Ce, Me), b && V && ye(V, Me), b = et, g.markEnd(g.createFunctionDeclaration(u, y, [], k), Xe);
          }
          function uu() {
            var u, y = null, k, T, V, ne, Ce = [], Me, et, Xe;
            return Xe = w, $("function"), D("(") || (u = w, y = he(), b ? xe(u.value) && ye(u, h.StrictFunctionName) : xe(u.value) ? (T = u, V = h.StrictFunctionName) : Ee(u.value) && (T = u, V = h.StrictReservedWord)), ne = Is(T), Ce = ne.params, k = ne.stricted, T = ne.firstRestricted, ne.message && (V = ne.message), et = b, Me = Vn(), b && T && fe(T, V), b && k && ye(k, V), b = et, g.markEnd(g.createFunctionExpression(y, Ce, [], Me), Xe);
          }
          function Ir() {
            if (w.type === o.Keyword)
              switch (w.value) {
                case "const":
                case "let":
                  return $e(w.value);
                case "function":
                  return Ps();
                default:
                  return Ot();
              }
            if (w.type !== o.EOF)
              return Ot();
          }
          function hu() {
            for (var u, y = [], k, T, V; f < x && (k = w, !(k.type !== o.StringLiteral || (u = Ir(), y.push(u), u.expression.type !== c.Literal))); )
              T = m.slice(k.start + 1, k.end - 1), T === "use strict" ? (b = !0, V && ye(V, h.StrictOctalLiteral)) : !V && k.octal && (V = k);
            for (; f < x && (u = Ir(), !(typeof u > "u")); )
              y.push(u);
            return y;
          }
          function pu() {
            var u, y;
            return O(), ht(), y = w, b = !1, u = hu(), g.markEnd(g.createProgram(u), y);
          }
          function Rs() {
            var u, y, k, T = [];
            for (u = 0; u < S.tokens.length; ++u)
              y = S.tokens[u], k = {
                type: y.type,
                value: y.value
              }, S.range && (k.range = y.range), S.loc && (k.loc = y.loc), T.push(k);
            S.tokens = T;
          }
          function du(u, y) {
            var k, T, V;
            k = String, typeof u != "string" && !(u instanceof String) && (u = k(u)), g = v, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, y = y || {}, y.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []);
            try {
              if (ht(), w.type === o.EOF)
                return S.tokens;
              for (T = ge(); w.type !== o.EOF; )
                try {
                  T = ge();
                } catch (ne) {
                  if (T = w, S.errors) {
                    S.errors.push(ne);
                    break;
                  } else
                    throw ne;
                }
              Rs(), V = S.tokens, typeof S.comments < "u" && (V.comments = S.comments), typeof S.errors < "u" && (V.errors = S.errors);
            } catch (ne) {
              throw ne;
            } finally {
              S = {};
            }
            return V;
          }
          function fu(u, y) {
            var k, T;
            T = String, typeof u != "string" && !(u instanceof String) && (u = T(u)), g = v, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, typeof y < "u" && (S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, S.attachComment = typeof y.attachComment == "boolean" && y.attachComment, S.loc && y.source !== null && y.source !== void 0 && (S.source = T(y.source)), typeof y.tokens == "boolean" && y.tokens && (S.tokens = []), typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
            try {
              k = pu(), typeof S.comments < "u" && (k.comments = S.comments), typeof S.tokens < "u" && (Rs(), k.tokens = S.tokens), typeof S.errors < "u" && (k.errors = S.errors);
            } catch (V) {
              throw V;
            } finally {
              S = {};
            }
            return k;
          }
          s.version = "1.2.2", s.tokenize = du, s.parse = fu, s.Syntax = function() {
            var u, y = {};
            typeof Object.create == "function" && (y = /* @__PURE__ */ Object.create(null));
            for (u in c)
              c.hasOwnProperty(u) && (y[u] = c[u]);
            return typeof Object.freeze == "function" && Object.freeze(y), y;
          }();
        });
      }, {}], 1: [function(r, n, i) {
        (function(s) {
          var o = function() {
            var a = {
              trace: function() {
              },
              yy: {},
              symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
              terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
              productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
              performAction: function(h, d, v, m, b, f, E) {
                m.ast || (m.ast = l, l.initialize());
                var A = f.length - 1;
                switch (b) {
                  case 1:
                    return m.ast.set({ expression: { type: "root", value: f[A] } }), m.ast.unshift(), m.ast.yield();
                  case 2:
                    return m.ast.set({ expression: { type: "root", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 3:
                    return m.ast.unshift(), m.ast.yield();
                  case 4:
                    return m.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 5:
                    break;
                  case 6:
                    break;
                  case 7:
                    m.ast.set({ operation: "member" }), m.ast.push();
                    break;
                  case 8:
                    m.ast.set({ operation: "subscript" }), m.ast.push();
                    break;
                  case 9:
                    m.ast.set({ scope: "child" });
                    break;
                  case 10:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 11:
                    break;
                  case 12:
                    m.ast.set({ scope: "child", operation: "member" });
                    break;
                  case 13:
                    break;
                  case 14:
                    m.ast.set({ expression: { type: "wildcard", value: f[A] } });
                    break;
                  case 15:
                    m.ast.set({ expression: { type: "identifier", value: f[A] } });
                    break;
                  case 16:
                    m.ast.set({ expression: { type: "script_expression", value: f[A] } });
                    break;
                  case 17:
                    m.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                    break;
                  case 18:
                    break;
                  case 19:
                    m.ast.set({ scope: "child" });
                    break;
                  case 20:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 21:
                    break;
                  case 22:
                    break;
                  case 23:
                    break;
                  case 24:
                    f[A].length > 1 ? m.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                    break;
                  case 25:
                    this.$ = [f[A]];
                    break;
                  case 26:
                    this.$ = f[A - 2].concat(f[A]);
                    break;
                  case 27:
                    this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, m.ast.set(this.$);
                    break;
                  case 28:
                    this.$ = { expression: { type: "string_literal", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 29:
                    this.$ = { expression: { type: "slice", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 30:
                    this.$ = { expression: { type: "wildcard", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 31:
                    this.$ = { expression: { type: "script_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 32:
                    this.$ = { expression: { type: "filter_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 33:
                    this.$ = f[A];
                    break;
                  case 34:
                    this.$ = f[A];
                    break;
                }
              },
              table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
              defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
              parseError: function(h, d) {
                if (d.recoverable)
                  this.trace(h);
                else
                  throw new Error(h);
              },
              parse: function(h) {
                var d = this, v = [0], m = [null], b = [], f = this.table, E = "", A = 0, x = 0, g = 2, w = 1, _ = b.slice.call(arguments, 1);
                this.lexer.setInput(h), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
                var S = this.lexer.yylloc;
                b.push(S);
                var R = this.lexer.options && this.lexer.options.ranges;
                typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
                function L() {
                  var Ie;
                  return Ie = d.lexer.lex() || w, typeof Ie != "number" && (Ie = d.symbols_[Ie] || Ie), Ie;
                }
                for (var F, z, j, W, te = {}, le, ce, Ee, xe; ; ) {
                  if (z = v[v.length - 1], this.defaultActions[z] ? j = this.defaultActions[z] : ((F === null || typeof F > "u") && (F = L()), j = f[z] && f[z][F]), typeof j > "u" || !j.length || !j[0]) {
                    var _e = "";
                    xe = [];
                    for (le in f[z])
                      this.terminals_[le] && le > g && xe.push("'" + this.terminals_[le] + "'");
                    this.lexer.showPosition ? _e = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + xe.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : _e = "Parse error on line " + (A + 1) + ": Unexpected " + (F == w ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(_e, {
                      text: this.lexer.match,
                      token: this.terminals_[F] || F,
                      line: this.lexer.yylineno,
                      loc: S,
                      expected: xe
                    });
                  }
                  if (j[0] instanceof Array && j.length > 1)
                    throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + F);
                  switch (j[0]) {
                    case 1:
                      v.push(F), m.push(this.lexer.yytext), b.push(this.lexer.yylloc), v.push(j[1]), F = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                      break;
                    case 2:
                      if (ce = this.productions_[j[1]][1], te.$ = m[m.length - ce], te._$ = {
                        first_line: b[b.length - (ce || 1)].first_line,
                        last_line: b[b.length - 1].last_line,
                        first_column: b[b.length - (ce || 1)].first_column,
                        last_column: b[b.length - 1].last_column
                      }, R && (te._$.range = [
                        b[b.length - (ce || 1)].range[0],
                        b[b.length - 1].range[1]
                      ]), W = this.performAction.apply(te, [
                        E,
                        x,
                        A,
                        this.yy,
                        j[1],
                        m,
                        b
                      ].concat(_)), typeof W < "u")
                        return W;
                      ce && (v = v.slice(0, -1 * ce * 2), m = m.slice(0, -1 * ce), b = b.slice(0, -1 * ce)), v.push(this.productions_[j[1]][0]), m.push(te.$), b.push(te._$), Ee = f[v[v.length - 2]][v[v.length - 1]], v.push(Ee);
                      break;
                    case 3:
                      return !0;
                  }
                }
                return !0;
              }
            }, l = {
              initialize: function() {
                this._nodes = [], this._node = {}, this._stash = [];
              },
              set: function(h) {
                for (var d in h) this._node[d] = h[d];
                return this._node;
              },
              node: function(h) {
                return arguments.length && (this._node = h), this._node;
              },
              push: function() {
                this._nodes.push(this._node), this._node = {};
              },
              unshift: function() {
                this._nodes.unshift(this._node), this._node = {};
              },
              yield: function() {
                var h = this._nodes;
                return this.initialize(), h;
              }
            }, c = /* @__PURE__ */ function() {
              var h = {
                EOF: 1,
                parseError: function(d, v) {
                  if (this.yy.parser)
                    this.yy.parser.parseError(d, v);
                  else
                    throw new Error(d);
                },
                // resets the lexer, sets new input
                setInput: function(d) {
                  return this._input = d, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                  }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
                },
                // consumes and returns one char from the input
                input: function() {
                  var d = this._input[0];
                  this.yytext += d, this.yyleng++, this.offset++, this.match += d, this.matched += d;
                  var v = d.match(/(?:\r\n?|\n).*/g);
                  return v ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), d;
                },
                // unshifts one char (or a string) into the input
                unput: function(d) {
                  var v = d.length, m = d.split(/(?:\r\n?|\n)/g);
                  this._input = d + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - v - 1), this.offset -= v;
                  var b = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
                  var f = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: m ? (m.length === b.length ? this.yylloc.first_column : 0) + b[b.length - m.length].length - m[0].length : this.yylloc.first_column - v
                  }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - v]), this.yyleng = this.yytext.length, this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function() {
                  return this._more = !0, this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function() {
                  if (this.options.backtrack_lexer)
                    this._backtrack = !0;
                  else
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                      text: "",
                      token: null,
                      line: this.yylineno
                    });
                  return this;
                },
                // retain first n characters of the match
                less: function(d) {
                  this.unput(this.match.slice(d));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function() {
                  var d = this.matched.substr(0, this.matched.length - this.match.length);
                  return (d.length > 20 ? "..." : "") + d.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function() {
                  var d = this.match;
                  return d.length < 20 && (d += this._input.substr(0, 20 - d.length)), (d.substr(0, 20) + (d.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function() {
                  var d = this.pastInput(), v = new Array(d.length + 1).join("-");
                  return d + this.upcomingInput() + `
` + v + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function(d, v) {
                  var m, b, f;
                  if (this.options.backtrack_lexer && (f = {
                    yylineno: this.yylineno,
                    yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                  }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), b = d[0].match(/(?:\r\n?|\n).*/g), b && (this.yylineno += b.length), this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: b ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + d[0].length
                  }, this.yytext += d[0], this.match += d[0], this.matches = d, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(d[0].length), this.matched += d[0], m = this.performAction.call(this, this.yy, this, v, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
                    return m;
                  if (this._backtrack) {
                    for (var E in f)
                      this[E] = f[E];
                    return !1;
                  }
                  return !1;
                },
                // return next match in input
                next: function() {
                  if (this.done)
                    return this.EOF;
                  this._input || (this.done = !0);
                  var d, v, m, b;
                  this._more || (this.yytext = "", this.match = "");
                  for (var f = this._currentRules(), E = 0; E < f.length; E++)
                    if (m = this._input.match(this.rules[f[E]]), m && (!v || m[0].length > v[0].length)) {
                      if (v = m, b = E, this.options.backtrack_lexer) {
                        if (d = this.test_match(m, f[E]), d !== !1)
                          return d;
                        if (this._backtrack) {
                          v = !1;
                          continue;
                        } else
                          return !1;
                      } else if (!this.options.flex)
                        break;
                    }
                  return v ? (d = this.test_match(v, f[b]), d !== !1 ? d : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                },
                // return next match that has a token
                lex: function() {
                  var d = this.next();
                  return d || this.lex();
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function(d) {
                  this.conditionStack.push(d);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function() {
                  var d = this.conditionStack.length - 1;
                  return d > 0 ? this.conditionStack.pop() : this.conditionStack[0];
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function() {
                  return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function(d) {
                  return d = this.conditionStack.length - 1 - Math.abs(d || 0), d >= 0 ? this.conditionStack[d] : "INITIAL";
                },
                // alias for begin(condition)
                pushState: function(d) {
                  this.begin(d);
                },
                // return the number of states currently on the stack
                stateStackSize: function() {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function(d, v, m, b) {
                  switch (m) {
                    case 0:
                      return 4;
                    case 1:
                      return 14;
                    case 2:
                      return 12;
                    case 3:
                      return 15;
                    case 4:
                      return 16;
                    case 5:
                      return 22;
                    case 6:
                      return 24;
                    case 7:
                      return 28;
                    case 8:
                      return 30;
                    case 9:
                      return 18;
                    case 10:
                      return v.yytext = v.yytext.substr(1, v.yyleng - 2), 32;
                    case 11:
                      return v.yytext = v.yytext.substr(1, v.yyleng - 2), 33;
                    case 12:
                      return 17;
                    case 13:
                      return 31;
                  }
                },
                rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
                conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
              };
              return h;
            }();
            a.lexer = c;
            function p() {
              this.yy = {};
            }
            return p.prototype = a, a.Parser = p, new p();
          }();
          typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
            return o.parse.apply(o, arguments);
          }, i.main = function(a) {
            a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
            var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
            return i.parser.parse(l);
          }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
        }).call(this, r("_process"));
      }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
        n.exports = {
          identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
          integer: "-?(?:0|[1-9][0-9]*)",
          qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
          q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
        };
      }, {}], 3: [function(r, n, i) {
        var s = r("./dict"), o = r("fs"), a = {
          lex: {
            macros: {
              esc: "\\\\",
              int: s.integer
            },
            rules: [
              ["\\$", "return 'DOLLAR'"],
              ["\\.\\.", "return 'DOT_DOT'"],
              ["\\.", "return 'DOT'"],
              ["\\*", "return 'STAR'"],
              [s.identifier, "return 'IDENTIFIER'"],
              ["\\[", "return '['"],
              ["\\]", "return ']'"],
              [",", "return ','"],
              ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
              ["{int}", "return 'INTEGER'"],
              [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
              [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
              ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
              ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
            ]
          },
          start: "JSON_PATH",
          bnf: {
            JSON_PATH: [
              ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
              ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
            ],
            PATH_COMPONENTS: [
              ["PATH_COMPONENT", ""],
              ["PATH_COMPONENTS PATH_COMPONENT", ""]
            ],
            PATH_COMPONENT: [
              ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
              ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
            ],
            MEMBER_COMPONENT: [
              ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_MEMBER_COMPONENT: [
              ["DOT MEMBER_EXPRESSION", ""]
            ],
            LEADING_CHILD_MEMBER_EXPRESSION: [
              ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
            ],
            DESCENDANT_MEMBER_COMPONENT: [
              ["DOT_DOT MEMBER_EXPRESSION", ""]
            ],
            MEMBER_EXPRESSION: [
              ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
              ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
              ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
              ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
              ["END", ""]
            ],
            SUBSCRIPT_COMPONENT: [
              ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_SUBSCRIPT_COMPONENT: [
              ["[ SUBSCRIPT ]", ""]
            ],
            DESCENDANT_SUBSCRIPT_COMPONENT: [
              ["DOT_DOT [ SUBSCRIPT ]", ""]
            ],
            SUBSCRIPT: [
              ["SUBSCRIPT_EXPRESSION", ""],
              ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
            ],
            SUBSCRIPT_EXPRESSION_LIST: [
              ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
              ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
            ],
            SUBSCRIPT_EXPRESSION_LISTABLE: [
              ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
              ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
              ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
            ],
            SUBSCRIPT_EXPRESSION: [
              ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
              ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
              ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
            ],
            STRING_LITERAL: [
              ["QQ_STRING", "$$ = $1"],
              ["Q_STRING", "$$ = $1"]
            ]
          }
        };
        o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
      }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
        var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
          return this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.traverse = v(!0), this.descend = v();
        }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
          var g = [x.operation, x.scope, x.expression.type].join("-"), w = this._fns[g];
          if (!w) throw new Error("couldn't resolve key: " + g);
          return w.bind(this);
        }, c.prototype.register = function(x, g) {
          if (!g instanceof Function)
            throw new Error("handler must be a function");
          this._fns[x] = g;
        }, c.prototype._fns = {
          "member-child-identifier": function(x, g) {
            var w = x.expression.value, _ = g.value;
            if (_ instanceof Object && w in _)
              return [{ value: _[w], path: g.path.concat(w) }];
          },
          "member-descendant-identifier": b(function(x, g, w) {
            return x == w;
          }),
          "subscript-child-numeric_literal": m(function(x, g, w) {
            return x === w;
          }),
          "member-child-numeric_literal": m(function(x, g, w) {
            return String(x) === String(w);
          }),
          "subscript-descendant-numeric_literal": b(function(x, g, w) {
            return x === w;
          }),
          "member-child-wildcard": m(function() {
            return !0;
          }),
          "member-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-child-wildcard": m(function() {
            return !0;
          }),
          "subscript-child-slice": function(x, g) {
            if (h(g.value)) {
              var w = x.expression.value.split(":").map(A), _ = g.value.map(function(S, R) {
                return { value: S, path: g.path.concat(R) };
              });
              return o.apply(null, [_].concat(w));
            }
          },
          "subscript-child-union": function(x, g) {
            var w = [];
            return x.expression.value.forEach(function(_) {
              var S = { operation: "subscript", scope: "child", expression: _.expression }, R = this.resolve(S), L = R(S, g);
              L && (w = w.concat(L));
            }, this), E(w);
          },
          "subscript-descendant-union": function(x, g, w) {
            var _ = r(".."), S = this, R = [], L = _.nodes(g, "$..*").slice(1);
            return L.forEach(function(F) {
              R.length >= w || x.expression.value.forEach(function(z) {
                var j = { operation: "subscript", scope: "child", expression: z.expression }, W = S.resolve(j), te = W(j, F);
                R = R.concat(te);
              });
            }), E(R);
          },
          "subscript-child-filter_expression": function(x, g, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.descend(g, null, R, w);
          },
          "subscript-descendant-filter_expression": function(x, g, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.traverse(g, null, R, w);
          },
          "subscript-child-script_expression": function(x, g) {
            var w = x.expression.value.slice(1, -1);
            return p(g, w, "$[{{value}}]");
          },
          "member-child-script_expression": function(x, g) {
            var w = x.expression.value.slice(1, -1);
            return p(g, w, "$.{{value}}");
          },
          "member-descendant-script_expression": function(x, g) {
            var w = x.expression.value.slice(1, -1);
            return p(g, w, "$..value");
          }
        }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
        function p(x, g, w) {
          var _ = r("./index"), S = s.parse(g).body[0].expression, R = f(S, { "@": x.value }), L = w.replace(/\{\{\s*value\s*\}\}/g, R), F = _.nodes(x.value, L);
          return F.forEach(function(z) {
            z.path = x.path.concat(z.path.slice(1));
          }), F;
        }
        function h(x) {
          return Array.isArray(x);
        }
        function d(x) {
          return x && !(x instanceof Array) && x instanceof Object;
        }
        function v(x) {
          return function(g, w, _, S) {
            var R = g.value, L = g.path, F = [], z = (function(j, W) {
              h(j) ? (j.forEach(function(te, le) {
                F.length >= S || _(le, te, w) && F.push({ path: W.concat(le), value: te });
              }), j.forEach(function(te, le) {
                F.length >= S || x && z(te, W.concat(le));
              })) : d(j) && (this.keys(j).forEach(function(te) {
                F.length >= S || _(te, j[te], w) && F.push({ path: W.concat(te), value: j[te] });
              }), this.keys(j).forEach(function(te) {
                F.length >= S || x && z(j[te], W.concat(te));
              }));
            }).bind(this);
            return z(R, L), F;
          };
        }
        function m(x) {
          return function(g, w, _) {
            return this.descend(w, g.expression.value, x, _);
          };
        }
        function b(x) {
          return function(g, w, _) {
            return this.traverse(w, g.expression.value, x, _);
          };
        }
        function f() {
          try {
            return a.apply(this, arguments);
          } catch {
          }
        }
        function E(x) {
          return x = x.filter(function(g) {
            return g;
          }), l(
            x,
            function(g) {
              return g.path.map(function(w) {
                return String(w).replace("-", "--");
              }).join("-");
            }
          );
        }
        function A(x) {
          var g = String(x);
          return g.match(/^-?[0-9]+$/) ? parseInt(g) : null;
        }
        n.exports = c;
      }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
        var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
          this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.parser = new a(), this.handlers = new l();
        }, c.prototype.parse = function(d) {
          return s.ok(p(d), "we need a path"), this.parser.parse(d);
        }, c.prototype.parent = function(d, v) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
          var m = this.nodes(d, v)[0];
          return m.path.pop(), this.value(d, m.path);
        }, c.prototype.apply = function(d, v, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), s.equal(typeof m, "function", "fn needs to be function");
          var b = this.nodes(d, v).sort(function(f, E) {
            return E.path.length - f.path.length;
          });
          return b.forEach(function(f) {
            var E = f.path.pop(), A = this.value(d, this.stringify(f.path)), x = f.value = m.call(d, A[E]);
            A[E] = x;
          }, this), b;
        }, c.prototype.value = function(d, v, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), arguments.length >= 3) {
            var b = this.nodes(d, v).shift();
            if (!b) return this._vivify(d, v, m);
            var f = b.path.slice(-1).shift(), E = this.parent(d, this.stringify(b.path));
            E[f] = m;
          }
          return this.query(d, this.stringify(v), 1).shift();
        }, c.prototype._vivify = function(d, v, m) {
          var b = this;
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
          var f = this.parser.parse(v).map(function(A) {
            return A.expression.value;
          }), E = function(A, x) {
            var g = A.pop(), w = b.value(d, A);
            w || (E(A.concat(), typeof g == "string" ? {} : []), w = b.value(d, A)), w[g] = x;
          };
          return E(f, m), this.query(d, v)[0];
        }, c.prototype.query = function(d, v, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(p(v), "we need a path");
          var b = this.nodes(d, v, m).map(function(f) {
            return f.value;
          });
          return b;
        }, c.prototype.paths = function(d, v, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
          var b = this.nodes(d, v, m).map(function(f) {
            return f.path;
          });
          return b;
        }, c.prototype.nodes = function(d, v, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), m === 0) return [];
          var b = this.parser.parse(v), f = this.handlers, E = [{ path: ["$"], value: d }], A = [];
          return b.length && b[0].expression.type == "root" && b.shift(), b.length ? (b.forEach(function(x, g) {
            if (!(A.length >= m)) {
              var w = f.resolve(x), _ = [];
              E.forEach(function(S) {
                if (!(A.length >= m)) {
                  var R = w(x, S, m);
                  g == b.length - 1 ? A = A.concat(R || []) : _ = _.concat(R || []);
                }
              }), E = _;
            }
          }), m ? A.slice(0, m) : A) : E;
        }, c.prototype.stringify = function(d) {
          s.ok(d, "we need a path");
          var v = "$", m = {
            "descendant-member": "..{{value}}",
            "child-member": ".{{value}}",
            "descendant-subscript": "..[{{value}}]",
            "child-subscript": "[{{value}}]"
          };
          return d = this._normalize(d), d.forEach(function(b) {
            if (b.expression.type != "root") {
              var f = [b.scope, b.operation].join("-"), E = m[f], A;
              if (b.expression.type == "string_literal" ? A = JSON.stringify(b.expression.value) : A = b.expression.value, !E) throw new Error("couldn't find template " + f);
              v += E.replace(/{{value}}/, A);
            }
          }), v;
        }, c.prototype._normalize = function(d) {
          if (s.ok(d, "we need a path"), typeof d == "string")
            return this.parser.parse(d);
          if (Array.isArray(d) && typeof d[0] == "string") {
            var v = [{ expression: { type: "root", value: "$" } }];
            return d.forEach(function(m, b) {
              if (!(m == "$" && b === 0))
                if (typeof m == "string" && m.match("^" + o.identifier + "$"))
                  v.push({
                    operation: "member",
                    scope: "child",
                    expression: { value: m, type: "identifier" }
                  });
                else {
                  var f = typeof m == "number" ? "numeric_literal" : "string_literal";
                  v.push({
                    operation: "subscript",
                    scope: "child",
                    expression: { value: m, type: f }
                  });
                }
            }), v;
          } else if (Array.isArray(d) && typeof d[0] == "object")
            return d;
          throw new Error("couldn't understand path " + d);
        };
        function p(d) {
          return Object.prototype.toString.call(d) == "[object String]";
        }
        c.Handlers = l, c.Parser = a;
        var h = new c();
        h.JSONPath = c, n.exports = h;
      }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
        var s = r("./grammar"), o = r("../generated/parser"), a = function() {
          var l = new o.Parser(), c = l.parseError;
          return l.yy.parseError = function() {
            l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
          }, l;
        };
        a.grammar = s, n.exports = a;
      }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
        n.exports = function(o, a, l, c) {
          if (typeof a == "string") throw new Error("start cannot be a string");
          if (typeof l == "string") throw new Error("end cannot be a string");
          if (typeof c == "string") throw new Error("step cannot be a string");
          var p = o.length;
          if (c === 0) throw new Error("step cannot be zero");
          if (c = c ? s(c) : 1, a = a < 0 ? p + a : a, l = l < 0 ? p + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : p - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? p : -1)), a = c > 0 ? Math.max(0, a) : Math.min(p, a), l = c > 0 ? Math.min(l, p) : Math.max(-1, l), c > 0 && l <= a) return [];
          if (c < 0 && a <= l) return [];
          for (var h = [], d = a; d != l && !(c < 0 && d <= l || c > 0 && d >= l); d += c)
            h.push(o[d]);
          return h;
        };
        function s(o) {
          return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
        }
      }, {}], 8: [function(r, n, i) {
        var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = v;
        l.AssertionError = function(g) {
          this.name = "AssertionError", this.actual = g.actual, this.expected = g.expected, this.operator = g.operator, g.message ? (this.message = g.message, this.generatedMessage = !1) : (this.message = h(this), this.generatedMessage = !0);
          var w = g.stackStartFunction || d;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, w);
          else {
            var _ = new Error();
            if (_.stack) {
              var S = _.stack, R = w.name, L = S.indexOf(`
` + R);
              if (L >= 0) {
                var F = S.indexOf(`
`, L + 1);
                S = S.substring(F + 1);
              }
              this.stack = S;
            }
          }
        }, s.inherits(l.AssertionError, Error);
        function c(g, w) {
          return s.isUndefined(w) ? "" + w : s.isNumber(w) && !isFinite(w) || s.isFunction(w) || s.isRegExp(w) ? w.toString() : w;
        }
        function p(g, w) {
          return s.isString(g) ? g.length < w ? g : g.slice(0, w) : g;
        }
        function h(g) {
          return p(JSON.stringify(g.actual, c), 128) + " " + g.operator + " " + p(JSON.stringify(g.expected, c), 128);
        }
        function d(g, w, _, S, R) {
          throw new l.AssertionError({
            message: _,
            actual: g,
            expected: w,
            operator: S,
            stackStartFunction: R
          });
        }
        l.fail = d;
        function v(g, w) {
          g || d(g, !0, w, "==", l.ok);
        }
        l.ok = v, l.equal = function(g, w, _) {
          g != w && d(g, w, _, "==", l.equal);
        }, l.notEqual = function(g, w, _) {
          g == w && d(g, w, _, "!=", l.notEqual);
        }, l.deepEqual = function(g, w, _) {
          m(g, w) || d(g, w, _, "deepEqual", l.deepEqual);
        };
        function m(g, w) {
          if (g === w)
            return !0;
          if (s.isBuffer(g) && s.isBuffer(w)) {
            if (g.length != w.length) return !1;
            for (var _ = 0; _ < g.length; _++)
              if (g[_] !== w[_]) return !1;
            return !0;
          } else return s.isDate(g) && s.isDate(w) ? g.getTime() === w.getTime() : s.isRegExp(g) && s.isRegExp(w) ? g.source === w.source && g.global === w.global && g.multiline === w.multiline && g.lastIndex === w.lastIndex && g.ignoreCase === w.ignoreCase : !s.isObject(g) && !s.isObject(w) ? g == w : f(g, w);
        }
        function b(g) {
          return Object.prototype.toString.call(g) == "[object Arguments]";
        }
        function f(g, w) {
          if (s.isNullOrUndefined(g) || s.isNullOrUndefined(w) || g.prototype !== w.prototype) return !1;
          if (s.isPrimitive(g) || s.isPrimitive(w))
            return g === w;
          var _ = b(g), S = b(w);
          if (_ && !S || !_ && S)
            return !1;
          if (_)
            return g = o.call(g), w = o.call(w), m(g, w);
          var R = x(g), L = x(w), F, z;
          if (R.length != L.length)
            return !1;
          for (R.sort(), L.sort(), z = R.length - 1; z >= 0; z--)
            if (R[z] != L[z])
              return !1;
          for (z = R.length - 1; z >= 0; z--)
            if (F = R[z], !m(g[F], w[F])) return !1;
          return !0;
        }
        l.notDeepEqual = function(g, w, _) {
          m(g, w) && d(g, w, _, "notDeepEqual", l.notDeepEqual);
        }, l.strictEqual = function(g, w, _) {
          g !== w && d(g, w, _, "===", l.strictEqual);
        }, l.notStrictEqual = function(g, w, _) {
          g === w && d(g, w, _, "!==", l.notStrictEqual);
        };
        function E(g, w) {
          return !g || !w ? !1 : Object.prototype.toString.call(w) == "[object RegExp]" ? w.test(g) : g instanceof w ? !0 : w.call({}, g) === !0;
        }
        function A(g, w, _, S) {
          var R;
          s.isString(_) && (S = _, _ = null);
          try {
            w();
          } catch (L) {
            R = L;
          }
          if (S = (_ && _.name ? " (" + _.name + ")." : ".") + (S ? " " + S : "."), g && !R && d(R, _, "Missing expected exception" + S), !g && E(R, _) && d(R, _, "Got unwanted exception" + S), g && R && _ && !E(R, _) || !g && R)
            throw R;
        }
        l.throws = function(g, w, _) {
          A.apply(this, [!0].concat(o.call(arguments)));
        }, l.doesNotThrow = function(g, w) {
          A.apply(this, [!1].concat(o.call(arguments)));
        }, l.ifError = function(g) {
          if (g)
            throw g;
        };
        var x = Object.keys || function(g) {
          var w = [];
          for (var _ in g)
            a.call(g, _) && w.push(_);
          return w;
        };
      }, { "util/": 11 }], 9: [function(r, n, i) {
        typeof Object.create == "function" ? n.exports = function(s, o) {
          s.super_ = o, s.prototype = Object.create(o.prototype, {
            constructor: {
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : n.exports = function(s, o) {
          s.super_ = o;
          var a = function() {
          };
          a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
        };
      }, {}], 10: [function(r, n, i) {
        n.exports = function(s) {
          return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
        };
      }, {}], 11: [function(r, n, i) {
        (function(s, o) {
          var a = /%[sdj%]/g;
          i.format = function(O) {
            if (!L(O)) {
              for (var N = [], J = 0; J < arguments.length; J++)
                N.push(p(arguments[J]));
              return N.join(" ");
            }
            for (var J = 1, re = arguments, oe = re.length, ee = String(O).replace(a, function(H) {
              if (H === "%%") return "%";
              if (J >= oe) return H;
              switch (H) {
                case "%s":
                  return String(re[J++]);
                case "%d":
                  return Number(re[J++]);
                case "%j":
                  try {
                    return JSON.stringify(re[J++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return H;
              }
            }), ae = re[J]; J < oe; ae = re[++J])
              _(ae) || !W(ae) ? ee += " " + ae : ee += " " + p(ae);
            return ee;
          }, i.deprecate = function(O, N) {
            if (z(o.process))
              return function() {
                return i.deprecate(O, N).apply(this, arguments);
              };
            if (s.noDeprecation === !0)
              return O;
            var J = !1;
            function re() {
              if (!J) {
                if (s.throwDeprecation)
                  throw new Error(N);
                s.traceDeprecation ? console.trace(N) : console.error(N), J = !0;
              }
              return O.apply(this, arguments);
            }
            return re;
          };
          var l = {}, c;
          i.debuglog = function(O) {
            if (z(c) && (c = s.env.NODE_DEBUG || ""), O = O.toUpperCase(), !l[O])
              if (new RegExp("\\b" + O + "\\b", "i").test(c)) {
                var N = s.pid;
                l[O] = function() {
                  var J = i.format.apply(i, arguments);
                  console.error("%s %d: %s", O, N, J);
                };
              } else
                l[O] = function() {
                };
            return l[O];
          };
          function p(O, N) {
            var J = {
              seen: [],
              stylize: d
            };
            return arguments.length >= 3 && (J.depth = arguments[2]), arguments.length >= 4 && (J.colors = arguments[3]), w(N) ? J.showHidden = N : N && i._extend(J, N), z(J.showHidden) && (J.showHidden = !1), z(J.depth) && (J.depth = 2), z(J.colors) && (J.colors = !1), z(J.customInspect) && (J.customInspect = !0), J.colors && (J.stylize = h), m(J, O, J.depth);
          }
          i.inspect = p, p.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, p.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function h(O, N) {
            var J = p.styles[N];
            return J ? "\x1B[" + p.colors[J][0] + "m" + O + "\x1B[" + p.colors[J][1] + "m" : O;
          }
          function d(O, N) {
            return O;
          }
          function v(O) {
            var N = {};
            return O.forEach(function(J, re) {
              N[J] = !0;
            }), N;
          }
          function m(O, N, J) {
            if (O.customInspect && N && ce(N.inspect) && // Filter out the util module, it's inspect function is special
            N.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
            !(N.constructor && N.constructor.prototype === N)) {
              var re = N.inspect(J, O);
              return L(re) || (re = m(O, re, J)), re;
            }
            var oe = b(O, N);
            if (oe)
              return oe;
            var ee = Object.keys(N), ae = v(ee);
            if (O.showHidden && (ee = Object.getOwnPropertyNames(N)), le(N) && (ee.indexOf("message") >= 0 || ee.indexOf("description") >= 0))
              return f(N);
            if (ee.length === 0) {
              if (ce(N)) {
                var me = N.name ? ": " + N.name : "";
                return O.stylize("[Function" + me + "]", "special");
              }
              if (j(N))
                return O.stylize(RegExp.prototype.toString.call(N), "regexp");
              if (te(N))
                return O.stylize(Date.prototype.toString.call(N), "date");
              if (le(N))
                return f(N);
            }
            var H = "", X = !1, Ae = ["{", "}"];
            if (g(N) && (X = !0, Ae = ["[", "]"]), ce(N)) {
              var Re = N.name ? ": " + N.name : "";
              H = " [Function" + Re + "]";
            }
            if (j(N) && (H = " " + RegExp.prototype.toString.call(N)), te(N) && (H = " " + Date.prototype.toUTCString.call(N)), le(N) && (H = " " + f(N)), ee.length === 0 && (!X || N.length == 0))
              return Ae[0] + H + Ae[1];
            if (J < 0)
              return j(N) ? O.stylize(RegExp.prototype.toString.call(N), "regexp") : O.stylize("[Object]", "special");
            O.seen.push(N);
            var Fe;
            return X ? Fe = E(O, N, J, ae, ee) : Fe = ee.map(function(Te) {
              return A(O, N, J, ae, Te, X);
            }), O.seen.pop(), x(Fe, H, Ae);
          }
          function b(O, N) {
            if (z(N))
              return O.stylize("undefined", "undefined");
            if (L(N)) {
              var J = "'" + JSON.stringify(N).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return O.stylize(J, "string");
            }
            if (R(N))
              return O.stylize("" + N, "number");
            if (w(N))
              return O.stylize("" + N, "boolean");
            if (_(N))
              return O.stylize("null", "null");
          }
          function f(O) {
            return "[" + Error.prototype.toString.call(O) + "]";
          }
          function E(O, N, J, re, oe) {
            for (var ee = [], ae = 0, me = N.length; ae < me; ++ae)
              ue(N, String(ae)) ? ee.push(A(
                O,
                N,
                J,
                re,
                String(ae),
                !0
              )) : ee.push("");
            return oe.forEach(function(H) {
              H.match(/^\d+$/) || ee.push(A(
                O,
                N,
                J,
                re,
                H,
                !0
              ));
            }), ee;
          }
          function A(O, N, J, re, oe, ee) {
            var ae, me, H;
            if (H = Object.getOwnPropertyDescriptor(N, oe) || { value: N[oe] }, H.get ? H.set ? me = O.stylize("[Getter/Setter]", "special") : me = O.stylize("[Getter]", "special") : H.set && (me = O.stylize("[Setter]", "special")), ue(re, oe) || (ae = "[" + oe + "]"), me || (O.seen.indexOf(H.value) < 0 ? (_(J) ? me = m(O, H.value, null) : me = m(O, H.value, J - 1), me.indexOf(`
`) > -1 && (ee ? me = me.split(`
`).map(function(X) {
              return "  " + X;
            }).join(`
`).substr(2) : me = `
` + me.split(`
`).map(function(X) {
              return "   " + X;
            }).join(`
`))) : me = O.stylize("[Circular]", "special")), z(ae)) {
              if (ee && oe.match(/^\d+$/))
                return me;
              ae = JSON.stringify("" + oe), ae.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ae = ae.substr(1, ae.length - 2), ae = O.stylize(ae, "name")) : (ae = ae.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ae = O.stylize(ae, "string"));
            }
            return ae + ": " + me;
          }
          function x(O, N, J) {
            var re = O.reduce(function(oe, ee) {
              return ee.indexOf(`
`) >= 0, oe + ee.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return re > 60 ? J[0] + (N === "" ? "" : N + `
 `) + " " + O.join(`,
  `) + " " + J[1] : J[0] + N + " " + O.join(", ") + " " + J[1];
          }
          function g(O) {
            return Array.isArray(O);
          }
          i.isArray = g;
          function w(O) {
            return typeof O == "boolean";
          }
          i.isBoolean = w;
          function _(O) {
            return O === null;
          }
          i.isNull = _;
          function S(O) {
            return O == null;
          }
          i.isNullOrUndefined = S;
          function R(O) {
            return typeof O == "number";
          }
          i.isNumber = R;
          function L(O) {
            return typeof O == "string";
          }
          i.isString = L;
          function F(O) {
            return typeof O == "symbol";
          }
          i.isSymbol = F;
          function z(O) {
            return O === void 0;
          }
          i.isUndefined = z;
          function j(O) {
            return W(O) && xe(O) === "[object RegExp]";
          }
          i.isRegExp = j;
          function W(O) {
            return typeof O == "object" && O !== null;
          }
          i.isObject = W;
          function te(O) {
            return W(O) && xe(O) === "[object Date]";
          }
          i.isDate = te;
          function le(O) {
            return W(O) && (xe(O) === "[object Error]" || O instanceof Error);
          }
          i.isError = le;
          function ce(O) {
            return typeof O == "function";
          }
          i.isFunction = ce;
          function Ee(O) {
            return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || // ES6 symbol
            typeof O > "u";
          }
          i.isPrimitive = Ee, i.isBuffer = r("./support/isBuffer");
          function xe(O) {
            return Object.prototype.toString.call(O);
          }
          function _e(O) {
            return O < 10 ? "0" + O.toString(10) : O.toString(10);
          }
          var Ie = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function je() {
            var O = /* @__PURE__ */ new Date(), N = [
              _e(O.getHours()),
              _e(O.getMinutes()),
              _e(O.getSeconds())
            ].join(":");
            return [O.getDate(), Ie[O.getMonth()], N].join(" ");
          }
          i.log = function() {
            console.log("%s - %s", je(), i.format.apply(i, arguments));
          }, i.inherits = r("inherits"), i._extend = function(O, N) {
            if (!N || !W(N)) return O;
            for (var J = Object.keys(N), re = J.length; re--; )
              O[J[re]] = N[J[re]];
            return O;
          };
          function ue(O, N) {
            return Object.prototype.hasOwnProperty.call(O, N);
          }
        }).call(this, r("_process"), typeof F7 < "u" ? F7 : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
      }, {}], 13: [function(r, n, i) {
        (function(s) {
          function o(p, h) {
            for (var d = 0, v = p.length - 1; v >= 0; v--) {
              var m = p[v];
              m === "." ? p.splice(v, 1) : m === ".." ? (p.splice(v, 1), d++) : d && (p.splice(v, 1), d--);
            }
            if (h)
              for (; d--; d)
                p.unshift("..");
            return p;
          }
          i.resolve = function() {
            for (var p = "", h = !1, d = arguments.length - 1; d >= -1 && !h; d--) {
              var v = d >= 0 ? arguments[d] : s.cwd();
              if (typeof v != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              v && (p = v + "/" + p, h = v.charAt(0) === "/");
            }
            return p = o(l(p.split("/"), function(m) {
              return !!m;
            }), !h).join("/"), (h ? "/" : "") + p || ".";
          }, i.normalize = function(p) {
            var h = i.isAbsolute(p), d = c(p, -1) === "/";
            return p = o(l(p.split("/"), function(v) {
              return !!v;
            }), !h).join("/"), !p && !h && (p = "."), p && d && (p += "/"), (h ? "/" : "") + p;
          }, i.isAbsolute = function(p) {
            return p.charAt(0) === "/";
          }, i.join = function() {
            var p = Array.prototype.slice.call(arguments, 0);
            return i.normalize(l(p, function(h, d) {
              if (typeof h != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return h;
            }).join("/"));
          }, i.relative = function(p, h) {
            p = i.resolve(p).substr(1), h = i.resolve(h).substr(1);
            function d(x) {
              for (var g = 0; g < x.length && x[g] === ""; g++)
                ;
              for (var w = x.length - 1; w >= 0 && x[w] === ""; w--)
                ;
              return g > w ? [] : x.slice(g, w - g + 1);
            }
            for (var v = d(p.split("/")), m = d(h.split("/")), b = Math.min(v.length, m.length), f = b, E = 0; E < b; E++)
              if (v[E] !== m[E]) {
                f = E;
                break;
              }
            for (var A = [], E = f; E < v.length; E++)
              A.push("..");
            return A = A.concat(m.slice(f)), A.join("/");
          }, i.sep = "/", i.delimiter = ":", i.dirname = function(p) {
            if (typeof p != "string" && (p = p + ""), p.length === 0) return ".";
            for (var h = p.charCodeAt(0), d = h === 47, v = -1, m = !0, b = p.length - 1; b >= 1; --b)
              if (h = p.charCodeAt(b), h === 47) {
                if (!m) {
                  v = b;
                  break;
                }
              } else
                m = !1;
            return v === -1 ? d ? "/" : "." : d && v === 1 ? "/" : p.slice(0, v);
          };
          function a(p) {
            typeof p != "string" && (p = p + "");
            var h = 0, d = -1, v = !0, m;
            for (m = p.length - 1; m >= 0; --m)
              if (p.charCodeAt(m) === 47) {
                if (!v) {
                  h = m + 1;
                  break;
                }
              } else d === -1 && (v = !1, d = m + 1);
            return d === -1 ? "" : p.slice(h, d);
          }
          i.basename = function(p, h) {
            var d = a(p);
            return h && d.substr(-1 * h.length) === h && (d = d.substr(0, d.length - h.length)), d;
          }, i.extname = function(p) {
            typeof p != "string" && (p = p + "");
            for (var h = -1, d = 0, v = -1, m = !0, b = 0, f = p.length - 1; f >= 0; --f) {
              var E = p.charCodeAt(f);
              if (E === 47) {
                if (!m) {
                  d = f + 1;
                  break;
                }
                continue;
              }
              v === -1 && (m = !1, v = f + 1), E === 46 ? h === -1 ? h = f : b !== 1 && (b = 1) : h !== -1 && (b = -1);
            }
            return h === -1 || v === -1 || // We saw a non-dot character immediately before the dot
            b === 0 || // The (right-most) trimmed path component is exactly '..'
            b === 1 && h === v - 1 && h === d + 1 ? "" : p.slice(h, v);
          };
          function l(p, h) {
            if (p.filter) return p.filter(h);
            for (var d = [], v = 0; v < p.length; v++)
              h(p[v], v, p) && d.push(p[v]);
            return d;
          }
          var c = "ab".substr(-1) === "b" ? function(p, h, d) {
            return p.substr(h, d);
          } : function(p, h, d) {
            return h < 0 && (h = p.length + h), p.substr(h, d);
          };
        }).call(this, r("_process"));
      }, { _process: 14 }], 14: [function(r, n, i) {
        var s = n.exports = {}, o, a;
        function l() {
          throw new Error("setTimeout has not been defined");
        }
        function c() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? o = setTimeout : o = l;
          } catch {
            o = l;
          }
          try {
            typeof clearTimeout == "function" ? a = clearTimeout : a = c;
          } catch {
            a = c;
          }
        })();
        function p(g) {
          if (o === setTimeout)
            return setTimeout(g, 0);
          if ((o === l || !o) && setTimeout)
            return o = setTimeout, setTimeout(g, 0);
          try {
            return o(g, 0);
          } catch {
            try {
              return o.call(null, g, 0);
            } catch {
              return o.call(this, g, 0);
            }
          }
        }
        function h(g) {
          if (a === clearTimeout)
            return clearTimeout(g);
          if ((a === c || !a) && clearTimeout)
            return a = clearTimeout, clearTimeout(g);
          try {
            return a(g);
          } catch {
            try {
              return a.call(null, g);
            } catch {
              return a.call(this, g);
            }
          }
        }
        var d = [], v = !1, m, b = -1;
        function f() {
          !v || !m || (v = !1, m.length ? d = m.concat(d) : b = -1, d.length && E());
        }
        function E() {
          if (!v) {
            var g = p(f);
            v = !0;
            for (var w = d.length; w; ) {
              for (m = d, d = []; ++b < w; )
                m && m[b].run();
              b = -1, w = d.length;
            }
            m = null, v = !1, h(g);
          }
        }
        s.nextTick = function(g) {
          var w = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var _ = 1; _ < arguments.length; _++)
              w[_ - 1] = arguments[_];
          d.push(new A(g, w)), d.length === 1 && !v && p(E);
        };
        function A(g, w) {
          this.fun = g, this.array = w;
        }
        A.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
        function x() {
        }
        s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(g) {
          return [];
        }, s.binding = function(g) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(g) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 15: [function(r, n, i) {
        var s = r("escodegen").generate;
        n.exports = function(o, a) {
          a || (a = {});
          var l = {}, c = function p(h, d) {
            if (h.type === "Literal")
              return h.value;
            if (h.type === "UnaryExpression") {
              var v = p(h.argument);
              return h.operator === "+" ? +v : h.operator === "-" ? -v : h.operator === "~" ? ~v : h.operator === "!" ? !v : l;
            } else if (h.type === "ArrayExpression") {
              for (var m = [], b = 0, f = h.elements.length; b < f; b++) {
                var E = p(h.elements[b]);
                if (E === l) return l;
                m.push(E);
              }
              return m;
            } else if (h.type === "ObjectExpression") {
              for (var A = {}, b = 0; b < h.properties.length; b++) {
                var x = h.properties[b], g = x.value === null ? x.value : p(x.value);
                if (g === l) return l;
                A[x.key.value || x.key.name] = g;
              }
              return A;
            } else if (h.type === "BinaryExpression" || h.type === "LogicalExpression") {
              var f = p(h.left);
              if (f === l) return l;
              var w = p(h.right);
              if (w === l) return l;
              var _ = h.operator;
              return _ === "==" ? f == w : _ === "===" ? f === w : _ === "!=" ? f != w : _ === "!==" ? f !== w : _ === "+" ? f + w : _ === "-" ? f - w : _ === "*" ? f * w : _ === "/" ? f / w : _ === "%" ? f % w : _ === "<" ? f < w : _ === "<=" ? f <= w : _ === ">" ? f > w : _ === ">=" ? f >= w : _ === "|" ? f | w : _ === "&" ? f & w : _ === "^" ? f ^ w : _ === "&&" ? f && w : _ === "||" ? f || w : l;
            } else {
              if (h.type === "Identifier")
                return {}.hasOwnProperty.call(a, h.name) ? a[h.name] : l;
              if (h.type === "ThisExpression")
                return {}.hasOwnProperty.call(a, "this") ? a.this : l;
              if (h.type === "CallExpression") {
                var S = p(h.callee);
                if (S === l || typeof S != "function") return l;
                var R = h.callee.object ? p(h.callee.object) : l;
                R === l && (R = null);
                for (var L = [], b = 0, f = h.arguments.length; b < f; b++) {
                  var E = p(h.arguments[b]);
                  if (E === l) return l;
                  L.push(E);
                }
                return S.apply(R, L);
              } else if (h.type === "MemberExpression") {
                var A = p(h.object);
                if (A === l || typeof A == "function")
                  return l;
                if (h.property.type === "Identifier")
                  return A[h.property.name];
                var x = p(h.property);
                return x === l ? l : A[x];
              } else if (h.type === "ConditionalExpression") {
                var v = p(h.test);
                return v === l ? l : p(v ? h.consequent : h.alternate);
              } else if (h.type === "ExpressionStatement") {
                var v = p(h.expression);
                return v === l ? l : v;
              } else {
                if (h.type === "ReturnStatement")
                  return p(h.argument);
                if (h.type === "FunctionExpression") {
                  var F = h.body.body, z = {};
                  Object.keys(a).forEach(function(Ie) {
                    z[Ie] = a[Ie];
                  });
                  for (var b = 0; b < h.params.length; b++) {
                    var j = h.params[b];
                    if (j.type == "Identifier")
                      a[j.name] = null;
                    else return l;
                  }
                  for (var b in F)
                    if (p(F[b]) === l)
                      return l;
                  a = z;
                  var W = Object.keys(a), te = W.map(function(Ie) {
                    return a[Ie];
                  });
                  return Function(W.join(", "), "return " + s(h)).apply(null, te);
                } else if (h.type === "TemplateLiteral") {
                  for (var le = "", b = 0; b < h.expressions.length; b++)
                    le += p(h.quasis[b]), le += p(h.expressions[b]);
                  return le += p(h.quasis[b]), le;
                } else if (h.type === "TaggedTemplateExpression") {
                  var ce = p(h.tag), Ee = h.quasi, xe = Ee.quasis.map(p), _e = Ee.expressions.map(p);
                  return ce.apply(null, [xe].concat(_e));
                } else return h.type === "TemplateElement" ? h.value.cooked : l;
              }
            }
          }(o);
          return c === l ? void 0 : c;
        };
      }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
        n.exports = r("./lib/index");
      }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
    });
  }(X7)), X7.exports;
}
xpe();
const Epe = "https://fizz.studio/schema/manifest.schema.json", Spe = {
  $id: Epe
};
Spe.$id;
function Ape(t) {
  const e = t.datasets[0];
  if (e.data.source !== "inline")
    throw new Error("only manifests with inline data can use this function.");
  const r = {};
  for (const n of e.series)
    r[n.key] = n.records;
  return r;
}
function Yn(t) {
  return t.replace(/\W+/g, "_").toLowerCase();
}
const o4 = {
  line: "line",
  stepline: "line",
  bar: "bar",
  column: "bar",
  lollipop: "bar",
  histogram: "histogram",
  scatter: "scatter",
  heatmap: "scatter",
  pie: "pastry",
  donut: "pastry",
  graph: "graph"
};
(() => {
  const t = {
    line: [],
    bar: [],
    pastry: [],
    scatter: [],
    histogram: [],
    graph: []
  };
  for (let e of Object.keys(o4))
    t[o4[e]].push(e);
  return t;
})();
function t_(t) {
  return o4[t] === "pastry";
}
var zD = (t) => {
  throw TypeError(t);
}, UD = (t, e, r) => e.has(t) || zD("Cannot " + r), r_ = (t, e, r) => (UD(t, e, "read from private field"), r ? r.call(t) : e.get(t)), n_ = (t, e, r) => e.has(t) ? zD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), i_ = (t, e, r, n) => (UD(t, e, "write to private field"), e.set(t, r), r);
const jy = "[a-fA-F0-9]", Td = "[a-zA-Z0-9-._~]", ao = "[!$&'()*+,;=]", $h = `%${jy}${jy}`, Bm = "(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])", K5 = `${Bm}\\.${Bm}\\.${Bm}\\.${Bm}`, Mr = `${jy}{1,4}`, Eu = `(?:${Mr}:${Mr}|${K5})`, kpe = `(?:(?:${Mr}:){6}${Eu}|::(?:${Mr}:){5}${Eu}|(?:${Mr})?::(?:${Mr}:){4}${Eu}|(?:(?:${Mr}:){0,1}${Mr})?::(?:${Mr}:){3}${Eu}|(?:(?:${Mr}:){0,2}${Mr})?::(?:${Mr}:){2}${Eu}|(?:(?:${Mr}:){0,3}${Mr})?::(?:${Mr}:){1}${Eu}|(?:(?:${Mr}:){0,4}${Mr})?::${Eu}|(?:(?:${Mr}:){0,5}${Mr})?::${Mr}|(?:(?:${Mr}:){0,6}${Mr})?::)`, _pe = `v${jy}+\\.(?:${Td}|${ao}|:)+`, VD = `\\[(?:${kpe}|${_pe})\\]`, Ld = "(?<scheme>[a-zA-Z][a-zA-Z0-9-+.]*)", HD = ":(?<port>\\d*)", Cpe = `(?:${Td}|${$h}|${ao})*?`, Ipe = `(?<host>${VD}|${K5}|${Cpe})`, Ppe = `(?<userinfo>(?:${Td}|${$h}|${ao}|:)*)`, Y5 = `(?:${Td}|${$h}|${ao}|:|@)`, GD = `${Y5}*?`, WD = `(?:/${GD})*`, Z5 = `(?<authority>(?:${Ppe}@)?${Ipe}(?:${HD})?)`, J5 = `(?<path>${WD})`, X5 = `(?<path2>${GD}${WD})`, eS = `(?:\\?(?<query>(?:${Y5}|/|\\?)*))?`, qD = `(?:#(?<fragment>(?:${Y5}|/|\\?)*))?`, Rpe = `^${Ld}:(?://${Z5}${J5}|${X5})${eS}${qD}$`, Ope = `^(?:${Ld}:|)(?://${Z5}${J5}|${X5})${eS}${qD}$`, Tpe = `^${Ld}:(?://${Z5}${J5}|${X5})${eS}$`, $g = "[a-zA-Z0-9-._~\\00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF\\u10000-\\u1FFFD\\u20000-\\u2FFFD\\u30000-\\u3FFFD\\u40000-\\u4FFFD\\u50000-\\u5FFFD\\u60000-\\u6FFFD\\u70000-\\u7FFFD\\u80000-\\u8FFFD\\u90000-\\u9FFFD\\uA0000-\\uAFFFD\\uB0000-\\uBFFFD\\uC0000-\\uCFFFD\\uD0000-\\uDFFFD\\uE1000-\\uEFFFD]", Lpe = "[\\uE000-\\uF8FF\\uF0000-\\uFFFFD\\u100000-\\u10FFFD]", Mpe = `(?:${$g}|${$h}|${ao})*?`, Npe = `(?<host>${VD}|${K5}|${Mpe})`, Dpe = `(?<userinfo>(?:${$g}|${$h}|${ao}|:)*)`, tS = `(?:${$g}|${$h}|${ao}|:|@)`, QD = `${tS}*?`, KD = `(?:/${QD})*`, rS = `(?<authority>(?:${Dpe}@)?${Npe}(?:${HD})?)`, nS = `(?<path>${KD})`, iS = `(?<path2>${QD}${KD})`, sS = `(?:\\?(?<query>(?:${tS}|${Lpe}|/|\\?)*))?`, YD = `(?:#(?<fragment>(?:${tS}|/|\\?)*))?`, ZD = `^${Ld}:(?://${rS}${nS}|${iS})${sS}${YD}$`, JD = `^(?:${Ld}:|)(?://${rS}${nS}|${iS})${sS}${YD}$`, XD = `^${Ld}:(?://${rS}${nS}|${iS})${sS}$`, $pe = (t) => (e, r) => {
  const n = (
    /** @type IdentifierComponents */
    t.parseReference(e)
  );
  if (n.scheme === void 0) {
    const i = t.parseAbsolute(r);
    n.scheme = i.scheme, n.authority === void 0 && (n.authority = i.authority, n.path === "" ? (n.path = i.path, n.query === void 0 && (n.query = i.query)) : n.path.startsWith("/") || (n.path = jpe(n.path, i)));
  }
  return e$(t, n);
}, jpe = (t, e) => {
  if (e.authority && e.path === "")
    return "/" + t;
  {
    const r = e.path.lastIndexOf("/");
    return r === -1 ? t : e.path.slice(0, r + 1) + t;
  }
}, Bpe = /^\.?\.\/|^\.\.?$/, Fpe = /^\/\.(?:\/|$)/, zpe = /^\/\.\.(?:\/|$)/, Upe = (t) => {
  let e = "";
  for (; t.length > 0; )
    if (Bpe.test(t))
      t = s_(t);
    else if (Fpe.test(t))
      t = o_(t);
    else if (zpe.test(t))
      t = o_(t), e = Vpe(e);
    else {
      const r = Hpe(t);
      t = s_(t), e += r;
    }
  return e;
}, s_ = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "" : "/" + t.slice(e + 1);
}, o_ = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? "/" : "/" + t.slice(e + 1);
}, Vpe = (t) => {
  const e = t.lastIndexOf("/");
  return e === -1 ? t : t.slice(0, e);
}, Hpe = (t) => {
  const e = t.indexOf("/", 1);
  return e === -1 ? t : t.slice(0, e);
}, e$ = (t, e) => {
  let r = e.scheme.toLowerCase() + ":";
  return r += e.authority === void 0 ? "" : "//" + e.authority.toLowerCase(), r += t.normalizePath(e.path), r += e.query === void 0 ? "" : "?" + t.normalizeQuery(e.query), r += e.fragment === void 0 ? "" : "#" + t.normalizeFragment(e.fragment), r;
}, t$ = new RegExp($h, "g"), r$ = (t) => (e) => {
  const r = parseInt(e.slice(1), 16), n = String.fromCharCode(r);
  return t(n) ? n : e.toUpperCase();
};
RegExp.prototype.test.bind(new RegExp(`${Td}|${ao}|[:@]`));
const Gpe = RegExp.prototype.test.bind(new RegExp(`${$g}|${ao}|[:@]`)), Wpe = (t) => (e) => Upe(e).replaceAll(t$, r$(t));
RegExp.prototype.test.bind(new RegExp(`${Td}|${ao}|[:@/?]`));
const a_ = RegExp.prototype.test.bind(new RegExp(`${$g}|${ao}|[:@/?]`)), l_ = (t) => (e) => e.replaceAll(t$, r$(t));
RegExp.prototype.test.bind(new RegExp(Rpe));
RegExp.prototype.test.bind(new RegExp(Ope));
RegExp.prototype.test.bind(new RegExp(Tpe));
RegExp.prototype.test.bind(new RegExp(ZD));
RegExp.prototype.test.bind(new RegExp(JD));
RegExp.prototype.test.bind(new RegExp(XD));
const oS = (t, e) => (r) => {
  const n = t.exec(r);
  if (n === null)
    throw Error(`Invalid ${e}: ${r}`);
  const i = (
    /** @type Record<string, string> */
    n.groups
  );
  return i.authority === void 0 && (i.path = i.path2), delete i.path2, /** @type A */
  i;
}, aS = (
  /** @type Parser<IdentifierComponents> */
  oS(new RegExp(ZD), "IRI")
), n$ = (
  /** @type Parser<RelativeIdentifierComponents> */
  oS(new RegExp(JD), "IRI-reference")
), qpe = (
  /** @type Parser<AbsoluteIdentifierComponents> */
  oS(new RegExp(XD), "absolute-IRI")
), i$ = {
  iri: {
    parseAbsolute: qpe,
    parseReference: n$,
    parse: aS,
    normalizePath: Wpe(Gpe),
    normalizeQuery: l_(a_),
    normalizeFragment: l_(a_)
  }
}, Qpe = (t) => (e) => {
  const r = t.parse(e);
  return delete r.fragment, e$(t, r);
}, Yu = Qpe(i$.iri), O0 = $pe(i$.iri), Kpe = "", a4 = function* (t) {
  if (t.length > 0 && t[0] !== "/")
    throw Error("Invalid JSON Pointer");
  let e = 1, r = 0;
  for (; r < t.length; ) {
    const n = t.indexOf("/", e);
    r = n === -1 ? t.length : n;
    const i = t.slice(e, r);
    e = r + 1, yield Jpe(i);
  }
}, Ype = (t, e = void 0) => {
  if (e === void 0) {
    const r = [...a4(t)];
    return (n) => c_(r, n);
  } else
    return c_(a4(t), e);
}, c_ = (t, e) => {
  let r = Kpe;
  for (const n of t)
    e = ede(e, n, r), r = mh(n, r);
  return e;
}, mh = (t, e) => e + "/" + Zpe(t), Zpe = (t) => t.toString().replace(/~/g, "~0").replace(/\//g, "~1"), Jpe = (t) => t.toString().replace(/~1/g, "/").replace(/~0/g, "~"), Xpe = (t, e) => Array.isArray(t) && e === "-" ? t.length : e, ede = (t, e, r = "") => {
  if (t === void 0)
    throw TypeError(`Value at '${r}' is undefined and does not have property '${e}'`);
  if (t === null)
    throw TypeError(`Value at '${r}' is null and does not have property '${e}'`);
  if (tde(t))
    throw TypeError(`Value at '${r}' is a ${typeof t} and does not have property '${e}'`);
  {
    const n = Xpe(t, e);
    return t[n];
  }
}, tde = (t) => t === null || typeof t != "object", s$ = (t) => {
  const e = typeof t;
  switch (e) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JSON compatible type: ${r}`);
    }
  }
}, o$ = (t) => {
  const e = t.indexOf("#"), r = e === -1 ? t.length : e;
  return t.slice(0, r);
}, a$ = (t) => decodeURIComponent(n$(t).fragment || ""), By = {}, Rv = (t) => {
  if (t.indexOf("#") !== -1) {
    const e = o$(t);
    return { ...By[e], id: t };
  }
  return By[t];
}, rde = (t, e) => {
  const r = nde(t, e);
  if (!r)
    throw Error(`Encountered unknown keyword '${t}'`);
  const n = Rv(r);
  if (!n)
    throw Error(`Encountered unsupported keyword ${t}. You can provide an implementation for the '${r}' keyword using the 'addKeyword' function.`);
  return n;
}, ct = (t) => {
  By[t.id] = t;
}, l4 = {}, Rc = (t, e) => {
  l4[t] = e;
}, Yf = {}, c4 = {}, Ow = {}, nde = (t, e) => {
  var r;
  return ((r = l$(e)) == null ? void 0 : r[t]) || (c4[e] || t.startsWith("x-")) && `https://json-schema.org/keyword/unknown#${t}`;
}, Xr = (t, e) => {
  const r = l$(t);
  for (const n in r)
    if (r[n] === e)
      return n;
}, l$ = (t) => {
  if (!(t in Yf))
    throw Error(`Encountered unknown dialect '${t}'`);
  return Yf[t];
}, c$ = (t, e, r = !1, n = !0) => {
  c4[t] = r, Ow[t] = Ow[t] || n, Yf[t] = {}, Object.entries(e).forEach(([i, s]) => {
    if (i in l4)
      Object.entries(l4[i]).forEach(([o, a]) => {
        !(a in By) && !s && (a = `https://json-schema.org/keyword/unknown#${o}`), Yf[t][o] = a;
      });
    else if (!r || s)
      throw delete Yf[t], delete c4[t], delete Ow[t], Error(`Unrecognized vocabulary: ${i}. You can define this vocabulary with the 'defineVocabulary' function.`);
  });
};
var u_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function u$(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Fm = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var h_;
function ide() {
  if (h_) return Fm;
  h_ = 1;
  var t = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, e = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, n = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  Fm.format = o, Fm.parse = a;
  function o(h) {
    if (!h || typeof h != "object")
      throw new TypeError("argument obj is required");
    var d = h.parameters, v = h.type;
    if (!v || !s.test(v))
      throw new TypeError("invalid type");
    var m = v;
    if (d && typeof d == "object")
      for (var b, f = Object.keys(d).sort(), E = 0; E < f.length; E++) {
        if (b = f[E], !r.test(b))
          throw new TypeError("invalid parameter name");
        m += "; " + b + "=" + c(d[b]);
      }
    return m;
  }
  function a(h) {
    if (!h)
      throw new TypeError("argument string is required");
    var d = typeof h == "object" ? l(h) : h;
    if (typeof d != "string")
      throw new TypeError("argument string is required to be a string");
    var v = d.indexOf(";"), m = v !== -1 ? d.slice(0, v).trim() : d.trim();
    if (!s.test(m))
      throw new TypeError("invalid media type");
    var b = new p(m.toLowerCase());
    if (v !== -1) {
      var f, E, A;
      for (t.lastIndex = v; E = t.exec(d); ) {
        if (E.index !== v)
          throw new TypeError("invalid parameter format");
        v += E[0].length, f = E[1].toLowerCase(), A = E[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(n, "$1"))), b.parameters[f] = A;
      }
      if (v !== d.length)
        throw new TypeError("invalid parameter format");
    }
    return b;
  }
  function l(h) {
    var d;
    if (typeof h.getHeader == "function" ? d = h.getHeader("content-type") : typeof h.headers == "object" && (d = h.headers && h.headers["content-type"]), typeof d != "string")
      throw new TypeError("content-type header is missing from object");
    return d;
  }
  function c(h) {
    var d = String(h);
    if (r.test(d))
      return d;
    if (d.length > 0 && !e.test(d))
      throw new TypeError("invalid parameter value");
    return '"' + d.replace(i, "\\$1") + '"';
  }
  function p(h) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = h;
  }
  return Fm;
}
var h$ = ide();
const sde = /* @__PURE__ */ u$(h$), T0 = {}, p$ = (t, e) => {
  T0[t] = e;
}, ode = (t) => {
  const e = t.headers.get("content-type");
  if (e === null)
    throw new pde("The media type of the response could not be determined. Make sure the response includes a 'Content-Type' header.", { cause: t });
  const r = h$.parse(e);
  for (const n in T0)
    if (cde(n, r.type))
      return T0[n].parse(t);
  throw new hde(r.type, `'${r.type}' is not supported. Use the 'addMediaTypePlugin' function to add support for this media type.`, {
    cause: t
  });
}, ade = "A-Za-z", Tw = `[!#$%&'*\\-_.^\`|~\\d${ade}]+`, lde = `(?<type>${Tw})/(?<subType>${Tw}(?:\\+(?<suffix>${Tw}))?)`, p_ = new RegExp(lde), cde = (t, e) => {
  var r, n;
  if (t === e)
    return !0;
  const i = (r = p_.exec(t)) == null ? void 0 : r.groups;
  if (!i)
    throw Error(`Unable to parse media-range: ${t}`);
  const s = (n = p_.exec(e)) == null ? void 0 : n.groups;
  if (!s)
    throw Error(`Unable to parse media-type: ${e}`);
  return (i.type === s.type || i.type === "*") && (i.subType === s.subType || i.subType === "*" || i.subType === s.suffix);
}, ude = () => {
  let t = "";
  for (const e in T0)
    t = d_(t, e, T0[e].quality);
  return d_(t, "*/*", "0.001");
}, d_ = (t, e, r) => (t.length > 0 && (t += ", "), t += e, r && (t += `; q=${r}`), t);
let hde = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.mediaType = e;
  }
}, pde = class extends Error {
  constructor(e = void 0) {
    super(e), this.name = this.constructor.name;
  }
};
const dde = (t, e = void 0) => JSON.parse(t, (r, n) => {
  const i = n !== null && typeof n.$ref == "string" ? new $u(n.$ref) : n;
  return e ? e(r, i) : i;
});
var k1, _1;
let $u = class {
  constructor(e, r = void 0) {
    n_(this, k1), n_(this, _1), i_(this, k1, e), i_(this, _1, r ?? { $ref: e });
  }
  get href() {
    return r_(this, k1);
  }
  toJSON() {
    return r_(this, _1);
  }
};
k1 = /* @__PURE__ */ new WeakMap(), _1 = /* @__PURE__ */ new WeakMap();
const d$ = (t) => {
  const e = typeof t;
  switch (e) {
    case "bigint":
      return "number";
    case "number":
    case "string":
    case "boolean":
    case "undefined":
      return e;
    case "object":
      if (t instanceof $u)
        return "reference";
      if (Array.isArray(t))
        return "array";
      if (t === null)
        return "null";
      if (Object.getPrototypeOf(t) === Object.prototype || Object.getPrototypeOf(t) === null)
        return "object";
    default: {
      const r = e === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : e;
      throw Error(`Not a JRef compatible type: ${r}`);
    }
  }
}, fde = {
  parse: async (t) => ({
    baseUri: t.url,
    root: dde(await t.text()),
    anchorLocation: gde
  }),
  fileMatcher: (t) => /[^/]\.jref$/.test(t)
}, gde = (t) => decodeURI(t || ""), u4 = {}, f$ = (t, e) => {
  u4[t] = e;
}, mde = (t, e) => {
  t = O0(t, e);
  const { scheme: r } = aS(t);
  if (!(r in u4))
    throw new yde(r, `The '${r}:' URI scheme is not supported. Use the 'addUriSchemePlugin' function to add support for '${r}:' URIs.`);
  return u4[r].retrieve(t, e);
};
let yde = class extends Error {
  constructor(e, r = void 0) {
    super(r), this.name = this.constructor.name, this.scheme = e;
  }
};
const vde = /* @__PURE__ */ new Set([200, 203]), bde = async (t) => {
  const e = await fetch(t, { headers: { Accept: ude() } });
  if (e.status >= 400)
    throw new f_(e, `Failed to retrieve '${t}'`);
  if (!vde.has(e.status))
    throw new f_(e, "Unsupported HTTP response status code");
  return e;
}, g$ = { retrieve: bde };
let f_ = class extends Error {
  constructor(e, r = void 0) {
    super(`${e.status} ${e.statusText}${r ? ` -- ${r}` : ""}`), this.name = this.constructor.name, this.response = e;
  }
};
var m$ = wde;
function wde(t, e) {
  return function r() {
    e == null && (e = t.length);
    var n = [].slice.call(arguments);
    return n.length >= e ? t.apply(this, n) : function() {
      return r.apply(this, n.concat([].slice.call(arguments)));
    };
  };
}
const xde = () => {
  var t, e;
  return ((e = (t = globalThis.document) == null ? void 0 : t.location) == null ? void 0 : e.toString()) ?? "";
}, Ov = async (t, e = { _cache: {} }) => {
  var r, n, i;
  const s = ((r = e.document) == null ? void 0 : r.baseUri) ?? xde();
  t = O0(t, s);
  const o = Yu(t), { fragment: a } = aS(t), l = e._cache[o] ?? ((i = (n = e.document) == null ? void 0 : n.embedded) == null ? void 0 : i[o]);
  if (l)
    e.document = l, e.uri = t, e.cursor = e.document.anchorLocation(a);
  else {
    try {
      const c = await mde(t, s);
      e.document = await ode(c), e.uri = c.url + (a === void 0 ? "" : `#${a}`), e.cursor = e.document.anchorLocation(a);
    } catch (c) {
      const p = e.uri ? ` Referenced from '${e.uri}'.` : "";
      throw new Sde(`Unable to load resource '${t}'.${p}`, c);
    }
    e._cache[o] = e.document;
  }
  return e._value = Ype(e.cursor, e.document.root), y$(e);
}, y$ = (t) => d$(Pt(t)) === "reference" ? Ov(Pt(t).href, t) : t, Pt = (t) => t._value, Na = (t) => d$(t._value), v$ = (t, e) => t in e._value, b$ = (t) => t._value.length, Qs = m$((t, e) => y$({
  ...e,
  cursor: mh(`${t}`, e.cursor),
  _value: e._value[t]
})), Oc = async function* (t) {
  for (let e = 0; e < Pt(t).length; e++)
    yield Qs(e, t);
}, h4 = function* (t) {
  for (const e in Pt(t))
    yield e;
}, Ede = async function* (t) {
  for (const e in Pt(t))
    yield Qs(e, t);
}, yh = async function* (t) {
  for (const e in Pt(t))
    yield [e, await Qs(e, t)];
};
let Sde = class extends Error {
  constructor(e, r) {
    super(e, { cause: r }), this.name = this.constructor.name;
  }
};
p$("application/reference+json", fde);
f$("http", g$);
f$("https", g$);
const Ade = {
  parse: async (t) => {
    const e = sde.parse(t.headers.get("content-type") ?? ""), r = e.parameters.schema ?? e.parameters.profile;
    return zy(await t.json(), t.url, r);
  },
  fileMatcher: async (t) => /(\.|\/)schema\.json$/.test(t)
}, Fy = {}, kde = async (t, e = void 0) => {
  e || (e = { _cache: {} });
  for (const n in Fy)
    n in e._cache || (e._cache[n] = Fy[n]);
  const r = await Ov(t, { ...e });
  if (typeof r.document.dialectId != "string")
    throw Error(`The document at ${r.document.baseUri} is not a schema.`);
  return r;
}, Ya = (t, e, r) => {
  t = structuredClone(t);
  const n = zy(t, e, r);
  if (n.baseUri in Fy)
    throw Error(`A schema has already been registered for '${n.baseUri}. You can use 'unregisterSchema' to remove the old schema before registering the new one.`);
  if (n.baseUri.startsWith("file:"))
    throw Error(`Registering a schema with a 'file:' URI scheme is not allowed: ${n.baseUri}`);
  Fy[n.baseUri] = n;
}, zy = (t, e, r, n = {}) => {
  if (typeof t.$schema == "string" && (r = t.$schema, delete t.$schema), !r)
    throw Error("Unable to determine a dialect for the schema. The dialect can be declared in a number of ways, but the recommended way is to use the '$schema' keyword in your schema.");
  r = Yu(r);
  const i = Xr(r, "https://json-schema.org/keyword/draft-04/id"), s = Xr(r, "https://json-schema.org/keyword/id") || i;
  if (!t[s] && !e)
    throw Error(`Unable to determine an identifier for the schema. Use the '${s}' keyword or pass a retrievalUri when loading the schema.`);
  const o = O0(t[s] ?? "", e ?? "");
  e = Yu(o), i && o.length > e.length ? t[s] = "#" + a$(o) : delete t[s];
  const a = Xr(r, "https://json-schema.org/keyword/vocabulary");
  if (s$(t[a]) === "object") {
    const h = t[a]["https://json-schema.org/draft/2019-09/vocab/core"] || t[a]["https://json-schema.org/draft/2020-12/vocab/core"];
    c$(e, t[a], h, !1), delete t[a];
  }
  const l = { "": "" }, c = {}, p = Xr(r, "https://json-schema.org/keyword/draft-2019-09/recursiveAnchor");
  return t[p] === !0 && (c[""] = `${e}#`), delete t[p], n[e] = {
    baseUri: e,
    dialectId: r,
    root: p4(t, e, r, "", n, l, c),
    anchorLocation: (h) => {
      if (h === void 0)
        return "";
      if (h = decodeURI(h), h[0] === "/")
        return h;
      if (h in l)
        return l[h];
      throw Error(`No such anchor '${e}#${encodeURI(h)}'`);
    },
    anchors: l,
    dynamicAnchors: c,
    embedded: n
  }, n[e];
}, p4 = (t, e, r, n, i, s, o) => {
  if (s$(t) === "object") {
    const a = typeof t.$schema == "string" ? Yu(t.$schema) : r, l = Xr(a, "https://json-schema.org/keyword/id");
    if (typeof t[l] == "string") {
      const m = Yu(O0(t[l], e));
      return t[l] = m, i[m] = zy(t, m, a, i), new $u(m, {});
    }
    const c = Xr(a, "https://json-schema.org/keyword/draft-04/id");
    if (typeof t[c] == "string")
      if (t[c][0] === "#") {
        const m = decodeURIComponent(t[c].slice(1));
        s[m] = n, delete t[c];
      } else {
        const m = Yu(O0(t[c], e));
        return t[c] = m, i[m] = zy(t, m, a, i), new $u(m, {});
      }
    const p = Xr(r, "https://json-schema.org/keyword/draft-04/ref");
    if (typeof t[p] == "string")
      return new $u(t[p], t);
    const h = Xr(r, "https://json-schema.org/keyword/anchor");
    typeof t[h] == "string" && (s[t[h]] = n, delete t[h]);
    const d = Xr(r, "https://json-schema.org/keyword/dynamicAnchor");
    typeof t[d] == "string" && (o[t[d]] = `${e}#${encodeURI(n)}`, delete t[d]);
    const v = Xr(r, "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor");
    typeof t[v] == "string" && (o[t[v]] = `${e}#${encodeURI(n)}`, s[t[v]] = n, delete t[v]);
    for (const m in t) {
      const b = Xr(r, "https://json-schema.org/keyword/ref");
      m === b && typeof t[m] == "string" ? t[m] = new $u(t[m], t[m]) : t[m] = p4(t[m], e, r, mh(m, n), i, s, o);
    }
  } else if (Array.isArray(t))
    for (let a = 0; a < t.length; a++)
      t[a] = p4(t[a], e, r, mh(a, n), i, s, o);
  return t;
}, Kp = (t) => `${t.document.baseUri}#${encodeURI(t.cursor)}`, Md = (
  /** @type API.curry */
  (t) => (...e) => {
    const r = t.length === 1 ? (
      /** @type Extract<typeof fn, (a: any) => any> */
      t(e[0])
    ) : t(e[0], e[1]), n = (
      /** @type I */
      e[t.length]
    );
    return n === void 0 ? r : r(n);
  }
), w$ = Md((t) => function* (e) {
  for (const r of e)
    yield t(r);
}), Zn = Md((t) => async function* (e) {
  for await (const r of e)
    yield t(r);
}), x$ = Md((t) => function* (e) {
  for (const r of e)
    t(r) && (yield r);
}), _de = Md((t) => function* (e) {
  let r = 0;
  for (const n of e)
    r++ >= t && (yield n);
}), Cde = (t) => {
  const e = A$(t).next();
  return e.done ? void 0 : e.value;
}, E$ = function* (t, e) {
  for (let r = t; e === void 0; r++)
    yield r;
}, g_ = function* () {
}, lS = function* (t, e) {
  const r = A$(e);
  for (const n of t)
    yield [n, r.next().value];
}, Ide = function* (...t) {
  for (const e of t)
    yield* e;
}, S$ = (
  /** @type API.reduce */
  Md(
    // eslint-disable-next-line @stylistic/no-extra-parens
    /** @type API.reduce */
    (t, e) => (r) => {
      for (const n of r)
        e = t(
          e,
          /** @type any */
          n
        );
      return e;
    }
  )
), lo = async (t) => {
  const e = [];
  for await (const r of t)
    e.push(r);
  return e;
}, Pde = (t) => {
  const e = /* @__PURE__ */ new Set();
  for (const r of t)
    e.add(r);
  return e;
}, d4 = async (t) => {
  const e = /* @__PURE__ */ Object.create(null);
  for await (const [r, n] of t)
    e[r] = n;
  return e;
}, Rde = Md((t) => (e) => {
  let r = Cde(e) ?? "";
  for (const n of e)
    r += t + n;
  return r;
}), A$ = (t) => {
  if (typeof (t == null ? void 0 : t[Symbol.iterator]) == "function")
    return t[Symbol.iterator]();
  throw TypeError("`iter` is not iterable");
}, vn = (
  /** @type (acc: any, ...fns: ((a: any) => any)[]) => any */
  (t, ...e) => S$((r, n) => n(r), t, e)
), C1 = (t, e = "", r = "", n = void 0) => {
  const i = typeof t;
  switch (i) {
    case "number":
    case "string":
    case "boolean":
      return xf(e, r, t, i, [], n);
    case "object":
      if (t === null)
        return xf(e, r, t, "null", [], n);
      if (Array.isArray(t)) {
        const s = xf(e, r, t, "array", [], n);
        return s.children = t.map((o, a) => C1(o, e, mh(a, r), s)), s;
      } else if (Object.getPrototypeOf(t) === Object.prototype) {
        const s = xf(e, r, t, "object", [], n);
        return s.children = Object.entries(t).map((o) => {
          const a = mh(o[0], r), l = xf(e, a, void 0, "property", [], s);
          return l.children = o.map((c) => C1(c, e, a, l)), l;
        }), s;
      } else if (t instanceof $u)
        return C1(t.toJSON(), e, r, n);
    default: {
      const s = i === "object" ? Object.getPrototypeOf(t).constructor.name || "anonymous" : i;
      throw Error(`Not a JSON compatible type: ${s}`);
    }
  }
}, xf = (t, e, r, n, i, s) => {
  const o = {
    baseUri: t ? Yu(t) : "",
    pointer: e,
    value: r,
    type: n,
    children: i,
    parent: s,
    valid: !0,
    errors: {},
    annotations: {}
  };
  return o.root = (s == null ? void 0 : s.root) ?? o, o;
}, Ode = (t) => `${t.baseUri}#${encodeURI(t.pointer)}`, _r = (t) => t.value, Wt = (t) => t.type, Yp = (t, e) => t in e.value, jh = function* (t) {
  t.type === "array" && (yield* t.children);
}, cS = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      yield e.children[0];
}, Tde = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children[1] && (yield e.children[1]);
}, Tc = function* (t) {
  if (t.type === "object")
    for (const e of t.children)
      e.children.length === 2 && (yield e.children);
}, jg = (t) => {
  if (t.type === "array")
    return t.children.length;
}, f4 = function* (t) {
  switch (yield t, Wt(t)) {
    case "object":
      for (const e of Tde(t))
        yield* f4(e);
      break;
    case "array":
      for (const e of jh(t))
        yield* f4(e);
      break;
  }
}, Mp = {};
let Lde = 0;
const Mde = (t, e) => {
  t in Mp || (Mp[t] = {});
  const r = `pubsub_subscription_${Lde++}`;
  return Mp[t][r] = e, r;
}, Nde = async (t, e) => {
  const r = [];
  for (const n in Mp)
    if (n === t || t.startsWith(`${n}.`))
      for (const i in Mp[n])
        r.push(Mp[t][i](t, e));
  await Promise.all(r);
};
let k$;
const Dde = () => k$, $de = (t) => {
  k$ = t;
};
let jde = class extends Error {
  constructor(e) {
    super("Invalid Schema"), this.name = this.constructor.name, this.output = e;
  }
};
const _$ = "https://json-schema.org/evaluation/validate", Bde = async (t, e) => {
  await Nde("validate.metaValidate", t), t.document.baseUri in e.metaData || (e.metaData[t.document.baseUri] = {
    dynamicAnchors: t.document.dynamicAnchors
  });
  const r = Kp(t);
  if (!(r in e)) {
    e[r] = !1;
    const n = Pt(t);
    if (!["object", "boolean"].includes(typeof n))
      throw Error(`No schema found at '${r}'`);
    e[r] = typeof n == "boolean" ? n : await vn(
      yh(t),
      Zn(async ([i, s]) => {
        const o = rde(i, t.document.dialectId), a = await o.compile(s, e, t);
        return [o.id, mh(i, Kp(t)), a];
      }),
      lo
    );
  }
  return r;
}, Fde = (t, e, r, n, i = !1) => {
  n = { ...r.metaData[o$(t)].dynamicAnchors, ...n };
  let s = !0;
  if (typeof r[t] == "boolean")
    s = r[t];
  else
    for (const [o, a, l] of r[t])
      e.valid = Rv(o).interpret(l, e, r, n, i, t), e.valid || (i || (e.errors[a] = o), s = !1);
  return s || (e.errors[t] = _$), e.valid = s, s;
}, zde = /* @__PURE__ */ new Set(), Ude = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedProperties")
      continue;
    const l = Rv(o), c = "collectEvaluatedProperties" in l ? l.collectEvaluatedProperties(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && zde;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, Vde = /* @__PURE__ */ new Set(), Hde = (t, e, r, n, i = !1) => {
  if (typeof r[t] == "boolean")
    return r[t] ? /* @__PURE__ */ new Set() : !1;
  const s = /* @__PURE__ */ new Set();
  for (const [o, , a] of r[t]) {
    if (i && o === "https://json-schema.org/keyword/unevaluatedItems")
      continue;
    const l = Rv(o), c = "collectEvaluatedItems" in l ? l.collectEvaluatedItems(a, e, r, n, i) : l.interpret(a, e, r, n, !0) && Vde;
    if (c === !1)
      return !1;
    c.forEach(s.add, s);
  }
  return s;
}, Ge = { id: _$, compile: Bde, interpret: Fde, collectEvaluatedProperties: Ude, collectEvaluatedItems: Hde }, Uy = {}, Gde = (t, e) => {
  if (e in Uy)
    return Uy[e](t);
  throw Error(`The '${e}' error format is not supported`);
};
Uy.FLAG = (t) => ({ valid: t.valid });
Uy.BASIC = (t) => {
  const e = {
    valid: t.valid
  };
  if (!t.valid) {
    e.errors = [];
    for (const r of f4(t))
      for (const [n, i] of Object.entries(r.errors).reverse())
        i !== "https://json-schema.org/evaluation/validate" && !r.valid && e.errors.unshift({
          keyword: i,
          absoluteKeywordLocation: n,
          instanceLocation: Ode(r),
          valid: r.valid
        });
  }
  return e;
};
const C$ = "FLAG";
$de(C$);
const Wde = async (t) => {
  const e = { metaData: {} }, r = await Ge.compile(t, e);
  return { ast: e, schemaUri: r };
}, qde = m$(({ ast: t, schemaUri: e }, r, n = C$) => (Ge.interpret(e, r, t, {}), Gde(r, n))), Lw = {};
Mde("validate.metaValidate", async (t, e) => {
  if (!e.document.validated) {
    if (e.document.validated = !0, !(e.document.dialectId in Lw)) {
      const i = await kde(e.document.dialectId, e), s = await Wde(i);
      Lw[e.document.dialectId] = qde(s);
    }
    const r = C1(e.document.root, e.document.baseUri), n = Lw[e.document.dialectId](r, Dde());
    if (!n.valid)
      throw new jde(n);
  }
});
const Qde = "https://json-schema.org/keyword/additionalProperties", Kde = async (t, e, r) => {
  const n = Xr(t.document.dialectId, "https://json-schema.org/keyword/properties"), i = await Qs(n, r), s = Na(i) === "object" ? w$((p) => "^" + Yde(p) + "$", h4(i)) : g_(), o = Xr(t.document.dialectId, "https://json-schema.org/keyword/patternProperties"), a = await Qs(o, r), l = Na(a) === "object" ? h4(a) : g_(), c = vn(
    Ide(s, l),
    Rde("|")
  ) || "(?!)";
  return [new RegExp(c, "u"), await Ge.compile(t, e)];
}, Yde = (t) => t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), Zde = ([t, e], r, n, i, s) => {
  if (Wt(r) !== "object")
    return !0;
  let o = !0;
  for (const [a, l] of Tc(r)) {
    const c = _r(a);
    !t.test(c) && !Ge.interpret(e, l, n, i, s) && (o = !1);
  }
  return o;
}, Jde = ([t, e], r, n, i) => {
  if (Wt(r) !== "object")
    return !0;
  const s = /* @__PURE__ */ new Set();
  for (const [o, a] of Tc(r)) {
    const l = _r(o);
    if (!t.test(l)) {
      if (!Ge.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, Xde = { id: Qde, compile: Kde, interpret: Zde, collectEvaluatedProperties: Jde }, efe = "https://json-schema.org/keyword/allOf", tfe = (t, e) => vn(
  Oc(t),
  Zn((r) => Ge.compile(r, e)),
  lo
), rfe = (t, e, r, n, i) => {
  let s = !0;
  for (const o of t)
    Ge.interpret(o, e, r, n, i) || (s = !1);
  return s;
}, nfe = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = Ge.collectEvaluatedProperties(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, ife = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s of t) {
    const o = Ge.collectEvaluatedItems(s, e, r, n);
    if (!o)
      return !1;
    o.forEach(i.add, i);
  }
  return i;
}, sfe = { id: efe, compile: tfe, interpret: rfe, collectEvaluatedProperties: nfe, collectEvaluatedItems: ife }, ofe = { id: "https://json-schema.org/keyword/anchor" }, afe = "https://json-schema.org/keyword/anyOf", lfe = (t, e) => vn(
  Oc(t),
  Zn((r) => Ge.compile(r, e)),
  lo
), cfe = (t, e, r, n, i) => t.filter((s) => Ge.interpret(s, e, r, n, i)).length > 0, ufe = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ge.collectEvaluatedProperties(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, hfe = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ge.collectEvaluatedItems(s, e, r, n);
    o && (i || (i = /* @__PURE__ */ new Set()), o.forEach(i.add, i));
  }
  return i;
}, pfe = { id: afe, compile: lfe, interpret: cfe, collectEvaluatedProperties: ufe, collectEvaluatedItems: hfe }, dfe = "https://json-schema.org/keyword/conditional", ffe = (t, e) => vn(
  Oc(t),
  I$,
  Zn((r) => Ge.compile(r, e)),
  lo
), gfe = (t, e, r, n, i) => {
  for (let s = 0; s < t.length; s += 2) {
    const o = Ge.interpret(t[s], e, r, n, i);
    if (s + 1 === t.length)
      return o;
    if (o)
      return Ge.interpret(t[s + 1], e, r, n, i);
  }
  return !0;
}, mfe = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = Ge.collectEvaluatedProperties(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return Ge.collectEvaluatedProperties(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, yfe = (t, e, r, n) => {
  for (let i = 0; i < t.length; i += 2) {
    const s = Ge.collectEvaluatedItems(t[i], e, r, n);
    if (i + 1 === t.length)
      return s;
    if (s !== !1)
      return Ge.collectEvaluatedItems(t[i + 1], e, r, n);
  }
  return /* @__PURE__ */ new Set();
}, I$ = async function* (t, e = 1) {
  for await (const r of t)
    e > 0 && Na(r) === "array" ? yield* I$(Oc(r), e - 1) : yield r;
}, vfe = { id: dfe, compile: ffe, interpret: gfe, collectEvaluatedProperties: mfe, collectEvaluatedItems: yfe };
var m_, y_;
function bfe() {
  return y_ || (y_ = 1, m_ = {
    space: "",
    cycles: !1,
    replacer: (t, e) => e,
    stringify: JSON.stringify
  }), m_;
}
var v_, b_;
function Su() {
  return b_ || (b_ = 1, v_ = {
    isArray: Array.isArray,
    assign: Object.assign,
    isObject: (t) => typeof t == "object",
    isFunction: (t) => typeof t == "function",
    isBoolean: (t) => typeof t == "boolean",
    isRegex: (t) => t instanceof RegExp,
    keys: Object.keys
  }), v_;
}
var Mw, w_;
function wfe() {
  if (w_) return Mw;
  w_ = 1;
  const t = bfe(), e = Su().isFunction, r = Su().isBoolean, n = Su().isObject, i = Su().isArray, s = Su().isRegex, o = Su().assign, a = Su().keys;
  function l(p) {
    return p == null ? p : s(p) ? p.toString() : p.toJSON ? p.toJSON() : p;
  }
  function c(p, h) {
    h = h || o({}, t), e(h) && (h = { compare: h });
    const d = h.space || t.space, v = r(h.cycles) ? h.cycles : t.cycles, m = h.replacer || t.replacer, b = h.stringify || t.stringify, f = h.compare && /* @__PURE__ */ function(A) {
      return function(x) {
        return function(g, w) {
          const _ = { key: g, value: x[g] }, S = { key: w, value: x[w] };
          return A(_, S);
        };
      };
    }(h.compare);
    v || b(p);
    const E = [];
    return function A(x, g, w, _) {
      const S = d ? `
` + new Array(_ + 1).join(d) : "", R = d ? ": " : ":";
      if (w = l(w), w = m.call(x, g, w), w !== void 0) {
        if (!n(w) || w === null) return b(w);
        if (i(w)) {
          const L = [];
          for (let F = 0; F < w.length; F++) {
            const z = A(w, F, w[F], _ + 1) || b(null);
            L.push(S + d + z);
          }
          return "[" + L.join(",") + S + "]";
        } else {
          if (v) {
            if (E.indexOf(w) !== -1)
              return b("[Circular]");
            E.push(w);
          }
          const L = a(w).sort(f && f(w)), F = [];
          for (let z = 0; z < L.length; z++) {
            const j = L[z], W = A(w, j, w[j], _ + 1);
            if (!W) continue;
            const te = b(j) + R + W;
            F.push(S + d + te);
          }
          return E.splice(E.indexOf(w), 1), "{" + F.join(",") + S + "}";
        }
      }
    }({ "": p }, "", p, 0);
  }
  return Mw = c, Mw;
}
var xfe = wfe();
const Bg = /* @__PURE__ */ u$(xfe), Efe = "https://json-schema.org/keyword/const", Sfe = (t) => Bg(Pt(t)), Afe = (t, e) => Bg(_r(e)) === t, kfe = { id: Efe, compile: Sfe, interpret: Afe }, _fe = "https://json-schema.org/keyword/contains", Cfe = async (t, e, r) => {
  const n = await Ge.compile(t, e), i = Xr(t.document.dialectId, "https://json-schema.org/keyword/minContains"), s = await Qs(i, r), o = Na(s) === "number" ? Pt(s) : 1, a = Xr(t.document.dialectId, "https://json-schema.org/keyword/maxContains"), l = await Qs(a, r), c = Na(l) === "number" ? Pt(l) : Number.MAX_SAFE_INTEGER;
  return { contains: n, minContains: o, maxContains: c };
}, P$ = ({ contains: t, minContains: e, maxContains: r }, n, i, s, o) => {
  const a = Wt(n) !== "array" || vn(
    jh(n),
    x$((l) => Ge.interpret(t, l, i, s, o)),
    S$((l) => l + 1, 0)
  );
  return a >= e && a <= r;
}, Ife = (t, e, r, n) => P$(t, e, r, n, !0) && Wt(e) === "array" && vn(
  lS(jh(e), E$(0)),
  x$(([i]) => Ge.interpret(t.contains, i, r, n, !0)),
  w$(([, i]) => i),
  Pde
), Pfe = { id: _fe, compile: Cfe, interpret: P$, collectEvaluatedItems: Ife }, Rfe = "https://json-schema.org/keyword/comment", Ofe = () => {
}, Tfe = () => !0, Lfe = { id: Rfe, compile: Ofe, interpret: Tfe }, Cs = (t, e, r, n) => {
  e in t.annotations || (t.annotations[e] = {}), t.annotations[e][r] = n;
}, R$ = "https://json-schema.org/keyword/contentEncoding", Mfe = (t) => Pt(t), Nfe = (t, e, r, n, i, s) => (Cs(e, R$, s, t), !0), Dfe = { id: R$, compile: Mfe, interpret: Nfe }, O$ = "https://json-schema.org/keyword/contentMediaType", $fe = (t) => Pt(t), jfe = (t, e, r, n, i, s) => (Cs(e, O$, s, t), !0), Bfe = { id: O$, compile: $fe, interpret: jfe }, T$ = "https://json-schema.org/keyword/contentSchema", Ffe = (t) => Kp(t), zfe = (t, e, r, n, i, s) => (Cs(e, T$, s, t), !0), Ufe = { id: T$, compile: Ffe, interpret: zfe }, L$ = "https://json-schema.org/keyword/default", Vfe = (t) => Pt(t), Hfe = (t, e, r, n, i, s) => (Cs(e, L$, s, t), !0), Gfe = { id: L$, compile: Vfe, interpret: Hfe }, Wfe = "https://json-schema.org/keyword/definitions", qfe = (t, e) => vn(
  Ede(t),
  Zn((r) => Ge.compile(r, e)),
  lo
), Qfe = () => !0, Kfe = { id: Wfe, compile: qfe, interpret: Qfe }, Yfe = "https://json-schema.org/keyword/dependentRequired", Zfe = (t) => vn(
  yh(t),
  Zn(([e, r]) => [e, Pt(r)]),
  lo
), Jfe = (t, e) => {
  if (Wt(e) !== "object")
    return !0;
  let r = !0;
  for (const [n, i] of t)
    Yp(n, e) && !i.every((s) => Yp(s, e)) && (r = !1);
  return r;
}, Xfe = { id: Yfe, compile: Zfe, interpret: Jfe }, e0e = "https://json-schema.org/keyword/dependentSchemas", t0e = (t, e) => vn(
  yh(t),
  Zn(async ([r, n]) => [r, await Ge.compile(n, e)]),
  lo
), r0e = (t, e, r, n, i) => {
  if (Wt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    Yp(o, e) && !Ge.interpret(a, e, r, n, i) && (s = !1);
  return s;
}, n0e = (t, e, r, n) => {
  if (Wt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    if (Yp(s, e)) {
      const a = Ge.collectEvaluatedProperties(o, e, r, n);
      if (a === !1)
        return !1;
      a.forEach(Set.prototype.add.bind(i));
    }
  return i;
}, i0e = { id: e0e, compile: t0e, interpret: r0e, collectEvaluatedProperties: n0e }, M$ = "https://json-schema.org/keyword/deprecated", s0e = (t) => Pt(t), o0e = (t, e, r, n, i, s) => (Cs(e, M$, s, t), !0), a0e = { id: M$, compile: s0e, interpret: o0e }, N$ = "https://json-schema.org/keyword/description", l0e = (t) => Pt(t), c0e = (t, e, r, n, i, s) => (Cs(e, N$, s, t), !0), u0e = { id: N$, compile: l0e, interpret: c0e }, h0e = { id: "https://json-schema.org/keyword/dynamicAnchor" }, p0e = "https://json-schema.org/keyword/dynamicRef", d0e = async (t, e) => {
  const r = Pt(t), n = await Ov(t.document.baseUri, t);
  return await Ge.compile(n, e), r;
}, uS = (t, e, r, n, i, s) => {
  if (!(e in i))
    throw Error(`No dynamic anchor found for "${e}"`);
  return t(i[e], r, n, i, s);
}, f0e = (...t) => uS(Ge.interpret, ...t), g0e = (...t) => uS(Ge.collectEvaluatedProperties, ...t), m0e = (...t) => uS(Ge.collectEvaluatedItems, ...t), y0e = { id: p0e, compile: d0e, interpret: f0e, collectEvaluatedProperties: g0e, collectEvaluatedItems: m0e }, v0e = "https://json-schema.org/keyword/else", b0e = async (t, e, r) => {
  const n = Xr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (v$(n, r)) {
    const i = await Qs(n, r);
    return [await Ge.compile(i, e), await Ge.compile(t, e)];
  } else
    return [];
}, w0e = ([t, e], r, n, i, s) => t === void 0 || Ge.interpret(t, r, n, i, !0) || Ge.interpret(e, r, n, i, s), x0e = ([t, e], r, n, i) => t === void 0 || Ge.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ge.collectEvaluatedProperties(e, r, n, i), E0e = ([t, e], r, n, i) => t === void 0 || Ge.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ge.collectEvaluatedItems(e, r, n, i), S0e = { id: v0e, compile: b0e, interpret: w0e, collectEvaluatedProperties: x0e, collectEvaluatedItems: E0e }, A0e = "https://json-schema.org/keyword/enum", k0e = (t) => vn(
  Oc(t),
  Zn(Pt),
  Zn(Bg),
  lo
), _0e = (t, e) => {
  const r = Bg(_r(e));
  return t.some((n) => r === n);
}, C0e = { id: A0e, compile: k0e, interpret: _0e }, D$ = "https://json-schema.org/keyword/examples", I0e = (t) => Pt(t), P0e = (t, e, r, n, i, s) => (Cs(e, D$, s, t), !0), R0e = { id: D$, compile: I0e, interpret: P0e }, O0e = "https://json-schema.org/keyword/exclusiveMaximum", T0e = (t) => Pt(t), L0e = (t, e) => Wt(e) !== "number" || _r(e) < t, M0e = { id: O0e, compile: T0e, interpret: L0e }, N0e = "https://json-schema.org/keyword/exclusiveMinimum", D0e = (t) => Pt(t), $0e = (t, e) => Wt(e) !== "number" || _r(e) > t, j0e = { id: N0e, compile: D0e, interpret: $0e }, $$ = "https://json-schema.org/keyword/format", B0e = (t) => Pt(t), F0e = (t, e, r, n, i, s) => (Cs(e, $$, s, t), !0), z0e = { id: $$, compile: B0e, interpret: F0e }, U0e = { id: "https://json-schema.org/keyword/id" }, V0e = "https://json-schema.org/keyword/if", H0e = (t, e) => Ge.compile(t, e), G0e = (t, e, r, n) => (Ge.interpret(t, e, r, n, !0), !0), W0e = (t, e, r, n) => Ge.collectEvaluatedProperties(t, e, r, n) || [], q0e = (t, e, r, n) => Ge.collectEvaluatedItems(t, e, r, n) || /* @__PURE__ */ new Set(), Q0e = { id: V0e, compile: H0e, interpret: G0e, collectEvaluatedProperties: W0e, collectEvaluatedItems: q0e }, K0e = () => {
  const t = gs(!1), e = gs(!0);
  return In(t, e), { start: t, end: e };
}, Y0e = (t) => {
  const e = gs(!1), r = gs(!0);
  return rge(e, r, t), { start: e, end: r };
}, Z0e = (t, e) => t === void 0 ? e : (In(t.end, e.start), t.end.isEnd = !1, { start: t.start, end: e.end }), J0e = (t, e) => {
  const r = gs(!1);
  In(r, t.start), In(r, e.start);
  const n = gs(!0);
  return In(t.end, n), t.end.isEnd = !1, In(e.end, n), e.end.isEnd = !1, { start: r, end: n };
}, X0e = (t) => {
  const e = gs(!1), r = gs(!0);
  return In(e, r), In(e, t.start), In(t.end, r), In(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, ege = (t) => {
  const e = gs(!1), r = gs(!0);
  return In(e, r), In(e, t.start), In(t.end, r), t.end.isEnd = !1, { start: e, end: r };
}, tge = (t) => {
  const e = gs(!1), r = gs(!0);
  return In(e, t.start), In(t.end, r), In(t.end, t.start), t.end.isEnd = !1, { start: e, end: r };
}, In = (t, e) => {
  t.epsilonTransitions.push(e);
}, rge = (t, e, r) => {
  t.transition[r] = e;
}, gs = (t) => ({
  isEnd: t,
  transition: {},
  epsilonTransitions: []
}), nge = "https://json-schema.org/keyword/itemPattern", j$ = async (t, e) => {
  const r = [[]];
  let n = r[0];
  for await (const i of Oc(t))
    if (Na(i) === "string") {
      const s = Pt(i);
      if (s === "*")
        n.push(X0e(n.pop()));
      else if (s === "?")
        n.push(ege(n.pop()));
      else if (s === "+")
        n.push(tge(n.pop()));
      else if (s === "|")
        n = [], r.push(n);
      else
        throw Error(`Unsupported pattern syntax: ${s}`);
    } else {
      const s = Na(i) === "array" ? j$(i, e) : Y0e(await Ge.compile(i, e));
      n.push(await s);
    }
  return b$(t) === 0 ? K0e() : r.map((i) => i.reduce(Z0e)).reduce(J0e);
}, hS = (t) => (e, r, n, i, s) => {
  if (Wt(r) !== "array")
    return !0;
  let o = [];
  g4(e.start, o, []);
  for (const a of jh(r)) {
    const l = [];
    for (const c of o) {
      const p = ige(t, c.transition, a, n, i, s);
      p && g4(p, l, []);
    }
    o = l;
  }
  return !!o.find((a) => a.isEnd);
}, g4 = (t, e, r) => {
  if (t.epsilonTransitions.length)
    for (const n of t.epsilonTransitions)
      r.find((i) => i === n) || (r.push(n), g4(n, e, r));
  else
    e.push(t);
}, ige = (t, e, r, n, i, s) => {
  for (const o in e)
    if (t(o, r, n, i, s))
      return e[o];
}, sge = hS(Ge.interpret), oge = hS(Ge.collectEvaluatedProperties), age = hS(Ge.collectEvaluatedItems), lge = { id: nge, compile: j$, interpret: sge, collectEvalatedProperties: oge, collectEvalatedItems: age }, cge = "https://json-schema.org/keyword/items", uge = async (t, e, r) => {
  const n = Xr(t.document.dialectId, "https://json-schema.org/keyword/prefixItems"), i = await Qs(n, r);
  return [Na(i) === "array" ? b$(i) : 0, await Ge.compile(t, e)];
}, B$ = ([t, e], r, n, i, s) => {
  if (Wt(r) !== "array")
    return !0;
  let o = !0;
  for (const a of _de(t, jh(r)))
    Ge.interpret(e, a, n, i, s) || (o = !1);
  return o;
}, hge = (t, e, r, n) => {
  if (!B$(t, e, r, n, !0))
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (let s = t[0]; s < jg(e); s++)
    i.add(s);
  return i;
}, pge = { id: cge, compile: uge, interpret: B$, collectEvaluatedItems: hge }, dge = "https://json-schema.org/keyword/maxContains", fge = (t) => Pt(t), gge = () => !0, mge = { id: dge, compile: fge, interpret: gge }, yge = "https://json-schema.org/keyword/maxItems", vge = (t) => Pt(t), bge = (t, e) => Wt(e) !== "array" || jg(e) <= t, wge = { id: yge, compile: vge, interpret: bge }, xge = "https://json-schema.org/keyword/maxLength", Ege = (t) => Pt(t), Sge = (t, e) => Wt(e) !== "string" || [..._r(e)].length <= t, Age = { id: xge, compile: Ege, interpret: Sge }, kge = "https://json-schema.org/keyword/maxProperties", _ge = (t) => Pt(t), Cge = (t, e) => Wt(e) !== "object" || [...cS(e)].length <= t, Ige = { id: kge, compile: _ge, interpret: Cge }, Pge = "https://json-schema.org/keyword/maximum", Rge = (t) => Pt(t), Oge = (t, e) => Wt(e) !== "number" || _r(e) <= t, Tge = { id: Pge, compile: Rge, interpret: Oge }, Lge = "https://json-schema.org/keyword/minContains", Mge = (t) => Pt(t), Nge = () => !0, Dge = { id: Lge, compile: Mge, interpret: Nge }, $ge = "https://json-schema.org/keyword/minItems", jge = (t) => Pt(t), Bge = (t, e) => Wt(e) !== "array" || jg(e) >= t, Fge = { id: $ge, compile: jge, interpret: Bge }, zge = "https://json-schema.org/keyword/minLength", Uge = (t) => Pt(t), Vge = (t, e) => Wt(e) !== "string" || [..._r(e)].length >= t, Hge = { id: zge, compile: Uge, interpret: Vge }, Gge = "https://json-schema.org/keyword/minProperties", Wge = (t) => Pt(t), qge = (t, e) => Wt(e) !== "object" || [...cS(e)].length >= t, Qge = { id: Gge, compile: Wge, interpret: qge }, Kge = "https://json-schema.org/keyword/minimum", Yge = (t) => Pt(t), Zge = (t, e) => Wt(e) !== "number" || _r(e) >= t, Jge = { id: Kge, compile: Yge, interpret: Zge }, Xge = "https://json-schema.org/keyword/multipleOf", eme = (t) => Pt(t), tme = (t, e) => {
  if (Wt(e) !== "number")
    return !0;
  const r = _r(e) % t;
  return x_(0, r) || x_(t, r);
}, x_ = (t, e) => Math.abs(t - e) < 11920929e-14, rme = { id: Xge, compile: eme, interpret: tme }, nme = "https://json-schema.org/keyword/not", ime = (...t) => Ge.compile(...t), sme = (...t) => !Ge.interpret(...t), ome = { id: nme, compile: ime, interpret: sme }, ame = "https://json-schema.org/keyword/oneOf", lme = (t, e) => vn(
  Oc(t),
  Zn((r) => Ge.compile(r, e)),
  lo
), cme = (t, e, r, n, i) => {
  let s = 0;
  for (const o of t)
    Ge.interpret(o, e, r, n, i) && s++;
  return s === 1;
}, ume = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ge.collectEvaluatedProperties(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, hme = (t, e, r, n) => {
  let i = !1;
  for (const s of t) {
    const o = Ge.collectEvaluatedItems(s, e, r, n);
    if (o) {
      if (i)
        return !1;
      i = o;
    }
  }
  return i;
}, pme = { id: ame, compile: lme, interpret: cme, collectEvaluatedProperties: ume, collectEvaluatedItems: hme }, dme = "https://json-schema.org/keyword/pattern", fme = (t) => new RegExp(Pt(t), "u"), gme = (t, e) => Wt(e) !== "string" || t.test(_r(e)), mme = { id: dme, compile: fme, interpret: gme }, yme = "https://json-schema.org/keyword/patternProperties", vme = (t, e) => vn(
  yh(t),
  Zn(async ([r, n]) => [
    new RegExp(r, "u"),
    await Ge.compile(n, e)
  ]),
  lo
), bme = (t, e, r, n, i) => {
  if (Wt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of t)
    for (const [l, c] of Tc(e)) {
      const p = _r(l);
      o.test(p) && !Ge.interpret(a, c, r, n, i) && (s = !1);
    }
  return s;
}, wme = (t, e, r, n) => {
  if (Wt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of t)
    for (const [a, l] of Tc(e)) {
      const c = _r(a);
      if (s.test(c)) {
        if (!Ge.interpret(o, l, r, n, !0))
          return !1;
        i.add(c);
      }
    }
  return i;
}, xme = { id: yme, compile: vme, interpret: bme, collectEvaluatedProperties: wme }, Eme = "https://json-schema.org/keyword/prefixItems", Sme = (t, e) => vn(
  Oc(t),
  Zn((r) => Ge.compile(r, e)),
  lo
), F$ = (t, e, r, n, i) => {
  if (Wt(e) !== "array")
    return !0;
  let s = !0, o = 0;
  const a = jg(e);
  for (const [l, c] of lS(t, jh(e))) {
    if (o >= a)
      break;
    Ge.interpret(l, c, r, n, i) || (s = !1), o++;
  }
  return s;
}, Ame = (t, e, r, n) => F$(t, e, r, n, !0) && new Set(t.map((i, s) => s)), kme = { id: Eme, compile: Sme, interpret: F$, collectEvaluatedItems: Ame }, _me = "https://json-schema.org/keyword/properties", Cme = (t, e) => vn(
  yh(t),
  Zn(async ([r, n]) => [r, await Ge.compile(n, e)]),
  d4
), Ime = (t, e, r, n, i) => {
  if (Wt(e) !== "object")
    return !0;
  let s = !0;
  for (const [o, a] of Tc(e)) {
    const l = _r(o);
    l in t && !Ge.interpret(t[l], a, r, n, i) && (s = !1);
  }
  return s;
}, Pme = (t, e, r, n) => {
  if (Wt(e) !== "object")
    return !1;
  const i = /* @__PURE__ */ new Set();
  for (const [s, o] of Tc(e)) {
    const a = _r(s);
    if (a in t) {
      if (!Ge.interpret(t[a], o, r, n, !0))
        return !1;
      i.add(a);
    }
  }
  return i;
}, Rme = { id: _me, compile: Cme, interpret: Ime, collectEvaluatedProperties: Pme }, Ome = "https://json-schema.org/keyword/propertyDependencies", Tme = (t, e) => vn(
  yh(t),
  Zn(async ([r, n]) => [r, await vn(
    yh(n),
    Zn(async ([i, s]) => [i, await Ge.compile(s, e)]),
    d4
  )]),
  d4
), Lme = (t, e, r, n, i) => {
  if (Wt(e) !== "object")
    return !0;
  let s = !0;
  const o = _r(e);
  for (const [a, l] of Object.entries(t)) {
    const c = o[a];
    Yp(a, e) && c in l && !Ge.interpret(l[c], e, r, n, i) && (s = !1);
  }
  return s;
}, Mme = (t, e, r, n) => {
  const i = /* @__PURE__ */ new Set();
  for (const s in t) {
    const o = _r(e)[s], a = t[s];
    if (Yp(s, e) && o in a) {
      const l = Ge.collectEvaluatedProperties(a[o], e, r, n);
      if (!l)
        return !1;
      l.forEach(i.add, i);
    }
  }
  return i;
}, Nme = { id: Ome, compile: Tme, interpret: Lme, collectEvaluatedProperties: Mme }, Dme = "https://json-schema.org/keyword/propertyNames", $me = (t, e) => Ge.compile(t, e), jme = (t, e, r, n) => {
  if (Wt(e) !== "object")
    return !0;
  let i = !0;
  for (const s of cS(e))
    Ge.interpret(t, s, r, n, !0) || (i = !1);
  return i;
}, Bme = { id: Dme, compile: $me, interpret: jme }, z$ = "https://json-schema.org/keyword/readOnly", Fme = (t) => Pt(t), zme = (t, e, r, n, i, s) => (Cs(e, z$, s, t), !0), Ume = { id: z$, compile: Fme, interpret: zme }, Vme = "https://json-schema.org/keyword/ref", Hme = (...t) => Ge.compile(...t), Gme = (...t) => Ge.interpret(...t), Wme = (...t) => Ge.collectEvaluatedProperties(...t), qme = (...t) => Ge.collectEvaluatedItems(...t), Qme = { id: Vme, compile: Hme, interpret: Gme, collectEvaluatedProperties: Wme, collectEvaluatedItems: qme }, Kme = "https://json-schema.org/keyword/requireAllExcept", Yme = async (t, e, r) => {
  const n = await Pt(t), i = Xr(t.document.dialectId, "https://json-schema.org/keyword/properties"), s = await Qs(i, r), o = Na(s) === "object" ? h4(s) : [], a = new Set(o);
  return n.forEach((l) => o.remove(l)), [...a];
}, Zme = (t, e) => Wt(e) !== "object" || t.every((r) => Object.hasOwn(_r(e), r)), Jme = { id: Kme, compile: Yme, interpret: Zme }, Xme = "https://json-schema.org/keyword/required", e1e = (t) => Pt(t), t1e = (t, e) => Wt(e) !== "object" || t.every((r) => Object.hasOwn(_r(e), r)), r1e = { id: Xme, compile: e1e, interpret: t1e }, U$ = "https://json-schema.org/keyword/title", n1e = (t) => Pt(t), i1e = (t, e, r, n, i, s) => (Cs(e, U$, s, t), !0), s1e = { id: U$, compile: n1e, interpret: i1e }, o1e = "https://json-schema.org/keyword/then", a1e = async (t, e, r) => {
  const n = Xr(t.document.dialectId, "https://json-schema.org/keyword/if");
  if (v$(n, r)) {
    const i = await Qs(n, r);
    return [await Ge.compile(i, e), await Ge.compile(t, e)];
  } else
    return [];
}, l1e = ([t, e], r, n, i, s) => t === void 0 || !Ge.interpret(t, r, n, i, !0) || Ge.interpret(e, r, n, i, s), c1e = ([t, e], r, n, i) => t === void 0 || !Ge.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ge.collectEvaluatedProperties(e, r, n, i), u1e = ([t, e], r, n, i) => t === void 0 || !Ge.interpret(t, r, n, i, !0) ? /* @__PURE__ */ new Set() : Ge.collectEvaluatedItems(e, r, n, i), h1e = { id: o1e, compile: a1e, interpret: l1e, collectEvaluatedProperties: c1e, collectEvaluatedItems: u1e }, p1e = "https://json-schema.org/keyword/type", d1e = (t) => Pt(t), f1e = (t, e) => typeof t == "string" ? E_(e)(t) : t.some(E_(e)), E_ = (t) => (e) => e === "integer" ? Wt(t) === "number" && Number.isInteger(_r(t)) : Wt(t) === e, g1e = { id: p1e, compile: d1e, interpret: f1e }, m1e = "https://json-schema.org/keyword/unevaluatedItems", y1e = async (t, e, r) => [Kp(r), await Ge.compile(t, e)], v1e = ([t, e], r, n, i, s) => {
  if (Wt(r) !== "array")
    return !0;
  const o = Ge.collectEvaluatedItems(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of lS(jh(r), E$(0)))
    !o.has(c) && !Ge.interpret(e, l, n, i, s) && (a = !1);
  return a;
}, b1e = (t, e, r, n) => {
  const i = Ge.collectEvaluatedItems(t[0], e, r, n, !0);
  if (!i)
    return !1;
  const s = /* @__PURE__ */ new Set();
  for (let o = 0; o < jg(e); o++)
    i.has(o) || s.add(o);
  return s;
}, w1e = { id: m1e, compile: y1e, interpret: v1e, collectEvaluatedItems: b1e }, x1e = "https://json-schema.org/keyword/unevaluatedProperties", E1e = async (t, e, r) => [Kp(r), await Ge.compile(t, e)], S1e = ([t, e], r, n, i, s) => {
  if (Wt(r) !== "object")
    return !0;
  const o = Ge.collectEvaluatedProperties(t, r, n, i, !0);
  if (o === !1)
    return !0;
  let a = !0;
  for (const [l, c] of Tc(r)) {
    const p = _r(l);
    !o.has(p) && !Ge.interpret(e, c, n, i, s) && (a = !1);
  }
  return a;
}, A1e = ([t, e], r, n, i) => {
  if (Wt(r) !== "object")
    return !0;
  const s = Ge.collectEvaluatedProperties(t, r, n, i, !0);
  if (!s)
    return !1;
  for (const [o, a] of Tc(r)) {
    const l = _r(o);
    if (!s.has(l)) {
      if (!Ge.interpret(e, a, n, i, !0))
        return !1;
      s.add(l);
    }
  }
  return s;
}, k1e = { id: x1e, compile: E1e, interpret: S1e, collectEvaluatedProperties: A1e }, _1e = "https://json-schema.org/keyword/uniqueItems", C1e = (t) => Pt(t), I1e = (t, e) => {
  if (Wt(e) !== "array" || t === !1)
    return !0;
  const r = _r(e).map(Bg);
  return new Set(r).size === r.length;
}, P1e = { id: _1e, compile: C1e, interpret: I1e }, V$ = "https://json-schema.org/keyword/unknown", R1e = (t) => [[...a4(t.cursor)].pop(), Pt(t)], O1e = ([t, e], r, n, i, s, o) => {
  const a = `${V$}#${t}`;
  return Cs(r, a, o, e), !0;
}, T1e = { id: V$, compile: R1e, interpret: O1e }, L1e = { id: "https://json-schema.org/keyword/vocabulary" }, H$ = "https://json-schema.org/keyword/writeOnly", M1e = (t) => Pt(t), N1e = (t, e, r, n, i, s) => (Cs(e, H$, s, t), !0), D1e = { id: H$, compile: M1e, interpret: N1e };
p$("application/schema+json", Ade);
ct(Xde);
ct(sfe);
ct(ofe);
ct(pfe);
ct(vfe);
ct(kfe);
ct(Pfe);
ct(Lfe);
ct(Dfe);
ct(Bfe);
ct(Ufe);
ct(Gfe);
ct(Kfe);
ct(Xfe);
ct(i0e);
ct(a0e);
ct(u0e);
ct(h0e);
ct(y0e);
ct(S0e);
ct(C0e);
ct(R0e);
ct(M0e);
ct(j0e);
ct(z0e);
ct(U0e);
ct(Q0e);
ct(lge);
ct(pge);
ct(mge);
ct(wge);
ct(Age);
ct(Ige);
ct(Tge);
ct(Dge);
ct(Fge);
ct(Hge);
ct(Qge);
ct(Jge);
ct(rme);
ct(ome);
ct(pme);
ct(mme);
ct(xme);
ct(kme);
ct(Rme);
ct(Nme);
ct(Bme);
ct(Ume);
ct(Qme);
ct(Jme);
ct(r1e);
ct(s1e);
ct(h1e);
ct(g1e);
ct(w1e);
ct(k1e);
ct(P1e);
ct(T1e);
ct(L1e);
ct(D1e);
const $1e = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://json-schema.org/draft/2020-12/schema",
  $vocabulary: {
    "https://json-schema.org/draft/2020-12/vocab/core": !0,
    "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
    "https://json-schema.org/draft/2020-12/vocab/validation": !0,
    "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
    "https://json-schema.org/draft/2020-12/vocab/content": !0
  },
  $dynamicAnchor: "meta",
  title: "Core and Validation specifications meta-schema",
  allOf: [
    { $ref: "meta/core" },
    { $ref: "meta/applicator" },
    { $ref: "meta/unevaluated" },
    { $ref: "meta/validation" },
    { $ref: "meta/meta-data" },
    { $ref: "meta/format-annotation" },
    { $ref: "meta/content" }
  ],
  type: ["object", "boolean"],
  properties: {
    definitions: {
      $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    dependencies: {
      $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
      type: "object",
      additionalProperties: {
        anyOf: [
          { $dynamicRef: "#meta" },
          { $ref: "meta/validation#/$defs/stringArray" }
        ]
      }
    }
  }
}, j1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/core",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Core vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    $id: {
      type: "string",
      format: "uri-reference",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $anchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicRef: {
      type: "string",
      format: "uri-reference"
    },
    $dynamicAnchor: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        type: "string",
        format: "uri"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    }
  }
}, B1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/applicator",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    prefixItems: { $ref: "#/$defs/schemaArray" },
    items: { $dynamicRef: "#meta" },
    contains: { $dynamicRef: "#meta" },
    additionalProperties: { $dynamicRef: "#meta" },
    properties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      default: {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $dynamicRef: "#meta" },
      propertyNames: { format: "regex" },
      default: {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      }
    },
    propertyNames: { $dynamicRef: "#meta" },
    if: { $dynamicRef: "#meta" },
    then: { $dynamicRef: "#meta" },
    else: { $dynamicRef: "#meta" },
    allOf: { $ref: "#/$defs/schemaArray" },
    anyOf: { $ref: "#/$defs/schemaArray" },
    oneOf: { $ref: "#/$defs/schemaArray" },
    not: { $dynamicRef: "#meta" }
  },
  $defs: {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: { $dynamicRef: "#meta" }
    }
  }
}, F1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/validation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Validation vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: { $ref: "#/$defs/nonNegativeInteger" },
    minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: { $ref: "#/$defs/nonNegativeInteger" },
    minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    uniqueItems: {
      type: "boolean",
      default: !1
    },
    maxContains: { $ref: "#/$defs/nonNegativeInteger" },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 1
    },
    maxProperties: { $ref: "#/$defs/nonNegativeInteger" },
    minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" },
    required: { $ref: "#/$defs/stringArray" },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    },
    const: !0,
    enum: {
      type: "array",
      items: !0
    },
    type: {
      anyOf: [
        { $ref: "#/$defs/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/$defs/simpleTypes" },
          minItems: 1,
          uniqueItems: !0
        }
      ]
    }
  },
  $defs: {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      default: 0
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: []
    }
  }
}, z1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/meta-data",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Meta-data vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    default: !0,
    deprecated: {
      type: "boolean",
      default: !1
    },
    readOnly: {
      type: "boolean",
      default: !1
    },
    writeOnly: {
      type: "boolean",
      default: !1
    },
    examples: {
      type: "array",
      items: !0
    }
  }
}, U1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-annotation",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for annotation results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, V1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/format-assertion",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Format vocabulary meta-schema for assertion results",
  type: ["object", "boolean"],
  properties: {
    format: { type: "string" }
  }
}, H1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/content",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Content vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    contentSchema: { $dynamicRef: "#meta" }
  }
}, G1e = {
  $id: "https://json-schema.org/draft/2020-12/meta/unevaluated",
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $dynamicAnchor: "meta",
  title: "Unevaluated applicator vocabulary meta-schema",
  type: ["object", "boolean"],
  properties: {
    unevaluatedItems: { $dynamicRef: "#meta" },
    unevaluatedProperties: { $dynamicRef: "#meta" }
  }
}, W1e = { id: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor" }, q1e = "https://json-schema.org/keyword/draft-2020-12/dynamicRef", Q1e = async (t, e) => {
  const r = a$(Pt(t)), n = await Ov(Pt(t), t);
  return await Ge.compile(n, e), [n.document.baseUri, r, Kp(n)];
}, pS = (t, [e, r, n], i, s, o, a) => r in s.metaData[e].dynamicAnchors ? (o = { ...s.metaData[e].dynamicAnchors, ...o }, t(o[r], i, s, o, a)) : t(n, i, s, o, a), K1e = (...t) => pS(Ge.interpret, ...t), Y1e = (...t) => pS(Ge.collectEvaluatedProperties, ...t), Z1e = (...t) => pS(Ge.collectEvaluatedItems, ...t), J1e = { id: q1e, compile: Q1e, interpret: K1e, collectEvaluatedProperties: Y1e, collectEvaluatedItems: Z1e };
ct(J1e);
ct(W1e);
Rc("https://json-schema.org/draft/2020-12/vocab/core", {
  $anchor: "https://json-schema.org/keyword/anchor",
  $comment: "https://json-schema.org/keyword/comment",
  $defs: "https://json-schema.org/keyword/definitions",
  $dynamicAnchor: "https://json-schema.org/keyword/draft-2020-12/dynamicAnchor",
  $dynamicRef: "https://json-schema.org/keyword/draft-2020-12/dynamicRef",
  $id: "https://json-schema.org/keyword/id",
  $ref: "https://json-schema.org/keyword/ref",
  $vocabulary: "https://json-schema.org/keyword/vocabulary"
});
Rc("https://json-schema.org/draft/2020-12/vocab/applicator", {
  additionalProperties: "https://json-schema.org/keyword/additionalProperties",
  allOf: "https://json-schema.org/keyword/allOf",
  anyOf: "https://json-schema.org/keyword/anyOf",
  contains: "https://json-schema.org/keyword/contains",
  dependentSchemas: "https://json-schema.org/keyword/dependentSchemas",
  if: "https://json-schema.org/keyword/if",
  then: "https://json-schema.org/keyword/then",
  else: "https://json-schema.org/keyword/else",
  items: "https://json-schema.org/keyword/items",
  not: "https://json-schema.org/keyword/not",
  oneOf: "https://json-schema.org/keyword/oneOf",
  patternProperties: "https://json-schema.org/keyword/patternProperties",
  prefixItems: "https://json-schema.org/keyword/prefixItems",
  properties: "https://json-schema.org/keyword/properties",
  propertyNames: "https://json-schema.org/keyword/propertyNames"
});
Rc("https://json-schema.org/draft/2020-12/vocab/validation", {
  const: "https://json-schema.org/keyword/const",
  dependentRequired: "https://json-schema.org/keyword/dependentRequired",
  enum: "https://json-schema.org/keyword/enum",
  exclusiveMaximum: "https://json-schema.org/keyword/exclusiveMaximum",
  exclusiveMinimum: "https://json-schema.org/keyword/exclusiveMinimum",
  maxContains: "https://json-schema.org/keyword/maxContains",
  maxItems: "https://json-schema.org/keyword/maxItems",
  maxLength: "https://json-schema.org/keyword/maxLength",
  maxProperties: "https://json-schema.org/keyword/maxProperties",
  maximum: "https://json-schema.org/keyword/maximum",
  minContains: "https://json-schema.org/keyword/minContains",
  minItems: "https://json-schema.org/keyword/minItems",
  minLength: "https://json-schema.org/keyword/minLength",
  minProperties: "https://json-schema.org/keyword/minProperties",
  minimum: "https://json-schema.org/keyword/minimum",
  multipleOf: "https://json-schema.org/keyword/multipleOf",
  pattern: "https://json-schema.org/keyword/pattern",
  required: "https://json-schema.org/keyword/required",
  type: "https://json-schema.org/keyword/type",
  uniqueItems: "https://json-schema.org/keyword/uniqueItems"
});
Rc("https://json-schema.org/draft/2020-12/vocab/meta-data", {
  default: "https://json-schema.org/keyword/default",
  deprecated: "https://json-schema.org/keyword/deprecated",
  description: "https://json-schema.org/keyword/description",
  examples: "https://json-schema.org/keyword/examples",
  readOnly: "https://json-schema.org/keyword/readOnly",
  title: "https://json-schema.org/keyword/title",
  writeOnly: "https://json-schema.org/keyword/writeOnly"
});
Rc("https://json-schema.org/draft/2020-12/vocab/format-annotation", {
  format: "https://json-schema.org/keyword/format"
});
Rc("https://json-schema.org/draft/2020-12/vocab/format-assertion", {
  format: "https://json-schema.org/keyword/format-assertion"
});
Rc("https://json-schema.org/draft/2020-12/vocab/content", {
  contentEncoding: "https://json-schema.org/keyword/contentEncoding",
  contentMediaType: "https://json-schema.org/keyword/contentMediaType",
  contentSchema: "https://json-schema.org/keyword/contentSchema"
});
Rc("https://json-schema.org/draft/2020-12/vocab/unevaluated", {
  unevaluatedItems: "https://json-schema.org/keyword/unevaluatedItems",
  unevaluatedProperties: "https://json-schema.org/keyword/unevaluatedProperties"
});
c$("https://json-schema.org/draft/2020-12/schema", {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, !0);
Ya($1e);
Ya(j1e);
Ya(B1e);
Ya(F1e);
Ya(z1e);
Ya(U1e);
Ya(V1e);
Ya(H1e);
Ya(G1e);
function zm(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var S_ = { exports: {} };
/*! jsonpath 1.1.1 */
var A_;
function X1e() {
  return A_ || (A_ = 1, function(t, e) {
    (function(r) {
      t.exports = r();
    })(function() {
      return function r(n, i, s) {
        function o(c, p) {
          if (!i[c]) {
            if (!n[c]) {
              var h = typeof zm == "function" && zm;
              if (!p && h) return h(c, !0);
              if (a) return a(c, !0);
              var d = new Error("Cannot find module '" + c + "'");
              throw d.code = "MODULE_NOT_FOUND", d;
            }
            var v = i[c] = { exports: {} };
            n[c][0].call(v.exports, function(m) {
              var b = n[c][1][m];
              return o(b || m);
            }, v, v.exports, r, n, i, s);
          }
          return i[c].exports;
        }
        for (var a = typeof zm == "function" && zm, l = 0; l < s.length; l++) o(s[l]);
        return o;
      }({ "./aesprim": [function(r, n, i) {
        (function(s, o) {
          o(typeof i < "u" ? i : s.esprima = {});
        })(this, function(s) {
          var o, a, l, c, p, h, d, v, m, b, f, E, A, x, g, w, _, S;
          o = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9
          }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
            "(",
            "{",
            "[",
            "in",
            "typeof",
            "instanceof",
            "new",
            "return",
            "case",
            "delete",
            "throw",
            "void",
            // assignment operators
            "=",
            "+=",
            "-=",
            "*=",
            "/=",
            "%=",
            "<<=",
            ">>=",
            ">>>=",
            "&=",
            "|=",
            "^=",
            ",",
            // binary/unary operators
            "+",
            "-",
            "*",
            "/",
            "%",
            "++",
            "--",
            "<<",
            ">>",
            ">>>",
            "&",
            "|",
            "^",
            "!",
            "~",
            "&&",
            "||",
            "?",
            ":",
            "===",
            "==",
            ">=",
            "<=",
            "<",
            ">",
            "!=",
            "!=="
          ], c = {
            AssignmentExpression: "AssignmentExpression",
            ArrayExpression: "ArrayExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            Program: "Program",
            Property: "Property",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SwitchStatement: "SwitchStatement",
            SwitchCase: "SwitchCase",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement"
          }, p = {
            Data: 1,
            Get: 2,
            Set: 4
          }, h = {
            UnexpectedToken: "Unexpected token %0",
            UnexpectedNumber: "Unexpected number",
            UnexpectedString: "Unexpected string",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedEOS: "Unexpected end of input",
            NewlineAfterThrow: "Illegal newline after throw",
            InvalidRegExp: "Invalid regular expression",
            UnterminatedRegExp: "Invalid regular expression: missing /",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NoCatchOrFinally: "Missing catch or finally after try",
            UnknownLabel: "Undefined label '%0'",
            Redeclaration: "%0 '%1' has already been declared",
            IllegalContinue: "Illegal continue statement",
            IllegalBreak: "Illegal break statement",
            IllegalReturn: "Illegal return statement",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
            AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
            AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode"
          }, d = {
            NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
            NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
          };
          function R(u, y) {
            if (!u)
              throw new Error("ASSERT: " + y);
          }
          function L(u) {
            return u >= 48 && u <= 57;
          }
          function F(u) {
            return "0123456789abcdefABCDEF".indexOf(u) >= 0;
          }
          function z(u) {
            return "01234567".indexOf(u) >= 0;
          }
          function j(u) {
            return u === 32 || u === 9 || u === 11 || u === 12 || u === 160 || u >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(u) >= 0;
          }
          function W(u) {
            return u === 10 || u === 13 || u === 8232 || u === 8233;
          }
          function te(u) {
            return u == 64 || u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierStart.test(String.fromCharCode(u));
          }
          function le(u) {
            return u === 36 || u === 95 || // $ (dollar) and _ (underscore)
            u >= 65 && u <= 90 || // A..Z
            u >= 97 && u <= 122 || // a..z
            u >= 48 && u <= 57 || // 0..9
            u === 92 || // \ (backslash)
            u >= 128 && d.NonAsciiIdentifierPart.test(String.fromCharCode(u));
          }
          function ce(u) {
            switch (u) {
              case "class":
              case "enum":
              case "export":
              case "extends":
              case "import":
              case "super":
                return !0;
              default:
                return !1;
            }
          }
          function Ee(u) {
            switch (u) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return !0;
              default:
                return !1;
            }
          }
          function xe(u) {
            return u === "eval" || u === "arguments";
          }
          function _e(u) {
            if (b && Ee(u))
              return !0;
            switch (u.length) {
              case 2:
                return u === "if" || u === "in" || u === "do";
              case 3:
                return u === "var" || u === "for" || u === "new" || u === "try" || u === "let";
              case 4:
                return u === "this" || u === "else" || u === "case" || u === "void" || u === "with" || u === "enum";
              case 5:
                return u === "while" || u === "break" || u === "catch" || u === "throw" || u === "const" || u === "yield" || u === "class" || u === "super";
              case 6:
                return u === "return" || u === "typeof" || u === "delete" || u === "switch" || u === "export" || u === "import";
              case 7:
                return u === "default" || u === "finally" || u === "extends";
              case 8:
                return u === "function" || u === "continue" || u === "debugger";
              case 10:
                return u === "instanceof";
              default:
                return !1;
            }
          }
          function Ie(u, y, k, T, V) {
            var ne;
            R(typeof k == "number", "Comment must have valid position"), !(_.lastCommentStart >= k) && (_.lastCommentStart = k, ne = {
              type: u,
              value: y
            }, S.range && (ne.range = [k, T]), S.loc && (ne.loc = V), S.comments.push(ne), S.attachComment && (S.leadingComments.push(ne), S.trailingComments.push(ne)));
          }
          function je(u) {
            var y, k, T, V;
            for (y = f - u, k = {
              start: {
                line: E,
                column: f - A - u
              }
            }; f < x; )
              if (T = m.charCodeAt(f), ++f, W(T)) {
                S.comments && (V = m.slice(y + u, f - 1), k.end = {
                  line: E,
                  column: f - A - 1
                }, Ie("Line", V, y, f - 1, k)), T === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f;
                return;
              }
            S.comments && (V = m.slice(y + u, f), k.end = {
              line: E,
              column: f - A
            }, Ie("Line", V, y, f, k));
          }
          function ue() {
            var u, y, k, T;
            for (S.comments && (u = f - 2, y = {
              start: {
                line: E,
                column: f - A - 2
              }
            }); f < x; )
              if (k = m.charCodeAt(f), W(k))
                k === 13 && m.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && fe({}, h.UnexpectedToken, "ILLEGAL");
              else if (k === 42) {
                if (m.charCodeAt(f + 1) === 47) {
                  ++f, ++f, S.comments && (T = m.slice(u + 2, f - 2), y.end = {
                    line: E,
                    column: f - A
                  }, Ie("Block", T, u, f, y));
                  return;
                }
                ++f;
              } else
                ++f;
            fe({}, h.UnexpectedToken, "ILLEGAL");
          }
          function O() {
            var u, y;
            for (y = f === 0; f < x; )
              if (u = m.charCodeAt(f), j(u))
                ++f;
              else if (W(u))
                ++f, u === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f, y = !0;
              else if (u === 47)
                if (u = m.charCodeAt(f + 1), u === 47)
                  ++f, ++f, je(2), y = !0;
                else if (u === 42)
                  ++f, ++f, ue();
                else
                  break;
              else if (y && u === 45)
                if (m.charCodeAt(f + 1) === 45 && m.charCodeAt(f + 2) === 62)
                  f += 3, je(3);
                else
                  break;
              else if (u === 60)
                if (m.slice(f + 1, f + 4) === "!--")
                  ++f, ++f, ++f, ++f, je(4);
                else
                  break;
              else
                break;
          }
          function N(u) {
            var y, k, T, V = 0;
            for (k = u === "u" ? 4 : 2, y = 0; y < k; ++y)
              if (f < x && F(m[f]))
                T = m[f++], V = V * 16 + "0123456789abcdef".indexOf(T.toLowerCase());
              else
                return "";
            return String.fromCharCode(V);
          }
          function J() {
            var u, y;
            for (u = m.charCodeAt(f++), y = String.fromCharCode(u), u === 92 && (m.charCodeAt(f) !== 117 && fe({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !te(u.charCodeAt(0))) && fe({}, h.UnexpectedToken, "ILLEGAL"), y = u); f < x && (u = m.charCodeAt(f), !!le(u)); )
              ++f, y += String.fromCharCode(u), u === 92 && (y = y.substr(0, y.length - 1), m.charCodeAt(f) !== 117 && fe({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !le(u.charCodeAt(0))) && fe({}, h.UnexpectedToken, "ILLEGAL"), y += u);
            return y;
          }
          function re() {
            var u, y;
            for (u = f++; f < x; ) {
              if (y = m.charCodeAt(f), y === 92)
                return f = u, J();
              if (le(y))
                ++f;
              else
                break;
            }
            return m.slice(u, f);
          }
          function oe() {
            var u, y, k;
            return u = f, y = m.charCodeAt(f) === 92 ? J() : re(), y.length === 1 ? k = o.Identifier : _e(y) ? k = o.Keyword : y === "null" ? k = o.NullLiteral : y === "true" || y === "false" ? k = o.BooleanLiteral : k = o.Identifier, {
              type: k,
              value: y,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function ee() {
            var u = f, y = m.charCodeAt(f), k, T = m[f], V, ne, Ce;
            switch (y) {
              case 46:
              case 40:
              case 41:
              case 59:
              case 44:
              case 123:
              case 125:
              case 91:
              case 93:
              case 58:
              case 63:
              case 126:
                return ++f, S.tokenize && (y === 40 ? S.openParenToken = S.tokens.length : y === 123 && (S.openCurlyToken = S.tokens.length)), {
                  type: o.Punctuator,
                  value: String.fromCharCode(y),
                  lineNumber: E,
                  lineStart: A,
                  start: u,
                  end: f
                };
              default:
                if (k = m.charCodeAt(f + 1), k === 61)
                  switch (y) {
                    case 43:
                    case 45:
                    case 47:
                    case 60:
                    case 62:
                    case 94:
                    case 124:
                    case 37:
                    case 38:
                    case 42:
                      return f += 2, {
                        type: o.Punctuator,
                        value: String.fromCharCode(y) + String.fromCharCode(k),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                    case 33:
                    case 61:
                      return f += 2, m.charCodeAt(f) === 61 && ++f, {
                        type: o.Punctuator,
                        value: m.slice(u, f),
                        lineNumber: E,
                        lineStart: A,
                        start: u,
                        end: f
                      };
                  }
            }
            if (Ce = m.substr(f, 4), Ce === ">>>=")
              return f += 4, {
                type: o.Punctuator,
                value: Ce,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (ne = Ce.substr(0, 3), ne === ">>>" || ne === "<<=" || ne === ">>=")
              return f += 3, {
                type: o.Punctuator,
                value: ne,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if (V = ne.substr(0, 2), T === V[1] && "+-<>&|".indexOf(T) >= 0 || V === "=>")
              return f += 2, {
                type: o.Punctuator,
                value: V,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            if ("<>=!+-*%&|^/".indexOf(T) >= 0)
              return ++f, {
                type: o.Punctuator,
                value: T,
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            fe({}, h.UnexpectedToken, "ILLEGAL");
          }
          function ae(u) {
            for (var y = ""; f < x && F(m[f]); )
              y += m[f++];
            return y.length === 0 && fe({}, h.UnexpectedToken, "ILLEGAL"), te(m.charCodeAt(f)) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt("0x" + y, 16),
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function me(u) {
            for (var y = "0" + m[f++]; f < x && z(m[f]); )
              y += m[f++];
            return (te(m.charCodeAt(f)) || L(m.charCodeAt(f))) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseInt(y, 8),
              octal: !0,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          }
          function H() {
            var u, y, k;
            if (k = m[f], R(
              L(k.charCodeAt(0)) || k === ".",
              "Numeric literal must start with a decimal digit or a decimal point"
            ), y = f, u = "", k !== ".") {
              if (u = m[f++], k = m[f], u === "0") {
                if (k === "x" || k === "X")
                  return ++f, ae(y);
                if (z(k))
                  return me(y);
                k && L(k.charCodeAt(0)) && fe({}, h.UnexpectedToken, "ILLEGAL");
              }
              for (; L(m.charCodeAt(f)); )
                u += m[f++];
              k = m[f];
            }
            if (k === ".") {
              for (u += m[f++]; L(m.charCodeAt(f)); )
                u += m[f++];
              k = m[f];
            }
            if (k === "e" || k === "E")
              if (u += m[f++], k = m[f], (k === "+" || k === "-") && (u += m[f++]), L(m.charCodeAt(f)))
                for (; L(m.charCodeAt(f)); )
                  u += m[f++];
              else
                fe({}, h.UnexpectedToken, "ILLEGAL");
            return te(m.charCodeAt(f)) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.NumericLiteral,
              value: parseFloat(u),
              lineNumber: E,
              lineStart: A,
              start: y,
              end: f
            };
          }
          function X() {
            var u = "", y, k, T, V, ne, Ce, Me = !1, et, Xe;
            for (et = E, Xe = A, y = m[f], R(
              y === "'" || y === '"',
              "String literal must starts with a quote"
            ), k = f, ++f; f < x; )
              if (T = m[f++], T === y) {
                y = "";
                break;
              } else if (T === "\\")
                if (T = m[f++], !T || !W(T.charCodeAt(0)))
                  switch (T) {
                    case "u":
                    case "x":
                      Ce = f, ne = N(T), ne ? u += ne : (f = Ce, u += T);
                      break;
                    case "n":
                      u += `
`;
                      break;
                    case "r":
                      u += "\r";
                      break;
                    case "t":
                      u += "	";
                      break;
                    case "b":
                      u += "\b";
                      break;
                    case "f":
                      u += "\f";
                      break;
                    case "v":
                      u += "\v";
                      break;
                    default:
                      z(T) ? (V = "01234567".indexOf(T), V !== 0 && (Me = !0), f < x && z(m[f]) && (Me = !0, V = V * 8 + "01234567".indexOf(m[f++]), "0123".indexOf(T) >= 0 && f < x && z(m[f]) && (V = V * 8 + "01234567".indexOf(m[f++]))), u += String.fromCharCode(V)) : u += T;
                      break;
                  }
                else
                  ++E, T === "\r" && m[f] === `
` && ++f, A = f;
              else {
                if (W(T.charCodeAt(0)))
                  break;
                u += T;
              }
            return y !== "" && fe({}, h.UnexpectedToken, "ILLEGAL"), {
              type: o.StringLiteral,
              value: u,
              octal: Me,
              startLineNumber: et,
              startLineStart: Xe,
              lineNumber: E,
              lineStart: A,
              start: k,
              end: f
            };
          }
          function Ae(u, y) {
            var k;
            try {
              k = new RegExp(u, y);
            } catch {
              fe({}, h.InvalidRegExp);
            }
            return k;
          }
          function Re() {
            var u, y, k, T, V;
            for (u = m[f], R(u === "/", "Regular expression literal must start with a slash"), y = m[f++], k = !1, T = !1; f < x; )
              if (u = m[f++], y += u, u === "\\")
                u = m[f++], W(u.charCodeAt(0)) && fe({}, h.UnterminatedRegExp), y += u;
              else if (W(u.charCodeAt(0)))
                fe({}, h.UnterminatedRegExp);
              else if (k)
                u === "]" && (k = !1);
              else if (u === "/") {
                T = !0;
                break;
              } else u === "[" && (k = !0);
            return T || fe({}, h.UnterminatedRegExp), V = y.substr(1, y.length - 2), {
              value: V,
              literal: y
            };
          }
          function Fe() {
            var u, y, k, T;
            for (y = "", k = ""; f < x && (u = m[f], !!le(u.charCodeAt(0))); )
              if (++f, u === "\\" && f < x)
                if (u = m[f], u === "u") {
                  if (++f, T = f, u = N("u"), u)
                    for (k += u, y += "\\u"; T < f; ++T)
                      y += m[T];
                  else
                    f = T, k += "u", y += "\\u";
                  ye({}, h.UnexpectedToken, "ILLEGAL");
                } else
                  y += "\\", ye({}, h.UnexpectedToken, "ILLEGAL");
              else
                k += u, y += u;
            return {
              value: k,
              literal: y
            };
          }
          function Te() {
            var u, y, k, T;
            return w = null, O(), u = f, y = Re(), k = Fe(), T = Ae(y.value, k.value), S.tokenize ? {
              type: o.RegularExpression,
              value: T,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            } : {
              literal: y.literal + k.literal,
              value: T,
              start: u,
              end: f
            };
          }
          function qe() {
            var u, y, k, T;
            return O(), u = f, y = {
              start: {
                line: E,
                column: f - A
              }
            }, k = Te(), y.end = {
              line: E,
              column: f - A
            }, S.tokenize || (S.tokens.length > 0 && (T = S.tokens[S.tokens.length - 1], T.range[0] === u && T.type === "Punctuator" && (T.value === "/" || T.value === "/=") && S.tokens.pop()), S.tokens.push({
              type: "RegularExpression",
              value: k.literal,
              range: [u, f],
              loc: y
            })), k;
          }
          function tt(u) {
            return u.type === o.Identifier || u.type === o.Keyword || u.type === o.BooleanLiteral || u.type === o.NullLiteral;
          }
          function Pe() {
            var u, y;
            if (u = S.tokens[S.tokens.length - 1], !u)
              return qe();
            if (u.type === "Punctuator") {
              if (u.value === "]")
                return ee();
              if (u.value === ")")
                return y = S.tokens[S.openParenToken - 1], y && y.type === "Keyword" && (y.value === "if" || y.value === "while" || y.value === "for" || y.value === "with") ? qe() : ee();
              if (u.value === "}") {
                if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 4], !y)
                    return ee();
                } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                  if (y = S.tokens[S.openCurlyToken - 5], !y)
                    return qe();
                } else
                  return ee();
                return l.indexOf(y.value) >= 0 ? ee() : qe();
              }
              return qe();
            }
            return u.type === "Keyword" ? qe() : ee();
          }
          function At() {
            var u;
            return O(), f >= x ? {
              type: o.EOF,
              lineNumber: E,
              lineStart: A,
              start: f,
              end: f
            } : (u = m.charCodeAt(f), te(u) ? oe() : u === 40 || u === 41 || u === 59 ? ee() : u === 39 || u === 34 ? X() : u === 46 ? L(m.charCodeAt(f + 1)) ? H() : ee() : L(u) ? H() : S.tokenize && u === 47 ? Pe() : ee());
          }
          function er() {
            var u, y, k;
            return O(), u = {
              start: {
                line: E,
                column: f - A
              }
            }, y = At(), u.end = {
              line: E,
              column: f - A
            }, y.type !== o.EOF && (k = m.slice(y.start, y.end), S.tokens.push({
              type: a[y.type],
              value: k,
              range: [y.start, y.end],
              loc: u
            })), y;
          }
          function ge() {
            var u;
            return u = w, f = u.end, E = u.lineNumber, A = u.lineStart, w = typeof S.tokens < "u" ? er() : At(), f = u.end, E = u.lineNumber, A = u.lineStart, u;
          }
          function ht() {
            var u, y, k;
            u = f, y = E, k = A, w = typeof S.tokens < "u" ? er() : At(), f = u, E = y, A = k;
          }
          function it(u, y) {
            this.line = u, this.column = y;
          }
          function kt(u, y, k, T) {
            this.start = new it(u, y), this.end = new it(k, T);
          }
          v = {
            name: "SyntaxTree",
            processComment: function(u) {
              var y, k;
              if (!(u.type === c.Program && u.body.length > 0)) {
                for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= u.range[1] ? (k = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= u.range[1] && (k = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= u.range[0]; )
                  y = S.bottomRightStack.pop();
                y ? y.leadingComments && y.leadingComments[y.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = y.leadingComments, delete y.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = S.leadingComments, S.leadingComments = []), k && (u.trailingComments = k), S.bottomRightStack.push(u);
              }
            },
            markEnd: function(u, y) {
              return S.range && (u.range = [y.start, f]), S.loc && (u.loc = new kt(
                y.startLineNumber === void 0 ? y.lineNumber : y.startLineNumber,
                y.start - (y.startLineStart === void 0 ? y.lineStart : y.startLineStart),
                E,
                f - A
              ), this.postProcess(u)), S.attachComment && this.processComment(u), u;
            },
            postProcess: function(u) {
              return S.source && (u.loc.source = S.source), u;
            },
            createArrayExpression: function(u) {
              return {
                type: c.ArrayExpression,
                elements: u
              };
            },
            createAssignmentExpression: function(u, y, k) {
              return {
                type: c.AssignmentExpression,
                operator: u,
                left: y,
                right: k
              };
            },
            createBinaryExpression: function(u, y, k) {
              var T = u === "||" || u === "&&" ? c.LogicalExpression : c.BinaryExpression;
              return {
                type: T,
                operator: u,
                left: y,
                right: k
              };
            },
            createBlockStatement: function(u) {
              return {
                type: c.BlockStatement,
                body: u
              };
            },
            createBreakStatement: function(u) {
              return {
                type: c.BreakStatement,
                label: u
              };
            },
            createCallExpression: function(u, y) {
              return {
                type: c.CallExpression,
                callee: u,
                arguments: y
              };
            },
            createCatchClause: function(u, y) {
              return {
                type: c.CatchClause,
                param: u,
                body: y
              };
            },
            createConditionalExpression: function(u, y, k) {
              return {
                type: c.ConditionalExpression,
                test: u,
                consequent: y,
                alternate: k
              };
            },
            createContinueStatement: function(u) {
              return {
                type: c.ContinueStatement,
                label: u
              };
            },
            createDebuggerStatement: function() {
              return {
                type: c.DebuggerStatement
              };
            },
            createDoWhileStatement: function(u, y) {
              return {
                type: c.DoWhileStatement,
                body: u,
                test: y
              };
            },
            createEmptyStatement: function() {
              return {
                type: c.EmptyStatement
              };
            },
            createExpressionStatement: function(u) {
              return {
                type: c.ExpressionStatement,
                expression: u
              };
            },
            createForStatement: function(u, y, k, T) {
              return {
                type: c.ForStatement,
                init: u,
                test: y,
                update: k,
                body: T
              };
            },
            createForInStatement: function(u, y, k) {
              return {
                type: c.ForInStatement,
                left: u,
                right: y,
                body: k,
                each: !1
              };
            },
            createFunctionDeclaration: function(u, y, k, T) {
              return {
                type: c.FunctionDeclaration,
                id: u,
                params: y,
                defaults: k,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createFunctionExpression: function(u, y, k, T) {
              return {
                type: c.FunctionExpression,
                id: u,
                params: y,
                defaults: k,
                body: T,
                rest: null,
                generator: !1,
                expression: !1
              };
            },
            createIdentifier: function(u) {
              return {
                type: c.Identifier,
                name: u
              };
            },
            createIfStatement: function(u, y, k) {
              return {
                type: c.IfStatement,
                test: u,
                consequent: y,
                alternate: k
              };
            },
            createLabeledStatement: function(u, y) {
              return {
                type: c.LabeledStatement,
                label: u,
                body: y
              };
            },
            createLiteral: function(u) {
              return {
                type: c.Literal,
                value: u.value,
                raw: m.slice(u.start, u.end)
              };
            },
            createMemberExpression: function(u, y, k) {
              return {
                type: c.MemberExpression,
                computed: u === "[",
                object: y,
                property: k
              };
            },
            createNewExpression: function(u, y) {
              return {
                type: c.NewExpression,
                callee: u,
                arguments: y
              };
            },
            createObjectExpression: function(u) {
              return {
                type: c.ObjectExpression,
                properties: u
              };
            },
            createPostfixExpression: function(u, y) {
              return {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !1
              };
            },
            createProgram: function(u) {
              return {
                type: c.Program,
                body: u
              };
            },
            createProperty: function(u, y, k) {
              return {
                type: c.Property,
                key: y,
                value: k,
                kind: u
              };
            },
            createReturnStatement: function(u) {
              return {
                type: c.ReturnStatement,
                argument: u
              };
            },
            createSequenceExpression: function(u) {
              return {
                type: c.SequenceExpression,
                expressions: u
              };
            },
            createSwitchCase: function(u, y) {
              return {
                type: c.SwitchCase,
                test: u,
                consequent: y
              };
            },
            createSwitchStatement: function(u, y) {
              return {
                type: c.SwitchStatement,
                discriminant: u,
                cases: y
              };
            },
            createThisExpression: function() {
              return {
                type: c.ThisExpression
              };
            },
            createThrowStatement: function(u) {
              return {
                type: c.ThrowStatement,
                argument: u
              };
            },
            createTryStatement: function(u, y, k, T) {
              return {
                type: c.TryStatement,
                block: u,
                guardedHandlers: y,
                handlers: k,
                finalizer: T
              };
            },
            createUnaryExpression: function(u, y) {
              return u === "++" || u === "--" ? {
                type: c.UpdateExpression,
                operator: u,
                argument: y,
                prefix: !0
              } : {
                type: c.UnaryExpression,
                operator: u,
                argument: y,
                prefix: !0
              };
            },
            createVariableDeclaration: function(u, y) {
              return {
                type: c.VariableDeclaration,
                declarations: u,
                kind: y
              };
            },
            createVariableDeclarator: function(u, y) {
              return {
                type: c.VariableDeclarator,
                id: u,
                init: y
              };
            },
            createWhileStatement: function(u, y) {
              return {
                type: c.WhileStatement,
                test: u,
                body: y
              };
            },
            createWithStatement: function(u, y) {
              return {
                type: c.WithStatement,
                object: u,
                body: y
              };
            }
          };
          function Ze() {
            var u, y, k, T;
            return u = f, y = E, k = A, O(), T = E !== y, f = u, E = y, A = k, T;
          }
          function fe(u, y) {
            var k, T = Array.prototype.slice.call(arguments, 2), V = y.replace(
              /%(\d)/g,
              function(ne, Ce) {
                return R(Ce < T.length, "Message reference must be in range"), T[Ce];
              }
            );
            throw typeof u.lineNumber == "number" ? (k = new Error("Line " + u.lineNumber + ": " + V), k.index = u.start, k.lineNumber = u.lineNumber, k.column = u.start - A + 1) : (k = new Error("Line " + E + ": " + V), k.index = f, k.lineNumber = E, k.column = f - A + 1), k.description = V, k;
          }
          function ye() {
            try {
              fe.apply(null, arguments);
            } catch (u) {
              if (S.errors)
                S.errors.push(u);
              else
                throw u;
            }
          }
          function Je(u) {
            if (u.type === o.EOF && fe(u, h.UnexpectedEOS), u.type === o.NumericLiteral && fe(u, h.UnexpectedNumber), u.type === o.StringLiteral && fe(u, h.UnexpectedString), u.type === o.Identifier && fe(u, h.UnexpectedIdentifier), u.type === o.Keyword) {
              if (ce(u.value))
                fe(u, h.UnexpectedReserved);
              else if (b && Ee(u.value)) {
                ye(u, h.StrictReservedWord);
                return;
              }
              fe(u, h.UnexpectedToken, u.value);
            }
            fe(u, h.UnexpectedToken, u.value);
          }
          function C(u) {
            var y = ge();
            (y.type !== o.Punctuator || y.value !== u) && Je(y);
          }
          function $(u) {
            var y = ge();
            (y.type !== o.Keyword || y.value !== u) && Je(y);
          }
          function D(u) {
            return w.type === o.Punctuator && w.value === u;
          }
          function se(u) {
            return w.type === o.Keyword && w.value === u;
          }
          function pe() {
            var u;
            return w.type !== o.Punctuator ? !1 : (u = w.value, u === "=" || u === "*=" || u === "/=" || u === "%=" || u === "+=" || u === "-=" || u === "<<=" || u === ">>=" || u === ">>>=" || u === "&=" || u === "^=" || u === "|=");
          }
          function Se() {
            var u;
            if (m.charCodeAt(f) === 59 || D(";")) {
              ge();
              return;
            }
            u = E, O(), E === u && w.type !== o.EOF && !D("}") && Je(w);
          }
          function Le(u) {
            return u.type === c.Identifier || u.type === c.MemberExpression;
          }
          function ot() {
            var u = [], y;
            for (y = w, C("["); !D("]"); )
              D(",") ? (ge(), u.push(null)) : (u.push(q()), D("]") || C(","));
            return ge(), g.markEnd(g.createArrayExpression(u), y);
          }
          function dt(u, y) {
            var k, T, V;
            return k = b, V = w, T = Vn(), y && b && xe(u[0].name) && ye(y, h.StrictParamName), b = k, g.markEnd(g.createFunctionExpression(null, u, [], T), V);
          }
          function St() {
            var u, y;
            return y = w, u = ge(), u.type === o.StringLiteral || u.type === o.NumericLiteral ? (b && u.octal && ye(u, h.StrictOctalLiteral), g.markEnd(g.createLiteral(u), y)) : g.markEnd(g.createIdentifier(u.value), y);
          }
          function rt() {
            var u, y, k, T, V, ne;
            if (u = w, ne = w, u.type === o.Identifier)
              return k = St(), u.value === "get" && !D(":") ? (y = St(), C("("), C(")"), T = dt([]), g.markEnd(g.createProperty("get", y, T), ne)) : u.value === "set" && !D(":") ? (y = St(), C("("), u = w, u.type !== o.Identifier ? (C(")"), ye(u, h.UnexpectedToken, u.value), T = dt([])) : (V = [he()], C(")"), T = dt(V, u)), g.markEnd(g.createProperty("set", y, T), ne)) : (C(":"), T = q(), g.markEnd(g.createProperty("init", k, T), ne));
            if (u.type === o.EOF || u.type === o.Punctuator)
              Je(u);
            else
              return y = St(), C(":"), T = q(), g.markEnd(g.createProperty("init", y, T), ne);
          }
          function zt() {
            var u = [], y, k, T, V, ne = {}, Ce = String, Me;
            for (Me = w, C("{"); !D("}"); )
              y = rt(), y.key.type === c.Identifier ? k = y.key.name : k = Ce(y.key.value), V = y.kind === "init" ? p.Data : y.kind === "get" ? p.Get : p.Set, T = "$" + k, Object.prototype.hasOwnProperty.call(ne, T) ? (ne[T] === p.Data ? b && V === p.Data ? ye({}, h.StrictDuplicateProperty) : V !== p.Data && ye({}, h.AccessorDataProperty) : V === p.Data ? ye({}, h.AccessorDataProperty) : ne[T] & V && ye({}, h.AccessorGetSet), ne[T] |= V) : ne[T] = V, u.push(y), D("}") || C(",");
            return C("}"), g.markEnd(g.createObjectExpression(u), Me);
          }
          function Xt() {
            var u;
            return C("("), u = G(), C(")"), u;
          }
          function tr() {
            var u, y, k, T;
            if (D("("))
              return Xt();
            if (D("["))
              return ot();
            if (D("{"))
              return zt();
            if (u = w.type, T = w, u === o.Identifier)
              k = g.createIdentifier(ge().value);
            else if (u === o.StringLiteral || u === o.NumericLiteral)
              b && w.octal && ye(w, h.StrictOctalLiteral), k = g.createLiteral(ge());
            else if (u === o.Keyword) {
              if (se("function"))
                return uu();
              se("this") ? (ge(), k = g.createThisExpression()) : Je(ge());
            } else u === o.BooleanLiteral ? (y = ge(), y.value = y.value === "true", k = g.createLiteral(y)) : u === o.NullLiteral ? (y = ge(), y.value = null, k = g.createLiteral(y)) : D("/") || D("/=") ? (typeof S.tokens < "u" ? k = g.createLiteral(qe()) : k = g.createLiteral(Te()), ht()) : Je(ge());
            return g.markEnd(k, T);
          }
          function Nr() {
            var u = [];
            if (C("("), !D(")"))
              for (; f < x && (u.push(q()), !D(")")); )
                C(",");
            return C(")"), u;
          }
          function Ai() {
            var u, y;
            return y = w, u = ge(), tt(u) || Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function Zt() {
            return C("."), Ai();
          }
          function Un() {
            var u;
            return C("["), u = G(), C("]"), u;
          }
          function M() {
            var u, y, k;
            return k = w, $("new"), u = K(), y = D("(") ? Nr() : [], g.markEnd(g.createNewExpression(u, y), k);
          }
          function U() {
            var u, y, k, T, V;
            for (V = w, u = _.allowIn, _.allowIn = !0, y = se("new") ? M() : tr(), _.allowIn = u; ; ) {
              if (D("."))
                T = Zt(), y = g.createMemberExpression(".", y, T);
              else if (D("("))
                k = Nr(), y = g.createCallExpression(y, k);
              else if (D("["))
                T = Un(), y = g.createMemberExpression("[", y, T);
              else
                break;
              g.markEnd(y, V);
            }
            return y;
          }
          function K() {
            var u, y, k, T;
            for (T = w, u = _.allowIn, y = se("new") ? M() : tr(), _.allowIn = u; D(".") || D("["); )
              D("[") ? (k = Un(), y = g.createMemberExpression("[", y, k)) : (k = Zt(), y = g.createMemberExpression(".", y, k)), g.markEnd(y, T);
            return y;
          }
          function de() {
            var u, y, k = w;
            return u = U(), w.type === o.Punctuator && (D("++") || D("--")) && !Ze() && (b && u.type === c.Identifier && xe(u.name) && ye({}, h.StrictLHSPostfix), Le(u) || ye({}, h.InvalidLHSInAssignment), y = ge(), u = g.markEnd(g.createPostfixExpression(y.value, u), k)), u;
          }
          function ve() {
            var u, y, k;
            return w.type !== o.Punctuator && w.type !== o.Keyword ? y = de() : D("++") || D("--") ? (k = w, u = ge(), y = ve(), b && y.type === c.Identifier && xe(y.name) && ye({}, h.StrictLHSPrefix), Le(y) || ye({}, h.InvalidLHSInAssignment), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k)) : D("+") || D("-") || D("~") || D("!") ? (k = w, u = ge(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k)) : se("delete") || se("void") || se("typeof") ? (k = w, u = ge(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k), b && y.operator === "delete" && y.argument.type === c.Identifier && ye({}, h.StrictDelete)) : y = de(), y;
          }
          function Z(u, y) {
            var k = 0;
            if (u.type !== o.Punctuator && u.type !== o.Keyword)
              return 0;
            switch (u.value) {
              case "||":
                k = 1;
                break;
              case "&&":
                k = 2;
                break;
              case "|":
                k = 3;
                break;
              case "^":
                k = 4;
                break;
              case "&":
                k = 5;
                break;
              case "==":
              case "!=":
              case "===":
              case "!==":
                k = 6;
                break;
              case "<":
              case ">":
              case "<=":
              case ">=":
              case "instanceof":
                k = 7;
                break;
              case "in":
                k = y ? 7 : 0;
                break;
              case "<<":
              case ">>":
              case ">>>":
                k = 8;
                break;
              case "+":
              case "-":
                k = 9;
                break;
              case "*":
              case "/":
              case "%":
                k = 11;
                break;
            }
            return k;
          }
          function I() {
            var u, y, k, T, V, ne, Ce, Me, et, Xe;
            if (u = w, et = ve(), T = w, V = Z(T, _.allowIn), V === 0)
              return et;
            for (T.prec = V, ge(), y = [u, w], Ce = ve(), ne = [et, T, Ce]; (V = Z(w, _.allowIn)) > 0; ) {
              for (; ne.length > 2 && V <= ne[ne.length - 2].prec; )
                Ce = ne.pop(), Me = ne.pop().value, et = ne.pop(), k = g.createBinaryExpression(Me, et, Ce), y.pop(), u = y[y.length - 1], g.markEnd(k, u), ne.push(k);
              T = ge(), T.prec = V, ne.push(T), y.push(w), k = ve(), ne.push(k);
            }
            for (Xe = ne.length - 1, k = ne[Xe], y.pop(); Xe > 1; )
              k = g.createBinaryExpression(ne[Xe - 1].value, ne[Xe - 2], k), Xe -= 2, u = y.pop(), g.markEnd(k, u);
            return k;
          }
          function B() {
            var u, y, k, T, V;
            return V = w, u = I(), D("?") && (ge(), y = _.allowIn, _.allowIn = !0, k = q(), _.allowIn = y, C(":"), T = q(), u = g.createConditionalExpression(u, k, T), g.markEnd(u, V)), u;
          }
          function q() {
            var u, y, k, T, V;
            return u = w, V = w, T = y = B(), pe() && (Le(y) || ye({}, h.InvalidLHSInAssignment), b && y.type === c.Identifier && xe(y.name) && ye(u, h.StrictLHSAssignment), u = ge(), k = q(), T = g.markEnd(g.createAssignmentExpression(u.value, y, k), V)), T;
          }
          function G() {
            var u, y = w;
            if (u = q(), D(",")) {
              for (u = g.createSequenceExpression([u]); f < x && D(","); )
                ge(), u.expressions.push(q());
              g.markEnd(u, y);
            }
            return u;
          }
          function Y() {
            for (var u = [], y; f < x && !(D("}") || (y = Ir(), typeof y > "u")); )
              u.push(y);
            return u;
          }
          function ie() {
            var u, y;
            return y = w, C("{"), u = Y(), C("}"), g.markEnd(g.createBlockStatement(u), y);
          }
          function he() {
            var u, y;
            return y = w, u = ge(), u.type !== o.Identifier && Je(u), g.markEnd(g.createIdentifier(u.value), y);
          }
          function be(u) {
            var y = null, k, T;
            return T = w, k = he(), b && xe(k.name) && ye({}, h.StrictVarName), u === "const" ? (C("="), y = q()) : D("=") && (ge(), y = q()), g.markEnd(g.createVariableDeclarator(k, y), T);
          }
          function ke(u) {
            var y = [];
            do {
              if (y.push(be(u)), !D(","))
                break;
              ge();
            } while (f < x);
            return y;
          }
          function De() {
            var u;
            return $("var"), u = ke(), Se(), g.createVariableDeclaration(u, "var");
          }
          function $e(u) {
            var y, k;
            return k = w, $(u), y = ke(u), Se(), g.markEnd(g.createVariableDeclaration(y, u), k);
          }
          function Qe() {
            return C(";"), g.createEmptyStatement();
          }
          function ut() {
            var u = G();
            return Se(), g.createExpressionStatement(u);
          }
          function st() {
            var u, y, k;
            return $("if"), C("("), u = G(), C(")"), y = Ot(), se("else") ? (ge(), k = Ot()) : k = null, g.createIfStatement(u, y, k);
          }
          function Rt() {
            var u, y, k;
            return $("do"), k = _.inIteration, _.inIteration = !0, u = Ot(), _.inIteration = k, $("while"), C("("), y = G(), C(")"), D(";") && ge(), g.createDoWhileStatement(u, y);
          }
          function $t() {
            var u, y, k;
            return $("while"), C("("), u = G(), C(")"), k = _.inIteration, _.inIteration = !0, y = Ot(), _.inIteration = k, g.createWhileStatement(u, y);
          }
          function Or() {
            var u, y, k;
            return k = w, u = ge(), y = ke(), g.markEnd(g.createVariableDeclaration(y, u.value), k);
          }
          function an() {
            var u, y, k, T, V, ne, Ce;
            return u = y = k = null, $("for"), C("("), D(";") ? ge() : (se("var") || se("let") ? (_.allowIn = !1, u = Or(), _.allowIn = !0, u.declarations.length === 1 && se("in") && (ge(), T = u, V = G(), u = null)) : (_.allowIn = !1, u = G(), _.allowIn = !0, se("in") && (Le(u) || ye({}, h.InvalidLHSInForIn), ge(), T = u, V = G(), u = null)), typeof T > "u" && C(";")), typeof T > "u" && (D(";") || (y = G()), C(";"), D(")") || (k = G())), C(")"), Ce = _.inIteration, _.inIteration = !0, ne = Ot(), _.inIteration = Ce, typeof T > "u" ? g.createForStatement(u, y, k, ne) : g.createForInStatement(T, V, ne);
          }
          function wo() {
            var u = null, y;
            return $("continue"), m.charCodeAt(f) === 59 ? (ge(), _.inIteration || fe({}, h.IllegalContinue), g.createContinueStatement(null)) : Ze() ? (_.inIteration || fe({}, h.IllegalContinue), g.createContinueStatement(null)) : (w.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(_.labelSet, y) || fe({}, h.UnknownLabel, u.name)), Se(), u === null && !_.inIteration && fe({}, h.IllegalContinue), g.createContinueStatement(u));
          }
          function xo() {
            var u = null, y;
            return $("break"), m.charCodeAt(f) === 59 ? (ge(), _.inIteration || _.inSwitch || fe({}, h.IllegalBreak), g.createBreakStatement(null)) : Ze() ? (_.inIteration || _.inSwitch || fe({}, h.IllegalBreak), g.createBreakStatement(null)) : (w.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(_.labelSet, y) || fe({}, h.UnknownLabel, u.name)), Se(), u === null && !(_.inIteration || _.inSwitch) && fe({}, h.IllegalBreak), g.createBreakStatement(u));
          }
          function ru() {
            var u = null;
            return $("return"), _.inFunctionBody || ye({}, h.IllegalReturn), m.charCodeAt(f) === 32 && te(m.charCodeAt(f + 1)) ? (u = G(), Se(), g.createReturnStatement(u)) : Ze() ? g.createReturnStatement(null) : (D(";") || !D("}") && w.type !== o.EOF && (u = G()), Se(), g.createReturnStatement(u));
          }
          function nu() {
            var u, y;
            return b && (O(), ye({}, h.StrictModeWith)), $("with"), C("("), u = G(), C(")"), y = Ot(), g.createWithStatement(u, y);
          }
          function iu() {
            var u, y = [], k, T;
            for (T = w, se("default") ? (ge(), u = null) : ($("case"), u = G()), C(":"); f < x && !(D("}") || se("default") || se("case")); )
              k = Ot(), y.push(k);
            return g.markEnd(g.createSwitchCase(u, y), T);
          }
          function su() {
            var u, y, k, T, V;
            if ($("switch"), C("("), u = G(), C(")"), C("{"), y = [], D("}"))
              return ge(), g.createSwitchStatement(u, y);
            for (T = _.inSwitch, _.inSwitch = !0, V = !1; f < x && !D("}"); )
              k = iu(), k.test === null && (V && fe({}, h.MultipleDefaultsInSwitch), V = !0), y.push(k);
            return _.inSwitch = T, C("}"), g.createSwitchStatement(u, y);
          }
          function ou() {
            var u;
            return $("throw"), Ze() && fe({}, h.NewlineAfterThrow), u = G(), Se(), g.createThrowStatement(u);
          }
          function au() {
            var u, y, k;
            return k = w, $("catch"), C("("), D(")") && Je(w), u = he(), b && xe(u.name) && ye({}, h.StrictCatchVariable), C(")"), y = ie(), g.markEnd(g.createCatchClause(u, y), k);
          }
          function lu() {
            var u, y = [], k = null;
            return $("try"), u = ie(), se("catch") && y.push(au()), se("finally") && (ge(), k = ie()), y.length === 0 && !k && fe({}, h.NoCatchOrFinally), g.createTryStatement(u, [], y, k);
          }
          function cu() {
            return $("debugger"), Se(), g.createDebuggerStatement();
          }
          function Ot() {
            var u = w.type, y, k, T, V;
            if (u === o.EOF && Je(w), u === o.Punctuator && w.value === "{")
              return ie();
            if (V = w, u === o.Punctuator)
              switch (w.value) {
                case ";":
                  return g.markEnd(Qe(), V);
                case "(":
                  return g.markEnd(ut(), V);
              }
            if (u === o.Keyword)
              switch (w.value) {
                case "break":
                  return g.markEnd(xo(), V);
                case "continue":
                  return g.markEnd(wo(), V);
                case "debugger":
                  return g.markEnd(cu(), V);
                case "do":
                  return g.markEnd(Rt(), V);
                case "for":
                  return g.markEnd(an(), V);
                case "function":
                  return g.markEnd(Ps(), V);
                case "if":
                  return g.markEnd(st(), V);
                case "return":
                  return g.markEnd(ru(), V);
                case "switch":
                  return g.markEnd(su(), V);
                case "throw":
                  return g.markEnd(ou(), V);
                case "try":
                  return g.markEnd(lu(), V);
                case "var":
                  return g.markEnd(De(), V);
                case "while":
                  return g.markEnd($t(), V);
                case "with":
                  return g.markEnd(nu(), V);
              }
            return y = G(), y.type === c.Identifier && D(":") ? (ge(), T = "$" + y.name, Object.prototype.hasOwnProperty.call(_.labelSet, T) && fe({}, h.Redeclaration, "Label", y.name), _.labelSet[T] = !0, k = Ot(), delete _.labelSet[T], g.markEnd(g.createLabeledStatement(y, k), V)) : (Se(), g.markEnd(g.createExpressionStatement(y), V));
          }
          function Vn() {
            var u, y = [], k, T, V, ne, Ce, Me, et, Xe;
            for (Xe = w, C("{"); f < x && !(w.type !== o.StringLiteral || (k = w, u = Ir(), y.push(u), u.expression.type !== c.Literal)); )
              T = m.slice(k.start + 1, k.end - 1), T === "use strict" ? (b = !0, V && ye(V, h.StrictOctalLiteral)) : !V && k.octal && (V = k);
            for (ne = _.labelSet, Ce = _.inIteration, Me = _.inSwitch, et = _.inFunctionBody, _.labelSet = {}, _.inIteration = !1, _.inSwitch = !1, _.inFunctionBody = !0; f < x && !(D("}") || (u = Ir(), typeof u > "u")); )
              y.push(u);
            return C("}"), _.labelSet = ne, _.inIteration = Ce, _.inSwitch = Me, _.inFunctionBody = et, g.markEnd(g.createBlockStatement(y), Xe);
          }
          function Is(u) {
            var y, k = [], T, V, ne, Ce, Me;
            if (C("("), !D(")"))
              for (ne = {}; f < x && (T = w, y = he(), Ce = "$" + T.value, b ? (xe(T.value) && (V = T, Me = h.StrictParamName), Object.prototype.hasOwnProperty.call(ne, Ce) && (V = T, Me = h.StrictParamDupe)) : u || (xe(T.value) ? (u = T, Me = h.StrictParamName) : Ee(T.value) ? (u = T, Me = h.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ne, Ce) && (u = T, Me = h.StrictParamDupe)), k.push(y), ne[Ce] = !0, !D(")")); )
                C(",");
            return C(")"), {
              params: k,
              stricted: V,
              firstRestricted: u,
              message: Me
            };
          }
          function Ps() {
            var u, y = [], k, T, V, ne, Ce, Me, et, Xe;
            return Xe = w, $("function"), T = w, u = he(), b ? xe(T.value) && ye(T, h.StrictFunctionName) : xe(T.value) ? (Ce = T, Me = h.StrictFunctionName) : Ee(T.value) && (Ce = T, Me = h.StrictReservedWord), ne = Is(Ce), y = ne.params, V = ne.stricted, Ce = ne.firstRestricted, ne.message && (Me = ne.message), et = b, k = Vn(), b && Ce && fe(Ce, Me), b && V && ye(V, Me), b = et, g.markEnd(g.createFunctionDeclaration(u, y, [], k), Xe);
          }
          function uu() {
            var u, y = null, k, T, V, ne, Ce = [], Me, et, Xe;
            return Xe = w, $("function"), D("(") || (u = w, y = he(), b ? xe(u.value) && ye(u, h.StrictFunctionName) : xe(u.value) ? (T = u, V = h.StrictFunctionName) : Ee(u.value) && (T = u, V = h.StrictReservedWord)), ne = Is(T), Ce = ne.params, k = ne.stricted, T = ne.firstRestricted, ne.message && (V = ne.message), et = b, Me = Vn(), b && T && fe(T, V), b && k && ye(k, V), b = et, g.markEnd(g.createFunctionExpression(y, Ce, [], Me), Xe);
          }
          function Ir() {
            if (w.type === o.Keyword)
              switch (w.value) {
                case "const":
                case "let":
                  return $e(w.value);
                case "function":
                  return Ps();
                default:
                  return Ot();
              }
            if (w.type !== o.EOF)
              return Ot();
          }
          function hu() {
            for (var u, y = [], k, T, V; f < x && (k = w, !(k.type !== o.StringLiteral || (u = Ir(), y.push(u), u.expression.type !== c.Literal))); )
              T = m.slice(k.start + 1, k.end - 1), T === "use strict" ? (b = !0, V && ye(V, h.StrictOctalLiteral)) : !V && k.octal && (V = k);
            for (; f < x && (u = Ir(), !(typeof u > "u")); )
              y.push(u);
            return y;
          }
          function pu() {
            var u, y;
            return O(), ht(), y = w, b = !1, u = hu(), g.markEnd(g.createProgram(u), y);
          }
          function Rs() {
            var u, y, k, T = [];
            for (u = 0; u < S.tokens.length; ++u)
              y = S.tokens[u], k = {
                type: y.type,
                value: y.value
              }, S.range && (k.range = y.range), S.loc && (k.loc = y.loc), T.push(k);
            S.tokens = T;
          }
          function du(u, y) {
            var k, T, V;
            k = String, typeof u != "string" && !(u instanceof String) && (u = k(u)), g = v, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, y = y || {}, y.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []);
            try {
              if (ht(), w.type === o.EOF)
                return S.tokens;
              for (T = ge(); w.type !== o.EOF; )
                try {
                  T = ge();
                } catch (ne) {
                  if (T = w, S.errors) {
                    S.errors.push(ne);
                    break;
                  } else
                    throw ne;
                }
              Rs(), V = S.tokens, typeof S.comments < "u" && (V.comments = S.comments), typeof S.errors < "u" && (V.errors = S.errors);
            } catch (ne) {
              throw ne;
            } finally {
              S = {};
            }
            return V;
          }
          function fu(u, y) {
            var k, T;
            T = String, typeof u != "string" && !(u instanceof String) && (u = T(u)), g = v, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, w = null, _ = {
              allowIn: !0,
              labelSet: {},
              inFunctionBody: !1,
              inIteration: !1,
              inSwitch: !1,
              lastCommentStart: -1
            }, S = {}, typeof y < "u" && (S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, S.attachComment = typeof y.attachComment == "boolean" && y.attachComment, S.loc && y.source !== null && y.source !== void 0 && (S.source = T(y.source)), typeof y.tokens == "boolean" && y.tokens && (S.tokens = []), typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
            try {
              k = pu(), typeof S.comments < "u" && (k.comments = S.comments), typeof S.tokens < "u" && (Rs(), k.tokens = S.tokens), typeof S.errors < "u" && (k.errors = S.errors);
            } catch (V) {
              throw V;
            } finally {
              S = {};
            }
            return k;
          }
          s.version = "1.2.2", s.tokenize = du, s.parse = fu, s.Syntax = function() {
            var u, y = {};
            typeof Object.create == "function" && (y = /* @__PURE__ */ Object.create(null));
            for (u in c)
              c.hasOwnProperty(u) && (y[u] = c[u]);
            return typeof Object.freeze == "function" && Object.freeze(y), y;
          }();
        });
      }, {}], 1: [function(r, n, i) {
        (function(s) {
          var o = function() {
            var a = {
              trace: function() {
              },
              yy: {},
              symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
              terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
              productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
              performAction: function(h, d, v, m, b, f, E) {
                m.ast || (m.ast = l, l.initialize());
                var A = f.length - 1;
                switch (b) {
                  case 1:
                    return m.ast.set({ expression: { type: "root", value: f[A] } }), m.ast.unshift(), m.ast.yield();
                  case 2:
                    return m.ast.set({ expression: { type: "root", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 3:
                    return m.ast.unshift(), m.ast.yield();
                  case 4:
                    return m.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                  case 5:
                    break;
                  case 6:
                    break;
                  case 7:
                    m.ast.set({ operation: "member" }), m.ast.push();
                    break;
                  case 8:
                    m.ast.set({ operation: "subscript" }), m.ast.push();
                    break;
                  case 9:
                    m.ast.set({ scope: "child" });
                    break;
                  case 10:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 11:
                    break;
                  case 12:
                    m.ast.set({ scope: "child", operation: "member" });
                    break;
                  case 13:
                    break;
                  case 14:
                    m.ast.set({ expression: { type: "wildcard", value: f[A] } });
                    break;
                  case 15:
                    m.ast.set({ expression: { type: "identifier", value: f[A] } });
                    break;
                  case 16:
                    m.ast.set({ expression: { type: "script_expression", value: f[A] } });
                    break;
                  case 17:
                    m.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                    break;
                  case 18:
                    break;
                  case 19:
                    m.ast.set({ scope: "child" });
                    break;
                  case 20:
                    m.ast.set({ scope: "descendant" });
                    break;
                  case 21:
                    break;
                  case 22:
                    break;
                  case 23:
                    break;
                  case 24:
                    f[A].length > 1 ? m.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                    break;
                  case 25:
                    this.$ = [f[A]];
                    break;
                  case 26:
                    this.$ = f[A - 2].concat(f[A]);
                    break;
                  case 27:
                    this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, m.ast.set(this.$);
                    break;
                  case 28:
                    this.$ = { expression: { type: "string_literal", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 29:
                    this.$ = { expression: { type: "slice", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 30:
                    this.$ = { expression: { type: "wildcard", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 31:
                    this.$ = { expression: { type: "script_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 32:
                    this.$ = { expression: { type: "filter_expression", value: f[A] } }, m.ast.set(this.$);
                    break;
                  case 33:
                    this.$ = f[A];
                    break;
                  case 34:
                    this.$ = f[A];
                    break;
                }
              },
              table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
              defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
              parseError: function(h, d) {
                if (d.recoverable)
                  this.trace(h);
                else
                  throw new Error(h);
              },
              parse: function(h) {
                var d = this, v = [0], m = [null], b = [], f = this.table, E = "", A = 0, x = 0, g = 2, w = 1, _ = b.slice.call(arguments, 1);
                this.lexer.setInput(h), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
                var S = this.lexer.yylloc;
                b.push(S);
                var R = this.lexer.options && this.lexer.options.ranges;
                typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
                function L() {
                  var Ie;
                  return Ie = d.lexer.lex() || w, typeof Ie != "number" && (Ie = d.symbols_[Ie] || Ie), Ie;
                }
                for (var F, z, j, W, te = {}, le, ce, Ee, xe; ; ) {
                  if (z = v[v.length - 1], this.defaultActions[z] ? j = this.defaultActions[z] : ((F === null || typeof F > "u") && (F = L()), j = f[z] && f[z][F]), typeof j > "u" || !j.length || !j[0]) {
                    var _e = "";
                    xe = [];
                    for (le in f[z])
                      this.terminals_[le] && le > g && xe.push("'" + this.terminals_[le] + "'");
                    this.lexer.showPosition ? _e = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + xe.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : _e = "Parse error on line " + (A + 1) + ": Unexpected " + (F == w ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(_e, {
                      text: this.lexer.match,
                      token: this.terminals_[F] || F,
                      line: this.lexer.yylineno,
                      loc: S,
                      expected: xe
                    });
                  }
                  if (j[0] instanceof Array && j.length > 1)
                    throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + F);
                  switch (j[0]) {
                    case 1:
                      v.push(F), m.push(this.lexer.yytext), b.push(this.lexer.yylloc), v.push(j[1]), F = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                      break;
                    case 2:
                      if (ce = this.productions_[j[1]][1], te.$ = m[m.length - ce], te._$ = {
                        first_line: b[b.length - (ce || 1)].first_line,
                        last_line: b[b.length - 1].last_line,
                        first_column: b[b.length - (ce || 1)].first_column,
                        last_column: b[b.length - 1].last_column
                      }, R && (te._$.range = [
                        b[b.length - (ce || 1)].range[0],
                        b[b.length - 1].range[1]
                      ]), W = this.performAction.apply(te, [
                        E,
                        x,
                        A,
                        this.yy,
                        j[1],
                        m,
                        b
                      ].concat(_)), typeof W < "u")
                        return W;
                      ce && (v = v.slice(0, -1 * ce * 2), m = m.slice(0, -1 * ce), b = b.slice(0, -1 * ce)), v.push(this.productions_[j[1]][0]), m.push(te.$), b.push(te._$), Ee = f[v[v.length - 2]][v[v.length - 1]], v.push(Ee);
                      break;
                    case 3:
                      return !0;
                  }
                }
                return !0;
              }
            }, l = {
              initialize: function() {
                this._nodes = [], this._node = {}, this._stash = [];
              },
              set: function(h) {
                for (var d in h) this._node[d] = h[d];
                return this._node;
              },
              node: function(h) {
                return arguments.length && (this._node = h), this._node;
              },
              push: function() {
                this._nodes.push(this._node), this._node = {};
              },
              unshift: function() {
                this._nodes.unshift(this._node), this._node = {};
              },
              yield: function() {
                var h = this._nodes;
                return this.initialize(), h;
              }
            }, c = /* @__PURE__ */ function() {
              var h = {
                EOF: 1,
                parseError: function(d, v) {
                  if (this.yy.parser)
                    this.yy.parser.parseError(d, v);
                  else
                    throw new Error(d);
                },
                // resets the lexer, sets new input
                setInput: function(d) {
                  return this._input = d, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                  }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
                },
                // consumes and returns one char from the input
                input: function() {
                  var d = this._input[0];
                  this.yytext += d, this.yyleng++, this.offset++, this.match += d, this.matched += d;
                  var v = d.match(/(?:\r\n?|\n).*/g);
                  return v ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), d;
                },
                // unshifts one char (or a string) into the input
                unput: function(d) {
                  var v = d.length, m = d.split(/(?:\r\n?|\n)/g);
                  this._input = d + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - v - 1), this.offset -= v;
                  var b = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
                  var f = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: m ? (m.length === b.length ? this.yylloc.first_column : 0) + b[b.length - m.length].length - m[0].length : this.yylloc.first_column - v
                  }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - v]), this.yyleng = this.yytext.length, this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function() {
                  return this._more = !0, this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function() {
                  if (this.options.backtrack_lexer)
                    this._backtrack = !0;
                  else
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                      text: "",
                      token: null,
                      line: this.yylineno
                    });
                  return this;
                },
                // retain first n characters of the match
                less: function(d) {
                  this.unput(this.match.slice(d));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function() {
                  var d = this.matched.substr(0, this.matched.length - this.match.length);
                  return (d.length > 20 ? "..." : "") + d.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function() {
                  var d = this.match;
                  return d.length < 20 && (d += this._input.substr(0, 20 - d.length)), (d.substr(0, 20) + (d.length > 20 ? "..." : "")).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function() {
                  var d = this.pastInput(), v = new Array(d.length + 1).join("-");
                  return d + this.upcomingInput() + `
` + v + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function(d, v) {
                  var m, b, f;
                  if (this.options.backtrack_lexer && (f = {
                    yylineno: this.yylineno,
                    yylloc: {
                      first_line: this.yylloc.first_line,
                      last_line: this.last_line,
                      first_column: this.yylloc.first_column,
                      last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: this.conditionStack.slice(0),
                    done: this.done
                  }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), b = d[0].match(/(?:\r\n?|\n).*/g), b && (this.yylineno += b.length), this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: b ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + d[0].length
                  }, this.yytext += d[0], this.match += d[0], this.matches = d, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(d[0].length), this.matched += d[0], m = this.performAction.call(this, this.yy, this, v, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
                    return m;
                  if (this._backtrack) {
                    for (var E in f)
                      this[E] = f[E];
                    return !1;
                  }
                  return !1;
                },
                // return next match in input
                next: function() {
                  if (this.done)
                    return this.EOF;
                  this._input || (this.done = !0);
                  var d, v, m, b;
                  this._more || (this.yytext = "", this.match = "");
                  for (var f = this._currentRules(), E = 0; E < f.length; E++)
                    if (m = this._input.match(this.rules[f[E]]), m && (!v || m[0].length > v[0].length)) {
                      if (v = m, b = E, this.options.backtrack_lexer) {
                        if (d = this.test_match(m, f[E]), d !== !1)
                          return d;
                        if (this._backtrack) {
                          v = !1;
                          continue;
                        } else
                          return !1;
                      } else if (!this.options.flex)
                        break;
                    }
                  return v ? (d = this.test_match(v, f[b]), d !== !1 ? d : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                },
                // return next match that has a token
                lex: function() {
                  var d = this.next();
                  return d || this.lex();
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function(d) {
                  this.conditionStack.push(d);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function() {
                  var d = this.conditionStack.length - 1;
                  return d > 0 ? this.conditionStack.pop() : this.conditionStack[0];
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function() {
                  return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function(d) {
                  return d = this.conditionStack.length - 1 - Math.abs(d || 0), d >= 0 ? this.conditionStack[d] : "INITIAL";
                },
                // alias for begin(condition)
                pushState: function(d) {
                  this.begin(d);
                },
                // return the number of states currently on the stack
                stateStackSize: function() {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function(d, v, m, b) {
                  switch (m) {
                    case 0:
                      return 4;
                    case 1:
                      return 14;
                    case 2:
                      return 12;
                    case 3:
                      return 15;
                    case 4:
                      return 16;
                    case 5:
                      return 22;
                    case 6:
                      return 24;
                    case 7:
                      return 28;
                    case 8:
                      return 30;
                    case 9:
                      return 18;
                    case 10:
                      return v.yytext = v.yytext.substr(1, v.yyleng - 2), 32;
                    case 11:
                      return v.yytext = v.yytext.substr(1, v.yyleng - 2), 33;
                    case 12:
                      return 17;
                    case 13:
                      return 31;
                  }
                },
                rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
                conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
              };
              return h;
            }();
            a.lexer = c;
            function p() {
              this.yy = {};
            }
            return p.prototype = a, a.Parser = p, new p();
          }();
          typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
            return o.parse.apply(o, arguments);
          }, i.main = function(a) {
            a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
            var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
            return i.parser.parse(l);
          }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
        }).call(this, r("_process"));
      }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
        n.exports = {
          identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
          integer: "-?(?:0|[1-9][0-9]*)",
          qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
          q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
        };
      }, {}], 3: [function(r, n, i) {
        var s = r("./dict"), o = r("fs"), a = {
          lex: {
            macros: {
              esc: "\\\\",
              int: s.integer
            },
            rules: [
              ["\\$", "return 'DOLLAR'"],
              ["\\.\\.", "return 'DOT_DOT'"],
              ["\\.", "return 'DOT'"],
              ["\\*", "return 'STAR'"],
              [s.identifier, "return 'IDENTIFIER'"],
              ["\\[", "return '['"],
              ["\\]", "return ']'"],
              [",", "return ','"],
              ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
              ["{int}", "return 'INTEGER'"],
              [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
              [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
              ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
              ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
            ]
          },
          start: "JSON_PATH",
          bnf: {
            JSON_PATH: [
              ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
              ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
              ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
            ],
            PATH_COMPONENTS: [
              ["PATH_COMPONENT", ""],
              ["PATH_COMPONENTS PATH_COMPONENT", ""]
            ],
            PATH_COMPONENT: [
              ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
              ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
            ],
            MEMBER_COMPONENT: [
              ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_MEMBER_COMPONENT: [
              ["DOT MEMBER_EXPRESSION", ""]
            ],
            LEADING_CHILD_MEMBER_EXPRESSION: [
              ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
            ],
            DESCENDANT_MEMBER_COMPONENT: [
              ["DOT_DOT MEMBER_EXPRESSION", ""]
            ],
            MEMBER_EXPRESSION: [
              ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
              ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
              ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
              ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
              ["END", ""]
            ],
            SUBSCRIPT_COMPONENT: [
              ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
              ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
            ],
            CHILD_SUBSCRIPT_COMPONENT: [
              ["[ SUBSCRIPT ]", ""]
            ],
            DESCENDANT_SUBSCRIPT_COMPONENT: [
              ["DOT_DOT [ SUBSCRIPT ]", ""]
            ],
            SUBSCRIPT: [
              ["SUBSCRIPT_EXPRESSION", ""],
              ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
            ],
            SUBSCRIPT_EXPRESSION_LIST: [
              ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
              ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
            ],
            SUBSCRIPT_EXPRESSION_LISTABLE: [
              ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
              ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
              ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
            ],
            SUBSCRIPT_EXPRESSION: [
              ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
              ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
              ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
            ],
            STRING_LITERAL: [
              ["QQ_STRING", "$$ = $1"],
              ["Q_STRING", "$$ = $1"]
            ]
          }
        };
        o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
      }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
        var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
          return this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.traverse = v(!0), this.descend = v();
        }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
          var g = [x.operation, x.scope, x.expression.type].join("-"), w = this._fns[g];
          if (!w) throw new Error("couldn't resolve key: " + g);
          return w.bind(this);
        }, c.prototype.register = function(x, g) {
          if (!g instanceof Function)
            throw new Error("handler must be a function");
          this._fns[x] = g;
        }, c.prototype._fns = {
          "member-child-identifier": function(x, g) {
            var w = x.expression.value, _ = g.value;
            if (_ instanceof Object && w in _)
              return [{ value: _[w], path: g.path.concat(w) }];
          },
          "member-descendant-identifier": b(function(x, g, w) {
            return x == w;
          }),
          "subscript-child-numeric_literal": m(function(x, g, w) {
            return x === w;
          }),
          "member-child-numeric_literal": m(function(x, g, w) {
            return String(x) === String(w);
          }),
          "subscript-descendant-numeric_literal": b(function(x, g, w) {
            return x === w;
          }),
          "member-child-wildcard": m(function() {
            return !0;
          }),
          "member-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-descendant-wildcard": b(function() {
            return !0;
          }),
          "subscript-child-wildcard": m(function() {
            return !0;
          }),
          "subscript-child-slice": function(x, g) {
            if (h(g.value)) {
              var w = x.expression.value.split(":").map(A), _ = g.value.map(function(S, R) {
                return { value: S, path: g.path.concat(R) };
              });
              return o.apply(null, [_].concat(w));
            }
          },
          "subscript-child-union": function(x, g) {
            var w = [];
            return x.expression.value.forEach(function(_) {
              var S = { operation: "subscript", scope: "child", expression: _.expression }, R = this.resolve(S), L = R(S, g);
              L && (w = w.concat(L));
            }, this), E(w);
          },
          "subscript-descendant-union": function(x, g, w) {
            var _ = r(".."), S = this, R = [], L = _.nodes(g, "$..*").slice(1);
            return L.forEach(function(F) {
              R.length >= w || x.expression.value.forEach(function(z) {
                var j = { operation: "subscript", scope: "child", expression: z.expression }, W = S.resolve(j), te = W(j, F);
                R = R.concat(te);
              });
            }), E(R);
          },
          "subscript-child-filter_expression": function(x, g, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.descend(g, null, R, w);
          },
          "subscript-descendant-filter_expression": function(x, g, w) {
            var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(L, F) {
              return f(S, { "@": F });
            };
            return this.traverse(g, null, R, w);
          },
          "subscript-child-script_expression": function(x, g) {
            var w = x.expression.value.slice(1, -1);
            return p(g, w, "$[{{value}}]");
          },
          "member-child-script_expression": function(x, g) {
            var w = x.expression.value.slice(1, -1);
            return p(g, w, "$.{{value}}");
          },
          "member-descendant-script_expression": function(x, g) {
            var w = x.expression.value.slice(1, -1);
            return p(g, w, "$..value");
          }
        }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
        function p(x, g, w) {
          var _ = r("./index"), S = s.parse(g).body[0].expression, R = f(S, { "@": x.value }), L = w.replace(/\{\{\s*value\s*\}\}/g, R), F = _.nodes(x.value, L);
          return F.forEach(function(z) {
            z.path = x.path.concat(z.path.slice(1));
          }), F;
        }
        function h(x) {
          return Array.isArray(x);
        }
        function d(x) {
          return x && !(x instanceof Array) && x instanceof Object;
        }
        function v(x) {
          return function(g, w, _, S) {
            var R = g.value, L = g.path, F = [], z = (function(j, W) {
              h(j) ? (j.forEach(function(te, le) {
                F.length >= S || _(le, te, w) && F.push({ path: W.concat(le), value: te });
              }), j.forEach(function(te, le) {
                F.length >= S || x && z(te, W.concat(le));
              })) : d(j) && (this.keys(j).forEach(function(te) {
                F.length >= S || _(te, j[te], w) && F.push({ path: W.concat(te), value: j[te] });
              }), this.keys(j).forEach(function(te) {
                F.length >= S || x && z(j[te], W.concat(te));
              }));
            }).bind(this);
            return z(R, L), F;
          };
        }
        function m(x) {
          return function(g, w, _) {
            return this.descend(w, g.expression.value, x, _);
          };
        }
        function b(x) {
          return function(g, w, _) {
            return this.traverse(w, g.expression.value, x, _);
          };
        }
        function f() {
          try {
            return a.apply(this, arguments);
          } catch {
          }
        }
        function E(x) {
          return x = x.filter(function(g) {
            return g;
          }), l(
            x,
            function(g) {
              return g.path.map(function(w) {
                return String(w).replace("-", "--");
              }).join("-");
            }
          );
        }
        function A(x) {
          var g = String(x);
          return g.match(/^-?[0-9]+$/) ? parseInt(g) : null;
        }
        n.exports = c;
      }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
        var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
          this.initialize.apply(this, arguments);
        };
        c.prototype.initialize = function() {
          this.parser = new a(), this.handlers = new l();
        }, c.prototype.parse = function(d) {
          return s.ok(p(d), "we need a path"), this.parser.parse(d);
        }, c.prototype.parent = function(d, v) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
          var m = this.nodes(d, v)[0];
          return m.path.pop(), this.value(d, m.path);
        }, c.prototype.apply = function(d, v, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), s.equal(typeof m, "function", "fn needs to be function");
          var b = this.nodes(d, v).sort(function(f, E) {
            return E.path.length - f.path.length;
          });
          return b.forEach(function(f) {
            var E = f.path.pop(), A = this.value(d, this.stringify(f.path)), x = f.value = m.call(d, A[E]);
            A[E] = x;
          }, this), b;
        }, c.prototype.value = function(d, v, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), arguments.length >= 3) {
            var b = this.nodes(d, v).shift();
            if (!b) return this._vivify(d, v, m);
            var f = b.path.slice(-1).shift(), E = this.parent(d, this.stringify(b.path));
            E[f] = m;
          }
          return this.query(d, this.stringify(v), 1).shift();
        }, c.prototype._vivify = function(d, v, m) {
          var b = this;
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
          var f = this.parser.parse(v).map(function(A) {
            return A.expression.value;
          }), E = function(A, x) {
            var g = A.pop(), w = b.value(d, A);
            w || (E(A.concat(), typeof g == "string" ? {} : []), w = b.value(d, A)), w[g] = x;
          };
          return E(f, m), this.query(d, v)[0];
        }, c.prototype.query = function(d, v, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(p(v), "we need a path");
          var b = this.nodes(d, v, m).map(function(f) {
            return f.value;
          });
          return b;
        }, c.prototype.paths = function(d, v, m) {
          s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
          var b = this.nodes(d, v, m).map(function(f) {
            return f.path;
          });
          return b;
        }, c.prototype.nodes = function(d, v, m) {
          if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), m === 0) return [];
          var b = this.parser.parse(v), f = this.handlers, E = [{ path: ["$"], value: d }], A = [];
          return b.length && b[0].expression.type == "root" && b.shift(), b.length ? (b.forEach(function(x, g) {
            if (!(A.length >= m)) {
              var w = f.resolve(x), _ = [];
              E.forEach(function(S) {
                if (!(A.length >= m)) {
                  var R = w(x, S, m);
                  g == b.length - 1 ? A = A.concat(R || []) : _ = _.concat(R || []);
                }
              }), E = _;
            }
          }), m ? A.slice(0, m) : A) : E;
        }, c.prototype.stringify = function(d) {
          s.ok(d, "we need a path");
          var v = "$", m = {
            "descendant-member": "..{{value}}",
            "child-member": ".{{value}}",
            "descendant-subscript": "..[{{value}}]",
            "child-subscript": "[{{value}}]"
          };
          return d = this._normalize(d), d.forEach(function(b) {
            if (b.expression.type != "root") {
              var f = [b.scope, b.operation].join("-"), E = m[f], A;
              if (b.expression.type == "string_literal" ? A = JSON.stringify(b.expression.value) : A = b.expression.value, !E) throw new Error("couldn't find template " + f);
              v += E.replace(/{{value}}/, A);
            }
          }), v;
        }, c.prototype._normalize = function(d) {
          if (s.ok(d, "we need a path"), typeof d == "string")
            return this.parser.parse(d);
          if (Array.isArray(d) && typeof d[0] == "string") {
            var v = [{ expression: { type: "root", value: "$" } }];
            return d.forEach(function(m, b) {
              if (!(m == "$" && b === 0))
                if (typeof m == "string" && m.match("^" + o.identifier + "$"))
                  v.push({
                    operation: "member",
                    scope: "child",
                    expression: { value: m, type: "identifier" }
                  });
                else {
                  var f = typeof m == "number" ? "numeric_literal" : "string_literal";
                  v.push({
                    operation: "subscript",
                    scope: "child",
                    expression: { value: m, type: f }
                  });
                }
            }), v;
          } else if (Array.isArray(d) && typeof d[0] == "object")
            return d;
          throw new Error("couldn't understand path " + d);
        };
        function p(d) {
          return Object.prototype.toString.call(d) == "[object String]";
        }
        c.Handlers = l, c.Parser = a;
        var h = new c();
        h.JSONPath = c, n.exports = h;
      }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
        var s = r("./grammar"), o = r("../generated/parser"), a = function() {
          var l = new o.Parser(), c = l.parseError;
          return l.yy.parseError = function() {
            l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
          }, l;
        };
        a.grammar = s, n.exports = a;
      }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
        n.exports = function(o, a, l, c) {
          if (typeof a == "string") throw new Error("start cannot be a string");
          if (typeof l == "string") throw new Error("end cannot be a string");
          if (typeof c == "string") throw new Error("step cannot be a string");
          var p = o.length;
          if (c === 0) throw new Error("step cannot be zero");
          if (c = c ? s(c) : 1, a = a < 0 ? p + a : a, l = l < 0 ? p + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : p - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? p : -1)), a = c > 0 ? Math.max(0, a) : Math.min(p, a), l = c > 0 ? Math.min(l, p) : Math.max(-1, l), c > 0 && l <= a) return [];
          if (c < 0 && a <= l) return [];
          for (var h = [], d = a; d != l && !(c < 0 && d <= l || c > 0 && d >= l); d += c)
            h.push(o[d]);
          return h;
        };
        function s(o) {
          return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
        }
      }, {}], 8: [function(r, n, i) {
        var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = v;
        l.AssertionError = function(g) {
          this.name = "AssertionError", this.actual = g.actual, this.expected = g.expected, this.operator = g.operator, g.message ? (this.message = g.message, this.generatedMessage = !1) : (this.message = h(this), this.generatedMessage = !0);
          var w = g.stackStartFunction || d;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, w);
          else {
            var _ = new Error();
            if (_.stack) {
              var S = _.stack, R = w.name, L = S.indexOf(`
` + R);
              if (L >= 0) {
                var F = S.indexOf(`
`, L + 1);
                S = S.substring(F + 1);
              }
              this.stack = S;
            }
          }
        }, s.inherits(l.AssertionError, Error);
        function c(g, w) {
          return s.isUndefined(w) ? "" + w : s.isNumber(w) && !isFinite(w) || s.isFunction(w) || s.isRegExp(w) ? w.toString() : w;
        }
        function p(g, w) {
          return s.isString(g) ? g.length < w ? g : g.slice(0, w) : g;
        }
        function h(g) {
          return p(JSON.stringify(g.actual, c), 128) + " " + g.operator + " " + p(JSON.stringify(g.expected, c), 128);
        }
        function d(g, w, _, S, R) {
          throw new l.AssertionError({
            message: _,
            actual: g,
            expected: w,
            operator: S,
            stackStartFunction: R
          });
        }
        l.fail = d;
        function v(g, w) {
          g || d(g, !0, w, "==", l.ok);
        }
        l.ok = v, l.equal = function(g, w, _) {
          g != w && d(g, w, _, "==", l.equal);
        }, l.notEqual = function(g, w, _) {
          g == w && d(g, w, _, "!=", l.notEqual);
        }, l.deepEqual = function(g, w, _) {
          m(g, w) || d(g, w, _, "deepEqual", l.deepEqual);
        };
        function m(g, w) {
          if (g === w)
            return !0;
          if (s.isBuffer(g) && s.isBuffer(w)) {
            if (g.length != w.length) return !1;
            for (var _ = 0; _ < g.length; _++)
              if (g[_] !== w[_]) return !1;
            return !0;
          } else return s.isDate(g) && s.isDate(w) ? g.getTime() === w.getTime() : s.isRegExp(g) && s.isRegExp(w) ? g.source === w.source && g.global === w.global && g.multiline === w.multiline && g.lastIndex === w.lastIndex && g.ignoreCase === w.ignoreCase : !s.isObject(g) && !s.isObject(w) ? g == w : f(g, w);
        }
        function b(g) {
          return Object.prototype.toString.call(g) == "[object Arguments]";
        }
        function f(g, w) {
          if (s.isNullOrUndefined(g) || s.isNullOrUndefined(w) || g.prototype !== w.prototype) return !1;
          if (s.isPrimitive(g) || s.isPrimitive(w))
            return g === w;
          var _ = b(g), S = b(w);
          if (_ && !S || !_ && S)
            return !1;
          if (_)
            return g = o.call(g), w = o.call(w), m(g, w);
          var R = x(g), L = x(w), F, z;
          if (R.length != L.length)
            return !1;
          for (R.sort(), L.sort(), z = R.length - 1; z >= 0; z--)
            if (R[z] != L[z])
              return !1;
          for (z = R.length - 1; z >= 0; z--)
            if (F = R[z], !m(g[F], w[F])) return !1;
          return !0;
        }
        l.notDeepEqual = function(g, w, _) {
          m(g, w) && d(g, w, _, "notDeepEqual", l.notDeepEqual);
        }, l.strictEqual = function(g, w, _) {
          g !== w && d(g, w, _, "===", l.strictEqual);
        }, l.notStrictEqual = function(g, w, _) {
          g === w && d(g, w, _, "!==", l.notStrictEqual);
        };
        function E(g, w) {
          return !g || !w ? !1 : Object.prototype.toString.call(w) == "[object RegExp]" ? w.test(g) : g instanceof w ? !0 : w.call({}, g) === !0;
        }
        function A(g, w, _, S) {
          var R;
          s.isString(_) && (S = _, _ = null);
          try {
            w();
          } catch (L) {
            R = L;
          }
          if (S = (_ && _.name ? " (" + _.name + ")." : ".") + (S ? " " + S : "."), g && !R && d(R, _, "Missing expected exception" + S), !g && E(R, _) && d(R, _, "Got unwanted exception" + S), g && R && _ && !E(R, _) || !g && R)
            throw R;
        }
        l.throws = function(g, w, _) {
          A.apply(this, [!0].concat(o.call(arguments)));
        }, l.doesNotThrow = function(g, w) {
          A.apply(this, [!1].concat(o.call(arguments)));
        }, l.ifError = function(g) {
          if (g)
            throw g;
        };
        var x = Object.keys || function(g) {
          var w = [];
          for (var _ in g)
            a.call(g, _) && w.push(_);
          return w;
        };
      }, { "util/": 11 }], 9: [function(r, n, i) {
        typeof Object.create == "function" ? n.exports = function(s, o) {
          s.super_ = o, s.prototype = Object.create(o.prototype, {
            constructor: {
              value: s,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : n.exports = function(s, o) {
          s.super_ = o;
          var a = function() {
          };
          a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
        };
      }, {}], 10: [function(r, n, i) {
        n.exports = function(s) {
          return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
        };
      }, {}], 11: [function(r, n, i) {
        (function(s, o) {
          var a = /%[sdj%]/g;
          i.format = function(O) {
            if (!L(O)) {
              for (var N = [], J = 0; J < arguments.length; J++)
                N.push(p(arguments[J]));
              return N.join(" ");
            }
            for (var J = 1, re = arguments, oe = re.length, ee = String(O).replace(a, function(H) {
              if (H === "%%") return "%";
              if (J >= oe) return H;
              switch (H) {
                case "%s":
                  return String(re[J++]);
                case "%d":
                  return Number(re[J++]);
                case "%j":
                  try {
                    return JSON.stringify(re[J++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return H;
              }
            }), ae = re[J]; J < oe; ae = re[++J])
              _(ae) || !W(ae) ? ee += " " + ae : ee += " " + p(ae);
            return ee;
          }, i.deprecate = function(O, N) {
            if (z(o.process))
              return function() {
                return i.deprecate(O, N).apply(this, arguments);
              };
            if (s.noDeprecation === !0)
              return O;
            var J = !1;
            function re() {
              if (!J) {
                if (s.throwDeprecation)
                  throw new Error(N);
                s.traceDeprecation ? console.trace(N) : console.error(N), J = !0;
              }
              return O.apply(this, arguments);
            }
            return re;
          };
          var l = {}, c;
          i.debuglog = function(O) {
            if (z(c) && (c = s.env.NODE_DEBUG || ""), O = O.toUpperCase(), !l[O])
              if (new RegExp("\\b" + O + "\\b", "i").test(c)) {
                var N = s.pid;
                l[O] = function() {
                  var J = i.format.apply(i, arguments);
                  console.error("%s %d: %s", O, N, J);
                };
              } else
                l[O] = function() {
                };
            return l[O];
          };
          function p(O, N) {
            var J = {
              seen: [],
              stylize: d
            };
            return arguments.length >= 3 && (J.depth = arguments[2]), arguments.length >= 4 && (J.colors = arguments[3]), w(N) ? J.showHidden = N : N && i._extend(J, N), z(J.showHidden) && (J.showHidden = !1), z(J.depth) && (J.depth = 2), z(J.colors) && (J.colors = !1), z(J.customInspect) && (J.customInspect = !0), J.colors && (J.stylize = h), m(J, O, J.depth);
          }
          i.inspect = p, p.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, p.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function h(O, N) {
            var J = p.styles[N];
            return J ? "\x1B[" + p.colors[J][0] + "m" + O + "\x1B[" + p.colors[J][1] + "m" : O;
          }
          function d(O, N) {
            return O;
          }
          function v(O) {
            var N = {};
            return O.forEach(function(J, re) {
              N[J] = !0;
            }), N;
          }
          function m(O, N, J) {
            if (O.customInspect && N && ce(N.inspect) && // Filter out the util module, it's inspect function is special
            N.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
            !(N.constructor && N.constructor.prototype === N)) {
              var re = N.inspect(J, O);
              return L(re) || (re = m(O, re, J)), re;
            }
            var oe = b(O, N);
            if (oe)
              return oe;
            var ee = Object.keys(N), ae = v(ee);
            if (O.showHidden && (ee = Object.getOwnPropertyNames(N)), le(N) && (ee.indexOf("message") >= 0 || ee.indexOf("description") >= 0))
              return f(N);
            if (ee.length === 0) {
              if (ce(N)) {
                var me = N.name ? ": " + N.name : "";
                return O.stylize("[Function" + me + "]", "special");
              }
              if (j(N))
                return O.stylize(RegExp.prototype.toString.call(N), "regexp");
              if (te(N))
                return O.stylize(Date.prototype.toString.call(N), "date");
              if (le(N))
                return f(N);
            }
            var H = "", X = !1, Ae = ["{", "}"];
            if (g(N) && (X = !0, Ae = ["[", "]"]), ce(N)) {
              var Re = N.name ? ": " + N.name : "";
              H = " [Function" + Re + "]";
            }
            if (j(N) && (H = " " + RegExp.prototype.toString.call(N)), te(N) && (H = " " + Date.prototype.toUTCString.call(N)), le(N) && (H = " " + f(N)), ee.length === 0 && (!X || N.length == 0))
              return Ae[0] + H + Ae[1];
            if (J < 0)
              return j(N) ? O.stylize(RegExp.prototype.toString.call(N), "regexp") : O.stylize("[Object]", "special");
            O.seen.push(N);
            var Fe;
            return X ? Fe = E(O, N, J, ae, ee) : Fe = ee.map(function(Te) {
              return A(O, N, J, ae, Te, X);
            }), O.seen.pop(), x(Fe, H, Ae);
          }
          function b(O, N) {
            if (z(N))
              return O.stylize("undefined", "undefined");
            if (L(N)) {
              var J = "'" + JSON.stringify(N).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return O.stylize(J, "string");
            }
            if (R(N))
              return O.stylize("" + N, "number");
            if (w(N))
              return O.stylize("" + N, "boolean");
            if (_(N))
              return O.stylize("null", "null");
          }
          function f(O) {
            return "[" + Error.prototype.toString.call(O) + "]";
          }
          function E(O, N, J, re, oe) {
            for (var ee = [], ae = 0, me = N.length; ae < me; ++ae)
              ue(N, String(ae)) ? ee.push(A(
                O,
                N,
                J,
                re,
                String(ae),
                !0
              )) : ee.push("");
            return oe.forEach(function(H) {
              H.match(/^\d+$/) || ee.push(A(
                O,
                N,
                J,
                re,
                H,
                !0
              ));
            }), ee;
          }
          function A(O, N, J, re, oe, ee) {
            var ae, me, H;
            if (H = Object.getOwnPropertyDescriptor(N, oe) || { value: N[oe] }, H.get ? H.set ? me = O.stylize("[Getter/Setter]", "special") : me = O.stylize("[Getter]", "special") : H.set && (me = O.stylize("[Setter]", "special")), ue(re, oe) || (ae = "[" + oe + "]"), me || (O.seen.indexOf(H.value) < 0 ? (_(J) ? me = m(O, H.value, null) : me = m(O, H.value, J - 1), me.indexOf(`
`) > -1 && (ee ? me = me.split(`
`).map(function(X) {
              return "  " + X;
            }).join(`
`).substr(2) : me = `
` + me.split(`
`).map(function(X) {
              return "   " + X;
            }).join(`
`))) : me = O.stylize("[Circular]", "special")), z(ae)) {
              if (ee && oe.match(/^\d+$/))
                return me;
              ae = JSON.stringify("" + oe), ae.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ae = ae.substr(1, ae.length - 2), ae = O.stylize(ae, "name")) : (ae = ae.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ae = O.stylize(ae, "string"));
            }
            return ae + ": " + me;
          }
          function x(O, N, J) {
            var re = O.reduce(function(oe, ee) {
              return ee.indexOf(`
`) >= 0, oe + ee.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return re > 60 ? J[0] + (N === "" ? "" : N + `
 `) + " " + O.join(`,
  `) + " " + J[1] : J[0] + N + " " + O.join(", ") + " " + J[1];
          }
          function g(O) {
            return Array.isArray(O);
          }
          i.isArray = g;
          function w(O) {
            return typeof O == "boolean";
          }
          i.isBoolean = w;
          function _(O) {
            return O === null;
          }
          i.isNull = _;
          function S(O) {
            return O == null;
          }
          i.isNullOrUndefined = S;
          function R(O) {
            return typeof O == "number";
          }
          i.isNumber = R;
          function L(O) {
            return typeof O == "string";
          }
          i.isString = L;
          function F(O) {
            return typeof O == "symbol";
          }
          i.isSymbol = F;
          function z(O) {
            return O === void 0;
          }
          i.isUndefined = z;
          function j(O) {
            return W(O) && xe(O) === "[object RegExp]";
          }
          i.isRegExp = j;
          function W(O) {
            return typeof O == "object" && O !== null;
          }
          i.isObject = W;
          function te(O) {
            return W(O) && xe(O) === "[object Date]";
          }
          i.isDate = te;
          function le(O) {
            return W(O) && (xe(O) === "[object Error]" || O instanceof Error);
          }
          i.isError = le;
          function ce(O) {
            return typeof O == "function";
          }
          i.isFunction = ce;
          function Ee(O) {
            return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || // ES6 symbol
            typeof O > "u";
          }
          i.isPrimitive = Ee, i.isBuffer = r("./support/isBuffer");
          function xe(O) {
            return Object.prototype.toString.call(O);
          }
          function _e(O) {
            return O < 10 ? "0" + O.toString(10) : O.toString(10);
          }
          var Ie = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function je() {
            var O = /* @__PURE__ */ new Date(), N = [
              _e(O.getHours()),
              _e(O.getMinutes()),
              _e(O.getSeconds())
            ].join(":");
            return [O.getDate(), Ie[O.getMonth()], N].join(" ");
          }
          i.log = function() {
            console.log("%s - %s", je(), i.format.apply(i, arguments));
          }, i.inherits = r("inherits"), i._extend = function(O, N) {
            if (!N || !W(N)) return O;
            for (var J = Object.keys(N), re = J.length; re--; )
              O[J[re]] = N[J[re]];
            return O;
          };
          function ue(O, N) {
            return Object.prototype.hasOwnProperty.call(O, N);
          }
        }).call(this, r("_process"), typeof u_ < "u" ? u_ : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
      }, {}], 13: [function(r, n, i) {
        (function(s) {
          function o(p, h) {
            for (var d = 0, v = p.length - 1; v >= 0; v--) {
              var m = p[v];
              m === "." ? p.splice(v, 1) : m === ".." ? (p.splice(v, 1), d++) : d && (p.splice(v, 1), d--);
            }
            if (h)
              for (; d--; d)
                p.unshift("..");
            return p;
          }
          i.resolve = function() {
            for (var p = "", h = !1, d = arguments.length - 1; d >= -1 && !h; d--) {
              var v = d >= 0 ? arguments[d] : s.cwd();
              if (typeof v != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              v && (p = v + "/" + p, h = v.charAt(0) === "/");
            }
            return p = o(l(p.split("/"), function(m) {
              return !!m;
            }), !h).join("/"), (h ? "/" : "") + p || ".";
          }, i.normalize = function(p) {
            var h = i.isAbsolute(p), d = c(p, -1) === "/";
            return p = o(l(p.split("/"), function(v) {
              return !!v;
            }), !h).join("/"), !p && !h && (p = "."), p && d && (p += "/"), (h ? "/" : "") + p;
          }, i.isAbsolute = function(p) {
            return p.charAt(0) === "/";
          }, i.join = function() {
            var p = Array.prototype.slice.call(arguments, 0);
            return i.normalize(l(p, function(h, d) {
              if (typeof h != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return h;
            }).join("/"));
          }, i.relative = function(p, h) {
            p = i.resolve(p).substr(1), h = i.resolve(h).substr(1);
            function d(x) {
              for (var g = 0; g < x.length && x[g] === ""; g++)
                ;
              for (var w = x.length - 1; w >= 0 && x[w] === ""; w--)
                ;
              return g > w ? [] : x.slice(g, w - g + 1);
            }
            for (var v = d(p.split("/")), m = d(h.split("/")), b = Math.min(v.length, m.length), f = b, E = 0; E < b; E++)
              if (v[E] !== m[E]) {
                f = E;
                break;
              }
            for (var A = [], E = f; E < v.length; E++)
              A.push("..");
            return A = A.concat(m.slice(f)), A.join("/");
          }, i.sep = "/", i.delimiter = ":", i.dirname = function(p) {
            if (typeof p != "string" && (p = p + ""), p.length === 0) return ".";
            for (var h = p.charCodeAt(0), d = h === 47, v = -1, m = !0, b = p.length - 1; b >= 1; --b)
              if (h = p.charCodeAt(b), h === 47) {
                if (!m) {
                  v = b;
                  break;
                }
              } else
                m = !1;
            return v === -1 ? d ? "/" : "." : d && v === 1 ? "/" : p.slice(0, v);
          };
          function a(p) {
            typeof p != "string" && (p = p + "");
            var h = 0, d = -1, v = !0, m;
            for (m = p.length - 1; m >= 0; --m)
              if (p.charCodeAt(m) === 47) {
                if (!v) {
                  h = m + 1;
                  break;
                }
              } else d === -1 && (v = !1, d = m + 1);
            return d === -1 ? "" : p.slice(h, d);
          }
          i.basename = function(p, h) {
            var d = a(p);
            return h && d.substr(-1 * h.length) === h && (d = d.substr(0, d.length - h.length)), d;
          }, i.extname = function(p) {
            typeof p != "string" && (p = p + "");
            for (var h = -1, d = 0, v = -1, m = !0, b = 0, f = p.length - 1; f >= 0; --f) {
              var E = p.charCodeAt(f);
              if (E === 47) {
                if (!m) {
                  d = f + 1;
                  break;
                }
                continue;
              }
              v === -1 && (m = !1, v = f + 1), E === 46 ? h === -1 ? h = f : b !== 1 && (b = 1) : h !== -1 && (b = -1);
            }
            return h === -1 || v === -1 || // We saw a non-dot character immediately before the dot
            b === 0 || // The (right-most) trimmed path component is exactly '..'
            b === 1 && h === v - 1 && h === d + 1 ? "" : p.slice(h, v);
          };
          function l(p, h) {
            if (p.filter) return p.filter(h);
            for (var d = [], v = 0; v < p.length; v++)
              h(p[v], v, p) && d.push(p[v]);
            return d;
          }
          var c = "ab".substr(-1) === "b" ? function(p, h, d) {
            return p.substr(h, d);
          } : function(p, h, d) {
            return h < 0 && (h = p.length + h), p.substr(h, d);
          };
        }).call(this, r("_process"));
      }, { _process: 14 }], 14: [function(r, n, i) {
        var s = n.exports = {}, o, a;
        function l() {
          throw new Error("setTimeout has not been defined");
        }
        function c() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? o = setTimeout : o = l;
          } catch {
            o = l;
          }
          try {
            typeof clearTimeout == "function" ? a = clearTimeout : a = c;
          } catch {
            a = c;
          }
        })();
        function p(g) {
          if (o === setTimeout)
            return setTimeout(g, 0);
          if ((o === l || !o) && setTimeout)
            return o = setTimeout, setTimeout(g, 0);
          try {
            return o(g, 0);
          } catch {
            try {
              return o.call(null, g, 0);
            } catch {
              return o.call(this, g, 0);
            }
          }
        }
        function h(g) {
          if (a === clearTimeout)
            return clearTimeout(g);
          if ((a === c || !a) && clearTimeout)
            return a = clearTimeout, clearTimeout(g);
          try {
            return a(g);
          } catch {
            try {
              return a.call(null, g);
            } catch {
              return a.call(this, g);
            }
          }
        }
        var d = [], v = !1, m, b = -1;
        function f() {
          !v || !m || (v = !1, m.length ? d = m.concat(d) : b = -1, d.length && E());
        }
        function E() {
          if (!v) {
            var g = p(f);
            v = !0;
            for (var w = d.length; w; ) {
              for (m = d, d = []; ++b < w; )
                m && m[b].run();
              b = -1, w = d.length;
            }
            m = null, v = !1, h(g);
          }
        }
        s.nextTick = function(g) {
          var w = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var _ = 1; _ < arguments.length; _++)
              w[_ - 1] = arguments[_];
          d.push(new A(g, w)), d.length === 1 && !v && p(E);
        };
        function A(g, w) {
          this.fun = g, this.array = w;
        }
        A.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
        function x() {
        }
        s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(g) {
          return [];
        }, s.binding = function(g) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(g) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, {}], 15: [function(r, n, i) {
        var s = r("escodegen").generate;
        n.exports = function(o, a) {
          a || (a = {});
          var l = {}, c = function p(h, d) {
            if (h.type === "Literal")
              return h.value;
            if (h.type === "UnaryExpression") {
              var v = p(h.argument);
              return h.operator === "+" ? +v : h.operator === "-" ? -v : h.operator === "~" ? ~v : h.operator === "!" ? !v : l;
            } else if (h.type === "ArrayExpression") {
              for (var m = [], b = 0, f = h.elements.length; b < f; b++) {
                var E = p(h.elements[b]);
                if (E === l) return l;
                m.push(E);
              }
              return m;
            } else if (h.type === "ObjectExpression") {
              for (var A = {}, b = 0; b < h.properties.length; b++) {
                var x = h.properties[b], g = x.value === null ? x.value : p(x.value);
                if (g === l) return l;
                A[x.key.value || x.key.name] = g;
              }
              return A;
            } else if (h.type === "BinaryExpression" || h.type === "LogicalExpression") {
              var f = p(h.left);
              if (f === l) return l;
              var w = p(h.right);
              if (w === l) return l;
              var _ = h.operator;
              return _ === "==" ? f == w : _ === "===" ? f === w : _ === "!=" ? f != w : _ === "!==" ? f !== w : _ === "+" ? f + w : _ === "-" ? f - w : _ === "*" ? f * w : _ === "/" ? f / w : _ === "%" ? f % w : _ === "<" ? f < w : _ === "<=" ? f <= w : _ === ">" ? f > w : _ === ">=" ? f >= w : _ === "|" ? f | w : _ === "&" ? f & w : _ === "^" ? f ^ w : _ === "&&" ? f && w : _ === "||" ? f || w : l;
            } else {
              if (h.type === "Identifier")
                return {}.hasOwnProperty.call(a, h.name) ? a[h.name] : l;
              if (h.type === "ThisExpression")
                return {}.hasOwnProperty.call(a, "this") ? a.this : l;
              if (h.type === "CallExpression") {
                var S = p(h.callee);
                if (S === l || typeof S != "function") return l;
                var R = h.callee.object ? p(h.callee.object) : l;
                R === l && (R = null);
                for (var L = [], b = 0, f = h.arguments.length; b < f; b++) {
                  var E = p(h.arguments[b]);
                  if (E === l) return l;
                  L.push(E);
                }
                return S.apply(R, L);
              } else if (h.type === "MemberExpression") {
                var A = p(h.object);
                if (A === l || typeof A == "function")
                  return l;
                if (h.property.type === "Identifier")
                  return A[h.property.name];
                var x = p(h.property);
                return x === l ? l : A[x];
              } else if (h.type === "ConditionalExpression") {
                var v = p(h.test);
                return v === l ? l : p(v ? h.consequent : h.alternate);
              } else if (h.type === "ExpressionStatement") {
                var v = p(h.expression);
                return v === l ? l : v;
              } else {
                if (h.type === "ReturnStatement")
                  return p(h.argument);
                if (h.type === "FunctionExpression") {
                  var F = h.body.body, z = {};
                  Object.keys(a).forEach(function(Ie) {
                    z[Ie] = a[Ie];
                  });
                  for (var b = 0; b < h.params.length; b++) {
                    var j = h.params[b];
                    if (j.type == "Identifier")
                      a[j.name] = null;
                    else return l;
                  }
                  for (var b in F)
                    if (p(F[b]) === l)
                      return l;
                  a = z;
                  var W = Object.keys(a), te = W.map(function(Ie) {
                    return a[Ie];
                  });
                  return Function(W.join(", "), "return " + s(h)).apply(null, te);
                } else if (h.type === "TemplateLiteral") {
                  for (var le = "", b = 0; b < h.expressions.length; b++)
                    le += p(h.quasis[b]), le += p(h.expressions[b]);
                  return le += p(h.quasis[b]), le;
                } else if (h.type === "TaggedTemplateExpression") {
                  var ce = p(h.tag), Ee = h.quasi, xe = Ee.quasis.map(p), _e = Ee.expressions.map(p);
                  return ce.apply(null, [xe].concat(_e));
                } else return h.type === "TemplateElement" ? h.value.cooked : l;
              }
            }
          }(o);
          return c === l ? void 0 : c;
        };
      }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
        n.exports = r("./lib/index");
      }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
    });
  }(S_)), S_.exports;
}
X1e();
const eye = "https://fizz.studio/schema/manifest.schema.json", tye = {
  $id: eye
};
tye.$id;
function rye(t) {
  const e = t.datasets[0];
  if (e.data.source !== "inline")
    throw new Error("only manifests with inline data can use this function.");
  const r = {};
  for (const n of e.series)
    r[n.key] = n.records;
  return r;
}
function G$(t) {
  return new Set(...t.map((e) => e.x));
}
function nye(t, e) {
  return t.size === e.size && t.isSubsetOf(e);
}
function iye(t) {
  let e = null;
  for (const r in t) {
    const n = t[r], i = G$(n);
    if (i.size !== n.length)
      return !1;
    if (e === null)
      e = i;
    else if (!nye(i, e))
      return !1;
  }
  return !0;
}
function Au(t) {
  return t.toLowerCase().replace(/\s+/g, "_").replace(/[^\w-]+/g, "_");
}
const k_ = {
  line: "line",
  stepline: "line",
  bar: "bar",
  column: "bar",
  lollipop: "bar",
  histogram: "histogram",
  scatter: "scatter",
  heatmap: "scatter",
  pie: "pastry",
  donut: "pastry",
  graph: "graph"
};
(() => {
  const t = {
    line: [],
    bar: [],
    pastry: [],
    scatter: [],
    histogram: [],
    graph: []
  };
  for (let e of Object.keys(k_))
    t[k_[e]].push(e);
  return t;
})();
const sye = {
  bar: "column",
  column: "column",
  lollipop: "column",
  histogram: "column",
  line: "line",
  stepline: "line",
  graph: "line",
  scatter: "other",
  heatmap: "other",
  pie: "other",
  donut: "other"
};
let Nw = class extends Error {
  constructor(e) {
    super(`[jimifier]: ${e}`);
  }
}, oye = class {
  constructor(e, r) {
    if (this._manifest = e, this._dataset = this._manifest.datasets[0], this._dataset.data.source === "inline")
      this._data = rye(this._manifest);
    else if (r)
      this._data = r;
    else
      throw new Nw("JIM cannot be created without external or inline chart data");
    this._seriesKeys = Object.keys(this._data);
  }
  get jim() {
    return this._jim;
  }
  _addSelectorsOrdered(e) {
    let r = 1;
    const n = G$(this._data[this._seriesKeys[0]]);
    this._seriesKeys.forEach((i, s) => {
      n.forEach((o, a) => {
        e[`datapoint${r}`] = {
          dom: `#datapoint-${Au(o)}_${Au(i)}`,
          json: [
            `$.datasets[0].series[${s}].name`,
            `$.datasets[0].series[${s}].records[${a}].*`
          ]
        }, r++;
      });
    });
  }
  _addSelectorsUnordered(e) {
    let r = 1;
    Object.keys(this._data).forEach((n, i) => {
      this._data[n].forEach((s, o) => {
        const a = Au(s.x), l = Au(s.y);
        e[`datapoint${r}`] = {
          dom: `#datapoint-${a}_${l}_${Au(n)}`,
          json: [
            `$.datasets[0].series[${i}].name`,
            `$.datasets[0].series[${i}].records[${o}].*`
          ]
        }, r++;
      });
    });
  }
  _renderSelectors() {
    const e = {
      chartTitle: {
        dom: "#chart-title",
        json: "$.datasets[0].title"
      }
    };
    return iye(this._data) ? this._addSelectorsOrdered(e) : this._addSelectorsUnordered(e), e;
  }
  render() {
    const e = {
      title: this._dataset.title,
      facets: this._dataset.facets,
      series: []
    };
    e.series = this._dataset.series.map((i) => ({
      name: i.key,
      type: sye[this._dataset.type],
      records: this._data[i.key]
    }));
    const r = this._renderSelectors(), n = this._renderBehaviors();
    this._jim = {
      datasets: [e],
      selectors: r,
      behaviors: n,
      version: { jim: "0.4.0" }
    };
  }
  addSeriesSummary(e, r) {
    if (!this._jim)
      throw new Nw("JIM must be rendered before adding series summary");
    const n = this._seriesKeys.indexOf(e);
    if (n === -1)
      throw new Nw(`Series key "${e}" not found`);
    this._jim.datasets[0].series[n].description = r;
    const i = `seriesSummary_${Au(e)}`;
    this._jim.selectors[i] = {
      dom: `#series-${Au(e)}`,
      json: `$.datasets[0].series[${n}].description`
    };
  }
  _renderBehaviors() {
    const e = [];
    return this._seriesKeys.forEach((r, n) => {
      e.push({
        target: {
          selector: `$.selectors.seriesSummary_${r}`
        },
        enter: {
          haptic: {
            durations: [0, 125, 125, 125, 125, 125, 125, 125],
            repeatInterval: 125
          },
          audio: {
            earcon: "PewPew",
            repeat: "none"
          }
        },
        details: {
          announcement: {
            path: `$.datasets[0].series[${n}].description`
          }
        }
      });
    }), e;
  }
};
var Xl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Um = {}, W$ = {}, Tv = {};
Tv.byteLength = cye;
Tv.toByteArray = hye;
Tv.fromByteArray = fye;
var Po = [], ns = [], aye = typeof Uint8Array < "u" ? Uint8Array : Array, Dw = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ip = 0, lye = Dw.length; ip < lye; ++ip)
  Po[ip] = Dw[ip], ns[Dw.charCodeAt(ip)] = ip;
ns[45] = 62;
ns[95] = 63;
function q$(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = t.indexOf("=");
  r === -1 && (r = e);
  var n = r === e ? 0 : 4 - r % 4;
  return [r, n];
}
function cye(t) {
  var e = q$(t), r = e[0], n = e[1];
  return (r + n) * 3 / 4 - n;
}
function uye(t, e, r) {
  return (e + r) * 3 / 4 - r;
}
function hye(t) {
  var e, r = q$(t), n = r[0], i = r[1], s = new aye(uye(t, n, i)), o = 0, a = i > 0 ? n - 4 : n, l;
  for (l = 0; l < a; l += 4)
    e = ns[t.charCodeAt(l)] << 18 | ns[t.charCodeAt(l + 1)] << 12 | ns[t.charCodeAt(l + 2)] << 6 | ns[t.charCodeAt(l + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
  return i === 2 && (e = ns[t.charCodeAt(l)] << 2 | ns[t.charCodeAt(l + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = ns[t.charCodeAt(l)] << 10 | ns[t.charCodeAt(l + 1)] << 4 | ns[t.charCodeAt(l + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
}
function pye(t) {
  return Po[t >> 18 & 63] + Po[t >> 12 & 63] + Po[t >> 6 & 63] + Po[t & 63];
}
function dye(t, e, r) {
  for (var n, i = [], s = e; s < r; s += 3)
    n = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (t[s + 2] & 255), i.push(pye(n));
  return i.join("");
}
function fye(t) {
  for (var e, r = t.length, n = r % 3, i = [], s = 16383, o = 0, a = r - n; o < a; o += s)
    i.push(dye(t, o, o + s > a ? a : o + s));
  return n === 1 ? (e = t[r - 1], i.push(
    Po[e >> 2] + Po[e << 4 & 63] + "=="
  )) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i.push(
    Po[e >> 10] + Po[e >> 4 & 63] + Po[e << 2 & 63] + "="
  )), i.join("");
}
var dS = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
dS.read = function(t, e, r, n, i) {
  var s, o, a = i * 8 - n - 1, l = (1 << a) - 1, c = l >> 1, p = -7, h = r ? i - 1 : 0, d = r ? -1 : 1, v = t[e + h];
  for (h += d, s = v & (1 << -p) - 1, v >>= -p, p += a; p > 0; s = s * 256 + t[e + h], h += d, p -= 8)
    ;
  for (o = s & (1 << -p) - 1, s >>= -p, p += n; p > 0; o = o * 256 + t[e + h], h += d, p -= 8)
    ;
  if (s === 0)
    s = 1 - c;
  else {
    if (s === l)
      return o ? NaN : (v ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, n), s = s - c;
  }
  return (v ? -1 : 1) * o * Math.pow(2, s - n);
};
dS.write = function(t, e, r, n, i, s) {
  var o, a, l, c = s * 8 - i - 1, p = (1 << c) - 1, h = p >> 1, d = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = n ? 0 : s - 1, m = n ? 1 : -1, b = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = p) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + h >= 1 ? e += d / l : e += d * Math.pow(2, 1 - h), e * l >= 2 && (o++, l /= 2), o + h >= p ? (a = 0, o = p) : o + h >= 1 ? (a = (e * l - 1) * Math.pow(2, i), o = o + h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i), o = 0)); i >= 8; t[r + v] = a & 255, v += m, a /= 256, i -= 8)
    ;
  for (o = o << i | a, c += i; c > 0; t[r + v] = o & 255, v += m, o /= 256, c -= 8)
    ;
  t[r + v - m] |= b * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  const e = Tv, r = dS, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = p, t.SlowBuffer = w, t.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  t.kMaxLength = i;
  const { Uint8Array: s, ArrayBuffer: o, SharedArrayBuffer: a } = globalThis;
  p.TYPED_ARRAY_SUPPORT = l(), !p.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function l() {
    try {
      const C = new s(1), $ = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf($, s.prototype), Object.setPrototypeOf(C, $), C.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(p.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (p.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(p.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (p.isBuffer(this))
        return this.byteOffset;
    }
  });
  function c(C) {
    if (C > i)
      throw new RangeError('The value "' + C + '" is invalid for option "size"');
    const $ = new s(C);
    return Object.setPrototypeOf($, p.prototype), $;
  }
  function p(C, $, D) {
    if (typeof C == "number") {
      if (typeof $ == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return m(C);
    }
    return h(C, $, D);
  }
  p.poolSize = 8192;
  function h(C, $, D) {
    if (typeof C == "string")
      return b(C, $);
    if (o.isView(C))
      return E(C);
    if (C == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C
      );
    if (kt(C, o) || C && kt(C.buffer, o) || typeof a < "u" && (kt(C, a) || C && kt(C.buffer, a)))
      return A(C, $, D);
    if (typeof C == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const se = C.valueOf && C.valueOf();
    if (se != null && se !== C)
      return p.from(se, $, D);
    const pe = x(C);
    if (pe) return pe;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof C[Symbol.toPrimitive] == "function")
      return p.from(C[Symbol.toPrimitive]("string"), $, D);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C
    );
  }
  p.from = function(C, $, D) {
    return h(C, $, D);
  }, Object.setPrototypeOf(p.prototype, s.prototype), Object.setPrototypeOf(p, s);
  function d(C) {
    if (typeof C != "number")
      throw new TypeError('"size" argument must be of type number');
    if (C < 0)
      throw new RangeError('The value "' + C + '" is invalid for option "size"');
  }
  function v(C, $, D) {
    return d(C), C <= 0 ? c(C) : $ !== void 0 ? typeof D == "string" ? c(C).fill($, D) : c(C).fill($) : c(C);
  }
  p.alloc = function(C, $, D) {
    return v(C, $, D);
  };
  function m(C) {
    return d(C), c(C < 0 ? 0 : g(C) | 0);
  }
  p.allocUnsafe = function(C) {
    return m(C);
  }, p.allocUnsafeSlow = function(C) {
    return m(C);
  };
  function b(C, $) {
    if ((typeof $ != "string" || $ === "") && ($ = "utf8"), !p.isEncoding($))
      throw new TypeError("Unknown encoding: " + $);
    const D = _(C, $) | 0;
    let se = c(D);
    const pe = se.write(C, $);
    return pe !== D && (se = se.slice(0, pe)), se;
  }
  function f(C) {
    const $ = C.length < 0 ? 0 : g(C.length) | 0, D = c($);
    for (let se = 0; se < $; se += 1)
      D[se] = C[se] & 255;
    return D;
  }
  function E(C) {
    if (kt(C, s)) {
      const $ = new s(C);
      return A($.buffer, $.byteOffset, $.byteLength);
    }
    return f(C);
  }
  function A(C, $, D) {
    if ($ < 0 || C.byteLength < $)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (C.byteLength < $ + (D || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let se;
    return $ === void 0 && D === void 0 ? se = new s(C) : D === void 0 ? se = new s(C, $) : se = new s(C, $, D), Object.setPrototypeOf(se, p.prototype), se;
  }
  function x(C) {
    if (p.isBuffer(C)) {
      const $ = g(C.length) | 0, D = c($);
      return D.length === 0 || C.copy(D, 0, 0, $), D;
    }
    if (C.length !== void 0)
      return typeof C.length != "number" || Ze(C.length) ? c(0) : f(C);
    if (C.type === "Buffer" && Array.isArray(C.data))
      return f(C.data);
  }
  function g(C) {
    if (C >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return C | 0;
  }
  function w(C) {
    return +C != C && (C = 0), p.alloc(+C);
  }
  p.isBuffer = function(C) {
    return C != null && C._isBuffer === !0 && C !== p.prototype;
  }, p.compare = function(C, $) {
    if (kt(C, s) && (C = p.from(C, C.offset, C.byteLength)), kt($, s) && ($ = p.from($, $.offset, $.byteLength)), !p.isBuffer(C) || !p.isBuffer($))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (C === $) return 0;
    let D = C.length, se = $.length;
    for (let pe = 0, Se = Math.min(D, se); pe < Se; ++pe)
      if (C[pe] !== $[pe]) {
        D = C[pe], se = $[pe];
        break;
      }
    return D < se ? -1 : se < D ? 1 : 0;
  }, p.isEncoding = function(C) {
    switch (String(C).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, p.concat = function(C, $) {
    if (!Array.isArray(C))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (C.length === 0)
      return p.alloc(0);
    let D;
    if ($ === void 0)
      for ($ = 0, D = 0; D < C.length; ++D)
        $ += C[D].length;
    const se = p.allocUnsafe($);
    let pe = 0;
    for (D = 0; D < C.length; ++D) {
      let Se = C[D];
      if (kt(Se, s))
        pe + Se.length > se.length ? (p.isBuffer(Se) || (Se = p.from(Se)), Se.copy(se, pe)) : s.prototype.set.call(
          se,
          Se,
          pe
        );
      else if (p.isBuffer(Se))
        Se.copy(se, pe);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      pe += Se.length;
    }
    return se;
  };
  function _(C, $) {
    if (p.isBuffer(C))
      return C.length;
    if (o.isView(C) || kt(C, o))
      return C.byteLength;
    if (typeof C != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof C
      );
    const D = C.length, se = arguments.length > 2 && arguments[2] === !0;
    if (!se && D === 0) return 0;
    let pe = !1;
    for (; ; )
      switch ($) {
        case "ascii":
        case "latin1":
        case "binary":
          return D;
        case "utf8":
        case "utf-8":
          return At(C).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return D * 2;
        case "hex":
          return D >>> 1;
        case "base64":
          return ht(C).length;
        default:
          if (pe)
            return se ? -1 : At(C).length;
          $ = ("" + $).toLowerCase(), pe = !0;
      }
  }
  p.byteLength = _;
  function S(C, $, D) {
    let se = !1;
    if (($ === void 0 || $ < 0) && ($ = 0), $ > this.length || ((D === void 0 || D > this.length) && (D = this.length), D <= 0) || (D >>>= 0, $ >>>= 0, D <= $))
      return "";
    for (C || (C = "utf8"); ; )
      switch (C) {
        case "hex":
          return ue(this, $, D);
        case "utf8":
        case "utf-8":
          return Ee(this, $, D);
        case "ascii":
          return Ie(this, $, D);
        case "latin1":
        case "binary":
          return je(this, $, D);
        case "base64":
          return ce(this, $, D);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return O(this, $, D);
        default:
          if (se) throw new TypeError("Unknown encoding: " + C);
          C = (C + "").toLowerCase(), se = !0;
      }
  }
  p.prototype._isBuffer = !0;
  function R(C, $, D) {
    const se = C[$];
    C[$] = C[D], C[D] = se;
  }
  p.prototype.swap16 = function() {
    const C = this.length;
    if (C % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let $ = 0; $ < C; $ += 2)
      R(this, $, $ + 1);
    return this;
  }, p.prototype.swap32 = function() {
    const C = this.length;
    if (C % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let $ = 0; $ < C; $ += 4)
      R(this, $, $ + 3), R(this, $ + 1, $ + 2);
    return this;
  }, p.prototype.swap64 = function() {
    const C = this.length;
    if (C % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let $ = 0; $ < C; $ += 8)
      R(this, $, $ + 7), R(this, $ + 1, $ + 6), R(this, $ + 2, $ + 5), R(this, $ + 3, $ + 4);
    return this;
  }, p.prototype.toString = function() {
    const C = this.length;
    return C === 0 ? "" : arguments.length === 0 ? Ee(this, 0, C) : S.apply(this, arguments);
  }, p.prototype.toLocaleString = p.prototype.toString, p.prototype.equals = function(C) {
    if (!p.isBuffer(C)) throw new TypeError("Argument must be a Buffer");
    return this === C ? !0 : p.compare(this, C) === 0;
  }, p.prototype.inspect = function() {
    let C = "";
    const $ = t.INSPECT_MAX_BYTES;
    return C = this.toString("hex", 0, $).replace(/(.{2})/g, "$1 ").trim(), this.length > $ && (C += " ... "), "<Buffer " + C + ">";
  }, n && (p.prototype[n] = p.prototype.inspect), p.prototype.compare = function(C, $, D, se, pe) {
    if (kt(C, s) && (C = p.from(C, C.offset, C.byteLength)), !p.isBuffer(C))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof C
      );
    if ($ === void 0 && ($ = 0), D === void 0 && (D = C ? C.length : 0), se === void 0 && (se = 0), pe === void 0 && (pe = this.length), $ < 0 || D > C.length || se < 0 || pe > this.length)
      throw new RangeError("out of range index");
    if (se >= pe && $ >= D)
      return 0;
    if (se >= pe)
      return -1;
    if ($ >= D)
      return 1;
    if ($ >>>= 0, D >>>= 0, se >>>= 0, pe >>>= 0, this === C) return 0;
    let Se = pe - se, Le = D - $;
    const ot = Math.min(Se, Le), dt = this.slice(se, pe), St = C.slice($, D);
    for (let rt = 0; rt < ot; ++rt)
      if (dt[rt] !== St[rt]) {
        Se = dt[rt], Le = St[rt];
        break;
      }
    return Se < Le ? -1 : Le < Se ? 1 : 0;
  };
  function L(C, $, D, se, pe) {
    if (C.length === 0) return -1;
    if (typeof D == "string" ? (se = D, D = 0) : D > 2147483647 ? D = 2147483647 : D < -2147483648 && (D = -2147483648), D = +D, Ze(D) && (D = pe ? 0 : C.length - 1), D < 0 && (D = C.length + D), D >= C.length) {
      if (pe) return -1;
      D = C.length - 1;
    } else if (D < 0)
      if (pe) D = 0;
      else return -1;
    if (typeof $ == "string" && ($ = p.from($, se)), p.isBuffer($))
      return $.length === 0 ? -1 : F(C, $, D, se, pe);
    if (typeof $ == "number")
      return $ = $ & 255, typeof s.prototype.indexOf == "function" ? pe ? s.prototype.indexOf.call(C, $, D) : s.prototype.lastIndexOf.call(C, $, D) : F(C, [$], D, se, pe);
    throw new TypeError("val must be string, number or Buffer");
  }
  function F(C, $, D, se, pe) {
    let Se = 1, Le = C.length, ot = $.length;
    if (se !== void 0 && (se = String(se).toLowerCase(), se === "ucs2" || se === "ucs-2" || se === "utf16le" || se === "utf-16le")) {
      if (C.length < 2 || $.length < 2)
        return -1;
      Se = 2, Le /= 2, ot /= 2, D /= 2;
    }
    function dt(rt, zt) {
      return Se === 1 ? rt[zt] : rt.readUInt16BE(zt * Se);
    }
    let St;
    if (pe) {
      let rt = -1;
      for (St = D; St < Le; St++)
        if (dt(C, St) === dt($, rt === -1 ? 0 : St - rt)) {
          if (rt === -1 && (rt = St), St - rt + 1 === ot) return rt * Se;
        } else
          rt !== -1 && (St -= St - rt), rt = -1;
    } else
      for (D + ot > Le && (D = Le - ot), St = D; St >= 0; St--) {
        let rt = !0;
        for (let zt = 0; zt < ot; zt++)
          if (dt(C, St + zt) !== dt($, zt)) {
            rt = !1;
            break;
          }
        if (rt) return St;
      }
    return -1;
  }
  p.prototype.includes = function(C, $, D) {
    return this.indexOf(C, $, D) !== -1;
  }, p.prototype.indexOf = function(C, $, D) {
    return L(this, C, $, D, !0);
  }, p.prototype.lastIndexOf = function(C, $, D) {
    return L(this, C, $, D, !1);
  };
  function z(C, $, D, se) {
    D = Number(D) || 0;
    const pe = C.length - D;
    se ? (se = Number(se), se > pe && (se = pe)) : se = pe;
    const Se = $.length;
    se > Se / 2 && (se = Se / 2);
    let Le;
    for (Le = 0; Le < se; ++Le) {
      const ot = parseInt($.substr(Le * 2, 2), 16);
      if (Ze(ot)) return Le;
      C[D + Le] = ot;
    }
    return Le;
  }
  function j(C, $, D, se) {
    return it(At($, C.length - D), C, D, se);
  }
  function W(C, $, D, se) {
    return it(er($), C, D, se);
  }
  function te(C, $, D, se) {
    return it(ht($), C, D, se);
  }
  function le(C, $, D, se) {
    return it(ge($, C.length - D), C, D, se);
  }
  p.prototype.write = function(C, $, D, se) {
    if ($ === void 0)
      se = "utf8", D = this.length, $ = 0;
    else if (D === void 0 && typeof $ == "string")
      se = $, D = this.length, $ = 0;
    else if (isFinite($))
      $ = $ >>> 0, isFinite(D) ? (D = D >>> 0, se === void 0 && (se = "utf8")) : (se = D, D = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const pe = this.length - $;
    if ((D === void 0 || D > pe) && (D = pe), C.length > 0 && (D < 0 || $ < 0) || $ > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    se || (se = "utf8");
    let Se = !1;
    for (; ; )
      switch (se) {
        case "hex":
          return z(this, C, $, D);
        case "utf8":
        case "utf-8":
          return j(this, C, $, D);
        case "ascii":
        case "latin1":
        case "binary":
          return W(this, C, $, D);
        case "base64":
          return te(this, C, $, D);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return le(this, C, $, D);
        default:
          if (Se) throw new TypeError("Unknown encoding: " + se);
          se = ("" + se).toLowerCase(), Se = !0;
      }
  }, p.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ce(C, $, D) {
    return $ === 0 && D === C.length ? e.fromByteArray(C) : e.fromByteArray(C.slice($, D));
  }
  function Ee(C, $, D) {
    D = Math.min(C.length, D);
    const se = [];
    let pe = $;
    for (; pe < D; ) {
      const Se = C[pe];
      let Le = null, ot = Se > 239 ? 4 : Se > 223 ? 3 : Se > 191 ? 2 : 1;
      if (pe + ot <= D) {
        let dt, St, rt, zt;
        switch (ot) {
          case 1:
            Se < 128 && (Le = Se);
            break;
          case 2:
            dt = C[pe + 1], (dt & 192) === 128 && (zt = (Se & 31) << 6 | dt & 63, zt > 127 && (Le = zt));
            break;
          case 3:
            dt = C[pe + 1], St = C[pe + 2], (dt & 192) === 128 && (St & 192) === 128 && (zt = (Se & 15) << 12 | (dt & 63) << 6 | St & 63, zt > 2047 && (zt < 55296 || zt > 57343) && (Le = zt));
            break;
          case 4:
            dt = C[pe + 1], St = C[pe + 2], rt = C[pe + 3], (dt & 192) === 128 && (St & 192) === 128 && (rt & 192) === 128 && (zt = (Se & 15) << 18 | (dt & 63) << 12 | (St & 63) << 6 | rt & 63, zt > 65535 && zt < 1114112 && (Le = zt));
        }
      }
      Le === null ? (Le = 65533, ot = 1) : Le > 65535 && (Le -= 65536, se.push(Le >>> 10 & 1023 | 55296), Le = 56320 | Le & 1023), se.push(Le), pe += ot;
    }
    return _e(se);
  }
  const xe = 4096;
  function _e(C) {
    const $ = C.length;
    if ($ <= xe)
      return String.fromCharCode.apply(String, C);
    let D = "", se = 0;
    for (; se < $; )
      D += String.fromCharCode.apply(
        String,
        C.slice(se, se += xe)
      );
    return D;
  }
  function Ie(C, $, D) {
    let se = "";
    D = Math.min(C.length, D);
    for (let pe = $; pe < D; ++pe)
      se += String.fromCharCode(C[pe] & 127);
    return se;
  }
  function je(C, $, D) {
    let se = "";
    D = Math.min(C.length, D);
    for (let pe = $; pe < D; ++pe)
      se += String.fromCharCode(C[pe]);
    return se;
  }
  function ue(C, $, D) {
    const se = C.length;
    (!$ || $ < 0) && ($ = 0), (!D || D < 0 || D > se) && (D = se);
    let pe = "";
    for (let Se = $; Se < D; ++Se)
      pe += fe[C[Se]];
    return pe;
  }
  function O(C, $, D) {
    const se = C.slice($, D);
    let pe = "";
    for (let Se = 0; Se < se.length - 1; Se += 2)
      pe += String.fromCharCode(se[Se] + se[Se + 1] * 256);
    return pe;
  }
  p.prototype.slice = function(C, $) {
    const D = this.length;
    C = ~~C, $ = $ === void 0 ? D : ~~$, C < 0 ? (C += D, C < 0 && (C = 0)) : C > D && (C = D), $ < 0 ? ($ += D, $ < 0 && ($ = 0)) : $ > D && ($ = D), $ < C && ($ = C);
    const se = this.subarray(C, $);
    return Object.setPrototypeOf(se, p.prototype), se;
  };
  function N(C, $, D) {
    if (C % 1 !== 0 || C < 0) throw new RangeError("offset is not uint");
    if (C + $ > D) throw new RangeError("Trying to access beyond buffer length");
  }
  p.prototype.readUintLE = p.prototype.readUIntLE = function(C, $, D) {
    C = C >>> 0, $ = $ >>> 0, D || N(C, $, this.length);
    let se = this[C], pe = 1, Se = 0;
    for (; ++Se < $ && (pe *= 256); )
      se += this[C + Se] * pe;
    return se;
  }, p.prototype.readUintBE = p.prototype.readUIntBE = function(C, $, D) {
    C = C >>> 0, $ = $ >>> 0, D || N(C, $, this.length);
    let se = this[C + --$], pe = 1;
    for (; $ > 0 && (pe *= 256); )
      se += this[C + --$] * pe;
    return se;
  }, p.prototype.readUint8 = p.prototype.readUInt8 = function(C, $) {
    return C = C >>> 0, $ || N(C, 1, this.length), this[C];
  }, p.prototype.readUint16LE = p.prototype.readUInt16LE = function(C, $) {
    return C = C >>> 0, $ || N(C, 2, this.length), this[C] | this[C + 1] << 8;
  }, p.prototype.readUint16BE = p.prototype.readUInt16BE = function(C, $) {
    return C = C >>> 0, $ || N(C, 2, this.length), this[C] << 8 | this[C + 1];
  }, p.prototype.readUint32LE = p.prototype.readUInt32LE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), (this[C] | this[C + 1] << 8 | this[C + 2] << 16) + this[C + 3] * 16777216;
  }, p.prototype.readUint32BE = p.prototype.readUInt32BE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), this[C] * 16777216 + (this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3]);
  }, p.prototype.readBigUInt64LE = ye(function(C) {
    C = C >>> 0, Te(C, "offset");
    const $ = this[C], D = this[C + 7];
    ($ === void 0 || D === void 0) && qe(C, this.length - 8);
    const se = $ + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24, pe = this[++C] + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + D * 2 ** 24;
    return BigInt(se) + (BigInt(pe) << BigInt(32));
  }), p.prototype.readBigUInt64BE = ye(function(C) {
    C = C >>> 0, Te(C, "offset");
    const $ = this[C], D = this[C + 7];
    ($ === void 0 || D === void 0) && qe(C, this.length - 8);
    const se = $ * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C], pe = this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + D;
    return (BigInt(se) << BigInt(32)) + BigInt(pe);
  }), p.prototype.readIntLE = function(C, $, D) {
    C = C >>> 0, $ = $ >>> 0, D || N(C, $, this.length);
    let se = this[C], pe = 1, Se = 0;
    for (; ++Se < $ && (pe *= 256); )
      se += this[C + Se] * pe;
    return pe *= 128, se >= pe && (se -= Math.pow(2, 8 * $)), se;
  }, p.prototype.readIntBE = function(C, $, D) {
    C = C >>> 0, $ = $ >>> 0, D || N(C, $, this.length);
    let se = $, pe = 1, Se = this[C + --se];
    for (; se > 0 && (pe *= 256); )
      Se += this[C + --se] * pe;
    return pe *= 128, Se >= pe && (Se -= Math.pow(2, 8 * $)), Se;
  }, p.prototype.readInt8 = function(C, $) {
    return C = C >>> 0, $ || N(C, 1, this.length), this[C] & 128 ? (255 - this[C] + 1) * -1 : this[C];
  }, p.prototype.readInt16LE = function(C, $) {
    C = C >>> 0, $ || N(C, 2, this.length);
    const D = this[C] | this[C + 1] << 8;
    return D & 32768 ? D | 4294901760 : D;
  }, p.prototype.readInt16BE = function(C, $) {
    C = C >>> 0, $ || N(C, 2, this.length);
    const D = this[C + 1] | this[C] << 8;
    return D & 32768 ? D | 4294901760 : D;
  }, p.prototype.readInt32LE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), this[C] | this[C + 1] << 8 | this[C + 2] << 16 | this[C + 3] << 24;
  }, p.prototype.readInt32BE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), this[C] << 24 | this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3];
  }, p.prototype.readBigInt64LE = ye(function(C) {
    C = C >>> 0, Te(C, "offset");
    const $ = this[C], D = this[C + 7];
    ($ === void 0 || D === void 0) && qe(C, this.length - 8);
    const se = this[C + 4] + this[C + 5] * 2 ** 8 + this[C + 6] * 2 ** 16 + (D << 24);
    return (BigInt(se) << BigInt(32)) + BigInt($ + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24);
  }), p.prototype.readBigInt64BE = ye(function(C) {
    C = C >>> 0, Te(C, "offset");
    const $ = this[C], D = this[C + 7];
    ($ === void 0 || D === void 0) && qe(C, this.length - 8);
    const se = ($ << 24) + // Overflow
    this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C];
    return (BigInt(se) << BigInt(32)) + BigInt(this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + D);
  }), p.prototype.readFloatLE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), r.read(this, C, !0, 23, 4);
  }, p.prototype.readFloatBE = function(C, $) {
    return C = C >>> 0, $ || N(C, 4, this.length), r.read(this, C, !1, 23, 4);
  }, p.prototype.readDoubleLE = function(C, $) {
    return C = C >>> 0, $ || N(C, 8, this.length), r.read(this, C, !0, 52, 8);
  }, p.prototype.readDoubleBE = function(C, $) {
    return C = C >>> 0, $ || N(C, 8, this.length), r.read(this, C, !1, 52, 8);
  };
  function J(C, $, D, se, pe, Se) {
    if (!p.isBuffer(C)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if ($ > pe || $ < Se) throw new RangeError('"value" argument is out of bounds');
    if (D + se > C.length) throw new RangeError("Index out of range");
  }
  p.prototype.writeUintLE = p.prototype.writeUIntLE = function(C, $, D, se) {
    if (C = +C, $ = $ >>> 0, D = D >>> 0, !se) {
      const Le = Math.pow(2, 8 * D) - 1;
      J(this, C, $, D, Le, 0);
    }
    let pe = 1, Se = 0;
    for (this[$] = C & 255; ++Se < D && (pe *= 256); )
      this[$ + Se] = C / pe & 255;
    return $ + D;
  }, p.prototype.writeUintBE = p.prototype.writeUIntBE = function(C, $, D, se) {
    if (C = +C, $ = $ >>> 0, D = D >>> 0, !se) {
      const Le = Math.pow(2, 8 * D) - 1;
      J(this, C, $, D, Le, 0);
    }
    let pe = D - 1, Se = 1;
    for (this[$ + pe] = C & 255; --pe >= 0 && (Se *= 256); )
      this[$ + pe] = C / Se & 255;
    return $ + D;
  }, p.prototype.writeUint8 = p.prototype.writeUInt8 = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 1, 255, 0), this[$] = C & 255, $ + 1;
  }, p.prototype.writeUint16LE = p.prototype.writeUInt16LE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 2, 65535, 0), this[$] = C & 255, this[$ + 1] = C >>> 8, $ + 2;
  }, p.prototype.writeUint16BE = p.prototype.writeUInt16BE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 2, 65535, 0), this[$] = C >>> 8, this[$ + 1] = C & 255, $ + 2;
  }, p.prototype.writeUint32LE = p.prototype.writeUInt32LE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 4, 4294967295, 0), this[$ + 3] = C >>> 24, this[$ + 2] = C >>> 16, this[$ + 1] = C >>> 8, this[$] = C & 255, $ + 4;
  }, p.prototype.writeUint32BE = p.prototype.writeUInt32BE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 4, 4294967295, 0), this[$] = C >>> 24, this[$ + 1] = C >>> 16, this[$ + 2] = C >>> 8, this[$ + 3] = C & 255, $ + 4;
  };
  function re(C, $, D, se, pe) {
    Fe($, se, pe, C, D, 7);
    let Se = Number($ & BigInt(4294967295));
    C[D++] = Se, Se = Se >> 8, C[D++] = Se, Se = Se >> 8, C[D++] = Se, Se = Se >> 8, C[D++] = Se;
    let Le = Number($ >> BigInt(32) & BigInt(4294967295));
    return C[D++] = Le, Le = Le >> 8, C[D++] = Le, Le = Le >> 8, C[D++] = Le, Le = Le >> 8, C[D++] = Le, D;
  }
  function oe(C, $, D, se, pe) {
    Fe($, se, pe, C, D, 7);
    let Se = Number($ & BigInt(4294967295));
    C[D + 7] = Se, Se = Se >> 8, C[D + 6] = Se, Se = Se >> 8, C[D + 5] = Se, Se = Se >> 8, C[D + 4] = Se;
    let Le = Number($ >> BigInt(32) & BigInt(4294967295));
    return C[D + 3] = Le, Le = Le >> 8, C[D + 2] = Le, Le = Le >> 8, C[D + 1] = Le, Le = Le >> 8, C[D] = Le, D + 8;
  }
  p.prototype.writeBigUInt64LE = ye(function(C, $ = 0) {
    return re(this, C, $, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeBigUInt64BE = ye(function(C, $ = 0) {
    return oe(this, C, $, BigInt(0), BigInt("0xffffffffffffffff"));
  }), p.prototype.writeIntLE = function(C, $, D, se) {
    if (C = +C, $ = $ >>> 0, !se) {
      const ot = Math.pow(2, 8 * D - 1);
      J(this, C, $, D, ot - 1, -ot);
    }
    let pe = 0, Se = 1, Le = 0;
    for (this[$] = C & 255; ++pe < D && (Se *= 256); )
      C < 0 && Le === 0 && this[$ + pe - 1] !== 0 && (Le = 1), this[$ + pe] = (C / Se >> 0) - Le & 255;
    return $ + D;
  }, p.prototype.writeIntBE = function(C, $, D, se) {
    if (C = +C, $ = $ >>> 0, !se) {
      const ot = Math.pow(2, 8 * D - 1);
      J(this, C, $, D, ot - 1, -ot);
    }
    let pe = D - 1, Se = 1, Le = 0;
    for (this[$ + pe] = C & 255; --pe >= 0 && (Se *= 256); )
      C < 0 && Le === 0 && this[$ + pe + 1] !== 0 && (Le = 1), this[$ + pe] = (C / Se >> 0) - Le & 255;
    return $ + D;
  }, p.prototype.writeInt8 = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 1, 127, -128), C < 0 && (C = 255 + C + 1), this[$] = C & 255, $ + 1;
  }, p.prototype.writeInt16LE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 2, 32767, -32768), this[$] = C & 255, this[$ + 1] = C >>> 8, $ + 2;
  }, p.prototype.writeInt16BE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 2, 32767, -32768), this[$] = C >>> 8, this[$ + 1] = C & 255, $ + 2;
  }, p.prototype.writeInt32LE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 4, 2147483647, -2147483648), this[$] = C & 255, this[$ + 1] = C >>> 8, this[$ + 2] = C >>> 16, this[$ + 3] = C >>> 24, $ + 4;
  }, p.prototype.writeInt32BE = function(C, $, D) {
    return C = +C, $ = $ >>> 0, D || J(this, C, $, 4, 2147483647, -2147483648), C < 0 && (C = 4294967295 + C + 1), this[$] = C >>> 24, this[$ + 1] = C >>> 16, this[$ + 2] = C >>> 8, this[$ + 3] = C & 255, $ + 4;
  }, p.prototype.writeBigInt64LE = ye(function(C, $ = 0) {
    return re(this, C, $, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), p.prototype.writeBigInt64BE = ye(function(C, $ = 0) {
    return oe(this, C, $, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ee(C, $, D, se, pe, Se) {
    if (D + se > C.length) throw new RangeError("Index out of range");
    if (D < 0) throw new RangeError("Index out of range");
  }
  function ae(C, $, D, se, pe) {
    return $ = +$, D = D >>> 0, pe || ee(C, $, D, 4), r.write(C, $, D, se, 23, 4), D + 4;
  }
  p.prototype.writeFloatLE = function(C, $, D) {
    return ae(this, C, $, !0, D);
  }, p.prototype.writeFloatBE = function(C, $, D) {
    return ae(this, C, $, !1, D);
  };
  function me(C, $, D, se, pe) {
    return $ = +$, D = D >>> 0, pe || ee(C, $, D, 8), r.write(C, $, D, se, 52, 8), D + 8;
  }
  p.prototype.writeDoubleLE = function(C, $, D) {
    return me(this, C, $, !0, D);
  }, p.prototype.writeDoubleBE = function(C, $, D) {
    return me(this, C, $, !1, D);
  }, p.prototype.copy = function(C, $, D, se) {
    if (!p.isBuffer(C)) throw new TypeError("argument should be a Buffer");
    if (D || (D = 0), !se && se !== 0 && (se = this.length), $ >= C.length && ($ = C.length), $ || ($ = 0), se > 0 && se < D && (se = D), se === D || C.length === 0 || this.length === 0) return 0;
    if ($ < 0)
      throw new RangeError("targetStart out of bounds");
    if (D < 0 || D >= this.length) throw new RangeError("Index out of range");
    if (se < 0) throw new RangeError("sourceEnd out of bounds");
    se > this.length && (se = this.length), C.length - $ < se - D && (se = C.length - $ + D);
    const pe = se - D;
    return this === C && typeof s.prototype.copyWithin == "function" ? this.copyWithin($, D, se) : s.prototype.set.call(
      C,
      this.subarray(D, se),
      $
    ), pe;
  }, p.prototype.fill = function(C, $, D, se) {
    if (typeof C == "string") {
      if (typeof $ == "string" ? (se = $, $ = 0, D = this.length) : typeof D == "string" && (se = D, D = this.length), se !== void 0 && typeof se != "string")
        throw new TypeError("encoding must be a string");
      if (typeof se == "string" && !p.isEncoding(se))
        throw new TypeError("Unknown encoding: " + se);
      if (C.length === 1) {
        const Se = C.charCodeAt(0);
        (se === "utf8" && Se < 128 || se === "latin1") && (C = Se);
      }
    } else typeof C == "number" ? C = C & 255 : typeof C == "boolean" && (C = Number(C));
    if ($ < 0 || this.length < $ || this.length < D)
      throw new RangeError("Out of range index");
    if (D <= $)
      return this;
    $ = $ >>> 0, D = D === void 0 ? this.length : D >>> 0, C || (C = 0);
    let pe;
    if (typeof C == "number")
      for (pe = $; pe < D; ++pe)
        this[pe] = C;
    else {
      const Se = p.isBuffer(C) ? C : p.from(C, se), Le = Se.length;
      if (Le === 0)
        throw new TypeError('The value "' + C + '" is invalid for argument "value"');
      for (pe = 0; pe < D - $; ++pe)
        this[pe + $] = Se[pe % Le];
    }
    return this;
  };
  const H = {};
  function X(C, $, D) {
    H[C] = class extends D {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: $.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${C}]`, this.stack, delete this.name;
      }
      get code() {
        return C;
      }
      set code(se) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: se,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${C}]: ${this.message}`;
      }
    };
  }
  X(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(C) {
      return C ? `${C} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), X(
    "ERR_INVALID_ARG_TYPE",
    function(C, $) {
      return `The "${C}" argument must be of type number. Received type ${typeof $}`;
    },
    TypeError
  ), X(
    "ERR_OUT_OF_RANGE",
    function(C, $, D) {
      let se = `The value of "${C}" is out of range.`, pe = D;
      return Number.isInteger(D) && Math.abs(D) > 2 ** 32 ? pe = Ae(String(D)) : typeof D == "bigint" && (pe = String(D), (D > BigInt(2) ** BigInt(32) || D < -(BigInt(2) ** BigInt(32))) && (pe = Ae(pe)), pe += "n"), se += ` It must be ${$}. Received ${pe}`, se;
    },
    RangeError
  );
  function Ae(C) {
    let $ = "", D = C.length;
    const se = C[0] === "-" ? 1 : 0;
    for (; D >= se + 4; D -= 3)
      $ = `_${C.slice(D - 3, D)}${$}`;
    return `${C.slice(0, D)}${$}`;
  }
  function Re(C, $, D) {
    Te($, "offset"), (C[$] === void 0 || C[$ + D] === void 0) && qe($, C.length - (D + 1));
  }
  function Fe(C, $, D, se, pe, Se) {
    if (C > D || C < $) {
      const Le = typeof $ == "bigint" ? "n" : "";
      let ot;
      throw $ === 0 || $ === BigInt(0) ? ot = `>= 0${Le} and < 2${Le} ** ${(Se + 1) * 8}${Le}` : ot = `>= -(2${Le} ** ${(Se + 1) * 8 - 1}${Le}) and < 2 ** ${(Se + 1) * 8 - 1}${Le}`, new H.ERR_OUT_OF_RANGE("value", ot, C);
    }
    Re(se, pe, Se);
  }
  function Te(C, $) {
    if (typeof C != "number")
      throw new H.ERR_INVALID_ARG_TYPE($, "number", C);
  }
  function qe(C, $, D) {
    throw Math.floor(C) !== C ? (Te(C, D), new H.ERR_OUT_OF_RANGE("offset", "an integer", C)) : $ < 0 ? new H.ERR_BUFFER_OUT_OF_BOUNDS() : new H.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${$}`,
      C
    );
  }
  const tt = /[^+/0-9A-Za-z-_]/g;
  function Pe(C) {
    if (C = C.split("=")[0], C = C.trim().replace(tt, ""), C.length < 2) return "";
    for (; C.length % 4 !== 0; )
      C = C + "=";
    return C;
  }
  function At(C, $) {
    $ = $ || 1 / 0;
    let D;
    const se = C.length;
    let pe = null;
    const Se = [];
    for (let Le = 0; Le < se; ++Le) {
      if (D = C.charCodeAt(Le), D > 55295 && D < 57344) {
        if (!pe) {
          if (D > 56319) {
            ($ -= 3) > -1 && Se.push(239, 191, 189);
            continue;
          } else if (Le + 1 === se) {
            ($ -= 3) > -1 && Se.push(239, 191, 189);
            continue;
          }
          pe = D;
          continue;
        }
        if (D < 56320) {
          ($ -= 3) > -1 && Se.push(239, 191, 189), pe = D;
          continue;
        }
        D = (pe - 55296 << 10 | D - 56320) + 65536;
      } else pe && ($ -= 3) > -1 && Se.push(239, 191, 189);
      if (pe = null, D < 128) {
        if (($ -= 1) < 0) break;
        Se.push(D);
      } else if (D < 2048) {
        if (($ -= 2) < 0) break;
        Se.push(
          D >> 6 | 192,
          D & 63 | 128
        );
      } else if (D < 65536) {
        if (($ -= 3) < 0) break;
        Se.push(
          D >> 12 | 224,
          D >> 6 & 63 | 128,
          D & 63 | 128
        );
      } else if (D < 1114112) {
        if (($ -= 4) < 0) break;
        Se.push(
          D >> 18 | 240,
          D >> 12 & 63 | 128,
          D >> 6 & 63 | 128,
          D & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Se;
  }
  function er(C) {
    const $ = [];
    for (let D = 0; D < C.length; ++D)
      $.push(C.charCodeAt(D) & 255);
    return $;
  }
  function ge(C, $) {
    let D, se, pe;
    const Se = [];
    for (let Le = 0; Le < C.length && !(($ -= 2) < 0); ++Le)
      D = C.charCodeAt(Le), se = D >> 8, pe = D % 256, Se.push(pe), Se.push(se);
    return Se;
  }
  function ht(C) {
    return e.toByteArray(Pe(C));
  }
  function it(C, $, D, se) {
    let pe;
    for (pe = 0; pe < se && !(pe + D >= $.length || pe >= C.length); ++pe)
      $[pe + D] = C[pe];
    return pe;
  }
  function kt(C, $) {
    return C instanceof $ || C != null && C.constructor != null && C.constructor.name != null && C.constructor.name === $.name;
  }
  function Ze(C) {
    return C !== C;
  }
  const fe = function() {
    const C = "0123456789abcdef", $ = new Array(256);
    for (let D = 0; D < 16; ++D) {
      const se = D * 16;
      for (let pe = 0; pe < 16; ++pe)
        $[se + pe] = C[D] + C[pe];
    }
    return $;
  }();
  function ye(C) {
    return typeof BigInt > "u" ? Je : C;
  }
  function Je() {
    throw new Error("BigInt not supported");
  }
})(W$);
const ju = W$.Buffer;
var $w, __;
function Q$() {
  if (__) return $w;
  __ = 1;
  const t = (o, a, l) => {
    const c = o.length, p = l.length, h = o.substring(0, a), d = o.substring(a + p, c);
    return [h, d];
  }, e = (o, a, l) => {
    const c = o.length, p = l.length, h = ju.alloc(a);
    o.copy(h, 0, 0, a);
    const d = ju.alloc(c - a - p);
    return o.copy(d, 0, a + p, c), [h, d];
  }, r = (o, a) => {
    const l = o.indexOf(a);
    let c = t;
    if (l < 0)
      return [o];
    ju.isBuffer(o) && (c = e);
    const [p, h] = c(o, l, a);
    let d = [];
    return p.length > 0 && (d = [p]), d = [...d, a], h.length > 0 && (d = [...d, h]), d;
  }, n = (o, a) => {
    const l = r(o, a);
    return l.length <= 1 ? l : l.length <= 2 ? [l[0], ...n(l[1], a)] : [l[0], l[1], ...n(l[2], a)];
  }, i = (o, a) => o.flatMap((l) => n(l, a)), s = (o, a) => {
    if (a.length <= 0)
      return o;
    const l = i(o, a[0]);
    return s(l, a.slice(1));
  };
  return $w = (o, ...a) => s([o], a), $w;
}
var Vm = { exports: {} }, C_;
function fS() {
  if (C_) return Vm.exports;
  C_ = 1;
  var t = typeof Reflect == "object" ? Reflect : null, e = t && typeof t.apply == "function" ? t.apply : function(g, w, _) {
    return Function.prototype.apply.call(g, w, _);
  }, r;
  t && typeof t.ownKeys == "function" ? r = t.ownKeys : Object.getOwnPropertySymbols ? r = function(g) {
    return Object.getOwnPropertyNames(g).concat(Object.getOwnPropertySymbols(g));
  } : r = function(g) {
    return Object.getOwnPropertyNames(g);
  };
  function n(g) {
    console && console.warn && console.warn(g);
  }
  var i = Number.isNaN || function(g) {
    return g !== g;
  };
  function s() {
    s.init.call(this);
  }
  Vm.exports = s, Vm.exports.once = E, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var o = 10;
  function a(g) {
    if (typeof g != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof g);
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return o;
    },
    set: function(g) {
      if (typeof g != "number" || g < 0 || i(g))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + g + ".");
      o = g;
    }
  }), s.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(g) {
    if (typeof g != "number" || g < 0 || i(g))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + g + ".");
    return this._maxListeners = g, this;
  };
  function l(g) {
    return g._maxListeners === void 0 ? s.defaultMaxListeners : g._maxListeners;
  }
  s.prototype.getMaxListeners = function() {
    return l(this);
  }, s.prototype.emit = function(g) {
    for (var w = [], _ = 1; _ < arguments.length; _++) w.push(arguments[_]);
    var S = g === "error", R = this._events;
    if (R !== void 0)
      S = S && R.error === void 0;
    else if (!S)
      return !1;
    if (S) {
      var L;
      if (w.length > 0 && (L = w[0]), L instanceof Error)
        throw L;
      var F = new Error("Unhandled error." + (L ? " (" + L.message + ")" : ""));
      throw F.context = L, F;
    }
    var z = R[g];
    if (z === void 0)
      return !1;
    if (typeof z == "function")
      e(z, this, w);
    else
      for (var j = z.length, W = m(z, j), _ = 0; _ < j; ++_)
        e(W[_], this, w);
    return !0;
  };
  function c(g, w, _, S) {
    var R, L, F;
    if (a(_), L = g._events, L === void 0 ? (L = g._events = /* @__PURE__ */ Object.create(null), g._eventsCount = 0) : (L.newListener !== void 0 && (g.emit(
      "newListener",
      w,
      _.listener ? _.listener : _
    ), L = g._events), F = L[w]), F === void 0)
      F = L[w] = _, ++g._eventsCount;
    else if (typeof F == "function" ? F = L[w] = S ? [_, F] : [F, _] : S ? F.unshift(_) : F.push(_), R = l(g), R > 0 && F.length > R && !F.warned) {
      F.warned = !0;
      var z = new Error("Possible EventEmitter memory leak detected. " + F.length + " " + String(w) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      z.name = "MaxListenersExceededWarning", z.emitter = g, z.type = w, z.count = F.length, n(z);
    }
    return g;
  }
  s.prototype.addListener = function(g, w) {
    return c(this, g, w, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(g, w) {
    return c(this, g, w, !0);
  };
  function p() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function h(g, w, _) {
    var S = { fired: !1, wrapFn: void 0, target: g, type: w, listener: _ }, R = p.bind(S);
    return R.listener = _, S.wrapFn = R, R;
  }
  s.prototype.once = function(g, w) {
    return a(w), this.on(g, h(this, g, w)), this;
  }, s.prototype.prependOnceListener = function(g, w) {
    return a(w), this.prependListener(g, h(this, g, w)), this;
  }, s.prototype.removeListener = function(g, w) {
    var _, S, R, L, F;
    if (a(w), S = this._events, S === void 0)
      return this;
    if (_ = S[g], _ === void 0)
      return this;
    if (_ === w || _.listener === w)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete S[g], S.removeListener && this.emit("removeListener", g, _.listener || w));
    else if (typeof _ != "function") {
      for (R = -1, L = _.length - 1; L >= 0; L--)
        if (_[L] === w || _[L].listener === w) {
          F = _[L].listener, R = L;
          break;
        }
      if (R < 0)
        return this;
      R === 0 ? _.shift() : b(_, R), _.length === 1 && (S[g] = _[0]), S.removeListener !== void 0 && this.emit("removeListener", g, F || w);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(g) {
    var w, _, S;
    if (_ = this._events, _ === void 0)
      return this;
    if (_.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : _[g] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete _[g]), this;
    if (arguments.length === 0) {
      var R = Object.keys(_), L;
      for (S = 0; S < R.length; ++S)
        L = R[S], L !== "removeListener" && this.removeAllListeners(L);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (w = _[g], typeof w == "function")
      this.removeListener(g, w);
    else if (w !== void 0)
      for (S = w.length - 1; S >= 0; S--)
        this.removeListener(g, w[S]);
    return this;
  };
  function d(g, w, _) {
    var S = g._events;
    if (S === void 0)
      return [];
    var R = S[w];
    return R === void 0 ? [] : typeof R == "function" ? _ ? [R.listener || R] : [R] : _ ? f(R) : m(R, R.length);
  }
  s.prototype.listeners = function(g) {
    return d(this, g, !0);
  }, s.prototype.rawListeners = function(g) {
    return d(this, g, !1);
  }, s.listenerCount = function(g, w) {
    return typeof g.listenerCount == "function" ? g.listenerCount(w) : v.call(g, w);
  }, s.prototype.listenerCount = v;
  function v(g) {
    var w = this._events;
    if (w !== void 0) {
      var _ = w[g];
      if (typeof _ == "function")
        return 1;
      if (_ !== void 0)
        return _.length;
    }
    return 0;
  }
  s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? r(this._events) : [];
  };
  function m(g, w) {
    for (var _ = new Array(w), S = 0; S < w; ++S)
      _[S] = g[S];
    return _;
  }
  function b(g, w) {
    for (; w + 1 < g.length; w++)
      g[w] = g[w + 1];
    g.pop();
  }
  function f(g) {
    for (var w = new Array(g.length), _ = 0; _ < w.length; ++_)
      w[_] = g[_].listener || g[_];
    return w;
  }
  function E(g, w) {
    return new Promise(function(_, S) {
      function R(F) {
        g.removeListener(w, L), S(F);
      }
      function L() {
        typeof g.removeListener == "function" && g.removeListener("error", R), _([].slice.call(arguments));
      }
      x(g, w, L, { once: !0 }), w !== "error" && A(g, R, { once: !0 });
    });
  }
  function A(g, w, _) {
    typeof g.on == "function" && x(g, "error", w, _);
  }
  function x(g, w, _, S) {
    if (typeof g.on == "function")
      S.once ? g.once(w, _) : g.on(w, _);
    else if (typeof g.addEventListener == "function")
      g.addEventListener(w, function R(L) {
        S.once && g.removeEventListener(w, R), _(L);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof g);
  }
  return Vm.exports;
}
var jw = { exports: {} }, I_;
function Bh() {
  return I_ || (I_ = 1, typeof Object.create == "function" ? jw.exports = function(t, e) {
    e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : jw.exports = function(t, e) {
    if (e) {
      t.super_ = e;
      var r = function() {
      };
      r.prototype = e.prototype, t.prototype = new r(), t.prototype.constructor = t;
    }
  }), jw.exports;
}
function gye(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var K$ = { exports: {} }, Hr = K$.exports = {}, So, Ao;
function m4() {
  throw new Error("setTimeout has not been defined");
}
function y4() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? So = setTimeout : So = m4;
  } catch {
    So = m4;
  }
  try {
    typeof clearTimeout == "function" ? Ao = clearTimeout : Ao = y4;
  } catch {
    Ao = y4;
  }
})();
function Y$(t) {
  if (So === setTimeout)
    return setTimeout(t, 0);
  if ((So === m4 || !So) && setTimeout)
    return So = setTimeout, setTimeout(t, 0);
  try {
    return So(t, 0);
  } catch {
    try {
      return So.call(null, t, 0);
    } catch {
      return So.call(this, t, 0);
    }
  }
}
function mye(t) {
  if (Ao === clearTimeout)
    return clearTimeout(t);
  if ((Ao === y4 || !Ao) && clearTimeout)
    return Ao = clearTimeout, clearTimeout(t);
  try {
    return Ao(t);
  } catch {
    try {
      return Ao.call(null, t);
    } catch {
      return Ao.call(this, t);
    }
  }
}
var da = [], Np = !1, Bu, I1 = -1;
function yye() {
  !Np || !Bu || (Np = !1, Bu.length ? da = Bu.concat(da) : I1 = -1, da.length && Z$());
}
function Z$() {
  if (!Np) {
    var t = Y$(yye);
    Np = !0;
    for (var e = da.length; e; ) {
      for (Bu = da, da = []; ++I1 < e; )
        Bu && Bu[I1].run();
      I1 = -1, e = da.length;
    }
    Bu = null, Np = !1, mye(t);
  }
}
Hr.nextTick = function(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
  da.push(new J$(t, e)), da.length === 1 && !Np && Y$(Z$);
};
function J$(t, e) {
  this.fun = t, this.array = e;
}
J$.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Hr.title = "browser";
Hr.browser = !0;
Hr.env = {};
Hr.argv = [];
Hr.version = "";
Hr.versions = {};
function Za() {
}
Hr.on = Za;
Hr.addListener = Za;
Hr.once = Za;
Hr.off = Za;
Hr.removeListener = Za;
Hr.removeAllListeners = Za;
Hr.emit = Za;
Hr.prependListener = Za;
Hr.prependOnceListener = Za;
Hr.listeners = function(t) {
  return [];
};
Hr.binding = function(t) {
  throw new Error("process.binding is not supported");
};
Hr.cwd = function() {
  return "/";
};
Hr.chdir = function(t) {
  throw new Error("process.chdir is not supported");
};
Hr.umask = function() {
  return 0;
};
var vye = K$.exports;
const Vt = /* @__PURE__ */ gye(vye);
var P_, R_;
function X$() {
  return R_ || (R_ = 1, P_ = fS().EventEmitter), P_;
}
var O_ = {}, T_;
function Lv() {
  return T_ || (T_ = 1, function(t) {
    Object.defineProperties(t, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
    var e = {}, r = {};
    r.byteLength = p, r.toByteArray = d, r.fromByteArray = b;
    for (var n = [], i = [], s = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, l = o.length; a < l; ++a)
      n[a] = o[a], i[o.charCodeAt(a)] = a;
    i[45] = 62, i[95] = 63;
    function c(A) {
      var x = A.length;
      if (x % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var g = A.indexOf("=");
      g === -1 && (g = x);
      var w = g === x ? 0 : 4 - g % 4;
      return [g, w];
    }
    function p(A) {
      var x = c(A), g = x[0], w = x[1];
      return (g + w) * 3 / 4 - w;
    }
    function h(A, x, g) {
      return (x + g) * 3 / 4 - g;
    }
    function d(A) {
      var x, g = c(A), w = g[0], _ = g[1], S = new s(h(A, w, _)), R = 0, L = _ > 0 ? w - 4 : w, F;
      for (F = 0; F < L; F += 4)
        x = i[A.charCodeAt(F)] << 18 | i[A.charCodeAt(F + 1)] << 12 | i[A.charCodeAt(F + 2)] << 6 | i[A.charCodeAt(F + 3)], S[R++] = x >> 16 & 255, S[R++] = x >> 8 & 255, S[R++] = x & 255;
      return _ === 2 && (x = i[A.charCodeAt(F)] << 2 | i[A.charCodeAt(F + 1)] >> 4, S[R++] = x & 255), _ === 1 && (x = i[A.charCodeAt(F)] << 10 | i[A.charCodeAt(F + 1)] << 4 | i[A.charCodeAt(F + 2)] >> 2, S[R++] = x >> 8 & 255, S[R++] = x & 255), S;
    }
    function v(A) {
      return n[A >> 18 & 63] + n[A >> 12 & 63] + n[A >> 6 & 63] + n[A & 63];
    }
    function m(A, x, g) {
      for (var w, _ = [], S = x; S < g; S += 3)
        w = (A[S] << 16 & 16711680) + (A[S + 1] << 8 & 65280) + (A[S + 2] & 255), _.push(v(w));
      return _.join("");
    }
    function b(A) {
      for (var x, g = A.length, w = g % 3, _ = [], S = 16383, R = 0, L = g - w; R < L; R += S)
        _.push(m(A, R, R + S > L ? L : R + S));
      return w === 1 ? (x = A[g - 1], _.push(
        n[x >> 2] + n[x << 4 & 63] + "=="
      )) : w === 2 && (x = (A[g - 2] << 8) + A[g - 1], _.push(
        n[x >> 10] + n[x >> 4 & 63] + n[x << 2 & 63] + "="
      )), _.join("");
    }
    var f = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    f.read = function(A, x, g, w, _) {
      var S, R, L = _ * 8 - w - 1, F = (1 << L) - 1, z = F >> 1, j = -7, W = g ? _ - 1 : 0, te = g ? -1 : 1, le = A[x + W];
      for (W += te, S = le & (1 << -j) - 1, le >>= -j, j += L; j > 0; S = S * 256 + A[x + W], W += te, j -= 8)
        ;
      for (R = S & (1 << -j) - 1, S >>= -j, j += w; j > 0; R = R * 256 + A[x + W], W += te, j -= 8)
        ;
      if (S === 0)
        S = 1 - z;
      else {
        if (S === F)
          return R ? NaN : (le ? -1 : 1) * (1 / 0);
        R = R + Math.pow(2, w), S = S - z;
      }
      return (le ? -1 : 1) * R * Math.pow(2, S - w);
    }, f.write = function(A, x, g, w, _, S) {
      var R, L, F, z = S * 8 - _ - 1, j = (1 << z) - 1, W = j >> 1, te = _ === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, le = w ? 0 : S - 1, ce = w ? 1 : -1, Ee = x < 0 || x === 0 && 1 / x < 0 ? 1 : 0;
      for (x = Math.abs(x), isNaN(x) || x === 1 / 0 ? (L = isNaN(x) ? 1 : 0, R = j) : (R = Math.floor(Math.log(x) / Math.LN2), x * (F = Math.pow(2, -R)) < 1 && (R--, F *= 2), R + W >= 1 ? x += te / F : x += te * Math.pow(2, 1 - W), x * F >= 2 && (R++, F /= 2), R + W >= j ? (L = 0, R = j) : R + W >= 1 ? (L = (x * F - 1) * Math.pow(2, _), R = R + W) : (L = x * Math.pow(2, W - 1) * Math.pow(2, _), R = 0)); _ >= 8; A[g + le] = L & 255, le += ce, L /= 256, _ -= 8)
        ;
      for (R = R << _ | L, z += _; z > 0; A[g + le] = R & 255, le += ce, R /= 256, z -= 8)
        ;
      A[g + le - ce] |= Ee * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(A) {
      const x = r, g = f, w = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      A.Buffer = j, A.SlowBuffer = O, A.INSPECT_MAX_BYTES = 50;
      const _ = 2147483647;
      A.kMaxLength = _;
      const { Uint8Array: S, ArrayBuffer: R, SharedArrayBuffer: L } = globalThis;
      j.TYPED_ARRAY_SUPPORT = F(), !j.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
      function F() {
        try {
          const M = new S(1), U = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(U, S.prototype), Object.setPrototypeOf(M, U), M.foo() === 42;
        } catch {
          return !1;
        }
      }
      Object.defineProperty(j.prototype, "parent", {
        enumerable: !0,
        get: function() {
          if (j.isBuffer(this))
            return this.buffer;
        }
      }), Object.defineProperty(j.prototype, "offset", {
        enumerable: !0,
        get: function() {
          if (j.isBuffer(this))
            return this.byteOffset;
        }
      });
      function z(M) {
        if (M > _)
          throw new RangeError('The value "' + M + '" is invalid for option "size"');
        const U = new S(M);
        return Object.setPrototypeOf(U, j.prototype), U;
      }
      function j(M, U, K) {
        if (typeof M == "number") {
          if (typeof U == "string")
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return ce(M);
        }
        return W(M, U, K);
      }
      j.poolSize = 8192;
      function W(M, U, K) {
        if (typeof M == "string")
          return Ee(M, U);
        if (R.isView(M))
          return _e(M);
        if (M == null)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M
          );
        if (tr(M, R) || M && tr(M.buffer, R) || typeof L < "u" && (tr(M, L) || M && tr(M.buffer, L)))
          return Ie(M, U, K);
        if (typeof M == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const de = M.valueOf && M.valueOf();
        if (de != null && de !== M)
          return j.from(de, U, K);
        const ve = je(M);
        if (ve) return ve;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof M[Symbol.toPrimitive] == "function")
          return j.from(M[Symbol.toPrimitive]("string"), U, K);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M
        );
      }
      j.from = function(M, U, K) {
        return W(M, U, K);
      }, Object.setPrototypeOf(j.prototype, S.prototype), Object.setPrototypeOf(j, S);
      function te(M) {
        if (typeof M != "number")
          throw new TypeError('"size" argument must be of type number');
        if (M < 0)
          throw new RangeError('The value "' + M + '" is invalid for option "size"');
      }
      function le(M, U, K) {
        return te(M), M <= 0 ? z(M) : U !== void 0 ? typeof K == "string" ? z(M).fill(U, K) : z(M).fill(U) : z(M);
      }
      j.alloc = function(M, U, K) {
        return le(M, U, K);
      };
      function ce(M) {
        return te(M), z(M < 0 ? 0 : ue(M) | 0);
      }
      j.allocUnsafe = function(M) {
        return ce(M);
      }, j.allocUnsafeSlow = function(M) {
        return ce(M);
      };
      function Ee(M, U) {
        if ((typeof U != "string" || U === "") && (U = "utf8"), !j.isEncoding(U))
          throw new TypeError("Unknown encoding: " + U);
        const K = N(M, U) | 0;
        let de = z(K);
        const ve = de.write(M, U);
        return ve !== K && (de = de.slice(0, ve)), de;
      }
      function xe(M) {
        const U = M.length < 0 ? 0 : ue(M.length) | 0, K = z(U);
        for (let de = 0; de < U; de += 1)
          K[de] = M[de] & 255;
        return K;
      }
      function _e(M) {
        if (tr(M, S)) {
          const U = new S(M);
          return Ie(U.buffer, U.byteOffset, U.byteLength);
        }
        return xe(M);
      }
      function Ie(M, U, K) {
        if (U < 0 || M.byteLength < U)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (M.byteLength < U + (K || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let de;
        return U === void 0 && K === void 0 ? de = new S(M) : K === void 0 ? de = new S(M, U) : de = new S(M, U, K), Object.setPrototypeOf(de, j.prototype), de;
      }
      function je(M) {
        if (j.isBuffer(M)) {
          const U = ue(M.length) | 0, K = z(U);
          return K.length === 0 || M.copy(K, 0, 0, U), K;
        }
        if (M.length !== void 0)
          return typeof M.length != "number" || Nr(M.length) ? z(0) : xe(M);
        if (M.type === "Buffer" && Array.isArray(M.data))
          return xe(M.data);
      }
      function ue(M) {
        if (M >= _)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + _.toString(16) + " bytes");
        return M | 0;
      }
      function O(M) {
        return +M != M && (M = 0), j.alloc(+M);
      }
      j.isBuffer = function(M) {
        return M != null && M._isBuffer === !0 && M !== j.prototype;
      }, j.compare = function(M, U) {
        if (tr(M, S) && (M = j.from(M, M.offset, M.byteLength)), tr(U, S) && (U = j.from(U, U.offset, U.byteLength)), !j.isBuffer(M) || !j.isBuffer(U))
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (M === U) return 0;
        let K = M.length, de = U.length;
        for (let ve = 0, Z = Math.min(K, de); ve < Z; ++ve)
          if (M[ve] !== U[ve]) {
            K = M[ve], de = U[ve];
            break;
          }
        return K < de ? -1 : de < K ? 1 : 0;
      }, j.isEncoding = function(M) {
        switch (String(M).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, j.concat = function(M, U) {
        if (!Array.isArray(M))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (M.length === 0)
          return j.alloc(0);
        let K;
        if (U === void 0)
          for (U = 0, K = 0; K < M.length; ++K)
            U += M[K].length;
        const de = j.allocUnsafe(U);
        let ve = 0;
        for (K = 0; K < M.length; ++K) {
          let Z = M[K];
          if (tr(Z, S))
            ve + Z.length > de.length ? (j.isBuffer(Z) || (Z = j.from(Z)), Z.copy(de, ve)) : S.prototype.set.call(
              de,
              Z,
              ve
            );
          else if (j.isBuffer(Z))
            Z.copy(de, ve);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          ve += Z.length;
        }
        return de;
      };
      function N(M, U) {
        if (j.isBuffer(M))
          return M.length;
        if (R.isView(M) || tr(M, R))
          return M.byteLength;
        if (typeof M != "string")
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof M
          );
        const K = M.length, de = arguments.length > 2 && arguments[2] === !0;
        if (!de && K === 0) return 0;
        let ve = !1;
        for (; ; )
          switch (U) {
            case "ascii":
            case "latin1":
            case "binary":
              return K;
            case "utf8":
            case "utf-8":
              return dt(M).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return K * 2;
            case "hex":
              return K >>> 1;
            case "base64":
              return zt(M).length;
            default:
              if (ve)
                return de ? -1 : dt(M).length;
              U = ("" + U).toLowerCase(), ve = !0;
          }
      }
      j.byteLength = N;
      function J(M, U, K) {
        let de = !1;
        if ((U === void 0 || U < 0) && (U = 0), U > this.length || ((K === void 0 || K > this.length) && (K = this.length), K <= 0) || (K >>>= 0, U >>>= 0, K <= U))
          return "";
        for (M || (M = "utf8"); ; )
          switch (M) {
            case "hex":
              return At(this, U, K);
            case "utf8":
            case "utf-8":
              return Fe(this, U, K);
            case "ascii":
              return tt(this, U, K);
            case "latin1":
            case "binary":
              return Pe(this, U, K);
            case "base64":
              return Re(this, U, K);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return er(this, U, K);
            default:
              if (de) throw new TypeError("Unknown encoding: " + M);
              M = (M + "").toLowerCase(), de = !0;
          }
      }
      j.prototype._isBuffer = !0;
      function re(M, U, K) {
        const de = M[U];
        M[U] = M[K], M[K] = de;
      }
      j.prototype.swap16 = function() {
        const M = this.length;
        if (M % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let U = 0; U < M; U += 2)
          re(this, U, U + 1);
        return this;
      }, j.prototype.swap32 = function() {
        const M = this.length;
        if (M % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let U = 0; U < M; U += 4)
          re(this, U, U + 3), re(this, U + 1, U + 2);
        return this;
      }, j.prototype.swap64 = function() {
        const M = this.length;
        if (M % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let U = 0; U < M; U += 8)
          re(this, U, U + 7), re(this, U + 1, U + 6), re(this, U + 2, U + 5), re(this, U + 3, U + 4);
        return this;
      }, j.prototype.toString = function() {
        const M = this.length;
        return M === 0 ? "" : arguments.length === 0 ? Fe(this, 0, M) : J.apply(this, arguments);
      }, j.prototype.toLocaleString = j.prototype.toString, j.prototype.equals = function(M) {
        if (!j.isBuffer(M)) throw new TypeError("Argument must be a Buffer");
        return this === M ? !0 : j.compare(this, M) === 0;
      }, j.prototype.inspect = function() {
        let M = "";
        const U = A.INSPECT_MAX_BYTES;
        return M = this.toString("hex", 0, U).replace(/(.{2})/g, "$1 ").trim(), this.length > U && (M += " ... "), "<Buffer " + M + ">";
      }, w && (j.prototype[w] = j.prototype.inspect), j.prototype.compare = function(M, U, K, de, ve) {
        if (tr(M, S) && (M = j.from(M, M.offset, M.byteLength)), !j.isBuffer(M))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof M
          );
        if (U === void 0 && (U = 0), K === void 0 && (K = M ? M.length : 0), de === void 0 && (de = 0), ve === void 0 && (ve = this.length), U < 0 || K > M.length || de < 0 || ve > this.length)
          throw new RangeError("out of range index");
        if (de >= ve && U >= K)
          return 0;
        if (de >= ve)
          return -1;
        if (U >= K)
          return 1;
        if (U >>>= 0, K >>>= 0, de >>>= 0, ve >>>= 0, this === M) return 0;
        let Z = ve - de, I = K - U;
        const B = Math.min(Z, I), q = this.slice(de, ve), G = M.slice(U, K);
        for (let Y = 0; Y < B; ++Y)
          if (q[Y] !== G[Y]) {
            Z = q[Y], I = G[Y];
            break;
          }
        return Z < I ? -1 : I < Z ? 1 : 0;
      };
      function oe(M, U, K, de, ve) {
        if (M.length === 0) return -1;
        if (typeof K == "string" ? (de = K, K = 0) : K > 2147483647 ? K = 2147483647 : K < -2147483648 && (K = -2147483648), K = +K, Nr(K) && (K = ve ? 0 : M.length - 1), K < 0 && (K = M.length + K), K >= M.length) {
          if (ve) return -1;
          K = M.length - 1;
        } else if (K < 0)
          if (ve) K = 0;
          else return -1;
        if (typeof U == "string" && (U = j.from(U, de)), j.isBuffer(U))
          return U.length === 0 ? -1 : ee(M, U, K, de, ve);
        if (typeof U == "number")
          return U = U & 255, typeof S.prototype.indexOf == "function" ? ve ? S.prototype.indexOf.call(M, U, K) : S.prototype.lastIndexOf.call(M, U, K) : ee(M, [U], K, de, ve);
        throw new TypeError("val must be string, number or Buffer");
      }
      function ee(M, U, K, de, ve) {
        let Z = 1, I = M.length, B = U.length;
        if (de !== void 0 && (de = String(de).toLowerCase(), de === "ucs2" || de === "ucs-2" || de === "utf16le" || de === "utf-16le")) {
          if (M.length < 2 || U.length < 2)
            return -1;
          Z = 2, I /= 2, B /= 2, K /= 2;
        }
        function q(Y, ie) {
          return Z === 1 ? Y[ie] : Y.readUInt16BE(ie * Z);
        }
        let G;
        if (ve) {
          let Y = -1;
          for (G = K; G < I; G++)
            if (q(M, G) === q(U, Y === -1 ? 0 : G - Y)) {
              if (Y === -1 && (Y = G), G - Y + 1 === B) return Y * Z;
            } else
              Y !== -1 && (G -= G - Y), Y = -1;
        } else
          for (K + B > I && (K = I - B), G = K; G >= 0; G--) {
            let Y = !0;
            for (let ie = 0; ie < B; ie++)
              if (q(M, G + ie) !== q(U, ie)) {
                Y = !1;
                break;
              }
            if (Y) return G;
          }
        return -1;
      }
      j.prototype.includes = function(M, U, K) {
        return this.indexOf(M, U, K) !== -1;
      }, j.prototype.indexOf = function(M, U, K) {
        return oe(this, M, U, K, !0);
      }, j.prototype.lastIndexOf = function(M, U, K) {
        return oe(this, M, U, K, !1);
      };
      function ae(M, U, K, de) {
        K = Number(K) || 0;
        const ve = M.length - K;
        de ? (de = Number(de), de > ve && (de = ve)) : de = ve;
        const Z = U.length;
        de > Z / 2 && (de = Z / 2);
        let I;
        for (I = 0; I < de; ++I) {
          const B = parseInt(U.substr(I * 2, 2), 16);
          if (Nr(B)) return I;
          M[K + I] = B;
        }
        return I;
      }
      function me(M, U, K, de) {
        return Xt(dt(U, M.length - K), M, K, de);
      }
      function H(M, U, K, de) {
        return Xt(St(U), M, K, de);
      }
      function X(M, U, K, de) {
        return Xt(zt(U), M, K, de);
      }
      function Ae(M, U, K, de) {
        return Xt(rt(U, M.length - K), M, K, de);
      }
      j.prototype.write = function(M, U, K, de) {
        if (U === void 0)
          de = "utf8", K = this.length, U = 0;
        else if (K === void 0 && typeof U == "string")
          de = U, K = this.length, U = 0;
        else if (isFinite(U))
          U = U >>> 0, isFinite(K) ? (K = K >>> 0, de === void 0 && (de = "utf8")) : (de = K, K = void 0);
        else
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        const ve = this.length - U;
        if ((K === void 0 || K > ve) && (K = ve), M.length > 0 && (K < 0 || U < 0) || U > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        de || (de = "utf8");
        let Z = !1;
        for (; ; )
          switch (de) {
            case "hex":
              return ae(this, M, U, K);
            case "utf8":
            case "utf-8":
              return me(this, M, U, K);
            case "ascii":
            case "latin1":
            case "binary":
              return H(this, M, U, K);
            case "base64":
              return X(this, M, U, K);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Ae(this, M, U, K);
            default:
              if (Z) throw new TypeError("Unknown encoding: " + de);
              de = ("" + de).toLowerCase(), Z = !0;
          }
      }, j.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function Re(M, U, K) {
        return U === 0 && K === M.length ? x.fromByteArray(M) : x.fromByteArray(M.slice(U, K));
      }
      function Fe(M, U, K) {
        K = Math.min(M.length, K);
        const de = [];
        let ve = U;
        for (; ve < K; ) {
          const Z = M[ve];
          let I = null, B = Z > 239 ? 4 : Z > 223 ? 3 : Z > 191 ? 2 : 1;
          if (ve + B <= K) {
            let q, G, Y, ie;
            switch (B) {
              case 1:
                Z < 128 && (I = Z);
                break;
              case 2:
                q = M[ve + 1], (q & 192) === 128 && (ie = (Z & 31) << 6 | q & 63, ie > 127 && (I = ie));
                break;
              case 3:
                q = M[ve + 1], G = M[ve + 2], (q & 192) === 128 && (G & 192) === 128 && (ie = (Z & 15) << 12 | (q & 63) << 6 | G & 63, ie > 2047 && (ie < 55296 || ie > 57343) && (I = ie));
                break;
              case 4:
                q = M[ve + 1], G = M[ve + 2], Y = M[ve + 3], (q & 192) === 128 && (G & 192) === 128 && (Y & 192) === 128 && (ie = (Z & 15) << 18 | (q & 63) << 12 | (G & 63) << 6 | Y & 63, ie > 65535 && ie < 1114112 && (I = ie));
            }
          }
          I === null ? (I = 65533, B = 1) : I > 65535 && (I -= 65536, de.push(I >>> 10 & 1023 | 55296), I = 56320 | I & 1023), de.push(I), ve += B;
        }
        return qe(de);
      }
      const Te = 4096;
      function qe(M) {
        const U = M.length;
        if (U <= Te)
          return String.fromCharCode.apply(String, M);
        let K = "", de = 0;
        for (; de < U; )
          K += String.fromCharCode.apply(
            String,
            M.slice(de, de += Te)
          );
        return K;
      }
      function tt(M, U, K) {
        let de = "";
        K = Math.min(M.length, K);
        for (let ve = U; ve < K; ++ve)
          de += String.fromCharCode(M[ve] & 127);
        return de;
      }
      function Pe(M, U, K) {
        let de = "";
        K = Math.min(M.length, K);
        for (let ve = U; ve < K; ++ve)
          de += String.fromCharCode(M[ve]);
        return de;
      }
      function At(M, U, K) {
        const de = M.length;
        (!U || U < 0) && (U = 0), (!K || K < 0 || K > de) && (K = de);
        let ve = "";
        for (let Z = U; Z < K; ++Z)
          ve += Ai[M[Z]];
        return ve;
      }
      function er(M, U, K) {
        const de = M.slice(U, K);
        let ve = "";
        for (let Z = 0; Z < de.length - 1; Z += 2)
          ve += String.fromCharCode(de[Z] + de[Z + 1] * 256);
        return ve;
      }
      j.prototype.slice = function(M, U) {
        const K = this.length;
        M = ~~M, U = U === void 0 ? K : ~~U, M < 0 ? (M += K, M < 0 && (M = 0)) : M > K && (M = K), U < 0 ? (U += K, U < 0 && (U = 0)) : U > K && (U = K), U < M && (U = M);
        const de = this.subarray(M, U);
        return Object.setPrototypeOf(de, j.prototype), de;
      };
      function ge(M, U, K) {
        if (M % 1 !== 0 || M < 0) throw new RangeError("offset is not uint");
        if (M + U > K) throw new RangeError("Trying to access beyond buffer length");
      }
      j.prototype.readUintLE = j.prototype.readUIntLE = function(M, U, K) {
        M = M >>> 0, U = U >>> 0, K || ge(M, U, this.length);
        let de = this[M], ve = 1, Z = 0;
        for (; ++Z < U && (ve *= 256); )
          de += this[M + Z] * ve;
        return de;
      }, j.prototype.readUintBE = j.prototype.readUIntBE = function(M, U, K) {
        M = M >>> 0, U = U >>> 0, K || ge(M, U, this.length);
        let de = this[M + --U], ve = 1;
        for (; U > 0 && (ve *= 256); )
          de += this[M + --U] * ve;
        return de;
      }, j.prototype.readUint8 = j.prototype.readUInt8 = function(M, U) {
        return M = M >>> 0, U || ge(M, 1, this.length), this[M];
      }, j.prototype.readUint16LE = j.prototype.readUInt16LE = function(M, U) {
        return M = M >>> 0, U || ge(M, 2, this.length), this[M] | this[M + 1] << 8;
      }, j.prototype.readUint16BE = j.prototype.readUInt16BE = function(M, U) {
        return M = M >>> 0, U || ge(M, 2, this.length), this[M] << 8 | this[M + 1];
      }, j.prototype.readUint32LE = j.prototype.readUInt32LE = function(M, U) {
        return M = M >>> 0, U || ge(M, 4, this.length), (this[M] | this[M + 1] << 8 | this[M + 2] << 16) + this[M + 3] * 16777216;
      }, j.prototype.readUint32BE = j.prototype.readUInt32BE = function(M, U) {
        return M = M >>> 0, U || ge(M, 4, this.length), this[M] * 16777216 + (this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3]);
      }, j.prototype.readBigUInt64LE = Zt(function(M) {
        M = M >>> 0, pe(M, "offset");
        const U = this[M], K = this[M + 7];
        (U === void 0 || K === void 0) && Se(M, this.length - 8);
        const de = U + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + this[++M] * 2 ** 24, ve = this[++M] + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + K * 2 ** 24;
        return BigInt(de) + (BigInt(ve) << BigInt(32));
      }), j.prototype.readBigUInt64BE = Zt(function(M) {
        M = M >>> 0, pe(M, "offset");
        const U = this[M], K = this[M + 7];
        (U === void 0 || K === void 0) && Se(M, this.length - 8);
        const de = U * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + this[++M], ve = this[++M] * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + K;
        return (BigInt(de) << BigInt(32)) + BigInt(ve);
      }), j.prototype.readIntLE = function(M, U, K) {
        M = M >>> 0, U = U >>> 0, K || ge(M, U, this.length);
        let de = this[M], ve = 1, Z = 0;
        for (; ++Z < U && (ve *= 256); )
          de += this[M + Z] * ve;
        return ve *= 128, de >= ve && (de -= Math.pow(2, 8 * U)), de;
      }, j.prototype.readIntBE = function(M, U, K) {
        M = M >>> 0, U = U >>> 0, K || ge(M, U, this.length);
        let de = U, ve = 1, Z = this[M + --de];
        for (; de > 0 && (ve *= 256); )
          Z += this[M + --de] * ve;
        return ve *= 128, Z >= ve && (Z -= Math.pow(2, 8 * U)), Z;
      }, j.prototype.readInt8 = function(M, U) {
        return M = M >>> 0, U || ge(M, 1, this.length), this[M] & 128 ? (255 - this[M] + 1) * -1 : this[M];
      }, j.prototype.readInt16LE = function(M, U) {
        M = M >>> 0, U || ge(M, 2, this.length);
        const K = this[M] | this[M + 1] << 8;
        return K & 32768 ? K | 4294901760 : K;
      }, j.prototype.readInt16BE = function(M, U) {
        M = M >>> 0, U || ge(M, 2, this.length);
        const K = this[M + 1] | this[M] << 8;
        return K & 32768 ? K | 4294901760 : K;
      }, j.prototype.readInt32LE = function(M, U) {
        return M = M >>> 0, U || ge(M, 4, this.length), this[M] | this[M + 1] << 8 | this[M + 2] << 16 | this[M + 3] << 24;
      }, j.prototype.readInt32BE = function(M, U) {
        return M = M >>> 0, U || ge(M, 4, this.length), this[M] << 24 | this[M + 1] << 16 | this[M + 2] << 8 | this[M + 3];
      }, j.prototype.readBigInt64LE = Zt(function(M) {
        M = M >>> 0, pe(M, "offset");
        const U = this[M], K = this[M + 7];
        (U === void 0 || K === void 0) && Se(M, this.length - 8);
        const de = this[M + 4] + this[M + 5] * 2 ** 8 + this[M + 6] * 2 ** 16 + (K << 24);
        return (BigInt(de) << BigInt(32)) + BigInt(U + this[++M] * 2 ** 8 + this[++M] * 2 ** 16 + this[++M] * 2 ** 24);
      }), j.prototype.readBigInt64BE = Zt(function(M) {
        M = M >>> 0, pe(M, "offset");
        const U = this[M], K = this[M + 7];
        (U === void 0 || K === void 0) && Se(M, this.length - 8);
        const de = (U << 24) + // Overflow
        this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + this[++M];
        return (BigInt(de) << BigInt(32)) + BigInt(this[++M] * 2 ** 24 + this[++M] * 2 ** 16 + this[++M] * 2 ** 8 + K);
      }), j.prototype.readFloatLE = function(M, U) {
        return M = M >>> 0, U || ge(M, 4, this.length), g.read(this, M, !0, 23, 4);
      }, j.prototype.readFloatBE = function(M, U) {
        return M = M >>> 0, U || ge(M, 4, this.length), g.read(this, M, !1, 23, 4);
      }, j.prototype.readDoubleLE = function(M, U) {
        return M = M >>> 0, U || ge(M, 8, this.length), g.read(this, M, !0, 52, 8);
      }, j.prototype.readDoubleBE = function(M, U) {
        return M = M >>> 0, U || ge(M, 8, this.length), g.read(this, M, !1, 52, 8);
      };
      function ht(M, U, K, de, ve, Z) {
        if (!j.isBuffer(M)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (U > ve || U < Z) throw new RangeError('"value" argument is out of bounds');
        if (K + de > M.length) throw new RangeError("Index out of range");
      }
      j.prototype.writeUintLE = j.prototype.writeUIntLE = function(M, U, K, de) {
        if (M = +M, U = U >>> 0, K = K >>> 0, !de) {
          const I = Math.pow(2, 8 * K) - 1;
          ht(this, M, U, K, I, 0);
        }
        let ve = 1, Z = 0;
        for (this[U] = M & 255; ++Z < K && (ve *= 256); )
          this[U + Z] = M / ve & 255;
        return U + K;
      }, j.prototype.writeUintBE = j.prototype.writeUIntBE = function(M, U, K, de) {
        if (M = +M, U = U >>> 0, K = K >>> 0, !de) {
          const I = Math.pow(2, 8 * K) - 1;
          ht(this, M, U, K, I, 0);
        }
        let ve = K - 1, Z = 1;
        for (this[U + ve] = M & 255; --ve >= 0 && (Z *= 256); )
          this[U + ve] = M / Z & 255;
        return U + K;
      }, j.prototype.writeUint8 = j.prototype.writeUInt8 = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 1, 255, 0), this[U] = M & 255, U + 1;
      }, j.prototype.writeUint16LE = j.prototype.writeUInt16LE = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 2, 65535, 0), this[U] = M & 255, this[U + 1] = M >>> 8, U + 2;
      }, j.prototype.writeUint16BE = j.prototype.writeUInt16BE = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 2, 65535, 0), this[U] = M >>> 8, this[U + 1] = M & 255, U + 2;
      }, j.prototype.writeUint32LE = j.prototype.writeUInt32LE = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 4, 4294967295, 0), this[U + 3] = M >>> 24, this[U + 2] = M >>> 16, this[U + 1] = M >>> 8, this[U] = M & 255, U + 4;
      }, j.prototype.writeUint32BE = j.prototype.writeUInt32BE = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 4, 4294967295, 0), this[U] = M >>> 24, this[U + 1] = M >>> 16, this[U + 2] = M >>> 8, this[U + 3] = M & 255, U + 4;
      };
      function it(M, U, K, de, ve) {
        se(U, de, ve, M, K, 7);
        let Z = Number(U & BigInt(4294967295));
        M[K++] = Z, Z = Z >> 8, M[K++] = Z, Z = Z >> 8, M[K++] = Z, Z = Z >> 8, M[K++] = Z;
        let I = Number(U >> BigInt(32) & BigInt(4294967295));
        return M[K++] = I, I = I >> 8, M[K++] = I, I = I >> 8, M[K++] = I, I = I >> 8, M[K++] = I, K;
      }
      function kt(M, U, K, de, ve) {
        se(U, de, ve, M, K, 7);
        let Z = Number(U & BigInt(4294967295));
        M[K + 7] = Z, Z = Z >> 8, M[K + 6] = Z, Z = Z >> 8, M[K + 5] = Z, Z = Z >> 8, M[K + 4] = Z;
        let I = Number(U >> BigInt(32) & BigInt(4294967295));
        return M[K + 3] = I, I = I >> 8, M[K + 2] = I, I = I >> 8, M[K + 1] = I, I = I >> 8, M[K] = I, K + 8;
      }
      j.prototype.writeBigUInt64LE = Zt(function(M, U = 0) {
        return it(this, M, U, BigInt(0), BigInt("0xffffffffffffffff"));
      }), j.prototype.writeBigUInt64BE = Zt(function(M, U = 0) {
        return kt(this, M, U, BigInt(0), BigInt("0xffffffffffffffff"));
      }), j.prototype.writeIntLE = function(M, U, K, de) {
        if (M = +M, U = U >>> 0, !de) {
          const B = Math.pow(2, 8 * K - 1);
          ht(this, M, U, K, B - 1, -B);
        }
        let ve = 0, Z = 1, I = 0;
        for (this[U] = M & 255; ++ve < K && (Z *= 256); )
          M < 0 && I === 0 && this[U + ve - 1] !== 0 && (I = 1), this[U + ve] = (M / Z >> 0) - I & 255;
        return U + K;
      }, j.prototype.writeIntBE = function(M, U, K, de) {
        if (M = +M, U = U >>> 0, !de) {
          const B = Math.pow(2, 8 * K - 1);
          ht(this, M, U, K, B - 1, -B);
        }
        let ve = K - 1, Z = 1, I = 0;
        for (this[U + ve] = M & 255; --ve >= 0 && (Z *= 256); )
          M < 0 && I === 0 && this[U + ve + 1] !== 0 && (I = 1), this[U + ve] = (M / Z >> 0) - I & 255;
        return U + K;
      }, j.prototype.writeInt8 = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 1, 127, -128), M < 0 && (M = 255 + M + 1), this[U] = M & 255, U + 1;
      }, j.prototype.writeInt16LE = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 2, 32767, -32768), this[U] = M & 255, this[U + 1] = M >>> 8, U + 2;
      }, j.prototype.writeInt16BE = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 2, 32767, -32768), this[U] = M >>> 8, this[U + 1] = M & 255, U + 2;
      }, j.prototype.writeInt32LE = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 4, 2147483647, -2147483648), this[U] = M & 255, this[U + 1] = M >>> 8, this[U + 2] = M >>> 16, this[U + 3] = M >>> 24, U + 4;
      }, j.prototype.writeInt32BE = function(M, U, K) {
        return M = +M, U = U >>> 0, K || ht(this, M, U, 4, 2147483647, -2147483648), M < 0 && (M = 4294967295 + M + 1), this[U] = M >>> 24, this[U + 1] = M >>> 16, this[U + 2] = M >>> 8, this[U + 3] = M & 255, U + 4;
      }, j.prototype.writeBigInt64LE = Zt(function(M, U = 0) {
        return it(this, M, U, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), j.prototype.writeBigInt64BE = Zt(function(M, U = 0) {
        return kt(this, M, U, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function Ze(M, U, K, de, ve, Z) {
        if (K + de > M.length) throw new RangeError("Index out of range");
        if (K < 0) throw new RangeError("Index out of range");
      }
      function fe(M, U, K, de, ve) {
        return U = +U, K = K >>> 0, ve || Ze(M, U, K, 4), g.write(M, U, K, de, 23, 4), K + 4;
      }
      j.prototype.writeFloatLE = function(M, U, K) {
        return fe(this, M, U, !0, K);
      }, j.prototype.writeFloatBE = function(M, U, K) {
        return fe(this, M, U, !1, K);
      };
      function ye(M, U, K, de, ve) {
        return U = +U, K = K >>> 0, ve || Ze(M, U, K, 8), g.write(M, U, K, de, 52, 8), K + 8;
      }
      j.prototype.writeDoubleLE = function(M, U, K) {
        return ye(this, M, U, !0, K);
      }, j.prototype.writeDoubleBE = function(M, U, K) {
        return ye(this, M, U, !1, K);
      }, j.prototype.copy = function(M, U, K, de) {
        if (!j.isBuffer(M)) throw new TypeError("argument should be a Buffer");
        if (K || (K = 0), !de && de !== 0 && (de = this.length), U >= M.length && (U = M.length), U || (U = 0), de > 0 && de < K && (de = K), de === K || M.length === 0 || this.length === 0) return 0;
        if (U < 0)
          throw new RangeError("targetStart out of bounds");
        if (K < 0 || K >= this.length) throw new RangeError("Index out of range");
        if (de < 0) throw new RangeError("sourceEnd out of bounds");
        de > this.length && (de = this.length), M.length - U < de - K && (de = M.length - U + K);
        const ve = de - K;
        return this === M && typeof S.prototype.copyWithin == "function" ? this.copyWithin(U, K, de) : S.prototype.set.call(
          M,
          this.subarray(K, de),
          U
        ), ve;
      }, j.prototype.fill = function(M, U, K, de) {
        if (typeof M == "string") {
          if (typeof U == "string" ? (de = U, U = 0, K = this.length) : typeof K == "string" && (de = K, K = this.length), de !== void 0 && typeof de != "string")
            throw new TypeError("encoding must be a string");
          if (typeof de == "string" && !j.isEncoding(de))
            throw new TypeError("Unknown encoding: " + de);
          if (M.length === 1) {
            const Z = M.charCodeAt(0);
            (de === "utf8" && Z < 128 || de === "latin1") && (M = Z);
          }
        } else typeof M == "number" ? M = M & 255 : typeof M == "boolean" && (M = Number(M));
        if (U < 0 || this.length < U || this.length < K)
          throw new RangeError("Out of range index");
        if (K <= U)
          return this;
        U = U >>> 0, K = K === void 0 ? this.length : K >>> 0, M || (M = 0);
        let ve;
        if (typeof M == "number")
          for (ve = U; ve < K; ++ve)
            this[ve] = M;
        else {
          const Z = j.isBuffer(M) ? M : j.from(M, de), I = Z.length;
          if (I === 0)
            throw new TypeError('The value "' + M + '" is invalid for argument "value"');
          for (ve = 0; ve < K - U; ++ve)
            this[ve + U] = Z[ve % I];
        }
        return this;
      };
      const Je = {};
      function C(M, U, K) {
        Je[M] = class extends K {
          constructor() {
            super(), Object.defineProperty(this, "message", {
              value: U.apply(this, arguments),
              writable: !0,
              configurable: !0
            }), this.name = `${this.name} [${M}]`, this.stack, delete this.name;
          }
          get code() {
            return M;
          }
          set code(de) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: de,
              writable: !0
            });
          }
          toString() {
            return `${this.name} [${M}]: ${this.message}`;
          }
        };
      }
      C(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(M) {
          return M ? `${M} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ), C(
        "ERR_INVALID_ARG_TYPE",
        function(M, U) {
          return `The "${M}" argument must be of type number. Received type ${typeof U}`;
        },
        TypeError
      ), C(
        "ERR_OUT_OF_RANGE",
        function(M, U, K) {
          let de = `The value of "${M}" is out of range.`, ve = K;
          return Number.isInteger(K) && Math.abs(K) > 2 ** 32 ? ve = $(String(K)) : typeof K == "bigint" && (ve = String(K), (K > BigInt(2) ** BigInt(32) || K < -(BigInt(2) ** BigInt(32))) && (ve = $(ve)), ve += "n"), de += ` It must be ${U}. Received ${ve}`, de;
        },
        RangeError
      );
      function $(M) {
        let U = "", K = M.length;
        const de = M[0] === "-" ? 1 : 0;
        for (; K >= de + 4; K -= 3)
          U = `_${M.slice(K - 3, K)}${U}`;
        return `${M.slice(0, K)}${U}`;
      }
      function D(M, U, K) {
        pe(U, "offset"), (M[U] === void 0 || M[U + K] === void 0) && Se(U, M.length - (K + 1));
      }
      function se(M, U, K, de, ve, Z) {
        if (M > K || M < U) {
          const I = typeof U == "bigint" ? "n" : "";
          let B;
          throw U === 0 || U === BigInt(0) ? B = `>= 0${I} and < 2${I} ** ${(Z + 1) * 8}${I}` : B = `>= -(2${I} ** ${(Z + 1) * 8 - 1}${I}) and < 2 ** ${(Z + 1) * 8 - 1}${I}`, new Je.ERR_OUT_OF_RANGE("value", B, M);
        }
        D(de, ve, Z);
      }
      function pe(M, U) {
        if (typeof M != "number")
          throw new Je.ERR_INVALID_ARG_TYPE(U, "number", M);
      }
      function Se(M, U, K) {
        throw Math.floor(M) !== M ? (pe(M, K), new Je.ERR_OUT_OF_RANGE("offset", "an integer", M)) : U < 0 ? new Je.ERR_BUFFER_OUT_OF_BOUNDS() : new Je.ERR_OUT_OF_RANGE(
          "offset",
          `>= 0 and <= ${U}`,
          M
        );
      }
      const Le = /[^+/0-9A-Za-z-_]/g;
      function ot(M) {
        if (M = M.split("=")[0], M = M.trim().replace(Le, ""), M.length < 2) return "";
        for (; M.length % 4 !== 0; )
          M = M + "=";
        return M;
      }
      function dt(M, U) {
        U = U || 1 / 0;
        let K;
        const de = M.length;
        let ve = null;
        const Z = [];
        for (let I = 0; I < de; ++I) {
          if (K = M.charCodeAt(I), K > 55295 && K < 57344) {
            if (!ve) {
              if (K > 56319) {
                (U -= 3) > -1 && Z.push(239, 191, 189);
                continue;
              } else if (I + 1 === de) {
                (U -= 3) > -1 && Z.push(239, 191, 189);
                continue;
              }
              ve = K;
              continue;
            }
            if (K < 56320) {
              (U -= 3) > -1 && Z.push(239, 191, 189), ve = K;
              continue;
            }
            K = (ve - 55296 << 10 | K - 56320) + 65536;
          } else ve && (U -= 3) > -1 && Z.push(239, 191, 189);
          if (ve = null, K < 128) {
            if ((U -= 1) < 0) break;
            Z.push(K);
          } else if (K < 2048) {
            if ((U -= 2) < 0) break;
            Z.push(
              K >> 6 | 192,
              K & 63 | 128
            );
          } else if (K < 65536) {
            if ((U -= 3) < 0) break;
            Z.push(
              K >> 12 | 224,
              K >> 6 & 63 | 128,
              K & 63 | 128
            );
          } else if (K < 1114112) {
            if ((U -= 4) < 0) break;
            Z.push(
              K >> 18 | 240,
              K >> 12 & 63 | 128,
              K >> 6 & 63 | 128,
              K & 63 | 128
            );
          } else
            throw new Error("Invalid code point");
        }
        return Z;
      }
      function St(M) {
        const U = [];
        for (let K = 0; K < M.length; ++K)
          U.push(M.charCodeAt(K) & 255);
        return U;
      }
      function rt(M, U) {
        let K, de, ve;
        const Z = [];
        for (let I = 0; I < M.length && !((U -= 2) < 0); ++I)
          K = M.charCodeAt(I), de = K >> 8, ve = K % 256, Z.push(ve), Z.push(de);
        return Z;
      }
      function zt(M) {
        return x.toByteArray(ot(M));
      }
      function Xt(M, U, K, de) {
        let ve;
        for (ve = 0; ve < de && !(ve + K >= U.length || ve >= M.length); ++ve)
          U[ve + K] = M[ve];
        return ve;
      }
      function tr(M, U) {
        return M instanceof U || M != null && M.constructor != null && M.constructor.name != null && M.constructor.name === U.name;
      }
      function Nr(M) {
        return M !== M;
      }
      const Ai = function() {
        const M = "0123456789abcdef", U = new Array(256);
        for (let K = 0; K < 16; ++K) {
          const de = K * 16;
          for (let ve = 0; ve < 16; ++ve)
            U[de + ve] = M[K] + M[ve];
        }
        return U;
      }();
      function Zt(M) {
        return typeof BigInt > "u" ? Un : M;
      }
      function Un() {
        throw new Error("BigInt not supported");
      }
    })(e);
    const E = e.Buffer;
    t.Blob = e.Blob, t.BlobOptions = e.BlobOptions, t.Buffer = e.Buffer, t.File = e.File, t.FileOptions = e.FileOptions, t.INSPECT_MAX_BYTES = e.INSPECT_MAX_BYTES, t.SlowBuffer = e.SlowBuffer, t.TranscodeEncoding = e.TranscodeEncoding, t.atob = e.atob, t.btoa = e.btoa, t.constants = e.constants, t.default = E, t.isAscii = e.isAscii, t.isUtf8 = e.isUtf8, t.kMaxLength = e.kMaxLength, t.kStringMaxLength = e.kStringMaxLength, t.resolveObjectURL = e.resolveObjectURL, t.transcode = e.transcode;
  }(O_)), O_;
}
var L_ = {}, M_ = {}, N_, D_;
function ej() {
  return D_ || (D_ = 1, N_ = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, e = Symbol("test"), r = Object(e);
    if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
      return !1;
    var n = 42;
    t[e] = n;
    for (var i in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var s = Object.getOwnPropertySymbols(t);
    if (s.length !== 1 || s[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, e)
      );
      if (o.value !== n || o.enumerable !== !0)
        return !1;
    }
    return !0;
  }), N_;
}
var Bw, $_;
function Mv() {
  if ($_) return Bw;
  $_ = 1;
  var t = ej();
  return Bw = function() {
    return t() && !!Symbol.toStringTag;
  }, Bw;
}
var j_, B_;
function tj() {
  return B_ || (B_ = 1, j_ = Object), j_;
}
var F_, z_;
function bye() {
  return z_ || (z_ = 1, F_ = Error), F_;
}
var U_, V_;
function wye() {
  return V_ || (V_ = 1, U_ = EvalError), U_;
}
var H_, G_;
function xye() {
  return G_ || (G_ = 1, H_ = RangeError), H_;
}
var W_, q_;
function Eye() {
  return q_ || (q_ = 1, W_ = ReferenceError), W_;
}
var Q_, K_;
function rj() {
  return K_ || (K_ = 1, Q_ = SyntaxError), Q_;
}
var Y_, Z_;
function Fg() {
  return Z_ || (Z_ = 1, Y_ = TypeError), Y_;
}
var J_, X_;
function Sye() {
  return X_ || (X_ = 1, J_ = URIError), J_;
}
var eC, tC;
function Aye() {
  return tC || (tC = 1, eC = Math.abs), eC;
}
var rC, nC;
function kye() {
  return nC || (nC = 1, rC = Math.floor), rC;
}
var iC, sC;
function _ye() {
  return sC || (sC = 1, iC = Math.max), iC;
}
var oC, aC;
function Cye() {
  return aC || (aC = 1, oC = Math.min), oC;
}
var lC, cC;
function Iye() {
  return cC || (cC = 1, lC = Math.pow), lC;
}
var uC, hC;
function Pye() {
  return hC || (hC = 1, uC = Math.round), uC;
}
var pC, dC;
function Rye() {
  return dC || (dC = 1, pC = Number.isNaN || function(t) {
    return t !== t;
  }), pC;
}
var Fw, fC;
function Oye() {
  if (fC) return Fw;
  fC = 1;
  var t = /* @__PURE__ */ Rye();
  return Fw = function(e) {
    return t(e) || e === 0 ? e : e < 0 ? -1 : 1;
  }, Fw;
}
var gC, mC;
function Tye() {
  return mC || (mC = 1, gC = Object.getOwnPropertyDescriptor), gC;
}
var zw, yC;
function Nd() {
  if (yC) return zw;
  yC = 1;
  var t = /* @__PURE__ */ Tye();
  if (t)
    try {
      t([], "length");
    } catch {
      t = null;
    }
  return zw = t, zw;
}
var Uw, vC;
function Nv() {
  if (vC) return Uw;
  vC = 1;
  var t = Object.defineProperty || !1;
  if (t)
    try {
      t({}, "a", { value: 1 });
    } catch {
      t = !1;
    }
  return Uw = t, Uw;
}
var Vw, bC;
function Lye() {
  if (bC) return Vw;
  bC = 1;
  var t = typeof Symbol < "u" && Symbol, e = ej();
  return Vw = function() {
    return typeof t != "function" || typeof Symbol != "function" || typeof t("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e();
  }, Vw;
}
var wC, xC;
function nj() {
  return xC || (xC = 1, wC = typeof Reflect < "u" && Reflect.getPrototypeOf || null), wC;
}
var Hw, EC;
function ij() {
  if (EC) return Hw;
  EC = 1;
  var t = /* @__PURE__ */ tj();
  return Hw = t.getPrototypeOf || null, Hw;
}
var Gw, SC;
function Mye() {
  if (SC) return Gw;
  SC = 1;
  var t = "Function.prototype.bind called on incompatible ", e = Object.prototype.toString, r = Math.max, n = "[object Function]", i = function(a, l) {
    for (var c = [], p = 0; p < a.length; p += 1)
      c[p] = a[p];
    for (var h = 0; h < l.length; h += 1)
      c[h + a.length] = l[h];
    return c;
  }, s = function(a, l) {
    for (var c = [], p = l, h = 0; p < a.length; p += 1, h += 1)
      c[h] = a[p];
    return c;
  }, o = function(a, l) {
    for (var c = "", p = 0; p < a.length; p += 1)
      c += a[p], p + 1 < a.length && (c += l);
    return c;
  };
  return Gw = function(a) {
    var l = this;
    if (typeof l != "function" || e.apply(l) !== n)
      throw new TypeError(t + l);
    for (var c = s(arguments, 1), p, h = function() {
      if (this instanceof p) {
        var f = l.apply(
          this,
          i(c, arguments)
        );
        return Object(f) === f ? f : this;
      }
      return l.apply(
        a,
        i(c, arguments)
      );
    }, d = r(0, l.length - c.length), v = [], m = 0; m < d; m++)
      v[m] = "$" + m;
    if (p = Function("binder", "return function (" + o(v, ",") + "){ return binder.apply(this,arguments); }")(h), l.prototype) {
      var b = function() {
      };
      b.prototype = l.prototype, p.prototype = new b(), b.prototype = null;
    }
    return p;
  }, Gw;
}
var Ww, AC;
function zg() {
  if (AC) return Ww;
  AC = 1;
  var t = Mye();
  return Ww = Function.prototype.bind || t, Ww;
}
var kC, _C;
function gS() {
  return _C || (_C = 1, kC = Function.prototype.call), kC;
}
var CC, IC;
function mS() {
  return IC || (IC = 1, CC = Function.prototype.apply), CC;
}
var PC, RC;
function Nye() {
  return RC || (RC = 1, PC = typeof Reflect < "u" && Reflect && Reflect.apply), PC;
}
var qw, OC;
function sj() {
  if (OC) return qw;
  OC = 1;
  var t = zg(), e = mS(), r = gS(), n = Nye();
  return qw = n || t.call(r, e), qw;
}
var Qw, TC;
function yS() {
  if (TC) return Qw;
  TC = 1;
  var t = zg(), e = /* @__PURE__ */ Fg(), r = gS(), n = sj();
  return Qw = function(i) {
    if (i.length < 1 || typeof i[0] != "function")
      throw new e("a function is required");
    return n(t, r, i);
  }, Qw;
}
var Kw, LC;
function Dye() {
  if (LC) return Kw;
  LC = 1;
  var t = yS(), e = /* @__PURE__ */ Nd(), r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var n = !!r && e && e(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, s = i.getPrototypeOf;
  return Kw = n && typeof n.get == "function" ? t([n.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(o) {
      return s(o == null ? o : i(o));
    }
  ) : !1, Kw;
}
var Yw, MC;
function oj() {
  if (MC) return Yw;
  MC = 1;
  var t = nj(), e = ij(), r = /* @__PURE__ */ Dye();
  return Yw = t ? function(n) {
    return t(n);
  } : e ? function(n) {
    if (!n || typeof n != "object" && typeof n != "function")
      throw new TypeError("getProto: not an object");
    return e(n);
  } : r ? function(n) {
    return r(n);
  } : null, Yw;
}
var Zw, NC;
function aj() {
  if (NC) return Zw;
  NC = 1;
  var t = Function.prototype.call, e = Object.prototype.hasOwnProperty, r = zg();
  return Zw = r.call(t, e), Zw;
}
var Jw, DC;
function lj() {
  if (DC) return Jw;
  DC = 1;
  var t, e = /* @__PURE__ */ tj(), r = /* @__PURE__ */ bye(), n = /* @__PURE__ */ wye(), i = /* @__PURE__ */ xye(), s = /* @__PURE__ */ Eye(), o = /* @__PURE__ */ rj(), a = /* @__PURE__ */ Fg(), l = /* @__PURE__ */ Sye(), c = /* @__PURE__ */ Aye(), p = /* @__PURE__ */ kye(), h = /* @__PURE__ */ _ye(), d = /* @__PURE__ */ Cye(), v = /* @__PURE__ */ Iye(), m = /* @__PURE__ */ Pye(), b = /* @__PURE__ */ Oye(), f = Function, E = function(ae) {
    try {
      return f('"use strict"; return (' + ae + ").constructor;")();
    } catch {
    }
  }, A = /* @__PURE__ */ Nd(), x = /* @__PURE__ */ Nv(), g = function() {
    throw new a();
  }, w = A ? function() {
    try {
      return arguments.callee, g;
    } catch {
      try {
        return A(arguments, "callee").get;
      } catch {
        return g;
      }
    }
  }() : g, _ = Lye()(), S = oj(), R = ij(), L = nj(), F = mS(), z = gS(), j = {}, W = typeof Uint8Array > "u" || !S ? t : S(Uint8Array), te = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? t : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? t : ArrayBuffer,
    "%ArrayIteratorPrototype%": _ && S ? S([][Symbol.iterator]()) : t,
    "%AsyncFromSyncIteratorPrototype%": t,
    "%AsyncFunction%": j,
    "%AsyncGenerator%": j,
    "%AsyncGeneratorFunction%": j,
    "%AsyncIteratorPrototype%": j,
    "%Atomics%": typeof Atomics > "u" ? t : Atomics,
    "%BigInt%": typeof BigInt > "u" ? t : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? t : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? t : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? t : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": r,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": n,
    "%Float32Array%": typeof Float32Array > "u" ? t : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? t : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? t : FinalizationRegistry,
    "%Function%": f,
    "%GeneratorFunction%": j,
    "%Int8Array%": typeof Int8Array > "u" ? t : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? t : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? t : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": _ && S ? S(S([][Symbol.iterator]())) : t,
    "%JSON%": typeof JSON == "object" ? JSON : t,
    "%Map%": typeof Map > "u" ? t : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !_ || !S ? t : S((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": e,
    "%Object.getOwnPropertyDescriptor%": A,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? t : Promise,
    "%Proxy%": typeof Proxy > "u" ? t : Proxy,
    "%RangeError%": i,
    "%ReferenceError%": s,
    "%Reflect%": typeof Reflect > "u" ? t : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? t : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !_ || !S ? t : S((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? t : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": _ && S ? S(""[Symbol.iterator]()) : t,
    "%Symbol%": _ ? Symbol : t,
    "%SyntaxError%": o,
    "%ThrowTypeError%": w,
    "%TypedArray%": W,
    "%TypeError%": a,
    "%Uint8Array%": typeof Uint8Array > "u" ? t : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? t : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? t : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? t : Uint32Array,
    "%URIError%": l,
    "%WeakMap%": typeof WeakMap > "u" ? t : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? t : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? t : WeakSet,
    "%Function.prototype.call%": z,
    "%Function.prototype.apply%": F,
    "%Object.defineProperty%": x,
    "%Object.getPrototypeOf%": R,
    "%Math.abs%": c,
    "%Math.floor%": p,
    "%Math.max%": h,
    "%Math.min%": d,
    "%Math.pow%": v,
    "%Math.round%": m,
    "%Math.sign%": b,
    "%Reflect.getPrototypeOf%": L
  };
  if (S)
    try {
      null.error;
    } catch (ae) {
      var le = S(S(ae));
      te["%Error.prototype%"] = le;
    }
  var ce = function ae(me) {
    var H;
    if (me === "%AsyncFunction%")
      H = E("async function () {}");
    else if (me === "%GeneratorFunction%")
      H = E("function* () {}");
    else if (me === "%AsyncGeneratorFunction%")
      H = E("async function* () {}");
    else if (me === "%AsyncGenerator%") {
      var X = ae("%AsyncGeneratorFunction%");
      X && (H = X.prototype);
    } else if (me === "%AsyncIteratorPrototype%") {
      var Ae = ae("%AsyncGenerator%");
      Ae && S && (H = S(Ae.prototype));
    }
    return te[me] = H, H;
  }, Ee = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, xe = zg(), _e = /* @__PURE__ */ aj(), Ie = xe.call(z, Array.prototype.concat), je = xe.call(F, Array.prototype.splice), ue = xe.call(z, String.prototype.replace), O = xe.call(z, String.prototype.slice), N = xe.call(z, RegExp.prototype.exec), J = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, re = /\\(\\)?/g, oe = function(ae) {
    var me = O(ae, 0, 1), H = O(ae, -1);
    if (me === "%" && H !== "%")
      throw new o("invalid intrinsic syntax, expected closing `%`");
    if (H === "%" && me !== "%")
      throw new o("invalid intrinsic syntax, expected opening `%`");
    var X = [];
    return ue(ae, J, function(Ae, Re, Fe, Te) {
      X[X.length] = Fe ? ue(Te, re, "$1") : Re || Ae;
    }), X;
  }, ee = function(ae, me) {
    var H = ae, X;
    if (_e(Ee, H) && (X = Ee[H], H = "%" + X[0] + "%"), _e(te, H)) {
      var Ae = te[H];
      if (Ae === j && (Ae = ce(H)), typeof Ae > "u" && !me)
        throw new a("intrinsic " + ae + " exists, but is not available. Please file an issue!");
      return {
        alias: X,
        name: H,
        value: Ae
      };
    }
    throw new o("intrinsic " + ae + " does not exist!");
  };
  return Jw = function(ae, me) {
    if (typeof ae != "string" || ae.length === 0)
      throw new a("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof me != "boolean")
      throw new a('"allowMissing" argument must be a boolean');
    if (N(/^%?[^%]*%?$/, ae) === null)
      throw new o("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var H = oe(ae), X = H.length > 0 ? H[0] : "", Ae = ee("%" + X + "%", me), Re = Ae.name, Fe = Ae.value, Te = !1, qe = Ae.alias;
    qe && (X = qe[0], je(H, Ie([0, 1], qe)));
    for (var tt = 1, Pe = !0; tt < H.length; tt += 1) {
      var At = H[tt], er = O(At, 0, 1), ge = O(At, -1);
      if ((er === '"' || er === "'" || er === "`" || ge === '"' || ge === "'" || ge === "`") && er !== ge)
        throw new o("property names with quotes must have matching quotes");
      if ((At === "constructor" || !Pe) && (Te = !0), X += "." + At, Re = "%" + X + "%", _e(te, Re))
        Fe = te[Re];
      else if (Fe != null) {
        if (!(At in Fe)) {
          if (!me)
            throw new a("base intrinsic for " + ae + " exists, but the property is not available.");
          return;
        }
        if (A && tt + 1 >= H.length) {
          var ht = A(Fe, At);
          Pe = !!ht, Pe && "get" in ht && !("originalValue" in ht.get) ? Fe = ht.get : Fe = Fe[At];
        } else
          Pe = _e(Fe, At), Fe = Fe[At];
        Pe && !Te && (te[Re] = Fe);
      }
    }
    return Fe;
  }, Jw;
}
var Xw, $C;
function Ug() {
  if ($C) return Xw;
  $C = 1;
  var t = /* @__PURE__ */ lj(), e = yS(), r = e([t("%String.prototype.indexOf%")]);
  return Xw = function(n, i) {
    var s = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      t(n, !!i)
    );
    return typeof s == "function" && r(n, ".prototype.") > -1 ? e([s]) : s;
  }, Xw;
}
var e3, jC;
function $ye() {
  if (jC) return e3;
  jC = 1;
  var t = Mv()(), e = /* @__PURE__ */ Ug(), r = e("Object.prototype.toString"), n = function(o) {
    return t && o && typeof o == "object" && Symbol.toStringTag in o ? !1 : r(o) === "[object Arguments]";
  }, i = function(o) {
    return n(o) ? !0 : o !== null && typeof o == "object" && "length" in o && typeof o.length == "number" && o.length >= 0 && r(o) !== "[object Array]" && "callee" in o && r(o.callee) === "[object Function]";
  }, s = function() {
    return n(arguments);
  }();
  return n.isLegacyArguments = i, e3 = s ? n : i, e3;
}
var t3, BC;
function jye() {
  if (BC) return t3;
  BC = 1;
  var t = /* @__PURE__ */ Ug(), e = Mv()(), r = /* @__PURE__ */ aj(), n = /* @__PURE__ */ Nd(), i;
  if (e) {
    var s = t("RegExp.prototype.exec"), o = {}, a = function() {
      throw o;
    }, l = {
      toString: a,
      valueOf: a
    };
    typeof Symbol.toPrimitive == "symbol" && (l[Symbol.toPrimitive] = a), i = function(h) {
      if (!h || typeof h != "object")
        return !1;
      var d = (
        /** @type {NonNullable<typeof gOPD>} */
        n(
          /** @type {{ lastIndex?: unknown }} */
          h,
          "lastIndex"
        )
      ), v = d && r(d, "value");
      if (!v)
        return !1;
      try {
        s(
          h,
          /** @type {string} */
          /** @type {unknown} */
          l
        );
      } catch (m) {
        return m === o;
      }
    };
  } else {
    var c = t("Object.prototype.toString"), p = "[object RegExp]";
    i = function(h) {
      return !h || typeof h != "object" && typeof h != "function" ? !1 : c(h) === p;
    };
  }
  return t3 = i, t3;
}
var r3, FC;
function Bye() {
  if (FC) return r3;
  FC = 1;
  var t = /* @__PURE__ */ Ug(), e = jye(), r = t("RegExp.prototype.exec"), n = /* @__PURE__ */ Fg();
  return r3 = function(i) {
    if (!e(i))
      throw new n("`regex` must be a RegExp");
    return function(s) {
      return r(i, s) !== null;
    };
  }, r3;
}
var n3, zC;
function Fye() {
  if (zC) return n3;
  zC = 1;
  var t = /* @__PURE__ */ Ug(), e = /* @__PURE__ */ Bye(), r = e(/^\s*(?:function)?\*/), n = Mv()(), i = oj(), s = t("Object.prototype.toString"), o = t("Function.prototype.toString"), a = function() {
    if (!n)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, l;
  return n3 = function(c) {
    if (typeof c != "function")
      return !1;
    if (r(o(c)))
      return !0;
    if (!n) {
      var p = s(c);
      return p === "[object GeneratorFunction]";
    }
    if (!i)
      return !1;
    if (typeof l > "u") {
      var h = a();
      l = h ? (
        /** @type {GeneratorFunctionConstructor} */
        i(h)
      ) : !1;
    }
    return i(c) === l;
  }, n3;
}
var i3, UC;
function zye() {
  if (UC) return i3;
  UC = 1;
  var t = Function.prototype.toString, e = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, n;
  if (typeof e == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw n;
        }
      }), n = {}, e(function() {
        throw 42;
      }, null, r);
    } catch (A) {
      A !== n && (e = null);
    }
  else
    e = null;
  var i = /^\s*class\b/, s = function(A) {
    try {
      var x = t.call(A);
      return i.test(x);
    } catch {
      return !1;
    }
  }, o = function(A) {
    try {
      return s(A) ? !1 : (t.call(A), !0);
    } catch {
      return !1;
    }
  }, a = Object.prototype.toString, l = "[object Object]", c = "[object Function]", p = "[object GeneratorFunction]", h = "[object HTMLAllCollection]", d = "[object HTML document.all class]", v = "[object HTMLCollection]", m = typeof Symbol == "function" && !!Symbol.toStringTag, b = !(0 in [,]), f = function() {
    return !1;
  };
  if (typeof document == "object") {
    var E = document.all;
    a.call(E) === a.call(document.all) && (f = function(A) {
      if ((b || !A) && (typeof A > "u" || typeof A == "object"))
        try {
          var x = a.call(A);
          return (x === h || x === d || x === v || x === l) && A("") == null;
        } catch {
        }
      return !1;
    });
  }
  return i3 = e ? function(A) {
    if (f(A))
      return !0;
    if (!A || typeof A != "function" && typeof A != "object")
      return !1;
    try {
      e(A, null, r);
    } catch (x) {
      if (x !== n)
        return !1;
    }
    return !s(A) && o(A);
  } : function(A) {
    if (f(A))
      return !0;
    if (!A || typeof A != "function" && typeof A != "object")
      return !1;
    if (m)
      return o(A);
    if (s(A))
      return !1;
    var x = a.call(A);
    return x !== c && x !== p && !/^\[object HTML/.test(x) ? !1 : o(A);
  }, i3;
}
var s3, VC;
function Uye() {
  if (VC) return s3;
  VC = 1;
  var t = zye(), e = Object.prototype.toString, r = Object.prototype.hasOwnProperty, n = function(a, l, c) {
    for (var p = 0, h = a.length; p < h; p++)
      r.call(a, p) && (c == null ? l(a[p], p, a) : l.call(c, a[p], p, a));
  }, i = function(a, l, c) {
    for (var p = 0, h = a.length; p < h; p++)
      c == null ? l(a.charAt(p), p, a) : l.call(c, a.charAt(p), p, a);
  }, s = function(a, l, c) {
    for (var p in a)
      r.call(a, p) && (c == null ? l(a[p], p, a) : l.call(c, a[p], p, a));
  }, o = function(a, l, c) {
    if (!t(l))
      throw new TypeError("iterator must be a function");
    var p;
    arguments.length >= 3 && (p = c), e.call(a) === "[object Array]" ? n(a, l, p) : typeof a == "string" ? i(a, l, p) : s(a, l, p);
  };
  return s3 = o, s3;
}
var HC, GC;
function Vye() {
  return GC || (GC = 1, HC = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), HC;
}
var o3, WC;
function Hye() {
  if (WC) return o3;
  WC = 1;
  var t = /* @__PURE__ */ Vye(), e = typeof globalThis > "u" ? Xl : globalThis;
  return o3 = function() {
    for (var r = [], n = 0; n < t.length; n++)
      typeof e[t[n]] == "function" && (r[r.length] = t[n]);
    return r;
  }, o3;
}
var qC = { exports: {} }, a3, QC;
function Gye() {
  if (QC) return a3;
  QC = 1;
  var t = /* @__PURE__ */ Nv(), e = /* @__PURE__ */ rj(), r = /* @__PURE__ */ Fg(), n = /* @__PURE__ */ Nd();
  return a3 = function(i, s, o) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new r("`obj` must be an object or a function`");
    if (typeof s != "string" && typeof s != "symbol")
      throw new r("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new r("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new r("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new r("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new r("`loose`, if provided, must be a boolean");
    var a = arguments.length > 3 ? arguments[3] : null, l = arguments.length > 4 ? arguments[4] : null, c = arguments.length > 5 ? arguments[5] : null, p = arguments.length > 6 ? arguments[6] : !1, h = !!n && n(i, s);
    if (t)
      t(i, s, {
        configurable: c === null && h ? h.configurable : !c,
        enumerable: a === null && h ? h.enumerable : !a,
        value: o,
        writable: l === null && h ? h.writable : !l
      });
    else if (p || !a && !l && !c)
      i[s] = o;
    else
      throw new e("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, a3;
}
var l3, KC;
function Wye() {
  if (KC) return l3;
  KC = 1;
  var t = /* @__PURE__ */ Nv(), e = function() {
    return !!t;
  };
  return e.hasArrayLengthDefineBug = function() {
    if (!t)
      return null;
    try {
      return t([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, l3 = e, l3;
}
var c3, YC;
function qye() {
  if (YC) return c3;
  YC = 1;
  var t = /* @__PURE__ */ lj(), e = /* @__PURE__ */ Gye(), r = /* @__PURE__ */ Wye()(), n = /* @__PURE__ */ Nd(), i = /* @__PURE__ */ Fg(), s = t("%Math.floor%");
  return c3 = function(o, a) {
    if (typeof o != "function")
      throw new i("`fn` is not a function");
    if (typeof a != "number" || a < 0 || a > 4294967295 || s(a) !== a)
      throw new i("`length` must be a positive 32-bit integer");
    var l = arguments.length > 2 && !!arguments[2], c = !0, p = !0;
    if ("length" in o && n) {
      var h = n(o, "length");
      h && !h.configurable && (c = !1), h && !h.writable && (p = !1);
    }
    return (c || p || !l) && (r ? e(
      /** @type {Parameters<define>[0]} */
      o,
      "length",
      a,
      !0,
      !0
    ) : e(
      /** @type {Parameters<define>[0]} */
      o,
      "length",
      a
    )), o;
  }, c3;
}
var u3, ZC;
function Qye() {
  if (ZC) return u3;
  ZC = 1;
  var t = zg(), e = mS(), r = sj();
  return u3 = function() {
    return r(t, e, arguments);
  }, u3;
}
var JC;
function Kye() {
  return JC || (JC = 1, function(t) {
    var e = /* @__PURE__ */ qye(), r = /* @__PURE__ */ Nv(), n = yS(), i = Qye();
    t.exports = function(s) {
      var o = n(arguments), a = s.length - (arguments.length - 1);
      return e(
        o,
        1 + (a > 0 ? a : 0),
        !0
      );
    }, r ? r(t.exports, "apply", { value: i }) : t.exports.apply = i;
  }(qC)), qC.exports;
}
var h3, XC;
function cj() {
  if (XC) return h3;
  XC = 1;
  var t = Uye(), e = /* @__PURE__ */ Hye(), r = Kye(), n = /* @__PURE__ */ Ug(), i = /* @__PURE__ */ Nd(), s = n("Object.prototype.toString"), o = Mv()(), a = typeof globalThis > "u" ? Xl : globalThis, l = e(), c = n("String.prototype.slice"), p = Object.getPrototypeOf, h = n("Array.prototype.indexOf", !0) || function(b, f) {
    for (var E = 0; E < b.length; E += 1)
      if (b[E] === f)
        return E;
    return -1;
  }, d = { __proto__: null };
  o && i && p ? t(l, function(b) {
    var f = new a[b]();
    if (Symbol.toStringTag in f) {
      var E = p(f), A = i(E, Symbol.toStringTag);
      if (!A) {
        var x = p(E);
        A = i(x, Symbol.toStringTag);
      }
      d["$" + b] = r(A.get);
    }
  }) : t(l, function(b) {
    var f = new a[b](), E = f.slice || f.set;
    E && (d["$" + b] = r(E));
  });
  var v = function(b) {
    var f = !1;
    return t(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      d,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, A) {
        if (!f)
          try {
            "$" + E(b) === A && (f = c(A, 1));
          } catch {
          }
      }
    ), f;
  }, m = function(b) {
    var f = !1;
    return t(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      d,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(E, A) {
        if (!f)
          try {
            E(b), f = c(A, 1);
          } catch {
          }
      }
    ), f;
  };
  return h3 = function(b) {
    if (!b || typeof b != "object")
      return !1;
    if (!o) {
      var f = c(s(b), 8, -1);
      return h(l, f) > -1 ? f : f !== "Object" ? !1 : m(b);
    }
    return i ? v(b) : null;
  }, h3;
}
var p3, eI;
function Yye() {
  if (eI) return p3;
  eI = 1;
  var t = /* @__PURE__ */ cj();
  return p3 = function(e) {
    return !!t(e);
  }, p3;
}
var tI;
function Zye() {
  return tI || (tI = 1, function(t) {
    var e = /* @__PURE__ */ $ye(), r = Fye(), n = /* @__PURE__ */ cj(), i = /* @__PURE__ */ Yye();
    function s(Pe) {
      return Pe.call.bind(Pe);
    }
    var o = typeof BigInt < "u", a = typeof Symbol < "u", l = s(Object.prototype.toString), c = s(Number.prototype.valueOf), p = s(String.prototype.valueOf), h = s(Boolean.prototype.valueOf);
    if (o)
      var d = s(BigInt.prototype.valueOf);
    if (a)
      var v = s(Symbol.prototype.valueOf);
    function m(Pe, At) {
      if (typeof Pe != "object")
        return !1;
      try {
        return At(Pe), !0;
      } catch {
        return !1;
      }
    }
    t.isArgumentsObject = e, t.isGeneratorFunction = r, t.isTypedArray = i;
    function b(Pe) {
      return typeof Promise < "u" && Pe instanceof Promise || Pe !== null && typeof Pe == "object" && typeof Pe.then == "function" && typeof Pe.catch == "function";
    }
    t.isPromise = b;
    function f(Pe) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Pe) : i(Pe) || O(Pe);
    }
    t.isArrayBufferView = f;
    function E(Pe) {
      return n(Pe) === "Uint8Array";
    }
    t.isUint8Array = E;
    function A(Pe) {
      return n(Pe) === "Uint8ClampedArray";
    }
    t.isUint8ClampedArray = A;
    function x(Pe) {
      return n(Pe) === "Uint16Array";
    }
    t.isUint16Array = x;
    function g(Pe) {
      return n(Pe) === "Uint32Array";
    }
    t.isUint32Array = g;
    function w(Pe) {
      return n(Pe) === "Int8Array";
    }
    t.isInt8Array = w;
    function _(Pe) {
      return n(Pe) === "Int16Array";
    }
    t.isInt16Array = _;
    function S(Pe) {
      return n(Pe) === "Int32Array";
    }
    t.isInt32Array = S;
    function R(Pe) {
      return n(Pe) === "Float32Array";
    }
    t.isFloat32Array = R;
    function L(Pe) {
      return n(Pe) === "Float64Array";
    }
    t.isFloat64Array = L;
    function F(Pe) {
      return n(Pe) === "BigInt64Array";
    }
    t.isBigInt64Array = F;
    function z(Pe) {
      return n(Pe) === "BigUint64Array";
    }
    t.isBigUint64Array = z;
    function j(Pe) {
      return l(Pe) === "[object Map]";
    }
    j.working = typeof Map < "u" && j(/* @__PURE__ */ new Map());
    function W(Pe) {
      return typeof Map > "u" ? !1 : j.working ? j(Pe) : Pe instanceof Map;
    }
    t.isMap = W;
    function te(Pe) {
      return l(Pe) === "[object Set]";
    }
    te.working = typeof Set < "u" && te(/* @__PURE__ */ new Set());
    function le(Pe) {
      return typeof Set > "u" ? !1 : te.working ? te(Pe) : Pe instanceof Set;
    }
    t.isSet = le;
    function ce(Pe) {
      return l(Pe) === "[object WeakMap]";
    }
    ce.working = typeof WeakMap < "u" && ce(/* @__PURE__ */ new WeakMap());
    function Ee(Pe) {
      return typeof WeakMap > "u" ? !1 : ce.working ? ce(Pe) : Pe instanceof WeakMap;
    }
    t.isWeakMap = Ee;
    function xe(Pe) {
      return l(Pe) === "[object WeakSet]";
    }
    xe.working = typeof WeakSet < "u" && xe(/* @__PURE__ */ new WeakSet());
    function _e(Pe) {
      return xe(Pe);
    }
    t.isWeakSet = _e;
    function Ie(Pe) {
      return l(Pe) === "[object ArrayBuffer]";
    }
    Ie.working = typeof ArrayBuffer < "u" && Ie(new ArrayBuffer());
    function je(Pe) {
      return typeof ArrayBuffer > "u" ? !1 : Ie.working ? Ie(Pe) : Pe instanceof ArrayBuffer;
    }
    t.isArrayBuffer = je;
    function ue(Pe) {
      return l(Pe) === "[object DataView]";
    }
    ue.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ue(new DataView(new ArrayBuffer(1), 0, 1));
    function O(Pe) {
      return typeof DataView > "u" ? !1 : ue.working ? ue(Pe) : Pe instanceof DataView;
    }
    t.isDataView = O;
    var N = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function J(Pe) {
      return l(Pe) === "[object SharedArrayBuffer]";
    }
    function re(Pe) {
      return typeof N > "u" ? !1 : (typeof J.working > "u" && (J.working = J(new N())), J.working ? J(Pe) : Pe instanceof N);
    }
    t.isSharedArrayBuffer = re;
    function oe(Pe) {
      return l(Pe) === "[object AsyncFunction]";
    }
    t.isAsyncFunction = oe;
    function ee(Pe) {
      return l(Pe) === "[object Map Iterator]";
    }
    t.isMapIterator = ee;
    function ae(Pe) {
      return l(Pe) === "[object Set Iterator]";
    }
    t.isSetIterator = ae;
    function me(Pe) {
      return l(Pe) === "[object Generator]";
    }
    t.isGeneratorObject = me;
    function H(Pe) {
      return l(Pe) === "[object WebAssembly.Module]";
    }
    t.isWebAssemblyCompiledModule = H;
    function X(Pe) {
      return m(Pe, c);
    }
    t.isNumberObject = X;
    function Ae(Pe) {
      return m(Pe, p);
    }
    t.isStringObject = Ae;
    function Re(Pe) {
      return m(Pe, h);
    }
    t.isBooleanObject = Re;
    function Fe(Pe) {
      return o && m(Pe, d);
    }
    t.isBigIntObject = Fe;
    function Te(Pe) {
      return a && m(Pe, v);
    }
    t.isSymbolObject = Te;
    function qe(Pe) {
      return X(Pe) || Ae(Pe) || Re(Pe) || Fe(Pe) || Te(Pe);
    }
    t.isBoxedPrimitive = qe;
    function tt(Pe) {
      return typeof Uint8Array < "u" && (je(Pe) || re(Pe));
    }
    t.isAnyArrayBuffer = tt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Pe) {
      Object.defineProperty(t, Pe, {
        enumerable: !1,
        value: function() {
          throw new Error(Pe + " is not supported in userland");
        }
      });
    });
  }(M_)), M_;
}
var rI, nI;
function Jye() {
  return nI || (nI = 1, rI = function(t) {
    return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
  }), rI;
}
var iI;
function uj() {
  return iI || (iI = 1, function(t) {
    var e = Object.getOwnPropertyDescriptors || function(ue) {
      for (var O = Object.keys(ue), N = {}, J = 0; J < O.length; J++)
        N[O[J]] = Object.getOwnPropertyDescriptor(ue, O[J]);
      return N;
    }, r = /%[sdj%]/g;
    t.format = function(ue) {
      if (!w(ue)) {
        for (var O = [], N = 0; N < arguments.length; N++)
          O.push(o(arguments[N]));
        return O.join(" ");
      }
      for (var N = 1, J = arguments, re = J.length, oe = String(ue).replace(r, function(me) {
        if (me === "%%") return "%";
        if (N >= re) return me;
        switch (me) {
          case "%s":
            return String(J[N++]);
          case "%d":
            return Number(J[N++]);
          case "%j":
            try {
              return JSON.stringify(J[N++]);
            } catch {
              return "[Circular]";
            }
          default:
            return me;
        }
      }), ee = J[N]; N < re; ee = J[++N])
        A(ee) || !L(ee) ? oe += " " + ee : oe += " " + o(ee);
      return oe;
    }, t.deprecate = function(ue, O) {
      if (typeof Vt < "u" && Vt.noDeprecation === !0)
        return ue;
      if (typeof Vt > "u")
        return function() {
          return t.deprecate(ue, O).apply(this, arguments);
        };
      var N = !1;
      function J() {
        if (!N) {
          if (Vt.throwDeprecation)
            throw new Error(O);
          Vt.traceDeprecation ? console.trace(O) : console.error(O), N = !0;
        }
        return ue.apply(this, arguments);
      }
      return J;
    };
    var n = {}, i = /^$/;
    if (Vt.env.NODE_DEBUG) {
      var s = Vt.env.NODE_DEBUG;
      s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + s + "$", "i");
    }
    t.debuglog = function(ue) {
      if (ue = ue.toUpperCase(), !n[ue])
        if (i.test(ue)) {
          var O = Vt.pid;
          n[ue] = function() {
            var N = t.format.apply(t, arguments);
            console.error("%s %d: %s", ue, O, N);
          };
        } else
          n[ue] = function() {
          };
      return n[ue];
    };
    function o(ue, O) {
      var N = {
        seen: [],
        stylize: l
      };
      return arguments.length >= 3 && (N.depth = arguments[2]), arguments.length >= 4 && (N.colors = arguments[3]), E(O) ? N.showHidden = O : O && t._extend(N, O), S(N.showHidden) && (N.showHidden = !1), S(N.depth) && (N.depth = 2), S(N.colors) && (N.colors = !1), S(N.customInspect) && (N.customInspect = !0), N.colors && (N.stylize = a), p(N, ue, N.depth);
    }
    t.inspect = o, o.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, o.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function a(ue, O) {
      var N = o.styles[O];
      return N ? "\x1B[" + o.colors[N][0] + "m" + ue + "\x1B[" + o.colors[N][1] + "m" : ue;
    }
    function l(ue, O) {
      return ue;
    }
    function c(ue) {
      var O = {};
      return ue.forEach(function(N, J) {
        O[N] = !0;
      }), O;
    }
    function p(ue, O, N) {
      if (ue.customInspect && O && j(O.inspect) && // Filter out the util module, it's inspect function is special
      O.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.
      !(O.constructor && O.constructor.prototype === O)) {
        var J = O.inspect(N, ue);
        return w(J) || (J = p(ue, J, N)), J;
      }
      var re = h(ue, O);
      if (re)
        return re;
      var oe = Object.keys(O), ee = c(oe);
      if (ue.showHidden && (oe = Object.getOwnPropertyNames(O)), z(O) && (oe.indexOf("message") >= 0 || oe.indexOf("description") >= 0))
        return d(O);
      if (oe.length === 0) {
        if (j(O)) {
          var ae = O.name ? ": " + O.name : "";
          return ue.stylize("[Function" + ae + "]", "special");
        }
        if (R(O))
          return ue.stylize(RegExp.prototype.toString.call(O), "regexp");
        if (F(O))
          return ue.stylize(Date.prototype.toString.call(O), "date");
        if (z(O))
          return d(O);
      }
      var me = "", H = !1, X = ["{", "}"];
      if (f(O) && (H = !0, X = ["[", "]"]), j(O)) {
        var Ae = O.name ? ": " + O.name : "";
        me = " [Function" + Ae + "]";
      }
      if (R(O) && (me = " " + RegExp.prototype.toString.call(O)), F(O) && (me = " " + Date.prototype.toUTCString.call(O)), z(O) && (me = " " + d(O)), oe.length === 0 && (!H || O.length == 0))
        return X[0] + me + X[1];
      if (N < 0)
        return R(O) ? ue.stylize(RegExp.prototype.toString.call(O), "regexp") : ue.stylize("[Object]", "special");
      ue.seen.push(O);
      var Re;
      return H ? Re = v(ue, O, N, ee, oe) : Re = oe.map(function(Fe) {
        return m(ue, O, N, ee, Fe, H);
      }), ue.seen.pop(), b(Re, me, X);
    }
    function h(ue, O) {
      if (S(O))
        return ue.stylize("undefined", "undefined");
      if (w(O)) {
        var N = "'" + JSON.stringify(O).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ue.stylize(N, "string");
      }
      if (g(O))
        return ue.stylize("" + O, "number");
      if (E(O))
        return ue.stylize("" + O, "boolean");
      if (A(O))
        return ue.stylize("null", "null");
    }
    function d(ue) {
      return "[" + Error.prototype.toString.call(ue) + "]";
    }
    function v(ue, O, N, J, re) {
      for (var oe = [], ee = 0, ae = O.length; ee < ae; ++ee)
        xe(O, String(ee)) ? oe.push(m(
          ue,
          O,
          N,
          J,
          String(ee),
          !0
        )) : oe.push("");
      return re.forEach(function(me) {
        me.match(/^\d+$/) || oe.push(m(
          ue,
          O,
          N,
          J,
          me,
          !0
        ));
      }), oe;
    }
    function m(ue, O, N, J, re, oe) {
      var ee, ae, me;
      if (me = Object.getOwnPropertyDescriptor(O, re) || { value: O[re] }, me.get ? me.set ? ae = ue.stylize("[Getter/Setter]", "special") : ae = ue.stylize("[Getter]", "special") : me.set && (ae = ue.stylize("[Setter]", "special")), xe(J, re) || (ee = "[" + re + "]"), ae || (ue.seen.indexOf(me.value) < 0 ? (A(N) ? ae = p(ue, me.value, null) : ae = p(ue, me.value, N - 1), ae.indexOf(`
`) > -1 && (oe ? ae = ae.split(`
`).map(function(H) {
        return "  " + H;
      }).join(`
`).slice(2) : ae = `
` + ae.split(`
`).map(function(H) {
        return "   " + H;
      }).join(`
`))) : ae = ue.stylize("[Circular]", "special")), S(ee)) {
        if (oe && re.match(/^\d+$/))
          return ae;
        ee = JSON.stringify("" + re), ee.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ee = ee.slice(1, -1), ee = ue.stylize(ee, "name")) : (ee = ee.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ee = ue.stylize(ee, "string"));
      }
      return ee + ": " + ae;
    }
    function b(ue, O, N) {
      var J = ue.reduce(function(re, oe) {
        return oe.indexOf(`
`) >= 0, re + oe.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return J > 60 ? N[0] + (O === "" ? "" : O + `
 `) + " " + ue.join(`,
  `) + " " + N[1] : N[0] + O + " " + ue.join(", ") + " " + N[1];
    }
    t.types = Zye();
    function f(ue) {
      return Array.isArray(ue);
    }
    t.isArray = f;
    function E(ue) {
      return typeof ue == "boolean";
    }
    t.isBoolean = E;
    function A(ue) {
      return ue === null;
    }
    t.isNull = A;
    function x(ue) {
      return ue == null;
    }
    t.isNullOrUndefined = x;
    function g(ue) {
      return typeof ue == "number";
    }
    t.isNumber = g;
    function w(ue) {
      return typeof ue == "string";
    }
    t.isString = w;
    function _(ue) {
      return typeof ue == "symbol";
    }
    t.isSymbol = _;
    function S(ue) {
      return ue === void 0;
    }
    t.isUndefined = S;
    function R(ue) {
      return L(ue) && te(ue) === "[object RegExp]";
    }
    t.isRegExp = R, t.types.isRegExp = R;
    function L(ue) {
      return typeof ue == "object" && ue !== null;
    }
    t.isObject = L;
    function F(ue) {
      return L(ue) && te(ue) === "[object Date]";
    }
    t.isDate = F, t.types.isDate = F;
    function z(ue) {
      return L(ue) && (te(ue) === "[object Error]" || ue instanceof Error);
    }
    t.isError = z, t.types.isNativeError = z;
    function j(ue) {
      return typeof ue == "function";
    }
    t.isFunction = j;
    function W(ue) {
      return ue === null || typeof ue == "boolean" || typeof ue == "number" || typeof ue == "string" || typeof ue == "symbol" || // ES6 symbol
      typeof ue > "u";
    }
    t.isPrimitive = W, t.isBuffer = Jye();
    function te(ue) {
      return Object.prototype.toString.call(ue);
    }
    function le(ue) {
      return ue < 10 ? "0" + ue.toString(10) : ue.toString(10);
    }
    var ce = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function Ee() {
      var ue = /* @__PURE__ */ new Date(), O = [
        le(ue.getHours()),
        le(ue.getMinutes()),
        le(ue.getSeconds())
      ].join(":");
      return [ue.getDate(), ce[ue.getMonth()], O].join(" ");
    }
    t.log = function() {
      console.log("%s - %s", Ee(), t.format.apply(t, arguments));
    }, t.inherits = Bh(), t._extend = function(ue, O) {
      if (!O || !L(O)) return ue;
      for (var N = Object.keys(O), J = N.length; J--; )
        ue[N[J]] = O[N[J]];
      return ue;
    };
    function xe(ue, O) {
      return Object.prototype.hasOwnProperty.call(ue, O);
    }
    var _e = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    t.promisify = function(ue) {
      if (typeof ue != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (_e && ue[_e]) {
        var O = ue[_e];
        if (typeof O != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(O, _e, {
          value: O,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), O;
      }
      function O() {
        for (var N, J, re = new Promise(function(ae, me) {
          N = ae, J = me;
        }), oe = [], ee = 0; ee < arguments.length; ee++)
          oe.push(arguments[ee]);
        oe.push(function(ae, me) {
          ae ? J(ae) : N(me);
        });
        try {
          ue.apply(this, oe);
        } catch (ae) {
          J(ae);
        }
        return re;
      }
      return Object.setPrototypeOf(O, Object.getPrototypeOf(ue)), _e && Object.defineProperty(O, _e, {
        value: O,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        O,
        e(ue)
      );
    }, t.promisify.custom = _e;
    function Ie(ue, O) {
      if (!ue) {
        var N = new Error("Promise was rejected with a falsy value");
        N.reason = ue, ue = N;
      }
      return O(ue);
    }
    function je(ue) {
      if (typeof ue != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function O() {
        for (var N = [], J = 0; J < arguments.length; J++)
          N.push(arguments[J]);
        var re = N.pop();
        if (typeof re != "function")
          throw new TypeError("The last argument must be of type Function");
        var oe = this, ee = function() {
          return re.apply(oe, arguments);
        };
        ue.apply(this, N).then(
          function(ae) {
            Vt.nextTick(ee.bind(null, null, ae));
          },
          function(ae) {
            Vt.nextTick(Ie.bind(null, ae, ee));
          }
        );
      }
      return Object.setPrototypeOf(O, Object.getPrototypeOf(ue)), Object.defineProperties(
        O,
        e(ue)
      ), O;
    }
    t.callbackify = je;
  }(L_)), L_;
}
var d3, sI;
function Xye() {
  if (sI) return d3;
  sI = 1;
  function t(m, b) {
    var f = Object.keys(m);
    if (Object.getOwnPropertySymbols) {
      var E = Object.getOwnPropertySymbols(m);
      b && (E = E.filter(function(A) {
        return Object.getOwnPropertyDescriptor(m, A).enumerable;
      })), f.push.apply(f, E);
    }
    return f;
  }
  function e(m) {
    for (var b = 1; b < arguments.length; b++) {
      var f = arguments[b] != null ? arguments[b] : {};
      b % 2 ? t(Object(f), !0).forEach(function(E) {
        r(m, E, f[E]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(f)) : t(Object(f)).forEach(function(E) {
        Object.defineProperty(m, E, Object.getOwnPropertyDescriptor(f, E));
      });
    }
    return m;
  }
  function r(m, b, f) {
    return b = o(b), b in m ? Object.defineProperty(m, b, { value: f, enumerable: !0, configurable: !0, writable: !0 }) : m[b] = f, m;
  }
  function n(m, b) {
    if (!(m instanceof b))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(m, b) {
    for (var f = 0; f < b.length; f++) {
      var E = b[f];
      E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(m, o(E.key), E);
    }
  }
  function s(m, b, f) {
    return b && i(m.prototype, b), Object.defineProperty(m, "prototype", { writable: !1 }), m;
  }
  function o(m) {
    var b = a(m, "string");
    return typeof b == "symbol" ? b : String(b);
  }
  function a(m, b) {
    if (typeof m != "object" || m === null) return m;
    var f = m[Symbol.toPrimitive];
    if (f !== void 0) {
      var E = f.call(m, b);
      if (typeof E != "object") return E;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(m);
  }
  var l = Lv(), c = l.Buffer, p = uj(), h = p.inspect, d = h && h.custom || "inspect";
  function v(m, b, f) {
    c.prototype.copy.call(m, b, f);
  }
  return d3 = /* @__PURE__ */ function() {
    function m() {
      n(this, m), this.head = null, this.tail = null, this.length = 0;
    }
    return s(m, [{
      key: "push",
      value: function(b) {
        var f = {
          data: b,
          next: null
        };
        this.length > 0 ? this.tail.next = f : this.head = f, this.tail = f, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(b) {
        var f = {
          data: b,
          next: this.head
        };
        this.length === 0 && (this.tail = f), this.head = f, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var b = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, b;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(b) {
        if (this.length === 0) return "";
        for (var f = this.head, E = "" + f.data; f = f.next; ) E += b + f.data;
        return E;
      }
    }, {
      key: "concat",
      value: function(b) {
        if (this.length === 0) return c.alloc(0);
        for (var f = c.allocUnsafe(b >>> 0), E = this.head, A = 0; E; )
          v(E.data, f, A), A += E.data.length, E = E.next;
        return f;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(b, f) {
        var E;
        return b < this.head.data.length ? (E = this.head.data.slice(0, b), this.head.data = this.head.data.slice(b)) : b === this.head.data.length ? E = this.shift() : E = f ? this._getString(b) : this._getBuffer(b), E;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(b) {
        var f = this.head, E = 1, A = f.data;
        for (b -= A.length; f = f.next; ) {
          var x = f.data, g = b > x.length ? x.length : b;
          if (g === x.length ? A += x : A += x.slice(0, b), b -= g, b === 0) {
            g === x.length ? (++E, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = x.slice(g));
            break;
          }
          ++E;
        }
        return this.length -= E, A;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(b) {
        var f = c.allocUnsafe(b), E = this.head, A = 1;
        for (E.data.copy(f), b -= E.data.length; E = E.next; ) {
          var x = E.data, g = b > x.length ? x.length : b;
          if (x.copy(f, f.length - b, 0, g), b -= g, b === 0) {
            g === x.length ? (++A, E.next ? this.head = E.next : this.head = this.tail = null) : (this.head = E, E.data = x.slice(g));
            break;
          }
          ++A;
        }
        return this.length -= A, f;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: d,
      value: function(b, f) {
        return h(this, e(e({}, f), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), m;
  }(), d3;
}
var f3, oI;
function hj() {
  if (oI) return f3;
  oI = 1;
  function t(o, a) {
    var l = this, c = this._readableState && this._readableState.destroyed, p = this._writableState && this._writableState.destroyed;
    return c || p ? (a ? a(o) : o && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Vt.nextTick(i, this, o)) : Vt.nextTick(i, this, o)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(o || null, function(h) {
      !a && h ? l._writableState ? l._writableState.errorEmitted ? Vt.nextTick(r, l) : (l._writableState.errorEmitted = !0, Vt.nextTick(e, l, h)) : Vt.nextTick(e, l, h) : a ? (Vt.nextTick(r, l), a(h)) : Vt.nextTick(r, l);
    }), this);
  }
  function e(o, a) {
    i(o, a), r(o);
  }
  function r(o) {
    o._writableState && !o._writableState.emitClose || o._readableState && !o._readableState.emitClose || o.emit("close");
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function i(o, a) {
    o.emit("error", a);
  }
  function s(o, a) {
    var l = o._readableState, c = o._writableState;
    l && l.autoDestroy || c && c.autoDestroy ? o.destroy(a) : o.emit("error", a);
  }
  return f3 = {
    destroy: t,
    undestroy: n,
    errorOrDestroy: s
  }, f3;
}
var g3 = {}, aI;
function Dd() {
  if (aI) return g3;
  aI = 1;
  function t(a, l) {
    a.prototype = Object.create(l.prototype), a.prototype.constructor = a, a.__proto__ = l;
  }
  var e = {};
  function r(a, l, c) {
    c || (c = Error);
    function p(d, v, m) {
      return typeof l == "string" ? l : l(d, v, m);
    }
    var h = /* @__PURE__ */ function(d) {
      t(v, d);
      function v(m, b, f) {
        return d.call(this, p(m, b, f)) || this;
      }
      return v;
    }(c);
    h.prototype.name = c.name, h.prototype.code = a, e[a] = h;
  }
  function n(a, l) {
    if (Array.isArray(a)) {
      var c = a.length;
      return a = a.map(function(p) {
        return String(p);
      }), c > 2 ? "one of ".concat(l, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(l, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(l, " ").concat(a[0]);
    } else
      return "of ".concat(l, " ").concat(String(a));
  }
  function i(a, l, c) {
    return a.substr(0, l.length) === l;
  }
  function s(a, l, c) {
    return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - l.length, c) === l;
  }
  function o(a, l, c) {
    return typeof c != "number" && (c = 0), c + l.length > a.length ? !1 : a.indexOf(l, c) !== -1;
  }
  return r("ERR_INVALID_OPT_VALUE", function(a, l) {
    return 'The value "' + l + '" is invalid for option "' + a + '"';
  }, TypeError), r("ERR_INVALID_ARG_TYPE", function(a, l, c) {
    var p;
    typeof l == "string" && i(l, "not ") ? (p = "must not be", l = l.replace(/^not /, "")) : p = "must be";
    var h;
    if (s(a, " argument"))
      h = "The ".concat(a, " ").concat(p, " ").concat(n(l, "type"));
    else {
      var d = o(a, ".") ? "property" : "argument";
      h = 'The "'.concat(a, '" ').concat(d, " ").concat(p, " ").concat(n(l, "type"));
    }
    return h += ". Received type ".concat(typeof c), h;
  }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
    return "The " + a + " method is not implemented";
  }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(a) {
    return "Cannot call " + a + " after a stream was destroyed";
  }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(a) {
    return "Unknown encoding: " + a;
  }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), g3.codes = e, g3;
}
var m3, lI;
function pj() {
  if (lI) return m3;
  lI = 1;
  var t = Dd().codes.ERR_INVALID_OPT_VALUE;
  function e(n, i, s) {
    return n.highWaterMark != null ? n.highWaterMark : i ? n[s] : null;
  }
  function r(n, i, s, o) {
    var a = e(i, o, s);
    if (a != null) {
      if (!(isFinite(a) && Math.floor(a) === a) || a < 0) {
        var l = o ? s : "highWaterMark";
        throw new t(l, a);
      }
      return Math.floor(a);
    }
    return n.objectMode ? 16 : 16 * 1024;
  }
  return m3 = {
    getHighWaterMark: r
  }, m3;
}
var y3, cI;
function e2e() {
  if (cI) return y3;
  cI = 1, y3 = t;
  function t(r, n) {
    if (e("noDeprecation"))
      return r;
    var i = !1;
    function s() {
      if (!i) {
        if (e("throwDeprecation"))
          throw new Error(n);
        e("traceDeprecation") ? console.trace(n) : console.warn(n), i = !0;
      }
      return r.apply(this, arguments);
    }
    return s;
  }
  function e(r) {
    try {
      if (!Xl.localStorage) return !1;
    } catch {
      return !1;
    }
    var n = Xl.localStorage[r];
    return n == null ? !1 : String(n).toLowerCase() === "true";
  }
  return y3;
}
var v3, uI;
function dj() {
  if (uI) return v3;
  uI = 1, v3 = R;
  function t(re) {
    var oe = this;
    this.next = null, this.entry = null, this.finish = function() {
      J(oe, re);
    };
  }
  var e;
  R.WritableState = _;
  var r = {
    deprecate: e2e()
  }, n = X$(), i = Lv().Buffer, s = (typeof Xl < "u" ? Xl : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(re) {
    return i.from(re);
  }
  function a(re) {
    return i.isBuffer(re) || re instanceof s;
  }
  var l = hj(), c = pj(), p = c.getHighWaterMark, h = Dd().codes, d = h.ERR_INVALID_ARG_TYPE, v = h.ERR_METHOD_NOT_IMPLEMENTED, m = h.ERR_MULTIPLE_CALLBACK, b = h.ERR_STREAM_CANNOT_PIPE, f = h.ERR_STREAM_DESTROYED, E = h.ERR_STREAM_NULL_VALUES, A = h.ERR_STREAM_WRITE_AFTER_END, x = h.ERR_UNKNOWN_ENCODING, g = l.errorOrDestroy;
  Bh()(R, n);
  function w() {
  }
  function _(re, oe, ee) {
    e = e || Zp(), re = re || {}, typeof ee != "boolean" && (ee = oe instanceof e), this.objectMode = !!re.objectMode, ee && (this.objectMode = this.objectMode || !!re.writableObjectMode), this.highWaterMark = p(this, re, "writableHighWaterMark", ee), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ae = re.decodeStrings === !1;
    this.decodeStrings = !ae, this.defaultEncoding = re.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(me) {
      ce(oe, me);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = re.emitClose !== !1, this.autoDestroy = !!re.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  _.prototype.getBuffer = function() {
    for (var re = this.bufferedRequest, oe = []; re; )
      oe.push(re), re = re.next;
    return oe;
  }, function() {
    try {
      Object.defineProperty(_.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var S;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (S = Function.prototype[Symbol.hasInstance], Object.defineProperty(R, Symbol.hasInstance, {
    value: function(re) {
      return S.call(this, re) ? !0 : this !== R ? !1 : re && re._writableState instanceof _;
    }
  })) : S = function(re) {
    return re instanceof this;
  };
  function R(re) {
    e = e || Zp();
    var oe = this instanceof e;
    if (!oe && !S.call(R, this)) return new R(re);
    this._writableState = new _(re, this, oe), this.writable = !0, re && (typeof re.write == "function" && (this._write = re.write), typeof re.writev == "function" && (this._writev = re.writev), typeof re.destroy == "function" && (this._destroy = re.destroy), typeof re.final == "function" && (this._final = re.final)), n.call(this);
  }
  R.prototype.pipe = function() {
    g(this, new b());
  };
  function L(re, oe) {
    var ee = new A();
    g(re, ee), Vt.nextTick(oe, ee);
  }
  function F(re, oe, ee, ae) {
    var me;
    return ee === null ? me = new E() : typeof ee != "string" && !oe.objectMode && (me = new d("chunk", ["string", "Buffer"], ee)), me ? (g(re, me), Vt.nextTick(ae, me), !1) : !0;
  }
  R.prototype.write = function(re, oe, ee) {
    var ae = this._writableState, me = !1, H = !ae.objectMode && a(re);
    return H && !i.isBuffer(re) && (re = o(re)), typeof oe == "function" && (ee = oe, oe = null), H ? oe = "buffer" : oe || (oe = ae.defaultEncoding), typeof ee != "function" && (ee = w), ae.ending ? L(this, ee) : (H || F(this, ae, re, ee)) && (ae.pendingcb++, me = j(this, ae, H, re, oe, ee)), me;
  }, R.prototype.cork = function() {
    this._writableState.corked++;
  }, R.prototype.uncork = function() {
    var re = this._writableState;
    re.corked && (re.corked--, !re.writing && !re.corked && !re.bufferProcessing && re.bufferedRequest && _e(this, re));
  }, R.prototype.setDefaultEncoding = function(re) {
    if (typeof re == "string" && (re = re.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((re + "").toLowerCase()) > -1)) throw new x(re);
    return this._writableState.defaultEncoding = re, this;
  }, Object.defineProperty(R.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function z(re, oe, ee) {
    return !re.objectMode && re.decodeStrings !== !1 && typeof oe == "string" && (oe = i.from(oe, ee)), oe;
  }
  Object.defineProperty(R.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function j(re, oe, ee, ae, me, H) {
    if (!ee) {
      var X = z(oe, ae, me);
      ae !== X && (ee = !0, me = "buffer", ae = X);
    }
    var Ae = oe.objectMode ? 1 : ae.length;
    oe.length += Ae;
    var Re = oe.length < oe.highWaterMark;
    if (Re || (oe.needDrain = !0), oe.writing || oe.corked) {
      var Fe = oe.lastBufferedRequest;
      oe.lastBufferedRequest = {
        chunk: ae,
        encoding: me,
        isBuf: ee,
        callback: H,
        next: null
      }, Fe ? Fe.next = oe.lastBufferedRequest : oe.bufferedRequest = oe.lastBufferedRequest, oe.bufferedRequestCount += 1;
    } else
      W(re, oe, !1, Ae, ae, me, H);
    return Re;
  }
  function W(re, oe, ee, ae, me, H, X) {
    oe.writelen = ae, oe.writecb = X, oe.writing = !0, oe.sync = !0, oe.destroyed ? oe.onwrite(new f("write")) : ee ? re._writev(me, oe.onwrite) : re._write(me, H, oe.onwrite), oe.sync = !1;
  }
  function te(re, oe, ee, ae, me) {
    --oe.pendingcb, ee ? (Vt.nextTick(me, ae), Vt.nextTick(O, re, oe), re._writableState.errorEmitted = !0, g(re, ae)) : (me(ae), re._writableState.errorEmitted = !0, g(re, ae), O(re, oe));
  }
  function le(re) {
    re.writing = !1, re.writecb = null, re.length -= re.writelen, re.writelen = 0;
  }
  function ce(re, oe) {
    var ee = re._writableState, ae = ee.sync, me = ee.writecb;
    if (typeof me != "function") throw new m();
    if (le(ee), oe) te(re, ee, ae, oe, me);
    else {
      var H = Ie(ee) || re.destroyed;
      !H && !ee.corked && !ee.bufferProcessing && ee.bufferedRequest && _e(re, ee), ae ? Vt.nextTick(Ee, re, ee, H, me) : Ee(re, ee, H, me);
    }
  }
  function Ee(re, oe, ee, ae) {
    ee || xe(re, oe), oe.pendingcb--, ae(), O(re, oe);
  }
  function xe(re, oe) {
    oe.length === 0 && oe.needDrain && (oe.needDrain = !1, re.emit("drain"));
  }
  function _e(re, oe) {
    oe.bufferProcessing = !0;
    var ee = oe.bufferedRequest;
    if (re._writev && ee && ee.next) {
      var ae = oe.bufferedRequestCount, me = new Array(ae), H = oe.corkedRequestsFree;
      H.entry = ee;
      for (var X = 0, Ae = !0; ee; )
        me[X] = ee, ee.isBuf || (Ae = !1), ee = ee.next, X += 1;
      me.allBuffers = Ae, W(re, oe, !0, oe.length, me, "", H.finish), oe.pendingcb++, oe.lastBufferedRequest = null, H.next ? (oe.corkedRequestsFree = H.next, H.next = null) : oe.corkedRequestsFree = new t(oe), oe.bufferedRequestCount = 0;
    } else {
      for (; ee; ) {
        var Re = ee.chunk, Fe = ee.encoding, Te = ee.callback, qe = oe.objectMode ? 1 : Re.length;
        if (W(re, oe, !1, qe, Re, Fe, Te), ee = ee.next, oe.bufferedRequestCount--, oe.writing)
          break;
      }
      ee === null && (oe.lastBufferedRequest = null);
    }
    oe.bufferedRequest = ee, oe.bufferProcessing = !1;
  }
  R.prototype._write = function(re, oe, ee) {
    ee(new v("_write()"));
  }, R.prototype._writev = null, R.prototype.end = function(re, oe, ee) {
    var ae = this._writableState;
    return typeof re == "function" ? (ee = re, re = null, oe = null) : typeof oe == "function" && (ee = oe, oe = null), re != null && this.write(re, oe), ae.corked && (ae.corked = 1, this.uncork()), ae.ending || N(this, ae, ee), this;
  }, Object.defineProperty(R.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Ie(re) {
    return re.ending && re.length === 0 && re.bufferedRequest === null && !re.finished && !re.writing;
  }
  function je(re, oe) {
    re._final(function(ee) {
      oe.pendingcb--, ee && g(re, ee), oe.prefinished = !0, re.emit("prefinish"), O(re, oe);
    });
  }
  function ue(re, oe) {
    !oe.prefinished && !oe.finalCalled && (typeof re._final == "function" && !oe.destroyed ? (oe.pendingcb++, oe.finalCalled = !0, Vt.nextTick(je, re, oe)) : (oe.prefinished = !0, re.emit("prefinish")));
  }
  function O(re, oe) {
    var ee = Ie(oe);
    if (ee && (ue(re, oe), oe.pendingcb === 0 && (oe.finished = !0, re.emit("finish"), oe.autoDestroy))) {
      var ae = re._readableState;
      (!ae || ae.autoDestroy && ae.endEmitted) && re.destroy();
    }
    return ee;
  }
  function N(re, oe, ee) {
    oe.ending = !0, O(re, oe), ee && (oe.finished ? Vt.nextTick(ee) : re.once("finish", ee)), oe.ended = !0, re.writable = !1;
  }
  function J(re, oe, ee) {
    var ae = re.entry;
    for (re.entry = null; ae; ) {
      var me = ae.callback;
      oe.pendingcb--, me(ee), ae = ae.next;
    }
    oe.corkedRequestsFree.next = re;
  }
  return Object.defineProperty(R.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(re) {
      this._writableState && (this._writableState.destroyed = re);
    }
  }), R.prototype.destroy = l.destroy, R.prototype._undestroy = l.undestroy, R.prototype._destroy = function(re, oe) {
    oe(re);
  }, v3;
}
var b3, hI;
function Zp() {
  if (hI) return b3;
  hI = 1;
  var t = Object.keys || function(c) {
    var p = [];
    for (var h in c) p.push(h);
    return p;
  };
  b3 = o;
  var e = fj(), r = dj();
  Bh()(o, e);
  for (var n = t(r.prototype), i = 0; i < n.length; i++) {
    var s = n[i];
    o.prototype[s] || (o.prototype[s] = r.prototype[s]);
  }
  function o(c) {
    if (!(this instanceof o)) return new o(c);
    e.call(this, c), r.call(this, c), this.allowHalfOpen = !0, c && (c.readable === !1 && (this.readable = !1), c.writable === !1 && (this.writable = !1), c.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a)));
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(o.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(o.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function a() {
    this._writableState.ended || Vt.nextTick(l, this);
  }
  function l(c) {
    c.end();
  }
  return Object.defineProperty(o.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(c) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = c, this._writableState.destroyed = c);
    }
  }), b3;
}
var w3 = {}, x3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var pI;
function t2e() {
  return pI || (pI = 1, function(t, e) {
    var r = Lv(), n = r.Buffer;
    function i(o, a) {
      for (var l in o)
        a[l] = o[l];
    }
    n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (i(r, e), e.Buffer = s);
    function s(o, a, l) {
      return n(o, a, l);
    }
    s.prototype = Object.create(n.prototype), i(n, s), s.from = function(o, a, l) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return n(o, a, l);
    }, s.alloc = function(o, a, l) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var c = n(o);
      return a !== void 0 ? typeof l == "string" ? c.fill(a, l) : c.fill(a) : c.fill(0), c;
    }, s.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return n(o);
    }, s.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(o);
    };
  }(x3, x3.exports)), x3.exports;
}
var dI;
function fI() {
  if (dI) return w3;
  dI = 1;
  var t = t2e().Buffer, e = t.isEncoding || function(E) {
    switch (E = "" + E, E && E.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(E) {
    if (!E) return "utf8";
    for (var A; ; )
      switch (E) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return E;
        default:
          if (A) return;
          E = ("" + E).toLowerCase(), A = !0;
      }
  }
  function n(E) {
    var A = r(E);
    if (typeof A != "string" && (t.isEncoding === e || !e(E))) throw new Error("Unknown encoding: " + E);
    return A || E;
  }
  w3.StringDecoder = i;
  function i(E) {
    this.encoding = n(E);
    var A;
    switch (this.encoding) {
      case "utf16le":
        this.text = h, this.end = d, A = 4;
        break;
      case "utf8":
        this.fillLast = l, A = 4;
        break;
      case "base64":
        this.text = v, this.end = m, A = 3;
        break;
      default:
        this.write = b, this.end = f;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(A);
  }
  i.prototype.write = function(E) {
    if (E.length === 0) return "";
    var A, x;
    if (this.lastNeed) {
      if (A = this.fillLast(E), A === void 0) return "";
      x = this.lastNeed, this.lastNeed = 0;
    } else
      x = 0;
    return x < E.length ? A ? A + this.text(E, x) : this.text(E, x) : A || "";
  }, i.prototype.end = p, i.prototype.text = c, i.prototype.fillLast = function(E) {
    if (this.lastNeed <= E.length)
      return E.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    E.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, E.length), this.lastNeed -= E.length;
  };
  function s(E) {
    return E <= 127 ? 0 : E >> 5 === 6 ? 2 : E >> 4 === 14 ? 3 : E >> 3 === 30 ? 4 : E >> 6 === 2 ? -1 : -2;
  }
  function o(E, A, x) {
    var g = A.length - 1;
    if (g < x) return 0;
    var w = s(A[g]);
    return w >= 0 ? (w > 0 && (E.lastNeed = w - 1), w) : --g < x || w === -2 ? 0 : (w = s(A[g]), w >= 0 ? (w > 0 && (E.lastNeed = w - 2), w) : --g < x || w === -2 ? 0 : (w = s(A[g]), w >= 0 ? (w > 0 && (w === 2 ? w = 0 : E.lastNeed = w - 3), w) : 0));
  }
  function a(E, A, x) {
    if ((A[0] & 192) !== 128)
      return E.lastNeed = 0, "";
    if (E.lastNeed > 1 && A.length > 1) {
      if ((A[1] & 192) !== 128)
        return E.lastNeed = 1, "";
      if (E.lastNeed > 2 && A.length > 2 && (A[2] & 192) !== 128)
        return E.lastNeed = 2, "";
    }
  }
  function l(E) {
    var A = this.lastTotal - this.lastNeed, x = a(this, E);
    if (x !== void 0) return x;
    if (this.lastNeed <= E.length)
      return E.copy(this.lastChar, A, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    E.copy(this.lastChar, A, 0, E.length), this.lastNeed -= E.length;
  }
  function c(E, A) {
    var x = o(this, E, A);
    if (!this.lastNeed) return E.toString("utf8", A);
    this.lastTotal = x;
    var g = E.length - (x - this.lastNeed);
    return E.copy(this.lastChar, 0, g), E.toString("utf8", A, g);
  }
  function p(E) {
    var A = E && E.length ? this.write(E) : "";
    return this.lastNeed ? A + "" : A;
  }
  function h(E, A) {
    if ((E.length - A) % 2 === 0) {
      var x = E.toString("utf16le", A);
      if (x) {
        var g = x.charCodeAt(x.length - 1);
        if (g >= 55296 && g <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = E[E.length - 2], this.lastChar[1] = E[E.length - 1], x.slice(0, -1);
      }
      return x;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = E[E.length - 1], E.toString("utf16le", A, E.length - 1);
  }
  function d(E) {
    var A = E && E.length ? this.write(E) : "";
    if (this.lastNeed) {
      var x = this.lastTotal - this.lastNeed;
      return A + this.lastChar.toString("utf16le", 0, x);
    }
    return A;
  }
  function v(E, A) {
    var x = (E.length - A) % 3;
    return x === 0 ? E.toString("base64", A) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = E[E.length - 1] : (this.lastChar[0] = E[E.length - 2], this.lastChar[1] = E[E.length - 1]), E.toString("base64", A, E.length - x));
  }
  function m(E) {
    var A = E && E.length ? this.write(E) : "";
    return this.lastNeed ? A + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : A;
  }
  function b(E) {
    return E.toString(this.encoding);
  }
  function f(E) {
    return E && E.length ? this.write(E) : "";
  }
  return w3;
}
var E3, gI;
function vS() {
  if (gI) return E3;
  gI = 1;
  var t = Dd().codes.ERR_STREAM_PREMATURE_CLOSE;
  function e(s) {
    var o = !1;
    return function() {
      if (!o) {
        o = !0;
        for (var a = arguments.length, l = new Array(a), c = 0; c < a; c++)
          l[c] = arguments[c];
        s.apply(this, l);
      }
    };
  }
  function r() {
  }
  function n(s) {
    return s.setHeader && typeof s.abort == "function";
  }
  function i(s, o, a) {
    if (typeof o == "function") return i(s, null, o);
    o || (o = {}), a = e(a || r);
    var l = o.readable || o.readable !== !1 && s.readable, c = o.writable || o.writable !== !1 && s.writable, p = function() {
      s.writable || d();
    }, h = s._writableState && s._writableState.finished, d = function() {
      c = !1, h = !0, l || a.call(s);
    }, v = s._readableState && s._readableState.endEmitted, m = function() {
      l = !1, v = !0, c || a.call(s);
    }, b = function(A) {
      a.call(s, A);
    }, f = function() {
      var A;
      if (l && !v)
        return (!s._readableState || !s._readableState.ended) && (A = new t()), a.call(s, A);
      if (c && !h)
        return (!s._writableState || !s._writableState.ended) && (A = new t()), a.call(s, A);
    }, E = function() {
      s.req.on("finish", d);
    };
    return n(s) ? (s.on("complete", d), s.on("abort", f), s.req ? E() : s.on("request", E)) : c && !s._writableState && (s.on("end", p), s.on("close", p)), s.on("end", m), s.on("finish", d), o.error !== !1 && s.on("error", b), s.on("close", f), function() {
      s.removeListener("complete", d), s.removeListener("abort", f), s.removeListener("request", E), s.req && s.req.removeListener("finish", d), s.removeListener("end", p), s.removeListener("close", p), s.removeListener("finish", d), s.removeListener("end", m), s.removeListener("error", b), s.removeListener("close", f);
    };
  }
  return E3 = i, E3;
}
var S3, mI;
function r2e() {
  if (mI) return S3;
  mI = 1;
  var t;
  function e(x, g, w) {
    return g = r(g), g in x ? Object.defineProperty(x, g, { value: w, enumerable: !0, configurable: !0, writable: !0 }) : x[g] = w, x;
  }
  function r(x) {
    var g = n(x, "string");
    return typeof g == "symbol" ? g : String(g);
  }
  function n(x, g) {
    if (typeof x != "object" || x === null) return x;
    var w = x[Symbol.toPrimitive];
    if (w !== void 0) {
      var _ = w.call(x, g);
      if (typeof _ != "object") return _;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (g === "string" ? String : Number)(x);
  }
  var i = vS(), s = Symbol("lastResolve"), o = Symbol("lastReject"), a = Symbol("error"), l = Symbol("ended"), c = Symbol("lastPromise"), p = Symbol("handlePromise"), h = Symbol("stream");
  function d(x, g) {
    return {
      value: x,
      done: g
    };
  }
  function v(x) {
    var g = x[s];
    if (g !== null) {
      var w = x[h].read();
      w !== null && (x[c] = null, x[s] = null, x[o] = null, g(d(w, !1)));
    }
  }
  function m(x) {
    Vt.nextTick(v, x);
  }
  function b(x, g) {
    return function(w, _) {
      x.then(function() {
        if (g[l]) {
          w(d(void 0, !0));
          return;
        }
        g[p](w, _);
      }, _);
    };
  }
  var f = Object.getPrototypeOf(function() {
  }), E = Object.setPrototypeOf((t = {
    get stream() {
      return this[h];
    },
    next: function() {
      var x = this, g = this[a];
      if (g !== null)
        return Promise.reject(g);
      if (this[l])
        return Promise.resolve(d(void 0, !0));
      if (this[h].destroyed)
        return new Promise(function(R, L) {
          Vt.nextTick(function() {
            x[a] ? L(x[a]) : R(d(void 0, !0));
          });
        });
      var w = this[c], _;
      if (w)
        _ = new Promise(b(w, this));
      else {
        var S = this[h].read();
        if (S !== null)
          return Promise.resolve(d(S, !1));
        _ = new Promise(this[p]);
      }
      return this[c] = _, _;
    }
  }, e(t, Symbol.asyncIterator, function() {
    return this;
  }), e(t, "return", function() {
    var x = this;
    return new Promise(function(g, w) {
      x[h].destroy(null, function(_) {
        if (_) {
          w(_);
          return;
        }
        g(d(void 0, !0));
      });
    });
  }), t), f), A = function(x) {
    var g, w = Object.create(E, (g = {}, e(g, h, {
      value: x,
      writable: !0
    }), e(g, s, {
      value: null,
      writable: !0
    }), e(g, o, {
      value: null,
      writable: !0
    }), e(g, a, {
      value: null,
      writable: !0
    }), e(g, l, {
      value: x._readableState.endEmitted,
      writable: !0
    }), e(g, p, {
      value: function(_, S) {
        var R = w[h].read();
        R ? (w[c] = null, w[s] = null, w[o] = null, _(d(R, !1))) : (w[s] = _, w[o] = S);
      },
      writable: !0
    }), g));
    return w[c] = null, i(x, function(_) {
      if (_ && _.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var S = w[o];
        S !== null && (w[c] = null, w[s] = null, w[o] = null, S(_)), w[a] = _;
        return;
      }
      var R = w[s];
      R !== null && (w[c] = null, w[s] = null, w[o] = null, R(d(void 0, !0))), w[l] = !0;
    }), x.on("readable", m.bind(null, w)), w;
  };
  return S3 = A, S3;
}
var yI, vI;
function n2e() {
  return vI || (vI = 1, yI = function() {
    throw new Error("Readable.from is not available in the browser");
  }), yI;
}
var A3, bI;
function fj() {
  if (bI) return A3;
  bI = 1, A3 = L;
  var t;
  L.ReadableState = R, fS().EventEmitter;
  var e = function(H, X) {
    return H.listeners(X).length;
  }, r = X$(), n = Lv().Buffer, i = (typeof Xl < "u" ? Xl : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function s(H) {
    return n.from(H);
  }
  function o(H) {
    return n.isBuffer(H) || H instanceof i;
  }
  var a = uj(), l;
  a && a.debuglog ? l = a.debuglog("stream") : l = function() {
  };
  var c = Xye(), p = hj(), h = pj(), d = h.getHighWaterMark, v = Dd().codes, m = v.ERR_INVALID_ARG_TYPE, b = v.ERR_STREAM_PUSH_AFTER_EOF, f = v.ERR_METHOD_NOT_IMPLEMENTED, E = v.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, A, x, g;
  Bh()(L, r);
  var w = p.errorOrDestroy, _ = ["error", "close", "destroy", "pause", "resume"];
  function S(H, X, Ae) {
    if (typeof H.prependListener == "function") return H.prependListener(X, Ae);
    !H._events || !H._events[X] ? H.on(X, Ae) : Array.isArray(H._events[X]) ? H._events[X].unshift(Ae) : H._events[X] = [Ae, H._events[X]];
  }
  function R(H, X, Ae) {
    t = t || Zp(), H = H || {}, typeof Ae != "boolean" && (Ae = X instanceof t), this.objectMode = !!H.objectMode, Ae && (this.objectMode = this.objectMode || !!H.readableObjectMode), this.highWaterMark = d(this, H, "readableHighWaterMark", Ae), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = H.emitClose !== !1, this.autoDestroy = !!H.autoDestroy, this.destroyed = !1, this.defaultEncoding = H.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, H.encoding && (A || (A = fI().StringDecoder), this.decoder = new A(H.encoding), this.encoding = H.encoding);
  }
  function L(H) {
    if (t = t || Zp(), !(this instanceof L)) return new L(H);
    var X = this instanceof t;
    this._readableState = new R(H, this, X), this.readable = !0, H && (typeof H.read == "function" && (this._read = H.read), typeof H.destroy == "function" && (this._destroy = H.destroy)), r.call(this);
  }
  Object.defineProperty(L.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(H) {
      this._readableState && (this._readableState.destroyed = H);
    }
  }), L.prototype.destroy = p.destroy, L.prototype._undestroy = p.undestroy, L.prototype._destroy = function(H, X) {
    X(H);
  }, L.prototype.push = function(H, X) {
    var Ae = this._readableState, Re;
    return Ae.objectMode ? Re = !0 : typeof H == "string" && (X = X || Ae.defaultEncoding, X !== Ae.encoding && (H = n.from(H, X), X = ""), Re = !0), F(this, H, X, !1, Re);
  }, L.prototype.unshift = function(H) {
    return F(this, H, null, !0, !1);
  };
  function F(H, X, Ae, Re, Fe) {
    l("readableAddChunk", X);
    var Te = H._readableState;
    if (X === null)
      Te.reading = !1, ce(H, Te);
    else {
      var qe;
      if (Fe || (qe = j(Te, X)), qe)
        w(H, qe);
      else if (Te.objectMode || X && X.length > 0)
        if (typeof X != "string" && !Te.objectMode && Object.getPrototypeOf(X) !== n.prototype && (X = s(X)), Re)
          Te.endEmitted ? w(H, new E()) : z(H, Te, X, !0);
        else if (Te.ended)
          w(H, new b());
        else {
          if (Te.destroyed)
            return !1;
          Te.reading = !1, Te.decoder && !Ae ? (X = Te.decoder.write(X), Te.objectMode || X.length !== 0 ? z(H, Te, X, !1) : _e(H, Te)) : z(H, Te, X, !1);
        }
      else Re || (Te.reading = !1, _e(H, Te));
    }
    return !Te.ended && (Te.length < Te.highWaterMark || Te.length === 0);
  }
  function z(H, X, Ae, Re) {
    X.flowing && X.length === 0 && !X.sync ? (X.awaitDrain = 0, H.emit("data", Ae)) : (X.length += X.objectMode ? 1 : Ae.length, Re ? X.buffer.unshift(Ae) : X.buffer.push(Ae), X.needReadable && Ee(H)), _e(H, X);
  }
  function j(H, X) {
    var Ae;
    return !o(X) && typeof X != "string" && X !== void 0 && !H.objectMode && (Ae = new m("chunk", ["string", "Buffer", "Uint8Array"], X)), Ae;
  }
  L.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, L.prototype.setEncoding = function(H) {
    A || (A = fI().StringDecoder);
    var X = new A(H);
    this._readableState.decoder = X, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Ae = this._readableState.buffer.head, Re = ""; Ae !== null; )
      Re += X.write(Ae.data), Ae = Ae.next;
    return this._readableState.buffer.clear(), Re !== "" && this._readableState.buffer.push(Re), this._readableState.length = Re.length, this;
  };
  var W = 1073741824;
  function te(H) {
    return H >= W ? H = W : (H--, H |= H >>> 1, H |= H >>> 2, H |= H >>> 4, H |= H >>> 8, H |= H >>> 16, H++), H;
  }
  function le(H, X) {
    return H <= 0 || X.length === 0 && X.ended ? 0 : X.objectMode ? 1 : H !== H ? X.flowing && X.length ? X.buffer.head.data.length : X.length : (H > X.highWaterMark && (X.highWaterMark = te(H)), H <= X.length ? H : X.ended ? X.length : (X.needReadable = !0, 0));
  }
  L.prototype.read = function(H) {
    l("read", H), H = parseInt(H, 10);
    var X = this._readableState, Ae = H;
    if (H !== 0 && (X.emittedReadable = !1), H === 0 && X.needReadable && ((X.highWaterMark !== 0 ? X.length >= X.highWaterMark : X.length > 0) || X.ended))
      return l("read: emitReadable", X.length, X.ended), X.length === 0 && X.ended ? ee(this) : Ee(this), null;
    if (H = le(H, X), H === 0 && X.ended)
      return X.length === 0 && ee(this), null;
    var Re = X.needReadable;
    l("need readable", Re), (X.length === 0 || X.length - H < X.highWaterMark) && (Re = !0, l("length less than watermark", Re)), X.ended || X.reading ? (Re = !1, l("reading or ended", Re)) : Re && (l("do read"), X.reading = !0, X.sync = !0, X.length === 0 && (X.needReadable = !0), this._read(X.highWaterMark), X.sync = !1, X.reading || (H = le(Ae, X)));
    var Fe;
    return H > 0 ? Fe = oe(H, X) : Fe = null, Fe === null ? (X.needReadable = X.length <= X.highWaterMark, H = 0) : (X.length -= H, X.awaitDrain = 0), X.length === 0 && (X.ended || (X.needReadable = !0), Ae !== H && X.ended && ee(this)), Fe !== null && this.emit("data", Fe), Fe;
  };
  function ce(H, X) {
    if (l("onEofChunk"), !X.ended) {
      if (X.decoder) {
        var Ae = X.decoder.end();
        Ae && Ae.length && (X.buffer.push(Ae), X.length += X.objectMode ? 1 : Ae.length);
      }
      X.ended = !0, X.sync ? Ee(H) : (X.needReadable = !1, X.emittedReadable || (X.emittedReadable = !0, xe(H)));
    }
  }
  function Ee(H) {
    var X = H._readableState;
    l("emitReadable", X.needReadable, X.emittedReadable), X.needReadable = !1, X.emittedReadable || (l("emitReadable", X.flowing), X.emittedReadable = !0, Vt.nextTick(xe, H));
  }
  function xe(H) {
    var X = H._readableState;
    l("emitReadable_", X.destroyed, X.length, X.ended), !X.destroyed && (X.length || X.ended) && (H.emit("readable"), X.emittedReadable = !1), X.needReadable = !X.flowing && !X.ended && X.length <= X.highWaterMark, re(H);
  }
  function _e(H, X) {
    X.readingMore || (X.readingMore = !0, Vt.nextTick(Ie, H, X));
  }
  function Ie(H, X) {
    for (; !X.reading && !X.ended && (X.length < X.highWaterMark || X.flowing && X.length === 0); ) {
      var Ae = X.length;
      if (l("maybeReadMore read 0"), H.read(0), Ae === X.length)
        break;
    }
    X.readingMore = !1;
  }
  L.prototype._read = function(H) {
    w(this, new f("_read()"));
  }, L.prototype.pipe = function(H, X) {
    var Ae = this, Re = this._readableState;
    switch (Re.pipesCount) {
      case 0:
        Re.pipes = H;
        break;
      case 1:
        Re.pipes = [Re.pipes, H];
        break;
      default:
        Re.pipes.push(H);
        break;
    }
    Re.pipesCount += 1, l("pipe count=%d opts=%j", Re.pipesCount, X);
    var Fe = (!X || X.end !== !1) && H !== Vt.stdout && H !== Vt.stderr, Te = Fe ? tt : Ze;
    Re.endEmitted ? Vt.nextTick(Te) : Ae.once("end", Te), H.on("unpipe", qe);
    function qe(fe, ye) {
      l("onunpipe"), fe === Ae && ye && ye.hasUnpiped === !1 && (ye.hasUnpiped = !0, er());
    }
    function tt() {
      l("onend"), H.end();
    }
    var Pe = je(Ae);
    H.on("drain", Pe);
    var At = !1;
    function er() {
      l("cleanup"), H.removeListener("close", it), H.removeListener("finish", kt), H.removeListener("drain", Pe), H.removeListener("error", ht), H.removeListener("unpipe", qe), Ae.removeListener("end", tt), Ae.removeListener("end", Ze), Ae.removeListener("data", ge), At = !0, Re.awaitDrain && (!H._writableState || H._writableState.needDrain) && Pe();
    }
    Ae.on("data", ge);
    function ge(fe) {
      l("ondata");
      var ye = H.write(fe);
      l("dest.write", ye), ye === !1 && ((Re.pipesCount === 1 && Re.pipes === H || Re.pipesCount > 1 && me(Re.pipes, H) !== -1) && !At && (l("false write response, pause", Re.awaitDrain), Re.awaitDrain++), Ae.pause());
    }
    function ht(fe) {
      l("onerror", fe), Ze(), H.removeListener("error", ht), e(H, "error") === 0 && w(H, fe);
    }
    S(H, "error", ht);
    function it() {
      H.removeListener("finish", kt), Ze();
    }
    H.once("close", it);
    function kt() {
      l("onfinish"), H.removeListener("close", it), Ze();
    }
    H.once("finish", kt);
    function Ze() {
      l("unpipe"), Ae.unpipe(H);
    }
    return H.emit("pipe", Ae), Re.flowing || (l("pipe resume"), Ae.resume()), H;
  };
  function je(H) {
    return function() {
      var X = H._readableState;
      l("pipeOnDrain", X.awaitDrain), X.awaitDrain && X.awaitDrain--, X.awaitDrain === 0 && e(H, "data") && (X.flowing = !0, re(H));
    };
  }
  L.prototype.unpipe = function(H) {
    var X = this._readableState, Ae = {
      hasUnpiped: !1
    };
    if (X.pipesCount === 0) return this;
    if (X.pipesCount === 1)
      return H && H !== X.pipes ? this : (H || (H = X.pipes), X.pipes = null, X.pipesCount = 0, X.flowing = !1, H && H.emit("unpipe", this, Ae), this);
    if (!H) {
      var Re = X.pipes, Fe = X.pipesCount;
      X.pipes = null, X.pipesCount = 0, X.flowing = !1;
      for (var Te = 0; Te < Fe; Te++) Re[Te].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var qe = me(X.pipes, H);
    return qe === -1 ? this : (X.pipes.splice(qe, 1), X.pipesCount -= 1, X.pipesCount === 1 && (X.pipes = X.pipes[0]), H.emit("unpipe", this, Ae), this);
  }, L.prototype.on = function(H, X) {
    var Ae = r.prototype.on.call(this, H, X), Re = this._readableState;
    return H === "data" ? (Re.readableListening = this.listenerCount("readable") > 0, Re.flowing !== !1 && this.resume()) : H === "readable" && !Re.endEmitted && !Re.readableListening && (Re.readableListening = Re.needReadable = !0, Re.flowing = !1, Re.emittedReadable = !1, l("on readable", Re.length, Re.reading), Re.length ? Ee(this) : Re.reading || Vt.nextTick(O, this)), Ae;
  }, L.prototype.addListener = L.prototype.on, L.prototype.removeListener = function(H, X) {
    var Ae = r.prototype.removeListener.call(this, H, X);
    return H === "readable" && Vt.nextTick(ue, this), Ae;
  }, L.prototype.removeAllListeners = function(H) {
    var X = r.prototype.removeAllListeners.apply(this, arguments);
    return (H === "readable" || H === void 0) && Vt.nextTick(ue, this), X;
  };
  function ue(H) {
    var X = H._readableState;
    X.readableListening = H.listenerCount("readable") > 0, X.resumeScheduled && !X.paused ? X.flowing = !0 : H.listenerCount("data") > 0 && H.resume();
  }
  function O(H) {
    l("readable nexttick read 0"), H.read(0);
  }
  L.prototype.resume = function() {
    var H = this._readableState;
    return H.flowing || (l("resume"), H.flowing = !H.readableListening, N(this, H)), H.paused = !1, this;
  };
  function N(H, X) {
    X.resumeScheduled || (X.resumeScheduled = !0, Vt.nextTick(J, H, X));
  }
  function J(H, X) {
    l("resume", X.reading), X.reading || H.read(0), X.resumeScheduled = !1, H.emit("resume"), re(H), X.flowing && !X.reading && H.read(0);
  }
  L.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function re(H) {
    var X = H._readableState;
    for (l("flow", X.flowing); X.flowing && H.read() !== null; ) ;
  }
  L.prototype.wrap = function(H) {
    var X = this, Ae = this._readableState, Re = !1;
    H.on("end", function() {
      if (l("wrapped end"), Ae.decoder && !Ae.ended) {
        var qe = Ae.decoder.end();
        qe && qe.length && X.push(qe);
      }
      X.push(null);
    }), H.on("data", function(qe) {
      if (l("wrapped data"), Ae.decoder && (qe = Ae.decoder.write(qe)), !(Ae.objectMode && qe == null) && !(!Ae.objectMode && (!qe || !qe.length))) {
        var tt = X.push(qe);
        tt || (Re = !0, H.pause());
      }
    });
    for (var Fe in H)
      this[Fe] === void 0 && typeof H[Fe] == "function" && (this[Fe] = /* @__PURE__ */ function(qe) {
        return function() {
          return H[qe].apply(H, arguments);
        };
      }(Fe));
    for (var Te = 0; Te < _.length; Te++)
      H.on(_[Te], this.emit.bind(this, _[Te]));
    return this._read = function(qe) {
      l("wrapped _read", qe), Re && (Re = !1, H.resume());
    }, this;
  }, typeof Symbol == "function" && (L.prototype[Symbol.asyncIterator] = function() {
    return x === void 0 && (x = r2e()), x(this);
  }), Object.defineProperty(L.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(L.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(L.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(H) {
      this._readableState && (this._readableState.flowing = H);
    }
  }), L._fromList = oe, Object.defineProperty(L.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function oe(H, X) {
    if (X.length === 0) return null;
    var Ae;
    return X.objectMode ? Ae = X.buffer.shift() : !H || H >= X.length ? (X.decoder ? Ae = X.buffer.join("") : X.buffer.length === 1 ? Ae = X.buffer.first() : Ae = X.buffer.concat(X.length), X.buffer.clear()) : Ae = X.buffer.consume(H, X.decoder), Ae;
  }
  function ee(H) {
    var X = H._readableState;
    l("endReadable", X.endEmitted), X.endEmitted || (X.ended = !0, Vt.nextTick(ae, X, H));
  }
  function ae(H, X) {
    if (l("endReadableNT", H.endEmitted, H.length), !H.endEmitted && H.length === 0 && (H.endEmitted = !0, X.readable = !1, X.emit("end"), H.autoDestroy)) {
      var Ae = X._writableState;
      (!Ae || Ae.autoDestroy && Ae.finished) && X.destroy();
    }
  }
  typeof Symbol == "function" && (L.from = function(H, X) {
    return g === void 0 && (g = n2e()), g(L, H, X);
  });
  function me(H, X) {
    for (var Ae = 0, Re = H.length; Ae < Re; Ae++)
      if (H[Ae] === X) return Ae;
    return -1;
  }
  return A3;
}
var k3, wI;
function gj() {
  if (wI) return k3;
  wI = 1, k3 = a;
  var t = Dd().codes, e = t.ERR_METHOD_NOT_IMPLEMENTED, r = t.ERR_MULTIPLE_CALLBACK, n = t.ERR_TRANSFORM_ALREADY_TRANSFORMING, i = t.ERR_TRANSFORM_WITH_LENGTH_0, s = Zp();
  Bh()(a, s);
  function o(p, h) {
    var d = this._transformState;
    d.transforming = !1;
    var v = d.writecb;
    if (v === null)
      return this.emit("error", new r());
    d.writechunk = null, d.writecb = null, h != null && this.push(h), v(p);
    var m = this._readableState;
    m.reading = !1, (m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark);
  }
  function a(p) {
    if (!(this instanceof a)) return new a(p);
    s.call(this, p), this._transformState = {
      afterTransform: o.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, p && (typeof p.transform == "function" && (this._transform = p.transform), typeof p.flush == "function" && (this._flush = p.flush)), this.on("prefinish", l);
  }
  function l() {
    var p = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(h, d) {
      c(p, h, d);
    }) : c(this, null, null);
  }
  a.prototype.push = function(p, h) {
    return this._transformState.needTransform = !1, s.prototype.push.call(this, p, h);
  }, a.prototype._transform = function(p, h, d) {
    d(new e("_transform()"));
  }, a.prototype._write = function(p, h, d) {
    var v = this._transformState;
    if (v.writecb = d, v.writechunk = p, v.writeencoding = h, !v.transforming) {
      var m = this._readableState;
      (v.needTransform || m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark);
    }
  }, a.prototype._read = function(p) {
    var h = this._transformState;
    h.writechunk !== null && !h.transforming ? (h.transforming = !0, this._transform(h.writechunk, h.writeencoding, h.afterTransform)) : h.needTransform = !0;
  }, a.prototype._destroy = function(p, h) {
    s.prototype._destroy.call(this, p, function(d) {
      h(d);
    });
  };
  function c(p, h, d) {
    if (h) return p.emit("error", h);
    if (d != null && p.push(d), p._writableState.length) throw new i();
    if (p._transformState.transforming) throw new n();
    return p.push(null);
  }
  return k3;
}
var _3, xI;
function i2e() {
  if (xI) return _3;
  xI = 1, _3 = e;
  var t = gj();
  Bh()(e, t);
  function e(r) {
    if (!(this instanceof e)) return new e(r);
    t.call(this, r);
  }
  return e.prototype._transform = function(r, n, i) {
    i(null, r);
  }, _3;
}
var C3, EI;
function s2e() {
  if (EI) return C3;
  EI = 1;
  var t;
  function e(d) {
    var v = !1;
    return function() {
      v || (v = !0, d.apply(void 0, arguments));
    };
  }
  var r = Dd().codes, n = r.ERR_MISSING_ARGS, i = r.ERR_STREAM_DESTROYED;
  function s(d) {
    if (d) throw d;
  }
  function o(d) {
    return d.setHeader && typeof d.abort == "function";
  }
  function a(d, v, m, b) {
    b = e(b);
    var f = !1;
    d.on("close", function() {
      f = !0;
    }), t === void 0 && (t = vS()), t(d, {
      readable: v,
      writable: m
    }, function(A) {
      if (A) return b(A);
      f = !0, b();
    });
    var E = !1;
    return function(A) {
      if (!f && !E) {
        if (E = !0, o(d)) return d.abort();
        if (typeof d.destroy == "function") return d.destroy();
        b(A || new i("pipe"));
      }
    };
  }
  function l(d) {
    d();
  }
  function c(d, v) {
    return d.pipe(v);
  }
  function p(d) {
    return !d.length || typeof d[d.length - 1] != "function" ? s : d.pop();
  }
  function h() {
    for (var d = arguments.length, v = new Array(d), m = 0; m < d; m++)
      v[m] = arguments[m];
    var b = p(v);
    if (Array.isArray(v[0]) && (v = v[0]), v.length < 2)
      throw new n("streams");
    var f, E = v.map(function(A, x) {
      var g = x < v.length - 1, w = x > 0;
      return a(A, g, w, function(_) {
        f || (f = _), _ && E.forEach(l), !g && (E.forEach(l), b(f));
      });
    });
    return v.reduce(c);
  }
  return C3 = h, C3;
}
var I3, SI;
function o2e() {
  if (SI) return I3;
  SI = 1, I3 = r;
  var t = fS().EventEmitter, e = Bh();
  e(r, t), r.Readable = fj(), r.Writable = dj(), r.Duplex = Zp(), r.Transform = gj(), r.PassThrough = i2e(), r.finished = vS(), r.pipeline = s2e(), r.Stream = r;
  function r() {
    t.call(this);
  }
  return r.prototype.pipe = function(n, i) {
    var s = this;
    function o(v) {
      n.writable && n.write(v) === !1 && s.pause && s.pause();
    }
    s.on("data", o);
    function a() {
      s.readable && s.resume && s.resume();
    }
    n.on("drain", a), !n._isStdio && (!i || i.end !== !1) && (s.on("end", c), s.on("close", p));
    var l = !1;
    function c() {
      l || (l = !0, n.end());
    }
    function p() {
      l || (l = !0, typeof n.destroy == "function" && n.destroy());
    }
    function h(v) {
      if (d(), t.listenerCount(this, "error") === 0)
        throw v;
    }
    s.on("error", h), n.on("error", h);
    function d() {
      s.removeListener("data", o), n.removeListener("drain", a), s.removeListener("end", c), s.removeListener("close", p), s.removeListener("error", h), n.removeListener("error", h), s.removeListener("end", d), s.removeListener("close", d), n.removeListener("close", d);
    }
    return s.on("end", d), s.on("close", d), n.on("close", d), n.emit("pipe", s), n;
  }, I3;
}
var P3, AI;
function a2e() {
  if (AI) return P3;
  AI = 1;
  const t = (e, r) => {
    if (r.length <= 0 || e.length <= 0 || e.equals(r))
      return !1;
    for (let n = 1; n <= Math.min(e.length, r.length - 1); n++) {
      const i = e.subarray(e.length - n, e.length);
      if (r.compare(
        i,
        0,
        i.length,
        0,
        n
      ) === 0)
        return !0;
    }
    return !1;
  };
  return P3 = (e, ...r) => r.some((n) => t(e, n)), P3;
}
var R3, kI;
function l2e() {
  if (kI) return R3;
  kI = 1;
  const t = o2e(), e = Q$(), r = a2e();
  let n = ju.alloc(0);
  return R3 = (...i) => (s = "utf-8") => {
    const o = i.map((a) => ju.from(a, s));
    return new t.Transform({
      transform(a, l, c) {
        n = ju.concat([n, a]), r(n, ...o) || (e(n, ...o).forEach((p) => this.push(p)), n = ju.alloc(0)), c();
      }
    });
  }, R3;
}
var _I;
function c2e() {
  if (_I) return Um;
  _I = 1;
  const t = Q$(), e = l2e();
  return Um.tokenator = t, Um.tokenatorStream = e, Um;
}
var u2e = c2e();
let h2e = class {
  constructor(e, r) {
    this.delimiterStart = e, this.delimiterEnd = r;
  }
  capitalize(e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
  }
  join(e, r) {
    if (e.length === 0)
      return "";
    const n = e.toReversed();
    let i = n.shift(), s = !1;
    for (const o of n)
      s ? i = ", " + i : (i = (n.length === 1 ? " and " : ", and ") + i, s = !0), i = o + i;
    return r && (i = this.capitalize(i)), i;
  }
  parseSlot(e) {
    if (!e)
      throw new Error("Empty Slot");
    const r = e.match(/:/g);
    if (!r || r.length !== 1)
      throw new Error("Type Error in Slot");
    const n = e.split(":"), i = n[0], s = n[1], o = s.match(/#/g);
    let a;
    if (o) {
      if (o.length !== 1)
        throw new Error("Format Error in Slot");
      a = s.split("#")[1];
    }
    return { type: "slot", text: i, format: a };
  }
  parse(e) {
    const r = [], n = u2e.tokenator(e, this.delimiterStart, this.delimiterEnd);
    let i = "ground", s = "";
    for (const o of n)
      o === this.delimiterStart ? i === "ground" ? (s && (r.push({ type: "ground", text: s }), s = ""), i = "slot") : s += o : o === this.delimiterEnd && i === "slot" ? (r.push(this.parseSlot(s)), s = "", i = "ground") : s += o;
    if (i === "slot")
      throw new Error("missing delimiter");
    return s && r.push({ type: "ground", text: s }), r;
  }
  resolve(e, r) {
    let n = "";
    for (const i of e)
      if (i.type === "ground")
        n += i.text;
      else {
        const s = r[i.text];
        let o;
        if (Array.isArray(s) ? o = this.join(s) : typeof s > "u" ? o = "" : o = s.toString(), i.format)
          if (i.format === "cap")
            o = o.charAt(0).toUpperCase() + o.slice(1);
          else if (/^\.\d+$/.test(i.format))
            if (typeof s == "number") {
              const a = parseInt(i.format.slice(1));
              o = s.toFixed(a);
            } else
              throw new Error("[templum]: Decimal place format specifier can only be applied to numbers.");
          else
            throw new Error(`[templum]: Unknown format specifier '${i.format}'`);
        n += o;
      }
    return n;
  }
  interpolate(e, r) {
    return this.resolve(this.parse(e), r);
  }
};
const Jp = new h2e("${", "}"), p2e = Jp.capitalize.bind(Jp), d2e = Jp.join.bind(Jp), qn = Jp.interpolate.bind(Jp);
var f2e = Object.defineProperty, g2e = (t, e, r) => e in t ? f2e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ut = (t, e, r) => g2e(t, typeof e != "symbol" ? e + "" : e, r);
function Wr(t, e) {
  return e === "raw" || e === "statusBar" ? t.raw : e === "domId" ? Yn(t.raw) : t.value.toString();
}
function Zf(t, e) {
  return Wr(t.facetBox("x"), e);
}
function bS(t, e) {
  return Wr(t.facetBox("y"), e);
}
function L0(t, e) {
  const r = Zf(t, e), n = bS(t, e);
  return `${r}, ${n}`;
}
function m2e(t, e) {
  return [...t.entries()].map(([r, n]) => Wr(n, e)).join(", ");
}
var CI = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function y2e(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Hm(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var mj = { exports: {} };
/*! jsonpath 1.1.1 */
(function(t, e) {
  (function(r) {
    t.exports = r();
  })(function() {
    return function r(n, i, s) {
      function o(c, p) {
        if (!i[c]) {
          if (!n[c]) {
            var h = typeof Hm == "function" && Hm;
            if (!p && h) return h(c, !0);
            if (a) return a(c, !0);
            var d = new Error("Cannot find module '" + c + "'");
            throw d.code = "MODULE_NOT_FOUND", d;
          }
          var v = i[c] = { exports: {} };
          n[c][0].call(v.exports, function(m) {
            var b = n[c][1][m];
            return o(b || m);
          }, v, v.exports, r, n, i, s);
        }
        return i[c].exports;
      }
      for (var a = typeof Hm == "function" && Hm, l = 0; l < s.length; l++) o(s[l]);
      return o;
    }({ "./aesprim": [function(r, n, i) {
      (function(s, o) {
        o(typeof i < "u" ? i : s.esprima = {});
      })(this, function(s) {
        var o, a, l, c, p, h, d, v, m, b, f, E, A, x, g, w, _, S;
        o = {
          BooleanLiteral: 1,
          EOF: 2,
          Identifier: 3,
          Keyword: 4,
          NullLiteral: 5,
          NumericLiteral: 6,
          Punctuator: 7,
          StringLiteral: 8,
          RegularExpression: 9
        }, a = {}, a[o.BooleanLiteral] = "Boolean", a[o.EOF] = "<end>", a[o.Identifier] = "Identifier", a[o.Keyword] = "Keyword", a[o.NullLiteral] = "Null", a[o.NumericLiteral] = "Numeric", a[o.Punctuator] = "Punctuator", a[o.StringLiteral] = "String", a[o.RegularExpression] = "RegularExpression", l = [
          "(",
          "{",
          "[",
          "in",
          "typeof",
          "instanceof",
          "new",
          "return",
          "case",
          "delete",
          "throw",
          "void",
          // assignment operators
          "=",
          "+=",
          "-=",
          "*=",
          "/=",
          "%=",
          "<<=",
          ">>=",
          ">>>=",
          "&=",
          "|=",
          "^=",
          ",",
          // binary/unary operators
          "+",
          "-",
          "*",
          "/",
          "%",
          "++",
          "--",
          "<<",
          ">>",
          ">>>",
          "&",
          "|",
          "^",
          "!",
          "~",
          "&&",
          "||",
          "?",
          ":",
          "===",
          "==",
          ">=",
          "<=",
          "<",
          ">",
          "!=",
          "!=="
        ], c = {
          AssignmentExpression: "AssignmentExpression",
          ArrayExpression: "ArrayExpression",
          BlockStatement: "BlockStatement",
          BinaryExpression: "BinaryExpression",
          BreakStatement: "BreakStatement",
          CallExpression: "CallExpression",
          CatchClause: "CatchClause",
          ConditionalExpression: "ConditionalExpression",
          ContinueStatement: "ContinueStatement",
          DoWhileStatement: "DoWhileStatement",
          DebuggerStatement: "DebuggerStatement",
          EmptyStatement: "EmptyStatement",
          ExpressionStatement: "ExpressionStatement",
          ForStatement: "ForStatement",
          ForInStatement: "ForInStatement",
          FunctionDeclaration: "FunctionDeclaration",
          FunctionExpression: "FunctionExpression",
          Identifier: "Identifier",
          IfStatement: "IfStatement",
          Literal: "Literal",
          LabeledStatement: "LabeledStatement",
          LogicalExpression: "LogicalExpression",
          MemberExpression: "MemberExpression",
          NewExpression: "NewExpression",
          ObjectExpression: "ObjectExpression",
          Program: "Program",
          Property: "Property",
          ReturnStatement: "ReturnStatement",
          SequenceExpression: "SequenceExpression",
          SwitchStatement: "SwitchStatement",
          SwitchCase: "SwitchCase",
          ThisExpression: "ThisExpression",
          ThrowStatement: "ThrowStatement",
          TryStatement: "TryStatement",
          UnaryExpression: "UnaryExpression",
          UpdateExpression: "UpdateExpression",
          VariableDeclaration: "VariableDeclaration",
          VariableDeclarator: "VariableDeclarator",
          WhileStatement: "WhileStatement",
          WithStatement: "WithStatement"
        }, p = {
          Data: 1,
          Get: 2,
          Set: 4
        }, h = {
          UnexpectedToken: "Unexpected token %0",
          UnexpectedNumber: "Unexpected number",
          UnexpectedString: "Unexpected string",
          UnexpectedIdentifier: "Unexpected identifier",
          UnexpectedReserved: "Unexpected reserved word",
          UnexpectedEOS: "Unexpected end of input",
          NewlineAfterThrow: "Illegal newline after throw",
          InvalidRegExp: "Invalid regular expression",
          UnterminatedRegExp: "Invalid regular expression: missing /",
          InvalidLHSInAssignment: "Invalid left-hand side in assignment",
          InvalidLHSInForIn: "Invalid left-hand side in for-in",
          MultipleDefaultsInSwitch: "More than one default clause in switch statement",
          NoCatchOrFinally: "Missing catch or finally after try",
          UnknownLabel: "Undefined label '%0'",
          Redeclaration: "%0 '%1' has already been declared",
          IllegalContinue: "Illegal continue statement",
          IllegalBreak: "Illegal break statement",
          IllegalReturn: "Illegal return statement",
          StrictModeWith: "Strict mode code may not include a with statement",
          StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
          StrictVarName: "Variable name may not be eval or arguments in strict mode",
          StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
          StrictParamDupe: "Strict mode function may not have duplicate parameter names",
          StrictFunctionName: "Function name may not be eval or arguments in strict mode",
          StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
          StrictDelete: "Delete of an unqualified identifier in strict mode.",
          StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
          AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
          AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
          StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
          StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
          StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
          StrictReservedWord: "Use of future reserved word in strict mode"
        }, d = {
          NonAsciiIdentifierStart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]"),
          NonAsciiIdentifierPart: new RegExp("[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]")
        };
        function R(u, y) {
          if (!u)
            throw new Error("ASSERT: " + y);
        }
        function L(u) {
          return u >= 48 && u <= 57;
        }
        function F(u) {
          return "0123456789abcdefABCDEF".indexOf(u) >= 0;
        }
        function z(u) {
          return "01234567".indexOf(u) >= 0;
        }
        function j(u) {
          return u === 32 || u === 9 || u === 11 || u === 12 || u === 160 || u >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(u) >= 0;
        }
        function W(u) {
          return u === 10 || u === 13 || u === 8232 || u === 8233;
        }
        function te(u) {
          return u == 64 || u === 36 || u === 95 || // $ (dollar) and _ (underscore)
          u >= 65 && u <= 90 || // A..Z
          u >= 97 && u <= 122 || // a..z
          u === 92 || // \ (backslash)
          u >= 128 && d.NonAsciiIdentifierStart.test(String.fromCharCode(u));
        }
        function le(u) {
          return u === 36 || u === 95 || // $ (dollar) and _ (underscore)
          u >= 65 && u <= 90 || // A..Z
          u >= 97 && u <= 122 || // a..z
          u >= 48 && u <= 57 || // 0..9
          u === 92 || // \ (backslash)
          u >= 128 && d.NonAsciiIdentifierPart.test(String.fromCharCode(u));
        }
        function ce(u) {
          switch (u) {
            case "class":
            case "enum":
            case "export":
            case "extends":
            case "import":
            case "super":
              return !0;
            default:
              return !1;
          }
        }
        function Ee(u) {
          switch (u) {
            case "implements":
            case "interface":
            case "package":
            case "private":
            case "protected":
            case "public":
            case "static":
            case "yield":
            case "let":
              return !0;
            default:
              return !1;
          }
        }
        function xe(u) {
          return u === "eval" || u === "arguments";
        }
        function _e(u) {
          if (b && Ee(u))
            return !0;
          switch (u.length) {
            case 2:
              return u === "if" || u === "in" || u === "do";
            case 3:
              return u === "var" || u === "for" || u === "new" || u === "try" || u === "let";
            case 4:
              return u === "this" || u === "else" || u === "case" || u === "void" || u === "with" || u === "enum";
            case 5:
              return u === "while" || u === "break" || u === "catch" || u === "throw" || u === "const" || u === "yield" || u === "class" || u === "super";
            case 6:
              return u === "return" || u === "typeof" || u === "delete" || u === "switch" || u === "export" || u === "import";
            case 7:
              return u === "default" || u === "finally" || u === "extends";
            case 8:
              return u === "function" || u === "continue" || u === "debugger";
            case 10:
              return u === "instanceof";
            default:
              return !1;
          }
        }
        function Ie(u, y, k, T, V) {
          var ne;
          R(typeof k == "number", "Comment must have valid position"), !(_.lastCommentStart >= k) && (_.lastCommentStart = k, ne = {
            type: u,
            value: y
          }, S.range && (ne.range = [k, T]), S.loc && (ne.loc = V), S.comments.push(ne), S.attachComment && (S.leadingComments.push(ne), S.trailingComments.push(ne)));
        }
        function je(u) {
          var y, k, T, V;
          for (y = f - u, k = {
            start: {
              line: E,
              column: f - A - u
            }
          }; f < x; )
            if (T = m.charCodeAt(f), ++f, W(T)) {
              S.comments && (V = m.slice(y + u, f - 1), k.end = {
                line: E,
                column: f - A - 1
              }, Ie("Line", V, y, f - 1, k)), T === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f;
              return;
            }
          S.comments && (V = m.slice(y + u, f), k.end = {
            line: E,
            column: f - A
          }, Ie("Line", V, y, f, k));
        }
        function ue() {
          var u, y, k, T;
          for (S.comments && (u = f - 2, y = {
            start: {
              line: E,
              column: f - A - 2
            }
          }); f < x; )
            if (k = m.charCodeAt(f), W(k))
              k === 13 && m.charCodeAt(f + 1) === 10 && ++f, ++E, ++f, A = f, f >= x && fe({}, h.UnexpectedToken, "ILLEGAL");
            else if (k === 42) {
              if (m.charCodeAt(f + 1) === 47) {
                ++f, ++f, S.comments && (T = m.slice(u + 2, f - 2), y.end = {
                  line: E,
                  column: f - A
                }, Ie("Block", T, u, f, y));
                return;
              }
              ++f;
            } else
              ++f;
          fe({}, h.UnexpectedToken, "ILLEGAL");
        }
        function O() {
          var u, y;
          for (y = f === 0; f < x; )
            if (u = m.charCodeAt(f), j(u))
              ++f;
            else if (W(u))
              ++f, u === 13 && m.charCodeAt(f) === 10 && ++f, ++E, A = f, y = !0;
            else if (u === 47)
              if (u = m.charCodeAt(f + 1), u === 47)
                ++f, ++f, je(2), y = !0;
              else if (u === 42)
                ++f, ++f, ue();
              else
                break;
            else if (y && u === 45)
              if (m.charCodeAt(f + 1) === 45 && m.charCodeAt(f + 2) === 62)
                f += 3, je(3);
              else
                break;
            else if (u === 60)
              if (m.slice(f + 1, f + 4) === "!--")
                ++f, ++f, ++f, ++f, je(4);
              else
                break;
            else
              break;
        }
        function N(u) {
          var y, k, T, V = 0;
          for (k = u === "u" ? 4 : 2, y = 0; y < k; ++y)
            if (f < x && F(m[f]))
              T = m[f++], V = V * 16 + "0123456789abcdef".indexOf(T.toLowerCase());
            else
              return "";
          return String.fromCharCode(V);
        }
        function J() {
          var u, y;
          for (u = m.charCodeAt(f++), y = String.fromCharCode(u), u === 92 && (m.charCodeAt(f) !== 117 && fe({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !te(u.charCodeAt(0))) && fe({}, h.UnexpectedToken, "ILLEGAL"), y = u); f < x && (u = m.charCodeAt(f), !!le(u)); )
            ++f, y += String.fromCharCode(u), u === 92 && (y = y.substr(0, y.length - 1), m.charCodeAt(f) !== 117 && fe({}, h.UnexpectedToken, "ILLEGAL"), ++f, u = N("u"), (!u || u === "\\" || !le(u.charCodeAt(0))) && fe({}, h.UnexpectedToken, "ILLEGAL"), y += u);
          return y;
        }
        function re() {
          var u, y;
          for (u = f++; f < x; ) {
            if (y = m.charCodeAt(f), y === 92)
              return f = u, J();
            if (le(y))
              ++f;
            else
              break;
          }
          return m.slice(u, f);
        }
        function oe() {
          var u, y, k;
          return u = f, y = m.charCodeAt(f) === 92 ? J() : re(), y.length === 1 ? k = o.Identifier : _e(y) ? k = o.Keyword : y === "null" ? k = o.NullLiteral : y === "true" || y === "false" ? k = o.BooleanLiteral : k = o.Identifier, {
            type: k,
            value: y,
            lineNumber: E,
            lineStart: A,
            start: u,
            end: f
          };
        }
        function ee() {
          var u = f, y = m.charCodeAt(f), k, T = m[f], V, ne, Ce;
          switch (y) {
            case 46:
            case 40:
            case 41:
            case 59:
            case 44:
            case 123:
            case 125:
            case 91:
            case 93:
            case 58:
            case 63:
            case 126:
              return ++f, S.tokenize && (y === 40 ? S.openParenToken = S.tokens.length : y === 123 && (S.openCurlyToken = S.tokens.length)), {
                type: o.Punctuator,
                value: String.fromCharCode(y),
                lineNumber: E,
                lineStart: A,
                start: u,
                end: f
              };
            default:
              if (k = m.charCodeAt(f + 1), k === 61)
                switch (y) {
                  case 43:
                  case 45:
                  case 47:
                  case 60:
                  case 62:
                  case 94:
                  case 124:
                  case 37:
                  case 38:
                  case 42:
                    return f += 2, {
                      type: o.Punctuator,
                      value: String.fromCharCode(y) + String.fromCharCode(k),
                      lineNumber: E,
                      lineStart: A,
                      start: u,
                      end: f
                    };
                  case 33:
                  case 61:
                    return f += 2, m.charCodeAt(f) === 61 && ++f, {
                      type: o.Punctuator,
                      value: m.slice(u, f),
                      lineNumber: E,
                      lineStart: A,
                      start: u,
                      end: f
                    };
                }
          }
          if (Ce = m.substr(f, 4), Ce === ">>>=")
            return f += 4, {
              type: o.Punctuator,
              value: Ce,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          if (ne = Ce.substr(0, 3), ne === ">>>" || ne === "<<=" || ne === ">>=")
            return f += 3, {
              type: o.Punctuator,
              value: ne,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          if (V = ne.substr(0, 2), T === V[1] && "+-<>&|".indexOf(T) >= 0 || V === "=>")
            return f += 2, {
              type: o.Punctuator,
              value: V,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          if ("<>=!+-*%&|^/".indexOf(T) >= 0)
            return ++f, {
              type: o.Punctuator,
              value: T,
              lineNumber: E,
              lineStart: A,
              start: u,
              end: f
            };
          fe({}, h.UnexpectedToken, "ILLEGAL");
        }
        function ae(u) {
          for (var y = ""; f < x && F(m[f]); )
            y += m[f++];
          return y.length === 0 && fe({}, h.UnexpectedToken, "ILLEGAL"), te(m.charCodeAt(f)) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
            type: o.NumericLiteral,
            value: parseInt("0x" + y, 16),
            lineNumber: E,
            lineStart: A,
            start: u,
            end: f
          };
        }
        function me(u) {
          for (var y = "0" + m[f++]; f < x && z(m[f]); )
            y += m[f++];
          return (te(m.charCodeAt(f)) || L(m.charCodeAt(f))) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
            type: o.NumericLiteral,
            value: parseInt(y, 8),
            octal: !0,
            lineNumber: E,
            lineStart: A,
            start: u,
            end: f
          };
        }
        function H() {
          var u, y, k;
          if (k = m[f], R(
            L(k.charCodeAt(0)) || k === ".",
            "Numeric literal must start with a decimal digit or a decimal point"
          ), y = f, u = "", k !== ".") {
            if (u = m[f++], k = m[f], u === "0") {
              if (k === "x" || k === "X")
                return ++f, ae(y);
              if (z(k))
                return me(y);
              k && L(k.charCodeAt(0)) && fe({}, h.UnexpectedToken, "ILLEGAL");
            }
            for (; L(m.charCodeAt(f)); )
              u += m[f++];
            k = m[f];
          }
          if (k === ".") {
            for (u += m[f++]; L(m.charCodeAt(f)); )
              u += m[f++];
            k = m[f];
          }
          if (k === "e" || k === "E")
            if (u += m[f++], k = m[f], (k === "+" || k === "-") && (u += m[f++]), L(m.charCodeAt(f)))
              for (; L(m.charCodeAt(f)); )
                u += m[f++];
            else
              fe({}, h.UnexpectedToken, "ILLEGAL");
          return te(m.charCodeAt(f)) && fe({}, h.UnexpectedToken, "ILLEGAL"), {
            type: o.NumericLiteral,
            value: parseFloat(u),
            lineNumber: E,
            lineStart: A,
            start: y,
            end: f
          };
        }
        function X() {
          var u = "", y, k, T, V, ne, Ce, Me = !1, et, Xe;
          for (et = E, Xe = A, y = m[f], R(
            y === "'" || y === '"',
            "String literal must starts with a quote"
          ), k = f, ++f; f < x; )
            if (T = m[f++], T === y) {
              y = "";
              break;
            } else if (T === "\\")
              if (T = m[f++], !T || !W(T.charCodeAt(0)))
                switch (T) {
                  case "u":
                  case "x":
                    Ce = f, ne = N(T), ne ? u += ne : (f = Ce, u += T);
                    break;
                  case "n":
                    u += `
`;
                    break;
                  case "r":
                    u += "\r";
                    break;
                  case "t":
                    u += "	";
                    break;
                  case "b":
                    u += "\b";
                    break;
                  case "f":
                    u += "\f";
                    break;
                  case "v":
                    u += "\v";
                    break;
                  default:
                    z(T) ? (V = "01234567".indexOf(T), V !== 0 && (Me = !0), f < x && z(m[f]) && (Me = !0, V = V * 8 + "01234567".indexOf(m[f++]), "0123".indexOf(T) >= 0 && f < x && z(m[f]) && (V = V * 8 + "01234567".indexOf(m[f++]))), u += String.fromCharCode(V)) : u += T;
                    break;
                }
              else
                ++E, T === "\r" && m[f] === `
` && ++f, A = f;
            else {
              if (W(T.charCodeAt(0)))
                break;
              u += T;
            }
          return y !== "" && fe({}, h.UnexpectedToken, "ILLEGAL"), {
            type: o.StringLiteral,
            value: u,
            octal: Me,
            startLineNumber: et,
            startLineStart: Xe,
            lineNumber: E,
            lineStart: A,
            start: k,
            end: f
          };
        }
        function Ae(u, y) {
          var k;
          try {
            k = new RegExp(u, y);
          } catch {
            fe({}, h.InvalidRegExp);
          }
          return k;
        }
        function Re() {
          var u, y, k, T, V;
          for (u = m[f], R(u === "/", "Regular expression literal must start with a slash"), y = m[f++], k = !1, T = !1; f < x; )
            if (u = m[f++], y += u, u === "\\")
              u = m[f++], W(u.charCodeAt(0)) && fe({}, h.UnterminatedRegExp), y += u;
            else if (W(u.charCodeAt(0)))
              fe({}, h.UnterminatedRegExp);
            else if (k)
              u === "]" && (k = !1);
            else if (u === "/") {
              T = !0;
              break;
            } else u === "[" && (k = !0);
          return T || fe({}, h.UnterminatedRegExp), V = y.substr(1, y.length - 2), {
            value: V,
            literal: y
          };
        }
        function Fe() {
          var u, y, k, T;
          for (y = "", k = ""; f < x && (u = m[f], !!le(u.charCodeAt(0))); )
            if (++f, u === "\\" && f < x)
              if (u = m[f], u === "u") {
                if (++f, T = f, u = N("u"), u)
                  for (k += u, y += "\\u"; T < f; ++T)
                    y += m[T];
                else
                  f = T, k += "u", y += "\\u";
                ye({}, h.UnexpectedToken, "ILLEGAL");
              } else
                y += "\\", ye({}, h.UnexpectedToken, "ILLEGAL");
            else
              k += u, y += u;
          return {
            value: k,
            literal: y
          };
        }
        function Te() {
          var u, y, k, T;
          return w = null, O(), u = f, y = Re(), k = Fe(), T = Ae(y.value, k.value), S.tokenize ? {
            type: o.RegularExpression,
            value: T,
            lineNumber: E,
            lineStart: A,
            start: u,
            end: f
          } : {
            literal: y.literal + k.literal,
            value: T,
            start: u,
            end: f
          };
        }
        function qe() {
          var u, y, k, T;
          return O(), u = f, y = {
            start: {
              line: E,
              column: f - A
            }
          }, k = Te(), y.end = {
            line: E,
            column: f - A
          }, S.tokenize || (S.tokens.length > 0 && (T = S.tokens[S.tokens.length - 1], T.range[0] === u && T.type === "Punctuator" && (T.value === "/" || T.value === "/=") && S.tokens.pop()), S.tokens.push({
            type: "RegularExpression",
            value: k.literal,
            range: [u, f],
            loc: y
          })), k;
        }
        function tt(u) {
          return u.type === o.Identifier || u.type === o.Keyword || u.type === o.BooleanLiteral || u.type === o.NullLiteral;
        }
        function Pe() {
          var u, y;
          if (u = S.tokens[S.tokens.length - 1], !u)
            return qe();
          if (u.type === "Punctuator") {
            if (u.value === "]")
              return ee();
            if (u.value === ")")
              return y = S.tokens[S.openParenToken - 1], y && y.type === "Keyword" && (y.value === "if" || y.value === "while" || y.value === "for" || y.value === "with") ? qe() : ee();
            if (u.value === "}") {
              if (S.tokens[S.openCurlyToken - 3] && S.tokens[S.openCurlyToken - 3].type === "Keyword") {
                if (y = S.tokens[S.openCurlyToken - 4], !y)
                  return ee();
              } else if (S.tokens[S.openCurlyToken - 4] && S.tokens[S.openCurlyToken - 4].type === "Keyword") {
                if (y = S.tokens[S.openCurlyToken - 5], !y)
                  return qe();
              } else
                return ee();
              return l.indexOf(y.value) >= 0 ? ee() : qe();
            }
            return qe();
          }
          return u.type === "Keyword" ? qe() : ee();
        }
        function At() {
          var u;
          return O(), f >= x ? {
            type: o.EOF,
            lineNumber: E,
            lineStart: A,
            start: f,
            end: f
          } : (u = m.charCodeAt(f), te(u) ? oe() : u === 40 || u === 41 || u === 59 ? ee() : u === 39 || u === 34 ? X() : u === 46 ? L(m.charCodeAt(f + 1)) ? H() : ee() : L(u) ? H() : S.tokenize && u === 47 ? Pe() : ee());
        }
        function er() {
          var u, y, k;
          return O(), u = {
            start: {
              line: E,
              column: f - A
            }
          }, y = At(), u.end = {
            line: E,
            column: f - A
          }, y.type !== o.EOF && (k = m.slice(y.start, y.end), S.tokens.push({
            type: a[y.type],
            value: k,
            range: [y.start, y.end],
            loc: u
          })), y;
        }
        function ge() {
          var u;
          return u = w, f = u.end, E = u.lineNumber, A = u.lineStart, w = typeof S.tokens < "u" ? er() : At(), f = u.end, E = u.lineNumber, A = u.lineStart, u;
        }
        function ht() {
          var u, y, k;
          u = f, y = E, k = A, w = typeof S.tokens < "u" ? er() : At(), f = u, E = y, A = k;
        }
        function it(u, y) {
          this.line = u, this.column = y;
        }
        function kt(u, y, k, T) {
          this.start = new it(u, y), this.end = new it(k, T);
        }
        v = {
          name: "SyntaxTree",
          processComment: function(u) {
            var y, k;
            if (!(u.type === c.Program && u.body.length > 0)) {
              for (S.trailingComments.length > 0 ? S.trailingComments[0].range[0] >= u.range[1] ? (k = S.trailingComments, S.trailingComments = []) : S.trailingComments.length = 0 : S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments && S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments[0].range[0] >= u.range[1] && (k = S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments, delete S.bottomRightStack[S.bottomRightStack.length - 1].trailingComments); S.bottomRightStack.length > 0 && S.bottomRightStack[S.bottomRightStack.length - 1].range[0] >= u.range[0]; )
                y = S.bottomRightStack.pop();
              y ? y.leadingComments && y.leadingComments[y.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = y.leadingComments, delete y.leadingComments) : S.leadingComments.length > 0 && S.leadingComments[S.leadingComments.length - 1].range[1] <= u.range[0] && (u.leadingComments = S.leadingComments, S.leadingComments = []), k && (u.trailingComments = k), S.bottomRightStack.push(u);
            }
          },
          markEnd: function(u, y) {
            return S.range && (u.range = [y.start, f]), S.loc && (u.loc = new kt(
              y.startLineNumber === void 0 ? y.lineNumber : y.startLineNumber,
              y.start - (y.startLineStart === void 0 ? y.lineStart : y.startLineStart),
              E,
              f - A
            ), this.postProcess(u)), S.attachComment && this.processComment(u), u;
          },
          postProcess: function(u) {
            return S.source && (u.loc.source = S.source), u;
          },
          createArrayExpression: function(u) {
            return {
              type: c.ArrayExpression,
              elements: u
            };
          },
          createAssignmentExpression: function(u, y, k) {
            return {
              type: c.AssignmentExpression,
              operator: u,
              left: y,
              right: k
            };
          },
          createBinaryExpression: function(u, y, k) {
            var T = u === "||" || u === "&&" ? c.LogicalExpression : c.BinaryExpression;
            return {
              type: T,
              operator: u,
              left: y,
              right: k
            };
          },
          createBlockStatement: function(u) {
            return {
              type: c.BlockStatement,
              body: u
            };
          },
          createBreakStatement: function(u) {
            return {
              type: c.BreakStatement,
              label: u
            };
          },
          createCallExpression: function(u, y) {
            return {
              type: c.CallExpression,
              callee: u,
              arguments: y
            };
          },
          createCatchClause: function(u, y) {
            return {
              type: c.CatchClause,
              param: u,
              body: y
            };
          },
          createConditionalExpression: function(u, y, k) {
            return {
              type: c.ConditionalExpression,
              test: u,
              consequent: y,
              alternate: k
            };
          },
          createContinueStatement: function(u) {
            return {
              type: c.ContinueStatement,
              label: u
            };
          },
          createDebuggerStatement: function() {
            return {
              type: c.DebuggerStatement
            };
          },
          createDoWhileStatement: function(u, y) {
            return {
              type: c.DoWhileStatement,
              body: u,
              test: y
            };
          },
          createEmptyStatement: function() {
            return {
              type: c.EmptyStatement
            };
          },
          createExpressionStatement: function(u) {
            return {
              type: c.ExpressionStatement,
              expression: u
            };
          },
          createForStatement: function(u, y, k, T) {
            return {
              type: c.ForStatement,
              init: u,
              test: y,
              update: k,
              body: T
            };
          },
          createForInStatement: function(u, y, k) {
            return {
              type: c.ForInStatement,
              left: u,
              right: y,
              body: k,
              each: !1
            };
          },
          createFunctionDeclaration: function(u, y, k, T) {
            return {
              type: c.FunctionDeclaration,
              id: u,
              params: y,
              defaults: k,
              body: T,
              rest: null,
              generator: !1,
              expression: !1
            };
          },
          createFunctionExpression: function(u, y, k, T) {
            return {
              type: c.FunctionExpression,
              id: u,
              params: y,
              defaults: k,
              body: T,
              rest: null,
              generator: !1,
              expression: !1
            };
          },
          createIdentifier: function(u) {
            return {
              type: c.Identifier,
              name: u
            };
          },
          createIfStatement: function(u, y, k) {
            return {
              type: c.IfStatement,
              test: u,
              consequent: y,
              alternate: k
            };
          },
          createLabeledStatement: function(u, y) {
            return {
              type: c.LabeledStatement,
              label: u,
              body: y
            };
          },
          createLiteral: function(u) {
            return {
              type: c.Literal,
              value: u.value,
              raw: m.slice(u.start, u.end)
            };
          },
          createMemberExpression: function(u, y, k) {
            return {
              type: c.MemberExpression,
              computed: u === "[",
              object: y,
              property: k
            };
          },
          createNewExpression: function(u, y) {
            return {
              type: c.NewExpression,
              callee: u,
              arguments: y
            };
          },
          createObjectExpression: function(u) {
            return {
              type: c.ObjectExpression,
              properties: u
            };
          },
          createPostfixExpression: function(u, y) {
            return {
              type: c.UpdateExpression,
              operator: u,
              argument: y,
              prefix: !1
            };
          },
          createProgram: function(u) {
            return {
              type: c.Program,
              body: u
            };
          },
          createProperty: function(u, y, k) {
            return {
              type: c.Property,
              key: y,
              value: k,
              kind: u
            };
          },
          createReturnStatement: function(u) {
            return {
              type: c.ReturnStatement,
              argument: u
            };
          },
          createSequenceExpression: function(u) {
            return {
              type: c.SequenceExpression,
              expressions: u
            };
          },
          createSwitchCase: function(u, y) {
            return {
              type: c.SwitchCase,
              test: u,
              consequent: y
            };
          },
          createSwitchStatement: function(u, y) {
            return {
              type: c.SwitchStatement,
              discriminant: u,
              cases: y
            };
          },
          createThisExpression: function() {
            return {
              type: c.ThisExpression
            };
          },
          createThrowStatement: function(u) {
            return {
              type: c.ThrowStatement,
              argument: u
            };
          },
          createTryStatement: function(u, y, k, T) {
            return {
              type: c.TryStatement,
              block: u,
              guardedHandlers: y,
              handlers: k,
              finalizer: T
            };
          },
          createUnaryExpression: function(u, y) {
            return u === "++" || u === "--" ? {
              type: c.UpdateExpression,
              operator: u,
              argument: y,
              prefix: !0
            } : {
              type: c.UnaryExpression,
              operator: u,
              argument: y,
              prefix: !0
            };
          },
          createVariableDeclaration: function(u, y) {
            return {
              type: c.VariableDeclaration,
              declarations: u,
              kind: y
            };
          },
          createVariableDeclarator: function(u, y) {
            return {
              type: c.VariableDeclarator,
              id: u,
              init: y
            };
          },
          createWhileStatement: function(u, y) {
            return {
              type: c.WhileStatement,
              test: u,
              body: y
            };
          },
          createWithStatement: function(u, y) {
            return {
              type: c.WithStatement,
              object: u,
              body: y
            };
          }
        };
        function Ze() {
          var u, y, k, T;
          return u = f, y = E, k = A, O(), T = E !== y, f = u, E = y, A = k, T;
        }
        function fe(u, y) {
          var k, T = Array.prototype.slice.call(arguments, 2), V = y.replace(
            /%(\d)/g,
            function(ne, Ce) {
              return R(Ce < T.length, "Message reference must be in range"), T[Ce];
            }
          );
          throw typeof u.lineNumber == "number" ? (k = new Error("Line " + u.lineNumber + ": " + V), k.index = u.start, k.lineNumber = u.lineNumber, k.column = u.start - A + 1) : (k = new Error("Line " + E + ": " + V), k.index = f, k.lineNumber = E, k.column = f - A + 1), k.description = V, k;
        }
        function ye() {
          try {
            fe.apply(null, arguments);
          } catch (u) {
            if (S.errors)
              S.errors.push(u);
            else
              throw u;
          }
        }
        function Je(u) {
          if (u.type === o.EOF && fe(u, h.UnexpectedEOS), u.type === o.NumericLiteral && fe(u, h.UnexpectedNumber), u.type === o.StringLiteral && fe(u, h.UnexpectedString), u.type === o.Identifier && fe(u, h.UnexpectedIdentifier), u.type === o.Keyword) {
            if (ce(u.value))
              fe(u, h.UnexpectedReserved);
            else if (b && Ee(u.value)) {
              ye(u, h.StrictReservedWord);
              return;
            }
            fe(u, h.UnexpectedToken, u.value);
          }
          fe(u, h.UnexpectedToken, u.value);
        }
        function C(u) {
          var y = ge();
          (y.type !== o.Punctuator || y.value !== u) && Je(y);
        }
        function $(u) {
          var y = ge();
          (y.type !== o.Keyword || y.value !== u) && Je(y);
        }
        function D(u) {
          return w.type === o.Punctuator && w.value === u;
        }
        function se(u) {
          return w.type === o.Keyword && w.value === u;
        }
        function pe() {
          var u;
          return w.type !== o.Punctuator ? !1 : (u = w.value, u === "=" || u === "*=" || u === "/=" || u === "%=" || u === "+=" || u === "-=" || u === "<<=" || u === ">>=" || u === ">>>=" || u === "&=" || u === "^=" || u === "|=");
        }
        function Se() {
          var u;
          if (m.charCodeAt(f) === 59 || D(";")) {
            ge();
            return;
          }
          u = E, O(), E === u && w.type !== o.EOF && !D("}") && Je(w);
        }
        function Le(u) {
          return u.type === c.Identifier || u.type === c.MemberExpression;
        }
        function ot() {
          var u = [], y;
          for (y = w, C("["); !D("]"); )
            D(",") ? (ge(), u.push(null)) : (u.push(q()), D("]") || C(","));
          return ge(), g.markEnd(g.createArrayExpression(u), y);
        }
        function dt(u, y) {
          var k, T, V;
          return k = b, V = w, T = Vn(), y && b && xe(u[0].name) && ye(y, h.StrictParamName), b = k, g.markEnd(g.createFunctionExpression(null, u, [], T), V);
        }
        function St() {
          var u, y;
          return y = w, u = ge(), u.type === o.StringLiteral || u.type === o.NumericLiteral ? (b && u.octal && ye(u, h.StrictOctalLiteral), g.markEnd(g.createLiteral(u), y)) : g.markEnd(g.createIdentifier(u.value), y);
        }
        function rt() {
          var u, y, k, T, V, ne;
          if (u = w, ne = w, u.type === o.Identifier)
            return k = St(), u.value === "get" && !D(":") ? (y = St(), C("("), C(")"), T = dt([]), g.markEnd(g.createProperty("get", y, T), ne)) : u.value === "set" && !D(":") ? (y = St(), C("("), u = w, u.type !== o.Identifier ? (C(")"), ye(u, h.UnexpectedToken, u.value), T = dt([])) : (V = [he()], C(")"), T = dt(V, u)), g.markEnd(g.createProperty("set", y, T), ne)) : (C(":"), T = q(), g.markEnd(g.createProperty("init", k, T), ne));
          if (u.type === o.EOF || u.type === o.Punctuator)
            Je(u);
          else
            return y = St(), C(":"), T = q(), g.markEnd(g.createProperty("init", y, T), ne);
        }
        function zt() {
          var u = [], y, k, T, V, ne = {}, Ce = String, Me;
          for (Me = w, C("{"); !D("}"); )
            y = rt(), y.key.type === c.Identifier ? k = y.key.name : k = Ce(y.key.value), V = y.kind === "init" ? p.Data : y.kind === "get" ? p.Get : p.Set, T = "$" + k, Object.prototype.hasOwnProperty.call(ne, T) ? (ne[T] === p.Data ? b && V === p.Data ? ye({}, h.StrictDuplicateProperty) : V !== p.Data && ye({}, h.AccessorDataProperty) : V === p.Data ? ye({}, h.AccessorDataProperty) : ne[T] & V && ye({}, h.AccessorGetSet), ne[T] |= V) : ne[T] = V, u.push(y), D("}") || C(",");
          return C("}"), g.markEnd(g.createObjectExpression(u), Me);
        }
        function Xt() {
          var u;
          return C("("), u = G(), C(")"), u;
        }
        function tr() {
          var u, y, k, T;
          if (D("("))
            return Xt();
          if (D("["))
            return ot();
          if (D("{"))
            return zt();
          if (u = w.type, T = w, u === o.Identifier)
            k = g.createIdentifier(ge().value);
          else if (u === o.StringLiteral || u === o.NumericLiteral)
            b && w.octal && ye(w, h.StrictOctalLiteral), k = g.createLiteral(ge());
          else if (u === o.Keyword) {
            if (se("function"))
              return uu();
            se("this") ? (ge(), k = g.createThisExpression()) : Je(ge());
          } else u === o.BooleanLiteral ? (y = ge(), y.value = y.value === "true", k = g.createLiteral(y)) : u === o.NullLiteral ? (y = ge(), y.value = null, k = g.createLiteral(y)) : D("/") || D("/=") ? (typeof S.tokens < "u" ? k = g.createLiteral(qe()) : k = g.createLiteral(Te()), ht()) : Je(ge());
          return g.markEnd(k, T);
        }
        function Nr() {
          var u = [];
          if (C("("), !D(")"))
            for (; f < x && (u.push(q()), !D(")")); )
              C(",");
          return C(")"), u;
        }
        function Ai() {
          var u, y;
          return y = w, u = ge(), tt(u) || Je(u), g.markEnd(g.createIdentifier(u.value), y);
        }
        function Zt() {
          return C("."), Ai();
        }
        function Un() {
          var u;
          return C("["), u = G(), C("]"), u;
        }
        function M() {
          var u, y, k;
          return k = w, $("new"), u = K(), y = D("(") ? Nr() : [], g.markEnd(g.createNewExpression(u, y), k);
        }
        function U() {
          var u, y, k, T, V;
          for (V = w, u = _.allowIn, _.allowIn = !0, y = se("new") ? M() : tr(), _.allowIn = u; ; ) {
            if (D("."))
              T = Zt(), y = g.createMemberExpression(".", y, T);
            else if (D("("))
              k = Nr(), y = g.createCallExpression(y, k);
            else if (D("["))
              T = Un(), y = g.createMemberExpression("[", y, T);
            else
              break;
            g.markEnd(y, V);
          }
          return y;
        }
        function K() {
          var u, y, k, T;
          for (T = w, u = _.allowIn, y = se("new") ? M() : tr(), _.allowIn = u; D(".") || D("["); )
            D("[") ? (k = Un(), y = g.createMemberExpression("[", y, k)) : (k = Zt(), y = g.createMemberExpression(".", y, k)), g.markEnd(y, T);
          return y;
        }
        function de() {
          var u, y, k = w;
          return u = U(), w.type === o.Punctuator && (D("++") || D("--")) && !Ze() && (b && u.type === c.Identifier && xe(u.name) && ye({}, h.StrictLHSPostfix), Le(u) || ye({}, h.InvalidLHSInAssignment), y = ge(), u = g.markEnd(g.createPostfixExpression(y.value, u), k)), u;
        }
        function ve() {
          var u, y, k;
          return w.type !== o.Punctuator && w.type !== o.Keyword ? y = de() : D("++") || D("--") ? (k = w, u = ge(), y = ve(), b && y.type === c.Identifier && xe(y.name) && ye({}, h.StrictLHSPrefix), Le(y) || ye({}, h.InvalidLHSInAssignment), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k)) : D("+") || D("-") || D("~") || D("!") ? (k = w, u = ge(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k)) : se("delete") || se("void") || se("typeof") ? (k = w, u = ge(), y = ve(), y = g.createUnaryExpression(u.value, y), y = g.markEnd(y, k), b && y.operator === "delete" && y.argument.type === c.Identifier && ye({}, h.StrictDelete)) : y = de(), y;
        }
        function Z(u, y) {
          var k = 0;
          if (u.type !== o.Punctuator && u.type !== o.Keyword)
            return 0;
          switch (u.value) {
            case "||":
              k = 1;
              break;
            case "&&":
              k = 2;
              break;
            case "|":
              k = 3;
              break;
            case "^":
              k = 4;
              break;
            case "&":
              k = 5;
              break;
            case "==":
            case "!=":
            case "===":
            case "!==":
              k = 6;
              break;
            case "<":
            case ">":
            case "<=":
            case ">=":
            case "instanceof":
              k = 7;
              break;
            case "in":
              k = y ? 7 : 0;
              break;
            case "<<":
            case ">>":
            case ">>>":
              k = 8;
              break;
            case "+":
            case "-":
              k = 9;
              break;
            case "*":
            case "/":
            case "%":
              k = 11;
              break;
          }
          return k;
        }
        function I() {
          var u, y, k, T, V, ne, Ce, Me, et, Xe;
          if (u = w, et = ve(), T = w, V = Z(T, _.allowIn), V === 0)
            return et;
          for (T.prec = V, ge(), y = [u, w], Ce = ve(), ne = [et, T, Ce]; (V = Z(w, _.allowIn)) > 0; ) {
            for (; ne.length > 2 && V <= ne[ne.length - 2].prec; )
              Ce = ne.pop(), Me = ne.pop().value, et = ne.pop(), k = g.createBinaryExpression(Me, et, Ce), y.pop(), u = y[y.length - 1], g.markEnd(k, u), ne.push(k);
            T = ge(), T.prec = V, ne.push(T), y.push(w), k = ve(), ne.push(k);
          }
          for (Xe = ne.length - 1, k = ne[Xe], y.pop(); Xe > 1; )
            k = g.createBinaryExpression(ne[Xe - 1].value, ne[Xe - 2], k), Xe -= 2, u = y.pop(), g.markEnd(k, u);
          return k;
        }
        function B() {
          var u, y, k, T, V;
          return V = w, u = I(), D("?") && (ge(), y = _.allowIn, _.allowIn = !0, k = q(), _.allowIn = y, C(":"), T = q(), u = g.createConditionalExpression(u, k, T), g.markEnd(u, V)), u;
        }
        function q() {
          var u, y, k, T, V;
          return u = w, V = w, T = y = B(), pe() && (Le(y) || ye({}, h.InvalidLHSInAssignment), b && y.type === c.Identifier && xe(y.name) && ye(u, h.StrictLHSAssignment), u = ge(), k = q(), T = g.markEnd(g.createAssignmentExpression(u.value, y, k), V)), T;
        }
        function G() {
          var u, y = w;
          if (u = q(), D(",")) {
            for (u = g.createSequenceExpression([u]); f < x && D(","); )
              ge(), u.expressions.push(q());
            g.markEnd(u, y);
          }
          return u;
        }
        function Y() {
          for (var u = [], y; f < x && !(D("}") || (y = Ir(), typeof y > "u")); )
            u.push(y);
          return u;
        }
        function ie() {
          var u, y;
          return y = w, C("{"), u = Y(), C("}"), g.markEnd(g.createBlockStatement(u), y);
        }
        function he() {
          var u, y;
          return y = w, u = ge(), u.type !== o.Identifier && Je(u), g.markEnd(g.createIdentifier(u.value), y);
        }
        function be(u) {
          var y = null, k, T;
          return T = w, k = he(), b && xe(k.name) && ye({}, h.StrictVarName), u === "const" ? (C("="), y = q()) : D("=") && (ge(), y = q()), g.markEnd(g.createVariableDeclarator(k, y), T);
        }
        function ke(u) {
          var y = [];
          do {
            if (y.push(be(u)), !D(","))
              break;
            ge();
          } while (f < x);
          return y;
        }
        function De() {
          var u;
          return $("var"), u = ke(), Se(), g.createVariableDeclaration(u, "var");
        }
        function $e(u) {
          var y, k;
          return k = w, $(u), y = ke(u), Se(), g.markEnd(g.createVariableDeclaration(y, u), k);
        }
        function Qe() {
          return C(";"), g.createEmptyStatement();
        }
        function ut() {
          var u = G();
          return Se(), g.createExpressionStatement(u);
        }
        function st() {
          var u, y, k;
          return $("if"), C("("), u = G(), C(")"), y = Ot(), se("else") ? (ge(), k = Ot()) : k = null, g.createIfStatement(u, y, k);
        }
        function Rt() {
          var u, y, k;
          return $("do"), k = _.inIteration, _.inIteration = !0, u = Ot(), _.inIteration = k, $("while"), C("("), y = G(), C(")"), D(";") && ge(), g.createDoWhileStatement(u, y);
        }
        function $t() {
          var u, y, k;
          return $("while"), C("("), u = G(), C(")"), k = _.inIteration, _.inIteration = !0, y = Ot(), _.inIteration = k, g.createWhileStatement(u, y);
        }
        function Or() {
          var u, y, k;
          return k = w, u = ge(), y = ke(), g.markEnd(g.createVariableDeclaration(y, u.value), k);
        }
        function an() {
          var u, y, k, T, V, ne, Ce;
          return u = y = k = null, $("for"), C("("), D(";") ? ge() : (se("var") || se("let") ? (_.allowIn = !1, u = Or(), _.allowIn = !0, u.declarations.length === 1 && se("in") && (ge(), T = u, V = G(), u = null)) : (_.allowIn = !1, u = G(), _.allowIn = !0, se("in") && (Le(u) || ye({}, h.InvalidLHSInForIn), ge(), T = u, V = G(), u = null)), typeof T > "u" && C(";")), typeof T > "u" && (D(";") || (y = G()), C(";"), D(")") || (k = G())), C(")"), Ce = _.inIteration, _.inIteration = !0, ne = Ot(), _.inIteration = Ce, typeof T > "u" ? g.createForStatement(u, y, k, ne) : g.createForInStatement(T, V, ne);
        }
        function wo() {
          var u = null, y;
          return $("continue"), m.charCodeAt(f) === 59 ? (ge(), _.inIteration || fe({}, h.IllegalContinue), g.createContinueStatement(null)) : Ze() ? (_.inIteration || fe({}, h.IllegalContinue), g.createContinueStatement(null)) : (w.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(_.labelSet, y) || fe({}, h.UnknownLabel, u.name)), Se(), u === null && !_.inIteration && fe({}, h.IllegalContinue), g.createContinueStatement(u));
        }
        function xo() {
          var u = null, y;
          return $("break"), m.charCodeAt(f) === 59 ? (ge(), _.inIteration || _.inSwitch || fe({}, h.IllegalBreak), g.createBreakStatement(null)) : Ze() ? (_.inIteration || _.inSwitch || fe({}, h.IllegalBreak), g.createBreakStatement(null)) : (w.type === o.Identifier && (u = he(), y = "$" + u.name, Object.prototype.hasOwnProperty.call(_.labelSet, y) || fe({}, h.UnknownLabel, u.name)), Se(), u === null && !(_.inIteration || _.inSwitch) && fe({}, h.IllegalBreak), g.createBreakStatement(u));
        }
        function ru() {
          var u = null;
          return $("return"), _.inFunctionBody || ye({}, h.IllegalReturn), m.charCodeAt(f) === 32 && te(m.charCodeAt(f + 1)) ? (u = G(), Se(), g.createReturnStatement(u)) : Ze() ? g.createReturnStatement(null) : (D(";") || !D("}") && w.type !== o.EOF && (u = G()), Se(), g.createReturnStatement(u));
        }
        function nu() {
          var u, y;
          return b && (O(), ye({}, h.StrictModeWith)), $("with"), C("("), u = G(), C(")"), y = Ot(), g.createWithStatement(u, y);
        }
        function iu() {
          var u, y = [], k, T;
          for (T = w, se("default") ? (ge(), u = null) : ($("case"), u = G()), C(":"); f < x && !(D("}") || se("default") || se("case")); )
            k = Ot(), y.push(k);
          return g.markEnd(g.createSwitchCase(u, y), T);
        }
        function su() {
          var u, y, k, T, V;
          if ($("switch"), C("("), u = G(), C(")"), C("{"), y = [], D("}"))
            return ge(), g.createSwitchStatement(u, y);
          for (T = _.inSwitch, _.inSwitch = !0, V = !1; f < x && !D("}"); )
            k = iu(), k.test === null && (V && fe({}, h.MultipleDefaultsInSwitch), V = !0), y.push(k);
          return _.inSwitch = T, C("}"), g.createSwitchStatement(u, y);
        }
        function ou() {
          var u;
          return $("throw"), Ze() && fe({}, h.NewlineAfterThrow), u = G(), Se(), g.createThrowStatement(u);
        }
        function au() {
          var u, y, k;
          return k = w, $("catch"), C("("), D(")") && Je(w), u = he(), b && xe(u.name) && ye({}, h.StrictCatchVariable), C(")"), y = ie(), g.markEnd(g.createCatchClause(u, y), k);
        }
        function lu() {
          var u, y = [], k = null;
          return $("try"), u = ie(), se("catch") && y.push(au()), se("finally") && (ge(), k = ie()), y.length === 0 && !k && fe({}, h.NoCatchOrFinally), g.createTryStatement(u, [], y, k);
        }
        function cu() {
          return $("debugger"), Se(), g.createDebuggerStatement();
        }
        function Ot() {
          var u = w.type, y, k, T, V;
          if (u === o.EOF && Je(w), u === o.Punctuator && w.value === "{")
            return ie();
          if (V = w, u === o.Punctuator)
            switch (w.value) {
              case ";":
                return g.markEnd(Qe(), V);
              case "(":
                return g.markEnd(ut(), V);
            }
          if (u === o.Keyword)
            switch (w.value) {
              case "break":
                return g.markEnd(xo(), V);
              case "continue":
                return g.markEnd(wo(), V);
              case "debugger":
                return g.markEnd(cu(), V);
              case "do":
                return g.markEnd(Rt(), V);
              case "for":
                return g.markEnd(an(), V);
              case "function":
                return g.markEnd(Ps(), V);
              case "if":
                return g.markEnd(st(), V);
              case "return":
                return g.markEnd(ru(), V);
              case "switch":
                return g.markEnd(su(), V);
              case "throw":
                return g.markEnd(ou(), V);
              case "try":
                return g.markEnd(lu(), V);
              case "var":
                return g.markEnd(De(), V);
              case "while":
                return g.markEnd($t(), V);
              case "with":
                return g.markEnd(nu(), V);
            }
          return y = G(), y.type === c.Identifier && D(":") ? (ge(), T = "$" + y.name, Object.prototype.hasOwnProperty.call(_.labelSet, T) && fe({}, h.Redeclaration, "Label", y.name), _.labelSet[T] = !0, k = Ot(), delete _.labelSet[T], g.markEnd(g.createLabeledStatement(y, k), V)) : (Se(), g.markEnd(g.createExpressionStatement(y), V));
        }
        function Vn() {
          var u, y = [], k, T, V, ne, Ce, Me, et, Xe;
          for (Xe = w, C("{"); f < x && !(w.type !== o.StringLiteral || (k = w, u = Ir(), y.push(u), u.expression.type !== c.Literal)); )
            T = m.slice(k.start + 1, k.end - 1), T === "use strict" ? (b = !0, V && ye(V, h.StrictOctalLiteral)) : !V && k.octal && (V = k);
          for (ne = _.labelSet, Ce = _.inIteration, Me = _.inSwitch, et = _.inFunctionBody, _.labelSet = {}, _.inIteration = !1, _.inSwitch = !1, _.inFunctionBody = !0; f < x && !(D("}") || (u = Ir(), typeof u > "u")); )
            y.push(u);
          return C("}"), _.labelSet = ne, _.inIteration = Ce, _.inSwitch = Me, _.inFunctionBody = et, g.markEnd(g.createBlockStatement(y), Xe);
        }
        function Is(u) {
          var y, k = [], T, V, ne, Ce, Me;
          if (C("("), !D(")"))
            for (ne = {}; f < x && (T = w, y = he(), Ce = "$" + T.value, b ? (xe(T.value) && (V = T, Me = h.StrictParamName), Object.prototype.hasOwnProperty.call(ne, Ce) && (V = T, Me = h.StrictParamDupe)) : u || (xe(T.value) ? (u = T, Me = h.StrictParamName) : Ee(T.value) ? (u = T, Me = h.StrictReservedWord) : Object.prototype.hasOwnProperty.call(ne, Ce) && (u = T, Me = h.StrictParamDupe)), k.push(y), ne[Ce] = !0, !D(")")); )
              C(",");
          return C(")"), {
            params: k,
            stricted: V,
            firstRestricted: u,
            message: Me
          };
        }
        function Ps() {
          var u, y = [], k, T, V, ne, Ce, Me, et, Xe;
          return Xe = w, $("function"), T = w, u = he(), b ? xe(T.value) && ye(T, h.StrictFunctionName) : xe(T.value) ? (Ce = T, Me = h.StrictFunctionName) : Ee(T.value) && (Ce = T, Me = h.StrictReservedWord), ne = Is(Ce), y = ne.params, V = ne.stricted, Ce = ne.firstRestricted, ne.message && (Me = ne.message), et = b, k = Vn(), b && Ce && fe(Ce, Me), b && V && ye(V, Me), b = et, g.markEnd(g.createFunctionDeclaration(u, y, [], k), Xe);
        }
        function uu() {
          var u, y = null, k, T, V, ne, Ce = [], Me, et, Xe;
          return Xe = w, $("function"), D("(") || (u = w, y = he(), b ? xe(u.value) && ye(u, h.StrictFunctionName) : xe(u.value) ? (T = u, V = h.StrictFunctionName) : Ee(u.value) && (T = u, V = h.StrictReservedWord)), ne = Is(T), Ce = ne.params, k = ne.stricted, T = ne.firstRestricted, ne.message && (V = ne.message), et = b, Me = Vn(), b && T && fe(T, V), b && k && ye(k, V), b = et, g.markEnd(g.createFunctionExpression(y, Ce, [], Me), Xe);
        }
        function Ir() {
          if (w.type === o.Keyword)
            switch (w.value) {
              case "const":
              case "let":
                return $e(w.value);
              case "function":
                return Ps();
              default:
                return Ot();
            }
          if (w.type !== o.EOF)
            return Ot();
        }
        function hu() {
          for (var u, y = [], k, T, V; f < x && (k = w, !(k.type !== o.StringLiteral || (u = Ir(), y.push(u), u.expression.type !== c.Literal))); )
            T = m.slice(k.start + 1, k.end - 1), T === "use strict" ? (b = !0, V && ye(V, h.StrictOctalLiteral)) : !V && k.octal && (V = k);
          for (; f < x && (u = Ir(), !(typeof u > "u")); )
            y.push(u);
          return y;
        }
        function pu() {
          var u, y;
          return O(), ht(), y = w, b = !1, u = hu(), g.markEnd(g.createProgram(u), y);
        }
        function Rs() {
          var u, y, k, T = [];
          for (u = 0; u < S.tokens.length; ++u)
            y = S.tokens[u], k = {
              type: y.type,
              value: y.value
            }, S.range && (k.range = y.range), S.loc && (k.loc = y.loc), T.push(k);
          S.tokens = T;
        }
        function du(u, y) {
          var k, T, V;
          k = String, typeof u != "string" && !(u instanceof String) && (u = k(u)), g = v, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, w = null, _ = {
            allowIn: !0,
            labelSet: {},
            inFunctionBody: !1,
            inIteration: !1,
            inSwitch: !1,
            lastCommentStart: -1
          }, S = {}, y = y || {}, y.tokens = !0, S.tokens = [], S.tokenize = !0, S.openParenToken = -1, S.openCurlyToken = -1, S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []);
          try {
            if (ht(), w.type === o.EOF)
              return S.tokens;
            for (T = ge(); w.type !== o.EOF; )
              try {
                T = ge();
              } catch (ne) {
                if (T = w, S.errors) {
                  S.errors.push(ne);
                  break;
                } else
                  throw ne;
              }
            Rs(), V = S.tokens, typeof S.comments < "u" && (V.comments = S.comments), typeof S.errors < "u" && (V.errors = S.errors);
          } catch (ne) {
            throw ne;
          } finally {
            S = {};
          }
          return V;
        }
        function fu(u, y) {
          var k, T;
          T = String, typeof u != "string" && !(u instanceof String) && (u = T(u)), g = v, m = u, f = 0, E = m.length > 0 ? 1 : 0, A = 0, x = m.length, w = null, _ = {
            allowIn: !0,
            labelSet: {},
            inFunctionBody: !1,
            inIteration: !1,
            inSwitch: !1,
            lastCommentStart: -1
          }, S = {}, typeof y < "u" && (S.range = typeof y.range == "boolean" && y.range, S.loc = typeof y.loc == "boolean" && y.loc, S.attachComment = typeof y.attachComment == "boolean" && y.attachComment, S.loc && y.source !== null && y.source !== void 0 && (S.source = T(y.source)), typeof y.tokens == "boolean" && y.tokens && (S.tokens = []), typeof y.comment == "boolean" && y.comment && (S.comments = []), typeof y.tolerant == "boolean" && y.tolerant && (S.errors = []), S.attachComment && (S.range = !0, S.comments = [], S.bottomRightStack = [], S.trailingComments = [], S.leadingComments = []));
          try {
            k = pu(), typeof S.comments < "u" && (k.comments = S.comments), typeof S.tokens < "u" && (Rs(), k.tokens = S.tokens), typeof S.errors < "u" && (k.errors = S.errors);
          } catch (V) {
            throw V;
          } finally {
            S = {};
          }
          return k;
        }
        s.version = "1.2.2", s.tokenize = du, s.parse = fu, s.Syntax = function() {
          var u, y = {};
          typeof Object.create == "function" && (y = /* @__PURE__ */ Object.create(null));
          for (u in c)
            c.hasOwnProperty(u) && (y[u] = c[u]);
          return typeof Object.freeze == "function" && Object.freeze(y), y;
        }();
      });
    }, {}], 1: [function(r, n, i) {
      (function(s) {
        var o = function() {
          var a = {
            trace: function() {
            },
            yy: {},
            symbols_: { error: 2, JSON_PATH: 3, DOLLAR: 4, PATH_COMPONENTS: 5, LEADING_CHILD_MEMBER_EXPRESSION: 6, PATH_COMPONENT: 7, MEMBER_COMPONENT: 8, SUBSCRIPT_COMPONENT: 9, CHILD_MEMBER_COMPONENT: 10, DESCENDANT_MEMBER_COMPONENT: 11, DOT: 12, MEMBER_EXPRESSION: 13, DOT_DOT: 14, STAR: 15, IDENTIFIER: 16, SCRIPT_EXPRESSION: 17, INTEGER: 18, END: 19, CHILD_SUBSCRIPT_COMPONENT: 20, DESCENDANT_SUBSCRIPT_COMPONENT: 21, "[": 22, SUBSCRIPT: 23, "]": 24, SUBSCRIPT_EXPRESSION: 25, SUBSCRIPT_EXPRESSION_LIST: 26, SUBSCRIPT_EXPRESSION_LISTABLE: 27, ",": 28, STRING_LITERAL: 29, ARRAY_SLICE: 30, FILTER_EXPRESSION: 31, QQ_STRING: 32, Q_STRING: 33, $accept: 0, $end: 1 },
            terminals_: { 2: "error", 4: "DOLLAR", 12: "DOT", 14: "DOT_DOT", 15: "STAR", 16: "IDENTIFIER", 17: "SCRIPT_EXPRESSION", 18: "INTEGER", 19: "END", 22: "[", 24: "]", 28: ",", 30: "ARRAY_SLICE", 31: "FILTER_EXPRESSION", 32: "QQ_STRING", 33: "Q_STRING" },
            productions_: [0, [3, 1], [3, 2], [3, 1], [3, 2], [5, 1], [5, 2], [7, 1], [7, 1], [8, 1], [8, 1], [10, 2], [6, 1], [11, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [9, 1], [9, 1], [20, 3], [21, 4], [23, 1], [23, 1], [26, 1], [26, 3], [27, 1], [27, 1], [27, 1], [25, 1], [25, 1], [25, 1], [29, 1], [29, 1]],
            performAction: function(h, d, v, m, b, f, E) {
              m.ast || (m.ast = l, l.initialize());
              var A = f.length - 1;
              switch (b) {
                case 1:
                  return m.ast.set({ expression: { type: "root", value: f[A] } }), m.ast.unshift(), m.ast.yield();
                case 2:
                  return m.ast.set({ expression: { type: "root", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                case 3:
                  return m.ast.unshift(), m.ast.yield();
                case 4:
                  return m.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: f[A - 1] } }), m.ast.unshift(), m.ast.yield();
                case 5:
                  break;
                case 6:
                  break;
                case 7:
                  m.ast.set({ operation: "member" }), m.ast.push();
                  break;
                case 8:
                  m.ast.set({ operation: "subscript" }), m.ast.push();
                  break;
                case 9:
                  m.ast.set({ scope: "child" });
                  break;
                case 10:
                  m.ast.set({ scope: "descendant" });
                  break;
                case 11:
                  break;
                case 12:
                  m.ast.set({ scope: "child", operation: "member" });
                  break;
                case 13:
                  break;
                case 14:
                  m.ast.set({ expression: { type: "wildcard", value: f[A] } });
                  break;
                case 15:
                  m.ast.set({ expression: { type: "identifier", value: f[A] } });
                  break;
                case 16:
                  m.ast.set({ expression: { type: "script_expression", value: f[A] } });
                  break;
                case 17:
                  m.ast.set({ expression: { type: "numeric_literal", value: parseInt(f[A]) } });
                  break;
                case 18:
                  break;
                case 19:
                  m.ast.set({ scope: "child" });
                  break;
                case 20:
                  m.ast.set({ scope: "descendant" });
                  break;
                case 21:
                  break;
                case 22:
                  break;
                case 23:
                  break;
                case 24:
                  f[A].length > 1 ? m.ast.set({ expression: { type: "union", value: f[A] } }) : this.$ = f[A];
                  break;
                case 25:
                  this.$ = [f[A]];
                  break;
                case 26:
                  this.$ = f[A - 2].concat(f[A]);
                  break;
                case 27:
                  this.$ = { expression: { type: "numeric_literal", value: parseInt(f[A]) } }, m.ast.set(this.$);
                  break;
                case 28:
                  this.$ = { expression: { type: "string_literal", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 29:
                  this.$ = { expression: { type: "slice", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 30:
                  this.$ = { expression: { type: "wildcard", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 31:
                  this.$ = { expression: { type: "script_expression", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 32:
                  this.$ = { expression: { type: "filter_expression", value: f[A] } }, m.ast.set(this.$);
                  break;
                case 33:
                  this.$ = f[A];
                  break;
                case 34:
                  this.$ = f[A];
                  break;
              }
            },
            table: [{ 3: 1, 4: [1, 2], 6: 3, 13: 4, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 1: [3] }, { 1: [2, 1], 5: 10, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 3], 5: 21, 7: 11, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 12], 12: [2, 12], 14: [2, 12], 22: [2, 12] }, { 1: [2, 14], 12: [2, 14], 14: [2, 14], 22: [2, 14] }, { 1: [2, 15], 12: [2, 15], 14: [2, 15], 22: [2, 15] }, { 1: [2, 16], 12: [2, 16], 14: [2, 16], 22: [2, 16] }, { 1: [2, 17], 12: [2, 17], 14: [2, 17], 22: [2, 17] }, { 1: [2, 18], 12: [2, 18], 14: [2, 18], 22: [2, 18] }, { 1: [2, 2], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 5], 12: [2, 5], 14: [2, 5], 22: [2, 5] }, { 1: [2, 7], 12: [2, 7], 14: [2, 7], 22: [2, 7] }, { 1: [2, 8], 12: [2, 8], 14: [2, 8], 22: [2, 8] }, { 1: [2, 9], 12: [2, 9], 14: [2, 9], 22: [2, 9] }, { 1: [2, 10], 12: [2, 10], 14: [2, 10], 22: [2, 10] }, { 1: [2, 19], 12: [2, 19], 14: [2, 19], 22: [2, 19] }, { 1: [2, 20], 12: [2, 20], 14: [2, 20], 22: [2, 20] }, { 13: 23, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9] }, { 13: 24, 15: [1, 5], 16: [1, 6], 17: [1, 7], 18: [1, 8], 19: [1, 9], 22: [1, 25] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 26, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 1: [2, 4], 7: 22, 8: 12, 9: 13, 10: 14, 11: 15, 12: [1, 18], 14: [1, 19], 20: 16, 21: 17, 22: [1, 20] }, { 1: [2, 6], 12: [2, 6], 14: [2, 6], 22: [2, 6] }, { 1: [2, 11], 12: [2, 11], 14: [2, 11], 22: [2, 11] }, { 1: [2, 13], 12: [2, 13], 14: [2, 13], 22: [2, 13] }, { 15: [1, 29], 17: [1, 30], 18: [1, 33], 23: 38, 25: 27, 26: 28, 27: 32, 29: 34, 30: [1, 35], 31: [1, 31], 32: [1, 36], 33: [1, 37] }, { 24: [1, 39] }, { 24: [2, 23] }, { 24: [2, 24], 28: [1, 40] }, { 24: [2, 30] }, { 24: [2, 31] }, { 24: [2, 32] }, { 24: [2, 25], 28: [2, 25] }, { 24: [2, 27], 28: [2, 27] }, { 24: [2, 28], 28: [2, 28] }, { 24: [2, 29], 28: [2, 29] }, { 24: [2, 33], 28: [2, 33] }, { 24: [2, 34], 28: [2, 34] }, { 24: [1, 41] }, { 1: [2, 21], 12: [2, 21], 14: [2, 21], 22: [2, 21] }, { 18: [1, 33], 27: 42, 29: 34, 30: [1, 35], 32: [1, 36], 33: [1, 37] }, { 1: [2, 22], 12: [2, 22], 14: [2, 22], 22: [2, 22] }, { 24: [2, 26], 28: [2, 26] }],
            defaultActions: { 27: [2, 23], 29: [2, 30], 30: [2, 31], 31: [2, 32] },
            parseError: function(h, d) {
              if (d.recoverable)
                this.trace(h);
              else
                throw new Error(h);
            },
            parse: function(h) {
              var d = this, v = [0], m = [null], b = [], f = this.table, E = "", A = 0, x = 0, g = 2, w = 1, _ = b.slice.call(arguments, 1);
              this.lexer.setInput(h), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, typeof this.lexer.yylloc > "u" && (this.lexer.yylloc = {});
              var S = this.lexer.yylloc;
              b.push(S);
              var R = this.lexer.options && this.lexer.options.ranges;
              typeof this.yy.parseError == "function" ? this.parseError = this.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
              function L() {
                var Ie;
                return Ie = d.lexer.lex() || w, typeof Ie != "number" && (Ie = d.symbols_[Ie] || Ie), Ie;
              }
              for (var F, z, j, W, te = {}, le, ce, Ee, xe; ; ) {
                if (z = v[v.length - 1], this.defaultActions[z] ? j = this.defaultActions[z] : ((F === null || typeof F > "u") && (F = L()), j = f[z] && f[z][F]), typeof j > "u" || !j.length || !j[0]) {
                  var _e = "";
                  xe = [];
                  for (le in f[z])
                    this.terminals_[le] && le > g && xe.push("'" + this.terminals_[le] + "'");
                  this.lexer.showPosition ? _e = "Parse error on line " + (A + 1) + `:
` + this.lexer.showPosition() + `
Expecting ` + xe.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : _e = "Parse error on line " + (A + 1) + ": Unexpected " + (F == w ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(_e, {
                    text: this.lexer.match,
                    token: this.terminals_[F] || F,
                    line: this.lexer.yylineno,
                    loc: S,
                    expected: xe
                  });
                }
                if (j[0] instanceof Array && j.length > 1)
                  throw new Error("Parse Error: multiple actions possible at state: " + z + ", token: " + F);
                switch (j[0]) {
                  case 1:
                    v.push(F), m.push(this.lexer.yytext), b.push(this.lexer.yylloc), v.push(j[1]), F = null, x = this.lexer.yyleng, E = this.lexer.yytext, A = this.lexer.yylineno, S = this.lexer.yylloc;
                    break;
                  case 2:
                    if (ce = this.productions_[j[1]][1], te.$ = m[m.length - ce], te._$ = {
                      first_line: b[b.length - (ce || 1)].first_line,
                      last_line: b[b.length - 1].last_line,
                      first_column: b[b.length - (ce || 1)].first_column,
                      last_column: b[b.length - 1].last_column
                    }, R && (te._$.range = [
                      b[b.length - (ce || 1)].range[0],
                      b[b.length - 1].range[1]
                    ]), W = this.performAction.apply(te, [
                      E,
                      x,
                      A,
                      this.yy,
                      j[1],
                      m,
                      b
                    ].concat(_)), typeof W < "u")
                      return W;
                    ce && (v = v.slice(0, -1 * ce * 2), m = m.slice(0, -1 * ce), b = b.slice(0, -1 * ce)), v.push(this.productions_[j[1]][0]), m.push(te.$), b.push(te._$), Ee = f[v[v.length - 2]][v[v.length - 1]], v.push(Ee);
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }
          }, l = {
            initialize: function() {
              this._nodes = [], this._node = {}, this._stash = [];
            },
            set: function(h) {
              for (var d in h) this._node[d] = h[d];
              return this._node;
            },
            node: function(h) {
              return arguments.length && (this._node = h), this._node;
            },
            push: function() {
              this._nodes.push(this._node), this._node = {};
            },
            unshift: function() {
              this._nodes.unshift(this._node), this._node = {};
            },
            yield: function() {
              var h = this._nodes;
              return this.initialize(), h;
            }
          }, c = /* @__PURE__ */ function() {
            var h = {
              EOF: 1,
              parseError: function(d, v) {
                if (this.yy.parser)
                  this.yy.parser.parseError(d, v);
                else
                  throw new Error(d);
              },
              // resets the lexer, sets new input
              setInput: function(d) {
                return this._input = d, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                  first_line: 1,
                  first_column: 0,
                  last_line: 1,
                  last_column: 0
                }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
              },
              // consumes and returns one char from the input
              input: function() {
                var d = this._input[0];
                this.yytext += d, this.yyleng++, this.offset++, this.match += d, this.matched += d;
                var v = d.match(/(?:\r\n?|\n).*/g);
                return v ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), d;
              },
              // unshifts one char (or a string) into the input
              unput: function(d) {
                var v = d.length, m = d.split(/(?:\r\n?|\n)/g);
                this._input = d + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - v - 1), this.offset -= v;
                var b = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), m.length - 1 && (this.yylineno -= m.length - 1);
                var f = this.yylloc.range;
                return this.yylloc = {
                  first_line: this.yylloc.first_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.first_column,
                  last_column: m ? (m.length === b.length ? this.yylloc.first_column : 0) + b[b.length - m.length].length - m[0].length : this.yylloc.first_column - v
                }, this.options.ranges && (this.yylloc.range = [f[0], f[0] + this.yyleng - v]), this.yyleng = this.yytext.length, this;
              },
              // When called from action, caches matched text and appends it on next action
              more: function() {
                return this._more = !0, this;
              },
              // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
              reject: function() {
                if (this.options.backtrack_lexer)
                  this._backtrack = !0;
                else
                  return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                  });
                return this;
              },
              // retain first n characters of the match
              less: function(d) {
                this.unput(this.match.slice(d));
              },
              // displays already matched input, i.e. for error messages
              pastInput: function() {
                var d = this.matched.substr(0, this.matched.length - this.match.length);
                return (d.length > 20 ? "..." : "") + d.substr(-20).replace(/\n/g, "");
              },
              // displays upcoming input, i.e. for error messages
              upcomingInput: function() {
                var d = this.match;
                return d.length < 20 && (d += this._input.substr(0, 20 - d.length)), (d.substr(0, 20) + (d.length > 20 ? "..." : "")).replace(/\n/g, "");
              },
              // displays the character position where the lexing error occurred, i.e. for error messages
              showPosition: function() {
                var d = this.pastInput(), v = new Array(d.length + 1).join("-");
                return d + this.upcomingInput() + `
` + v + "^";
              },
              // test the lexed token: return FALSE when not a match, otherwise return token
              test_match: function(d, v) {
                var m, b, f;
                if (this.options.backtrack_lexer && (f = {
                  yylineno: this.yylineno,
                  yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
                }, this.options.ranges && (f.yylloc.range = this.yylloc.range.slice(0))), b = d[0].match(/(?:\r\n?|\n).*/g), b && (this.yylineno += b.length), this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: b ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + d[0].length
                }, this.yytext += d[0], this.match += d[0], this.matches = d, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(d[0].length), this.matched += d[0], m = this.performAction.call(this, this.yy, this, v, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), m)
                  return m;
                if (this._backtrack) {
                  for (var E in f)
                    this[E] = f[E];
                  return !1;
                }
                return !1;
              },
              // return next match in input
              next: function() {
                if (this.done)
                  return this.EOF;
                this._input || (this.done = !0);
                var d, v, m, b;
                this._more || (this.yytext = "", this.match = "");
                for (var f = this._currentRules(), E = 0; E < f.length; E++)
                  if (m = this._input.match(this.rules[f[E]]), m && (!v || m[0].length > v[0].length)) {
                    if (v = m, b = E, this.options.backtrack_lexer) {
                      if (d = this.test_match(m, f[E]), d !== !1)
                        return d;
                      if (this._backtrack) {
                        v = !1;
                        continue;
                      } else
                        return !1;
                    } else if (!this.options.flex)
                      break;
                  }
                return v ? (d = this.test_match(v, f[b]), d !== !1 ? d : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              },
              // return next match that has a token
              lex: function() {
                var d = this.next();
                return d || this.lex();
              },
              // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
              begin: function(d) {
                this.conditionStack.push(d);
              },
              // pop the previously active lexer condition state off the condition stack
              popState: function() {
                var d = this.conditionStack.length - 1;
                return d > 0 ? this.conditionStack.pop() : this.conditionStack[0];
              },
              // produce the lexer rule set which is active for the currently active lexer condition state
              _currentRules: function() {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
              },
              // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
              topState: function(d) {
                return d = this.conditionStack.length - 1 - Math.abs(d || 0), d >= 0 ? this.conditionStack[d] : "INITIAL";
              },
              // alias for begin(condition)
              pushState: function(d) {
                this.begin(d);
              },
              // return the number of states currently on the stack
              stateStackSize: function() {
                return this.conditionStack.length;
              },
              options: {},
              performAction: function(d, v, m, b) {
                switch (m) {
                  case 0:
                    return 4;
                  case 1:
                    return 14;
                  case 2:
                    return 12;
                  case 3:
                    return 15;
                  case 4:
                    return 16;
                  case 5:
                    return 22;
                  case 6:
                    return 24;
                  case 7:
                    return 28;
                  case 8:
                    return 30;
                  case 9:
                    return 18;
                  case 10:
                    return v.yytext = v.yytext.substr(1, v.yyleng - 2), 32;
                  case 11:
                    return v.yytext = v.yytext.substr(1, v.yyleng - 2), 33;
                  case 12:
                    return 17;
                  case 13:
                    return 31;
                }
              },
              rules: [/^(?:\$)/, /^(?:\.\.)/, /^(?:\.)/, /^(?:\*)/, /^(?:[a-zA-Z_]+[a-zA-Z0-9_]*)/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?:((-?(?:0|[1-9][0-9]*)))?\:((-?(?:0|[1-9][0-9]*)))?(\:((-?(?:0|[1-9][0-9]*)))?)?)/, /^(?:(-?(?:0|[1-9][0-9]*)))/, /^(?:"(?:\\["bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*")/, /^(?:'(?:\\['bfnrt/\\]|\\u[a-fA-F0-9]{4}|[^'\\])*')/, /^(?:\(.+?\)(?=\]))/, /^(?:\?\(.+?\)(?=\]))/],
              conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], inclusive: !0 } }
            };
            return h;
          }();
          a.lexer = c;
          function p() {
            this.yy = {};
          }
          return p.prototype = a, a.Parser = p, new p();
        }();
        typeof r < "u" && typeof i < "u" && (i.parser = o, i.Parser = o.Parser, i.parse = function() {
          return o.parse.apply(o, arguments);
        }, i.main = function(a) {
          a[1] || (console.log("Usage: " + a[0] + " FILE"), s.exit(1));
          var l = r("fs").readFileSync(r("path").normalize(a[1]), "utf8");
          return i.parser.parse(l);
        }, typeof n < "u" && r.main === n && i.main(s.argv.slice(1)));
      }).call(this, r("_process"));
    }, { _process: 14, fs: 12, path: 13 }], 2: [function(r, n, i) {
      n.exports = {
        identifier: "[a-zA-Z_]+[a-zA-Z0-9_]*",
        integer: "-?(?:0|[1-9][0-9]*)",
        qq_string: '"(?:\\\\["bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^"\\\\])*"',
        q_string: "'(?:\\\\['bfnrt/\\\\]|\\\\u[a-fA-F0-9]{4}|[^'\\\\])*'"
      };
    }, {}], 3: [function(r, n, i) {
      var s = r("./dict"), o = r("fs"), a = {
        lex: {
          macros: {
            esc: "\\\\",
            int: s.integer
          },
          rules: [
            ["\\$", "return 'DOLLAR'"],
            ["\\.\\.", "return 'DOT_DOT'"],
            ["\\.", "return 'DOT'"],
            ["\\*", "return 'STAR'"],
            [s.identifier, "return 'IDENTIFIER'"],
            ["\\[", "return '['"],
            ["\\]", "return ']'"],
            [",", "return ','"],
            ["({int})?\\:({int})?(\\:({int})?)?", "return 'ARRAY_SLICE'"],
            ["{int}", "return 'INTEGER'"],
            [s.qq_string, "yytext = yytext.substr(1,yyleng-2); return 'QQ_STRING';"],
            [s.q_string, "yytext = yytext.substr(1,yyleng-2); return 'Q_STRING';"],
            ["\\(.+?\\)(?=\\])", "return 'SCRIPT_EXPRESSION'"],
            ["\\?\\(.+?\\)(?=\\])", "return 'FILTER_EXPRESSION'"]
          ]
        },
        start: "JSON_PATH",
        bnf: {
          JSON_PATH: [
            ["DOLLAR", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
            ["DOLLAR PATH_COMPONENTS", 'yy.ast.set({ expression: { type: "root", value: $1 } }); yy.ast.unshift(); return yy.ast.yield()'],
            ["LEADING_CHILD_MEMBER_EXPRESSION", "yy.ast.unshift(); return yy.ast.yield()"],
            ["LEADING_CHILD_MEMBER_EXPRESSION PATH_COMPONENTS", 'yy.ast.set({ operation: "member", scope: "child", expression: { type: "identifier", value: $1 }}); yy.ast.unshift(); return yy.ast.yield()']
          ],
          PATH_COMPONENTS: [
            ["PATH_COMPONENT", ""],
            ["PATH_COMPONENTS PATH_COMPONENT", ""]
          ],
          PATH_COMPONENT: [
            ["MEMBER_COMPONENT", 'yy.ast.set({ operation: "member" }); yy.ast.push()'],
            ["SUBSCRIPT_COMPONENT", 'yy.ast.set({ operation: "subscript" }); yy.ast.push() ']
          ],
          MEMBER_COMPONENT: [
            ["CHILD_MEMBER_COMPONENT", 'yy.ast.set({ scope: "child" })'],
            ["DESCENDANT_MEMBER_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
          ],
          CHILD_MEMBER_COMPONENT: [
            ["DOT MEMBER_EXPRESSION", ""]
          ],
          LEADING_CHILD_MEMBER_EXPRESSION: [
            ["MEMBER_EXPRESSION", 'yy.ast.set({ scope: "child", operation: "member" })']
          ],
          DESCENDANT_MEMBER_COMPONENT: [
            ["DOT_DOT MEMBER_EXPRESSION", ""]
          ],
          MEMBER_EXPRESSION: [
            ["STAR", 'yy.ast.set({ expression: { type: "wildcard", value: $1 } })'],
            ["IDENTIFIER", 'yy.ast.set({ expression: { type: "identifier", value: $1 } })'],
            ["SCRIPT_EXPRESSION", 'yy.ast.set({ expression: { type: "script_expression", value: $1 } })'],
            ["INTEGER", 'yy.ast.set({ expression: { type: "numeric_literal", value: parseInt($1) } })'],
            ["END", ""]
          ],
          SUBSCRIPT_COMPONENT: [
            ["CHILD_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "child" })'],
            ["DESCENDANT_SUBSCRIPT_COMPONENT", 'yy.ast.set({ scope: "descendant" })']
          ],
          CHILD_SUBSCRIPT_COMPONENT: [
            ["[ SUBSCRIPT ]", ""]
          ],
          DESCENDANT_SUBSCRIPT_COMPONENT: [
            ["DOT_DOT [ SUBSCRIPT ]", ""]
          ],
          SUBSCRIPT: [
            ["SUBSCRIPT_EXPRESSION", ""],
            ["SUBSCRIPT_EXPRESSION_LIST", '$1.length > 1? yy.ast.set({ expression: { type: "union", value: $1 } }) : $$ = $1']
          ],
          SUBSCRIPT_EXPRESSION_LIST: [
            ["SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = [$1]"],
            ["SUBSCRIPT_EXPRESSION_LIST , SUBSCRIPT_EXPRESSION_LISTABLE", "$$ = $1.concat($3)"]
          ],
          SUBSCRIPT_EXPRESSION_LISTABLE: [
            ["INTEGER", '$$ = { expression: { type: "numeric_literal", value: parseInt($1) } }; yy.ast.set($$)'],
            ["STRING_LITERAL", '$$ = { expression: { type: "string_literal", value: $1 } }; yy.ast.set($$)'],
            ["ARRAY_SLICE", '$$ = { expression: { type: "slice", value: $1 } }; yy.ast.set($$)']
          ],
          SUBSCRIPT_EXPRESSION: [
            ["STAR", '$$ = { expression: { type: "wildcard", value: $1 } }; yy.ast.set($$)'],
            ["SCRIPT_EXPRESSION", '$$ = { expression: { type: "script_expression", value: $1 } }; yy.ast.set($$)'],
            ["FILTER_EXPRESSION", '$$ = { expression: { type: "filter_expression", value: $1 } }; yy.ast.set($$)']
          ],
          STRING_LITERAL: [
            ["QQ_STRING", "$$ = $1"],
            ["Q_STRING", "$$ = $1"]
          ]
        }
      };
      o.readFileSync && (a.moduleInclude = o.readFileSync(r.resolve("../include/module.js")), a.actionInclude = o.readFileSync(r.resolve("../include/action.js"))), n.exports = a;
    }, { "./dict": 2, fs: 12 }], 4: [function(r, n, i) {
      var s = r("./aesprim"), o = r("./slice"), a = r("static-eval"), l = r("underscore").uniq, c = function() {
        return this.initialize.apply(this, arguments);
      };
      c.prototype.initialize = function() {
        this.traverse = v(!0), this.descend = v();
      }, c.prototype.keys = Object.keys, c.prototype.resolve = function(x) {
        var g = [x.operation, x.scope, x.expression.type].join("-"), w = this._fns[g];
        if (!w) throw new Error("couldn't resolve key: " + g);
        return w.bind(this);
      }, c.prototype.register = function(x, g) {
        if (!g instanceof Function)
          throw new Error("handler must be a function");
        this._fns[x] = g;
      }, c.prototype._fns = {
        "member-child-identifier": function(x, g) {
          var w = x.expression.value, _ = g.value;
          if (_ instanceof Object && w in _)
            return [{ value: _[w], path: g.path.concat(w) }];
        },
        "member-descendant-identifier": b(function(x, g, w) {
          return x == w;
        }),
        "subscript-child-numeric_literal": m(function(x, g, w) {
          return x === w;
        }),
        "member-child-numeric_literal": m(function(x, g, w) {
          return String(x) === String(w);
        }),
        "subscript-descendant-numeric_literal": b(function(x, g, w) {
          return x === w;
        }),
        "member-child-wildcard": m(function() {
          return !0;
        }),
        "member-descendant-wildcard": b(function() {
          return !0;
        }),
        "subscript-descendant-wildcard": b(function() {
          return !0;
        }),
        "subscript-child-wildcard": m(function() {
          return !0;
        }),
        "subscript-child-slice": function(x, g) {
          if (h(g.value)) {
            var w = x.expression.value.split(":").map(A), _ = g.value.map(function(S, R) {
              return { value: S, path: g.path.concat(R) };
            });
            return o.apply(null, [_].concat(w));
          }
        },
        "subscript-child-union": function(x, g) {
          var w = [];
          return x.expression.value.forEach(function(_) {
            var S = { operation: "subscript", scope: "child", expression: _.expression }, R = this.resolve(S), L = R(S, g);
            L && (w = w.concat(L));
          }, this), E(w);
        },
        "subscript-descendant-union": function(x, g, w) {
          var _ = r(".."), S = this, R = [], L = _.nodes(g, "$..*").slice(1);
          return L.forEach(function(F) {
            R.length >= w || x.expression.value.forEach(function(z) {
              var j = { operation: "subscript", scope: "child", expression: z.expression }, W = S.resolve(j), te = W(j, F);
              R = R.concat(te);
            });
          }), E(R);
        },
        "subscript-child-filter_expression": function(x, g, w) {
          var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(L, F) {
            return f(S, { "@": F });
          };
          return this.descend(g, null, R, w);
        },
        "subscript-descendant-filter_expression": function(x, g, w) {
          var _ = x.expression.value.slice(2, -1), S = s.parse(_).body[0].expression, R = function(L, F) {
            return f(S, { "@": F });
          };
          return this.traverse(g, null, R, w);
        },
        "subscript-child-script_expression": function(x, g) {
          var w = x.expression.value.slice(1, -1);
          return p(g, w, "$[{{value}}]");
        },
        "member-child-script_expression": function(x, g) {
          var w = x.expression.value.slice(1, -1);
          return p(g, w, "$.{{value}}");
        },
        "member-descendant-script_expression": function(x, g) {
          var w = x.expression.value.slice(1, -1);
          return p(g, w, "$..value");
        }
      }, c.prototype._fns["subscript-child-string_literal"] = c.prototype._fns["member-child-identifier"], c.prototype._fns["member-descendant-numeric_literal"] = c.prototype._fns["subscript-descendant-string_literal"] = c.prototype._fns["member-descendant-identifier"];
      function p(x, g, w) {
        var _ = r("./index"), S = s.parse(g).body[0].expression, R = f(S, { "@": x.value }), L = w.replace(/\{\{\s*value\s*\}\}/g, R), F = _.nodes(x.value, L);
        return F.forEach(function(z) {
          z.path = x.path.concat(z.path.slice(1));
        }), F;
      }
      function h(x) {
        return Array.isArray(x);
      }
      function d(x) {
        return x && !(x instanceof Array) && x instanceof Object;
      }
      function v(x) {
        return function(g, w, _, S) {
          var R = g.value, L = g.path, F = [], z = (function(j, W) {
            h(j) ? (j.forEach(function(te, le) {
              F.length >= S || _(le, te, w) && F.push({ path: W.concat(le), value: te });
            }), j.forEach(function(te, le) {
              F.length >= S || x && z(te, W.concat(le));
            })) : d(j) && (this.keys(j).forEach(function(te) {
              F.length >= S || _(te, j[te], w) && F.push({ path: W.concat(te), value: j[te] });
            }), this.keys(j).forEach(function(te) {
              F.length >= S || x && z(j[te], W.concat(te));
            }));
          }).bind(this);
          return z(R, L), F;
        };
      }
      function m(x) {
        return function(g, w, _) {
          return this.descend(w, g.expression.value, x, _);
        };
      }
      function b(x) {
        return function(g, w, _) {
          return this.traverse(w, g.expression.value, x, _);
        };
      }
      function f() {
        try {
          return a.apply(this, arguments);
        } catch {
        }
      }
      function E(x) {
        return x = x.filter(function(g) {
          return g;
        }), l(
          x,
          function(g) {
            return g.path.map(function(w) {
              return String(w).replace("-", "--");
            }).join("-");
          }
        );
      }
      function A(x) {
        var g = String(x);
        return g.match(/^-?[0-9]+$/) ? parseInt(g) : null;
      }
      n.exports = c;
    }, { "..": "jsonpath", "./aesprim": "./aesprim", "./index": 5, "./slice": 7, "static-eval": 15, underscore: 12 }], 5: [function(r, n, i) {
      var s = r("assert"), o = r("./dict"), a = r("./parser"), l = r("./handlers"), c = function() {
        this.initialize.apply(this, arguments);
      };
      c.prototype.initialize = function() {
        this.parser = new a(), this.handlers = new l();
      }, c.prototype.parse = function(d) {
        return s.ok(p(d), "we need a path"), this.parser.parse(d);
      }, c.prototype.parent = function(d, v) {
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
        var m = this.nodes(d, v)[0];
        return m.path.pop(), this.value(d, m.path);
      }, c.prototype.apply = function(d, v, m) {
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), s.equal(typeof m, "function", "fn needs to be function");
        var b = this.nodes(d, v).sort(function(f, E) {
          return E.path.length - f.path.length;
        });
        return b.forEach(function(f) {
          var E = f.path.pop(), A = this.value(d, this.stringify(f.path)), x = f.value = m.call(d, A[E]);
          A[E] = x;
        }, this), b;
      }, c.prototype.value = function(d, v, m) {
        if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), arguments.length >= 3) {
          var b = this.nodes(d, v).shift();
          if (!b) return this._vivify(d, v, m);
          var f = b.path.slice(-1).shift(), E = this.parent(d, this.stringify(b.path));
          E[f] = m;
        }
        return this.query(d, this.stringify(v), 1).shift();
      }, c.prototype._vivify = function(d, v, m) {
        var b = this;
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
        var f = this.parser.parse(v).map(function(A) {
          return A.expression.value;
        }), E = function(A, x) {
          var g = A.pop(), w = b.value(d, A);
          w || (E(A.concat(), typeof g == "string" ? {} : []), w = b.value(d, A)), w[g] = x;
        };
        return E(f, m), this.query(d, v)[0];
      }, c.prototype.query = function(d, v, m) {
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(p(v), "we need a path");
        var b = this.nodes(d, v, m).map(function(f) {
          return f.value;
        });
        return b;
      }, c.prototype.paths = function(d, v, m) {
        s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path");
        var b = this.nodes(d, v, m).map(function(f) {
          return f.path;
        });
        return b;
      }, c.prototype.nodes = function(d, v, m) {
        if (s.ok(d instanceof Object, "obj needs to be an object"), s.ok(v, "we need a path"), m === 0) return [];
        var b = this.parser.parse(v), f = this.handlers, E = [{ path: ["$"], value: d }], A = [];
        return b.length && b[0].expression.type == "root" && b.shift(), b.length ? (b.forEach(function(x, g) {
          if (!(A.length >= m)) {
            var w = f.resolve(x), _ = [];
            E.forEach(function(S) {
              if (!(A.length >= m)) {
                var R = w(x, S, m);
                g == b.length - 1 ? A = A.concat(R || []) : _ = _.concat(R || []);
              }
            }), E = _;
          }
        }), m ? A.slice(0, m) : A) : E;
      }, c.prototype.stringify = function(d) {
        s.ok(d, "we need a path");
        var v = "$", m = {
          "descendant-member": "..{{value}}",
          "child-member": ".{{value}}",
          "descendant-subscript": "..[{{value}}]",
          "child-subscript": "[{{value}}]"
        };
        return d = this._normalize(d), d.forEach(function(b) {
          if (b.expression.type != "root") {
            var f = [b.scope, b.operation].join("-"), E = m[f], A;
            if (b.expression.type == "string_literal" ? A = JSON.stringify(b.expression.value) : A = b.expression.value, !E) throw new Error("couldn't find template " + f);
            v += E.replace(/{{value}}/, A);
          }
        }), v;
      }, c.prototype._normalize = function(d) {
        if (s.ok(d, "we need a path"), typeof d == "string")
          return this.parser.parse(d);
        if (Array.isArray(d) && typeof d[0] == "string") {
          var v = [{ expression: { type: "root", value: "$" } }];
          return d.forEach(function(m, b) {
            if (!(m == "$" && b === 0))
              if (typeof m == "string" && m.match("^" + o.identifier + "$"))
                v.push({
                  operation: "member",
                  scope: "child",
                  expression: { value: m, type: "identifier" }
                });
              else {
                var f = typeof m == "number" ? "numeric_literal" : "string_literal";
                v.push({
                  operation: "subscript",
                  scope: "child",
                  expression: { value: m, type: f }
                });
              }
          }), v;
        } else if (Array.isArray(d) && typeof d[0] == "object")
          return d;
        throw new Error("couldn't understand path " + d);
      };
      function p(d) {
        return Object.prototype.toString.call(d) == "[object String]";
      }
      c.Handlers = l, c.Parser = a;
      var h = new c();
      h.JSONPath = c, n.exports = h;
    }, { "./dict": 2, "./handlers": 4, "./parser": 6, assert: 8 }], 6: [function(r, n, i) {
      var s = r("./grammar"), o = r("../generated/parser"), a = function() {
        var l = new o.Parser(), c = l.parseError;
        return l.yy.parseError = function() {
          l.yy.ast && l.yy.ast.initialize(), c.apply(l, arguments);
        }, l;
      };
      a.grammar = s, n.exports = a;
    }, { "../generated/parser": 1, "./grammar": 3 }], 7: [function(r, n, i) {
      n.exports = function(o, a, l, c) {
        if (typeof a == "string") throw new Error("start cannot be a string");
        if (typeof l == "string") throw new Error("end cannot be a string");
        if (typeof c == "string") throw new Error("step cannot be a string");
        var p = o.length;
        if (c === 0) throw new Error("step cannot be zero");
        if (c = c ? s(c) : 1, a = a < 0 ? p + a : a, l = l < 0 ? p + l : l, a = s(a === 0 ? 0 : a || (c > 0 ? 0 : p - 1)), l = s(l === 0 ? 0 : l || (c > 0 ? p : -1)), a = c > 0 ? Math.max(0, a) : Math.min(p, a), l = c > 0 ? Math.min(l, p) : Math.max(-1, l), c > 0 && l <= a) return [];
        if (c < 0 && a <= l) return [];
        for (var h = [], d = a; d != l && !(c < 0 && d <= l || c > 0 && d >= l); d += c)
          h.push(o[d]);
        return h;
      };
      function s(o) {
        return String(o).match(/^[0-9]+$/) ? parseInt(o) : Number.isFinite(o) ? parseInt(o, 10) : 0;
      }
    }, {}], 8: [function(r, n, i) {
      var s = r("util/"), o = Array.prototype.slice, a = Object.prototype.hasOwnProperty, l = n.exports = v;
      l.AssertionError = function(g) {
        this.name = "AssertionError", this.actual = g.actual, this.expected = g.expected, this.operator = g.operator, g.message ? (this.message = g.message, this.generatedMessage = !1) : (this.message = h(this), this.generatedMessage = !0);
        var w = g.stackStartFunction || d;
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, w);
        else {
          var _ = new Error();
          if (_.stack) {
            var S = _.stack, R = w.name, L = S.indexOf(`
` + R);
            if (L >= 0) {
              var F = S.indexOf(`
`, L + 1);
              S = S.substring(F + 1);
            }
            this.stack = S;
          }
        }
      }, s.inherits(l.AssertionError, Error);
      function c(g, w) {
        return s.isUndefined(w) ? "" + w : s.isNumber(w) && !isFinite(w) || s.isFunction(w) || s.isRegExp(w) ? w.toString() : w;
      }
      function p(g, w) {
        return s.isString(g) ? g.length < w ? g : g.slice(0, w) : g;
      }
      function h(g) {
        return p(JSON.stringify(g.actual, c), 128) + " " + g.operator + " " + p(JSON.stringify(g.expected, c), 128);
      }
      function d(g, w, _, S, R) {
        throw new l.AssertionError({
          message: _,
          actual: g,
          expected: w,
          operator: S,
          stackStartFunction: R
        });
      }
      l.fail = d;
      function v(g, w) {
        g || d(g, !0, w, "==", l.ok);
      }
      l.ok = v, l.equal = function(g, w, _) {
        g != w && d(g, w, _, "==", l.equal);
      }, l.notEqual = function(g, w, _) {
        g == w && d(g, w, _, "!=", l.notEqual);
      }, l.deepEqual = function(g, w, _) {
        m(g, w) || d(g, w, _, "deepEqual", l.deepEqual);
      };
      function m(g, w) {
        if (g === w)
          return !0;
        if (s.isBuffer(g) && s.isBuffer(w)) {
          if (g.length != w.length) return !1;
          for (var _ = 0; _ < g.length; _++)
            if (g[_] !== w[_]) return !1;
          return !0;
        } else return s.isDate(g) && s.isDate(w) ? g.getTime() === w.getTime() : s.isRegExp(g) && s.isRegExp(w) ? g.source === w.source && g.global === w.global && g.multiline === w.multiline && g.lastIndex === w.lastIndex && g.ignoreCase === w.ignoreCase : !s.isObject(g) && !s.isObject(w) ? g == w : f(g, w);
      }
      function b(g) {
        return Object.prototype.toString.call(g) == "[object Arguments]";
      }
      function f(g, w) {
        if (s.isNullOrUndefined(g) || s.isNullOrUndefined(w) || g.prototype !== w.prototype) return !1;
        if (s.isPrimitive(g) || s.isPrimitive(w))
          return g === w;
        var _ = b(g), S = b(w);
        if (_ && !S || !_ && S)
          return !1;
        if (_)
          return g = o.call(g), w = o.call(w), m(g, w);
        var R = x(g), L = x(w), F, z;
        if (R.length != L.length)
          return !1;
        for (R.sort(), L.sort(), z = R.length - 1; z >= 0; z--)
          if (R[z] != L[z])
            return !1;
        for (z = R.length - 1; z >= 0; z--)
          if (F = R[z], !m(g[F], w[F])) return !1;
        return !0;
      }
      l.notDeepEqual = function(g, w, _) {
        m(g, w) && d(g, w, _, "notDeepEqual", l.notDeepEqual);
      }, l.strictEqual = function(g, w, _) {
        g !== w && d(g, w, _, "===", l.strictEqual);
      }, l.notStrictEqual = function(g, w, _) {
        g === w && d(g, w, _, "!==", l.notStrictEqual);
      };
      function E(g, w) {
        return !g || !w ? !1 : Object.prototype.toString.call(w) == "[object RegExp]" ? w.test(g) : g instanceof w ? !0 : w.call({}, g) === !0;
      }
      function A(g, w, _, S) {
        var R;
        s.isString(_) && (S = _, _ = null);
        try {
          w();
        } catch (L) {
          R = L;
        }
        if (S = (_ && _.name ? " (" + _.name + ")." : ".") + (S ? " " + S : "."), g && !R && d(R, _, "Missing expected exception" + S), !g && E(R, _) && d(R, _, "Got unwanted exception" + S), g && R && _ && !E(R, _) || !g && R)
          throw R;
      }
      l.throws = function(g, w, _) {
        A.apply(this, [!0].concat(o.call(arguments)));
      }, l.doesNotThrow = function(g, w) {
        A.apply(this, [!1].concat(o.call(arguments)));
      }, l.ifError = function(g) {
        if (g)
          throw g;
      };
      var x = Object.keys || function(g) {
        var w = [];
        for (var _ in g)
          a.call(g, _) && w.push(_);
        return w;
      };
    }, { "util/": 11 }], 9: [function(r, n, i) {
      typeof Object.create == "function" ? n.exports = function(s, o) {
        s.super_ = o, s.prototype = Object.create(o.prototype, {
          constructor: {
            value: s,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
      } : n.exports = function(s, o) {
        s.super_ = o;
        var a = function() {
        };
        a.prototype = o.prototype, s.prototype = new a(), s.prototype.constructor = s;
      };
    }, {}], 10: [function(r, n, i) {
      n.exports = function(s) {
        return s && typeof s == "object" && typeof s.copy == "function" && typeof s.fill == "function" && typeof s.readUInt8 == "function";
      };
    }, {}], 11: [function(r, n, i) {
      (function(s, o) {
        var a = /%[sdj%]/g;
        i.format = function(O) {
          if (!L(O)) {
            for (var N = [], J = 0; J < arguments.length; J++)
              N.push(p(arguments[J]));
            return N.join(" ");
          }
          for (var J = 1, re = arguments, oe = re.length, ee = String(O).replace(a, function(H) {
            if (H === "%%") return "%";
            if (J >= oe) return H;
            switch (H) {
              case "%s":
                return String(re[J++]);
              case "%d":
                return Number(re[J++]);
              case "%j":
                try {
                  return JSON.stringify(re[J++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return H;
            }
          }), ae = re[J]; J < oe; ae = re[++J])
            _(ae) || !W(ae) ? ee += " " + ae : ee += " " + p(ae);
          return ee;
        }, i.deprecate = function(O, N) {
          if (z(o.process))
            return function() {
              return i.deprecate(O, N).apply(this, arguments);
            };
          if (s.noDeprecation === !0)
            return O;
          var J = !1;
          function re() {
            if (!J) {
              if (s.throwDeprecation)
                throw new Error(N);
              s.traceDeprecation ? console.trace(N) : console.error(N), J = !0;
            }
            return O.apply(this, arguments);
          }
          return re;
        };
        var l = {}, c;
        i.debuglog = function(O) {
          if (z(c) && (c = s.env.NODE_DEBUG || ""), O = O.toUpperCase(), !l[O])
            if (new RegExp("\\b" + O + "\\b", "i").test(c)) {
              var N = s.pid;
              l[O] = function() {
                var J = i.format.apply(i, arguments);
                console.error("%s %d: %s", O, N, J);
              };
            } else
              l[O] = function() {
              };
          return l[O];
        };
        function p(O, N) {
          var J = {
            seen: [],
            stylize: d
          };
          return arguments.length >= 3 && (J.depth = arguments[2]), arguments.length >= 4 && (J.colors = arguments[3]), w(N) ? J.showHidden = N : N && i._extend(J, N), z(J.showHidden) && (J.showHidden = !1), z(J.depth) && (J.depth = 2), z(J.colors) && (J.colors = !1), z(J.customInspect) && (J.customInspect = !0), J.colors && (J.stylize = h), m(J, O, J.depth);
        }
        i.inspect = p, p.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        }, p.styles = {
          special: "cyan",
          number: "yellow",
          boolean: "yellow",
          undefined: "grey",
          null: "bold",
          string: "green",
          date: "magenta",
          // "name": intentionally not styling
          regexp: "red"
        };
        function h(O, N) {
          var J = p.styles[N];
          return J ? "\x1B[" + p.colors[J][0] + "m" + O + "\x1B[" + p.colors[J][1] + "m" : O;
        }
        function d(O, N) {
          return O;
        }
        function v(O) {
          var N = {};
          return O.forEach(function(J, re) {
            N[J] = !0;
          }), N;
        }
        function m(O, N, J) {
          if (O.customInspect && N && ce(N.inspect) && // Filter out the util module, it's inspect function is special
          N.inspect !== i.inspect && // Also filter out any prototype objects using the circular check.
          !(N.constructor && N.constructor.prototype === N)) {
            var re = N.inspect(J, O);
            return L(re) || (re = m(O, re, J)), re;
          }
          var oe = b(O, N);
          if (oe)
            return oe;
          var ee = Object.keys(N), ae = v(ee);
          if (O.showHidden && (ee = Object.getOwnPropertyNames(N)), le(N) && (ee.indexOf("message") >= 0 || ee.indexOf("description") >= 0))
            return f(N);
          if (ee.length === 0) {
            if (ce(N)) {
              var me = N.name ? ": " + N.name : "";
              return O.stylize("[Function" + me + "]", "special");
            }
            if (j(N))
              return O.stylize(RegExp.prototype.toString.call(N), "regexp");
            if (te(N))
              return O.stylize(Date.prototype.toString.call(N), "date");
            if (le(N))
              return f(N);
          }
          var H = "", X = !1, Ae = ["{", "}"];
          if (g(N) && (X = !0, Ae = ["[", "]"]), ce(N)) {
            var Re = N.name ? ": " + N.name : "";
            H = " [Function" + Re + "]";
          }
          if (j(N) && (H = " " + RegExp.prototype.toString.call(N)), te(N) && (H = " " + Date.prototype.toUTCString.call(N)), le(N) && (H = " " + f(N)), ee.length === 0 && (!X || N.length == 0))
            return Ae[0] + H + Ae[1];
          if (J < 0)
            return j(N) ? O.stylize(RegExp.prototype.toString.call(N), "regexp") : O.stylize("[Object]", "special");
          O.seen.push(N);
          var Fe;
          return X ? Fe = E(O, N, J, ae, ee) : Fe = ee.map(function(Te) {
            return A(O, N, J, ae, Te, X);
          }), O.seen.pop(), x(Fe, H, Ae);
        }
        function b(O, N) {
          if (z(N))
            return O.stylize("undefined", "undefined");
          if (L(N)) {
            var J = "'" + JSON.stringify(N).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return O.stylize(J, "string");
          }
          if (R(N))
            return O.stylize("" + N, "number");
          if (w(N))
            return O.stylize("" + N, "boolean");
          if (_(N))
            return O.stylize("null", "null");
        }
        function f(O) {
          return "[" + Error.prototype.toString.call(O) + "]";
        }
        function E(O, N, J, re, oe) {
          for (var ee = [], ae = 0, me = N.length; ae < me; ++ae)
            ue(N, String(ae)) ? ee.push(A(
              O,
              N,
              J,
              re,
              String(ae),
              !0
            )) : ee.push("");
          return oe.forEach(function(H) {
            H.match(/^\d+$/) || ee.push(A(
              O,
              N,
              J,
              re,
              H,
              !0
            ));
          }), ee;
        }
        function A(O, N, J, re, oe, ee) {
          var ae, me, H;
          if (H = Object.getOwnPropertyDescriptor(N, oe) || { value: N[oe] }, H.get ? H.set ? me = O.stylize("[Getter/Setter]", "special") : me = O.stylize("[Getter]", "special") : H.set && (me = O.stylize("[Setter]", "special")), ue(re, oe) || (ae = "[" + oe + "]"), me || (O.seen.indexOf(H.value) < 0 ? (_(J) ? me = m(O, H.value, null) : me = m(O, H.value, J - 1), me.indexOf(`
`) > -1 && (ee ? me = me.split(`
`).map(function(X) {
            return "  " + X;
          }).join(`
`).substr(2) : me = `
` + me.split(`
`).map(function(X) {
            return "   " + X;
          }).join(`
`))) : me = O.stylize("[Circular]", "special")), z(ae)) {
            if (ee && oe.match(/^\d+$/))
              return me;
            ae = JSON.stringify("" + oe), ae.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ae = ae.substr(1, ae.length - 2), ae = O.stylize(ae, "name")) : (ae = ae.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ae = O.stylize(ae, "string"));
          }
          return ae + ": " + me;
        }
        function x(O, N, J) {
          var re = O.reduce(function(oe, ee) {
            return ee.indexOf(`
`) >= 0, oe + ee.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return re > 60 ? J[0] + (N === "" ? "" : N + `
 `) + " " + O.join(`,
  `) + " " + J[1] : J[0] + N + " " + O.join(", ") + " " + J[1];
        }
        function g(O) {
          return Array.isArray(O);
        }
        i.isArray = g;
        function w(O) {
          return typeof O == "boolean";
        }
        i.isBoolean = w;
        function _(O) {
          return O === null;
        }
        i.isNull = _;
        function S(O) {
          return O == null;
        }
        i.isNullOrUndefined = S;
        function R(O) {
          return typeof O == "number";
        }
        i.isNumber = R;
        function L(O) {
          return typeof O == "string";
        }
        i.isString = L;
        function F(O) {
          return typeof O == "symbol";
        }
        i.isSymbol = F;
        function z(O) {
          return O === void 0;
        }
        i.isUndefined = z;
        function j(O) {
          return W(O) && xe(O) === "[object RegExp]";
        }
        i.isRegExp = j;
        function W(O) {
          return typeof O == "object" && O !== null;
        }
        i.isObject = W;
        function te(O) {
          return W(O) && xe(O) === "[object Date]";
        }
        i.isDate = te;
        function le(O) {
          return W(O) && (xe(O) === "[object Error]" || O instanceof Error);
        }
        i.isError = le;
        function ce(O) {
          return typeof O == "function";
        }
        i.isFunction = ce;
        function Ee(O) {
          return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || // ES6 symbol
          typeof O > "u";
        }
        i.isPrimitive = Ee, i.isBuffer = r("./support/isBuffer");
        function xe(O) {
          return Object.prototype.toString.call(O);
        }
        function _e(O) {
          return O < 10 ? "0" + O.toString(10) : O.toString(10);
        }
        var Ie = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ];
        function je() {
          var O = /* @__PURE__ */ new Date(), N = [
            _e(O.getHours()),
            _e(O.getMinutes()),
            _e(O.getSeconds())
          ].join(":");
          return [O.getDate(), Ie[O.getMonth()], N].join(" ");
        }
        i.log = function() {
          console.log("%s - %s", je(), i.format.apply(i, arguments));
        }, i.inherits = r("inherits"), i._extend = function(O, N) {
          if (!N || !W(N)) return O;
          for (var J = Object.keys(N), re = J.length; re--; )
            O[J[re]] = N[J[re]];
          return O;
        };
        function ue(O, N) {
          return Object.prototype.hasOwnProperty.call(O, N);
        }
      }).call(this, r("_process"), typeof CI < "u" ? CI : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./support/isBuffer": 10, _process: 14, inherits: 9 }], 12: [function(r, n, i) {
    }, {}], 13: [function(r, n, i) {
      (function(s) {
        function o(p, h) {
          for (var d = 0, v = p.length - 1; v >= 0; v--) {
            var m = p[v];
            m === "." ? p.splice(v, 1) : m === ".." ? (p.splice(v, 1), d++) : d && (p.splice(v, 1), d--);
          }
          if (h)
            for (; d--; d)
              p.unshift("..");
          return p;
        }
        i.resolve = function() {
          for (var p = "", h = !1, d = arguments.length - 1; d >= -1 && !h; d--) {
            var v = d >= 0 ? arguments[d] : s.cwd();
            if (typeof v != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            v && (p = v + "/" + p, h = v.charAt(0) === "/");
          }
          return p = o(l(p.split("/"), function(m) {
            return !!m;
          }), !h).join("/"), (h ? "/" : "") + p || ".";
        }, i.normalize = function(p) {
          var h = i.isAbsolute(p), d = c(p, -1) === "/";
          return p = o(l(p.split("/"), function(v) {
            return !!v;
          }), !h).join("/"), !p && !h && (p = "."), p && d && (p += "/"), (h ? "/" : "") + p;
        }, i.isAbsolute = function(p) {
          return p.charAt(0) === "/";
        }, i.join = function() {
          var p = Array.prototype.slice.call(arguments, 0);
          return i.normalize(l(p, function(h, d) {
            if (typeof h != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return h;
          }).join("/"));
        }, i.relative = function(p, h) {
          p = i.resolve(p).substr(1), h = i.resolve(h).substr(1);
          function d(x) {
            for (var g = 0; g < x.length && x[g] === ""; g++)
              ;
            for (var w = x.length - 1; w >= 0 && x[w] === ""; w--)
              ;
            return g > w ? [] : x.slice(g, w - g + 1);
          }
          for (var v = d(p.split("/")), m = d(h.split("/")), b = Math.min(v.length, m.length), f = b, E = 0; E < b; E++)
            if (v[E] !== m[E]) {
              f = E;
              break;
            }
          for (var A = [], E = f; E < v.length; E++)
            A.push("..");
          return A = A.concat(m.slice(f)), A.join("/");
        }, i.sep = "/", i.delimiter = ":", i.dirname = function(p) {
          if (typeof p != "string" && (p = p + ""), p.length === 0) return ".";
          for (var h = p.charCodeAt(0), d = h === 47, v = -1, m = !0, b = p.length - 1; b >= 1; --b)
            if (h = p.charCodeAt(b), h === 47) {
              if (!m) {
                v = b;
                break;
              }
            } else
              m = !1;
          return v === -1 ? d ? "/" : "." : d && v === 1 ? "/" : p.slice(0, v);
        };
        function a(p) {
          typeof p != "string" && (p = p + "");
          var h = 0, d = -1, v = !0, m;
          for (m = p.length - 1; m >= 0; --m)
            if (p.charCodeAt(m) === 47) {
              if (!v) {
                h = m + 1;
                break;
              }
            } else d === -1 && (v = !1, d = m + 1);
          return d === -1 ? "" : p.slice(h, d);
        }
        i.basename = function(p, h) {
          var d = a(p);
          return h && d.substr(-1 * h.length) === h && (d = d.substr(0, d.length - h.length)), d;
        }, i.extname = function(p) {
          typeof p != "string" && (p = p + "");
          for (var h = -1, d = 0, v = -1, m = !0, b = 0, f = p.length - 1; f >= 0; --f) {
            var E = p.charCodeAt(f);
            if (E === 47) {
              if (!m) {
                d = f + 1;
                break;
              }
              continue;
            }
            v === -1 && (m = !1, v = f + 1), E === 46 ? h === -1 ? h = f : b !== 1 && (b = 1) : h !== -1 && (b = -1);
          }
          return h === -1 || v === -1 || // We saw a non-dot character immediately before the dot
          b === 0 || // The (right-most) trimmed path component is exactly '..'
          b === 1 && h === v - 1 && h === d + 1 ? "" : p.slice(h, v);
        };
        function l(p, h) {
          if (p.filter) return p.filter(h);
          for (var d = [], v = 0; v < p.length; v++)
            h(p[v], v, p) && d.push(p[v]);
          return d;
        }
        var c = "ab".substr(-1) === "b" ? function(p, h, d) {
          return p.substr(h, d);
        } : function(p, h, d) {
          return h < 0 && (h = p.length + h), p.substr(h, d);
        };
      }).call(this, r("_process"));
    }, { _process: 14 }], 14: [function(r, n, i) {
      var s = n.exports = {}, o, a;
      function l() {
        throw new Error("setTimeout has not been defined");
      }
      function c() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? o = setTimeout : o = l;
        } catch {
          o = l;
        }
        try {
          typeof clearTimeout == "function" ? a = clearTimeout : a = c;
        } catch {
          a = c;
        }
      })();
      function p(g) {
        if (o === setTimeout)
          return setTimeout(g, 0);
        if ((o === l || !o) && setTimeout)
          return o = setTimeout, setTimeout(g, 0);
        try {
          return o(g, 0);
        } catch {
          try {
            return o.call(null, g, 0);
          } catch {
            return o.call(this, g, 0);
          }
        }
      }
      function h(g) {
        if (a === clearTimeout)
          return clearTimeout(g);
        if ((a === c || !a) && clearTimeout)
          return a = clearTimeout, clearTimeout(g);
        try {
          return a(g);
        } catch {
          try {
            return a.call(null, g);
          } catch {
            return a.call(this, g);
          }
        }
      }
      var d = [], v = !1, m, b = -1;
      function f() {
        !v || !m || (v = !1, m.length ? d = m.concat(d) : b = -1, d.length && E());
      }
      function E() {
        if (!v) {
          var g = p(f);
          v = !0;
          for (var w = d.length; w; ) {
            for (m = d, d = []; ++b < w; )
              m && m[b].run();
            b = -1, w = d.length;
          }
          m = null, v = !1, h(g);
        }
      }
      s.nextTick = function(g) {
        var w = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var _ = 1; _ < arguments.length; _++)
            w[_ - 1] = arguments[_];
        d.push(new A(g, w)), d.length === 1 && !v && p(E);
      };
      function A(g, w) {
        this.fun = g, this.array = w;
      }
      A.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
      function x() {
      }
      s.on = x, s.addListener = x, s.once = x, s.off = x, s.removeListener = x, s.removeAllListeners = x, s.emit = x, s.prependListener = x, s.prependOnceListener = x, s.listeners = function(g) {
        return [];
      }, s.binding = function(g) {
        throw new Error("process.binding is not supported");
      }, s.cwd = function() {
        return "/";
      }, s.chdir = function(g) {
        throw new Error("process.chdir is not supported");
      }, s.umask = function() {
        return 0;
      };
    }, {}], 15: [function(r, n, i) {
      var s = r("escodegen").generate;
      n.exports = function(o, a) {
        a || (a = {});
        var l = {}, c = function p(h, d) {
          if (h.type === "Literal")
            return h.value;
          if (h.type === "UnaryExpression") {
            var v = p(h.argument);
            return h.operator === "+" ? +v : h.operator === "-" ? -v : h.operator === "~" ? ~v : h.operator === "!" ? !v : l;
          } else if (h.type === "ArrayExpression") {
            for (var m = [], b = 0, f = h.elements.length; b < f; b++) {
              var E = p(h.elements[b]);
              if (E === l) return l;
              m.push(E);
            }
            return m;
          } else if (h.type === "ObjectExpression") {
            for (var A = {}, b = 0; b < h.properties.length; b++) {
              var x = h.properties[b], g = x.value === null ? x.value : p(x.value);
              if (g === l) return l;
              A[x.key.value || x.key.name] = g;
            }
            return A;
          } else if (h.type === "BinaryExpression" || h.type === "LogicalExpression") {
            var f = p(h.left);
            if (f === l) return l;
            var w = p(h.right);
            if (w === l) return l;
            var _ = h.operator;
            return _ === "==" ? f == w : _ === "===" ? f === w : _ === "!=" ? f != w : _ === "!==" ? f !== w : _ === "+" ? f + w : _ === "-" ? f - w : _ === "*" ? f * w : _ === "/" ? f / w : _ === "%" ? f % w : _ === "<" ? f < w : _ === "<=" ? f <= w : _ === ">" ? f > w : _ === ">=" ? f >= w : _ === "|" ? f | w : _ === "&" ? f & w : _ === "^" ? f ^ w : _ === "&&" ? f && w : _ === "||" ? f || w : l;
          } else {
            if (h.type === "Identifier")
              return {}.hasOwnProperty.call(a, h.name) ? a[h.name] : l;
            if (h.type === "ThisExpression")
              return {}.hasOwnProperty.call(a, "this") ? a.this : l;
            if (h.type === "CallExpression") {
              var S = p(h.callee);
              if (S === l || typeof S != "function") return l;
              var R = h.callee.object ? p(h.callee.object) : l;
              R === l && (R = null);
              for (var L = [], b = 0, f = h.arguments.length; b < f; b++) {
                var E = p(h.arguments[b]);
                if (E === l) return l;
                L.push(E);
              }
              return S.apply(R, L);
            } else if (h.type === "MemberExpression") {
              var A = p(h.object);
              if (A === l || typeof A == "function")
                return l;
              if (h.property.type === "Identifier")
                return A[h.property.name];
              var x = p(h.property);
              return x === l ? l : A[x];
            } else if (h.type === "ConditionalExpression") {
              var v = p(h.test);
              return v === l ? l : p(v ? h.consequent : h.alternate);
            } else if (h.type === "ExpressionStatement") {
              var v = p(h.expression);
              return v === l ? l : v;
            } else {
              if (h.type === "ReturnStatement")
                return p(h.argument);
              if (h.type === "FunctionExpression") {
                var F = h.body.body, z = {};
                Object.keys(a).forEach(function(Ie) {
                  z[Ie] = a[Ie];
                });
                for (var b = 0; b < h.params.length; b++) {
                  var j = h.params[b];
                  if (j.type == "Identifier")
                    a[j.name] = null;
                  else return l;
                }
                for (var b in F)
                  if (p(F[b]) === l)
                    return l;
                a = z;
                var W = Object.keys(a), te = W.map(function(Ie) {
                  return a[Ie];
                });
                return Function(W.join(", "), "return " + s(h)).apply(null, te);
              } else if (h.type === "TemplateLiteral") {
                for (var le = "", b = 0; b < h.expressions.length; b++)
                  le += p(h.quasis[b]), le += p(h.expressions[b]);
                return le += p(h.quasis[b]), le;
              } else if (h.type === "TaggedTemplateExpression") {
                var ce = p(h.tag), Ee = h.quasi, xe = Ee.quasis.map(p), _e = Ee.expressions.map(p);
                return ce.apply(null, [xe].concat(_e));
              } else return h.type === "TemplateElement" ? h.value.cooked : l;
            }
          }
        }(o);
        return c === l ? void 0 : c;
      };
    }, { escodegen: 12 }], jsonpath: [function(r, n, i) {
      n.exports = r("./lib/index");
    }, { "./lib/index": 5 }] }, {}, ["jsonpath"])("jsonpath");
  });
})(mj);
var v2e = mj.exports;
const v4 = /* @__PURE__ */ y2e(v2e);
function $d(t) {
  let e, r, n;
  return e = t, (i, s, o) => {
    if (o.value != null)
      o.value = II(o.value, e, r, n);
    else if (o.get != null)
      o.get = II(o.get, e, r, n);
    else
      throw "Only put a Memoize() decorator on a method or get accessor.";
  };
}
const O3 = /* @__PURE__ */ new Map();
function II(t, e, r = 0, n) {
  const i = Symbol("__memoized_map__");
  return function(...s) {
    let o;
    this.hasOwnProperty(i) || Object.defineProperty(this, i, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: /* @__PURE__ */ new Map()
    });
    let a = this[i];
    if (Array.isArray(n))
      for (const l of n)
        O3.has(l) ? O3.get(l).push(a) : O3.set(l, [a]);
    if (e || s.length > 0 || r > 0) {
      let l;
      e === !0 ? l = s.map((h) => h.toString()).join("!") : e ? l = e.apply(this, s) : l = s[0];
      const c = `${l}__timestamp`;
      let p = !1;
      if (r > 0)
        if (!a.has(c))
          p = !0;
        else {
          let h = a.get(c);
          p = Date.now() - h > r;
        }
      a.has(l) && !p ? o = a.get(l) : (o = t.apply(this, s), a.set(l, o), r > 0 && a.set(c, Date.now()));
    } else {
      const l = this;
      a.has(l) ? o = a.get(l) : (o = t.apply(this, s), a.set(l, o));
    }
    return o;
  };
}
var b2e = Object.defineProperty, w2e = (t, e, r) => e in t ? b2e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ki = (t, e, r) => w2e(t, typeof e != "symbol" ? e + "" : e, r), x2e = Object.defineProperty, E2e = (t, e, r) => e in t ? x2e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Lo = (t, e, r) => (E2e(t, typeof e != "symbol" ? e + "" : e, r), r), yj = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(globalThis, () => (() => {
    var r, n = { d: (Z, I) => {
      for (var B in I)
        n.o(I, B) && !n.o(Z, B) && Object.defineProperty(Z, B, { enumerable: !0, get: I[B] });
    }, o: (Z, I) => Object.prototype.hasOwnProperty.call(Z, I), r: (Z) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(Z, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(Z, "__esModule", { value: !0 });
    } }, i = {};
    async function s(Z) {
      const I = new DecompressionStream("gzip"), B = Z.stream().pipeThrough(I);
      return await new Response(B).blob();
    }
    n.r(i), n.d(i, { A: () => kt, AP: () => St, Adv: () => Je, AdvP: () => zt, C: () => C, CP: () => tr, Constituent: () => w, D: () => fe, DT: () => D, Dependent: () => ue, Dependent_en: () => Ai, N: () => it, NO: () => se, NP: () => dt, P: () => $, PP: () => Xt, Phrase: () => Ie, Phrase_en: () => Se, Pro: () => Ze, Q: () => pe, S: () => ot, SP: () => Nr, Terminal: () => le, Terminal_en: () => ge, V: () => ye, VP: () => rt, addToLexicon: () => p, comp: () => de, coord: () => ve, dependent: () => Zt, det: () => U, exceptionOnWarning: () => tt, fromJSON: () => oe, getElems: () => ae, getLanguage: () => d, getLemma: () => h, getLexicon: () => v, getRules: () => m, getSavedWarnings: () => er, isRunningUnderNode: () => Te, jsRealB_dateCreated: () => Fe, jsRealB_version: () => Re, load: () => me, loadEn: () => c, mix: () => Ae, mod: () => K, oneOf: () => X, phrase: () => Le, ppJSON: () => ee, resetSavedWarnings: () => At, root: () => Un, savedWarnings: () => qe, setExceptionOnWarning: () => Pe, setQuoteOOV: () => f, setReorderVPcomplements: () => A, subj: () => M, terminal: () => ht });
    const o = {}, a = {};
    let l = "en";
    async function c(Z = !1) {
      l = "en", await async function() {
        console.log("decompressing lexicon  and grammar rules");
        const I = await (await fetch("data:application/gzip;base64,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")).blob(), B = JSON.parse(await (await s(I)).text()), q = await (await fetch("data:application/gzip;base64,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")).blob(), G = JSON.parse(await (await s(q)).text());
        o.en = B, a.en = G;
      }(), Z && console.log("English lexicon and rules loaded");
    }
    function p(Z, I, B) {
      let q = v(B);
      if (I !== null)
        return I == null && (I = Object.values(Z)[0], Z = Object.keys(Z)[0]), q[Z] !== void 0 && I !== void 0 ? Object.assign(q[Z], I) : q[Z] = I, q[Z];
      q[Z] !== void 0 && delete q[Z];
    }
    function h(Z, I) {
      return v(I)[Z];
    }
    function d() {
      return l;
    }
    function v(Z) {
      return Z !== void 0 ? o[Z] : o[l];
    }
    function m(Z) {
      return Z !== void 0 ? a[Z] : a[l];
    }
    let b = !1;
    function f(Z) {
      b = Z;
    }
    let E = !1;
    function A(Z) {
      E = Z;
    }
    const x = ["root", "subj", "det", "mod", "comp", "coord"], g = class P1 {
      constructor(I) {
        this.parentConst = null, this.constType = I, this.props = {}, this.realization = null, this.optSource = "";
      }
      initProps() {
        if (this.isA("N", "A", "D", "V", "NO", "Pro", "Q", "DT")) {
          const I = this.defaultProps();
          this.peng = { pe: I.pe, n: I.n, g: I.g, pengNO: P1.pengNO++ }, this.isA("V") && (this.taux = { t: I.t, tauxNO: P1.tauxNO++ });
        }
      }
      clone() {
        return oe(this.toJSON(), this.lang);
      }
      error(I) {
        throw `Internal error: this should never have happened, sorry!
` + this.me() + ":: " + I;
      }
      isA(I) {
        if (arguments.length == 1) {
          if (!Array.isArray(I))
            return I == this.constType;
        } else
          I = Array.from(arguments);
        return I.includes(this.constType);
      }
      getProp(I) {
        const B = this.props[I];
        return B !== void 0 ? B : I == "pe" || I == "n" || I == "g" ? this.peng === void 0 ? void 0 : this.peng[I] : I == "t" || I == "aux" ? this.taux === void 0 ? void 0 : this.taux[I] : void 0;
      }
      setProp(I, B, q) {
        I == "pe" || I == "n" || I == "g" ? this.peng !== void 0 && (this.peng[I] = B) : I != "t" && I != "aux" || this.taux !== void 0 && (this.taux[I] = B), ["pe", "n", "g", "t", "aux"].includes(I) && q !== void 0 || (this.props[I] = B);
      }
      getFromPath(I) {
        if (I.length == 0)
          return this;
        const B = I.shift(), q = this.getConst(B);
        return q === void 0 ? typeof B == "object" && B.includes("") && I.length > 0 ? this.getFromPath(I) : void 0 : q.getFromPath(I);
      }
      getTonicPro(I) {
        if (this.isA("Pro")) {
          if (this.props.tn || this.props.c)
            return I !== void 0 ? this.props.c = I : (this.props.tn = "", "c" in this.props && delete this.props.c), this;
          if (this.tonic_forms().includes(this.lemma)) {
            if (I !== void 0)
              return Ze(this.lemma, this.lang).c(I);
          } else if (I !== void 0)
            return Ze(this.realize(), this.lang).c(I);
          return this;
        }
        {
          let B = Ze(this.tonic_pe_1(), this.lang);
          const q = this.getProp("g");
          q !== void 0 && B.g(q);
          const G = this.getProp("n");
          G !== void 0 && B.n(G);
          const Y = this.getProp("pe");
          return Y !== void 0 && B.pe(Y), I === void 0 ? Ze(B.realize(), this.lang).tn("") : Ze(B.realize(), this.lang).c(I);
        }
      }
      getParentLang() {
        return this.lang !== void 0 ? this.lang : this.parentConst === null ? d() : this.parentConst.getParentLang();
      }
      addOptSource(I, B) {
        this.optSource += "." + I + "(" + (B === void 0 ? "" : JSON.stringify(B)) + ")";
      }
      tag(I, B) {
        return B == null || Object.keys(B).length == 0 ? (this.addOptSource("tag", I), B = {}) : this.optSource += ".tag('" + I + "'," + JSON.stringify(B) + ")", this.props.tag === void 0 && (this.props.tag = []), this.props.tag.push([I, B]), this;
      }
      dOpt(I) {
        if (this.addOptSource("dOpt", I), typeof I != "object")
          return this.warn("bad application", ".dOpt", "object", typeof I);
        if (this.isA("DT")) {
          const B = ["year", "month", "date", "day", "hour", "minute", "second", "nat", "det", "rtime"], q = Object.keys(I);
          for (let G = 0; G < q.length; G++) {
            const Y = q[G];
            if (!B.includes(Y))
              return this.warn("ignored value for option", "DT.dOpt", Y);
            {
              const ie = I[Y];
              if (Y == "rtime")
                if (typeof ie == "boolean")
                  this.props.dOpt.rtime = !!ie && /* @__PURE__ */ new Date();
                else if (typeof ie == "string")
                  this.props.dOpt.rtime = new Date(ie);
                else {
                  if (!(ie instanceof Date))
                    return this.warn("bad application", ".dOpt('rtime')", ["boolean", "string", "Date"], ie);
                  this.props.dOpt.rtime = ie;
                }
              else {
                if (typeof ie != "boolean")
                  return this.warn("bad application", ".dOpt(" + Y + ")", "boolean", ie);
                this.props.dOpt[Y] = ie;
              }
            }
          }
        } else {
          if (!this.isA("NO"))
            return this.warn("bad application", ".dOpt", ["DT", "NO"], this.constType);
          {
            const B = ["mprecision", "raw", "nat", "ord", "rom"], q = Object.keys(I);
            for (let G = 0; G < q.length; G++) {
              const Y = q[G];
              if (!B.includes(Y))
                return this.warn("ignored value for option", "NO.dOpt", Y);
              {
                const ie = I[Y];
                if (Y == "mprecision") {
                  if (typeof ie != "number")
                    return this.warn("bad application", "precision", "number", ie);
                  this.props.dOpt.mprecision = ie;
                } else {
                  if (typeof ie != "boolean")
                    return this.warn("bad application", ".dOpt(" + Y + ")", "boolean", ie);
                  this.props.dOpt[Y] = ie;
                }
              }
            }
          }
        }
        return this;
      }
      nat(I) {
        if (this.addOptSource("nat", I), !this.isA("DT", "NO"))
          return this.warn("bad application", ".nat", ["DT", "NO"], this.constType);
        {
          const B = this.props.dOpt;
          if (I === void 0)
            B.nat = !0;
          else {
            if (typeof I != "boolean")
              return this.warn("bad application", ".nat", "boolean", I);
            B.nat = I;
          }
        }
        return this;
      }
      typ(I) {
        const B = { neg: [!1, !0], pas: [!1, !0], prog: [!1, !0], exc: [!1, !0], perf: [!1, !0], contr: [!1, !0], refl: [!1, !0], mod: [!1, "poss", "perm", "nece", "obli", "will"], int: [!1, "yon", "wos", "wod", "woi", "was", "wad", "wai", "whe", "why", "whn", "how", "muc", "tag"] };
        if (this.addOptSource("typ", I), this.isA("S", "SP", "VP") || this.isA(x))
          if (typeof I == "object") {
            for (let q in I) {
              const G = I[q], Y = B[q];
              Y === void 0 ? this.warn("unknown type", q, Object.keys(B)) : q == "neg" && this.validate_neg_option(G, I) || Y.includes(G) || (this.warn("ignored value for option", ".typ(" + q + ")", G), delete I[q]);
            }
            this.props.typ = I;
          } else
            this.warn("ignored value for option", ".typ", typeof I + ":" + JSON.stringify(I));
        else
          this.warn("bad application", ".typ(" + JSON.stringify(I) + ")", ["S", "SP", "VP", "Dependent"], this.constType);
        return this;
      }
      doFormat(I) {
        const B = m(this.lang).punctuation, q = v(this.lang);
        function G($e) {
          const Qe = q[$e];
          if (Qe !== void 0 && Qe.Pc !== void 0) {
            const ut = Qe.Pc.compl;
            if (ut !== void 0) {
              const st = $e, Rt = ut, $t = Qe.Pc.tab, Or = $t[0], an = $t.length == 2 ? $t[1] : q[ut].Pc.tab[0], wo = B[Or], xo = B[an];
              return { b: wo.b + st + wo.a, a: xo.b + Rt + xo.a };
            }
            {
              const st = Qe.Pc.tab[0], Rt = B[st];
              $e = Rt.b + $e + Rt.a;
            }
          }
          return { b: $e, a: $e };
        }
        function Y($e, Qe) {
          I[0].realization = $e + I[0].realization, I[I.length - 1].realization += Qe;
        }
        (function($e) {
          for (let Qe = 0; Qe < $e.length; )
            $e[Qe].realization == "" && $e.length > 1 ? $e.splice(Qe, 1) : Qe++;
        })(I), (this.isA("VP") || this.isA(x) && this.terminal.isA("V")) && this.doPronounPlacement(I), this.doElision(I);
        const ie = this.props.cap;
        if (ie !== void 0 && ie !== !1) {
          const $e = I[0].realization;
          $e.length > 0 && (I[0].realization = $e.charAt(0).toUpperCase() + $e.substring(1));
        }
        const he = this.props.tag;
        he !== void 0 && he.forEach(function($e) {
          const Qe = $e[0];
          var ut;
          Y((ut = $e[1], "<" + Qe + Object.entries(ut).map(function(st) {
            return " " + st[0] + '="' + st[1] + '"';
          }).join("") + ">"), "</" + Qe + ">");
        });
        const be = this.props.a;
        be !== void 0 && be.forEach(function($e) {
          Y("", G($e).b);
        });
        const ke = this.props.b;
        ke !== void 0 && ke.forEach(function($e) {
          Y(G($e).b, "");
        });
        const De = this.props.en || this.props.ba;
        return De !== void 0 && De.forEach(function($e) {
          const Qe = G($e);
          Y(Qe.b, Qe.a);
        }), I;
      }
      detokenize(I) {
        let B = "";
        const q = I.length - 1;
        if (q < 0)
          return B;
        for (let G = 0; G < q; G++) {
          const Y = I[G];
          Y.props.lier === !0 ? B += Y.realization + "-" + this.check_for_t(I, G) : /[- ']$/.exec(Y.realization) ? B += Y.realization : Y.realization.length > 0 && (B += Y.realization + " ");
        }
        if (B += I[q].realization, this.parentConst == null && (this.isA("S", "root") || this.isA("coord") && this.dependents[0].isA("root")) && B.length > 0 && this.props.cap !== !1) {
          const G = this.sepWordRE().exec(B)[1].length;
          if (G < B.length && (B = B.substring(0, G) + B.charAt(G).toUpperCase() + B.substring(G + 1)), this.props.tag === void 0) {
            const Y = /(.)( |(<[^>]+>))*$/.exec(B);
            Y == null || "?!.:;/)]}".includes(Y[1]) || (B += ". ");
          }
        }
        return B;
      }
      realize(I) {
        I !== void 0 && load(I);
        const B = this.real();
        return this.detokenize(B);
      }
      toString() {
        return P1.debug ? this.toSource() : this.realize();
      }
      indentSep(I, B) {
        return I >= 0 ? (I = I + this.constType.length + 1, B && this.peng !== void 0 && (this.peng.pengNO !== void 0 && (I += ("#" + this.peng.pengNO).length), this.taux && this.taux.tauxNO !== void 0 && (I += ("-" + this.taux.tauxNO).length)), [I, `,
` + " ".repeat(I)]) : [I, ","];
      }
      toSource() {
        return this.optSource;
      }
      toDebug() {
        return Object.keys(this.props).length > 0 ? JSON.stringify(this.props) : "";
      }
      warn(...I) {
        const B = this.warning(I);
        if (tt)
          throw B;
        return Array.isArray(qe) ? qe.push(B) : console.warn(B), this;
      }
    };
    Lo(g, "pengNO", 0), Lo(g, "tauxNO", 0), Lo(g, "debug", !1);
    let w = g;
    function _(Z, I, B, q) {
      w.prototype[Z] = function(G, Y) {
        if (G === void 0 && I !== void 0 && !I.includes(""))
          return this.warn("no value for option", Z, I);
        if (q === void 0 && (q = Z), this.isA("CP") && !["cap", "lier", "pos"].includes(Z)) {
          Y == null && this.addOptSource(q, G);
          for (let ie = 0; ie < this.elements.length; ie++) {
            const he = this.elements[ie];
            (B.length == 0 || he.isA(B)) && he[Z](G, !0);
          }
          return this;
        }
        if (this.isA("coord") && !["cap", "lier", "pos"].includes(Z)) {
          Y == null && this.addOptSource(q, G);
          for (let ie = 0; ie < this.dependents.length; ie++) {
            const he = this.dependents[ie].terminal;
            (B.length == 0 || he.isA(B)) && he[Z](G, !0);
          }
          return this;
        }
        return B.length == 0 || this.isA(B) || this.isA(x) ? I === void 0 || I.includes(G) ? (I === void 0 && (G === void 0 ? G = !0 : G !== !0 && G !== !1 && (this.warn("ignored value for option", Z, G), G = !1)), this.setProp(q, G), Y == null && this.addOptSource(Z, G ?? void 0), this) : this.warn("ignored value for option", Z, G) : b && this.isA("Q") ? this : this.warn("bad const for option", Z, this.constType, B);
      };
    }
    function S(Z) {
      w.prototype[Z] = function(I, B) {
        return this.props[Z] === void 0 && (this.props[Z] = []), this.props[Z].push(I), B == null && this.addOptSource(Z, I), this;
      };
    }
    function R(Z) {
      var I = ("" + Z).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
      return I ? Math.max(0, (I[1] ? I[1].length : 0) - (I[2] ? +I[2] : 0)) : 0;
    }
    function L(Z, I) {
      const B = I == "en", q = [{ sing: "mille", plur: "mille" }, { sing: "un million", plur: "millions" }, { sing: "un milliard", plur: "milliards" }, { sing: "un trillion", plur: "trillions" }, { sing: "un quatrillion", plur: "quatrillions" }, { sing: "un quintillion", plur: "quintillions" }], G = [{ sing: "one thousand", plur: "thousand" }, { sing: "one million", plur: "million" }, { sing: "one billion", plur: "billion" }, { sing: "one trillion", plur: "trillion" }, { sing: "one quatrillion", plur: "quatrillion" }, { sing: "one quintillion", plur: "quintillion" }];
      function Y(ke) {
        return ke.length == 0 || ke[0] == "000" && Y(ke.slice(1));
      }
      function ie(ke) {
        const De = ke[0], $e = ke[1];
        switch (De) {
          case "0":
            return he($e);
          case "1":
            return (B ? ["ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"] : ["dix", "onze", "douze", "treize", "quatorze", "quinze", "seize", "dix-sept", "dix-huit", "dix-neuf"])[+$e];
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
            var Qe = (B ? ["twenty", "thirty", "forty", "fifty", "sixty"] : ["vingt", "trente", "quarante", "cinquante", "soixante"])[De - 2];
            return $e == 0 ? Qe : Qe + ($e == "1" ? B ? "-one" : " et un" : "-" + he($e));
          case "7":
            return $e == 0 ? B ? "seventy" : "soixante-dix" : B ? "seventy-" + he($e) : "soixante" + ($e == 1 ? " et " : "-") + ie("1" + $e);
          case "8":
            return $e == 0 ? B ? "eighty" : "quatre-vingts" : (B ? "eighty-" : "quatre-vingt-") + he($e);
          case "9":
            return $e == 0 ? B ? "ninety" : "quatre-vingt-dix" : B ? "ninety-" + he($e) : "quatre-vingt-" + ie("1" + $e);
        }
      }
      function he(ke) {
        return (B ? ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"] : ["zro", "un", "deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf"])[+ke];
      }
      if (typeof Z == "number" && (Z = "" + Z), !/^-?\d+$/.test(Z))
        throw "nombreChaineEnLettres ne traite que des chiffres:" + Z;
      let be = !1;
      if (Z[0] == "-" && (be = !0, Z = Z.slice(1)), Z.length > 21)
        throw "nombreChaineEnLettres ne traite que les nombres d'au plus 21 chiffres:" + Z;
      return (be ? B ? "minus " : "moins " : "") + function ke(De) {
        const $e = De.length, Qe = De[0];
        if ($e == 1)
          return function(Rt) {
            if (Rt.length == 1)
              return he(Rt);
            if (Rt.length == 2)
              return ie(Rt);
            const $t = Rt[0], Or = Rt.slice(1);
            if ($t == "0")
              return ie(Or);
            const an = B ? "hundred" : "cent";
            return Or == "00" ? $t == "1" ? (B ? "one " : "") + an : he($t) + " " + an + (B ? "" : "s") : $t == "1" ? (B ? "one " : "") + an + " " + ie(Or) : he($t) + " " + an + (B ? " and " : " ") + ie(Or);
          }(Qe);
        const ut = De.slice(1);
        if (Qe == "000")
          return ke(ut);
        const st = B ? G : q;
        return (Qe == "001" ? st[$e - 2].sing : ke([Qe]) + " " + st[$e - 2].plur) + " " + (Y(ut) ? "" : ke(ut));
      }(function ke(De) {
        return De.length > 3 ? ke(De.slice(0, De.length - 3)).concat([De.slice(De.length - 3)]) : (De.length == 1 ? De = "00" + De : De.length == 2 && (De = "0" + De), [De]);
      }(Z)).trim();
    }
    _("pe", [1, 2, 3, "1", "2", "3"], ["D", "Pro", "N", "NP", "A", "AP", "V", "VP", "S", "SP", "CP"]), _("n", ["s", "p", "x"], ["D", "Pro", "N", "NP", "A", "AP", "V", "VP", "S", "SP", "CP"]), _("g", ["m", "f", "n", "x"], ["D", "Pro", "N", "NP", "A", "AP", "V", "VP", "S", "SP", "CP"]), _("t", ["p", "i", "f", "ps", "c", "s", "si", "ip", "pr", "pp", "b", "b-to", "pc", "pq", "cp", "pa", "fa", "spa", "spq", "bp", "bp-to"], ["V", "VP", "S", "SP", "CP"]), _("aux", ["av", "t", "a"], ["V", "VP", "S", "SP", "CP"]), _("f", ["co", "su"], ["A", "Adv"]), _("tn", ["", "refl"], ["Pro"]), _("c", ["nom", "acc", "dat", "refl", "gen"], ["Pro"]), _("pos", ["post", "pre"], ["A", "Adv", ...x]), _("pro", void 0, ["NP", "PP"]), _("ow", ["s", "p", "x"], ["D", "Pro"], "own"), _("cap", void 0, []), _("lier", void 0, []), S("b"), S("a"), S("ba"), S("en");
    var F = { one: "first", two: "second", three: "third", five: "fifth", eight: "eighth", nine: "ninth", twelve: "twelfth" }, z = { un: "premier", une: "premire", cinq: "cinquime", neuf: "neuvime" };
    function j(Z) {
      function I(B, q, G, Y) {
        switch (Y) {
          case 0:
            return "";
          case 1:
            return B;
          case 2:
            return B + B;
          case 3:
            return B + B + B;
          case 4:
            return B + q;
          case 5:
            return q;
          case 6:
            return q + B;
          case 7:
            return q + B + B;
          case 8:
            return q + B + B + B;
          case 9:
            return B + G;
          case 10:
            return G;
        }
      }
      return Z < 0 ? "*too small*" : Z <= 10 ? I("I", "V", "X", Z) : Z <= 100 ? I("X", "L", "C", Math.floor(Z / 10)) + j(Z % 10) : Z <= 1e3 ? I("C", "D", "M", Math.floor(Z / 100)) + j(Z % 100) : Z < 4e3 ? "M".repeat(Math.floor(Z / 1e3)) + j(Z % 1e3) : "*too big*";
    }
    function W(Z) {
      return typeof Z != "string" ? Z : Z.includes("'") ? Z.includes('"') ? '"' + Z.replace('"', '\\"') + '"' : '"' + Z + '"' : "'" + Z + "'";
    }
    const te = class b4 extends w {
      constructor(I, B) {
        if (super(B), I.length == 0 && B != "DT")
          return this.lang = lang || d(), this.setLemma("", B), void this.warn("bad number of parameters", B, 0);
        I.length == 1 ? (this.lang = d(), this.setLemma(I[0], B)) : I.length != 2 || I[1] != "en" && I[1] != "fr" ? (this.lang = d(), this.setLemma(I[0], B), B != "DT" && this.warn("bad number of parameters", B, I.length)) : (this.lang = I[1], this.setLemma(I[0], B));
      }
      me() {
        return this.constType + "(" + W(this.lemma) + ")";
      }
      morphoError(I, B) {
        return this.warn("morphology error", I + ` :${this.me()} : ` + JSON.stringify(B)), this.realization = "[[" + this.lemma + "]]", this.constType = "Q", this;
      }
      add() {
        return this.warn("bad application", ".add", "Phrase", this.constType), this;
      }
      setLemma(I, B) {
        B == null && (B = this.constType), typeof I == "string" && (I = I.replace(//g, "oe").replace(//g, "ae")), this.lemma = I, this.peng === void 0 && this.initProps();
        var q = typeof I;
        switch (B) {
          case "DT":
            I == null ? this.date = /* @__PURE__ */ new Date() : q == "string" ? this.date = new Date(I) : I instanceof Date ? (this.date = I, this.lemma = I.toString()) : this.warn("bad parameter", "string, Date", q), this.props.dOpt = { year: !0, month: !0, date: !0, day: !0, hour: !0, minute: !0, second: !0, nat: !0, det: !0, rtime: !1 };
            break;
          case "NO":
            if (q != "string" && q != "number" && (this.warn("bad parameter", "string, number", q), this.lemma = this.value = I = 0), q == "string") {
              let ie = v(this.lang)[I];
              if (ie !== void 0 && ie.value) {
                if (ie.A) {
                  this.lemma = this.value = ie.value, this.props.dOpt = { ord: !0 }, this.addOptSource("ord", !0);
                  break;
                }
                this.lemma = this.value = ie.value, this.props.dOpt = { nat: !0 }, this.addOptSource("nat", !0);
                break;
              }
              /^[-+]?[0-9]+([., ][0-9]*)?([Ee][-+][0-9]+)?$/.test(I) ? (this.lemma = I = I.replace(this.thousand_seps(), ""), this.value = +I) : (this.warn("bad parameter", "number", q), this.lemma = this.value = 0);
            } else
              this.lemma = this.value = I;
            this.nbDecimals = R(I), this.props.dOpt = { mprecision: 2, raw: !1, nat: !1, ord: !1 };
            break;
          case "Q":
            this.lemma = typeof I == "string" ? I : JSON.stringify(I);
            break;
          case "N":
          case "A":
          case "Pro":
          case "D":
          case "V":
          case "Adv":
          case "C":
          case "P":
            if (q != "string")
              return this.tab = null, this.realization = `[[${I}]]`, this.warn("bad parameter", "string", q);
            let Y = v(this.lang)[I];
            if (Y == null)
              this.tab = null, this.realization = `[[${I}]]`, this.warn("not in lexicon", this.lang), b && (this.lemma = typeof I == "string" ? I : JSON.stringify(I), this.constType = "Q", this.realization = this.lemma);
            else if (Y = Y[B], Y === void 0) {
              this.tab = null, this.realization = `[[${I}]]`;
              let ie = Object.keys(v(this.lang)[I]), he = ie.indexOf("basic");
              he >= 0 && ie.splice(he, 1), this.warn("not in lexicon", this.lang, ie), b && (this.lemma = typeof I == "string" ? I : JSON.stringify(I), this.constType = "Q", this.realization = this.lemma);
            } else {
              const ie = Object.keys(Y), he = m(this.lang);
              for (let be = 0; be < ie.length; be++) {
                const ke = ie[be];
                if (ke == "tab") {
                  var G;
                  if (this.tab = Y.tab, B != "V") {
                    const De = he.declension[this.tab];
                    if (De !== void 0 && (G = De.ending, B == "Pro")) {
                      const $e = De.declension, Qe = $e[0].pe || 3;
                      if (Qe !== 3) {
                        let ut = 1;
                        for (; ut < $e.length && $e[ut].pe == Qe; )
                          ut++;
                        ut == $e.length && this.setProp("pe", Qe);
                      }
                    }
                  } else {
                    const De = he.conjugation[this.tab];
                    De !== void 0 ? G = De.ending : (G = "", this.warn("bad lexicon table", I, G));
                  }
                  I.endsWith(G) ? this.stem = I.substring(0, I.length - G.length) : (this.tab = null, this.isA("Adv", "C", "P") || this.warn("bad lexicon table", I, G));
                } else {
                  let De = Y[ke];
                  this.setProp(ke, De, !0);
                }
              }
            }
            break;
          default:
            this.warn("not implemented", B);
        }
        return this;
      }
      grammaticalNumber() {
        return this.isA("NO") ? this.props.dOpt.ord == 1 ? "s" : null : this.warn("bad application", "grammaticalNumber", "NO", this.constType);
      }
      bestMatch(I, B, q) {
        let G = [];
        for (var Y = 0; Y < B.length; Y++) {
          const he = B[Y];
          let be = 0;
          for (let ke in q)
            if (he[ke] !== void 0) {
              const De = q[ke];
              if (ke == "pe" && he[ke] != De) {
                be = 0;
                break;
              }
              he[ke] == De ? be += 2 : he[ke] == "x" && (be += 1);
            }
          G.push([be, he.val]);
        }
        G.sort((he, be) => be[0] - he[0]);
        const ie = G[0];
        return ie[0] == 0 ? (this.morphoError(I, q), null) : ie[1];
      }
      decline(I) {
        const B = m(this.lang);
        let q = B.declension[this.tab].declension, G = this.stem;
        if (this.isA("A", "Adv"))
          return this.decline_adj_adv(B, q, G);
        if (q.length == 1)
          this.realization = this.stem + q[0].val;
        else {
          let Y = this.getProp("g");
          this.isA("D", "N") && Y == null && (Y = "m");
          let ie = this.getProp("n");
          this.isA("D", "N") && ie == null && (ie = "s");
          let he = 3;
          if (I) {
            let Qe = this.getProp("pe");
            he = Qe === void 0 ? 3 : +Qe;
          }
          let be = I ? { pe: he, g: Y, n: ie } : { g: Y, n: ie };
          if (this.props.own !== void 0 && (be.own = this.props.own), this.isA("Pro")) {
            const Qe = this.props.c;
            Qe !== void 0 && (this.check_bad_pronoun_case(Qe) || (be.c = Qe));
            const ut = this.props.tn;
            if (ut !== void 0 && (Qe !== void 0 ? this.warn("both tonic and clitic") : be.tn = ut), Qe !== void 0 || ut !== void 0)
              if (this.lemma == this.tonic_pe_1())
                this.getProp("g") === void 0 && delete be.g, this.getProp("n") === void 0 && delete be.n, Qe != "nom" && ut != "" || this.getProp("pe") !== void 0 || (be.pe = 1, this.setProp("pe", 1));
              else {
                const st = q[0];
                this.should_set_person_number(Qe) && (this.setProp("g", st.g || Y), this.setProp("n", st.n || ie), this.setProp("pe", be.pe = st.pe || 3));
              }
            else
              this.lemma != "on" && (be.tn = "");
          }
          const ke = this.declension_word(), De = this.bestMatch(ke, q, be);
          if (De == null)
            return [this.morphoError(ke, be)];
          const $e = this.check_gender_lexicon(Y, ie);
          if ($e != null)
            return $e;
          this.realization = this.stem + De;
        }
        return [this];
      }
      insertReal(I, B, q) {
        if (B instanceof b4)
          return B.parentConst = this.parentConst, B.realize(), q == null ? I.push(B) : I.splice(q, 0, B), I;
        this.warn("bad Constituent", se(q + 1).dOpt({ ord: !0 }).realize(), typeof B);
      }
      isReflexive() {
        if (!this.isA("V"))
          return this.error("isReflexive() should be called only for a verb,  not a " + this.constType);
        const I = this.getProp("pat");
        if (I !== void 0 && I.length == 1 && I[0] == "rfl")
          return !0;
        let B = this.parentConst;
        for (; B != null; ) {
          if (B.isA("VP", "SP", "S") || B.isA(x) && B.terminal.isA("V")) {
            const q = B.props.typ;
            if (q !== void 0 && q.refl === !0)
              return !!I.includes("rfl") || (this.ignoreRefl = !0, b4.noIgnoredReflVerbs.has(this.lemma) || this.warn("ignored reflexive", I), !1);
            if (!B.isA("VP"))
              return !1;
          }
          B = B.parentConst;
        }
        return !1;
      }
      dateFormat(I, B) {
        const q = /(.*?)\[(.+?)\]|(.+$)/g, G = m(this.lang).date, Y = G.format[B.nat ? "natural" : "non_natural"];
        function ie(be) {
          if (be.length == 0)
            return "";
          let ke = "", De = Y[be];
          B.det || (De = De.slice(De.indexOf("[")));
          for (const $e of De.matchAll(q))
            if ($e[1] == null)
              ke += $e[3];
            else {
              const Qe = (ut) => (ut < 10 ? "0" : "") + ut;
              switch (ke += $e[1], $e[2]) {
                case "Y":
                  ke += I.getFullYear();
                  break;
                case "F":
                  ke += G.text.month["" + (I.getMonth() + 1)];
                  break;
                case "M0":
                  ke += Qe(I.getMonth() + 1);
                  break;
                case "M":
                  ke += I.getMonth() + 1;
                  break;
                case "d0":
                  ke += Qe(I.getDate());
                  break;
                case "d":
                  ke += I.getDate();
                  break;
                case "l":
                  ke += G.text.weekday["" + I.getDay()];
                  break;
                case "A":
                  ke += G.text.meridiem[I.getHours() < 12 ? 0 : 1];
                  break;
                case "h":
                  ke += I.getHours() % 12;
                  break;
                case "H0":
                  ke += Qe(I.getHours());
                  break;
                case "H":
                  ke += I.getHours();
                  break;
                case "m0":
                  ke += Qe(I.getMinutes());
                  break;
                case "m":
                  ke += I.getMinutes();
                  break;
                case "s0":
                  ke += Qe(I.getSeconds());
                  break;
                case "s":
                  ke += I.getSeconds();
                  break;
                default:
                  console.log("strange field:" + $e[2]);
              }
            }
          return ke;
        }
        let he;
        if (B.rtime) {
          const be = G.format.relative_time, ke = B.rtime, De = Math.ceil((I.getTime() - ke.getTime()) / 864e5);
          ke.setDate(ke + De), he = be["" + De] !== void 0 ? be["" + De].replace("[l]", G.text.weekday[I.getDay()]) : be[De < 0 ? "-" : "+"].replace("[x]", Math.abs(De));
        } else
          he = ie(["year", "month", "date", "day"].filter((be) => B[be] == 1).join("-"));
        return [he, ie(["hour", "minute", "second"].filter((be) => B[be] == 1).join(":"))].filter((be) => be.length > 0).join(" ");
      }
      real() {
        switch (this.constType) {
          case "N":
          case "A":
            if (this.tab !== null)
              return this.doFormat(this.decline(!1));
            break;
          case "Adv":
            if (this.tab !== null)
              return this.doFormat(this.decline(!1));
            this.realization === null && (this.realization = this.lemma);
            break;
          case "C":
          case "P":
          case "Q":
            this.realization === null && (this.realization = this.lemma);
            break;
          case "D":
          case "Pro":
            if (this.tab !== null)
              return this.doFormat(this.decline(!0));
            break;
          case "V":
            return this.doFormat(this.conjugate());
          case "DT":
            this.realization = this.dateFormat(this.date, this.getProp("dOpt"));
            break;
          case "NO":
            this.setProp("n", this.grammaticalNumber());
            const I = this.getProp("dOpt");
            I.nat == 1 ? this.realization = this.numberToWord(this.value, this.lang, this.peng.g) : I.ord == 1 ? (this.setProp("n", "s"), this.realization = this.numberToOrdinal(this.value, this.lang, this.peng.g)) : I.rom == 1 ? this.realization = this.numberToRoman(this.value) : I.raw == 0 ? this.realization = function(B, q, G) {
              let Y = G === void 0 ? 2 : G;
              const ie = m(q).number;
              return Y = R(B) > Y ? Y : R(B), function(he, be, ke, De) {
                he = (he + "").replace(/[^0-9+\-Ee.]/g, "");
                var $e = isFinite(+he) ? +he : 0, Qe = isFinite(+be) ? Math.abs(be) : 0, ut = De === void 0 ? "" : De, st = ke === void 0 ? "." : ke, Rt = "";
                return (Rt = (Qe ? function($t, Or) {
                  var an = Math.pow(10, Or);
                  return "" + (Math.round($t * an) / an).toFixed(Or);
                }($e, Qe) : "" + Math.round($e)).split("."))[0].length > 3 && (Rt[0] = Rt[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, ut)), (Rt[1] || "").length < Qe && (Rt[1] = Rt[1] || "", Rt[1] += new Array(Qe - Rt[1].length + 1).join("0")), Rt.join(st);
              }(B, Y, ie.symbol.decimal, ie.symbol.group);
            }(this.value, this.lang, I.mprecision) : this.realization = this.value + "";
            break;
          default:
            this.error("Terminal.real:" + this.constType + ": not implemented");
        }
        return this.doFormat([this]);
      }
      numberToWord(I, B, q) {
        return parseInt(I) !== I ? (this.warn("bad number in word", I), I + "") : this.numberOne(q, I) ?? L(I, B);
      }
      numberToOrdinal(I, B, q) {
        return parseInt(I) !== I || I <= 0 ? (this.warn("bad ordinal", I), `[[${I}]]`) : function(G, Y, ie) {
          const he = Y == "en";
          if ((G = L(G, Y)) == "zro" || G == "zero")
            return G;
          const be = /(.*?)(\w+)$/.exec(G), ke = be[2];
          return he ? ke in F ? be[1] + F[ke] : G.charAt(G.length - 1) == "y" ? G.substring(0, G.length - 1) + "ieth" : G + "th" : G == "un" ? ie == "f" ? "premire" : "premier" : G.endsWith("et un") ? G + "ime" : ke in z ? be[1] + z[ke] : G.charAt(G.length - 1) == "e" || G.endsWith("quatre-vingts") ? G.substring(0, G.length - 1) + "ime" : G + "ime";
        }(I, B, q);
      }
      numberToRoman(I) {
        return parseInt(I) !== I || I <= 0 || I >= 4e3 ? (this.warn("bad roman", I), `[[${I}]]`) : j(I);
      }
      toSource() {
        return this.constType + "(" + W(this.lemma) + ")" + super.toSource();
      }
      toDebug() {
        let I = this.constType + "(" + W(this.lemma) + ")";
        return this.peng !== void 0 && (this.peng.pengNO !== void 0 && (I += "#" + this.peng.pengNO), this.peng.tauxNO !== void 0 && (I += "-" + this.peng.tauxNO)), I + super.toDebug();
      }
    };
    Lo(te, "noIgnoredReflVerbs", /* @__PURE__ */ new Set(["avoir", "tre", "pouvoir", "devoir", "vouloir"]));
    let le = te;
    const ce = (Z) => class extends Z {
      lang() {
        return "en";
      }
      isEn() {
        return !0;
      }
      isFr() {
        return !1;
      }
      defaultProps() {
        return { g: "n", n: "s", pe: 3, t: "p" };
      }
      tonic_forms() {
        return ["us", "her", "you", "him", "them", "it"];
      }
      tonic_pe_1() {
        return "me";
      }
      relative_pronouns() {
        return ["that", "who", "which"];
      }
      validate_neg_option(I, B) {
        return !1;
      }
      sepWordRE() {
        return /((?:[^<\w'-]*(?:<[^>]+>)?)*)([\w'-]+)?(.*)/;
      }
      doElision(I) {
        const B = /^(heir|herb|honest|honou?r(able)?|hour)/i, q = /^(uni.*|ub.*|use.*|usu.*|uv.*)/i, G = /^[A-Z]+$/, Y = { "are+not": "aren't", "can+not": "can't", "did+not": "didn't", "do+not": "don't", "does+not": "doesn't", "had+not": "hadn't", "has+not": "hasn't", "have+not": "haven't", "is+not": "isn't", "must+not": "mustn't", "need+not": "needn't", "should+not": "shouldn't", "was+not": "wasn't", "were+not": "weren't", "will+not": "won't", "would+not": "wouldn't", "could+not": "couldn't", "let+us": "let's", "I+am": "I'm", "I+will": "I'll", "I+have": "I've", "I+had": "I'd", "I+would": "I'd", "she+will": "she'll", "he+is": "he's", "he+has": "he's", "she+had": "she'd", "she+would": "she'd", "he+will": "he'll", "she+is": "she's", "she+has": "she's", "he+would": "he'd", "he+had": "he'd", "you+are": "you're", "you+will": "you'll", "you+would": "you'd", "you+had": "you'd", "you+have": "you've", "we+are": "we're", "we+will": "we'll", "we+had": "we'd", "we+would": "we'd", "we+have": "we've", "they+will": "they'll", "they+are": "they're", "they+had": "they'd", "they+would": "they'd", "they+have": "they've", "it+is": "it's", "it+will": "it'll", "it+had": "it'd", "it+would": "it'd", "there+will": "there'll", "there+is": "there's", "there+has": "there's", "there+have": "there've", "that+is": "that's", "that+had": "that'd", "that+would": "that'd", "that+will": "that'll", "what+is": "what's" };
        var ie = I.length - 1;
        if (ie != 0)
          for (var he = 0; he < ie; he++) {
            var be = this.sepWordRE().exec(I[he].realization);
            if (be !== void 0 && be[2] !== void 0) {
              var ke = this.sepWordRE().exec(I[he + 1].realization);
              if (ke !== void 0 && ke[2] !== void 0) {
                var De = be[2], $e = ke[2];
                if (De != "a" && De != "A" || !I[he].isA("D")) {
                  if (this.contraction !== void 0 && this.contraction === !0)
                    if (De == "cannot")
                      I[he].realization = be[1] + "can't" + be[3];
                    else {
                      const Qe = Y[De + "+" + $e];
                      Qe != null && (I[he].realization = be[1] + Qe + be[3], I[he + 1].realization = ke[1] + ke[3].trim(), he++);
                    }
                } else
                  (/^[ai]/i.exec($e) || /^e/i.exec($e) && !/^eu/i.exec($e) || /^o/i.exec($e) && !/^onc?e/.exec($e) || /^u/i.exec($e) && !q.exec($e) || B.exec($e) || G.exec($e)) && (I[he].realization = be[1] + De + "n" + be[3], he++);
              }
            }
          }
      }
      check_for_t(I, B) {
        return "";
      }
      warning(I) {
        function B(Y) {
          return Array.isArray(Y) || (Y = [Y]), tr.apply(null, [C("or")].concat(Y.map((ie) => pe(ie)))).realize();
        }
        const q = { "bad parameter": (Y, ie) => ot(dt(fe("the"), it("parameter")), rt(ye("be").t("c"), pe(Y).a(","), pe("not"), pe(ie))).typ({ mod: "nece" }), "bad application": (Y, ie, he) => ot(pe(Y), rt(ye("apply").t("c"), Xt($("to"), B(ie)).a(","), pe("not"), Xt($("to"), pe(he)))).typ({ mod: "nece", pas: !0 }), "bad position": (Y, ie) => ot(pe(Y), rt(ye("be").t("c"), kt("small").f("co"), C("than"), pe(ie))).typ({ mod: "nece" }), "bad const for option": (Y, ie, he) => tr(C("but"), rt(ye("apply"), dt(fe("the"), it("option"), pe(Y)), Xt($("to"), pe(ie))).typ({ pas: !0 }).a(","), Nr(rt(ye("be").t("c"), Xt($("to"), B(he)))).typ({ mod: "nece" })), "ignored value for option": (Y, ie) => ot(pe(ie).a(":"), rt(ye("ignore"), dt(fe("this"), kt("bad").pos("pre"), it("value"), Xt($("for"), it("option"), pe(Y)))).typ({ pas: !0 })), "unknown type": (Y, ie) => ot(dt(kt("illegal"), it("type"), pe(Y).b(":")).a(","), rt(ye("be").t("c"), B(ie)).typ({ mod: "nece" })), "no value for option": (Y, ie) => ot(dt(fe("no"), it("value"), Xt($("for"), it("option"), pe(Y))), rt(ye("be"), Xt($("among"), pe(ie)))).typ({ mod: "nece" }), "not found": (Y, ie) => ot(zt(fe("no"), pe(Y)), rt(ye("find").t("pp"), Xt($("in"), pe(ie)))), "bad ordinal": (Y) => ot(rt(ye("realize"), pe(Y), zt(Je("as"), fe("a"), it("ordinal")))).typ({ neg: !0, mod: "poss" }), "bad roman": (Y) => ot(rt(ye("realize"), pe(Y), zt(Je("as"), dt(fe("a"), kt("Roman"), it("number"))))).typ({ neg: !0, mod: "poss" }), "bad number in word": (Y) => ot(rt(ye("realize"), pe(Y), Xt($("in"), it("word").n("p")))).typ({ neg: !0, mod: "poss" }), "no French contraction": () => ot(rt(ye("ignore"), dt(it("contraction")), Xt($("in"), it("French")))).typ({ pas: !0 }), "morphology error": (Y) => ot(dt(it("error"), Xt($("within"), dt(fe("the"), it("morphology")))).a(":"), pe(Y)), "not implemented": (Y) => ot(pe(Y), rt(ye("implement"))).typ({ neg: !0, pas: !0 }), "not in lexicon": (Y, ie) => ot(Je("not"), ye("find").t("pp"), Xt($("within"), fe("the"), kt(Y == "en" ? "English" : "French"), it("lexicon")), ie !== void 0 ? zt(Je("but"), ye("exist"), Je("as"), B(ie)) : pe("")), "no appropriate pronoun": () => ot(rt(ye("find"), dt(fe("a"), kt("appropriate"), it("pronoun")))).typ({ neg: !0, pas: !0, mod: "poss" }), "both tonic and clitic": () => ot(tr(C("and"), pe("tn(..)"), pe("c(..)")), rt(ye("use").n("p"), Je("together")).typ({ neg: !0, pas: !0, mod: "poss" }).a(","), pe("tn(..)"), rt(ye("ignore")).typ({ pas: !0 })), "bad Constituent": (Y, ie) => ot(dt(fe("the"), it("parameter"), pe(Y)), rt(ye("be"), pe("Constituent"), Je("but"), pe(ie))).typ({ neg: !0 }), "bad Dependent": (Y, ie) => ot(dt(fe("the"), it("parameter"), pe(Y)), rt(ye("be"), pe("Dependent"), Je("but"), pe(ie))).typ({ neg: !0 }), "Dependent needs Terminal": (Y) => ot(dt(fe("the"), se(1).dOpt({ ord: !0 }), it("parameter"), Xt($("of"), pe("Dependent"))), rt(ye("be"), pe("Terminal"), Je("but"), pe(Y))).typ({ neg: !0 }), "bad number of parameters": (Y, ie) => ot(pe(Y), rt(ye("accept"), dt(fe("a"), kt("single"), it("parameter"))).a(","), Nr(C("but"), Ze("I"), rt(rt(ye("have"), se(ie))))), "Dependent without params": () => ot(pe("Dependent"), Xt($("without"), it("parameter"))), "bad lexicon table": (Y, ie) => ot(dt(it("error"), Xt($("within"), dt(fe("the"), it("lexicon")))).a(":"), Nr(pe(Y), rt(ye("end"), Xt($("with"), pe(ie)))).typ({ neg: !0 })), "bad language": (Y) => ot(dt(it("language")), rt(ye("be"), tr(C("or"), pe('"en"'), pe('"fr"')).a(","), pe("not"), pe(Y).en('"'))).typ({ mod: "obli" }), "ignored reflexive": (Y) => ot(rt(ye("be"), kt("reflexive")).typ({ mod: "poss", neg: !0 }).a(","), Y.length > 0 ? zt(Je("only"), B(Y)) : void 0), "inconsistent dependents within a coord": (Y, ie) => ot(pe(Y), rt(ye("expect").t("pp"), Xt($("within"), dt(fe("this"), pe("coord")))), Nr(C("but"), pe(ie), ye("be").t("ps"), ye("find").t("pp"))), "user-warning": (Y) => ot(pe(typeof Y == "string" ? Y : Y.realize())) }[I.shift()];
        let G = q.apply(null, I).cap(!1);
        return q === void 0 && this.error("warn called with an unknown error message:" + arguments[0]), this.me() + ":: " + G.realize();
      }
    }, Ee = (Z) => class extends ce(Z) {
      thousand_seps() {
        return /,/g;
      }
      grammaticalNumber() {
        return super.grammaticalNumber() ?? (Math.abs(this.value) == 1 && this.nbDecimals == 0 ? "s" : "p");
      }
      decline_adj_adv(I, B, q) {
        this.realization = this.lemma;
        const G = this.getProp("f");
        if (G !== void 0 && G !== !1) {
          if (this.tab == "a1") {
            const Y = Je(G == "co" ? "more" : "most");
            return Y.realization = Y.lemma, [Y, this];
          }
          {
            if (this.tab == "b1") {
              const ie = v(this.lang)[this.lemma].A;
              if (ie === void 0)
                return [this];
              {
                B = I.declension[ie.tab].declension;
                const he = I.declension[ie.tab].ending;
                q = q.slice(0, q.length - he.length);
              }
            }
            const Y = this.bestMatch("adjective declension", B, { f: G });
            return Y == null ? [this.morphoError("decline [en]:A", { f: G })] : (this.realization = q + Y, [this]);
          }
        }
        return [this];
      }
      check_bad_pronoun_case(I) {
        return I == "refl" && (this.warn("ignored value for option", "c", I), !0);
      }
      should_set_person_number(I) {
        return I != "gen";
      }
      tonic_forms() {
        return ["us", "her", "you", "him", "them", "it"];
      }
      declension_word() {
        return "declension";
      }
      check_gender_lexicon(I, B) {
        return null;
      }
      conjugate() {
        let I = +this.getProp("pe") || 3;
        const B = this.getProp("n"), q = (this.getProp("g"), this.getProp("t"));
        if (this.tab == null)
          return [this.morphoError("conjugate_en:tab", { pe: I, n: B, t: q })];
        const G = q == "s" ? "p" : q == "si" ? "ps" : q, Y = m(this.lang).conjugation[this.tab].t[G];
        let ie = [this];
        if (Y !== void 0)
          switch (q) {
            case "p":
            case "ps":
            case "s":
            case "si":
              if (typeof Y == "string")
                this.realization = this.stem + Y;
              else {
                let he = Y[I - 1 + (B == "p" ? 3 : 0)];
                if (he == null)
                  return [this.morphoError("conjugate_en:pe", { pe: I, n: B, t: q })];
                q == "s" && I == 3 && (he = Y[0]), this.realization = this.stem + he;
              }
              break;
            case "b":
            case "pp":
            case "pr":
              this.realization = this.stem + Y;
          }
        else if (q == "f")
          this.realization = this.lemma, this.insertReal(ie, ye("will"), 0);
        else if (q == "c")
          this.realization = this.lemma, this.insertReal(ie, ye("will").t("ps"), 0);
        else if (q == "bp" || q == "bp-to") {
          const he = m(this.lang).conjugation[this.tab].t.pp;
          this.realization = he !== void 0 ? this.stem + he : this.lemma, this.insertReal(ie, ye("have").t("b"), 0), q == "bp-to" && this.insertReal(ie, P("to"), 0);
        } else if (q == "b-to")
          this.realization = this.lemma, this.insertReal(ie, P("to"), 0);
        else {
          if (q != "ip")
            return [this.morphoError("conjugate_en: unrecognized tense", { pe: I, n: B, t: q })];
          this.realization = this.lemma, I == 1 && B == "p" && this.insertReal(ie, Q("let's"), 0);
        }
        return ie;
      }
      numberOne(I, B) {
        return null;
      }
    }, xe = { can: "cannot", may: "may not", shall: "shall not", will: "will not", must: "must not", could: "could not", might: "might not", should: "should not", would: "would not" }, _e = (Z) => class extends Z {
      word_last() {
        return "last";
      }
      adj_def_pos() {
        return "pre";
      }
      passive_pronoun_subject(I) {
        return I.lemma == "I" ? Ze("me").tn("").g(I.getProp("g")).n(I.getProp("n")).pe(I.getProp("pe")) : I.getTonicPro();
      }
      passive_dummy_subject() {
        return "it";
      }
      passive_context() {
        return "passive context";
      }
      passive_should_link_subject() {
        return !0;
      }
      passive_prep(I) {
        return I ? "to" : "by";
      }
      passive_human_object(I, B) {
        return I == "wod" && B !== void 0 && ["m", "f"].includes(B.getProp("g"));
      }
      should_add_interrogative_prefix(I) {
        return I != "yon";
      }
      and_conj() {
        return "and";
      }
      prepositionsList() {
        return { all: /* @__PURE__ */ new Set(["about", "above", "across", "after", "against", "along", "alongside", "amid", "among", "amongst", "around", "as", "at", "back", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "by", "concerning", "considering", "despite", "down", "during", "except", "for", "from", "in", "inside", "into", "less", "like", "minus", "near", "next", "of", "off", "on", "onto", "outside", "over", "past", "per", "plus", "round", "since", "than", "through", "throughout", "till", "to", "toward", "towards", "under", "underneath", "unlike", "until", "up", "upon", "versus", "with", "within", "without"]), whe: /* @__PURE__ */ new Set(["above", "across", "along", "alongside", "amid", "around", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "in", "inside", "into", "near", "next", "onto", "outside", "over", "past", "toward", "towards", "under", "underneath", "until", "via", "within"]), whn: /* @__PURE__ */ new Set(["after", "before", "during", "since", "till"]) };
      }
      affixHopping(I, B, q, G) {
        const Y = I.peng, ie = G.neg === !0;
        let he = [], be = [], ke = !1;
        B != "f" && B != "c" || (ke = !0, B = B == "f" ? "p" : "ps");
        const De = G.prog !== void 0 && G.prog !== !1, $e = G.perf !== void 0 && G.perf !== !1, Qe = G.pas !== void 0 && G.pas !== !1, ut = G.int, st = G.mod;
        st !== void 0 && st !== !1 ? (he.push(q[st].aux), be.push("b")) : ke && (he.push(q.future.aux), be.push("b")), $e || De || Qe ? ($e && (he.push(q.perfect.aux), be.push(q.perfect.participle)), De && (he.push(q.continuous.aux), be.push(q.continuous.participle)), Qe && (he.push(q.passive.aux), be.push(q.passive.participle))) : ut !== void 0 && ut !== !1 && he.length == 0 && I.lemma != "be" && I.lemma != "have" && ut != "wos" && ut != "was" && ut != "tag" && (["pp", "pr", "b-to"].includes(B) || (he.push("do"), be.push("b"))), he.push(I.lemma);
        const Rt = he.shift();
        let $t = [];
        if (ie)
          ["pp", "pr", "b", "b-to", "bp", "bp-to"].includes(B) ? ($t.push(Je("not", "en")), B != "b" && B != "bp" || $t.push($("to", "en")), $t.push(ye(Rt, "en").t(B))) : B == "ip" && Y.pe == 1 && Y.n == "p" ? ($t.push(pe("let's")), $t.push(Je("not", "en")), $t.push(ye(Rt, "en").t("b"))) : Rt in xe ? Rt == "can" && B == "p" ? $t.push(pe("cannot")) : ($t.push(ye(Rt, "en").t(B)), $t.push(Je("not", "en"))) : Rt == "be" || Rt == "have" && I.lemma != "have" ? ($t.push(ye(Rt).t(B)), $t.push(Je("not", "en"))) : ($t.push(ye("do", "en").t(B)), $t.push(Je("not", "en")), Rt != "do" && $t.push(ye(Rt).t("b")));
        else {
          let Or = ye(Rt).t(B);
          I.lemma in xe && Or.pe(1), $t.push(Or);
        }
        for ($t[0].peng = Y; he.length > 0; ) {
          const Or = he.shift();
          $t.push(ye(Or).t(be.shift()));
        }
        return G.refl === !0 && B != "pp" && $t.push(Ze("myself", "en").pe(I.getProp("pe")).n(I.getProp("n")).g(I.getProp("g"))), $t;
      }
      checkAdverbPos(I) {
        function B(be, ke, De) {
          I.splice(De, 0, ...I.splice(be, ke));
        }
        const q = this.relative_pronouns();
        let G = I.length - 1;
        for (; G >= 0 && (!I[G].isA("Pro") || !q.includes(I[G].lemma)); )
          G--;
        G++;
        const Y = I.map((be, ke) => ke >= G && be.isA("Adv") && be.lemma != "not" ? ke : -1).filter((be) => be != -1);
        if (Y.length == 0)
          return;
        const ie = Y[0], he = I[ie];
        for (let be = 1; be < Y.length; be++)
          Y[be] != Y[be - 1] + 1 && Y.splice(be, Y.length - be);
        ie >= G + 2 && he.props.pos === void 0 && function(be) {
          for (let ke = 0; ke < ie - 1; ke++) {
            const De = I[ke];
            if (De.isA("V") && be.includes(De.lemma)) {
              if (I[ke + 1].isA("V")) {
                if ((De.lemma == "will" || De.lemma == "shall") && De.parentConst !== null && De.parentConst.getProp("t") == "f")
                  continue;
                B(ie, Y.length, ke + 1);
              } else
                I[ke + 1].lemma == "not" && I[ke + 2].isA("V") && B(ie, Y.length, ke + 2);
              break;
            }
          }
        }(["have", "can", "will", "shall", "may", "must"]);
      }
      doPronounPlacement() {
      }
    };
    class Ie extends w {
      constructor(I, B, q) {
        if (super(B), this.lang = q || d(), I = ae(I), this.elements = [], this.elementsSource = [], I.length > 0) {
          const G = I.length - 1;
          for (let Y = 0; Y < G; Y++) {
            let ie = I[Y];
            typeof ie == "string" && (ie = pe(ie)), ie instanceof le || ie instanceof Ie ? (this.addElement(ie), this.elementsSource.push(ie)) : this.warn("bad Constituent", se(Y + 1).dOpt({ ord: !0 }).realize(), typeof ie + ":" + JSON.stringify(ie));
          }
          this.add(I[G], void 0, !0);
        }
      }
      addElement(I, B) {
        return I instanceof le || I instanceof Ie ? (I.parentConst = this, B == null ? this.elements.push(I) : typeof B == "number" && B <= this.elements.length && B >= 0 ? this.elements.splice(B, 0, I) : this.warn("bad position", B, this.elements.length)) : this.warn("bad Constituent", se(B + 1).dOpt({ ord: !0 }).realize(), typeof I), this;
      }
      removeElement(I) {
        if (typeof I == "number" && I < this.elements.length && I >= 0) {
          const B = this.elements.splice(I, 1)[0];
          return B.parentConst = null, B;
        }
        return this.warn("bad position", I, this.elements.length);
      }
      add(I, B, q) {
        function G(Y, ie, he) {
          ie > he && ([he, ie] = [ie, he]);
          for (var be = ie; be <= he; be++)
            if (!Y[be].isA("A", "N"))
              return !1;
          return !0;
        }
        if (I === null)
          return this;
        if (typeof I == "string" && (I = pe(I)), !(I instanceof w))
          return this.warn("bad Constituent", this.word_last(), typeof I + ":" + JSON.stringify(I));
        q === void 0 ? this.optSource += ".add(" + I.toSource() + (B === void 0 ? "" : "," + B) + ")" : this.elementsSource.push(I), this.addElement(I, B), this.linkProperties();
        for (let Y = 0; Y < this.elements.length; Y++) {
          const ie = this.elements[Y];
          if (ie.isA("A")) {
            const he = this.getIndex("N");
            if (he >= 0) {
              const be = ie.props.pos || this.adj_def_pos();
              (be == "pre" && Y > he || be == "post" && Y < he) && G(this.elements, Y, he) && this.addElement(this.removeElement(Y), he);
            }
          } else if (ie.isA("Adv") && ie.props.pos !== void 0) {
            const he = this.getIndex("V");
            if (he >= 0) {
              const be = ie.props.pos;
              (be == "pre" && Y > he || be == "post" && Y < he) && this.addElement(this.removeElement(Y), he);
            }
          }
        }
        return this;
      }
      grammaticalNumber() {
        return this.error("grammaticalNumber must be called on a NO, not a " + this.constType);
      }
      getHeadIndex(I) {
        let B = I.substring(0, I.length - 1), q = this.getIndex([I, B]);
        return q < 0 && (q = 0), q;
      }
      linkProperties() {
        let I;
        if (this.elements.length == 0)
          return this;
        switch (this.constType) {
          case "NP":
            I = this.getHeadIndex("NP"), this.peng = this.elements[I].peng;
            for (let Y = 0; Y < this.elements.length; Y++)
              if (Y != I) {
                const ie = this.elements[Y];
                if (this.peng) {
                  if (ie.isA("NO") && Y < I)
                    this.peng.n = ie.grammaticalNumber(), ie.peng.g = this.peng.g;
                  else if (ie.isA("D", "A", "V"))
                    this.link_DAV_properties(ie);
                  else if (ie.isA("CP")) {
                    const he = this;
                    ie.elements.forEach(function(be) {
                      be.isA("A", "NO") && (be.peng = he.peng);
                    });
                  }
                }
              }
            const B = this.getFromPath([["S", "SP"], "Pro"]);
            if (B !== void 0) {
              const Y = B.parentConst.getFromPath(["VP", "V"]);
              Y != null && this.link_subj_obj_subordinate(B, Y);
            }
            break;
          case "VP":
            I = this.getHeadIndex("VP"), this.peng = this.elements[I].peng, this.taux = this.elements[I].taux;
            break;
          case "AdvP":
          case "PP":
          case "AP":
            I = this.getHeadIndex(this.constType), this.peng = this.elements[I].peng;
            break;
          case "CP":
            this.peng = { pengNO: w.pengNO++ };
            break;
          case "S":
          case "SP":
            let q = this.getFromPath([["", "VP"], "V"]);
            if (q !== void 0 && (this.taux = q.taux, q.getProp("t") == "ip"))
              return this;
            let G = this.getIndex(["NP", "N", "CP", "Pro"]);
            if (G >= 0) {
              let Y = this.elements[G];
              if (this.isA("SP") && Y.isA("Pro") && ["que", "o", "that"].includes(Y.lemma)) {
                const he = this.elements.slice(G + 1).findIndex((be) => be.isA("NP", "N", "CP", "Pro"));
                if (!(he >= 0))
                  return this;
                Y = this.elements[G + 1 + he];
              }
              this.peng = Y.peng;
              const ie = this.linkPengWithSubject("VP", "V", Y);
              ie !== void 0 ? (this.taux = ie.taux, this.linkAttributes(ie, this.getFromPath([["VP"], ["CP"]]), Y)) : (this.getFromPath(["CP", "VP"]) !== void 0 && this.getConst("CP").elements.forEach(function(he) {
                he instanceof Ie && he.linkPengWithSubject("VP", "V", Y);
              }), this.check_coordinated_object());
            }
            break;
          default:
            this.error("linkProperties	,unimplemented type:" + this.constType);
        }
        return this;
      }
      linkPengWithSubject(I, B, q) {
        if (q.isA("Pro") && q.props.c == "gen")
          return;
        let G = this.getFromPath([I, B]);
        return G !== void 0 ? G.parentConst.peng = G.peng = q.peng : (G = this.getFromPath([B]), G !== void 0 && (G.peng = q.peng)), G;
      }
      me() {
        const I = this.elements.map(function(B) {
          return B.me();
        });
        return this.constType + "(" + I.join() + ")";
      }
      setLemma(I, B) {
        return this.error("***: should never happen: setLemma: called on a Phrase"), this;
      }
      getIndex(I) {
        return typeof I == "string" && (I = [I]), this.elements.findIndex((B) => B.isA(I), this);
      }
      getConst(I) {
        const B = this.getIndex(I);
        if (!(B < 0))
          return this.elements[B];
      }
      findGenderNumberPerson(I) {
        let B, q, G = 3, Y = 0;
        for (let ie = 0; ie < this.elements.length; ie++) {
          const he = this.elements[ie];
          if (he.isA("NP", "N", "Pro", "Q", "NO")) {
            Y += 1;
            const be = he.getProp("g");
            B === void 0 && be !== void 0 && (B = be), be == "m" && (B = "m"), he.getProp("n") == "p" && (q = "p");
            const ke = he.getProp("pe");
            ke !== void 0 && ke < G && (G = ke);
          }
        }
        return Y > 1 && I && (q = "p"), { g: B, n: q, pe: G };
      }
      pronominalizeChildren() {
        for (let I of this.elements)
          I.props.pro !== !0 || I.isA("Pro") || I.pronominalize();
      }
      passivate() {
        let I, B, q;
        if (this.isA("VP"))
          I = null, B = this;
        else {
          if (B = this.getConst("VP"), B === void 0)
            return this.warn("not found", "VP", this.passive_context());
          this.elements.length > 0 && this.elements[0].isA("N", "NP", "Pro", "S") ? (I = this.removeElement(0), I.isA("Pro") && (I = this.passive_pronoun_subject(I))) : I = null;
        }
        if (B === void 0)
          return this.warn("not found", "VP", isFr() ? "contexte passif" : "passive context");
        {
          let G = B.getIndex(["NP", "Pro"]);
          if (G >= 0) {
            let Y = B.removeElement(G);
            if (Y.isA("Pro") ? (Y = Y.getTonicPro("nom"), G == 0 && (G = B.getIndex("V") + 1)) : Y.isA("NP") && Y.props.pro === !0 && (Y = Y.getTonicPro("nom")), q = Y, this.addElement(q, 0), this.passive_should_link_subject() && this.linkPengWithSubject("VP", "V", q), I != null) {
              let ie = this.passive_prep(I.isA("S"));
              B.addElement(Xt($(ie, this.lang), I), G);
            }
          } else if (I != null) {
            q = Ze(this.passive_dummy_subject(), this.lang).c("nom"), this.addElement(q, 0), this.linkPengWithSubject("VP", "V", q), B.peng = q.peng;
            let Y, ie = B.getIndex("V"), he = this.passive_prep(I.isA("S"));
            Y = I.isA("S") ? void 0 : ie + 1, B.addElement(Xt($(he, this.lang), I), Y);
          }
          this.passive_agree_auxiliary(B, q);
        }
      }
      processVP(I, B, q) {
        if (this.getFromPath(["CP", "VP"]) !== void 0)
          return void this.getConst("CP").elements.forEach(function(Y) {
            Y.isA("VP") && Y.processVP(I, B, q);
          });
        const G = I[B];
        if (G !== void 0 && G !== !1) {
          let Y;
          if (this.isA("VP"))
            Y = this;
          else {
            const he = this.getIndex(["VP"]);
            if (!(he >= 0))
              return void this.warn("bad const for option", '.typ("' + B + ":" + G + '")', this.constType, ["VP"]);
            Y = this.elements[he];
          }
          const ie = Y.getIndex("V");
          if (ie >= 0) {
            const he = Y.elements[ie];
            q(Y, ie, he, G);
          }
        }
      }
      getIdxCtx(I, B) {
        if (this.isA(I)) {
          var q = this.getIndex(B);
          if (q >= 0)
            return [q, this.elements];
        } else if (this.isA("S", "SP")) {
          var G = this.getConst(I);
          if (G !== void 0)
            return G.getIdxCtx(I, B);
        }
        return [void 0, void 0];
      }
      moveAuxToFront() {
        if (this.isEn() && this.isA("S", "SP")) {
          let [I, B] = this.getIdxCtx("VP", "V");
          if (I !== void 0 && !["pp", "pr", "b-to"].includes(this.getProp("t"))) {
            const q = B[0].parentConst.removeElement(0);
            this.addElement(q, 0);
          }
        }
      }
      invertSubject() {
        const I = this.getIndex(["NP", "N", "Pro", "SP", "CP"]);
        if (I >= 0) {
          const B = this.elements[I];
          let q;
          if (B.isA("Pro")) {
            if (B.getProp("pe") == 1 && B.getProp("n") == "s")
              return void this.add(pe("est-ce que"), I);
            q = this.removeElement(I);
          } else
            B.isA("CP") ? (q = Ze("moi", "fr").c("nom").g("m").n("p").pe(3), B.pronoun = q) : q = Ze("moi", "fr").g(B.getProp("g")).n(B.getProp("n")).pe(3).c("nom");
          let [G, Y] = this.getIdxCtx("VP", "V");
          if (G !== void 0) {
            let ie = Y[G];
            ie.parentConst.addElement(q, G + 1), ie.lier();
          }
        }
      }
      processInt(I) {
        const B = I.int, q = m(this.lang).sentence_type.int, G = q.prefix;
        let Y, ie;
        switch (B) {
          case "yon":
          case "how":
          case "why":
          case "muc":
            this.isEn() ? this.moveAuxToFront() : this.invertSubject(), Y = G[B];
            break;
          case "wos":
          case "was":
            if (this.isA("S", "SP", "VP")) {
              const he = this.getIndex(["NP", "N", "Pro", "SP"]);
              if (he !== void 0) {
                const be = this.getIndex(["VP", "V"]);
                be !== void 0 && he < be && (this.elements[be].setProp("pe", 3), this.removeElement(he));
              }
            }
            Y = G[B];
            break;
          case "wod":
          case "wad":
            if (this.isA("S", "SP", "VP")) {
              let he;
              const [be, ke] = this.getIdxCtx("VP", ["NP", "N", "Pro", "SP"]);
              be !== void 0 && (he = ke[0].parentConst.removeElement(be)[ie] = this.passive_subject_par(he, ie)), Y = this.passive_human_object(he, ie) ? "whom" : G[B], this.isEn() ? this.moveAuxToFront() : this.invertSubject();
            }
            break;
          case "woi":
          case "wai":
          case "whe":
          case "whn":
            if (this.isA("S", "SP", "VP")) {
              const [he, be] = this.getIdxCtx("VP", "PP");
              if (Y = G[B], he !== void 0) {
                let ke = be[he].elements[0];
                if (ke.isA("P")) {
                  ke = ke.lemma;
                  const De = this.prepositionsList();
                  B == "whe" ? De.whe.has(ke) && be[0].parentConst.removeElement(he) : B == "whn" ? De.whn.has(ke) && be[0].parentConst.removeElement(he) : De.all.has(ke) && (this.interrogative_pronoun_woi(int_), be[0].parentConst.removeElement(he));
                }
              }
              this.isEn() ? this.moveAuxToFront() : this.invertSubject();
            }
            break;
          case "tag":
            this.isA("S", "SP", "VP") && (this.tag_question(I), Y = G[B]);
            break;
          default:
            this.warn("not implemented", "int:" + B);
        }
        this.should_add_interrogative_prefix(B) && this.addElement(pe(Y), 0), this.a(q.punctuation, !0);
      }
      processTyp(I) {
        I.pas !== void 0 && I.pas !== !1 && this.passivate(), this.processTyp_verb(I), "int" in I && I.int !== !1 && this.processInt(I);
        const B = I.exc;
        return B !== void 0 && B === !0 && this.a(m(this.lang).sentence_type.exc.punctuation, !0), this;
      }
      cpReal() {
        var I = [];
        let B = this.getIndex("C");
        B < 0 && this.elements[0].isA("Q") && (B = 0);
        const q = this.elements.filter(function(be, ke) {
          return ke != B;
        });
        var G = q.length - 1;
        if (G == -1)
          return [];
        if (G == 0)
          return Array.prototype.push.apply(I, q[0].real()), this.setProp("g", q[0].getProp("g")), this.setProp("n", q[0].getProp("n")), this.setProp("pe", q[0].getProp("pe") || 3), this.doFormat(I);
        for (let be = 0; be < G; be++) {
          const ke = q[be];
          (B < 0 || be < G - 1) && (ke.props.a !== void 0 && ke.props.a.includes(",") || (ke.props.a = [","])), Array.prototype.push.apply(I, ke.real());
        }
        let Y;
        if (B >= 0 && Array.prototype.push.apply(I, this.elements[B].real()), Array.prototype.push.apply(I, q[G].real()), B >= 0) {
          Y = this.elements[B];
          var ie = this.and_conj(), he = this.findGenderNumberPerson(Y.lemma == ie);
          he.g !== void 0 && this.setProp("g", he.g), he.n !== void 0 && this.setProp("n", he.n), this.setProp("pe", he.pe), this.pronoun !== void 0 && (this.pronoun.peng = he, this.pronoun.props.g = he.g, this.pronoun.props.n = he.n, this.pronoun.props.pe = he.pe);
        }
        return this.doFormat(I);
      }
      vpReal() {
        var I = [];
        function B(he) {
          return he.map((be) => be.lemma.length).reduce((be, ke) => be + ke, 0) + he.length;
        }
        this.pronominalizeChildren();
        const q = this.elements.length - 1;
        for (var G = q; G >= 0 && !this.elements[G].isA("V"); )
          G--;
        (G < 0 || this.elements[G].getProp("t") == "pp" || ["tre", "be"].includes(this.elements[G].lemma)) && (G = q);
        let Y = 0;
        for (; Y <= G; )
          Array.prototype.push.apply(I, this.elements[Y].real()), Y++;
        if (Y > q)
          return this.doFormat(I);
        let ie = [];
        for (; Y <= q; )
          ie.push(this.elements[Y].real()), Y++;
        return ie.sort(function(he, be) {
          const ke = B(he), De = B(be);
          return Math.min(ke, De) / Math.max(ke, De) > 0.75 ? 0 : ke - De;
        }), ie.forEach((he) => Array.prototype.push.apply(I, he)), this.doFormat(I);
      }
      real() {
        let I = [];
        if (this.isA("CP"))
          return this.cpReal();
        {
          this.pronominalizeChildren();
          const q = this.props.typ;
          q !== void 0 && this.processTyp(q);
          const G = this.elements;
          for (let Y of G) {
            var B;
            B = Y.isA("CP") ? Y.cpReal() : Y.isA("VP") && E ? Y.vpReal() : Y.real(), Array.prototype.push.apply(I, B);
          }
          this.isA("VP") && I.length > 1 && this.checkAdverbPos(I);
        }
        return this.doFormat(I);
      }
      toSource(I) {
        I === void 0 && (I = -1);
        let [B, q] = this.indentSep(I), G = this.constType + "(" + this.elementsSource.map((Y) => Y.toSource(B)).join(q) + ")";
        return G += super.toSource(), G;
      }
      toDebug(I) {
        I === void 0 && (I = -1);
        let [B, q] = this.indentSep(I, !0), G = this.constType;
        return this.peng !== void 0 && (this.peng.pengNO !== void 0 && (G += "#" + this.peng.pengNO), this.taux && this.taux.tauxNO !== void 0 && (G += "-" + this.taux.tauxNO)), G += "(" + this.elements.map((Y) => Y.toDebug(B)).join(q) + ")", G += super.toSource(), G;
      }
    }
    const je = (Z) => class extends ce(Z) {
      link_DAV_properties(I) {
        I.isA("D") && I.lemma == "no" ? this.peng.n = "p" : (this.isA("A") || I.isA("D") && I.getProp("own") === void 0) && (I.peng = this.peng);
      }
      link_subj_obj_subordinate(I, B) {
        ["who", "which", "that"].includes(I.lemma) && (B.peng = this.peng, this.linkAttributes(B, this.getFromPath([["VP"], ["CP"]]), this));
      }
      linkAttributes(I, B, q) {
      }
      check_coordinated_object() {
      }
      pronominalize() {
        if (!this.isA("NP"))
          return this.warn("bad application", ".pro", ["NP"], this.constType);
        const I = this.parentConst;
        let B;
        if (I !== null) {
          let q = this, G = I.elements.findIndex((Y) => Y == q, this);
          I.getIndex("V"), B = this.peng == I.peng || I.isA("SP") && I.elements[0].isA("Pro") ? this.getTonicPro("nom") : this.getTonicPro("acc"), B.peng = this.peng, Object.assign(B.props, this.props), this.peng == I.peng && (I.peng = B.peng), I.removeElement(G), I.addElement(B, G);
        } else
          B = this.getTonicPro("nom"), B.props = this.props, B.peng = this.peng, this.elements = [B];
        return B;
      }
      passive_agree_auxiliary(I, B) {
      }
      processTyp_verb(I) {
        let B;
        if (this.isA("VP"))
          B = this;
        else {
          const G = this.getIndex(["VP"]);
          if (!(G >= 0))
            return this.warn("bad const for option", ".typ(" + JSON.stringify(I) + ")", this.constType, ["VP"]);
          B = this.elements[G];
        }
        const q = B.getIndex("V");
        if (q >= 0) {
          I.contr !== void 0 && I.contr !== !1 && (B.contraction = !0, this.contraction = !0);
          const G = this.affixHopping(B.elements[q], B.getProp("t"), m(this.lang).compound, I);
          B.removeElement(q);
          for (let Y = 0; Y < G.length; Y++)
            B.addElement(G[Y], q + Y);
        } else
          this.warn("not found", "V", "VP");
      }
      move_object(I) {
        if (this.isA("S", "SP")) {
          let [B, q] = this.getIdxCtx("VP", "V");
          if (B !== void 0 && !["pp", "pr", "b-to"].includes(this.getProp("t"))) {
            const G = q[0].parentConst.removeElement(0);
            this.addElement(G, 0);
          }
        }
      }
      passive_subject_par(I, B) {
        return [I, B];
      }
      interrogative_pronoun_woi(I) {
        return I == "woi" ? "whom" : "what";
      }
      tag_question(I) {
        let B;
        const q = this.getFromPath(["VP", "V"]);
        if (q !== void 0) {
          B = "mod" in I && I.mod !== !1 ? m(this.lang).compound[I.mod].aux : ["have", "be", "can", "will", "shall", "may", "must"].includes(q.lemma) ? q.lemma : "do";
          let G = "neg" in I && I.neg === !0, Y = q.getProp("pe"), ie = q.getProp("t"), he = q.getProp("n"), be = q.getProp("g"), ke = Ze("I").pe(Y).n(he).g(be);
          const De = this.getIndex(["NP", "N", "Pro", "SP"]);
          if (De >= 0) {
            const ut = this.getIndex(["VP", "V"]);
            if (ut >= 0 && De < ut) {
              const st = this.elements[De];
              st.isA("Pro") ? st.getProp("pe") != 1 || B != "be" || ie != "p" || G ? ["this", "that", "nothing"].includes(st.lemma) ? ke = Ze("I").g("n") : ["somebody", "anybody", "nobody", "everybody", "someone", "anyone", "everyone"].includes(st.lemma) ? (ke = Ze("I").n("p"), st.lemma == "nobody" && (G = !0)) : ke = st.clone() : Y = 2 : (ke = st.clone().pro(), ke.g(st.getProp("g")).n(st.getProp("n")));
            }
          } else
            ie == "ip" && (B == "do" && (B = "will"), ke = Ze("I").pe(2).n(he).g(be));
          const $e = q.parentConst.getConst("Adv");
          let Qe;
          $e !== void 0 && ["hardly", "scarcely", "never", "seldom"].includes($e.lemma) && (G = !0), q.parentConst.a(","), Qe = B != "have" || G ? rt(ye(B).t(ie).pe(Y).n(he), ke).typ({ neg: !G, contr: !0 }) : rt(ye("have").t(ie).pe(Y).n(he), Je("not"), ke).typ({ contr: !0 }), Qe.peng = ke.peng, this.addElement(Qe);
        }
      }
    };
    class ue extends w {
      constructor(I, B, q) {
        if (super(B), this.lang = q || d(), this.dependents = [], this.terminal = pe("*terminal*"), I.length == 0)
          return this.warn("Dependent without params"), null;
        if (typeof I[0] == "string" ? this.terminal = pe(I.shift()) : I[0] instanceof le ? this.terminal = I.shift() : (this.warn("Dependent needs Terminal", I[0].constructor.name), I.shift()), this.terminal.parentConst = this, this.peng = this.terminal.peng, this.terminal.isA("V") && (this.taux = this.terminal.taux), I = ae(I), this.dependentsSource = [], I.length > 0) {
          const G = I.length - 1;
          for (let Y = 0; Y < G; Y++) {
            let ie = I[Y];
            ie instanceof ue ? (this.addDependent(ie), this.dependentsSource.push(ie)) : this.warn("bad Dependent", se(Y + 2).dOpt({ ord: !0 }).realize(), ie.constructor.name + ":" + JSON.stringify(ie));
          }
          this.add(I[G], void 0, !0);
        }
      }
      addDependent(I, B) {
        return I instanceof ue ? (I.parentConst = this, B == null ? this.dependents.push(I) : typeof B == "number" && B <= this.dependents.length && B >= 0 ? this.dependents.splice(B, 0, I) : this.warn("bad position", B, this.dependents.length)) : this.warn("bad Dependent", se(B + 1).dOpt({ ord: !0 }).realize(), I.constructor.name), this;
      }
      removeDependent(I) {
        if (typeof I == "number" && I < this.dependents.length && I >= 0) {
          const B = this.dependents.splice(I, 1)[0];
          return B.parentConst = null, B;
        }
        return this.warn("bad position", I, this.dependents.length);
      }
      changeDeprel(I) {
        return this.isA("coord") ? this.dependents.forEach((B) => B.constType = I) : this.constType = I, this;
      }
      findIndex(I, B) {
        for (let q = B = B || 0; q < this.dependents.length; q++) {
          const G = this.dependents[q];
          if (G.isA("coord") && G.dependents.length > 0 && I(G.dependents[0]) || I(G))
            return q;
        }
        return -1;
      }
      add(I, B, q) {
        return I instanceof ue ? (q === void 0 ? this.optSource += ".add(" + I.toSource() + (B === void 0 ? "" : "," + B) + ")" : this.dependentsSource.push(I), this.addDependent(I, B), this.linkProperties(), this) : this.warn("bad Dependent", this.word_last(), I.constructor.name);
      }
      me() {
        let I = this.dependents.map(function(B) {
          return B.me();
        });
        return I.unshift(this.terminal.me()), this.constType + "(" + I.join() + ")";
      }
      setPengRecursive(I, B, q) {
        I.peng = q, I.terminal.peng && I.terminal.peng.pengNO == B && (I.terminal.peng = q);
        for (let G of I.dependents)
          this.setPengRecursive(G, B, q);
      }
      linkProperties() {
        if (this.dependents.length == 0)
          return this;
        const I = this.terminal;
        this.isA("coord") && (this.peng = { pengNO: w.pengNO++ }, I.peng = this.peng);
        for (const B of this.dependents) {
          const q = B.terminal;
          switch (B.constType) {
            case "subj":
              I.isA("V") && (I.peng = B.peng);
              break;
            case "det":
              q.isA("D") ? q.peng = this.peng : q.isA("NO") ? q.peng = I.peng : q.isA("P") && q.lemma == "de" && B.dependents.length == 1 && B.dependents[0].isA("mod") && B.dependents[0].terminal.isA("D") && (B.dependents[0].terminal.peng = this.peng);
              break;
            case "mod":
            case "comp":
              if (q.isA("A"))
                this.peng !== void 0 && (q.peng = this.peng), this.link_attributes(q, I);
              else if (q.isA("V")) {
                const G = B.findIndex((Y) => Y.isA("subj", "comp", "mod") && Y.terminal.isA("Pro") && this.relative_pronouns().includes(Y.terminal.lemma));
                G >= 0 && (B.dependents[G].constType == "subj" && (q.peng = this.peng), this.link_pp_before(B, I)), this.link_pp_with_head(q);
              } else if (q.isA("Pro") && this.relative_pronouns().includes(q.lemma)) {
                this.peng !== void 0 && (q.peng = this.peng);
                for (let G of B.dependents)
                  G.peng !== void 0 && this.setPengRecursive(G, G.peng.pengNO, this.peng);
              }
              break;
            case "root":
            case "*pre*":
            case "*post*":
              break;
            case "coord":
              if (B.dependents.length > 0) {
                const G = B.dependents[0];
                if (G.isA("subj"))
                  I.peng = B.peng;
                else if (G.isA("det"))
                  B.peng = I.peng;
                else if (G.isA("mod", "comp") && G.terminal.isA("V", "A")) {
                  B.peng = I.peng;
                  for (let Y of B.dependents)
                    Y.peng = I.peng, Y.terminal.peng = I.peng;
                }
              }
              break;
            default:
              this.error("Strange dependent:" + B.constType);
          }
        }
      }
      setLemma(I, B) {
        return this.error("***: should never happen: setLemma: called on a Dependent"), this;
      }
      findGenderNumberPerson(I) {
        let B, q, G = 3, Y = 0;
        for (let ie = 0; ie < this.dependents.length; ie++) {
          const he = this.dependents[ie].terminal;
          if (he.isA("N", "Pro", "Q", "NO")) {
            Y += 1;
            const be = he.getProp("g");
            B === void 0 && be !== void 0 && (B = be), be == "m" && (B = "m"), he.getProp("n") == "p" && (q = "p");
            const ke = he.getProp("pe");
            ke !== void 0 && ke < G && (G = ke);
          }
        }
        return Y > 1 && I && (q = "p"), { g: B, n: q, pe: G };
      }
      pronominalizeChildren() {
        for (let I of this.dependents)
          I.props.pro !== !0 || I.terminal.isA("Pro") || I.pronominalize();
      }
      passivate() {
        let I, B, q;
        if (!this.terminal.isA("V"))
          return this.warn("not found", "V", this.passive_context());
        {
          const G = this.findIndex((ie) => ie.isA("subj"));
          if (G >= 0) {
            I = this.dependents[G];
            let ie = I.terminal;
            ie.isA("Pro") && (ie = this.passive_pronoun_subject(ie));
          } else
            I = null;
          const Y = this.findIndex((ie) => ie.isA("comp") && ie.terminal.isA("N", "Pro"));
          Y >= 0 ? (B = this.dependents[Y], B.terminal.isA("Pro") ? B.terminal = B.terminal.getTonicPro("nom") : B.terminal.isA("N") && B.props.pro === !0 && (B = B.getTonicPro("nom")), B.changeDeprel("subj"), this.passive_should_link_subject() && (this.terminal.peng = B.peng), I != null && (I.changeDeprel("mod"), this.removeDependent(G), q = this.passive_prep(I.terminal.isA("V")), this.addDependent(de($(q, this.lang), I)))) : I != null && (B = Ze(this.passive_dummy_subject(), this.lang).c("nom"), I.changeDeprel("mod"), this.removeDependent(G), this.addPre(B), this.peng = B.peng, q = this.passive_prep(I.terminal.isA("V")), this.addDependent(de($(q, this.lang), I))), this.passive_agree_with_auxiliary(B);
        }
      }
      processV(I, B, q) {
        if (this.isA("coord"))
          this.dependents.forEach(function(G) {
            G.processV(I, q);
          });
        else if (this.terminal.isA("V")) {
          const G = I[B];
          G != null && G !== !1 && q(this, G);
        }
      }
      addPre(I, B) {
        I instanceof le && (I = [I]);
        for (let q of I)
          this.addDependent(Zt("*pre*", [q]), B);
        return this;
      }
      addPost(I) {
        I instanceof le && (I = [I]);
        for (let B of I.reverse())
          this.addDependent(Zt("*post*", [B]), 0);
        return this;
      }
      processTypInt(I) {
        const B = I.int, q = m(this.lang).sentence_type.int, G = q.prefix;
        let Y, ie, he = this.searchStart;
        switch (he === void 0 && (he = 0), B) {
          case "yon":
          case "how":
          case "why":
          case "muc":
            this.move_object(B), Y = G[B];
            break;
          case "wos":
          case "was":
            let be = this.findIndex(($e) => $e.isA("subj"), he);
            be >= 0 && (this.terminal.setProp("n", "s"), this.terminal.setProp("pe", 3), this.removeDependent(be)), Y = G[B];
            break;
          case "wod":
          case "wad":
            let ke;
            for (let $e = he; $e < this.dependents.length; $e++) {
              const Qe = this.dependents[$e];
              if (Qe.isA("comp") && Qe.terminal.isA("N") && Qe.findIndex((ut) => ut.terminal.isA("P") && ut.getProp("pos") == "pre") < 0) {
                ke = this.removeDependent($e);
                break;
              }
            }
            ie = this.check_passive_subject_with_par(), Y = this.passive_human_object(B, ke) ? "whom" : G[B], this.move_object(B);
            break;
          case "woi":
          case "wai":
          case "whe":
          case "whn":
            let De = !1;
            Y = G[B];
            for (let $e = he; $e < this.dependents.length; $e++) {
              const Qe = this.dependents[$e];
              let ut;
              if (Qe.terminal.isA("P"))
                ut = Qe.terminal.lemma;
              else {
                const st = Qe.findIndex((Rt) => Rt.terminal.isA("P") && Rt.getProp("pos") == "pre");
                st >= 0 && (ut = Qe.dependents[st].terminal.lemma);
              }
              if (Qe.isA("comp", "mod") && ut !== void 0) {
                const st = this.preposition_list();
                if (B == "whe" && st.whe.has(ut) || B == "whn" && st.whn.has(ut) ? De = !0 : st.all.has(ut) && (Y = ut + " " + this.interrogative_pronoun_woi(int_), De = !0), De) {
                  this.removeDependent($e);
                  break;
                }
              }
            }
            this.move_object(B);
            break;
          case "tag":
            this.tag_question(I), Y = G[B];
            break;
          default:
            this.warn("not implemented", "int:" + B);
        }
        this.should_add_interrogative_prefix(B) && this.addPre(pe(Y), 0), ie !== void 0 && (this.addPre(ie, 0), B == "wad" && (this.dependents[1].terminal.lemma = "quoi")), this.a(q.punctuation, !0);
      }
      processTyp(I) {
        I.pas !== void 0 && I.pas !== !1 && this.passivate(), this.processTyp_verb(I), "int" in I && I.int !== !1 && this.processTypInt(I);
        const B = I.exc;
        return B !== void 0 && B === !0 && this.a(m(this.lang).sentence_type.exc.punctuation, !0), this;
      }
      coordReal() {
        let I = [];
        var B = this.dependents.length - 1;
        if (B == -1)
          return [];
        if (B == 0) {
          const be = this.dependents[0];
          return I = be.real(), this.setProp("g", be.getProp("g")), this.setProp("n", be.getProp("n")), this.setProp("pe", be.getProp("pe") || 3), this.doFormat(I);
        }
        const q = this.dependents[0].constType, G = this.terminal.lemma == "";
        for (let be = 0; be < B; be++) {
          const ke = this.dependents[be];
          (G || be < B - 1) && (ke.props.a !== void 0 && ke.props.a.includes(",") || (ke.props.a = [","])), ke.isA("coord") ? I.push(...ke.coordReal()) : ke.isA(q) || q == "coord" ? I.push(...ke.real()) : this.warn("inconsistent dependents within a coord", q, ke.constType);
        }
        I.push(...this.terminal.real());
        const Y = this.dependents[B];
        if (Y.isA("coord"))
          return I.push(...Y.coordReal()), this.doFormat(I);
        Y.isA(q) || q == "coord" || this.warn("inconsistent dependents within a coord", q, Y.constType), I.push(...Y.real());
        const ie = this.terminal;
        if (ie.isA("C")) {
          const be = this.and_conj();
          var he = this.findGenderNumberPerson(ie.lemma == be);
          he.g !== void 0 && this.setProp("g", he.g), he.n !== void 0 && this.setProp("n", he.n), this.setProp("pe", he.pe), ie.pronoun !== void 0 && (ie.pronoun.peng = he, ie.pronoun.props.g = he.g, ie.pronoun.props.n = he.n, ie.pronoun.props.pe = he.pe);
        } else
          ie.isA("Q") || this.warn("bad parameter", "C", ie.constType);
        return this.doFormat(I);
      }
      depPosition() {
        let I = this.props.pos;
        return I !== void 0 || (I = "post", this.isA("subj", "det", "*pre*") ? I = "pre" : this.isA("mod") && this.terminal.isA("A") && this.parentConst.terminal.isA("N") ? I = this.terminal.props.pos || this.adj_def_pos() : this.isA("coord") && this.dependents.length > 0 && (I = this.dependents[0].depPosition())), I;
      }
      doFrenchPronounPlacement(I) {
        return doFrenchPronounPlacement(I);
      }
      real() {
        let I;
        if (this.isA("coord") && this.parentConst == null)
          I = this.coordReal();
        else {
          this.pronominalizeChildren();
          const B = this.props.typ;
          B !== void 0 && this.processTyp(B);
          const q = this.dependents;
          let G = 0;
          for (let Y = 0; Y < q.length; Y++)
            q[Y].depPosition() == "pre" && (G != Y && q.splice(G, 0, q.splice(Y, 1)[0]), G++);
          if (q.length == 0)
            I = this.terminal.real();
          else if (G == 0) {
            I = this.terminal.real();
            for (let Y of q)
              I.push(...Y.isA("coord") ? Y.coordReal() : Y.real());
          } else {
            I = [];
            for (let Y = 0; Y < q.length; Y++) {
              const ie = q[Y];
              I.push(...ie.isA("coord") ? ie.coordReal() : ie.real()), Y == G - 1 && I.push(...this.terminal.real());
            }
          }
          this.terminal.isA("V") && this.checkAdverbPos(I);
        }
        return this.doFormat(I);
      }
      toSource(I) {
        I === void 0 && (I = -1);
        let [B, q] = this.indentSep(I), G = this.dependentsSource.map((ie) => ie.toSource(B));
        G.unshift(this.terminal.toSource());
        let Y = this.constType + "(" + G.join(q) + ")";
        return Y += w.prototype.toSource.call(this), Y;
      }
      toDebug(I) {
        I === void 0 && (I = -1);
        let [B, q] = this.indentSep(I, !0), G = this.dependents.map((ie) => ie.toDebug(B));
        G.unshift(this.terminal.toDebug());
        let Y = this.constType;
        return this.peng !== void 0 && (this.peng.pengNO !== void 0 && (Y += "#" + this.peng.pengNO), this.taux && this.taux.tauxNO !== void 0 && (Y += "-" + this.taux.tauxNO)), Y += "(" + G.join(q) + ")", Y += w.prototype.toDebug.call(this), Y;
      }
    }
    Ie.prototype.toDependent = function(Z) {
      function I(q, G, Y) {
        return q < G ? Y.isA("comp") ? Y.pos("pre") : !Y.isA("mod") || Y.isEn() && Y.terminal.isA("A") || Y.pos("pre") : Y.isA("subj", "det") && Y.pos("post"), Y;
      }
      let B;
      switch (Z = Z || "root", this.constType) {
        case "NP":
        case "VP":
        case "AP":
        case "PP":
        case "AdvP":
          B = function(he, be) {
            let ke;
            const De = be.substr(0, be.length - 1), $e = he.getHeadIndex(be);
            return he.elements[$e].isA(De) ? (ke = Zt(Z, [he.elements[$e]]), he.elements.forEach(function(Qe, ut) {
              if (ut != $e) {
                const st = Qe.toDependent(be == "VP" ? "comp" : "mod");
                ke.add(I(ut, $e, st), void 0, !0);
              }
            })) : console.log(`Phrase.toDependent:: ${be} without ${De}`, he.toSource()), ke;
          }(this, this.constType);
          break;
        case "CP":
          const q = this.getIndex("C");
          q >= 0 ? (B = Zt("coord", [this.elements[q]]), this.elements.forEach(function(he, be) {
            be != q && B.add(he.toDependent(Z), void 0, !0);
          })) : console.log("Phrase.toDependent:: CP without C", this.toSource());
          break;
        case "S":
        case "SP":
          let G = this.getIndex("VP");
          B = G >= 0 ? this.elements[G].toDependent(Z) : Zt(Z, [pe("")]);
          let Y = -1;
          this.isA("SP") && this.isFr() && (Y = this.getIndex(["Pro"]), Y >= 0 && this.elements[Y].lemma == "que" ? B.add(this.elements[Y].toDependent("comp").pos("pre"), 0, !0) : Y = -1);
          let ie = this.getIndex(["NP", "N", "CP", "Pro"]);
          this.elements.forEach(function(he, be) {
            if (be != G && be != Y) {
              const ke = he.toDependent(be == ie ? "subj" : "mod");
              B.add(I(be, G, ke), void 0, !0);
            }
          });
          break;
        default:
          console.log(`Phrase.toDependent:: ${this.constType} not yet implemented`);
      }
      return B.props = this.props, B.optSource = function q(G) {
        let Y = G.indexOf(".add(");
        if (Y < 0)
          return G;
        const ie = G.length;
        let he = 1, be = Y + 5;
        for (; he > 0 && be < ie; ) {
          const ke = G.charAt(be);
          ke == "(" ? he++ : ke == ")" && he--, be++;
        }
        return G.substring(0, Y) + q(G.substring(be));
      }(this.optSource), this.parentConst !== null || this.isA("S") || B.cap(!1), B;
    }, le.prototype.toDependent = function(Z) {
      let I, B = this.parentConst === null;
      return I = this.isA("D", "NO") ? U(this) : Zt(Z || "root", [this]), B && I.cap(!1), I;
    };
    const O = (Z) => class extends ce(Z) {
      link_attributes(I, B) {
      }
      relative_pronouns() {
        return ["who", "that"];
      }
      link_pp_before(I, B) {
      }
      link_pp_with_head(I) {
      }
      passive_agree_with_auxiliary(I) {
      }
      check_passive_subject_with_par() {
      }
      pronominalize() {
        let I;
        this.props.pe = 3, I = this.parentConst === null || this.isA("subj") ? this.getTonicPro("nom") : this.getTonicPro("acc"), I.peng = this.peng, I.parentConst = this, this.terminal = I, this.dependents = [], this.dependentsSource = [];
      }
      processTyp_verb(I) {
        I.contr !== void 0 && I.contr !== !1 && (this.contraction = !0);
        const B = this.affixHopping(this.terminal, this.getProp("t"), m(this.lang).compound, I);
        let q = B.pop();
        q.isA("Pro") && q.lemma == "myself" && (this.addPost(q), q = B.pop()), this.terminal = q, this.addPre(B);
      }
      move_object(I) {
        let B = this.findIndex((q) => q.isA("*pre*"));
        if (B >= 0 && !["pp", "pr"].includes(this.getProp("t"))) {
          const q = this.dependents[B].terminal;
          this.removeDependent(B), this.addPre(q, 0);
        } else if (["be", "have"].includes(this.terminal.lemma)) {
          const q = this.findIndex((G) => G.isA("subj"));
          q >= 0 && this.dependents[q].pos("post");
        } else
          this.dependents.length == 0 && this.addDependent(de(ye("do").pe(3).t("p")));
      }
      tag_question(I) {
        let B;
        const q = this.findIndex((st) => st.terminal.isA("V") && st.depPosition() == "pre"), G = q < 0 ? this.terminal : this.dependents[q].terminal;
        B = "mod" in I && I.mod !== !1 ? m(this.lang).compound[I.mod].aux : ["have", "be", "can", "will", "shall", "may", "must"].includes(G.lemma) ? G.lemma : "do";
        let Y = "neg" in I && I.neg === !0, ie = G.getProp("pe"), he = G.getProp("t"), be = G.getProp("n"), ke = G.getProp("g"), De = Ze("I").pe(ie).n(be).g(ke);
        const $e = this.findIndex((st) => st.isA("mod") && st.terminal.isA("Adv"));
        $e >= 0 && ["hardly", "scarcely", "never", "seldom"].includes(this.dependents[$e].terminal.lemma) && (Y = !0);
        let Qe = this.findIndex((st) => st.isA("subj"));
        if (Qe >= 0) {
          const st = this.dependents[Qe].terminal;
          st.isA("Pro") ? (st.getProp("pe") != 1 || B != "be" || he != "p" || Y ? ["this", "that", "nothing"].includes(st.lemma) ? De = Ze("I").g("n") : ["somebody", "anybody", "nobody", "everybody", "someone", "anyone", "everyone"].includes(st.lemma) ? (De = Ze("I").n("p"), st.lemma == "nobody" && (Y = !0)) : De = st.clone() : ie = 2, De = M(De).pos("post")) : st.isA("N") ? (De = this.dependents[Qe].clone().pro().pos("post"), De.g(st.getProp("g")).n(st.getProp("n"))) : De = M(Ze("it").c("nom")).pos("post");
        } else
          he == "ip" ? (B == "do" && (B = "will"), De = Ze("I").pe(2).n(be).g(ke)) : De = Ze("it").c("nom"), De = M(De).pos("post");
        let ut = this.dependents.length - 1;
        for (; ut >= 0 && this.dependents[ut].depPosition() != "post"; )
          ut--;
        ut < 0 ? G.a(",") : this.dependents[ut].a(","), B != "have" || Y ? this.addDependent(de(ye(B).t(he).pe(ie).n(be), De).typ({ neg: !Y, contr: !0 })) : this.addDependent(de(ye("have").t(he).pe(ie).n(be), K(Je("not")), De).typ({ contr: !0 }));
      }
    }, N = ["N", "A", "Pro", "D", "V", "Adv", "C", "P", "DT", "NO", "Q"], J = ["S", "NP", "AP", "VP", "AdvP", "PP", "CP", "SP"], re = ["root", "det", "subj", "comp", "mod", "coord"];
    function oe(Z, I) {
      if (typeof Z != "object" || Array.isArray(Z))
        console.log("fromJSON: object expected, but found " + typeof Z + ":" + JSON.stringify(Z));
      else if (Z.lang && (Z.lang == "en" ? I = "en" : Z.lang == "fr" ? I = "fr" : (console.log("FromJSON: lang should be 'en' or 'fr', not " + Z.lang + " 'en' will be used"), I = "en")), "phrase" in Z) {
        const B = Z.phrase;
        if (J.includes(B))
          return Ie.fromJSON(B, Z, I);
        console.log("fromJSON: unknown Phrase type:" + B);
      } else if ("dependent" in Z) {
        const B = Z.dependent;
        if (re.includes(B))
          return ue.fromJSON(B, Z, I);
        console.log("fromJSON: unknown Phrase type:" + B);
      } else if ("terminal" in Z) {
        const B = Z.terminal;
        if (N.includes(B))
          return le.fromJSON(B, Z, I);
        console.log("fromJSON: unknown Terminal type:" + B);
      }
    }
    function ee(Z, I, B) {
      function q(ie) {
        B += ie;
      }
      function G(ie) {
        ie.includes("\\") && (ie = ie.replace(/\\/g, "\\\\")), ie.includes('"') && (ie = ie.replace(/"/g, '\\"')), q('"' + ie + '"');
      }
      switch (arguments.length) {
        case 1:
          return ee(Z, 0, "");
        case 2:
          return ee(Z, I, "");
        default:
          switch (typeof Z) {
            case "string":
              G(Z);
              break;
            case "object":
              if (Z === null)
                q("null");
              else if (Array.isArray(Z)) {
                q("[");
                const ie = Z.length, he = Z.some((be) => typeof be == "object" && be !== null);
                for (var Y = 1; Y <= ie; Y++) {
                  const be = Z[Y - 1];
                  he && Y > 1 && q(`
` + " ".repeat(I + 1)), q(ee(be, I + 1, "")), Y < ie && q(",");
                }
                q("]");
              } else {
                q("{");
                const ie = Object.keys(Z), he = ie.length;
                for (Y = 1; Y <= he; Y++) {
                  const be = ie[Y - 1];
                  Y > 1 && q(`
` + " ".repeat(I + 1)), G(be), q(":"), q(ee(Z[be], I + 1 + be.length + 3, "")), Y < he && q(",");
                }
                q("}");
              }
              break;
            default:
              q(Z);
          }
      }
      return B;
    }
    function ae(Z) {
      let I = [];
      for (const B of Z)
        B != null && (Array.isArray(B) ? Array.prototype.push.apply(I, ae(B)) : I.push(B));
      return I;
    }
    function me(Z, I = !1) {
      Z == "en" ? c(I) : pe(Z).warn("bad language", Z);
    }
    w.prototype.setJSONprops = function(Z) {
      if ("props" in Z) {
        const I = Z.props;
        for (let B in I)
          B in this ? Array.isArray(I[B]) ? I[B].forEach((q) => Array.isArray(q) ? w.prototype[B].apply(this, q) : w.prototype[B].call(this, q)) : w.prototype[B].call(this, I[B]) : ["pat", "h"].includes(B) || console.log("Constituent.fromJSON: illegal prop:" + B);
      }
      return this;
    }, Ie.fromJSON = function(Z, I, B) {
      if ("elements" in I) {
        const q = I.elements;
        if (Array.isArray(q)) {
          const G = q.map((Y) => oe(Y, B));
          return new Se(G, Z, "en").setJSONprops(I);
        }
        console.log("Phrase.fromJSON: elements should be an array:" + JSON.stringify(I));
      } else
        console.log("Phrase.fromJSON: no elements found in " + JSON.stringify(I));
    }, ue.fromJSON = function(Z, I, B) {
      if ("terminal" in I)
        if ("dependents" in I) {
          const q = I.dependents;
          if (Array.isArray(q)) {
            let G = q.map((Y) => oe(Y, B));
            return G.unshift(oe(I.terminal, B)), new Ai(G, Z, "en").setJSONprops(I);
          }
          console.log("Dependent.fromJSON: dependents should be an array:" + JSON.stringify(I));
        } else
          console.log("Dependent.fromJSON: no dependents found in " + JSON.stringify(I));
      else
        console.log("Dependent.fromJSON: no terminal found in Dependent:" + JSON.stringify(I));
    }, le.fromJSON = function(Z, I, B) {
      if ("lemma" in I)
        return new ge([I.lemma, "en"], Z).setJSONprops(I);
      console.log("Terminal.fromJSON: no lemma found in " + JSON.stringify(I));
    }, Ie.prototype.toJSON = function() {
      let Z = { phrase: this.constType, elements: this.elements.map((I) => I.toJSON()) };
      return Object.keys(this.props).length > 0 && (Z.props = this.props), this.parentConst != null && this.lang == this.parentConst.lang || (Z.lang = this.lang), Z;
    }, ue.prototype.toJSON = function() {
      let Z = { dependent: this.constType, terminal: this.terminal.toJSON() };
      return this.dependents && (Z.dependents = this.dependents.map((I) => I.toJSON())), Object.keys(this.props).length > 0 && (Z.props = this.props), this.parentConst != null && this.lang == this.parentConst.lang || (Z.lang = this.lang), Z;
    }, le.prototype.toJSON = function() {
      let Z = { terminal: this.constType, lemma: this.lemma };
      return Object.keys(this.props).length > 0 && (Z.props = this.props), this.parentConst != null && this.lang == this.parentConst.lang || (Z.lang = this.lang), Z;
    };
    let H = /* @__PURE__ */ new Map();
    function X(Z) {
      Array.isArray(Z) || (Z = Array.from(arguments));
      const I = Z.length, B = Z.toString();
      let q, G;
      if (H.has(B)) {
        let ie = H.get(B);
        if (ie.length < I) {
          q = [];
          for (let he = 0; he < I; he++)
            ie.indexOf(he) < 0 && q.push(he);
        } else {
          const he = ie[ie.length - 1];
          q = [...Array(I).keys()], q.splice(he, 1), ie.splice(0);
        }
        G = q[Math.floor(Math.random() * q.length)], ie.push(G);
      } else
        q = [...Array(I).keys()], G = q[Math.floor(Math.random() * q.length)], H.set(B, [G]);
      const Y = Z[G];
      return typeof Y == "function" ? Y() : Y;
    }
    function Ae(Z) {
      for (let I = (Z = Array.isArray(Z) ? [...Z] : Array.from(arguments)).length - 1; I > 0; I--) {
        const B = Math.floor(Math.random() * (I + 1));
        [Z[I], Z[B]] = [Z[B], Z[I]];
      }
      return Z.map((I) => typeof I == "function" ? I() : I);
    }
    const Re = "5.0.1", Fe = "2025-09-04, 5:12:12 p.m.", Te = typeof process < "u" && ((r = process == null ? void 0 : process.versions) == null ? void 0 : r.node);
    let qe, tt = !1;
    function Pe(Z) {
      tt = Z;
    }
    function At() {
      qe = [];
    }
    function er() {
      return qe || [];
    }
    class ge extends Ee(le) {
    }
    function ht(Z, I) {
      return I.length == 1 ? d() : I[1], new ge(I, Z);
    }
    function it(...Z) {
      return ht("N", Z);
    }
    function kt(...Z) {
      return ht("A", Z);
    }
    function Ze(...Z) {
      return ht("Pro", Z);
    }
    function fe(...Z) {
      return ht("D", Z);
    }
    function ye(...Z) {
      return ht("V", Z);
    }
    function Je(...Z) {
      return ht("Adv", Z);
    }
    function C(...Z) {
      return ht("C", Z);
    }
    function $(...Z) {
      return ht("P", Z);
    }
    function D(...Z) {
      return ht("DT", Z);
    }
    function se(...Z) {
      return ht("NO", Z);
    }
    function pe(...Z) {
      return ht("Q", Z);
    }
    class Se extends je(_e(Ie)) {
    }
    function Le(Z, I) {
      return new Se(I, Z, "en");
    }
    function ot(...Z) {
      return Le("S", Z);
    }
    function dt(...Z) {
      return Le("NP", Z);
    }
    function St(...Z) {
      return Le("AP", Z);
    }
    function rt(...Z) {
      return Le("VP", Z);
    }
    function zt(...Z) {
      return Le("AdvP", Z);
    }
    function Xt(...Z) {
      return Le("PP", Z);
    }
    function tr(...Z) {
      return Le("CP", Z);
    }
    function Nr(...Z) {
      return Le("SP", Z);
    }
    class Ai extends O(_e(ue)) {
    }
    function Zt(Z, I) {
      return new Ai(I, Z, "en");
    }
    function Un(...Z) {
      return Zt("root", Z);
    }
    function M(...Z) {
      return Zt("subj", Z);
    }
    function U(...Z) {
      return Zt("det", Z);
    }
    function K(...Z) {
      return Zt("mod", Z);
    }
    function de(...Z) {
      return Zt("comp", Z);
    }
    function ve(...Z) {
      return Zt("coord", Z);
    }
    return i;
  })());
})(yj);
var Bl = yj.exports;
let S2e = class extends Error {
  constructor() {
    super("The first array in a zipped array must not be longer than the second.");
  }
};
function A2e(t, e) {
  if (t.length > e.length)
    throw new S2e();
  return t.map(function(r, n) {
    return [r, e[n]];
  });
}
var pr;
((t) => {
  class e extends Error {
  }
  class r extends Bl.Terminal_en {
    clone() {
      const j = new this.constructor(this.lemma);
      let W = this.toJSON();
      return j.setJSONprops(W), j;
    }
    after(j) {
      return this.a(j.lemma);
    }
    before(j) {
      return this.b(j.lemma);
    }
  }
  t.Terminal = r;
  class n extends r {
    /**
     * Constructs a noun object
     * @param {string} lemma - The base noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "N");
    }
  }
  t.Noun = n;
  class i extends n {
    /**
     * Constructs a proper noun object
     * @param {string} lemma - The base proper noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super(j), this.cap();
    }
  }
  t.ProperNoun = i;
  class s extends r {
    /**
     * Constructs a verb object
     * @param {string} lemma - The base verb to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "V");
    }
    t(j) {
      return j === "present" && (j = "p"), j === "past" && (j = "ps"), j === "future" && (j = "f"), j === "present-participle" && (j = "pr"), j === "past-participle" && (j = "pp"), r.prototype.t.call(this, j);
    }
    /**
     * Provides shorthand for past tense
     */
    past() {
      return this.t("past");
    }
    /**
     * Provides shorthand for present tense
     */
    present() {
      return this.t("present");
    }
    /**
     * Provides shorthand for future tense
     */
    future() {
      return this.t("future");
    }
  }
  t.Verb = s;
  class o extends r {
    /**
     * Constructs an adjective object
     * @param {string} lemma - The base adjective to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "A");
    }
  }
  t.Adjective = o;
  class a extends r {
    /**
     * Constructs a determiner object
     * @param {string} lemma - The base noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "D");
    }
  }
  t.Determiner = a;
  class l extends r {
    /**
     * Constructs a conjunction object
     * @param {string} lemma - The base conjunction to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "C");
    }
  }
  t.Conjunction = l;
  class c extends r {
    /**
     * Constructs a preposition object
     * @param {string} lemma - The base preposition to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "P");
    }
  }
  t.Preposition = c;
  class p extends r {
    /**
     * Constructs a pronoun object
     * @param {string} lemma - The base pronoun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "Pro");
    }
  }
  t.Pronoun = p;
  class h extends r {
    /**
     * Constructs an adverb object
     * @param {string} lemma - The base adverb to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "Adv");
    }
  }
  t.Adverb = h;
  class d extends r {
    /**
     * Constructs a noun object
     * @param {string | Date} lemma - The base date to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      j === void 0 ? super([], "DT") : super([j], "DT");
    }
  }
  t.DateNoun = d;
  class v extends r {
    /**
     * Constructs a noun object
     * @param {string} lemma - The base noun to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "NO");
    }
  }
  t.NumberNoun = v;
  class m extends r {
    /**
     * Constructs a quoted raw text object
     * @param {string} text - The base text to be processed
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j) {
      super([j], "Q");
    }
  }
  t.Quote = m;
  class b extends Bl.Phrase_en {
    constructor(j, W) {
      j = j.filter((te) => te != null), super(j, W, "en");
    }
    clone() {
      const j = this.elements.map((le) => le.clone()), W = new this.constructor(j);
      let te = this.toJSON();
      return W.setJSONprops(te), W;
    }
    after(j) {
      return this.a(j.lemma);
    }
    before(j) {
      return this.b(j.lemma);
    }
    realize(j) {
      return super.realize(j).replaceAll(" ,", ",");
    }
  }
  t.Phrase = b;
  class f extends b {
    /**
     * Constructs a noun phrase object
     * @param {MaybeConstituent[]} elements - The elements of the noun phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "NP");
    }
    /**
     * Finds the determiner of the NP, if it has one
     * NOTE: this method assumes that, if an NP has a determiner, then it has a single D element at
     * the top level
     * @returns {Determiner | null} The NP's determiner, if it has one, and null otherwise
     */
    getDeterminer() {
      for (const j of this.elements)
        if (j instanceof a)
          return j;
      return null;
    }
    /**
     * Finds the head noun of the NP
     * NOTE: as an NP object may contain NP objects as constituents, this method can recurse through
     * the constituent tree
     * @returns {Noun} The NP's head noun
     */
    getHeadNoun() {
      const j = this.elements[this.getHeadIndex("NP")];
      return j instanceof f ? j.getHeadNoun() : j;
    }
    /**
     * Given this NP, supposing it has a CP of NPs as its first element, repeatedly factorizes common
     * elements out of the CP, and returns a simplified NP. If simplification isn't possible, no change
     * is made.
     * @param {Boolean} oxford Whether the CP should use the Oxford comma.
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    factorize(j = !1) {
      if (!(this.elements[0] instanceof w))
        throw new e("only NPs of the form NP(CP(...), ...) can be simplified");
      let W = this.elements[0];
      const te = [], le = [];
      let ce = !1;
      for (; !ce; ) {
        const Ee = W.factorize();
        if (Ee.length)
          Ee[0] instanceof w ? (W = Ee[0], le.unshift(Ee[1])) : (te.push(Ee[0]), W = Ee[1]);
        else {
          let xe = W.clone();
          j && xe.oxfordify(), te.push(xe), ce = !0;
        }
      }
      return new f(...te, ...le);
    }
  }
  t.NounPhrase = f;
  class E extends b {
    /**
     * Constructs an adjective phrase object
     * @param {MaybeConstituent[]} elements - The elements of the adjective phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "AP");
    }
  }
  t.AdjPhrase = E;
  class A extends b {
    /**
     * Constructs a verb phrase object
     * @param {MaybeConstituent[]} elements - The elements of the verb phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "VP");
    }
  }
  t.VerbPhrase = A;
  class x extends b {
    /**
     * Constructs a prepositional phrase object
     * @param {MaybeConstituent[]} elements - The elements of the prepositional phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "PP");
    }
  }
  t.PrepPhrase = x;
  class g extends b {
    /**
     * Constructs an adverbal phrase object
     * @param {MaybeConstituent[]} elements - The elements of the adverbal phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "AdvP");
    }
  }
  t.AdvPhrase = g;
  class w extends b {
    /**
     * Constructs a coordinated phrase object
     * @param {MaybeConstituent[]} elements - The elements of the coordinated phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "CP");
    }
    /**
     * Adds an Oxford Comma to this CP; does nothing if the phrase has < 3 constituents, an Oxford Comma
     * is already present, or this CP doesn't begin with a C or a Q.
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    oxfordify() {
      if (this.elements[0] instanceof l || this.elements[0] instanceof m) {
        const j = this.elements.slice(1);
        if (j.length > 2) {
          const W = j[j.length - 2];
          (!W.props.a || !W.props.a.includes(",")) && W.a(",");
        }
      }
      return this;
    }
    /**
     * Factorizes a common element out of this CP. Only possible when this CP is composed of NPs.
     * @returns {[AdjPhrase, CoordPhrase] | [CoordPhrase, Noun] | []}
     * Factorized sequence of common element + CP (in whichever order is appropriate), or the empty array if
     * no factorization was possible. Specifically:
     * 1: [factored-out common AP, remaining CP(conj, NP+)]
     * 2: [remaining CP(conj, N+), factored-out common head N]
     * 3: []
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    factorize() {
      let j = null, W = null;
      if (this.elements[0] instanceof l || this.elements[0] instanceof m ? (j = this.elements[0], W = this.elements.slice(1)) : W = this.elements, !W.every((te) => te instanceof f))
        throw new e("all CP elements must be NPs");
      if (W = W, W.every((te) => te.elements[0] instanceof E && te.elements.slice(1).every((le) => le instanceof n))) {
        const te = W[0].elements[0];
        if (W.every((le) => R(le.elements[0], te))) {
          const le = W.map((ce) => new f(...ce.elements.slice(1)));
          return j && le.unshift(j), [te.clone(), new w(...le)];
        }
      } else if (W.every((te) => te.elements.length > 1 && te.elements.every((le) => le instanceof n))) {
        const te = W[0], le = te.elements[te.elements.length - 1];
        if (W.every(
          (ce) => R(ce.elements[ce.elements.length - 1], le)
        )) {
          const ce = W.map((Ee) => new f(...Ee.elements.slice(0, -1)));
          return j && ce.unshift(j), [new w(...ce), le.clone()];
        }
      } else {
        if (W.every((te) => te.elements.length === 1 && te.elements[0] instanceof n))
          return [];
        throw new e("unrecognized CP structure");
      }
      return [];
    }
  }
  t.CoordPhrase = w;
  class _ extends b {
    /**
     * Constructs an subordinated phrase object.
     * NOTE: `restrictive` should be necessary, but is needed because `.b(',')` does
     *   not work properly in JSRealB. See: https://github.com/rali-udem/jsRealB/issues/54
     * @param {boolean} restrictive - Whether the subordinated phrase is restrictive
     * @param {MaybeConstituent[]} elements - The elements of the subordinated phrase
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(j, ...W) {
      super(W, "SP"), this.restrictive = j;
    }
  }
  t.SubordPhrase = _;
  class S extends b {
    /**
     * Constructs a sentence object
     * @param {MaybeConstituent[]} elements - The elements of the sentence
     * @public
     * @memberOf module:@fizz/theseusaurus
     */
    constructor(...j) {
      super(j, "S");
    }
    // (@simonvarey): This override is necessary as a workaround for a JSRealB design decision. See
    //   rali-udem/jsRealB#56 and theseusaurus#57. Note that it will fail if the sentence has more 
    //   than one tag: see theseusaurus#58.
    realize(j) {
      let W = super.realize(j);
      if ("tag" in this.props) {
        const te = `</${this.props.tag[0][0]}>`;
        W = W.slice(0, -te.length) + `.${te} `;
      }
      return W;
    }
  }
  t.Sentence = S;
  function R(z, j) {
    return z.lang === j.lang && z.constType === j.constType ? z instanceof d ? (j = j, F(z.props.dOpt, j.props.dOpt) ? !1 : L(z, j)) : z instanceof b ? (j = j, z.elements.length !== j.elements.length || A2e(z.elements, j.elements).some((W) => !R(W[0], W[1])) ? !1 : L(z, j)) : z.lemma === j.lemma && L(z, j) : !1;
  }
  t.compareNodes = R;
  function L(z, j) {
    for (const W of Object.keys(z.props))
      if (W !== "dOpt" && z.getProp(W) !== j.getProp(W))
        return !1;
    return !0;
  }
  function F(z, j) {
    if (j === void 0 || Object.keys(z).length !== Object.keys(j).length)
      return !1;
    for (const W of Object.keys(z))
      if (z[W] !== j[W])
        return !1;
    return !0;
  }
})(pr || (pr = {}));
const Tf = class _i {
  /*resetSavedWarnings: any;
  getSavedWarnings: any;*/
  /*ppJSON: any;
  jsRealB_version: any;
  jsRealB_dateCreated: any;
  lexiconEn: any;
  loadEn: any;
  lexiconFr: any;
  loadFr: any;*/
  /**
   * Proxies each function of jsRealB as a function of the Theseusaurus class, with options for extension.
   * @constructor
   */
  constructor() {
    Lo(this, "oneOf"), Lo(this, "setExceptionOnWarning"), this.oneOf = Bl.oneOf, this.setExceptionOnWarning = Bl.setExceptionOnWarning;
  }
  /**
   * Initializes the Theseusaurus object.
   * @private
   * @memberOf module:@fizz/theseusaurus
   */
  async init() {
    await Bl.loadEn(), this._updateLexicon();
  }
  // Helper Functions
  static _addDefToLexicon(e, r, n) {
    const i = {
      N: "n1",
      A: "a1",
      Adv: "b1",
      V: "",
      D: "",
      C: "",
      P: "",
      Pro: "",
      DT: "",
      NO: "",
      Q: ""
    }, s = _i.getLemma(e, "en");
    let o;
    if (s !== void 0) {
      if (s[r] !== void 0) {
        const a = s[r].tab;
        a !== n && n !== "default" && console.warn(`[Theseusaurus]: a different definition of ${e} as a ${r} already exists in the lexicon. Old def: ${a}. New def: ${n}`);
        return;
      }
      n = n === "default" ? i[r] : n, o = { ...s, [r]: { tab: n } };
    } else
      n = n === "default" ? i[r] : n, o = { [r]: { tab: n } };
    _i.addToLexicon(e, o, "en");
  }
  /**
   * Adds chart-specific words and grammar rules to default lexicon.
   * @private
   * @memberOf module:@fizz/theseusaurus
   * NOTE: Previously, 'rising' and 'falling' were added to the lexicon here as adjectives. However,
   *       they are available as the present participle (code: 'pr') forms of the verbs 'rise' and 'fall'.
   */
  _updateLexicon() {
    _i._addDefToLexicon("high", "N", "n1"), _i._addDefToLexicon("x-axis", "N", "n8"), _i._addDefToLexicon("y-axis", "N", "n8"), _i._addDefToLexicon("which", "Adv", "b1"), _i._addDefToLexicon("whose", "Adv", "b1"), _i._addDefToLexicon("what", "Adv", "b1"), _i._addDefToLexicon("worldwide", "Adv", "b1");
  }
  /**
   * Composes a list of words from an array into a coordinated phrase.
   * TODO(?): Allow phrases to be members of the list
   * @param {string[]} wordArray An array of words.
   * @param {new (lemma:string): Terminal} partOfSpeech A terminal constructor for the words with their
   *  part of speech.
   * @param {string} [conjunction] An optional conjunction, such as 'and' (default), 'or', 'nor', 'and then',
   *  or ''; if the empty string, this will make a list without a conjunction.
   * @returns {CoordPhrase} A coordinated phrase. with the tagged words joined with commas and an optional
   *  conjunction.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  composeList(e, r, n = "and") {
    const i = e.slice().map((a) => r(a));
    let s;
    n.includes(" ") ? s = this.Q(n) : n ? s = this.C(n) : s = null;
    const o = this.CP(s, ...i);
    return o.oxfordify(), o;
  }
  // Constituents
  /**
   * Extends the N (noun) function with optional declension parameter
   * @param {string} lemma - The base noun to be processed
   * @param {GramNumber} number - The grammatical number of the noun (e.g. singular/plural). Default is 'singular' ('s').
   * @returns {Noun} - The noun object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  N(e, r = "s", n) {
    n && _i._addDefToLexicon(e, "N", "default");
    const i = new pr.Noun(e);
    return i.n(r), i;
  }
  /**
   * Extends the PN (proper noun) function with optional declension parameter
   * @param {string} lemma - The base noun to be processed
   * @param {GramNumber} number - The grammatical number of the noun (e.g. singular/plural). Default is 'singular' ('s').
   * @returns {ProperNoun} - The noun object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  PN(e, r = "s") {
    _i._addDefToLexicon(e, "N", "default");
    const n = new pr.ProperNoun(e);
    return n.n(r), n;
  }
  /**
   * Extends the V (verb) function with optional tense parameter
   * @param {string} lemma - The base verb to be processed
   * @param {Tense} tense - The tense of the verb. Default is 'present' ('p').
   * @param {GramNumber} number - The number of the verb. Default is 'singular' ('s'). In English, this is only
   *  relevant for 'is'/'are'.
   * @returns {Verb} - The verb function object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  V(e, r = "p", n = "s") {
    return new pr.Verb(e).t(r).n(n);
  }
  /**
   * Extends the A (adjective) function
   * @param {string} lemma - The base adjective to be processed
   * @param {boolean | undefined} addToLexicon - Optional parameter stating whether to add lemma
   *  to lexicon if it does not already exist.
   * @returns {Adjective} - The adjective function object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  A(e, r) {
    return r && _i._addDefToLexicon(e, "A", "default"), new pr.Adjective(e);
  }
  /**
   * Extends the D (determiner) function
   * @param {string} lemma - The base determiner to be processed
   * @returns {Determiner} - The determiner object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  D(e) {
    return new pr.Determiner(e);
  }
  /**
   * Extends the C (conjunction) function
   * @param {string} lemma - The base conjunction to be processed
   * @returns {Conjunction} - The conjunction object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  C(e) {
    return new pr.Conjunction(e);
  }
  /**
   * Extends the P (preposition) function
   * @param {string} lemma - The base preposition to be processed
   * @returns {Preposition} - The preposition object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  P(e) {
    return new pr.Preposition(e);
  }
  /**
   * Extends the Adv (adverb) function
   * @param {string} lemma - The base adverb to be processed
   * @returns {Adverb} - The adverb object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  Adv(e) {
    return new pr.Adverb(e);
  }
  /**
   * Extends the Pro (pronoun) function
   * @param {string} lemma - The base pronoun to be processed
   * @returns {Pronoun} - The pronoun object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  Pro(e) {
    return new pr.Pronoun(e);
  }
  /**
   * Extends the Q (quote) function
   * @param {string} lemma - The raw text to be processed
   * @returns {Quote} - The quote object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  Q(e) {
    return new pr.Quote(e);
  }
  /**
   * Extends the NP (noun phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the noun phrase
   * @returns {NounPhrase} - The noun phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  NP(...e) {
    return new pr.NounPhrase(...e);
  }
  /**
   * Extends the VP (verb phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the verb phrase
   * @returns {VerbPhrase} - The verb phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  VP(...e) {
    return new pr.VerbPhrase(...e);
  }
  /**
   * Extends the AP (adjective phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the adjective phrase
   * @returns {AdjPhrase} - The adjective phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  AP(...e) {
    return new pr.AdjPhrase(...e);
  }
  /**
   * Extends the PP (prepositional phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the prepositional phrase
   * @returns {PrepPhrase} - The prepositional phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  PP(...e) {
    return new pr.PrepPhrase(...e);
  }
  /**
   * Extends the AdvP (adverbial phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the adverbial phrase
   * @returns {AdvPhrase} - The adverbial phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  AdvP(...e) {
    return new pr.AdvPhrase(...e);
  }
  /**
   * Extends the CP (coordinated phrase) function
   * @param {MaybeConstituent[]} constituents - The constituents of the coordinated phrase
   * @returns {CoordPhrase} - The coordinated phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  CP(...e) {
    return new pr.CoordPhrase(...e);
  }
  /**
   * Extends the DT (date) function with year-only handling and optional preposition parameter
   * @param {string | number | Date} lemma - The base date to be processed
   * @param {string} opt - Options for formating. If 'p' is value, will add a preposition to a year-only lemma.
   * @returns {DateNoun} - The date object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  DT(e, r) {
    let n;
    if (e === void 0)
      n = new pr.DateNoun();
    else if (e instanceof Date)
      n = new pr.DateNoun(e);
    else {
      const s = e.toString();
      if (s.match(/^\d+$/)) {
        const o = `${s}/01/01`;
        n = new pr.DateNoun(o).dOpt({
          year: !0,
          month: !1,
          date: !1,
          day: !1,
          hour: !1,
          minute: !1,
          second: !1,
          rtime: !1
        });
      } else
        n = new pr.DateNoun(s);
    }
    let i = !1;
    return r === "p" && (i = !0), n.dOpt({ nat: i, det: i });
  }
  /**
   * Extends the NO (number) function
   * @param {number} number - The base number to be processed
   * @returns {NumberNoun} - The number object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  NO(e) {
    const r = e.toString();
    return new pr.NumberNoun(r).dOpt({ raw: !0 });
  }
  /**
   * Extends the SP (subordinated phrase) function
   * NOTE: `restrictive` should be necessary, but is needed because `.b(',')` does
   *   not work properly in JSRealB. See: https://github.com/rali-udem/jsRealB/issues/54
   * @param {boolean} restrictive - Whether the subordinated phrase is restrictive
   * @param {Constituent[]} constituents - The constituents of the subordinated phrase
   * @returns {SubordPhrase} - The subordinated phrase object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  SP(e, ...r) {
    return new pr.SubordPhrase(e, ...r);
  }
  /**
   * Extends the S (sentence) function
   * @param {Constituent[]} constituents - The constituents of the sentence
   * @returns {Sentence} - The sentence object.
   * @public
   * @memberOf module:@fizz/theseusaurus
   */
  S(...e) {
    return new pr.Sentence(...e);
  }
};
Lo(Tf, "fromJSON", Bl.fromJSON), Lo(Tf, "addToLexicon", Bl.addToLexicon), Lo(Tf, "getLemma", Bl.getLemma), /**
* Compares two syntax tree nodes for equality.
* @param {Constituent} nodeA First node to check.
* @param {Constituent} nodeB Second node to check.
* @returns {boolean} Equality test result.
* @public
* @memberOf module:@fizz/theseusaurus
*/
Lo(Tf, "compareNodes", pr.compareNodes);
let k2e = Tf;
function Ti(t, e, r, n, i) {
  return Da(e, ((s, o) => {
    const a = s[o];
    if (a === void 0)
      throw new TypeError(d8(o));
    return a;
  })(t, e), r, n, i);
}
function Da(t, e, r, n, i, s) {
  const o = N0(e, r, n);
  if (i && e !== o)
    throw new RangeError(OB(t, e, r, n, s));
  return o;
}
function vi(t) {
  return t !== null && /object|function/.test(typeof t);
}
function ms(t, e = Map) {
  const r = new e();
  return (n, ...i) => {
    if (r.has(n))
      return r.get(n);
    const s = t(n, ...i);
    return r.set(n, s), s;
  };
}
function M0(t) {
  return Xp({
    name: t
  }, 1);
}
function Xp(t, e) {
  return $a((r) => ({
    value: r,
    configurable: 1,
    writable: !e
  }), t);
}
function _2e(t) {
  return $a((e) => ({
    get: e,
    configurable: 1
  }), t);
}
function wS(t) {
  return {
    [Symbol.toStringTag]: {
      value: t,
      configurable: 1
    }
  };
}
function jd(t, e) {
  const r = {};
  let n = t.length;
  for (const i of e)
    r[t[--n]] = i;
  return r;
}
function $a(t, e, r) {
  const n = {};
  for (const i in e)
    n[i] = t(e[i], i, r);
  return n;
}
function Dv(t, e, r) {
  const n = {};
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    n[s] = t(s, i, r);
  }
  return n;
}
function vj(t, e, r) {
  const n = {};
  for (let i = 0; i < t.length; i++)
    n[e[i]] = r[t[i]];
  return n;
}
function co(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const n of t)
    r[n] = e[n];
  return r;
}
function PI(t, e) {
  for (const r of e)
    if (r in t)
      return 1;
  return 0;
}
function bj(t, e, r) {
  for (const n of t)
    if (e[n] !== r[n])
      return 0;
  return 1;
}
function wj(t, e, r) {
  const n = {
    ...r
  };
  for (let i = 0; i < e; i++)
    n[t[i]] = 0;
  return n;
}
function ir(t, ...e) {
  return (...r) => t(...e, ...r);
}
function RI(t) {
  return t[0].toUpperCase() + t.substring(1);
}
function Vg(t) {
  return t.slice().sort();
}
function Vy(t, e) {
  return String(e).padStart(t, "0");
}
function Fl(t, e) {
  return Math.sign(t - e);
}
function N0(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
function Ea(t, e) {
  return [Math.floor(t / e), Jf(t, e)];
}
function Jf(t, e) {
  return (t % e + e) % e;
}
function ec(t, e) {
  return [$v(t, e), xS(t, e)];
}
function $v(t, e) {
  return Math.trunc(t / e) || 0;
}
function xS(t, e) {
  return t % e || 0;
}
function Gm(t) {
  return Math.abs(t % 1) === 0.5;
}
function xj(t, e, r) {
  let n = 0, i = 0;
  for (let a = 0; a <= e; a++) {
    const l = t[r[a]], c = Wo[a], p = Fr / c, [h, d] = ec(l, p);
    n += d * c, i += h;
  }
  const [s, o] = ec(n, Fr);
  return [i + s, o];
}
function jv(t, e, r) {
  const n = {};
  for (let i = e; i >= 0; i--) {
    const s = Wo[i];
    n[r[i]] = $v(t, s), t = xS(t, s);
  }
  return n;
}
function C2e(t) {
  if (t !== void 0)
    return Xn(t);
}
function I2e(t) {
  if (t !== void 0)
    return fa(t);
}
function Ej(t) {
  if (t !== void 0)
    return ES(t);
}
function fa(t) {
  return kj(ES(t));
}
function ES(t) {
  return Aj(jbe(t));
}
function Sj(t, e) {
  if (e == null)
    throw new RangeError(d8(t));
  return e;
}
function Hg(t) {
  if (!vi(t))
    throw new TypeError(cbe);
  return t;
}
function SS(t, e, r = t) {
  if (typeof e !== t)
    throw new TypeError(jc(r, e));
  return e;
}
function Aj(t, e = "number") {
  if (!Number.isInteger(t))
    throw new RangeError(nbe(e, t));
  return t || 0;
}
function kj(t, e = "number") {
  if (t <= 0)
    throw new RangeError(ibe(e, t));
  return t;
}
function AS(t) {
  if (typeof t == "symbol")
    throw new TypeError(lbe);
  return String(t);
}
function R1(t, e) {
  return vi(t) ? String(t) : Xn(t, e);
}
function kS(t) {
  if (typeof t == "string")
    return BigInt(t);
  if (typeof t != "bigint")
    throw new TypeError(abe(t));
  return t;
}
function _j(t, e = "number") {
  if (typeof t == "bigint")
    throw new TypeError(obe(e));
  if (t = Number(t), !Number.isFinite(t))
    throw new RangeError(sbe(e, t));
  return t;
}
function si(t, e) {
  return Math.trunc(_j(t, e)) || 0;
}
function _S(t, e) {
  return Aj(_j(t, e), e);
}
function OI(t, e) {
  return kj(si(t, e), e);
}
function CS(t, e) {
  let [r, n] = ec(e, Fr), i = t + r;
  const s = Math.sign(i);
  return s && s === -Math.sign(n) && (i -= s, n += s * Fr), [i, n];
}
function ed(t, e, r = 1) {
  return CS(t[0] + e[0] * r, t[1] + e[1] * r);
}
function vh(t, e) {
  return CS(t[0], t[1] + e);
}
function Ho(t, e) {
  return ed(e, t, -1);
}
function ys(t, e) {
  return Fl(t[0], e[0]) || Fl(t[1], e[1]);
}
function Cj(t, e, r) {
  return ys(t, e) === -1 || ys(t, r) === 1;
}
function IS(t, e = 1) {
  const r = BigInt(Fr / e);
  return [Number(t / r), Number(t % r) * e];
}
function Hy(t, e = 1) {
  const r = Fr / e, [n, i] = ec(t, r);
  return [n, i * e];
}
function Go(t, e = 1, r) {
  const [n, i] = t, [s, o] = ec(i, e);
  return n * (Fr / e) + (s + (r ? o / e : 0));
}
function PS(t, e, r = Ea) {
  const [n, i] = t, [s, o] = r(i, e);
  return [n * (Fr / e) + s, o];
}
function RS(t) {
  return Ti(t, "isoYear", z0, F0, 1), t.isoYear === z0 ? Ti(t, "isoMonth", 4, 12, 1) : t.isoYear === F0 && Ti(t, "isoMonth", 1, 9, 1), t;
}
function Fs(t) {
  return Qi({
    ...t,
    ...Ki,
    isoHour: 12
  }), t;
}
function Qi(t) {
  const e = Ti(t, "isoYear", z0, F0, 1), r = e === z0 ? 1 : e === F0 ? -1 : 0;
  return r && na(Rn({
    ...t,
    isoDay: t.isoDay + r,
    isoNanosecond: t.isoNanosecond - r
  })), t;
}
function na(t) {
  if (!t || Cj(t, Wbe, Gbe))
    throw new RangeError(Bc);
  return t;
}
function tc(t) {
  return xj(t, 5, po)[1];
}
function Bv(t) {
  const [e, r] = Ea(t, Fr);
  return [jv(r, 5, po), e];
}
function TI(t) {
  return PS(t, Do);
}
function ui(t) {
  return Bd(t.isoYear, t.isoMonth, t.isoDay, t.isoHour, t.isoMinute, t.isoSecond, t.isoMillisecond);
}
function Rn(t) {
  const e = ui(t);
  if (e !== void 0) {
    const [r, n] = ec(e, Bi);
    return [r, n * el + (t.isoMicrosecond || 0) * Zg + (t.isoNanosecond || 0)];
  }
}
function OS(t, e) {
  const [r, n] = Bv(tc(t) - e);
  return na(Rn({
    ...t,
    isoDay: t.isoDay + n,
    ...r
  }));
}
function Gy(...t) {
  return Bd(...t) / FB;
}
function Bd(...t) {
  const [e, r] = Ij(...t), n = e.valueOf();
  if (!isNaN(n))
    return n - r * Bi;
}
function Ij(t, e = 1, r = 1, n = 0, i = 0, s = 0, o = 0) {
  const a = t === z0 ? 1 : t === F0 ? -1 : 0, l = /* @__PURE__ */ new Date();
  return l.setUTCHours(n, i, s, o), l.setUTCFullYear(t, e - 1, r + a), [l, a];
}
function Fd(t, e) {
  let [r, n] = vh(t, e);
  n < 0 && (n += Fr, r -= 1);
  const [i, s] = Ea(n, el), [o, a] = Ea(s, Zg);
  return Fv(r * Bi + i, o, a);
}
function Fv(t, e = 0, r = 0) {
  const n = Math.ceil(Math.max(0, Math.abs(t) - Hbe) / Bi) * Math.sign(t), i = new Date(t - n * Bi);
  return jd(ab, [i.getUTCFullYear(), i.getUTCMonth() + 1, i.getUTCDate() + n, i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds(), e, r]);
}
function TS(t, e) {
  if (e < -864e13)
    throw new RangeError(Bc);
  const r = t.formatToParts(e), n = {};
  for (const i of r)
    n[i.type] = i.value;
  return n;
}
function LS(t) {
  return [t.isoYear, t.isoMonth, t.isoDay];
}
function Pj(t, e) {
  return [e, 0];
}
function Rj() {
  return gl;
}
function Oj(t, e) {
  switch (e) {
    case 2:
      return MS(t) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function Tj(t) {
  return MS(t) ? 366 : 365;
}
function MS(t) {
  return t % 4 == 0 && (t % 100 != 0 || t % 400 == 0);
}
function Lj(t) {
  const [e, r] = Ij(t.isoYear, t.isoMonth, t.isoDay);
  return Jf(e.getUTCDay() - r, 7) || 7;
}
function Mj(t) {
  return this.id === Qd ? (({ isoYear: e }) => e < 1 ? ["gregory-inverse", 1 - e] : ["gregory", e])(t) : this.id === ic ? Kbe(t) : [];
}
function P2e(t) {
  const e = ui(t);
  if (e < Qbe) {
    const { isoYear: s } = t;
    return s < 1 ? ["japanese-inverse", 1 - s] : ["japanese", s];
  }
  const r = TS(L8(ic), e), { era: n, eraYear: i } = wB(r, ic);
  return [n, i];
}
function zv(t) {
  return Fh(t), zd(t, 1), t;
}
function Fh(t) {
  return Nj(t, 1), t;
}
function LI(t) {
  return bj(E8, t, Nj(t));
}
function Nj(t, e) {
  const { isoYear: r } = t, n = Ti(t, "isoMonth", 1, Rj(), e);
  return {
    isoYear: r,
    isoMonth: n,
    isoDay: Ti(t, "isoDay", 1, Oj(r, n), e)
  };
}
function zd(t, e) {
  return jd(po, [Ti(t, "isoHour", 0, 23, e), Ti(t, "isoMinute", 0, 59, e), Ti(t, "isoSecond", 0, 59, e), Ti(t, "isoMillisecond", 0, 999, e), Ti(t, "isoMicrosecond", 0, 999, e), Ti(t, "isoNanosecond", 0, 999, e)]);
}
function gr(t) {
  return t === void 0 ? 0 : rF(Hg(t));
}
function Uv(t, e = 0) {
  t = ia(t);
  const r = nF(t), n = swe(t, e);
  return [rF(t), n, r];
}
function Ud(t, e, r, n = 9, i = 0, s = 4) {
  e = ia(e);
  let o = tF(e, n, i), a = $S(e), l = em(e, s);
  const c = Xg(e, n, i, 1);
  return o == null ? o = Math.max(r, c) : Bj(o, c), a = jS(a, c, 1), t && (l = ((p) => p < 4 ? (p + 2) % 4 : p)(l)), [o, c, a, l];
}
function Vv(t, e = 6, r) {
  let n = $S(t = Hv(t, Zy));
  const i = em(t, 7);
  let s = Xg(t, e);
  return s = Sj(Zy, s), n = jS(n, s, void 0, r), [s, n, i];
}
function NS(t) {
  return A8(ia(t));
}
function Dj(t, e) {
  return DS(ia(t), e);
}
function R2e(t) {
  const e = Hv(t, B3), r = Lc(B3, nwe, e, 0);
  if (!r)
    throw new RangeError(jc(B3, r));
  return r;
}
function DS(t, e = 4) {
  const r = jj(t);
  return [em(t, 4), ...$j(Xg(t, e), r)];
}
function $j(t, e) {
  return t != null ? [Wo[t], t < 4 ? 9 - 3 * t : -1] : [e === void 0 ? 1 : 10 ** (9 - e), e];
}
function $S(t) {
  const e = t[Xf];
  return e === void 0 ? 1 : si(e, Xf);
}
function jS(t, e, r, n) {
  const i = n ? Fr : Wo[e + 1];
  if (i) {
    const s = Wo[e];
    if (i % ((t = Da(Xf, t, 1, i / s - (n ? 0 : 1), 1)) * s))
      throw new RangeError(jc(Xf, t));
  } else
    t = Da(Xf, t, 1, r ? 10 ** 9 : 1, 1);
  return t;
}
function jj(t) {
  let e = t[j3];
  if (e !== void 0) {
    if (typeof e != "number") {
      if (AS(e) === "auto")
        return;
      throw new RangeError(jc(j3, e));
    }
    e = Da(j3, Math.floor(e), 0, 9, 1);
  }
  return e;
}
function ia(t) {
  return t === void 0 ? {} : Hg(t);
}
function Hv(t, e) {
  return typeof t == "string" ? {
    [e]: t
  } : Hg(t);
}
function Gv(t) {
  return {
    overflow: Ybe[t]
  };
}
function BS(t, e, r = 9, n = 0, i) {
  let s = e[t];
  if (s === void 0)
    return i ? n : void 0;
  if (s = AS(s), s === "auto")
    return i ? n : null;
  let o = S4[s];
  if (o === void 0 && (o = zbe[s]), o === void 0)
    throw new RangeError(LB(t, s, S4));
  return Da(t, o, n, r, 1, f8), o;
}
function Lc(t, e, r, n = 0) {
  const i = r[t];
  if (i === void 0)
    return n;
  const s = AS(i), o = e[s];
  if (o === void 0)
    throw new RangeError(LB(t, s, e));
  return o;
}
function Bj(t, e) {
  if (e > t)
    throw new RangeError(Rbe);
}
function Ja(t) {
  return {
    branding: I8,
    epochNanoseconds: t
  };
}
function uo(t, e, r) {
  return {
    branding: Fc,
    calendar: r,
    timeZone: e,
    epochNanoseconds: t
  };
}
function ho(t, e = t.calendar) {
  return {
    branding: Kd,
    calendar: e,
    ...co(Ube, t)
  };
}
function Xa(t, e = t.calendar) {
  return {
    branding: tm,
    calendar: e,
    ...co(S8, t)
  };
}
function D0(t, e = t.calendar) {
  return {
    branding: k8,
    calendar: e,
    ...co(S8, t)
  };
}
function Wy(t, e = t.calendar) {
  return {
    branding: _8,
    calendar: e,
    ...co(S8, t)
  };
}
function sa(t) {
  return {
    branding: C8,
    ...co(YB, t)
  };
}
function bn(t) {
  return {
    branding: P8,
    sign: Mc(t),
    ...co(b8, t)
  };
}
function FS(t) {
  return PS(t.epochNanoseconds, el)[0];
}
function O2e(t) {
  return ((e, r = 1) => {
    const [n, i] = e, s = Math.floor(i / r), o = Fr / r;
    return BigInt(n) * BigInt(o) + BigInt(s);
  })(t.epochNanoseconds);
}
function Fj(t) {
  return t.epochNanoseconds;
}
function T2e(t, e, r, n, i) {
  const s = bh(n), [o, a] = ((E, A) => {
    const x = A((E = Hv(E, _4))[XB]);
    let g = iwe(E);
    return g = Sj(_4, g), [g, x];
  })(i, t), l = Math.max(o, s);
  if (!a && j0(l, a))
    return MI(n, o);
  if (!a)
    throw new RangeError(ib);
  if (!n.sign)
    return 0;
  const [c, p, h] = Yv(e, r, a), d = KS(h), v = Zv(h), m = YS(h), b = v(p, c, n);
  td(a) || (Qi(c), Qi(b));
  const f = m(p, c, b, o);
  return j0(o, a) ? MI(f, o) : ((E, A, x, g, w, _, S) => {
    const R = Mc(E), [L, F] = zS(g, x8(x, E), x, R, w, _, S), z = US(A, L, F);
    return E[wr[x]] + z * R;
  })(f, d(b), o, p, c, d, v);
}
function MI(t, e) {
  return Go(Nn(t), Wo[e], 1);
}
function zS(t, e, r, n, i, s, o) {
  const a = wr[r], l = {
    ...e,
    [a]: e[a] + n
  }, c = o(t, i, e), p = o(t, i, l);
  return [s(c), s(p)];
}
function US(t, e, r) {
  const n = Go(Ho(e, r));
  if (!n)
    throw new RangeError(qd);
  return Go(Ho(e, t)) / n;
}
function L2e(t, e) {
  const [r, n, i] = Vv(e, 5, 1);
  return Ja(qv(t.epochNanoseconds, r, n, i, 1));
}
function M2e(t, e, r) {
  let { epochNanoseconds: n, timeZone: i, calendar: s } = e;
  const [o, a, l] = Vv(r);
  if (o === 0 && a === 1)
    return e;
  const c = t(i);
  if (o === 6)
    n = ((p, h, d, v) => {
      const m = bs(d, h), [b, f] = p(m), E = d.epochNanoseconds, A = nc(h, b), x = nc(h, f);
      if (Cj(E, A, x))
        throw new RangeError(qd);
      return Gj(US(E, A, x), v) ? x : A;
    })(Vj, c, e, l);
  else {
    const p = c.R(n);
    n = Vd(c, zj(Fd(n, p), o, a, l), p, 2, 0, 1);
  }
  return uo(n, i, s);
}
function N2e(t, e) {
  return ho(zj(t, ...Vv(e)), t.calendar);
}
function D2e(t, e) {
  const [r, n, i] = Vv(e, 5);
  var s;
  return sa((s = i, VS(t, Gg(r, n), s)[0]));
}
function $2e(t, e) {
  const r = t(e.timeZone), n = bs(e, r), [i, s] = Vj(n), o = Go(Ho(nc(r, i), nc(r, s)), ob, 1);
  if (o <= 0)
    throw new RangeError(qd);
  return o;
}
function j2e(t, e) {
  const { timeZone: r, calendar: n } = e, i = ((s, o, a) => nc(o, s(bs(a, o))))(Hj, t(r), e);
  return uo(i, r, n);
}
function zj(t, e, r, n) {
  return Uj(t, Gg(e, r), n);
}
function Uj(t, e, r) {
  const [n, i] = VS(t, e, r);
  return Qi({
    ...zh(t, i),
    ...n
  });
}
function VS(t, e, r) {
  return Bv(rc(tc(t), e, r));
}
function qy(t) {
  return rc(t, sb, 7);
}
function Gg(t, e) {
  return Wo[t] * e;
}
function Vj(t) {
  const e = Hj(t);
  return [e, zh(e, 1)];
}
function Hj(t) {
  return Vbe(6, t);
}
function B2e(t, e, r) {
  const n = Math.min(bh(t), 6);
  return Hd(Qv(Nn(t, n), e, r), n);
}
function Wv(t, e, r, n, i, s, o, a, l, c) {
  if (n === 0 && i === 1)
    return t;
  const p = j0(n, a) ? td(a) && n < 6 && r >= 6 ? z2e : F2e : U2e;
  let [h, d, v] = p(t, e, r, n, i, s, o, a, l, c);
  return v && n !== 7 && (h = ((m, b, f, E, A, x, g, w) => {
    const _ = Mc(m);
    for (let S = E + 1; S <= f; S++) {
      if (S === 7 && f !== 7)
        continue;
      const R = x8(S, m);
      R[wr[S]] += _;
      const L = Go(Ho(g(w(A, x, R)), b));
      if (L && Math.sign(L) !== _)
        break;
      m = R;
    }
    return m;
  })(h, d, r, Math.max(6, n), o, a, l, c)), h;
}
function qv(t, e, r, n, i) {
  if (e === 6) {
    const s = ((o) => o[0] + o[1] / Fr)(t);
    return [rc(s, r, n), 0];
  }
  return Qv(t, Gg(e, r), n, i);
}
function Qv(t, e, r, n) {
  let [i, s] = t;
  n && s < 0 && (s += Fr, i -= 1);
  const [o, a] = Ea(rc(s, e, r), Fr);
  return CS(i + o, a);
}
function rc(t, e, r) {
  return Gj(t / e, r) * e;
}
function Gj(t, e) {
  return lwe[e](t);
}
function F2e(t, e, r, n, i, s) {
  const o = Mc(t), a = Nn(t), l = qv(a, n, i, s), c = Ho(a, l), p = Math.sign(l[0] - a[0]) === o, h = Hd(l, Math.min(r, 6));
  return [{
    ...t,
    ...h
  }, ed(e, c), p];
}
function z2e(t, e, r, n, i, s, o, a, l, c) {
  const p = Mc(t) || 1, h = Go(Nn(t, 5)), d = Gg(n, i);
  let v = rc(h, d, s);
  const [m, b] = zS(o, {
    ...t,
    ...w8
  }, 6, p, a, l, c), f = v - Go(Ho(m, b));
  let E = 0;
  f && Math.sign(f) !== p ? e = vh(m, v) : (E += p, v = rc(f, d, s), e = vh(b, v));
  const A = Jv(v);
  return [{
    ...t,
    ...A,
    days: t.days + E
  }, e, !!E];
}
function U2e(t, e, r, n, i, s, o, a, l, c) {
  const p = Mc(t), h = wr[n], d = x8(n, t);
  n === 7 && (t = {
    ...t,
    weeks: t.weeks + Math.trunc(t.days / 7)
  });
  const v = $v(t[h], i) * i;
  d[h] = v;
  const [m, b] = zS(o, d, n, i * p, a, l, c), f = v + US(e, m, b) * p * i, E = rc(f, i, s), A = Math.sign(E - f) === p;
  return d[h] = E, [d, A ? b : m, A];
}
function NI(t, e, r, n) {
  const [i, s, o, a] = ((c) => {
    const p = DS(c = ia(c));
    return [c.timeZone, ...p];
  })(n), l = i !== void 0;
  return ((c, p, h, d, v, m) => {
    h = Qv(h, v, d, 1);
    const b = p.R(h);
    return HS(Fd(h, b), m) + (c ? Wg(qy(b)) : "Z");
  })(l, e(l ? t(i) : Gh), r.epochNanoseconds, s, o, a);
}
function DI(t, e, r) {
  const [n, i, s, o, a, l] = ((c) => {
    c = ia(c);
    const p = A8(c), h = jj(c), d = awe(c), v = em(c, 4), m = Xg(c, 4);
    return [p, owe(c), d, v, ...$j(m, h)];
  })(r);
  return ((c, p, h, d, v, m, b, f, E, A) => {
    d = Qv(d, E, f, 1);
    const x = c(h).R(d);
    return HS(Fd(d, x), A) + Wg(qy(x), b) + ((g, w) => w !== 1 ? "[" + (w === 2 ? "!" : "") + g + "]" : "")(h, m) + GS(p, v);
  })(t, e.calendar, e.timeZone, e.epochNanoseconds, n, i, s, o, a, l);
}
function $I(t, e) {
  const [r, n, i, s] = ((c) => (c = ia(c), [A8(c), ...DS(c)]))(e);
  return o = t.calendar, a = r, l = s, HS(Uj(t, i, n), l) + GS(o, a);
  var o, a, l;
}
function jI(t, e) {
  return r = t.calendar, n = t, i = NS(e), Qy(n) + GS(r, i);
  var r, n, i;
}
function BI(t, e) {
  return Wj(t.calendar, qj, t, NS(e));
}
function FI(t, e) {
  return Wj(t.calendar, V2e, t, NS(e));
}
function zI(t, e) {
  const [r, n, i] = Dj(e);
  return s = i, Qj(VS(t, n, r)[0], s);
  var s;
}
function T3(t, e) {
  const [r, n, i] = Dj(e, 3);
  return n > 1 && Uh(t = {
    ...t,
    ...B2e(t, n, r)
  }), ((s, o) => {
    const { sign: a } = s, l = a === -1 ? bi(s) : s, { hours: c, minutes: p } = l, [h, d] = PS(Nn(l, 3), Do, ec);
    Jj(h);
    const v = WS(d, o), m = o >= 0 || !a || v;
    return (a < 0 ? "-" : "") + "P" + UI({
      Y: ku(l.years),
      M: ku(l.months),
      W: ku(l.weeks),
      D: ku(l.days)
    }) + (c || p || h || m ? "T" + UI({
      H: ku(c),
      M: ku(p),
      S: ku(h, m) + v
    }) : "");
  })(t, i);
}
function Wj(t, e, r, n) {
  const i = n > 1 || n === 0 && t !== ur;
  return n === 1 ? t === ur ? e(r) : Qy(r) : i ? Qy(r) + Kj(t, n === 2) : e(r);
}
function UI(t) {
  const e = [];
  for (const r in t) {
    const n = t[r];
    n && e.push(n, r);
  }
  return e.join("");
}
function HS(t, e) {
  return Qy(t) + "T" + Qj(t, e);
}
function Qy(t) {
  return qj(t) + "-" + zs(t.isoDay);
}
function qj(t) {
  const { isoYear: e } = t;
  return (e < 0 || e > 9999 ? Yj(e) + Vy(6, Math.abs(e)) : Vy(4, e)) + "-" + zs(t.isoMonth);
}
function V2e(t) {
  return zs(t.isoMonth) + "-" + zs(t.isoDay);
}
function Qj(t, e) {
  const r = [zs(t.isoHour), zs(t.isoMinute)];
  return e !== -1 && r.push(zs(t.isoSecond) + ((n, i, s, o) => WS(n * el + i * Zg + s, o))(t.isoMillisecond, t.isoMicrosecond, t.isoNanosecond, e)), r.join(":");
}
function Wg(t, e = 0) {
  if (e === 1)
    return "";
  const [r, n] = Ea(Math.abs(t), ob), [i, s] = Ea(n, sb), [o, a] = Ea(s, Do);
  return Yj(t) + zs(r) + ":" + zs(i) + (o || a ? ":" + zs(o) + WS(a) : "");
}
function GS(t, e) {
  return e !== 1 && (e > 1 || e === 0 && t !== ur) ? Kj(t, e === 2) : "";
}
function Kj(t, e) {
  return "[" + (e ? "!" : "") + "u-ca=" + t + "]";
}
function WS(t, e) {
  let r = Vy(9, t);
  return r = e === void 0 ? r.replace(hwe, "") : r.slice(0, e), r ? "." + r : "";
}
function Yj(t) {
  return t < 0 ? "-" : "+";
}
function ku(t, e) {
  return t || e ? t.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function H2e(t, e) {
  const { epochNanoseconds: r } = t, n = (e.R ? e : e(t.timeZone)).R(r), i = Fd(r, n);
  return {
    calendar: t.calendar,
    ...i,
    offsetNanoseconds: n
  };
}
function Vd(t, e, r, n = 0, i = 0, s, o) {
  if (r !== void 0 && n === 1 && (n === 1 || o))
    return OS(e, r);
  const a = t.I(e);
  if (r !== void 0 && n !== 3) {
    const l = ((c, p, h, d) => {
      const v = Rn(p);
      d && (h = qy(h));
      for (const m of c) {
        let b = Go(Ho(m, v));
        if (d && (b = qy(b)), b === h)
          return m;
      }
    })(a, e, r, s);
    if (l !== void 0)
      return l;
    if (n === 0)
      throw new RangeError(Abe);
  }
  return o ? Rn(e) : qg(t, e, i, a);
}
function qg(t, e, r = 0, n = t.I(e)) {
  if (n.length === 1)
    return n[0];
  if (r === 1)
    throw new RangeError(kbe);
  if (n.length)
    return n[r === 3 ? 1 : 0];
  const i = Rn(e), s = ((a, l) => {
    const c = a.R(vh(l, -864e11));
    return ((p) => {
      if (p > Fr)
        throw new RangeError(Sbe);
      return p;
    })(a.R(vh(l, Fr)) - c);
  })(t, i), o = s * (r === 2 ? -1 : 1);
  return (n = t.I(Fd(i, o)))[r === 2 ? 0 : n.length - 1];
}
function nc(t, e) {
  const r = t.I(e);
  if (r.length)
    return r[0];
  const n = vh(Rn(e), -864e11);
  return t.O(n, 1);
}
function VI(t, e, r) {
  return Ja(na(ed(e.epochNanoseconds, ((n) => {
    if (Xj(n))
      throw new RangeError(Ibe);
    return Nn(n, 5);
  })(t ? bi(r) : r))));
}
function HI(t, e, r, n, i, s = /* @__PURE__ */ Object.create(null)) {
  const o = e(n.timeZone), a = t(n.calendar);
  return {
    ...n,
    ...qS(o, a, n, r ? bi(i) : i, s)
  };
}
function GI(t, e, r, n, i = /* @__PURE__ */ Object.create(null)) {
  const { calendar: s } = r;
  return ho(QS(t(s), r, e ? bi(n) : n, i), s);
}
function WI(t, e, r, n, i) {
  const { calendar: s } = r;
  return Xa(Kv(t(s), r, e ? bi(n) : n, i), s);
}
function qI(t, e, r, n, i) {
  const s = r.calendar, o = t(s);
  let a = Fs($0(o, r));
  e && (n = ZS(n)), n.sign < 0 && (a = o.P(a, {
    ...Dn,
    months: 1
  }), a = zh(a, -1));
  const l = o.P(a, n, i);
  return D0($0(o, l), s);
}
function QI(t, e, r) {
  return sa(Zj(e, t ? bi(r) : r)[0]);
}
function qS(t, e, r, n, i) {
  const s = Nn(n, 5);
  let o = r.epochNanoseconds;
  if (Xj(n)) {
    const a = bs(r, t);
    o = ed(qg(t, {
      ...Kv(e, a, {
        ...n,
        ...w8
      }, i),
      ...co(po, a)
    }), s);
  } else
    o = ed(o, s), gr(i);
  return {
    epochNanoseconds: na(o)
  };
}
function QS(t, e, r, n) {
  const [i, s] = Zj(e, r);
  return Qi({
    ...Kv(t, e, {
      ...r,
      ...w8,
      days: r.days + s
    }, n),
    ...i
  });
}
function Kv(t, e, r, n) {
  if (r.years || r.months || r.weeks)
    return t.P(e, r, n);
  gr(n);
  const i = r.days + Nn(r, 5)[0];
  return i ? Fs(zh(e, i)) : e;
}
function $0(t, e, r = 1) {
  return zh(e, r - t.day(e));
}
function Zj(t, e) {
  const [r, n] = Nn(e, 5), [i, s] = Bv(tc(t) + n);
  return [i, r + s];
}
function zh(t, e) {
  return e ? {
    ...t,
    ...Fv(ui(t) + e * Bi)
  } : t;
}
function Yv(t, e, r) {
  const n = t(r.calendar);
  return td(r) ? [r, n, e(r.timeZone)] : [{
    ...r,
    ...Ki
  }, n];
}
function KS(t) {
  return t ? Fj : Rn;
}
function Zv(t) {
  return t ? ir(qS, t) : QS;
}
function YS(t) {
  return t ? ir(fve, t) : gve;
}
function td(t) {
  return t && t.epochNanoseconds;
}
function j0(t, e) {
  return t <= 6 - (td(e) ? 1 : 0);
}
function KI(t, e, r, n, i, s, o) {
  const a = t(ia(o).relativeTo), l = Math.max(bh(i), bh(s));
  if (j0(l, a))
    return bn(Uh(((b, f, E, A) => {
      const x = ed(Nn(b), Nn(f), A ? -1 : 1);
      if (!Number.isFinite(x[0]))
        throw new RangeError(Bc);
      return {
        ...Dn,
        ...Hd(x, E)
      };
    })(i, s, l, n)));
  if (!a)
    throw new RangeError(ib);
  n && (s = bi(s));
  const [c, p, h] = Yv(e, r, a), d = Zv(h), v = YS(h), m = d(p, c, i);
  return bn(v(p, c, d(p, m, s), l));
}
function G2e(t, e, r, n, i) {
  const s = bh(n), [o, a, l, c, p] = ((_, S, R) => {
    _ = Hv(_, Zy);
    let L = tF(_);
    const F = R(_[XB]);
    let z = $S(_);
    const j = em(_, 7);
    let W = Xg(_);
    if (L === void 0 && W === void 0)
      throw new RangeError(Pbe);
    if (W == null && (W = 0), L == null && (L = Math.max(W, S)), Bj(L, W), z = jS(z, W, 1), z > 1 && W > 5 && L !== W)
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    return [L, W, z, j, F];
  })(i, s, t), h = Math.max(s, o);
  if (!p && h <= 6)
    return bn(Uh(((_, S, R, L, F) => {
      const z = qv(Nn(_), R, L, F);
      return {
        ...Dn,
        ...Hd(z, S)
      };
    })(n, o, a, l, c)));
  if (!td(p) && !n.sign)
    return n;
  if (!p)
    throw new RangeError(ib);
  const [d, v, m] = Yv(e, r, p), b = KS(m), f = Zv(m), E = YS(m), A = f(v, d, n);
  td(p) || (Qi(d), Qi(A));
  let x = E(v, d, A, o);
  const g = n.sign, w = Mc(x);
  if (g && w && g !== w)
    throw new RangeError(qd);
  return x = Wv(x, b(A), o, a, l, c, v, d, b, f), bn(x);
}
function W2e(t) {
  return t.sign === -1 ? ZS(t) : t;
}
function ZS(t) {
  return bn(bi(t));
}
function bi(t) {
  const e = {};
  for (const r of wr)
    e[r] = -1 * t[r] || 0;
  return e;
}
function q2e(t) {
  return !t.sign;
}
function Mc(t, e = wr) {
  let r = 0;
  for (const n of e) {
    const i = Math.sign(t[n]);
    if (i) {
      if (r && r !== i)
        throw new RangeError(Cbe);
      r = i;
    }
  }
  return r;
}
function Uh(t) {
  for (const e of Fbe)
    Da(e, t[e], -4294967295, pwe, 1);
  return Jj(Go(Nn(t), Do)), t;
}
function Jj(t) {
  if (!Number.isSafeInteger(t))
    throw new RangeError(_be);
}
function Nn(t, e = 6) {
  return xj(t, e, wr);
}
function Hd(t, e = 6) {
  const [r, n] = t, i = jv(n, e, wr);
  if (i[wr[e]] += r * (Fr / Wo[e]), !Number.isFinite(i[wr[e]]))
    throw new RangeError(Bc);
  return i;
}
function Jv(t, e = 5) {
  return jv(t, e, wr);
}
function Xj(t) {
  return !!Mc(t, KB);
}
function bh(t) {
  let e = 9;
  for (; e > 0 && !t[wr[e]]; e--)
    ;
  return e;
}
function Q2e(t, e) {
  return [t, e];
}
function YI(t) {
  const e = Math.floor(t / T1) * T1;
  return [e, e + T1];
}
function K2e(t) {
  const e = Nc(t = R1(t));
  if (!e)
    throw new RangeError(Ni(t));
  let r;
  if (e.j)
    r = 0;
  else {
    if (!e.offset)
      throw new RangeError(Ni(t));
    r = Vh(e.offset);
  }
  return e.timeZone && r8(e.timeZone, 1), Ja(OS(zv(e), r));
}
function Y2e(t) {
  const e = Nc(Xn(t));
  if (!e)
    throw new RangeError(Ni(t));
  if (e.timeZone)
    return eB(e, e.offset ? Vh(e.offset) : void 0);
  if (e.j)
    throw new RangeError(Ni(t));
  return rB(e);
}
function Z2e(t, e) {
  const r = Nc(Xn(t));
  if (!r || !r.timeZone)
    throw new RangeError(Ni(t));
  const { offset: n } = r, i = n ? Vh(n) : void 0, [, s, o] = Uv(e);
  return eB(r, i, s, o);
}
function Vh(t) {
  const e = r8(t);
  if (e === void 0)
    throw new RangeError(Ni(t));
  return e;
}
function J2e(t) {
  const e = Nc(Xn(t));
  if (!e || e.j)
    throw new RangeError(Ni(t));
  return ho(tB(e));
}
function JS(t, e, r) {
  let n = Nc(Xn(t));
  if (!n || n.j)
    throw new RangeError(Ni(t));
  return e ? n.calendar === ur && (n = n.isoYear === -271821 && n.isoMonth === 4 ? {
    ...n,
    isoDay: 20,
    ...Ki
  } : {
    ...n,
    isoDay: 1,
    ...Ki
  }) : r && n.calendar === ur && (n = {
    ...n,
    isoYear: Aa
  }), Xa(n.C ? tB(n) : rB(n));
}
function X2e(t, e) {
  const r = e8(Xn(e));
  if (r)
    return XS(r), D0(RS(Fh(r)));
  const n = JS(e, 1);
  return D0($0(t(n.calendar), n));
}
function XS(t) {
  if (t.calendar !== ur)
    throw new RangeError(Sa(t.calendar));
}
function eve(t, e) {
  const r = t8(Xn(e));
  if (r)
    return XS(r), Wy(Fh(r));
  const n = JS(e, 0, 1), { calendar: i } = n, s = t(i), [o, a, l] = s.v(n), [c, p] = s.q(o, a), [h, d] = s.G(c, p, l);
  return Wy(Fs(s.V(h, d, l)), i);
}
function tve(t) {
  let e, r = ((n) => {
    const i = bwe.exec(n);
    return i ? (Xv(i[10]), sB(i)) : void 0;
  })(Xn(t));
  if (!r) {
    if (r = Nc(t), !r)
      throw new RangeError(Ni(t));
    if (!r.C)
      throw new RangeError(Ni(t));
    if (r.j)
      throw new RangeError(Sa("Z"));
    XS(r);
  }
  if ((e = e8(t)) && LI(e))
    throw new RangeError(Ni(t));
  if ((e = t8(t)) && LI(e))
    throw new RangeError(Ni(t));
  return sa(zd(r, 1));
}
function rve(t) {
  const e = ((r) => {
    const n = Ewe.exec(r);
    return n ? ((i) => {
      function s(p, h, d) {
        let v = 0, m = 0;
        if (d && ([v, l] = Ea(l, Wo[d])), p !== void 0) {
          if (a)
            throw new RangeError(Sa(p));
          m = ((b) => {
            const f = parseInt(b);
            if (!Number.isFinite(f))
              throw new RangeError(Sa(b));
            return f;
          })(p), o = 1, h && (l = n8(h) * (Wo[d] / Do), a = 1);
        }
        return v + m;
      }
      let o = 0, a = 0, l = 0, c = {
        ...jd(wr, [s(i[2]), s(i[3]), s(i[4]), s(i[5]), s(i[6], i[7], 5), s(i[8], i[9], 4), s(i[10], i[11], 3)]),
        ...jv(l, 2, wr)
      };
      if (!o)
        throw new RangeError(TB(wr));
      return i8(i[1]) < 0 && (c = bi(c)), c;
    })(n) : void 0;
  })(Xn(t));
  if (!e)
    throw new RangeError(Ni(t));
  return bn(Uh(e));
}
function nve(t) {
  const e = Nc(t) || e8(t) || t8(t);
  return e ? e.calendar : t;
}
function ive(t) {
  const e = Nc(t);
  return e && (e.timeZone || e.j && Gh || e.offset) || t;
}
function eB(t, e, r = 0, n = 0) {
  const i = s8(t.timeZone), s = Kt(i);
  let o;
  return zv(t), o = t.C ? Vd(s, t, e, r, n, !s.$, t.j) : nc(s, t), uo(o, i, nb(t.calendar));
}
function tB(t) {
  return nB(Qi(zv(t)));
}
function rB(t) {
  return nB(Fs(Fh(t)));
}
function nB(t) {
  return {
    ...t,
    calendar: nb(t.calendar)
  };
}
function Nc(t) {
  const e = vwe.exec(t);
  return e ? ((r) => {
    const n = r[10], i = (n || "").toUpperCase() === "Z";
    return {
      isoYear: iB(r),
      isoMonth: parseInt(r[4]),
      isoDay: parseInt(r[5]),
      ...sB(r.slice(5)),
      ...Xv(r[16]),
      C: !!r[6],
      j: i,
      offset: i ? void 0 : n
    };
  })(e) : void 0;
}
function e8(t) {
  const e = mwe.exec(t);
  return e ? ((r) => ({
    isoYear: iB(r),
    isoMonth: parseInt(r[4]),
    isoDay: 1,
    ...Xv(r[5])
  }))(e) : void 0;
}
function t8(t) {
  const e = ywe.exec(t);
  return e ? ((r) => ({
    isoYear: Aa,
    isoMonth: parseInt(r[1]),
    isoDay: parseInt(r[2]),
    ...Xv(r[3])
  }))(e) : void 0;
}
function r8(t, e) {
  const r = wwe.exec(t);
  return r ? ((n, i) => {
    const s = n[4] || n[5];
    if (i && s)
      throw new RangeError(Sa(s));
    return ((o) => {
      if (Math.abs(o) >= Fr)
        throw new RangeError(Ebe);
      return o;
    })((Dp(n[2]) * ob + Dp(n[3]) * sb + Dp(n[4]) * Do + n8(n[5] || "")) * i8(n[1]));
  })(r, e) : void 0;
}
function iB(t) {
  const e = i8(t[1]), r = parseInt(t[2] || t[3]);
  if (e < 0 && !r)
    throw new RangeError(Sa(-0));
  return e * r;
}
function sB(t) {
  const e = Dp(t[3]);
  return {
    ...Bv(n8(t[4] || ""))[0],
    isoHour: Dp(t[1]),
    isoMinute: Dp(t[2]),
    isoSecond: e === 60 ? 59 : e
  };
}
function Xv(t) {
  let e, r;
  const n = [];
  if (t.replace(xwe, (i, s, o) => {
    const a = !!s, [l, c] = o.split("=").reverse();
    if (c) {
      if (c === "u-ca")
        n.push(l), e || (e = a);
      else if (a || /[A-Z]/.test(c))
        throw new RangeError(Sa(i));
    } else {
      if (r)
        throw new RangeError(Sa(i));
      r = l;
    }
    return "";
  }), n.length > 1 && e)
    throw new RangeError(Sa(t));
  return {
    timeZone: r,
    calendar: n[0] || ur
  };
}
function n8(t) {
  return parseInt(t.padEnd(9, "0"));
}
function Gd(t) {
  return new RegExp(`^${t}$`, "i");
}
function i8(t) {
  return t && t !== "+" ? -1 : 1;
}
function Dp(t) {
  return t === void 0 ? 0 : parseInt(t);
}
function sve(t) {
  return s8(Xn(t));
}
function s8(t) {
  const e = o8(t);
  return typeof e == "number" ? Wg(e) : e ? ((r) => {
    if (kwe.test(r))
      throw new RangeError($B(r));
    if (Awe.test(r))
      throw new RangeError(xbe);
    return r.toLowerCase().split("/").map((n, i) => (n.length <= 3 || /\d/.test(n)) && !/etc|yap/.test(n) ? n.toUpperCase() : n.replace(/baja|dumont|[a-z]+/g, (s, o) => s.length <= 2 && !i || s === "in" || s === "chat" ? s.toUpperCase() : s.length > 2 || !o ? RI(s).replace(/island|noronha|murdo|rivadavia|urville/, RI) : s)).join("/");
  })(t) : Gh;
}
function ZI(t) {
  const e = o8(t);
  return typeof e == "number" ? e : e ? e.resolvedOptions().timeZone : Gh;
}
function o8(t) {
  const e = r8(t = t.toUpperCase(), 1);
  return e !== void 0 ? e : t !== Gh ? Swe(t) : void 0;
}
function oB(t, e) {
  return ys(t.epochNanoseconds, e.epochNanoseconds);
}
function aB(t, e) {
  return ys(t.epochNanoseconds, e.epochNanoseconds);
}
function ove(t, e, r, n, i, s) {
  const o = t(ia(s).relativeTo), a = Math.max(bh(n), bh(i));
  if (bj(wr, n, i))
    return 0;
  if (j0(a, o))
    return ys(Nn(n), Nn(i));
  if (!o)
    throw new RangeError(ib);
  const [l, c, p] = Yv(e, r, o), h = KS(p), d = Zv(p);
  return ys(h(d(c, l, n)), h(d(c, l, i)));
}
function lB(t, e) {
  return Wd(t, e) || a8(t, e);
}
function Wd(t, e) {
  return Fl(ui(t), ui(e));
}
function a8(t, e) {
  return Fl(tc(t), tc(e));
}
function ave(t, e) {
  return !oB(t, e);
}
function lve(t, e) {
  return !aB(t, e) && !!cB(t.timeZone, e.timeZone) && t.calendar === e.calendar;
}
function cve(t, e) {
  return !lB(t, e) && t.calendar === e.calendar;
}
function uve(t, e) {
  return !Wd(t, e) && t.calendar === e.calendar;
}
function hve(t, e) {
  return !Wd(t, e) && t.calendar === e.calendar;
}
function pve(t, e) {
  return !Wd(t, e) && t.calendar === e.calendar;
}
function dve(t, e) {
  return !a8(t, e);
}
function cB(t, e) {
  if (t === e)
    return 1;
  try {
    return ZI(t) === ZI(e);
  } catch {
  }
}
function JI(t, e, r, n) {
  const i = Ud(t, n, 3, 5), s = eb(e.epochNanoseconds, r.epochNanoseconds, ...i);
  return bn(t ? bi(s) : s);
}
function XI(t, e, r, n, i, s) {
  const o = rb(n.calendar, i.calendar), [a, l, c, p] = Ud(r, s, 5), h = n.epochNanoseconds, d = i.epochNanoseconds, v = ys(d, h);
  let m;
  if (v)
    if (a < 6)
      m = eb(h, d, a, l, c, p);
    else {
      const b = e(((E, A) => {
        if (!cB(E, A))
          throw new RangeError(jB);
        return E;
      })(n.timeZone, i.timeZone)), f = t(o);
      m = hB(f, b, n, i, v, a, s), m = Wv(m, d, a, l, c, p, f, n, Fj, ir(qS, b));
    }
  else
    m = Dn;
  return bn(r ? bi(m) : m);
}
function eP(t, e, r, n, i) {
  const s = rb(r.calendar, n.calendar), [o, a, l, c] = Ud(e, i, 6), p = Rn(r), h = Rn(n), d = ys(h, p);
  let v;
  if (d)
    if (o <= 6)
      v = eb(p, h, o, a, l, c);
    else {
      const m = t(s);
      v = pB(m, r, n, d, o, i), v = Wv(v, h, o, a, l, c, m, r, Rn, QS);
    }
  else
    v = Dn;
  return bn(e ? bi(v) : v);
}
function tP(t, e, r, n, i) {
  const s = rb(r.calendar, n.calendar);
  return uB(e, () => t(s), r, n, ...Ud(e, i, 6, 9, 6));
}
function rP(t, e, r, n, i) {
  const s = rb(r.calendar, n.calendar), o = Ud(e, i, 9, 9, 8), a = t(s), l = $0(a, r), c = $0(a, n);
  return l.isoYear === c.isoYear && l.isoMonth === c.isoMonth && l.isoDay === c.isoDay ? bn(Dn) : uB(e, () => a, Fs(l), Fs(c), ...o, 8);
}
function uB(t, e, r, n, i, s, o, a, l = 6) {
  const c = Rn(r), p = Rn(n);
  if (c === void 0 || p === void 0)
    throw new RangeError(Bc);
  let h;
  if (ys(p, c))
    if (i === 6)
      h = eb(c, p, i, s, o, a);
    else {
      const d = e();
      h = d.N(r, n, i), s === l && o === 1 || (h = Wv(h, p, i, s, o, a, d, r, Rn, Kv));
    }
  else
    h = Dn;
  return bn(t ? bi(h) : h);
}
function nP(t, e, r, n) {
  const [i, s, o, a] = Ud(t, n, 5, 5), l = rc(l8(e, r), Gg(s, o), a), c = {
    ...Dn,
    ...Jv(l, i)
  };
  return bn(t ? bi(c) : c);
}
function fve(t, e, r, n, i, s) {
  const o = ys(n.epochNanoseconds, r.epochNanoseconds);
  return o ? i < 6 ? dB(r.epochNanoseconds, n.epochNanoseconds, i) : hB(e, t, r, n, o, i, s) : Dn;
}
function gve(t, e, r, n, i) {
  const s = Rn(e), o = Rn(r), a = ys(o, s);
  return a ? n <= 6 ? dB(s, o, n) : pB(t, e, r, a, n, i) : Dn;
}
function hB(t, e, r, n, i, s, o) {
  const [a, l, c] = ((d, v, m, b) => {
    function f() {
      return S = {
        ...zh(x, w++ * -b),
        ...A
      }, R = qg(d, S), ys(g, R) === -b;
    }
    const E = bs(v, d), A = co(po, E), x = bs(m, d), g = m.epochNanoseconds;
    let w = 0;
    const _ = l8(E, x);
    let S, R;
    if (Math.sign(_) === -b && w++, f() && (b === -1 || f()))
      throw new RangeError(qd);
    const L = Go(Ho(R, g));
    return [E, S, L];
  })(e, r, n, i);
  var p, h;
  return {
    ...s === 6 ? (p = a, h = l, {
      ...Dn,
      days: fB(p, h)
    }) : t.N(a, l, s, o),
    ...Jv(c)
  };
}
function pB(t, e, r, n, i, s) {
  const [o, a, l] = ((c, p, h) => {
    let d = p, v = l8(c, p);
    return Math.sign(v) === -h && (d = zh(p, -h), v += Fr * h), [c, d, v];
  })(e, r, n);
  return {
    ...t.N(o, a, i, s),
    ...Jv(l)
  };
}
function eb(t, e, r, n, i, s) {
  return {
    ...Dn,
    ...Hd(qv(Ho(t, e), n, i, s), r)
  };
}
function dB(t, e, r) {
  return {
    ...Dn,
    ...Hd(Ho(t, e), r)
  };
}
function fB(t, e) {
  return tb(ui(t), ui(e));
}
function tb(t, e) {
  return Math.trunc((e - t) / Bi);
}
function l8(t, e) {
  return tc(e) - tc(t);
}
function rb(t, e) {
  if (t !== e)
    throw new RangeError(DB);
  return t;
}
function gB(t) {
  return this.m(t)[0];
}
function mB(t) {
  return this.m(t)[1];
}
function c8(t) {
  const [e] = this.v(t);
  return tb(this.p(e), ui(t)) + 1;
}
function u8(t) {
  const e = _we.exec(t);
  if (!e)
    throw new RangeError(bbe(t));
  return [parseInt(e[1]), !!e[2]];
}
function Qg(t, e) {
  return "M" + zs(t) + (e ? "L" : "");
}
function Ky(t, e, r) {
  return t + (e || r && t >= r ? 1 : 0);
}
function h8(t, e) {
  return t - (e && t >= e ? 1 : 0);
}
function yB(t, e) {
  return (e + t) * (Math.sign(e) || 1) || 0;
}
function w4(t) {
  return qB[bB(t)];
}
function vB(t) {
  return Dbe[bB(t)];
}
function bB(t) {
  return wh(t.id || ur);
}
function mve(t) {
  function e(i) {
    return ((s, o) => ({
      ...wB(s, o),
      o: s.month,
      day: parseInt(s.day)
    }))(TS(r, i), n);
  }
  const r = L8(t), n = wh(t);
  return {
    id: t,
    h: yve(e),
    l: vve(e)
  };
}
function yve(t) {
  return ms((e) => {
    const r = ui(e);
    return t(r);
  }, WeakMap);
}
function vve(t) {
  const e = t(0).year - qbe;
  return ms((r) => {
    let n, i = Bd(r - e), s = 0;
    const o = [], a = [];
    do
      i += 400 * Bi;
    while ((n = t(i)).year <= r);
    do
      if (i += (1 - n.day) * Bi, n.year === r && (o.push(i), a.push(n.o)), i -= Bi, ++s > 100 || i < -864e13)
        throw new RangeError(qd);
    while ((n = t(i)).year >= r);
    return {
      i: o.reverse(),
      u: BB(a.reverse())
    };
  });
}
function wB(t, e) {
  let r, n, i = xB(t);
  if (t.era) {
    const s = qB[e], o = QB[e] || {};
    s !== void 0 && (r = e === "islamic" ? "ah" : t.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), r === "bc" || r === "b" ? r = "bce" : r === "ad" || r === "a" ? r = "ce" : r === "beforeroc" && (r = "broc"), r = o[r] || r, n = i, i = yB(n, s[r] || 0));
  }
  return {
    era: r,
    eraYear: n,
    year: i
  };
}
function xB(t) {
  return parseInt(t.relatedYear || t.year);
}
function Yy(t) {
  const { year: e, o: r, day: n } = this.h(t), { u: i } = this.l(e);
  return [e, i[r] + 1, n];
}
function B0(t, e = 1, r = 1) {
  return this.l(t).i[e - 1] + (r - 1) * Bi;
}
function EB(t, e) {
  const r = O1.call(this, t);
  return [h8(e, r), r === e];
}
function O1(t) {
  const e = sP(this, t), r = sP(this, t - 1), n = e.length;
  if (n > r.length) {
    const i = vB(this);
    if (i < 0)
      return -i;
    for (let s = 0; s < n; s++)
      if (e[s] !== r[s])
        return s + 1;
  }
}
function Wm(t) {
  return tb(B0.call(this, t), B0.call(this, t + 1));
}
function iP(t, e) {
  const { i: r } = this.l(t);
  let n = e + 1, i = r;
  return n > r.length && (n = 1, i = this.l(t + 1).i), tb(r[e - 1], i[n - 1]);
}
function qm(t) {
  return this.l(t).i.length;
}
function SB(t) {
  const e = this.h(t);
  return [e.era, e.eraYear];
}
function sP(t, e) {
  return Object.keys(t.l(e).u);
}
function Kg(t) {
  return nb(Xn(t));
}
function nb(t) {
  if ((t = t.toLowerCase()) !== ur && t !== Qd) {
    const e = L8(t).resolvedOptions().calendar;
    if (wh(t) !== wh(e))
      throw new RangeError(NB(t));
    return e;
  }
  return t;
}
function wh(t) {
  return t === "islamicc" && (t = "islamic"), t.split("-")[0];
}
function AB(t, e) {
  return (r) => r === ur ? t : r === Qd || r === ic ? Object.assign(Object.create(t), {
    id: r
  }) : Object.assign(Object.create(e), Cwe(r));
}
function bve(t, e, r, n) {
  const i = Dc(r, n, rl, [], VB);
  if (i.timeZone !== void 0) {
    const s = r.F(i), o = Yg(i), a = t(i.timeZone);
    return {
      epochNanoseconds: Vd(e(a), {
        ...s,
        ...o
      }, i.offset !== void 0 ? Vh(i.offset) : void 0),
      timeZone: a
    };
  }
  return {
    ...r.F(i),
    ...Ki
  };
}
function wve(t, e, r, n, i, s) {
  const o = Dc(r, i, rl, zB, VB), a = t(o.timeZone), [l, c, p] = Uv(s), h = r.F(o, Gv(l)), d = Yg(o, l);
  return uo(Vd(e(a), {
    ...h,
    ...d
  }, o.offset !== void 0 ? Vh(o.offset) : void 0, c, p), a, n);
}
function xve(t, e, r) {
  const n = Dc(t, e, rl, [], tl), i = gr(r);
  return ho(Qi({
    ...t.F(n, Gv(i)),
    ...Yg(n, i)
  }));
}
function Eve(t, e, r, n = []) {
  const i = Dc(t, e, rl, n);
  return t.F(i, r);
}
function Sve(t, e, r, n) {
  const i = Dc(t, e, v8, n);
  return t.K(i, r);
}
function Ave(t, e, r, n) {
  const i = Dc(t, r, rl, Jg);
  return e && i.month !== void 0 && i.monthCode === void 0 && i.year === void 0 && (i.year = Aa), t._(i, n);
}
function kve(t, e) {
  return sa(Yg(vs(t, A4, [], 1), gr(e)));
}
function _ve(t) {
  const e = vs(t, b8);
  return bn(Uh({
    ...Dn,
    ...e
  }));
}
function Dc(t, e, r, n = [], i = []) {
  return vs(e, [...t.fields(r), ...i].sort(), n);
}
function vs(t, e, r, n = !r) {
  const i = {};
  let s, o = 0;
  for (const a of e) {
    if (a === s)
      throw new RangeError(hbe(a));
    if (a === "constructor" || a === "__proto__")
      throw new RangeError(ube(a));
    let l = t[a];
    if (l !== void 0)
      o = 1, oP[a] && (l = oP[a](l, a)), i[a] = l;
    else if (r) {
      if (r.includes(a))
        throw new TypeError(d8(a));
      i[a] = WB[a];
    }
    s = a;
  }
  if (n && !o)
    throw new TypeError(TB(e));
  return i;
}
function Yg(t, e) {
  return zd(M8({
    ...WB,
    ...t
  }), e);
}
function Cve(t, e, r, n, i) {
  const { calendar: s, timeZone: o } = r, a = t(s), l = e(o), c = [...a.fields(rl), ...UB].sort(), p = ((E) => {
    const A = bs(E, Kt), x = Wg(A.offsetNanoseconds), g = cb(E.calendar), [w, _, S] = g.v(A), [R, L] = g.q(w, _), F = Qg(R, L);
    return {
      ...Nwe(A),
      year: w,
      monthCode: F,
      day: S,
      offset: x
    };
  })(r), h = vs(n, c), d = a.k(p, h), v = {
    ...p,
    ...h
  }, [m, b, f] = Uv(i, 2);
  return uo(Vd(l, {
    ...a.F(d, Gv(m)),
    ...zd(M8(v), m)
  }, Vh(v.offset), b, f), o, s);
}
function Ive(t, e, r, n) {
  const i = t(e.calendar), s = [...i.fields(rl), ...tl].sort(), o = {
    ..._B(a = e),
    hour: a.isoHour,
    minute: a.isoMinute,
    second: a.isoSecond,
    millisecond: a.isoMillisecond,
    microsecond: a.isoMicrosecond,
    nanosecond: a.isoNanosecond
  };
  var a;
  const l = vs(r, s), c = gr(n), p = i.k(o, l), h = {
    ...o,
    ...l
  };
  return ho(Qi({
    ...i.F(p, Gv(c)),
    ...zd(M8(h), c)
  }));
}
function Pve(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(rl).sort(), o = _B(e), a = vs(r, s), l = i.k(o, a);
  return i.F(l, n);
}
function Rve(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(v8).sort(), o = ((c) => {
    const p = cb(c.calendar), [h, d] = p.v(c), [v, m] = p.q(h, d);
    return {
      year: h,
      monthCode: Qg(v, m)
    };
  })(e), a = vs(r, s), l = i.k(o, a);
  return i.K(l, n);
}
function Ove(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(rl).sort(), o = ((c) => {
    const p = cb(c.calendar), [h, d, v] = p.v(c), [m, b] = p.q(h, d);
    return {
      monthCode: Qg(m, b),
      day: v
    };
  })(e), a = vs(r, s), l = i.k(o, a);
  return i._(l, n);
}
function Tve(t, e, r) {
  return sa(((n, i, s) => Yg({
    ...co(A4, n),
    ...vs(i, A4)
  }, gr(s)))(t, e, r));
}
function Lve(t, e) {
  return bn((r = t, n = e, Uh({
    ...r,
    ...vs(n, b8)
  })));
  var r, n;
}
function kB(t, e, r, n, i) {
  e = co(r = t.fields(r), e), n = vs(n, i = t.fields(i), []);
  let s = t.k(e, n);
  return s = vs(s, [...r, ...i].sort(), []), t.F(s);
}
function L3(t, e) {
  const r = w4(t), n = QB[t.id || ""] || {};
  let { era: i, eraYear: s, year: o } = e;
  if (i !== void 0 || s !== void 0) {
    if (i === void 0 || s === void 0)
      throw new TypeError(gbe);
    if (!r)
      throw new RangeError(fbe);
    const a = r[n[i] || i];
    if (a === void 0)
      throw new RangeError(ybe(i));
    const l = yB(s, a);
    if (o !== void 0 && o !== l)
      throw new RangeError(mbe);
    o = l;
  } else if (o === void 0)
    throw new TypeError(vbe(r));
  return o;
}
function Qm(t, e, r, n) {
  let { month: i, monthCode: s } = e;
  if (s !== void 0) {
    const o = ((a, l, c, p) => {
      const h = a.L(c), [d, v] = u8(l);
      let m = Ky(d, v, h);
      if (v) {
        const b = vB(a);
        if (b === void 0)
          throw new RangeError(Sf);
        if (b > 0) {
          if (m > b)
            throw new RangeError(Sf);
          if (h === void 0) {
            if (p === 1)
              throw new RangeError(Sf);
            m--;
          }
        } else {
          if (m !== -b)
            throw new RangeError(Sf);
          if (h === void 0 && p === 1)
            throw new RangeError(Sf);
        }
      }
      return m;
    })(t, s, r, n);
    if (i !== void 0 && i !== o)
      throw new RangeError(wbe);
    i = o, n = 1;
  } else if (i === void 0)
    throw new TypeError(MB);
  return Da("month", i, 1, t.B(r), n);
}
function M3(t, e, r, n, i) {
  return Ti(e, "day", 1, t.U(n, r), i);
}
function N3(t, e, r, n) {
  let i = 0;
  const s = [];
  for (const o of r)
    e[o] !== void 0 ? i = 1 : s.push(o);
  if (Object.assign(t, e), i)
    for (const o of n || s)
      delete t[o];
}
function _B(t) {
  const e = cb(t.calendar), [r, n, i] = e.v(t), [s, o] = e.q(r, n);
  return {
    year: r,
    monthCode: Qg(s, o),
    day: i
  };
}
function Mve(t) {
  return Ja(na(IS(kS(t))));
}
function Nve(t, e, r, n, i = ur) {
  return uo(na(IS(kS(r))), e(n), t(i));
}
function Dve(t, e, r, n, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, p = ur) {
  return ho(Qi(zv($a(si, jd(ab, [e, r, n, i, s, o, a, l, c])))), t(p));
}
function $ve(t, e, r, n, i = ur) {
  return Xa(Fs(Fh($a(si, {
    isoYear: e,
    isoMonth: r,
    isoDay: n
  }))), t(i));
}
function jve(t, e, r, n = ur, i = 1) {
  const s = si(e), o = si(r), a = t(n);
  return D0(RS(Fh({
    isoYear: s,
    isoMonth: o,
    isoDay: si(i)
  })), a);
}
function Bve(t, e, r, n = ur, i = Aa) {
  const s = si(e), o = si(r), a = t(n);
  return Wy(Fs(Fh({
    isoYear: si(i),
    isoMonth: s,
    isoDay: o
  })), a);
}
function Fve(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0) {
  return sa(zd($a(si, jd(po, [t, e, r, n, i, s])), 1));
}
function zve(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0) {
  return bn(Uh($a(_S, jd(wr, [t, e, r, n, i, s, o, a, l, c]))));
}
function Uve(t, e, r = ur) {
  return uo(t.epochNanoseconds, e, r);
}
function Vve(t) {
  return Ja(t.epochNanoseconds);
}
function CB(t, e) {
  return ho(bs(e, t));
}
function IB(t, e) {
  return Xa(bs(e, t));
}
function PB(t, e) {
  return sa(bs(e, t));
}
function Hve(t, e, r, n) {
  const i = ((s, o, a, l) => {
    const c = ((p) => nF(ia(p)))(l);
    return qg(s(o), a, c);
  })(t, r, e, n);
  return uo(na(i), r, e.calendar);
}
function Gve(t, e, r, n, i) {
  const s = t(i.timeZone), o = i.plainTime, a = o !== void 0 ? e(o) : void 0, l = r(s);
  let c;
  return c = a ? qg(l, {
    ...n,
    ...a
  }) : nc(l, {
    ...n,
    ...Ki
  }), uo(c, s, n.calendar);
}
function Wve(t, e = Ki) {
  return ho(Qi({
    ...t,
    ...e
  }));
}
function qve(t, e, r) {
  return ((n, i) => {
    const s = Dc(n, i, HB);
    return n.K(s, void 0);
  })(t(e.calendar), r);
}
function Qve(t, e, r) {
  return ((n, i) => {
    const s = Dc(n, i, GB);
    return n._(s);
  })(t(e.calendar), r);
}
function Kve(t, e, r, n) {
  return ((i, s, o) => kB(i, s, HB, Hg(o), Jg))(t(e.calendar), r, n);
}
function Yve(t, e, r, n) {
  return ((i, s, o) => kB(i, s, GB, Hg(o), g8))(t(e.calendar), r, n);
}
function Zve(t) {
  return Ja(na(Hy(_S(t), el)));
}
function Jve(t) {
  return Ja(na(IS(kS(t))));
}
function Hh(t, e, r) {
  const n = new Set(r);
  return (i, s) => {
    const o = r && PI(i, r);
    if (!PI(i = ((a, l) => {
      const c = {};
      for (const p in l)
        a.has(p) || (c[p] = l[p]);
      return c;
    })(n, i), t)) {
      if (s && o)
        throw new TypeError("Invalid formatting options");
      i = {
        ...e,
        ...i
      };
    }
    return r && (i.timeZone = Gh, ["full", "long"].includes(i.J) && (i.J = "medium")), i;
  };
}
function $c(t, e = RB, r = 0) {
  const [n, , , i] = t;
  return (s, o = e3e, ...a) => {
    const l = e(i && i(...a), s, o, n, r), c = l.resolvedOptions();
    return [l, ...Xve(t, c, a)];
  };
}
function RB(t, e, r, n, i) {
  if (r = n(r, i), t) {
    if (r.timeZone !== void 0)
      throw new TypeError(Tbe);
    r.timeZone = t;
  }
  return new zl(e, r);
}
function Xve(t, e, r) {
  const [, n, i] = t;
  return r.map((s) => (s.calendar && ((o, a, l) => {
    if ((l || o !== ur) && o !== a)
      throw new RangeError(DB);
  })(s.calendar, e.calendar, i), n(s, e)));
}
function ebe(t, e, r) {
  const n = e.timeZone, i = t(n), s = {
    ...bs(e, i),
    ...r || Ki
  };
  let o;
  return o = r ? Vd(i, s, s.offsetNanoseconds, 2) : nc(i, s), uo(o, n, e.calendar);
}
function tbe(t, e = Ki) {
  return ho(Qi({
    ...t,
    ...e
  }));
}
function p8(t, e) {
  return {
    ...t,
    calendar: e
  };
}
function rbe(t, e) {
  return {
    ...t,
    timeZone: e
  };
}
function D3(t) {
  const e = x4();
  return Fd(e, t.R(e));
}
function x4() {
  return Hy(Date.now(), el);
}
function Ef() {
  return aP || (aP = new zl().resolvedOptions().timeZone);
}
const nbe = (t, e) => `Non-integer ${t}: ${e}`, ibe = (t, e) => `Non-positive ${t}: ${e}`, sbe = (t, e) => `Non-finite ${t}: ${e}`, obe = (t) => `Cannot convert bigint to ${t}`, abe = (t) => `Invalid bigint: ${t}`, lbe = "Cannot convert Symbol to string", cbe = "Invalid object", OB = (t, e, r, n, i) => i ? OB(t, i[e], i[r], i[n]) : jc(t, e) + `; must be between ${r}-${n}`, jc = (t, e) => `Invalid ${t}: ${e}`, d8 = (t) => `Missing ${t}`, ube = (t) => `Invalid field ${t}`, hbe = (t) => `Duplicate field ${t}`, TB = (t) => "No valid fields: " + t.join(), pbe = "Invalid bag", LB = (t, e, r) => jc(t, e) + "; must be " + Object.keys(r).join(), dbe = "Cannot use valueOf", E4 = "Invalid calling context", fbe = "Forbidden era/eraYear", gbe = "Mismatching era/eraYear", mbe = "Mismatching year/eraYear", ybe = (t) => `Invalid era: ${t}`, vbe = (t) => "Missing year" + (t ? "/era/eraYear" : ""), bbe = (t) => `Invalid monthCode: ${t}`, wbe = "Mismatching month/monthCode", MB = "Missing month/monthCode", Sf = "Invalid leap month", qd = "Invalid protocol results", NB = (t) => jc("Calendar", t), DB = "Mismatching Calendars", $B = (t) => jc("TimeZone", t), jB = "Mismatching TimeZones", xbe = "Forbidden ICU TimeZone", Ebe = "Out-of-bounds offset", Sbe = "Out-of-bounds TimeZone gap", Abe = "Invalid TimeZone offset", kbe = "Ambiguous offset", Bc = "Out-of-bounds date", _be = "Out-of-bounds duration", Cbe = "Cannot mix duration signs", ib = "Missing relativeTo", Ibe = "Cannot use large units", Pbe = "Required smallestUnit or largestUnit", Rbe = "smallestUnit > largestUnit", Ni = (t) => `Cannot parse: ${t}`, Sa = (t) => `Invalid substring: ${t}`, Obe = (t) => `Cannot format ${t}`, $3 = "Mismatching types for formatting", Tbe = "Cannot specify TimeZone", BB = /* @__PURE__ */ ir(Dv, (t, e) => e), rd = /* @__PURE__ */ ir(Dv, (t, e, r) => r), zs = /* @__PURE__ */ ir(Vy, 2), S4 = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, f8 = /* @__PURE__ */ Object.keys(S4), Bi = 864e5, FB = 1e3, Zg = 1e3, el = 1e6, Do = 1e9, sb = 6e10, ob = 36e11, Fr = 864e11, Wo = [1, Zg, el, Do, sb, ob, Fr], tl = /* @__PURE__ */ f8.slice(0, 6), A4 = /* @__PURE__ */ Vg(tl), Lbe = ["offset"], zB = ["timeZone"], UB = /* @__PURE__ */ tl.concat(Lbe), VB = /* @__PURE__ */ UB.concat(zB), k4 = ["era", "eraYear"], Mbe = /* @__PURE__ */ k4.concat(["year"]), g8 = ["year"], m8 = ["monthCode"], y8 = /* @__PURE__ */ ["month"].concat(m8), Jg = ["day"], v8 = /* @__PURE__ */ y8.concat(g8), HB = /* @__PURE__ */ m8.concat(g8), rl = /* @__PURE__ */ Jg.concat(v8), Nbe = /* @__PURE__ */ Jg.concat(y8), GB = /* @__PURE__ */ Jg.concat(m8), WB = /* @__PURE__ */ rd(tl, 0), ur = "iso8601", Qd = "gregory", ic = "japanese", qB = {
  [Qd]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [ic]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, QB = {
  [Qd]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [ic]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
}, Dbe = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, Xn = /* @__PURE__ */ ir(SS, "string"), $be = /* @__PURE__ */ ir(SS, "boolean"), jbe = /* @__PURE__ */ ir(SS, "number"), wr = /* @__PURE__ */ f8.map((t) => t + "s"), b8 = /* @__PURE__ */ Vg(wr), Bbe = /* @__PURE__ */ wr.slice(0, 6), KB = /* @__PURE__ */ wr.slice(6), Fbe = /* @__PURE__ */ KB.slice(1), zbe = /* @__PURE__ */ BB(wr), Dn = /* @__PURE__ */ rd(wr, 0), w8 = /* @__PURE__ */ rd(Bbe, 0), x8 = /* @__PURE__ */ ir(wj, wr), po = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"], E8 = ["isoDay", "isoMonth", "isoYear"], ab = /* @__PURE__ */ po.concat(E8), S8 = /* @__PURE__ */ Vg(E8), YB = /* @__PURE__ */ Vg(po), Ube = /* @__PURE__ */ Vg(ab), Ki = /* @__PURE__ */ rd(YB, 0), Vbe = /* @__PURE__ */ ir(wj, ab), ZB = 1e8, Hbe = ZB * Bi, Gbe = [ZB, 0], Wbe = [-1e8, 0], F0 = 275760, z0 = -271821, zl = Intl.DateTimeFormat, JB = "en-GB", qbe = 1970, Aa = 1972, gl = 12, Qbe = /* @__PURE__ */ Bd(1868, 9, 8), Kbe = /* @__PURE__ */ ms(P2e, WeakMap), Zy = "smallestUnit", _4 = "unit", Xf = "roundingIncrement", j3 = "fractionalSecondDigits", XB = "relativeTo", B3 = "direction", eF = {
  constrain: 0,
  reject: 1
}, Ybe = /* @__PURE__ */ Object.keys(eF), Zbe = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}, Jbe = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}, Xbe = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}, ewe = {
  auto: 0,
  never: 1,
  critical: 2
}, twe = {
  auto: 0,
  never: 1
}, rwe = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}, nwe = {
  previous: -1,
  next: 1
}, Xg = /* @__PURE__ */ ir(BS, Zy), tF = /* @__PURE__ */ ir(BS, "largestUnit"), iwe = /* @__PURE__ */ ir(BS, _4), rF = /* @__PURE__ */ ir(Lc, "overflow", eF), nF = /* @__PURE__ */ ir(Lc, "disambiguation", Zbe), swe = /* @__PURE__ */ ir(Lc, "offset", Jbe), A8 = /* @__PURE__ */ ir(Lc, "calendarName", Xbe), owe = /* @__PURE__ */ ir(Lc, "timeZoneName", ewe), awe = /* @__PURE__ */ ir(Lc, "offset", twe), em = /* @__PURE__ */ ir(Lc, "roundingMode", rwe), k8 = "PlainYearMonth", _8 = "PlainMonthDay", tm = "PlainDate", Kd = "PlainDateTime", C8 = "PlainTime", Fc = "ZonedDateTime", I8 = "Instant", P8 = "Duration", lwe = [Math.floor, (t) => Gm(t) ? Math.floor(t) : Math.round(t), Math.ceil, (t) => Gm(t) ? Math.ceil(t) : Math.round(t), Math.trunc, (t) => Gm(t) ? Math.trunc(t) || 0 : Math.round(t), (t) => t < 0 ? Math.floor(t) : Math.ceil(t), (t) => Math.sign(t) * Math.round(Math.abs(t)) || 0, (t) => Gm(t) ? (t = Math.trunc(t) || 0) + t % 2 : Math.round(t)], Gh = "UTC", T1 = 5184e3, cwe = /* @__PURE__ */ Gy(1847), uwe = /* @__PURE__ */ Gy(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10), hwe = /0+$/, bs = /* @__PURE__ */ ms(H2e, WeakMap), pwe = 2 ** 32 - 1, Kt = /* @__PURE__ */ ms((t) => {
  const e = o8(t);
  return typeof e == "object" ? new fwe(e) : new dwe(e || 0);
});
class dwe {
  constructor(e) {
    this.$ = e;
  }
  R() {
    return this.$;
  }
  I(e) {
    return ((r) => {
      const n = Rn({
        ...r,
        ...Ki
      });
      if (!n || Math.abs(n[0]) > 1e8)
        throw new RangeError(Bc);
    })(e), [OS(e, this.$)];
  }
  O() {
  }
}
class fwe {
  constructor(e) {
    this.nn = ((r) => {
      function n(c) {
        const p = N0(c, a, l), [h, d] = YI(p), v = s(h), m = s(d);
        return v === m ? v : i(o(h, d), v, m, c);
      }
      function i(c, p, h, d) {
        let v, m;
        for (; (d === void 0 || (v = d < c[0] ? p : d >= c[1] ? h : void 0) === void 0) && (m = c[1] - c[0]); ) {
          const b = c[0] + Math.floor(m / 2);
          r(b) === h ? c[1] = b : c[0] = b + 1;
        }
        return v;
      }
      const s = ms(r), o = ms(Q2e);
      let a = cwe, l = uwe;
      return {
        tn(c) {
          const p = n(c - 86400), h = n(c + 86400), d = c - p, v = c - h;
          if (p === h)
            return [d];
          const m = n(d);
          return m === n(v) ? [c - m] : p > h ? [d, v] : [];
        },
        rn: n,
        O(c, p) {
          const h = N0(c, a, l);
          let [d, v] = YI(h);
          const m = T1 * p, b = p < 0 ? () => v > a || (a = h, 0) : () => d < l || (l = h, 0);
          for (; b(); ) {
            const f = s(d), E = s(v);
            if (f !== E) {
              const A = o(d, v);
              i(A, f, E);
              const x = A[0];
              if ((Fl(x, c) || 1) === p)
                return x;
            }
            d += m, v += m;
          }
        }
      };
    })(/* @__PURE__ */ ((r) => (n) => {
      const i = TS(r, n * FB);
      return Gy(xB(i), parseInt(i.month), parseInt(i.day), parseInt(i.hour), parseInt(i.minute), parseInt(i.second)) - n;
    })(e));
  }
  R(e) {
    return this.nn.rn(((r) => TI(r)[0])(e)) * Do;
  }
  I(e) {
    const [r, n] = [Gy((i = e).isoYear, i.isoMonth, i.isoDay, i.isoHour, i.isoMinute, i.isoSecond), i.isoMillisecond * el + i.isoMicrosecond * Zg + i.isoNanosecond];
    var i;
    return this.nn.tn(r).map((s) => na(vh(Hy(s, Do), n)));
  }
  O(e, r) {
    const [n, i] = TI(e), s = this.nn.O(n + (r > 0 || i ? 1 : 0), r);
    if (s !== void 0)
      return Hy(s, Do);
  }
}
const R8 = "([+-])", L1 = "(?:[.,](\\d{1,9}))?", iF = `(?:(?:${R8}(\\d{6}))|(\\d{4}))-?(\\d{2})`, O8 = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + L1 + ")?)?", T8 = R8 + O8, gwe = iF + "-?(\\d{2})(?:[T ]" + O8 + "(Z|" + T8 + ")?)?", sF = "\\[(!?)([^\\]]*)\\]", lb = `((?:${sF}){0,9})`, mwe = /* @__PURE__ */ Gd(iF + lb), ywe = /* @__PURE__ */ Gd("(?:--)?(\\d{2})-?(\\d{2})" + lb), vwe = /* @__PURE__ */ Gd(gwe + lb), bwe = /* @__PURE__ */ Gd("T?" + O8 + "(?:" + T8 + ")?" + lb), wwe = /* @__PURE__ */ Gd(T8), xwe = /* @__PURE__ */ new RegExp(sF, "g"), Ewe = /* @__PURE__ */ Gd(`${R8}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${L1}H)?(?:(\\d+)${L1}M)?(?:(\\d+)${L1}S)?)?`), Swe = /* @__PURE__ */ ms((t) => new zl(JB, {
  timeZone: t,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
})), Awe = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, kwe = /[^\w\/:+-]+/, _we = /^M(\d{2})(L?)$/, Cwe = /* @__PURE__ */ ms(mve), L8 = /* @__PURE__ */ ms((t) => new zl(JB, {
  calendar: t,
  timeZone: Gh,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
})), oF = {
  P(t, e, r) {
    const n = gr(r);
    let i, { years: s, months: o, weeks: a, days: l } = e;
    if (l += Nn(e, 5)[0], s || o)
      i = ((c, p, h, d, v) => {
        let [m, b, f] = c.v(p);
        if (h) {
          const [E, A] = c.q(m, b);
          m += h, b = Ky(E, A, c.L(m)), b = Da("month", b, 1, c.B(m), v);
        }
        return d && ([m, b] = c.un(m, b, d)), f = Da("day", f, 1, c.U(m, b), v), c.p(m, b, f);
      })(this, t, s, o, n);
    else {
      if (!a && !l)
        return t;
      i = ui(t);
    }
    if (i === void 0)
      throw new RangeError(Bc);
    return i += (7 * a + l) * Bi, Fs(Fv(i));
  },
  N(t, e, r) {
    if (r <= 7) {
      let l = 0, c = fB({
        ...t,
        ...Ki
      }, {
        ...e,
        ...Ki
      });
      return r === 7 && ([l, c] = ec(c, 7)), {
        ...Dn,
        weeks: l,
        days: c
      };
    }
    const n = this.v(t), i = this.v(e);
    let [s, o, a] = ((l, c, p, h, d, v, m) => {
      let b = d - c, f = v - p, E = m - h;
      if (b || f) {
        const A = Math.sign(b || f);
        let x = l.U(d, v), g = 0;
        if (Math.sign(E) === -A) {
          const w = x;
          [d, v] = l.un(d, v, -A), b = d - c, f = v - p, x = l.U(d, v), g = A < 0 ? -w : x;
        }
        if (E = m - Math.min(h, x) + g, b) {
          const [w, _] = l.q(c, p), [S, R] = l.q(d, v);
          if (f = S - w || Number(R) - Number(_), Math.sign(f) === -A) {
            const L = A < 0 && -l.B(d);
            b = (d -= A) - c, f = v - Ky(w, _, l.L(d)) + (L || l.B(d));
          }
        }
      }
      return [b, f, E];
    })(this, ...n, ...i);
    return r === 8 && (o += this.cn(s, n[0]), s = 0), {
      ...Dn,
      years: s,
      months: o,
      days: a
    };
  },
  F(t, e) {
    const r = gr(e), n = L3(this, t), i = Qm(this, t, n, r), s = M3(this, t, i, n, r);
    return Xa(Fs(this.V(n, i, s)), this.id || ur);
  },
  K(t, e) {
    const r = gr(e), n = L3(this, t), i = Qm(this, t, n, r);
    return D0(RS(this.V(n, i, 1)), this.id || ur);
  },
  _(t, e) {
    const r = gr(e);
    let n, i, s, o = t.eraYear !== void 0 || t.year !== void 0 ? L3(this, t) : void 0;
    const a = !this.id;
    if (o === void 0 && a && (o = Aa), o !== void 0) {
      const h = Qm(this, t, o, r);
      n = M3(this, t, h, o, r);
      const d = this.L(o);
      i = h8(h, d), s = h === d;
    } else {
      if (t.monthCode === void 0)
        throw new TypeError(MB);
      if ([i, s] = u8(t.monthCode), this.id && this.id !== Qd && this.id !== ic)
        if (this.id && wh(this.id) === "coptic" && r === 0) {
          const h = s || i !== 13 ? 30 : 6;
          n = t.day, n = N0(n, 1, h);
        } else if (this.id && wh(this.id) === "chinese" && r === 0) {
          const h = !s || i !== 1 && i !== 9 && i !== 10 && i !== 11 && i !== 12 ? 30 : 29;
          n = t.day, n = N0(n, 1, h);
        } else
          n = t.day;
      else
        n = M3(this, t, Qm(this, t, Aa, r), Aa, r);
    }
    const l = this.G(i, s, n);
    if (!l)
      throw new RangeError("Cannot guess year");
    const [c, p] = l;
    return Wy(Fs(this.V(c, p, n)), this.id || ur);
  },
  fields(t) {
    return w4(this) && t.includes("year") ? [...t, ...k4] : t;
  },
  k(t, e) {
    const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
    return N3(r, e, y8), w4(this) && (N3(r, e, Mbe), this.id === ic && N3(r, e, Nbe, k4)), r;
  },
  inLeapYear(t) {
    const [e] = this.v(t);
    return this.sn(e);
  },
  monthsInYear(t) {
    const [e] = this.v(t);
    return this.B(e);
  },
  daysInMonth(t) {
    const [e, r] = this.v(t);
    return this.U(e, r);
  },
  daysInYear(t) {
    const [e] = this.v(t);
    return this.fn(e);
  },
  dayOfYear: c8,
  era(t) {
    return this.hn(t)[0];
  },
  eraYear(t) {
    return this.hn(t)[1];
  },
  monthCode(t) {
    const [e, r] = this.v(t), [n, i] = this.q(e, r);
    return Qg(n, i);
  },
  dayOfWeek: Lj,
  daysInWeek() {
    return 7;
  }
}, Iwe = {
  v: LS,
  hn: Mj,
  q: Pj
}, Pwe = {
  dayOfYear: c8,
  v: LS,
  p: Bd
}, Rwe = /* @__PURE__ */ Object.assign({}, Pwe, {
  weekOfYear: gB,
  yearOfWeek: mB,
  m(t) {
    function e(v) {
      return (7 - v < n ? 7 : 0) - v;
    }
    function r(v) {
      const m = Tj(d + v), b = v || 1, f = e(Jf(l + m * b, 7));
      return p = (m + (f - c) * b) / 7;
    }
    const n = this.id ? 1 : 4, i = Lj(t), s = this.dayOfYear(t), o = Jf(i - 1, 7), a = s - 1, l = Jf(o - a, 7), c = e(l);
    let p, h = Math.floor((a - c) / 7) + 1, d = t.isoYear;
    return h ? h > r(0) && (h = 1, d++) : (h = r(-1), d--), [h, d, p];
  }
}), Owe = /* @__PURE__ */ Object.assign({}, oF, Rwe, {
  v: LS,
  hn: Mj,
  q: Pj,
  G(t, e) {
    if (!e)
      return [Aa, t];
  },
  sn: MS,
  L() {
  },
  B: Rj,
  cn: (t) => t * gl,
  U: Oj,
  fn: Tj,
  V: (t, e, r) => ({
    isoYear: t,
    isoMonth: e,
    isoDay: r
  }),
  p: Bd,
  un: (t, e, r) => (t += $v(r, gl), (e += xS(r, gl)) < 1 ? (t--, e += gl) : e > gl && (t++, e -= gl), [t, e]),
  year(t) {
    return t.isoYear;
  },
  month(t) {
    return t.isoMonth;
  },
  day: (t) => t.isoDay
}), Twe = {
  v: Yy,
  hn: SB,
  q: EB
}, Lwe = {
  dayOfYear: c8,
  v: Yy,
  p: B0,
  weekOfYear: gB,
  yearOfWeek: mB,
  m() {
    return [];
  }
}, Mwe = /* @__PURE__ */ Object.assign({}, oF, Lwe, {
  v: Yy,
  hn: SB,
  q: EB,
  G(t, e, r) {
    const n = this.id && wh(this.id) === "chinese" ? ((c, p, h) => {
      if (p)
        switch (c) {
          case 1:
            return 1651;
          case 2:
            return h < 30 ? 1947 : 1765;
          case 3:
            return h < 30 ? 1966 : 1955;
          case 4:
            return h < 30 ? 1963 : 1944;
          case 5:
            return h < 30 ? 1971 : 1952;
          case 6:
            return h < 30 ? 1960 : 1941;
          case 7:
            return h < 30 ? 1968 : 1938;
          case 8:
            return h < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      return 1972;
    })(t, e, r) : Aa;
    let [i, s, o] = Yy.call(this, {
      isoYear: n,
      isoMonth: gl,
      isoDay: 31
    });
    const a = O1.call(this, i), l = s === a;
    (Fl(t, h8(s, a)) || Fl(Number(e), Number(l)) || Fl(r, o)) === 1 && i--;
    for (let c = 0; c < 100; c++) {
      const p = i - c, h = O1.call(this, p), d = Ky(t, e, h);
      if (e === (d === h) && r <= iP.call(this, p, d))
        return [p, d];
    }
  },
  sn(t) {
    const e = Wm.call(this, t);
    return e > Wm.call(this, t - 1) && e > Wm.call(this, t + 1);
  },
  L: O1,
  B: qm,
  cn(t, e) {
    const r = e + t, n = Math.sign(t), i = n < 0 ? -1 : 0;
    let s = 0;
    for (let o = e; o !== r; o += n)
      s += qm.call(this, o + i);
    return s;
  },
  U: iP,
  fn: Wm,
  V(t, e, r) {
    return Fv(B0.call(this, t, e, r));
  },
  p: B0,
  un(t, e, r) {
    if (r) {
      if (e += r, !Number.isSafeInteger(e))
        throw new RangeError(Bc);
      if (r < 0)
        for (; e < 1; )
          e += qm.call(this, --t);
      else {
        let n;
        for (; e > (n = qm.call(this, t)); )
          e -= n, t++;
      }
    }
    return [t, e];
  },
  year(t) {
    return this.h(t).year;
  },
  month(t) {
    const { year: e, o: r } = this.h(t), { u: n } = this.l(e);
    return n[r] + 1;
  },
  day(t) {
    return this.h(t).day;
  }
}), cb = /* @__PURE__ */ AB(Iwe, Twe), Bt = /* @__PURE__ */ AB(Owe, Mwe), oP = {
  era: R1,
  eraYear: si,
  year: si,
  month: OI,
  monthCode(t) {
    const e = R1(t);
    return u8(e), e;
  },
  day: OI,
  .../* @__PURE__ */ rd(tl, si),
  .../* @__PURE__ */ rd(wr, _S),
  offset(t) {
    const e = R1(t);
    return Vh(e), e;
  }
}, M8 = /* @__PURE__ */ ir(vj, tl, po), Nwe = /* @__PURE__ */ ir(vj, po, tl), Ul = "numeric", rm = ["timeZoneName"], aF = {
  month: Ul,
  day: Ul
}, N8 = {
  year: Ul,
  month: Ul
}, D8 = /* @__PURE__ */ Object.assign({}, N8, {
  day: Ul
}), $8 = {
  hour: Ul,
  minute: Ul,
  second: Ul
}, j8 = /* @__PURE__ */ Object.assign({}, D8, $8), Dwe = /* @__PURE__ */ Object.assign({}, j8, {
  timeZoneName: "short"
}), $we = /* @__PURE__ */ Object.keys(N8), jwe = /* @__PURE__ */ Object.keys(aF), Bwe = /* @__PURE__ */ Object.keys(D8), Fwe = /* @__PURE__ */ Object.keys($8), B8 = ["dateStyle"], zwe = /* @__PURE__ */ $we.concat(B8), Uwe = /* @__PURE__ */ jwe.concat(B8), F8 = /* @__PURE__ */ Bwe.concat(B8, ["weekday"]), nm = /* @__PURE__ */ Fwe.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]), z8 = /* @__PURE__ */ F8.concat(nm), Vwe = /* @__PURE__ */ rm.concat(nm), Hwe = /* @__PURE__ */ rm.concat(F8), Gwe = /* @__PURE__ */ rm.concat(["day", "weekday"], nm), Wwe = /* @__PURE__ */ rm.concat(["year", "weekday"], nm), qwe = /* @__PURE__ */ Hh(z8, j8), Qwe = /* @__PURE__ */ Hh(z8, Dwe), Kwe = /* @__PURE__ */ Hh(z8, j8, rm), Ywe = /* @__PURE__ */ Hh(F8, D8, Vwe), Zwe = /* @__PURE__ */ Hh(nm, $8, Hwe), Jwe = /* @__PURE__ */ Hh(zwe, N8, Gwe), Xwe = /* @__PURE__ */ Hh(Uwe, aF, Wwe), e3e = {}, lF = new zl(void 0, {
  calendar: ur
}).resolvedOptions().calendar === ur, cF = [qwe, FS], t3e = [Qwe, FS, 0, (t, e) => {
  const r = t.timeZone;
  if (e && e.timeZone !== r)
    throw new RangeError(jB);
  return r;
}], uF = [Kwe, ui], hF = [Ywe, ui], pF = [Zwe, (t) => tc(t) / el], dF = [Jwe, ui, lF], fF = [Xwe, ui, lF];
let aP;
function zc(t, e, r, n, i) {
  function s(...l) {
    if (!(this instanceof s))
      throw new TypeError(E4);
    uP(this, e(...l));
  }
  function o(l, c) {
    return Object.defineProperties(function(...p) {
      return l.call(this, a(this), ...p);
    }, M0(c));
  }
  function a(l) {
    const c = wi(l);
    if (!c || c.branding !== t)
      throw new TypeError(E4);
    return c;
  }
  return Object.defineProperties(s.prototype, {
    ..._2e($a(o, r)),
    ...Xp($a(o, n)),
    ...wS("Temporal." + t)
  }), Object.defineProperties(s, {
    ...Xp(i),
    ...M0(t)
  }), [s, (l) => {
    const c = Object.create(s.prototype);
    return uP(c, l), c;
  }, a];
}
function Yd(t) {
  if (wi(t) || t.calendar !== void 0 || t.timeZone !== void 0)
    throw new TypeError(pbe);
  return t;
}
function im(t) {
  return gF(t) || ur;
}
function gF(t) {
  const { calendar: e } = t;
  if (e !== void 0)
    return ub(e);
}
function ub(t) {
  if (vi(t)) {
    const { calendar: e } = wi(t) || {};
    if (!e)
      throw new TypeError(NB(t));
    return e;
  }
  return ((e) => nb(nve(Xn(e))))(t);
}
function U8(t) {
  const e = {};
  for (const r in t)
    e[r] = (n) => {
      const { calendar: i } = n;
      return Bt(i)[r](n);
    };
  return e;
}
function Uc() {
  throw new TypeError(dbe);
}
function os(t) {
  if (vi(t)) {
    const { timeZone: e } = wi(t) || {};
    if (!e)
      throw new TypeError($B(t));
    return e;
  }
  return ((e) => s8(ive(Xn(e))))(t);
}
function cn(t) {
  if (vi(t)) {
    const e = wi(t);
    return e && e.branding === P8 ? e : _ve(t);
  }
  return rve(t);
}
function Af(t) {
  if (t !== void 0) {
    if (vi(t)) {
      const e = wi(t) || {};
      switch (e.branding) {
        case Fc:
        case tm:
          return e;
        case Kd:
          return Xa(e);
      }
      const r = im(t);
      return {
        ...bve(os, Kt, Bt(r), t),
        calendar: r
      };
    }
    return Y2e(t);
  }
}
function ml(t, e) {
  if (vi(t)) {
    const n = wi(t) || {};
    switch (n.branding) {
      case C8:
        return gr(e), n;
      case Kd:
        return gr(e), sa(n);
      case Fc:
        return gr(e), PB(Kt, n);
    }
    return kve(t, e);
  }
  const r = tve(t);
  return gr(e), r;
}
function V8(t) {
  return t === void 0 ? void 0 : ml(t);
}
function sp(t, e) {
  if (vi(t)) {
    const n = wi(t) || {};
    switch (n.branding) {
      case Kd:
        return gr(e), n;
      case tm:
        return gr(e), ho({
          ...n,
          ...Ki
        });
      case Fc:
        return gr(e), CB(Kt, n);
    }
    return xve(Bt(im(t)), t, e);
  }
  const r = J2e(t);
  return gr(e), r;
}
function lP(t, e) {
  if (vi(t)) {
    const n = wi(t);
    if (n && n.branding === _8)
      return gr(e), n;
    const i = gF(t);
    return Ave(Bt(i || ur), !i, t, e);
  }
  const r = eve(Bt, t);
  return gr(e), r;
}
function op(t, e) {
  if (vi(t)) {
    const n = wi(t);
    return n && n.branding === k8 ? (gr(e), n) : Sve(Bt(im(t)), t, e);
  }
  const r = X2e(Bt, t);
  return gr(e), r;
}
function ap(t, e) {
  if (vi(t)) {
    const n = wi(t) || {};
    switch (n.branding) {
      case tm:
        return gr(e), n;
      case Kd:
        return gr(e), Xa(n);
      case Fc:
        return gr(e), IB(Kt, n);
    }
    return Eve(Bt(im(t)), t, e);
  }
  const r = JS(t);
  return gr(e), r;
}
function lp(t, e) {
  if (vi(t)) {
    const r = wi(t);
    if (r && r.branding === Fc)
      return Uv(e), r;
    const n = im(t);
    return wve(os, Kt, Bt(n), n, t, e);
  }
  return Z2e(t, e);
}
function cP(t) {
  return $a((e) => (r) => e(C4(r)), t);
}
function C4(t) {
  return bs(t, Kt);
}
function cp(t) {
  if (vi(t)) {
    const e = wi(t);
    if (e)
      switch (e.branding) {
        case I8:
          return e;
        case Fc:
          return Ja(e.epochNanoseconds);
      }
  }
  return K2e(t);
}
function r3e() {
  function t(s, o) {
    return new e(s, o);
  }
  function e(s, o = /* @__PURE__ */ Object.create(null)) {
    e2.set(this, ((a, l) => {
      const c = new zl(a, l), p = c.resolvedOptions(), h = p.locale, d = co(Object.keys(l), p), v = ms(s3e), m = (b, ...f) => {
        if (b) {
          if (f.length !== 2)
            throw new TypeError($3);
          for (const g of f)
            if (g === void 0)
              throw new TypeError($3);
        }
        b || f[0] !== void 0 || (f = []);
        const E = f.map((g) => wi(g) || Number(g));
        let A, x = 0;
        for (const g of E) {
          const w = typeof g == "object" ? g.branding : void 0;
          if (x++ && w !== A)
            throw new TypeError($3);
          A = w;
        }
        return A ? v(A)(h, d, ...E) : [c, ...E];
      };
      return m.X = c, m;
    })(s, o));
  }
  const r = zl.prototype, n = Object.getOwnPropertyDescriptors(r), i = Object.getOwnPropertyDescriptors(zl);
  for (const s in n) {
    const o = n[s], a = s.startsWith("format") && n3e(s);
    typeof o.value == "function" ? o.value = s === "constructor" ? t : a || i3e(s) : a && (o.get = function() {
      if (!e2.has(this))
        throw new TypeError(E4);
      return (...l) => a.apply(this, l);
    }, Object.defineProperties(o.get, M0(`get ${s}`)));
  }
  return i.prototype.value = e.prototype = Object.create({}, n), Object.defineProperties(t, i), t;
}
function n3e(t) {
  return Object.defineProperties(function(...e) {
    const r = e2.get(this), [n, ...i] = r(t.includes("Range"), ...e);
    return n[t](...i);
  }, M0(t));
}
function i3e(t) {
  return Object.defineProperties(function(...e) {
    return e2.get(this).X[t](...e);
  }, M0(t));
}
function s3e(t) {
  const e = h3e[t];
  if (!e)
    throw new TypeError(Obe(t));
  return $c(e, ms(RB), 1);
}
const Jy = /* @__PURE__ */ new WeakMap(), wi = /* @__PURE__ */ Jy.get.bind(Jy), uP = /* @__PURE__ */ Jy.set.bind(Jy), mF = {
  era: C2e,
  eraYear: Ej,
  year: ES,
  month: fa,
  daysInMonth: fa,
  daysInYear: fa,
  inLeapYear: $be,
  monthsInYear: fa
}, H8 = {
  monthCode: Xn
}, yF = {
  day: fa
}, o3e = {
  dayOfWeek: fa,
  dayOfYear: fa,
  weekOfYear: I2e,
  yearOfWeek: Ej,
  daysInWeek: fa
}, G8 = /* @__PURE__ */ U8(/* @__PURE__ */ Object.assign({}, mF, H8, yF, o3e)), a3e = /* @__PURE__ */ U8({
  ...mF,
  ...H8
}), l3e = /* @__PURE__ */ U8({
  ...H8,
  ...yF
}), sm = {
  calendarId: (t) => t.calendar
}, c3e = /* @__PURE__ */ Dv((t) => (e) => e[t], wr.concat("sign")), W8 = /* @__PURE__ */ Dv((t, e) => (r) => r[po[e]], tl), vF = {
  epochMilliseconds: FS,
  epochNanoseconds: O2e
}, [u3e, en, $Ie] = zc(P8, zve, {
  ...c3e,
  blank: q2e
}, {
  with: (t, e) => en(Lve(t, e)),
  negated: (t) => en(ZS(t)),
  abs: (t) => en(W2e(t)),
  add: (t, e, r) => en(KI(Af, Bt, Kt, 0, t, cn(e), r)),
  subtract: (t, e, r) => en(KI(Af, Bt, Kt, 1, t, cn(e), r)),
  round: (t, e) => en(G2e(Af, Bt, Kt, t, e)),
  total: (t, e) => T2e(Af, Bt, Kt, t, e),
  toLocaleString(t, e, r) {
    return Intl.DurationFormat ? new Intl.DurationFormat(e, r).format(this) : T3(t);
  },
  toString: T3,
  toJSON: (t) => T3(t),
  valueOf: Uc
}, {
  from: (t) => en(cn(t)),
  compare: (t, e, r) => ove(Af, Bt, Kt, cn(t), cn(e), r)
}), h3e = {
  Instant: cF,
  PlainDateTime: uF,
  PlainDate: hF,
  PlainTime: pF,
  PlainYearMonth: dF,
  PlainMonthDay: fF
}, p3e = /* @__PURE__ */ $c(cF), d3e = /* @__PURE__ */ $c(t3e), f3e = /* @__PURE__ */ $c(uF), g3e = /* @__PURE__ */ $c(hF), m3e = /* @__PURE__ */ $c(pF), y3e = /* @__PURE__ */ $c(dF), v3e = /* @__PURE__ */ $c(fF), [b3e, _l] = zc(C8, Fve, W8, {
  with(t, e, r) {
    return _l(Tve(this, Yd(e), r));
  },
  add: (t, e) => _l(QI(0, t, cn(e))),
  subtract: (t, e) => _l(QI(1, t, cn(e))),
  until: (t, e, r) => en(nP(0, t, ml(e), r)),
  since: (t, e, r) => en(nP(1, t, ml(e), r)),
  round: (t, e) => _l(D2e(t, e)),
  equals: (t, e) => dve(t, ml(e)),
  toLocaleString(t, e, r) {
    const [n, i] = m3e(e, r, t);
    return n.format(i);
  },
  toString: zI,
  toJSON: (t) => zI(t),
  valueOf: Uc
}, {
  from: (t, e) => _l(ml(t, e)),
  compare: (t, e) => a8(ml(t), ml(e))
}), [w3e, ko] = zc(Kd, ir(Dve, Kg), {
  ...sm,
  ...G8,
  ...W8
}, {
  with: (t, e, r) => ko(Ive(Bt, t, Yd(e), r)),
  withCalendar: (t, e) => ko(p8(t, ub(e))),
  withPlainTime: (t, e) => ko(tbe(t, V8(e))),
  add: (t, e, r) => ko(GI(Bt, 0, t, cn(e), r)),
  subtract: (t, e, r) => ko(GI(Bt, 1, t, cn(e), r)),
  until: (t, e, r) => en(eP(Bt, 0, t, sp(e), r)),
  since: (t, e, r) => en(eP(Bt, 1, t, sp(e), r)),
  round: (t, e) => ko(N2e(t, e)),
  equals: (t, e) => cve(t, sp(e)),
  toZonedDateTime: (t, e, r) => ri(Hve(Kt, t, os(e), r)),
  toPlainDate: (t) => Ro(Xa(t)),
  toPlainTime: (t) => _l(sa(t)),
  toLocaleString(t, e, r) {
    const [n, i] = f3e(e, r, t);
    return n.format(i);
  },
  toString: $I,
  toJSON: (t) => $I(t),
  valueOf: Uc
}, {
  from: (t, e) => ko(sp(t, e)),
  compare: (t, e) => lB(sp(t), sp(e))
}), [x3e, I4, jIe] = zc(_8, ir(Bve, Kg), {
  ...sm,
  ...l3e
}, {
  with: (t, e, r) => I4(Ove(Bt, t, Yd(e), r)),
  equals: (t, e) => pve(t, lP(e)),
  toPlainDate(t, e) {
    return Ro(Yve(Bt, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = v3e(e, r, t);
    return n.format(i);
  },
  toString: FI,
  toJSON: (t) => FI(t),
  valueOf: Uc
}, {
  from: (t, e) => I4(lP(t, e))
}), [E3e, Lf, BIe] = zc(k8, ir(jve, Kg), {
  ...sm,
  ...a3e
}, {
  with: (t, e, r) => Lf(Rve(Bt, t, Yd(e), r)),
  add: (t, e, r) => Lf(qI(Bt, 0, t, cn(e), r)),
  subtract: (t, e, r) => Lf(qI(Bt, 1, t, cn(e), r)),
  until: (t, e, r) => en(rP(Bt, 0, t, op(e), r)),
  since: (t, e, r) => en(rP(Bt, 1, t, op(e), r)),
  equals: (t, e) => hve(t, op(e)),
  toPlainDate(t, e) {
    return Ro(Kve(Bt, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = y3e(e, r, t);
    return n.format(i);
  },
  toString: BI,
  toJSON: (t) => BI(t),
  valueOf: Uc
}, {
  from: (t, e) => Lf(op(t, e)),
  compare: (t, e) => Wd(op(t), op(e))
}), [S3e, Ro, FIe] = zc(tm, ir($ve, Kg), {
  ...sm,
  ...G8
}, {
  with: (t, e, r) => Ro(Pve(Bt, t, Yd(e), r)),
  withCalendar: (t, e) => Ro(p8(t, ub(e))),
  add: (t, e, r) => Ro(WI(Bt, 0, t, cn(e), r)),
  subtract: (t, e, r) => Ro(WI(Bt, 1, t, cn(e), r)),
  until: (t, e, r) => en(tP(Bt, 0, t, ap(e), r)),
  since: (t, e, r) => en(tP(Bt, 1, t, ap(e), r)),
  equals: (t, e) => uve(t, ap(e)),
  toZonedDateTime(t, e) {
    const r = vi(e) ? e : {
      timeZone: e
    };
    return ri(Gve(os, ml, Kt, t, r));
  },
  toPlainDateTime: (t, e) => ko(Wve(t, V8(e))),
  toPlainYearMonth(t) {
    return Lf(qve(Bt, t, this));
  },
  toPlainMonthDay(t) {
    return I4(Qve(Bt, t, this));
  },
  toLocaleString(t, e, r) {
    const [n, i] = g3e(e, r, t);
    return n.format(i);
  },
  toString: jI,
  toJSON: (t) => jI(t),
  valueOf: Uc
}, {
  from: (t, e) => Ro(ap(t, e)),
  compare: (t, e) => Wd(ap(t), ap(e))
}), [A3e, ri] = zc(Fc, ir(Nve, Kg, sve), {
  ...vF,
  ...sm,
  ...cP(G8),
  ...cP(W8),
  offset: (t) => Wg(C4(t).offsetNanoseconds),
  offsetNanoseconds: (t) => C4(t).offsetNanoseconds,
  timeZoneId: (t) => t.timeZone,
  hoursInDay: (t) => $2e(Kt, t)
}, {
  with: (t, e, r) => ri(Cve(Bt, Kt, t, Yd(e), r)),
  withCalendar: (t, e) => ri(p8(t, ub(e))),
  withTimeZone: (t, e) => ri(rbe(t, os(e))),
  withPlainTime: (t, e) => ri(ebe(Kt, t, V8(e))),
  add: (t, e, r) => ri(HI(Bt, Kt, 0, t, cn(e), r)),
  subtract: (t, e, r) => ri(HI(Bt, Kt, 1, t, cn(e), r)),
  until: (t, e, r) => en(bn(XI(Bt, Kt, 0, t, lp(e), r))),
  since: (t, e, r) => en(bn(XI(Bt, Kt, 1, t, lp(e), r))),
  round: (t, e) => ri(M2e(Kt, t, e)),
  startOfDay: (t) => ri(j2e(Kt, t)),
  equals: (t, e) => lve(t, lp(e)),
  toInstant: (t) => yl(Vve(t)),
  toPlainDateTime: (t) => ko(CB(Kt, t)),
  toPlainDate: (t) => Ro(IB(Kt, t)),
  toPlainTime: (t) => _l(PB(Kt, t)),
  toLocaleString(t, e, r = {}) {
    const [n, i] = d3e(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => DI(Kt, t, e),
  toJSON: (t) => DI(Kt, t),
  valueOf: Uc,
  getTimeZoneTransition(t, e) {
    const { timeZone: r, epochNanoseconds: n } = t, i = R2e(e), s = Kt(r).O(n, i);
    return s ? ri({
      ...t,
      epochNanoseconds: s
    }) : null;
  }
}, {
  from: (t, e) => ri(lp(t, e)),
  compare: (t, e) => aB(lp(t), lp(e))
}), [k3e, yl, zIe] = zc(I8, Mve, vF, {
  add: (t, e) => yl(VI(0, t, cn(e))),
  subtract: (t, e) => yl(VI(1, t, cn(e))),
  until: (t, e, r) => en(JI(0, t, cp(e), r)),
  since: (t, e, r) => en(JI(1, t, cp(e), r)),
  round: (t, e) => yl(L2e(t, e)),
  equals: (t, e) => ave(t, cp(e)),
  toZonedDateTimeISO: (t, e) => ri(Uve(t, os(e))),
  toLocaleString(t, e, r) {
    const [n, i] = p3e(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => NI(os, Kt, t, e),
  toJSON: (t) => NI(os, Kt, t),
  valueOf: Uc
}, {
  from: (t) => yl(cp(t)),
  fromEpochMilliseconds: (t) => yl(Zve(t)),
  fromEpochNanoseconds: (t) => yl(Jve(t)),
  compare: (t, e) => oB(cp(t), cp(e))
}), _3e = /* @__PURE__ */ Object.defineProperties({}, {
  ...wS("Temporal.Now"),
  ...Xp({
    timeZoneId: () => Ef(),
    instant: () => yl(Ja(x4())),
    zonedDateTimeISO: (t = Ef()) => ri(uo(x4(), os(t), ur)),
    plainDateTimeISO: (t = Ef()) => ko(ho(D3(Kt(os(t))), ur)),
    plainDateISO: (t = Ef()) => Ro(Xa(D3(Kt(os(t))), ur)),
    plainTimeISO: (t = Ef()) => _l(sa(D3(Kt(os(t)))))
  })
}), Xy = /* @__PURE__ */ Object.defineProperties({}, {
  ...wS("Temporal"),
  ...Xp({
    PlainYearMonth: E3e,
    PlainMonthDay: x3e,
    PlainDate: S3e,
    PlainTime: b3e,
    PlainDateTime: w3e,
    ZonedDateTime: A3e,
    Instant: k3e,
    Duration: u3e,
    Now: _3e
  })
}), C3e = /* @__PURE__ */ r3e(), e2 = /* @__PURE__ */ new WeakMap();
Xp({
  DateTimeFormat: C3e
});
function hb(t) {
  Object.freeze(t);
  for (const e in t)
    typeof t == "object" && hb(t[e]);
}
function I3e(t) {
  return Object.keys(t).length === 0;
}
function Ep(t) {
  return { type: "connective", real: Er(t) };
}
function M1(t, e, r) {
  return {
    type: "simple-category",
    subtype: "currency",
    noun: Er(t),
    symbol: e,
    pos: r
  };
}
function Pi(t, e) {
  return e ? { type: "direction", direction: Er(t), aux: e } : { type: "direction", direction: Er(t) };
}
function Er(t) {
  return { en: t };
}
const Sp = function(t, e) {
  const r = { type: "simple-category" };
  if (I3e(t))
    throw new Error("[grammatize-information]: The category helper function must be called with at least one lemma.");
  for (const n in t) {
    const i = n;
    r[i] = Er(t[i]);
  }
  return e && (r.quasiname = !0), r;
};
function Dr(t) {
  return { type: "simple-category", noun: Er(t) };
}
function Ap(t, e) {
  return { type: "simple-category", adj: Er(t), inessential: e ?? !1 };
}
function bF(t) {
  return { type: "simple-category", pastParticiple: Er(t) };
}
function Gn(t, e) {
  return e ? { type: "predicate", pred: Er(t), aux: Er(e) } : { type: "predicate", pred: Er(t) };
}
function N1(t) {
  return { type: "simple-category", subtype: "unit", noun: Er(t) };
}
function Ou(t) {
  return { type: "simple-category", subtype: "scale", noun: Er(t) };
}
function kp(t, e) {
  return { type: "quantifier", quantifier: Er(t), aux: e ? Er(e) : void 0 };
}
const hP = Pi("back"), pP = Pi("up"), Oe = {
  // Predicates
  SHOW: Gn("show"),
  PEAK: Gn("peak"),
  BOTTOM_OUT: Gn("bottom", "out"),
  COMPARE: Gn("compare"),
  COPULA: Gn("be"),
  START: Gn("start"),
  END: Gn("end"),
  HAS: Gn("have"),
  REBOUND: Gn("rebound"),
  FALL_pred: Gn("fall"),
  RISE_pred: Gn("rise"),
  CLUSTER: Gn("cluster"),
  TRACK: Gn("track"),
  INTERSECT: Gn("intersect"),
  //TODO: combine with INTERSECTION
  // Categories
  LINE: Dr("line"),
  CHART: Dr("chart"),
  PRICE: Dr("price"),
  PERIOD: Dr("period"),
  RATE: Dr("rate"),
  INFLATION: Dr("inflation"),
  INTERSECTION: Dr("intersection"),
  NUMBER: Ou("number"),
  TREND: Dr("trend"),
  JUMP: Dr("jump"),
  DISTRIBUTION: Dr("distribution"),
  OUTLIER: Dr("outlier"),
  RECORD: Dr("record"),
  XAXIS: Dr("x-axis"),
  YAXIS: Dr("y-axis"),
  PERCENT: Ou("percent"),
  PERCENTAGE: Dr("percentage"),
  BAR: Dr("bar"),
  SLICE: Dr("slice"),
  PIE: Dr("pie"),
  GROUP: Dr("group"),
  TIME: Dr("time"),
  THOUSAND: Ou("thousand"),
  MILLION: Ou("million"),
  BILLION: Ou("billion"),
  TRILLION: Ou("trillion"),
  OVERALL: Ap("overall"),
  LARGE: Ap("large"),
  DIFFERENT: Ap("different"),
  ENTIRE: Ap("entire"),
  STEPPED: Ap("stepped"),
  FOLLOWED: bF("follow"),
  HIGH: Sp({ noun: "high", adj: "high" }),
  LOW: Sp({ noun: "low", adj: "low" }),
  STABLE: Sp({ noun: "stable", adj: "stable" }),
  RISE: Sp({ noun: "rise", participle: "rise" }),
  FALL: Sp({ noun: "fall", participle: "fall" }),
  // Units
  POINT: N1("point"),
  YEAR: N1("year"),
  QUARTER: N1("quarter"),
  // Directions
  OVER: Pi("over"),
  IN: Pi("in"),
  AT: Pi("at"),
  ON: Pi("on"),
  BACK: hP,
  UP: pP,
  BACK_UP: { ...hP, aux: pP },
  BY: Pi("by"),
  FROM: Pi("from"),
  TO: Pi("to"),
  BETWEEN: Pi("between"),
  EXCEPT: Pi("except"),
  ALONG: Pi("along"),
  // Connectives
  AND: Ep("and"),
  FOLLOWED_BY: Ep("followed by"),
  AND_THEN: Ep("and then"),
  BEFORE: Ep("before"),
  WHILE: Ep("while"),
  // Manners & Modes
  TOGETHER: { type: "manner", manner: Er("together") },
  TEMPORARILY: { type: "manner", manner: Er("temporarily") },
  AGAIN: { type: "manner", manner: Er("again") },
  WORLDWIDE: { type: "manner", manner: Er("worldwide") },
  POSSIBLY: { type: "mode", mode: Er("possibly") },
  // Quantifiers
  ALL: kp("all"),
  AROUND: { ...kp("around"), adverb: !0 },
  ALMOST: { ...kp("almost"), adverb: !0 },
  MORE_THAN: kp("more", "than"),
  EACH: kp("each"),
  // Pronouns
  EACH_OTHER: { type: "pronoun-entity", determiner: Er("each"), number: "plural", pronoun: Er("other") }
};
hb(Oe);
const D1 = {
  DOLLAR: M1("dollar", "$", "prefix"),
  US_DOLLAR: M1("U.S. dollar", "$", "prefix"),
  SK_WON: M1("South Korean won", "", "prefix")
};
hb(D1);
const Ol = {
  "0.01": Oe.PERCENT,
  1: Oe.NUMBER,
  1e3: Oe.THOUSAND,
  1e6: Oe.MILLION,
  1e9: Oe.BILLION,
  1e12: Oe.TRILLION
};
hb(Ol);
const Ci = class Ii {
  static participle(e) {
    return { type: "simple-category", participle: Er(e) };
  }
  // * Entities *
  // Helpers for Entities Helpers
  static _num(e) {
    let r;
    return e === "s" ? r = "singular" : e === "p" ? r = "plural" : r = e, r;
  }
  static _entityHelperBuilder(e, r, n, i) {
    return {
      type: "simple-entity",
      detType: e,
      number: Ii._num(r),
      category: n,
      mods: i
    };
  }
  // Simple Entities
  static the(e, r, n) {
    return Ii._entityHelperBuilder("definite", e, r, n ?? []);
  }
  static a(e, r, n) {
    return Ii._entityHelperBuilder("indefinite", e, r, n ?? []);
  }
  static this_(e, r, n) {
    return Ii._entityHelperBuilder("proximal", e, r, n ?? []);
  }
  static that(e, r, n) {
    return Ii._entityHelperBuilder("distal", e, r, n ?? []);
  }
  static proper(e, r) {
    return Ii._entityHelperBuilder("proper", "singular", e, r ?? []);
  }
  // Number Entities
  static numberEntity(e, r, n) {
    return {
      type: "number-entity",
      number: e,
      scale: r,
      mods: n
    };
  }
  // Money Values
  static moneyValue(e, r, n, i) {
    return {
      type: "simple-entity",
      subtype: "money-value",
      detType: "bare",
      number: e,
      scale: r,
      category: n,
      mods: i
    };
  }
  // Quantity Values
  static quantValue(e, r, n, i) {
    return {
      type: "simple-entity",
      subtype: "quant-value",
      detType: "indefinite",
      number: e,
      scale: r,
      category: n,
      mods: i
    };
  }
  // Plain Date Points
  static year(e) {
    const r = e.toString().padStart(4, "0");
    return {
      type: "plain-date-time",
      datetime: Xy.PlainDateTime.from(`${r}0101`),
      unit: "year"
    };
  }
  static quarter(e, r) {
    const n = e.toString().padStart(4, "0");
    if (![1, 2, 3, 4].includes(r))
      throw new Error(`[Grammatize-Information]: quarter number must be 1, 2, 3, or 4, not ${r}`);
    const i = ((r - 1) * 3 + 1).toString().padStart(2, "0");
    return {
      type: "plain-date-time",
      datetime: Xy.PlainDateTime.from(`${n}${i}01`),
      unit: "quarter"
    };
  }
  // * Modifiers *
  // Misc Modifiers
  static of(e) {
    return { type: "possession", possessor: e };
  }
  static for_(e) {
    return { type: "purpose", subtype: "for", purpose: e };
  }
  static with(e) {
    return { type: "purpose", subtype: "with", purpose: e };
  }
  static as(e) {
    return { type: "purpose", subtype: "as", purpose: e };
  }
  static ordinal(e) {
    return { type: "ordinal", ordinal: e };
  }
  static _pointLocationHelperBuilder(e, r) {
    return { type: "point-location", direction: e, point: r };
  }
  static over(e) {
    return Ii._pointLocationHelperBuilder(Oe.OVER, e);
  }
  static on(e) {
    return Ii._pointLocationHelperBuilder(Oe.ON, e);
  }
  static at(e) {
    return Ii._pointLocationHelperBuilder(Oe.AT, e);
  }
  static in_(e) {
    return Ii._pointLocationHelperBuilder(Oe.IN, e);
  }
  static by(e) {
    return Ii._pointLocationHelperBuilder(Oe.BY, e);
  }
  static path(e, r) {
    return { type: "path-location", start: e, end: r };
  }
  // * Statements *
  static svo(e, r, n, ...i) {
    return {
      type: "simple-statement",
      subject: e,
      clause: {
        type: "simple-clause",
        pred: r,
        object: n
      },
      mods: i
    };
  }
  // Coordinated Phrases
  static coord(e, ...r) {
    return { type: "coordinated-phrase", conn: e, coords: r };
  }
  static and(...e) {
    return Ii.coord(Oe.AND, ...e);
  }
  // * Tags *
  static tag(e, r, n) {
    return e.tag = { name: r, attributes: n }, e;
  }
};
ki(Ci, "en", Er), // * Categories *
// Simple Categories
ki(Ci, "category", Sp), ki(Ci, "noun", Dr), ki(Ci, "adj", Ap), ki(Ci, "pastParticiple", bF), // Units
ki(Ci, "unit", N1), // Scales
ki(Ci, "scale", Ou), // Currencies
ki(Ci, "currency", M1), ki(Ci, "quantifier", kp), // Locations
ki(Ci, "dir", Pi), // * Predicates *
ki(Ci, "pred", Gn), // * Coordination *
// Connectives
ki(Ci, "conn", Ep);
let we = Ci;
var vt;
((t) => {
  function e(N) {
    return n(N) || h(N) || le(N) || g(N) || c(N) || ce(N) || xe(N) || ue(N) || je(N) || O(N, e);
  }
  t.isComponent = e;
  function r(N) {
    return typeof N == "object" && !!N && "type" in N && e(N);
  }
  t.isComponentGuard = r;
  function n(N) {
    return i(N) || s(N) || o(N) || a(N) || l(N) || O(N, n);
  }
  t.isCategory = n;
  function i(N) {
    return N.type === "simple-category";
  }
  t.isSimpleCategory = i;
  function s(N) {
    return i(N) && "noun" in N && N.subtype === "unit";
  }
  t.isUnit = s;
  function o(N) {
    return i(N) && "noun" in N && N.subtype === "currency";
  }
  t.isCurrency = o;
  function a(N) {
    return i(N) && "noun" in N && N.subtype === "scale";
  }
  t.isScale = a;
  function l(N) {
    return N.type === "ordinal";
  }
  t.isOrdinal = l;
  function c(N) {
    return N.type === "quantifier";
  }
  t.isQuantifier = c;
  function p(N) {
    return typeof N == "number" ? N === 1 ? "s" : "p" : N === "singular" ? "s" : N === "plural" ? "p" : N;
  }
  t.normalizeNumber = p;
  function h(N) {
    return v(N) || m(N) || b(N) || x(N) || A(N) || O(N, h);
  }
  t.DET = {
    proper: { en: null },
    definite: { en: "the" },
    indefinite: { en: "a" },
    proximal: { en: "this" },
    distal: { en: "that" },
    bare: { en: null }
  };
  function d(N) {
    if (v(N) || m(N) || A(N))
      return p(N.number);
    if (x(N))
      return "s";
    if (O(N, h))
      return "p";
  }
  t.entityNumber = d;
  function v(N) {
    return N.type === "simple-entity";
  }
  t.isSimpleEntity = v;
  function m(N) {
    return N.type === "pronoun-entity";
  }
  t.isPronounEntity = m;
  function b(N) {
    return E(N) || f(N);
  }
  function f(N) {
    return v(N) && N.subtype === "quant-value";
  }
  t.isQuantValue = f;
  function E(N) {
    return v(N) && N.subtype === "money-value";
  }
  t.isMoneyValue = E;
  function A(N) {
    return N.type === "number-entity";
  }
  t.isNumberEntity = A;
  function x(N) {
    return N.type === "plain-date-time";
  }
  t.isPlainDateTime = x;
  function g(N) {
    return n(N) || _(N) || S(N) || R(N) || z(N) || L(N) || je(N) || O(N, g);
  }
  function w(N) {
    if (n(N))
      return "prepend";
    if (_(N) || S(N) || R(N) || z(N))
      return "postpend";
    if (L(N))
      return N.prepend ? "prepend" : "postpend";
    if (F(N))
      return "prepend";
    if (je(N))
      return "postpend";
    if (O(N, g))
      return w(N.coords[0]);
  }
  t.modPosition = w;
  function _(N) {
    return N.type === "possession";
  }
  t.isPossession = _, t.POSS_AUX = {
    en: "of"
  }, t.REL = {
    zero: { en: null },
    which: { en: "which" },
    that: { en: "that" },
    while: { en: "while" }
  };
  function S(N) {
    return N.type === "relative-clause";
  }
  t.isRelative = S;
  function R(N) {
    return N.type === "purpose";
  }
  t.isPurpose = R, t.PURPOSE_AUX = {
    for: we.en("for"),
    as: we.en("as"),
    with: we.en("with")
  };
  function L(N) {
    return N.type === "manner";
  }
  t.isManner = L;
  function F(N) {
    return N.type === "mode";
  }
  t.isMode = F;
  function z(N) {
    return j(N) || W(N) || te(N);
  }
  t.isLocation = z;
  function j(N) {
    return N.type === "direction";
  }
  t.isDirection = j;
  function W(N) {
    return N.type === "point-location";
  }
  t.isPointLocation = W;
  function te(N) {
    return N.type === "path-location";
  }
  t.isPathLocation = te;
  function le(N) {
    return N.type === "predicate";
  }
  t.isPredicate = le;
  function ce(N) {
    return Ee(N) || O(N, ce);
  }
  function Ee(N) {
    return N.type === "simple-clause";
  }
  t.isSimpleClause = Ee;
  function xe(N) {
    return _e(N) || Ie(N) || O(N, _e);
  }
  t.isStatement = xe;
  function _e(N) {
    return N.type === "simple-statement";
  }
  t.isSimpleStatement = _e;
  function Ie(N) {
    return N.type === "label";
  }
  t.isLabel = Ie;
  function je(N) {
    return N.type === "quote";
  }
  t.isQuote = je;
  function ue(N) {
    return N.type === "connective";
  }
  t.isConnective = ue;
  function O(N, J) {
    return N.type === "coordinated-phrase" && J(N.coords[0]);
  }
  t.isCoordinated = O;
})(vt || (vt = {}));
const P3e = [
  { cat: { noun: "Canada", adj: "Canadian" } },
  { cat: { noun: "nation", adj: "national" } },
  { cat: { noun: "Indonesia", adj: "Indonesian" } },
  { cat: { noun: "region", adj: "regional" } },
  { cat: { noun: "U.S.", adj: "U.S." }, quasiname: !0, synonyms: ["US", "United States"] },
  { cat: { noun: "Vietnam", adj: "Vietnamese" } },
  { cat: { noun: "world", adj: "global" }, quasiname: !0 }
];
function R3e(t) {
  const e = {};
  for (const r of t) {
    const n = we.category(r.cat, r.quasiname);
    e[r.cat.noun] = n, e[r.cat.adj] = n;
    for (const i of r.synonyms ?? [])
      e[i] = n;
  }
  return e;
}
R3e(P3e);
const qr = new k2e(), dP = qr.N, O3e = qr.A, T3e = qr.Pro, Km = qr.D, F3 = qr.V, up = qr.Adv, hp = qr.P, L3e = qr.C, _u = qr.Q, z3 = qr.S, M3e = qr.SP, N3e = qr.CP, U3 = qr.VP, Os = qr.NP, D3e = qr.AP, pp = qr.PP, fP = qr.AdvP, gP = qr.DT, ll = qr.NO;
function $3e(t, e) {
  const r = [], n = [];
  for (const i of t)
    e(i) ? r.push(i) : n.push(i);
  return [r, n];
}
function t2(t) {
  if (Array.isArray(t))
    return t.map((e) => t2(e));
  if (t instanceof Xy.PlainDateTime || Object.prototype.toString.call(t) === "[object Temporal.PlainDateTime]")
    return Xy.PlainDateTime.from(t);
  if (typeof t == "object") {
    const e = {};
    for (const r in t)
      e[r] = t2(t[r]);
    return e;
  }
  return t;
}
function P4(t) {
  const e = t2(t);
  for (const r in t)
    ["tag", "detTag", "auxTag", "startTag", "endTag"].includes(r) ? delete e[r] : vt.isComponentGuard(t[r]) && (e[r] = P4(t[r]));
  return e;
}
function Mf(t, e) {
  const r = P4(t), n = P4(e);
  return JSON.stringify(r) === JSON.stringify(n);
}
function j3e(t, e) {
  return t.some((r) => Mf(r, e));
}
async function B3e() {
  await qr.init();
}
class F3e {
  // Dispatch
  grammatizeMultiple(e, r) {
    return e.map((n) => this.grammatize(n, r));
  }
  grammatize(e, r, n) {
    let i = this.grammatizeDispatch(e, r, n);
    return "tag" in e && i.tag(e.tag.name, e.tag.attributes), i;
  }
  grammatizeDispatch(e, r, n) {
    if (vt.isCategory(e))
      return this.grammatizeCategory(e, r, n);
    if (vt.isQuantValue(e))
      return this.grammatizeQuantValue(e, r);
    if (vt.isMoneyValue(e))
      return this.grammatizeMoneyValue(e, r);
    if (vt.isSimpleEntity(e))
      return this.grammatizeSimpleEntity(e, r);
    if (vt.isPronounEntity(e))
      return this.grammatizePronounEntity(e, r);
    if (vt.isNumberEntity(e))
      return this.grammatizeNumberEntity(e, r);
    if (vt.isPlainDateTime(e))
      return this.grammatizePlainDateTime(e, r);
    if (vt.isPossession(e))
      return this.grammatizePoss(e, r);
    if (vt.isRelative(e))
      return this.grammatizeRelative(e, r);
    if (vt.isPurpose(e))
      return this.grammatizePurpose(e, r);
    if (vt.isManner(e))
      return this.grammatizeManner(e, r);
    if (vt.isMode(e))
      return this.grammatizeMode(e, r);
    if (vt.isDirection(e))
      return this.grammatizeDir(e, r);
    if (vt.isPointLocation(e))
      return this.grammatizeLoc(e, r);
    if (vt.isPathLocation(e))
      return this.grammatizePath(e, r);
    if (vt.isPredicate(e))
      return this.grammatizePredicate(e, r, n);
    if (vt.isSimpleClause(e))
      return this.grammatizeSimpleClause(e, r, n);
    if (vt.isSimpleStatement(e))
      return this.grammatizeSimpleStatement(e, r);
    if (vt.isQuantifier(e))
      return this.grammatizeQuantifier(e, r);
    if (vt.isLabel(e))
      return this.grammatizeLabel(e, r);
    if (vt.isQuote(e))
      return this.grammatizeQuote(e, r);
    if (vt.isConnective(e))
      return this.grammatizeConnective(e, r);
    if (vt.isCoordinated(e, vt.isComponent))
      return this.grammatizeCoord(e, r);
  }
  // Helpers
  _grammatizeAdj(e, r) {
    console.assert("adj" in e);
    const n = e.adj[r], i = O3e(n, !0);
    return (e.comparative === "comparative" || e.comparative === "superlative") && i.f(e.comparative === "comparative" ? "co" : "su"), i;
  }
  // Categories
  grammatizeCategory(e, r, n = "s") {
    return vt.isSimpleCategory(e) ? this.grammatizeSimpleCategory(e, r, n) : vt.isOrdinal(e) ? this.grammatizeOrdinal(e, r) : vt.isUnit(e) ? this.grammatizeUnit(e, r) : vt.isCurrency(e) ? this.grammatizeCurrencySymbol(e, r) : vt.isScale(e) ? this.grammatizeScale(e, r) : vt.isCoordinated(e, vt.isCategory) ? this.grammatizeCoord(e, r, n) : e;
  }
  grammatizeSimpleCategory(e, r, n) {
    console.assert("adj" in e || "noun" in e || "participle" in e || "pastParticiple" in e);
    let i;
    "force" in e && e.force !== void 0 ? (console.assert(e.force in e), i = e.force) : "adj" in e && "comparative" in e ? i = "adj" : "noun" in e ? i = "noun" : "adj" in e ? i = "adj" : "participle" in e ? i = "participle" : i = "pastParticiple";
    let s;
    return i === "noun" ? s = Os(dP(e.noun[r], n, !0)) : i === "participle" ? s = U3(F3(e.participle[r], "present-participle")) : i === "pastParticiple" ? s = U3(F3(e.pastParticiple[r], "past-participle")) : s = D3e(this._grammatizeAdj(e, r)), this.grammatizeMods(s, r, e.mods), s;
  }
  // This should return a (Number)Adjective. See https://github.com/fizzstudio/theseusaurus/issues/54
  grammatizeOrdinal(e, r) {
    return ll(e.ordinal).dOpt({ ord: !0 });
  }
  grammatizeUnit(e, r) {
    const n = {
      ...e,
      noun: e.noun
    };
    return this.grammatizeCategory(n, r);
  }
  grammatizeCurrencySymbol(e, r) {
    return _u(e.symbol);
  }
  grammatizeScale(e, r) {
    const n = {
      ...e,
      noun: e.noun
    };
    return this.grammatizeCategory(n, r);
  }
  // Entities
  grammatizeSimpleEntity(e, r) {
    if (e.detType === "proper" && e.number !== "singular")
      throw new Error("Proper nouns can only be singular");
    const n = e.quantifier ? this.grammatize(e.quantifier, r) : null, i = e.number === "singular" || e.number === 1 ? "s" : "p";
    let s;
    e.number === "plural" && e.detType === "indefinite" || e.detType === "proper" || e.detType === "bare" || typeof e.number == "number" && e.detType === "indefinite" ? s = null : (console.assert(vt.DET[e.detType][r] !== null, "nullish determiner"), s = Km(vt.DET[e.detType][r]), e.detTag && s.tag(e.detTag.name, e.detTag.attributes));
    const o = e.number === "singular" || e.number === "plural" ? null : ll(e.number), a = this.grammatize(e.category, r, i), l = e.scale && !Mf(e.scale, Ol[1]) ? this.grammatize(e.scale, r) : null;
    return this.grammatizeEntityMods(n, s, o, a, l, r, e.mods);
  }
  grammatizePronounEntity(e, r) {
    const n = T3e(e.pronoun[r]);
    return e.determiner ? Os(Km(e.determiner[r]), n) : Os(n);
  }
  grammatizeQuantValue(e, r) {
    const n = {
      ...e,
      type: "simple-entity",
      detType: "indefinite"
    };
    return this.grammatizeSimpleEntity(n, r);
  }
  grammatizeNumberEntity(e, r) {
    const n = e.quantifier ? this.grammatize(e.quantifier, r) : null;
    let i;
    return Mf(e.scale, Ol[1]) ? i = Os(n, ll(e.number)) : Mf(e.scale, Ol[0.01]) ? i = Os(n, ll(e.number).after(_u("%"))) : i = Os(n, ll(e.number), this.grammatize(e.scale, r)), this.grammatizeMods(i, r, e.mods), i;
  }
  grammatizeMoneyValue(e, r) {
    const n = e.category.pos === "prefix" ? ll(e.number).before(this.grammatizeCurrencySymbol(e.category, r)) : ll(e.number).after(this.grammatizeCurrencySymbol(e.category, r));
    let i;
    return "scale" in e && e.scale !== void 0 && !Mf(e.scale, Ol[1]) ? i = Os(n, this.grammatize(e.scale, r)) : i = Os(n), this.grammatizeMods(i, r, e.mods), i;
  }
  grammatizePlainDateTime(e, r) {
    if (e.unit === "year")
      return gP(`${e.datetime.year}`);
    if (e.unit === "quarter") {
      const n = (e.datetime.month - 1) / 3 + 1;
      if (![1, 2, 3, 4].includes(n))
        throw new Error(`[Grammatize-Information]: PlainDateTime ${e.datetime} does not represent a quarter.`);
      return Os(Km("the"), ll(n).dOpt({ ord: !0 }), dP("quarter"), pp(hp("of"), gP(`${e.datetime.year}`)));
    }
    e.unit;
  }
  grammatizeMods(e, r, n) {
    const i = n ?? [], s = i.filter((a) => vt.modPosition(a) === "prepend"), o = i.filter((a) => vt.modPosition(a) === "postpend");
    for (const a of s.reverse())
      e.add(this.grammatize(a, r), 0);
    for (const a of o)
      e.add(this.grammatize(a, r));
  }
  grammatizeEntityMods(e, r, n, i, s, o, a) {
    const [l, c] = $3e(
      a ?? [],
      (h) => vt.modPosition(h) === "prepend"
    );
    this.grammatizeMods(i, o, l);
    const p = Os(e, r, n, s, i);
    return this.grammatizeMods(p, o, c), p;
  }
  grammatizePoss(e, r) {
    const n = hp(vt.POSS_AUX[r]);
    return "auxTag" in e && n.tag(e.auxTag.name, e.auxTag.attributes), pp(n, this.grammatize(e.possessor, r));
  }
  grammatizeRelative(e, r) {
    const n = vt.REL[e.relativizer][r], i = n ? up(n) : null;
    "auxTag" in e && i && i.tag(e.auxTag.name, e.auxTag.attributes);
    const s = M3e(e.restrictive, i, this.grammatize(e.clause, r));
    return e.restrictive || s.before(_u(",")), s;
  }
  grammatizePurpose(e, r) {
    const n = hp(vt.PURPOSE_AUX[e.subtype][r]);
    return "auxTag" in e && n.tag(e.auxTag.name, e.auxTag.attributes), pp(n, this.grammatize(e.purpose, r));
  }
  grammatizeManner(e, r) {
    const n = up(e.manner[r]);
    return e.aux ? fP(n, hp(e.aux[r])) : n;
  }
  grammatizeQuantifier(e, r) {
    const n = e.quantifier[r], i = e.adverb ? up(n) : Km(n);
    return e.aux ? fP(i, hp(e.aux[r])) : i;
  }
  grammatizeMode(e, r) {
    return up(e.mode[r]);
  }
  grammatizeDir(e, r) {
    const n = e.aux ? this.grammatize(e.aux, r) : null;
    return pp(hp(e.direction[r]), n);
  }
  grammatizeLoc(e, r) {
    return pp(this.grammatize(e.direction, r), this.grammatize(e.point, r));
  }
  grammatizePath(e, r) {
    const n = this.grammatize(Oe.FROM, r);
    e.startTag && n.tag(e.startTag.name, e.startTag.attributes);
    const i = this.grammatize(Oe.TO, r);
    return e.endTag && i.tag(e.endTag.name, e.endTag.attributes), pp(
      n,
      this.grammatize(e.start, r),
      i,
      this.grammatize(e.end, r)
    );
  }
  grammatizePredicate(e, r, n = "s") {
    return e.forceNumber && (n = vt.normalizeNumber(e.forceNumber)), F3(e.pred[r], e.tense, n);
  }
  grammatizeSimpleClause(e, r, n = "s") {
    var i;
    const s = e.pred ? this.grammatize(e.pred, r, n) : void 0, o = (i = e.pred) != null && i.aux ? up(e.pred.aux[r]) : void 0, a = e.object ? this.grammatize(e.object, r) : void 0, l = U3(s, o, a);
    return this.grammatizeMods(l, r, e.mods), l;
  }
  grammatizeSimpleStatement(e, r) {
    const n = e.subject ? this.grammatize(e.subject, r) : up("there"), i = e.subject ? vt.entityNumber(e.subject) : "p", s = z3(n, this.grammatize(e.clause, r, i));
    return this.grammatizeMods(s, r, e.mods), s;
  }
  grammatizeLabel(e, r) {
    return z3(_u(e.text).a(":"));
  }
  grammatizeQuote(e, r) {
    return _u(e.text);
  }
  grammatizeConnective(e, r) {
    const n = e.real[r];
    return n.includes(" ") ? _u(n) : L3e(n);
  }
  /*if (this.abbrevs.includes('DROP-COMMON-SUBJ') &&
    this.lhs instanceof SimpleStatement &&
    this.rhs instanceof SimpleStatement &&
    this.lhs.subjectEquals(this.rhs) &&
    this.rhs.clause.object !== null
  ) {
    return S(this.lhs.grammatize(lang), this.conn.grammatize(lang), this.rhs.grammatizeVP(lang));
  }*/
  grammatizeCoord(e, r, n) {
    const i = e.coords.map((a) => this.grammatize(a, r, n)), s = this.grammatize(e.conn, r);
    e.firstComma && i.length === 2 && i[0].after(_u(","));
    const o = N3e(s, ...i).oxfordify();
    return vt.isSimpleStatement(e.coords[0]) ? z3(o) : vt.isCategory(e.coords[0]) ? Os(o) : o;
  }
}
class z3e extends F3e {
  constructor() {
    super(...arguments), ki(this, "mentioned", []);
  }
  words(e) {
    return e.trim().split(" ");
  }
  allSame(e) {
    const r = e[0];
    return r === void 0 ? !1 : e.every((n) => n === r);
  }
  getMiddle(e) {
    return this.words(e).slice(1, -1).join(" ");
  }
  grammatizeSimpleEntity(e, r) {
    if (j3e(this.mentioned, e)) {
      if (!e.mods || e.mods.length === 0)
        return super.grammatizeSimpleEntity(e, r);
      const n = t2(e);
      return n.mods = n.mods.filter(
        (i) => !vt.isPossession(i) && !(vt.isSimpleCategory(i) && i.inessential) && !(vt.isLocation(i) && i.inessential)
      ), super.grammatizeSimpleEntity(n, r);
    }
    return this.mentioned.push(e), super.grammatizeSimpleEntity(e, r);
  }
  grammatizeCoord(e, r, n) {
    if (vt.isSimpleEntity(e.coords[0])) {
      const i = e.coords;
      if (i.some((l) => !vt.isSimpleCategory(l.category)))
        return super.grammatizeCoord(e, r, n);
      const s = i.map((l) => l.category.noun[r]), o = s.map((l) => this.words(l).at(0)), a = s.map((l) => this.words(l).at(-1));
      if (this.allSame(o) && this.allSame(a) && o[0] !== a[0]) {
        const l = o[0], c = a[0], p = s.map((v) => this.getMiddle(v)).map((v) => we.noun(v)), h = we.and(...p), d = {
          type: "simple-entity",
          detType: "indefinite",
          //FIXME: is this always the wanted determiner?
          number: "plural",
          category: we.noun(c),
          mods: [we.adj(l), h]
        };
        return this.grammatize(d, r, n);
      }
    }
    return super.grammatizeCoord(e, r, n);
  }
  grammatizeMultiple(e, r) {
    const n = e.map((i) => this.grammatize(i, r));
    return this.mentioned = [], n;
  }
}
class U3e extends Error {
}
class Tu extends Error {
  constructor(e) {
    super(`[ParaSummary]: Problem processesing summary request.
` + e);
  }
}
const wF = Symbol.for("filter-series"), xF = Symbol.for("filter-datapoint"), V3e = Symbol.for("filter-series-datapoint"), EF = Symbol.for("filter-series-intersection"), mP = {
  [wF]: { name: "series", pattern: /^\?\(@.key === '(.+)'\)$/ },
  [xF]: { name: "datapoint", pattern: /^\?\(@.label === '(.+)' && @.value === '(.+)'\)$/ },
  [V3e]: { name: "series-datapoint", pattern: /^\?\(@.label === '(.+)'\)$/ },
  [EF]: { name: "series-intersection", pattern: /^\?\(@.series.includes\('(.+)'\)\)$/ }
};
function H3e(t, e) {
  const r = e.pattern.exec(t);
  if (r === null)
    throw new Tu(
      `Filter expression '${t}' in request did not match pattern for ${e.name}`
    );
  return r.slice(1);
}
const r2 = Symbol.for("number"), Fu = Symbol.for("end-of-request"), G3e = {
  "*": "allSeries",
  [wF]: {
    trend: "seriesTrend",
    stats: {
      max: "seriesMax",
      min: "seriesMin",
      extremes: "seriesExtremes"
    },
    datapoints: {
      [r2]: "seriesDatapoint"
    },
    record_count: "seriesRecordCount",
    ranking: "seriesRanking",
    [Fu]: "specificSeries"
  }
}, W3e = {
  $: {
    datasets: {
      0: {
        series: G3e,
        datapoints: {
          [xF]: "datapoint"
        },
        axes: {
          dependent: {
            [Fu]: "dependentAxis",
            __label: "dependentAxisLabel"
          },
          independent: {
            [Fu]: "independentAxis"
          }
        },
        intersections: {
          "*": "allIntersection",
          [r2]: "intersection",
          [EF]: {
            [Fu]: "seriesIntersections"
          }
        },
        clusters: {
          "*": "allCluster"
        },
        trackingGroups: {
          "*": "allTrackingGroup"
        },
        theme: "chartTheme",
        labels: "chartLabels",
        stats: {
          max: "chartMax",
          min: "chartMin",
          extremes: "chartExtremes"
        },
        trend: "onlySeriesTrend",
        highestRanking: "highestRanking",
        [Fu]: "chart"
      }
    }
  }
};
class q3e {
  constructor(e, r) {
    Ut(this, "cursor", 0), Ut(this, "tree", W3e), Ut(this, "args", []), this.request = e, this.parsedRequest = r;
  }
  get remainingRequest() {
    return this.parsedRequest.slice(this.cursor);
  }
  dispatch() {
    for (; ; ) {
      const e = this.processSegment();
      if (typeof e == "string")
        return [e, this.args];
      this.tree = e, this.cursor++;
    }
  }
  processSegment() {
    if (this.remainingRequest.length === 0)
      return this.endOfRequest();
    const e = this.remainingRequest[0].expression;
    if (e.type === "root")
      return this.root();
    if (e.type === "wildcard")
      return this.wildcard();
    if (e.type === "identifier") {
      const r = this.trySpecificIdentifier(e.value);
      if (r !== null)
        return r;
      throw new n2(`identifier: ${e.value}`);
    }
    if (e.type === "numeric_literal") {
      const r = e.value, n = this.trySpecificNumber(r);
      return n !== null ? n : this.anyNumber(r);
    }
    if (e.type === "filter_expression")
      return this.filter();
    throw new n2("other segment");
  }
  endOfRequest() {
    if (Fu in this.tree)
      return this.tree[Fu];
    throw new Tu("Request ended too early. Expected one of: " + Object.keys(this.tree));
  }
  root() {
    if ("$" in this.tree)
      return this.tree.$;
    throw new Tu(`The root segment "$" is not allowed at segment ${this.cursor}`);
  }
  wildcard() {
    if ("*" in this.tree)
      return this.tree["*"];
    throw new Tu(`The wildcard segment "*" is not allowed at segment ${this.cursor}`);
  }
  trySpecificIdentifier(e) {
    return e in this.tree ? this.tree[e] : null;
  }
  trySpecificNumber(e) {
    return e in this.tree ? this.tree[e] : null;
  }
  anyNumber(e) {
    if (r2 in this.tree)
      return this.args.push(String(e)), this.tree[r2];
    throw new Tu(`The numeric index "${e}" is not allowed at segment ${this.cursor}`);
  }
  filter() {
    const e = this.remainingRequest[0].expression.value, r = Object.getOwnPropertySymbols(mP).filter(
      (s) => s in this.tree
    );
    if (r.length === 0)
      throw new Tu(`The filter expression "${e}" is not allowed at segment ${this.cursor}`);
    if (r.length > 1)
      throw new Tu(`Unreachable: multiple filter expression should not exist in a tree (segment ${this.cursor})`);
    const n = r[0], i = H3e(e, mP[n]);
    return this.args.push(...i), this.tree[n];
  }
}
function U0(t) {
  return {
    name: "span",
    attributes: {
      "data-navcode": t
    }
  };
}
function Jt(t, e) {
  return we.tag({ ...t }, "span", { "data-navcode": e });
}
const SF = new DOMParser();
function Q3e(t, e) {
  const r = t.querySelector("parsererror");
  if (r)
    throw new Error(`[ParaSummary Internal]: Error in highlight parsing. 
 Error: ${r.textContent} 
 Text: ${e}`);
}
function K3e(t, e) {
  let r = SF.parseFromString(`<p>${t}</p>`, "text/xml");
  if (Q3e(r, t), r.documentElement.childNodes.length < 2)
    return t;
  let n = null, i = null, s = "";
  for (const o of r.documentElement.childNodes)
    if (n === null)
      n = o, i = n.getAttribute("data-navcode");
    else {
      const a = o.getAttribute("data-navcode");
      if (i !== null && a !== null && i === a || o.textContent === " " || o.textContent === ", " || o.textContent === ". " || o.textContent === ".  ") {
        n.textContent = n.textContent + o.textContent;
        const l = o.getAttribute("data-phrasecode"), c = e.findIndex((d) => d.phrasecode === l), p = n.getAttribute("data-phrasecode"), h = e.find((d) => d.phrasecode === p);
        h.end = e[c].end, e.splice(c, 1);
      } else
        s += n.outerHTML, n = o, i = n.getAttribute("data-navcode");
    }
  return s += n.outerHTML, s;
}
function R4(t) {
  let e = SF.parseFromString(`<p>${t}</p>`, "text/xml");
  const r = e.querySelector("parsererror");
  if (r)
    throw new Error(`[ParaSummary Internal]: Error in highlight parsing. 
 Error: ${r.textContent} 
 Text: ${t}`);
  let n = "", i = "";
  const s = [];
  let o = 0;
  for (const a of e.documentElement.childNodes) {
    const l = n.length;
    n += a.textContent;
    const c = n.length, p = o;
    if (o++, a.nodeName === "#text")
      i += `<span data-phrasecode="${p}">${a.textContent}</span>`, s.push({ start: l, end: c, phrasecode: `${p}` });
    else {
      const h = a.getAttribute("data-navcode");
      a.setAttribute("data-phrasecode", `${p}`), i += a.outerHTML, s.push({ start: l, end: c, phrasecode: `${p}`, navcode: h });
    }
  }
  return i = K3e(i, s), { text: n, html: i, highlights: s };
}
var Y3e = Object.defineProperty, Z3e = Object.getOwnPropertyDescriptor, AF = (t, e, r, n) => {
  for (var i = Z3e(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && Y3e(e, r, i), i;
};
class n2 extends Error {
  constructor(e) {
    super(`Not implemented yet: ${e}`);
  }
}
let Qr = class extends Error {
  constructor(e) {
    super("[ParaSummary]: " + e);
  }
};
function sn(t) {
  return console.warn(`[ParaSummary]: ${t}`), [];
}
function V3(t) {
  return console.warn(`[ParaSummary]: ${t}`), { text: "", html: "" };
}
const Cu = {
  seriesChartMin: "Series low and chart low",
  seriesMin: "Series low",
  seriesChartMax: "Series high and chart high",
  seriesMax: "Series high",
  firstDatapoint: "First datapoint in ${seriesLabel:string}",
  lastDatapoint: "Last datapoint in ${seriesLabel:string}",
  intersection: "Intersection between ${intersectLabels:string[]} at this point"
};
async function J3e() {
  await B3e();
}
class pb {
  constructor(e) {
    Ut(this, "grammatizator", new z3e()), this._model = e;
  }
  /**
   * Determines whether an y-value is the highest/lowest value on a series/the chart. Note: a chart
   * max/min must also be a series max/min
   * @param value The y-value
   * @param seriesKey The series being considered
   * @returns Whether the  y-value is the highest/lowest value on a series/the chart
   */
  getDatapointMinMax(e, r) {
    const n = [], i = this._model.atKey(r).getFacetStats("y").min.value, s = this._model.getFacetStats("y").min.value, o = this._model.atKey(r).getFacetStats("y").max.value, a = this._model.getFacetStats("y").max.value;
    return e === s ? n.push(Cu.seriesChartMin) : e === i && n.push(Cu.seriesMin), e === a ? n.push(Cu.seriesChartMax) : e === o && n.push(Cu.seriesMax), n;
  }
  intersectionKeys(e) {
    const r = /* @__PURE__ */ new Set();
    if (!this._model.isPlaneModel())
      return r;
    for (const n of this._model.intersections)
      n.record.labelValue !== null && n.record.labelValue === e.facetValueAsNumber("x") && n.value === e.facetValueAsNumber("y") && (r.add(n.series[0]), r.add(n.series[1]));
    return r;
  }
  getDatapointSummary(e, r) {
    const n = [], i = e.seriesKey;
    n.push(m2e(e, r));
    const s = e.facetValueAsNumber("y"), o = this.getDatapointMinMax(s, i);
    o.length && n.push(...o);
    const a = this._model.atKey(i).getLabel();
    e.datapointIndex === 0 ? n.push(qn(Cu.firstDatapoint, { seriesLabel: a })) : e.datapointIndex === this._model.atKey(i).length - 1 && n.push(qn(Cu.lastDatapoint, { seriesLabel: a }));
    const l = Array.from(this.intersectionKeys(e)).map((c) => this._model.atKey(c).getLabel());
    return l.length > 0 && n.push(qn(Cu.intersection, { intersectLabels: l })), n.join(". ") + ".";
  }
  getDatapointSummaryAllPoints(e, r) {
    return `${this._model.atKey(e.seriesKey).getLabel()}, ${e.datapointIndex}, all points`;
  }
  parseRequest(e) {
    let r;
    try {
      r = v4.parse(e);
    } catch (n) {
      throw n instanceof Error && (n.message.startsWith("Parse error") || n.message.startsWith("Lexical error")) ? new U3e(`[ParaSummary]: Summary request is not a valid JSONPath
` + n.message) : n;
    }
    return r;
  }
  dispatchRequest(e, r) {
    return new q3e(e, r).dispatch();
  }
  async requestSummary(e) {
    const r = this.parseRequest(e), [n, i] = this.dispatchRequest(e, r), s = this.getSummarizer()[n].call(this.getSummarizer(), ...i);
    return Promise.resolve(s);
  }
  async requestSummaries(e) {
    const r = e.map((n) => this.requestSummary(n));
    return Promise.all(r).then((n) => n.flat());
  }
  grammatizeComponents(e) {
    return this.grammatizator.grammatizeMultiple(e, "en").map((r) => r.toString()).join(" ").trim();
  }
  highlightComponents(e) {
    const r = this.grammatizeComponents(e);
    return R4(r);
  }
  async grammatizeSummaries(e) {
    const r = await this.requestSummaries(e);
    return this.grammatizeComponents(r);
  }
  async highlightSummaries(e) {
    const r = await this.grammatizeSummaries(e);
    return R4(r);
  }
}
AF([
  $d()
], pb.prototype, "getDatapointSummary");
AF([
  $d()
], pb.prototype, "getDatapointSummaryAllPoints");
function X3e(t) {
  if (t.length === 0)
    return 0;
  var e = t[0], r = 0, n;
  if (typeof e != "number")
    return Number.NaN;
  for (var i = 1; i < t.length; i++) {
    if (typeof t[i] != "number")
      return Number.NaN;
    n = e + t[i], Math.abs(e) >= Math.abs(t[i]) ? r += e - n + t[i] : r += t[i] - n + e, e = n;
  }
  return e + r;
}
function exe(t) {
  if (t.length === 0)
    throw new Error("mean requires at least one data point");
  return X3e(t) / t.length;
}
function txe(t, e) {
  const r = [];
  for (let n = 0; n < t; n++)
    r.push(e(n));
  return r;
}
function Li(t, e, r, n, i) {
  return ja(e, ((s, o) => {
    const a = s[o];
    if (a === void 0)
      throw new TypeError(FA(o));
    return a;
  })(t, e), r, n, i);
}
function ja(t, e, r, n, i, s) {
  const o = H0(e, r, n);
  if (i && e !== o)
    throw new RangeError(jz(t, e, r, n, s));
  return o;
}
function xi(t) {
  return t !== null && /object|function/.test(typeof t);
}
function ws(t, e = Map) {
  const r = new e();
  return (n, ...i) => {
    if (r.has(n))
      return r.get(n);
    const s = t(n, ...i);
    return r.set(n, s), s;
  };
}
function V0(t) {
  return nd({
    name: t
  }, 1);
}
function nd(t, e) {
  return Ba((r) => ({
    value: r,
    configurable: 1,
    writable: !e
  }), t);
}
function rxe(t) {
  return Ba((e) => ({
    get: e,
    configurable: 1
  }), t);
}
function q8(t) {
  return {
    [Symbol.toStringTag]: {
      value: t,
      configurable: 1
    }
  };
}
function Zd(t, e) {
  const r = {};
  let n = t.length;
  for (const i of e)
    r[t[--n]] = i;
  return r;
}
function Ba(t, e, r) {
  const n = {};
  for (const i in e)
    n[i] = t(e[i], i, r);
  return n;
}
function db(t, e, r) {
  const n = {};
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    n[s] = t(s, i, r);
  }
  return n;
}
function kF(t, e, r) {
  const n = {};
  for (let i = 0; i < t.length; i++)
    n[e[i]] = r[t[i]];
  return n;
}
function fo(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const n of t)
    r[n] = e[n];
  return r;
}
function yP(t, e) {
  for (const r of e)
    if (r in t)
      return 1;
  return 0;
}
function _F(t, e, r) {
  for (const n of t)
    if (e[n] !== r[n])
      return 0;
  return 1;
}
function CF(t, e, r) {
  const n = {
    ...r
  };
  for (let i = 0; i < e; i++)
    n[t[i]] = 0;
  return n;
}
function sr(t, ...e) {
  return (...r) => t(...e, ...r);
}
function vP(t) {
  return t[0].toUpperCase() + t.substring(1);
}
function om(t) {
  return t.slice().sort();
}
function i2(t, e) {
  return String(e).padStart(t, "0");
}
function Vl(t, e) {
  return Math.sign(t - e);
}
function H0(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
function ka(t, e) {
  return [Math.floor(t / e), e0(t, e)];
}
function e0(t, e) {
  return (t % e + e) % e;
}
function sc(t, e) {
  return [fb(t, e), Q8(t, e)];
}
function fb(t, e) {
  return Math.trunc(t / e) || 0;
}
function Q8(t, e) {
  return t % e || 0;
}
function Ym(t) {
  return Math.abs(t % 1) === 0.5;
}
function IF(t, e, r) {
  let n = 0, i = 0;
  for (let a = 0; a <= e; a++) {
    const l = t[r[a]], c = Ko[a], p = zr / c, [h, d] = sc(l, p);
    n += d * c, i += h;
  }
  const [s, o] = sc(n, zr);
  return [i + s, o];
}
function gb(t, e, r) {
  const n = {};
  for (let i = e; i >= 0; i--) {
    const s = Ko[i];
    n[r[i]] = fb(t, s), t = Q8(t, s);
  }
  return n;
}
function nxe(t) {
  if (t !== void 0)
    return ei(t);
}
function ixe(t) {
  if (t !== void 0)
    return ga(t);
}
function PF(t) {
  if (t !== void 0)
    return K8(t);
}
function ga(t) {
  return TF(K8(t));
}
function K8(t) {
  return OF(fEe(t));
}
function RF(t, e) {
  if (e == null)
    throw new RangeError(FA(t));
  return e;
}
function am(t) {
  if (!xi(t))
    throw new TypeError(B4e);
  return t;
}
function Y8(t, e, r = t) {
  if (typeof e !== t)
    throw new TypeError(Qc(r, e));
  return e;
}
function OF(t, e = "number") {
  if (!Number.isInteger(t))
    throw new RangeError(L4e(e, t));
  return t || 0;
}
function TF(t, e = "number") {
  if (t <= 0)
    throw new RangeError(M4e(e, t));
  return t;
}
function Z8(t) {
  if (typeof t == "symbol")
    throw new TypeError(j4e);
  return String(t);
}
function $1(t, e) {
  return xi(t) ? String(t) : ei(t, e);
}
function J8(t) {
  if (typeof t == "string")
    return BigInt(t);
  if (typeof t != "bigint")
    throw new TypeError($4e(t));
  return t;
}
function LF(t, e = "number") {
  if (typeof t == "bigint")
    throw new TypeError(D4e(e));
  if (t = Number(t), !Number.isFinite(t))
    throw new RangeError(N4e(e, t));
  return t;
}
function oi(t, e) {
  return Math.trunc(LF(t, e)) || 0;
}
function X8(t, e) {
  return OF(LF(t, e), e);
}
function bP(t, e) {
  return TF(oi(t, e), e);
}
function eA(t, e) {
  let [r, n] = sc(e, zr), i = t + r;
  const s = Math.sign(i);
  return s && s === -Math.sign(n) && (i -= s, n += s * zr), [i, n];
}
function id(t, e, r = 1) {
  return eA(t[0] + e[0] * r, t[1] + e[1] * r);
}
function xh(t, e) {
  return eA(t[0], t[1] + e);
}
function qo(t, e) {
  return id(e, t, -1);
}
function xs(t, e) {
  return Vl(t[0], e[0]) || Vl(t[1], e[1]);
}
function MF(t, e, r) {
  return xs(t, e) === -1 || xs(t, r) === 1;
}
function tA(t, e = 1) {
  const r = BigInt(zr / e);
  return [Number(t / r), Number(t % r) * e];
}
function s2(t, e = 1) {
  const r = zr / e, [n, i] = sc(t, r);
  return [n, i * e];
}
function Qo(t, e = 1, r) {
  const [n, i] = t, [s, o] = sc(i, e);
  return n * (zr / e) + (s + (r ? o / e : 0));
}
function rA(t, e, r = ka) {
  const [n, i] = t, [s, o] = r(i, e);
  return [n * (zr / e) + s, o];
}
function nA(t) {
  return Li(t, "isoYear", Y0, K0, 1), t.isoYear === Y0 ? Li(t, "isoMonth", 4, 12, 1) : t.isoYear === K0 && Li(t, "isoMonth", 1, 9, 1), t;
}
function Us(t) {
  return Yi({
    ...t,
    ...Zi,
    isoHour: 12
  }), t;
}
function Yi(t) {
  const e = Li(t, "isoYear", Y0, K0, 1), r = e === Y0 ? 1 : e === K0 ? -1 : 0;
  return r && oa(On({
    ...t,
    isoDay: t.isoDay + r,
    isoNanosecond: t.isoNanosecond - r
  })), t;
}
function oa(t) {
  if (!t || MF(t, EEe, xEe))
    throw new RangeError(Kc);
  return t;
}
function oc(t) {
  return IF(t, 5, yo)[1];
}
function mb(t) {
  const [e, r] = ka(t, zr);
  return [gb(r, 5, yo), e];
}
function wP(t) {
  return rA(t, $o);
}
function hi(t) {
  return Jd(t.isoYear, t.isoMonth, t.isoDay, t.isoHour, t.isoMinute, t.isoSecond, t.isoMillisecond);
}
function On(t) {
  const e = hi(t);
  if (e !== void 0) {
    const [r, n] = sc(e, Fi);
    return [r, n * sl + (t.isoMicrosecond || 0) * fm + (t.isoNanosecond || 0)];
  }
}
function iA(t, e) {
  const [r, n] = mb(oc(t) - e);
  return oa(On({
    ...t,
    isoDay: t.isoDay + n,
    ...r
  }));
}
function o2(...t) {
  return Jd(...t) / qz;
}
function Jd(...t) {
  const [e, r] = NF(...t), n = e.valueOf();
  if (!isNaN(n))
    return n - r * Fi;
}
function NF(t, e = 1, r = 1, n = 0, i = 0, s = 0, o = 0) {
  const a = t === Y0 ? 1 : t === K0 ? -1 : 0, l = /* @__PURE__ */ new Date();
  return l.setUTCHours(n, i, s, o), l.setUTCFullYear(t, e - 1, r + a), [l, a];
}
function Xd(t, e) {
  let [r, n] = xh(t, e);
  n < 0 && (n += zr, r -= 1);
  const [i, s] = ka(n, sl), [o, a] = ka(s, fm);
  return yb(r * Fi + i, o, a);
}
function yb(t, e = 0, r = 0) {
  const n = Math.ceil(Math.max(0, Math.abs(t) - wEe) / Fi) * Math.sign(t), i = new Date(t - n * Fi);
  return Zd(jb, [i.getUTCFullYear(), i.getUTCMonth() + 1, i.getUTCDate() + n, i.getUTCHours(), i.getUTCMinutes(), i.getUTCSeconds(), i.getUTCMilliseconds(), e, r]);
}
function sA(t, e) {
  if (e < -864e13)
    throw new RangeError(Kc);
  const r = t.formatToParts(e), n = {};
  for (const i of r)
    n[i.type] = i.value;
  return n;
}
function oA(t) {
  return [t.isoYear, t.isoMonth, t.isoDay];
}
function DF(t, e) {
  return [e, 0];
}
function $F() {
  return vl;
}
function jF(t, e) {
  switch (e) {
    case 2:
      return aA(t) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function BF(t) {
  return aA(t) ? 366 : 365;
}
function aA(t) {
  return t % 4 == 0 && (t % 100 != 0 || t % 400 == 0);
}
function FF(t) {
  const [e, r] = NF(t.isoYear, t.isoMonth, t.isoDay);
  return e0(e.getUTCDay() - r, 7) || 7;
}
function zF(t) {
  return this.id === lf ? (({ isoYear: e }) => e < 1 ? ["gregory-inverse", 1 - e] : ["gregory", e])(t) : this.id === cc ? kEe(t) : [];
}
function sxe(t) {
  const e = hi(t);
  if (e < AEe) {
    const { isoYear: s } = t;
    return s < 1 ? ["japanese-inverse", 1 - s] : ["japanese", s];
  }
  const r = sA(ok(cc), e), { era: n, eraYear: i } = Cz(r, cc);
  return [n, i];
}
function vb(t) {
  return Wh(t), ef(t, 1), t;
}
function Wh(t) {
  return UF(t, 1), t;
}
function xP(t) {
  return _F(KA, t, UF(t));
}
function UF(t, e) {
  const { isoYear: r } = t, n = Li(t, "isoMonth", 1, $F(), e);
  return {
    isoYear: r,
    isoMonth: n,
    isoDay: Li(t, "isoDay", 1, jF(r, n), e)
  };
}
function ef(t, e) {
  return Zd(yo, [Li(t, "isoHour", 0, 23, e), Li(t, "isoMinute", 0, 59, e), Li(t, "isoSecond", 0, 59, e), Li(t, "isoMillisecond", 0, 999, e), Li(t, "isoMicrosecond", 0, 999, e), Li(t, "isoNanosecond", 0, 999, e)]);
}
function mr(t) {
  return t === void 0 ? 0 : cU(am(t));
}
function bb(t, e = 0) {
  t = aa(t);
  const r = uU(t), n = NEe(t, e);
  return [cU(t), n, r];
}
function tf(t, e, r, n = 9, i = 0, s = 4) {
  e = aa(e);
  let o = lU(e, n, i), a = uA(e), l = ym(e, s);
  const c = mm(e, n, i, 1);
  return o == null ? o = Math.max(r, c) : WF(o, c), a = hA(a, c, 1), t && (l = ((p) => p < 4 ? (p + 2) % 4 : p)(l)), [o, c, a, l];
}
function wb(t, e = 6, r) {
  let n = uA(t = xb(t, p2));
  const i = ym(t, 7);
  let s = mm(t, e);
  return s = RF(p2, s), n = hA(n, s, void 0, r), [s, n, i];
}
function lA(t) {
  return ZA(aa(t));
}
function VF(t, e) {
  return cA(aa(t), e);
}
function oxe(t) {
  const e = xb(t, Z3), r = Vc(Z3, LEe, e, 0);
  if (!r)
    throw new RangeError(Qc(Z3, r));
  return r;
}
function cA(t, e = 4) {
  const r = GF(t);
  return [ym(t, 4), ...HF(mm(t, e), r)];
}
function HF(t, e) {
  return t != null ? [Ko[t], t < 4 ? 9 - 3 * t : -1] : [e === void 0 ? 1 : 10 ** (9 - e), e];
}
function uA(t) {
  const e = t[t0];
  return e === void 0 ? 1 : oi(e, t0);
}
function hA(t, e, r, n) {
  const i = n ? zr : Ko[e + 1];
  if (i) {
    const s = Ko[e];
    if (i % ((t = ja(t0, t, 1, i / s - (n ? 0 : 1), 1)) * s))
      throw new RangeError(Qc(t0, t));
  } else
    t = ja(t0, t, 1, r ? 10 ** 9 : 1, 1);
  return t;
}
function GF(t) {
  let e = t[Y3];
  if (e !== void 0) {
    if (typeof e != "number") {
      if (Z8(e) === "auto")
        return;
      throw new RangeError(Qc(Y3, e));
    }
    e = ja(Y3, Math.floor(e), 0, 9, 1);
  }
  return e;
}
function aa(t) {
  return t === void 0 ? {} : am(t);
}
function xb(t, e) {
  return typeof t == "string" ? {
    [e]: t
  } : am(t);
}
function Eb(t) {
  return {
    overflow: _Ee[t]
  };
}
function pA(t, e, r = 9, n = 0, i) {
  let s = e[t];
  if (s === void 0)
    return i ? n : void 0;
  if (s = Z8(s), s === "auto")
    return i ? n : null;
  let o = M4[s];
  if (o === void 0 && (o = yEe[s]), o === void 0)
    throw new RangeError(Fz(t, s, M4));
  return ja(t, o, n, r, 1, zA), o;
}
function Vc(t, e, r, n = 0) {
  const i = r[t];
  if (i === void 0)
    return n;
  const s = Z8(i), o = e[s];
  if (o === void 0)
    throw new RangeError(Fz(t, s, e));
  return o;
}
function WF(t, e) {
  if (e > t)
    throw new RangeError(oEe);
}
function nl(t) {
  return {
    branding: tk,
    epochNanoseconds: t
  };
}
function go(t, e, r) {
  return {
    branding: Yc,
    calendar: r,
    timeZone: e,
    epochNanoseconds: t
  };
}
function mo(t, e = t.calendar) {
  return {
    branding: cf,
    calendar: e,
    ...fo(vEe, t)
  };
}
function il(t, e = t.calendar) {
  return {
    branding: vm,
    calendar: e,
    ...fo(YA, t)
  };
}
function G0(t, e = t.calendar) {
  return {
    branding: JA,
    calendar: e,
    ...fo(YA, t)
  };
}
function a2(t, e = t.calendar) {
  return {
    branding: XA,
    calendar: e,
    ...fo(YA, t)
  };
}
function la(t) {
  return {
    branding: ek,
    ...fo(nU, t)
  };
}
function wn(t) {
  return {
    branding: rk,
    sign: Hc(t),
    ...fo(WA, t)
  };
}
function dA(t) {
  return rA(t.epochNanoseconds, sl)[0];
}
function axe(t) {
  return ((e, r = 1) => {
    const [n, i] = e, s = Math.floor(i / r), o = zr / r;
    return BigInt(n) * BigInt(o) + BigInt(s);
  })(t.epochNanoseconds);
}
function qF(t) {
  return t.epochNanoseconds;
}
function lxe(t, e, r, n, i) {
  const s = Eh(n), [o, a] = ((E, A) => {
    const x = A((E = xb(E, $4))[oU]);
    let g = MEe(E);
    return g = RF($4, g), [g, x];
  })(i, t), l = Math.max(o, s);
  if (!a && q0(l, a))
    return EP(n, o);
  if (!a)
    throw new RangeError(Nb);
  if (!n.sign)
    return 0;
  const [c, p, h] = Cb(e, r, a), d = EA(h), v = Ib(h), m = SA(h), b = v(p, c, n);
  sd(a) || (Yi(c), Yi(b));
  const f = m(p, c, b, o);
  return q0(o, a) ? EP(f, o) : ((E, A, x, g, w, _, S) => {
    const R = Hc(E), [L, F] = fA(g, QA(x, E), x, R, w, _, S), z = gA(A, L, F);
    return E[xr[x]] + z * R;
  })(f, d(b), o, p, c, d, v);
}
function EP(t, e) {
  return Qo($n(t), Ko[e], 1);
}
function fA(t, e, r, n, i, s, o) {
  const a = xr[r], l = {
    ...e,
    [a]: e[a] + n
  }, c = o(t, i, e), p = o(t, i, l);
  return [s(c), s(p)];
}
function gA(t, e, r) {
  const n = Qo(qo(e, r));
  if (!n)
    throw new RangeError(af);
  return Qo(qo(e, t)) / n;
}
function cxe(t, e) {
  const [r, n, i] = wb(e, 5, 1);
  return nl(Ab(t.epochNanoseconds, r, n, i, 1));
}
function uxe(t, e, r) {
  let { epochNanoseconds: n, timeZone: i, calendar: s } = e;
  const [o, a, l] = wb(r);
  if (o === 0 && a === 1)
    return e;
  const c = t(i);
  if (o === 6)
    n = ((p, h, d, v) => {
      const m = Ss(d, h), [b, f] = p(m), E = d.epochNanoseconds, A = lc(h, b), x = lc(h, f);
      if (MF(E, A, x))
        throw new RangeError(af);
      return JF(gA(E, A, x), v) ? x : A;
    })(YF, c, e, l);
  else {
    const p = c.R(n);
    n = rf(c, QF(Xd(n, p), o, a, l), p, 2, 0, 1);
  }
  return go(n, i, s);
}
function hxe(t, e) {
  return mo(QF(t, ...wb(e)), t.calendar);
}
function pxe(t, e) {
  const [r, n, i] = wb(e, 5);
  var s;
  return la((s = i, mA(t, lm(r, n), s)[0]));
}
function dxe(t, e) {
  const r = t(e.timeZone), n = Ss(e, r), [i, s] = YF(n), o = Qo(qo(lc(r, i), lc(r, s)), $b, 1);
  if (o <= 0)
    throw new RangeError(af);
  return o;
}
function fxe(t, e) {
  const { timeZone: r, calendar: n } = e, i = ((s, o, a) => lc(o, s(Ss(a, o))))(ZF, t(r), e);
  return go(i, r, n);
}
function QF(t, e, r, n) {
  return KF(t, lm(e, r), n);
}
function KF(t, e, r) {
  const [n, i] = mA(t, e, r);
  return Yi({
    ...qh(t, i),
    ...n
  });
}
function mA(t, e, r) {
  return mb(ac(oc(t), e, r));
}
function l2(t) {
  return ac(t, Db, 7);
}
function lm(t, e) {
  return Ko[t] * e;
}
function YF(t) {
  const e = ZF(t);
  return [e, qh(e, 1)];
}
function ZF(t) {
  return bEe(6, t);
}
function gxe(t, e, r) {
  const n = Math.min(Eh(t), 6);
  return nf(kb($n(t, n), e, r), n);
}
function Sb(t, e, r, n, i, s, o, a, l, c) {
  if (n === 0 && i === 1)
    return t;
  const p = q0(n, a) ? sd(a) && n < 6 && r >= 6 ? yxe : mxe : vxe;
  let [h, d, v] = p(t, e, r, n, i, s, o, a, l, c);
  return v && n !== 7 && (h = ((m, b, f, E, A, x, g, w) => {
    const _ = Hc(m);
    for (let S = E + 1; S <= f; S++) {
      if (S === 7 && f !== 7)
        continue;
      const R = QA(S, m);
      R[xr[S]] += _;
      const L = Qo(qo(g(w(A, x, R)), b));
      if (L && Math.sign(L) !== _)
        break;
      m = R;
    }
    return m;
  })(h, d, r, Math.max(6, n), o, a, l, c)), h;
}
function Ab(t, e, r, n, i) {
  if (e === 6) {
    const s = ((o) => o[0] + o[1] / zr)(t);
    return [ac(s, r, n), 0];
  }
  return kb(t, lm(e, r), n, i);
}
function kb(t, e, r, n) {
  let [i, s] = t;
  n && s < 0 && (s += zr, i -= 1);
  const [o, a] = ka(ac(s, e, r), zr);
  return eA(i + o, a);
}
function ac(t, e, r) {
  return JF(t / e, r) * e;
}
function JF(t, e) {
  return jEe[e](t);
}
function mxe(t, e, r, n, i, s) {
  const o = Hc(t), a = $n(t), l = Ab(a, n, i, s), c = qo(a, l), p = Math.sign(l[0] - a[0]) === o, h = nf(l, Math.min(r, 6));
  return [{
    ...t,
    ...h
  }, id(e, c), p];
}
function yxe(t, e, r, n, i, s, o, a, l, c) {
  const p = Hc(t) || 1, h = Qo($n(t, 5)), d = lm(n, i);
  let v = ac(h, d, s);
  const [m, b] = fA(o, {
    ...t,
    ...qA
  }, 6, p, a, l, c), f = v - Qo(qo(m, b));
  let E = 0;
  f && Math.sign(f) !== p ? e = xh(m, v) : (E += p, v = ac(f, d, s), e = xh(b, v));
  const A = Pb(v);
  return [{
    ...t,
    ...A,
    days: t.days + E
  }, e, !!E];
}
function vxe(t, e, r, n, i, s, o, a, l, c) {
  const p = Hc(t), h = xr[n], d = QA(n, t);
  n === 7 && (t = {
    ...t,
    weeks: t.weeks + Math.trunc(t.days / 7)
  });
  const v = fb(t[h], i) * i;
  d[h] = v;
  const [m, b] = fA(o, d, n, i * p, a, l, c), f = v + gA(e, m, b) * p * i, E = ac(f, i, s), A = Math.sign(E - f) === p;
  return d[h] = E, [d, A ? b : m, A];
}
function SP(t, e, r, n) {
  const [i, s, o, a] = ((c) => {
    const p = cA(c = aa(c));
    return [c.timeZone, ...p];
  })(n), l = i !== void 0;
  return ((c, p, h, d, v, m) => {
    h = kb(h, v, d, 1);
    const b = p.R(h);
    return yA(Xd(h, b), m) + (c ? cm(l2(b)) : "Z");
  })(l, e(l ? t(i) : Zh), r.epochNanoseconds, s, o, a);
}
function AP(t, e, r) {
  const [n, i, s, o, a, l] = ((c) => {
    c = aa(c);
    const p = ZA(c), h = GF(c), d = $Ee(c), v = ym(c, 4), m = mm(c, 4);
    return [p, DEe(c), d, v, ...HF(m, h)];
  })(r);
  return ((c, p, h, d, v, m, b, f, E, A) => {
    d = kb(d, E, f, 1);
    const x = c(h).R(d);
    return yA(Xd(d, x), A) + cm(l2(x), b) + ((g, w) => w !== 1 ? "[" + (w === 2 ? "!" : "") + g + "]" : "")(h, m) + vA(p, v);
  })(t, e.calendar, e.timeZone, e.epochNanoseconds, n, i, s, o, a, l);
}
function kP(t, e) {
  const [r, n, i, s] = ((c) => (c = aa(c), [ZA(c), ...cA(c)]))(e);
  return o = t.calendar, a = r, l = s, yA(KF(t, i, n), l) + vA(o, a);
  var o, a, l;
}
function _P(t, e) {
  return r = t.calendar, n = t, i = lA(e), c2(n) + vA(r, i);
  var r, n, i;
}
function CP(t, e) {
  return XF(t.calendar, ez, t, lA(e));
}
function IP(t, e) {
  return XF(t.calendar, bxe, t, lA(e));
}
function PP(t, e) {
  const [r, n, i] = VF(e);
  return s = i, tz(mA(t, n, r)[0], s);
  var s;
}
function H3(t, e) {
  const [r, n, i] = VF(e, 3);
  return n > 1 && Qh(t = {
    ...t,
    ...gxe(t, n, r)
  }), ((s, o) => {
    const { sign: a } = s, l = a === -1 ? Ei(s) : s, { hours: c, minutes: p } = l, [h, d] = rA($n(l, 3), $o, sc);
    sz(h);
    const v = bA(d, o), m = o >= 0 || !a || v;
    return (a < 0 ? "-" : "") + "P" + RP({
      Y: Iu(l.years),
      M: Iu(l.months),
      W: Iu(l.weeks),
      D: Iu(l.days)
    }) + (c || p || h || m ? "T" + RP({
      H: Iu(c),
      M: Iu(p),
      S: Iu(h, m) + v
    }) : "");
  })(t, i);
}
function XF(t, e, r, n) {
  const i = n > 1 || n === 0 && t !== hr;
  return n === 1 ? t === hr ? e(r) : c2(r) : i ? c2(r) + rz(t, n === 2) : e(r);
}
function RP(t) {
  const e = [];
  for (const r in t) {
    const n = t[r];
    n && e.push(n, r);
  }
  return e.join("");
}
function yA(t, e) {
  return c2(t) + "T" + tz(t, e);
}
function c2(t) {
  return ez(t) + "-" + Vs(t.isoDay);
}
function ez(t) {
  const { isoYear: e } = t;
  return (e < 0 || e > 9999 ? nz(e) + i2(6, Math.abs(e)) : i2(4, e)) + "-" + Vs(t.isoMonth);
}
function bxe(t) {
  return Vs(t.isoMonth) + "-" + Vs(t.isoDay);
}
function tz(t, e) {
  const r = [Vs(t.isoHour), Vs(t.isoMinute)];
  return e !== -1 && r.push(Vs(t.isoSecond) + ((n, i, s, o) => bA(n * sl + i * fm + s, o))(t.isoMillisecond, t.isoMicrosecond, t.isoNanosecond, e)), r.join(":");
}
function cm(t, e = 0) {
  if (e === 1)
    return "";
  const [r, n] = ka(Math.abs(t), $b), [i, s] = ka(n, Db), [o, a] = ka(s, $o);
  return nz(t) + Vs(r) + ":" + Vs(i) + (o || a ? ":" + Vs(o) + bA(a) : "");
}
function vA(t, e) {
  return e !== 1 && (e > 1 || e === 0 && t !== hr) ? rz(t, e === 2) : "";
}
function rz(t, e) {
  return "[" + (e ? "!" : "") + "u-ca=" + t + "]";
}
function bA(t, e) {
  let r = i2(9, t);
  return r = e === void 0 ? r.replace(zEe, "") : r.slice(0, e), r ? "." + r : "";
}
function nz(t) {
  return t < 0 ? "-" : "+";
}
function Iu(t, e) {
  return t || e ? t.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function wxe(t, e) {
  const { epochNanoseconds: r } = t, n = (e.R ? e : e(t.timeZone)).R(r), i = Xd(r, n);
  return {
    calendar: t.calendar,
    ...i,
    offsetNanoseconds: n
  };
}
function rf(t, e, r, n = 0, i = 0, s, o) {
  if (r !== void 0 && n === 1 && (n === 1 || o))
    return iA(e, r);
  const a = t.I(e);
  if (r !== void 0 && n !== 3) {
    const l = ((c, p, h, d) => {
      const v = On(p);
      d && (h = l2(h));
      for (const m of c) {
        let b = Qo(qo(m, v));
        if (d && (b = l2(b)), b === h)
          return m;
      }
    })(a, e, r, s);
    if (l !== void 0)
      return l;
    if (n === 0)
      throw new RangeError(eEe);
  }
  return o ? On(e) : um(t, e, i, a);
}
function um(t, e, r = 0, n = t.I(e)) {
  if (n.length === 1)
    return n[0];
  if (r === 1)
    throw new RangeError(tEe);
  if (n.length)
    return n[r === 3 ? 1 : 0];
  const i = On(e), s = ((a, l) => {
    const c = a.R(xh(l, -864e11));
    return ((p) => {
      if (p > zr)
        throw new RangeError(X4e);
      return p;
    })(a.R(xh(l, zr)) - c);
  })(t, i), o = s * (r === 2 ? -1 : 1);
  return (n = t.I(Xd(i, o)))[r === 2 ? 0 : n.length - 1];
}
function lc(t, e) {
  const r = t.I(e);
  if (r.length)
    return r[0];
  const n = xh(On(e), -864e11);
  return t.O(n, 1);
}
function OP(t, e, r) {
  return nl(oa(id(e.epochNanoseconds, ((n) => {
    if (oz(n))
      throw new RangeError(iEe);
    return $n(n, 5);
  })(t ? Ei(r) : r))));
}
function TP(t, e, r, n, i, s = /* @__PURE__ */ Object.create(null)) {
  const o = e(n.timeZone), a = t(n.calendar);
  return {
    ...n,
    ...wA(o, a, n, r ? Ei(i) : i, s)
  };
}
function LP(t, e, r, n, i = /* @__PURE__ */ Object.create(null)) {
  const { calendar: s } = r;
  return mo(xA(t(s), r, e ? Ei(n) : n, i), s);
}
function MP(t, e, r, n, i) {
  const { calendar: s } = r;
  return il(_b(t(s), r, e ? Ei(n) : n, i), s);
}
function NP(t, e, r, n, i) {
  const s = r.calendar, o = t(s);
  let a = Us(W0(o, r));
  e && (n = AA(n)), n.sign < 0 && (a = o.P(a, {
    ...jn,
    months: 1
  }), a = qh(a, -1));
  const l = o.P(a, n, i);
  return G0(W0(o, l), s);
}
function DP(t, e, r) {
  return la(iz(e, t ? Ei(r) : r)[0]);
}
function wA(t, e, r, n, i) {
  const s = $n(n, 5);
  let o = r.epochNanoseconds;
  if (oz(n)) {
    const a = Ss(r, t);
    o = id(um(t, {
      ..._b(e, a, {
        ...n,
        ...qA
      }, i),
      ...fo(yo, a)
    }), s);
  } else
    o = id(o, s), mr(i);
  return {
    epochNanoseconds: oa(o)
  };
}
function xA(t, e, r, n) {
  const [i, s] = iz(e, r);
  return Yi({
    ..._b(t, e, {
      ...r,
      ...qA,
      days: r.days + s
    }, n),
    ...i
  });
}
function _b(t, e, r, n) {
  if (r.years || r.months || r.weeks)
    return t.P(e, r, n);
  mr(n);
  const i = r.days + $n(r, 5)[0];
  return i ? Us(qh(e, i)) : e;
}
function W0(t, e, r = 1) {
  return qh(e, r - t.day(e));
}
function iz(t, e) {
  const [r, n] = $n(e, 5), [i, s] = mb(oc(t) + n);
  return [i, r + s];
}
function qh(t, e) {
  return e ? {
    ...t,
    ...yb(hi(t) + e * Fi)
  } : t;
}
function Cb(t, e, r) {
  const n = t(r.calendar);
  return sd(r) ? [r, n, e(r.timeZone)] : [{
    ...r,
    ...Zi
  }, n];
}
function EA(t) {
  return t ? qF : On;
}
function Ib(t) {
  return t ? sr(wA, t) : xA;
}
function SA(t) {
  return t ? sr(Hxe, t) : Gxe;
}
function sd(t) {
  return t && t.epochNanoseconds;
}
function q0(t, e) {
  return t <= 6 - (sd(e) ? 1 : 0);
}
function $P(t, e, r, n, i, s, o) {
  const a = t(aa(o).relativeTo), l = Math.max(Eh(i), Eh(s));
  if (q0(l, a))
    return wn(Qh(((b, f, E, A) => {
      const x = id($n(b), $n(f), A ? -1 : 1);
      if (!Number.isFinite(x[0]))
        throw new RangeError(Kc);
      return {
        ...jn,
        ...nf(x, E)
      };
    })(i, s, l, n)));
  if (!a)
    throw new RangeError(Nb);
  n && (s = Ei(s));
  const [c, p, h] = Cb(e, r, a), d = Ib(h), v = SA(h), m = d(p, c, i);
  return wn(v(p, c, d(p, m, s), l));
}
function xxe(t, e, r, n, i) {
  const s = Eh(n), [o, a, l, c, p] = ((_, S, R) => {
    _ = xb(_, p2);
    let L = lU(_);
    const F = R(_[oU]);
    let z = uA(_);
    const j = ym(_, 7);
    let W = mm(_);
    if (L === void 0 && W === void 0)
      throw new RangeError(sEe);
    if (W == null && (W = 0), L == null && (L = Math.max(W, S)), WF(L, W), z = hA(z, W, 1), z > 1 && W > 5 && L !== W)
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    return [L, W, z, j, F];
  })(i, s, t), h = Math.max(s, o);
  if (!p && h <= 6)
    return wn(Qh(((_, S, R, L, F) => {
      const z = Ab($n(_), R, L, F);
      return {
        ...jn,
        ...nf(z, S)
      };
    })(n, o, a, l, c)));
  if (!sd(p) && !n.sign)
    return n;
  if (!p)
    throw new RangeError(Nb);
  const [d, v, m] = Cb(e, r, p), b = EA(m), f = Ib(m), E = SA(m), A = f(v, d, n);
  sd(p) || (Yi(d), Yi(A));
  let x = E(v, d, A, o);
  const g = n.sign, w = Hc(x);
  if (g && w && g !== w)
    throw new RangeError(af);
  return x = Sb(x, b(A), o, a, l, c, v, d, b, f), wn(x);
}
function Exe(t) {
  return t.sign === -1 ? AA(t) : t;
}
function AA(t) {
  return wn(Ei(t));
}
function Ei(t) {
  const e = {};
  for (const r of xr)
    e[r] = -1 * t[r] || 0;
  return e;
}
function Sxe(t) {
  return !t.sign;
}
function Hc(t, e = xr) {
  let r = 0;
  for (const n of e) {
    const i = Math.sign(t[n]);
    if (i) {
      if (r && r !== i)
        throw new RangeError(nEe);
      r = i;
    }
  }
  return r;
}
function Qh(t) {
  for (const e of mEe)
    ja(e, t[e], -4294967295, UEe, 1);
  return sz(Qo($n(t), $o)), t;
}
function sz(t) {
  if (!Number.isSafeInteger(t))
    throw new RangeError(rEe);
}
function $n(t, e = 6) {
  return IF(t, e, xr);
}
function nf(t, e = 6) {
  const [r, n] = t, i = gb(n, e, xr);
  if (i[xr[e]] += r * (zr / Ko[e]), !Number.isFinite(i[xr[e]]))
    throw new RangeError(Kc);
  return i;
}
function Pb(t, e = 5) {
  return gb(t, e, xr);
}
function oz(t) {
  return !!Hc(t, rU);
}
function Eh(t) {
  let e = 9;
  for (; e > 0 && !t[xr[e]]; e--)
    ;
  return e;
}
function Axe(t, e) {
  return [t, e];
}
function jP(t) {
  const e = Math.floor(t / B1) * B1;
  return [e, e + B1];
}
function kxe(t) {
  const e = Gc(t = $1(t));
  if (!e)
    throw new RangeError(Di(t));
  let r;
  if (e.j)
    r = 0;
  else {
    if (!e.offset)
      throw new RangeError(Di(t));
    r = Kh(e.offset);
  }
  return e.timeZone && PA(e.timeZone, 1), nl(iA(vb(e), r));
}
function _xe(t) {
  const e = Gc(ei(t));
  if (!e)
    throw new RangeError(Di(t));
  if (e.timeZone)
    return az(e, e.offset ? Kh(e.offset) : void 0);
  if (e.j)
    throw new RangeError(Di(t));
  return cz(e);
}
function Cxe(t, e) {
  const r = Gc(ei(t));
  if (!r || !r.timeZone)
    throw new RangeError(Di(t));
  const { offset: n } = r, i = n ? Kh(n) : void 0, [, s, o] = bb(e);
  return az(r, i, s, o);
}
function Kh(t) {
  const e = PA(t);
  if (e === void 0)
    throw new RangeError(Di(t));
  return e;
}
function Ixe(t) {
  const e = Gc(ei(t));
  if (!e || e.j)
    throw new RangeError(Di(t));
  return mo(lz(e));
}
function kA(t, e, r) {
  let n = Gc(ei(t));
  if (!n || n.j)
    throw new RangeError(Di(t));
  return e ? n.calendar === hr && (n = n.isoYear === -271821 && n.isoMonth === 4 ? {
    ...n,
    isoDay: 20,
    ...Zi
  } : {
    ...n,
    isoDay: 1,
    ...Zi
  }) : r && n.calendar === hr && (n = {
    ...n,
    isoYear: Ca
  }), il(n.C ? lz(n) : cz(n));
}
function Pxe(t, e) {
  const r = CA(ei(e));
  if (r)
    return _A(r), G0(nA(Wh(r)));
  const n = kA(e, 1);
  return G0(W0(t(n.calendar), n));
}
function _A(t) {
  if (t.calendar !== hr)
    throw new RangeError(_a(t.calendar));
}
function Rxe(t, e) {
  const r = IA(ei(e));
  if (r)
    return _A(r), a2(Wh(r));
  const n = kA(e, 0, 1), { calendar: i } = n, s = t(i), [o, a, l] = s.v(n), [c, p] = s.q(o, a), [h, d] = s.G(c, p, l);
  return a2(Us(s.V(h, d, l)), i);
}
function Oxe(t) {
  let e, r = ((n) => {
    const i = KEe.exec(n);
    return i ? (Rb(i[10]), pz(i)) : void 0;
  })(ei(t));
  if (!r) {
    if (r = Gc(t), !r)
      throw new RangeError(Di(t));
    if (!r.C)
      throw new RangeError(Di(t));
    if (r.j)
      throw new RangeError(_a("Z"));
    _A(r);
  }
  if ((e = CA(t)) && xP(e))
    throw new RangeError(Di(t));
  if ((e = IA(t)) && xP(e))
    throw new RangeError(Di(t));
  return la(ef(r, 1));
}
function Txe(t) {
  const e = ((r) => {
    const n = JEe.exec(r);
    return n ? ((i) => {
      function s(p, h, d) {
        let v = 0, m = 0;
        if (d && ([v, l] = ka(l, Ko[d])), p !== void 0) {
          if (a)
            throw new RangeError(_a(p));
          m = ((b) => {
            const f = parseInt(b);
            if (!Number.isFinite(f))
              throw new RangeError(_a(b));
            return f;
          })(p), o = 1, h && (l = RA(h) * (Ko[d] / $o), a = 1);
        }
        return v + m;
      }
      let o = 0, a = 0, l = 0, c = {
        ...Zd(xr, [s(i[2]), s(i[3]), s(i[4]), s(i[5]), s(i[6], i[7], 5), s(i[8], i[9], 4), s(i[10], i[11], 3)]),
        ...gb(l, 2, xr)
      };
      if (!o)
        throw new RangeError(Bz(xr));
      return OA(i[1]) < 0 && (c = Ei(c)), c;
    })(n) : void 0;
  })(ei(t));
  if (!e)
    throw new RangeError(Di(t));
  return wn(Qh(e));
}
function Lxe(t) {
  const e = Gc(t) || CA(t) || IA(t);
  return e ? e.calendar : t;
}
function Mxe(t) {
  const e = Gc(t);
  return e && (e.timeZone || e.j && Zh || e.offset) || t;
}
function az(t, e, r = 0, n = 0) {
  const i = TA(t.timeZone), s = Yt(i);
  let o;
  return vb(t), o = t.C ? rf(s, t, e, r, n, !s.$, t.j) : lc(s, t), go(o, i, Mb(t.calendar));
}
function lz(t) {
  return uz(Yi(vb(t)));
}
function cz(t) {
  return uz(Us(Wh(t)));
}
function uz(t) {
  return {
    ...t,
    calendar: Mb(t.calendar)
  };
}
function Gc(t) {
  const e = QEe.exec(t);
  return e ? ((r) => {
    const n = r[10], i = (n || "").toUpperCase() === "Z";
    return {
      isoYear: hz(r),
      isoMonth: parseInt(r[4]),
      isoDay: parseInt(r[5]),
      ...pz(r.slice(5)),
      ...Rb(r[16]),
      C: !!r[6],
      j: i,
      offset: i ? void 0 : n
    };
  })(e) : void 0;
}
function CA(t) {
  const e = WEe.exec(t);
  return e ? ((r) => ({
    isoYear: hz(r),
    isoMonth: parseInt(r[4]),
    isoDay: 1,
    ...Rb(r[5])
  }))(e) : void 0;
}
function IA(t) {
  const e = qEe.exec(t);
  return e ? ((r) => ({
    isoYear: Ca,
    isoMonth: parseInt(r[1]),
    isoDay: parseInt(r[2]),
    ...Rb(r[3])
  }))(e) : void 0;
}
function PA(t, e) {
  const r = YEe.exec(t);
  return r ? ((n, i) => {
    const s = n[4] || n[5];
    if (i && s)
      throw new RangeError(_a(s));
    return ((o) => {
      if (Math.abs(o) >= zr)
        throw new RangeError(J4e);
      return o;
    })(($p(n[2]) * $b + $p(n[3]) * Db + $p(n[4]) * $o + RA(n[5] || "")) * OA(n[1]));
  })(r, e) : void 0;
}
function hz(t) {
  const e = OA(t[1]), r = parseInt(t[2] || t[3]);
  if (e < 0 && !r)
    throw new RangeError(_a(-0));
  return e * r;
}
function pz(t) {
  const e = $p(t[3]);
  return {
    ...mb(RA(t[4] || ""))[0],
    isoHour: $p(t[1]),
    isoMinute: $p(t[2]),
    isoSecond: e === 60 ? 59 : e
  };
}
function Rb(t) {
  let e, r;
  const n = [];
  if (t.replace(ZEe, (i, s, o) => {
    const a = !!s, [l, c] = o.split("=").reverse();
    if (c) {
      if (c === "u-ca")
        n.push(l), e || (e = a);
      else if (a || /[A-Z]/.test(c))
        throw new RangeError(_a(i));
    } else {
      if (r)
        throw new RangeError(_a(i));
      r = l;
    }
    return "";
  }), n.length > 1 && e)
    throw new RangeError(_a(t));
  return {
    timeZone: r,
    calendar: n[0] || hr
  };
}
function RA(t) {
  return parseInt(t.padEnd(9, "0"));
}
function sf(t) {
  return new RegExp(`^${t}$`, "i");
}
function OA(t) {
  return t && t !== "+" ? -1 : 1;
}
function $p(t) {
  return t === void 0 ? 0 : parseInt(t);
}
function Nxe(t) {
  return TA(ei(t));
}
function TA(t) {
  const e = LA(t);
  return typeof e == "number" ? cm(e) : e ? ((r) => {
    if (t6e.test(r))
      throw new RangeError(Hz(r));
    if (e6e.test(r))
      throw new RangeError(Z4e);
    return r.toLowerCase().split("/").map((n, i) => (n.length <= 3 || /\d/.test(n)) && !/etc|yap/.test(n) ? n.toUpperCase() : n.replace(/baja|dumont|[a-z]+/g, (s, o) => s.length <= 2 && !i || s === "in" || s === "chat" ? s.toUpperCase() : s.length > 2 || !o ? vP(s).replace(/island|noronha|murdo|rivadavia|urville/, vP) : s)).join("/");
  })(t) : Zh;
}
function BP(t) {
  const e = LA(t);
  return typeof e == "number" ? e : e ? e.resolvedOptions().timeZone : Zh;
}
function LA(t) {
  const e = PA(t = t.toUpperCase(), 1);
  return e !== void 0 ? e : t !== Zh ? XEe(t) : void 0;
}
function dz(t, e) {
  return xs(t.epochNanoseconds, e.epochNanoseconds);
}
function fz(t, e) {
  return xs(t.epochNanoseconds, e.epochNanoseconds);
}
function Dxe(t, e, r, n, i, s) {
  const o = t(aa(s).relativeTo), a = Math.max(Eh(n), Eh(i));
  if (_F(xr, n, i))
    return 0;
  if (q0(a, o))
    return xs($n(n), $n(i));
  if (!o)
    throw new RangeError(Nb);
  const [l, c, p] = Cb(e, r, o), h = EA(p), d = Ib(p);
  return xs(h(d(c, l, n)), h(d(c, l, i)));
}
function gz(t, e) {
  return of(t, e) || MA(t, e);
}
function of(t, e) {
  return Vl(hi(t), hi(e));
}
function MA(t, e) {
  return Vl(oc(t), oc(e));
}
function $xe(t, e) {
  return !dz(t, e);
}
function jxe(t, e) {
  return !fz(t, e) && !!mz(t.timeZone, e.timeZone) && t.calendar === e.calendar;
}
function Bxe(t, e) {
  return !gz(t, e) && t.calendar === e.calendar;
}
function Fxe(t, e) {
  return !of(t, e) && t.calendar === e.calendar;
}
function zxe(t, e) {
  return !of(t, e) && t.calendar === e.calendar;
}
function Uxe(t, e) {
  return !of(t, e) && t.calendar === e.calendar;
}
function Vxe(t, e) {
  return !MA(t, e);
}
function mz(t, e) {
  if (t === e)
    return 1;
  try {
    return BP(t) === BP(e);
  } catch {
  }
}
function FP(t, e, r, n) {
  const i = tf(t, n, 3, 5), s = Ob(e.epochNanoseconds, r.epochNanoseconds, ...i);
  return wn(t ? Ei(s) : s);
}
function zP(t, e, r, n, i, s) {
  const o = Lb(n.calendar, i.calendar), [a, l, c, p] = tf(r, s, 5), h = n.epochNanoseconds, d = i.epochNanoseconds, v = xs(d, h);
  let m;
  if (v)
    if (a < 6)
      m = Ob(h, d, a, l, c, p);
    else {
      const b = e(((E, A) => {
        if (!mz(E, A))
          throw new RangeError(Gz);
        return E;
      })(n.timeZone, i.timeZone)), f = t(o);
      m = vz(f, b, n, i, v, a, s), m = Sb(m, d, a, l, c, p, f, n, qF, sr(wA, b));
    }
  else
    m = jn;
  return wn(r ? Ei(m) : m);
}
function UP(t, e, r, n, i) {
  const s = Lb(r.calendar, n.calendar), [o, a, l, c] = tf(e, i, 6), p = On(r), h = On(n), d = xs(h, p);
  let v;
  if (d)
    if (o <= 6)
      v = Ob(p, h, o, a, l, c);
    else {
      const m = t(s);
      v = bz(m, r, n, d, o, i), v = Sb(v, h, o, a, l, c, m, r, On, xA);
    }
  else
    v = jn;
  return wn(e ? Ei(v) : v);
}
function VP(t, e, r, n, i) {
  const s = Lb(r.calendar, n.calendar);
  return yz(e, () => t(s), r, n, ...tf(e, i, 6, 9, 6));
}
function HP(t, e, r, n, i) {
  const s = Lb(r.calendar, n.calendar), o = tf(e, i, 9, 9, 8), a = t(s), l = W0(a, r), c = W0(a, n);
  return l.isoYear === c.isoYear && l.isoMonth === c.isoMonth && l.isoDay === c.isoDay ? wn(jn) : yz(e, () => a, Us(l), Us(c), ...o, 8);
}
function yz(t, e, r, n, i, s, o, a, l = 6) {
  const c = On(r), p = On(n);
  if (c === void 0 || p === void 0)
    throw new RangeError(Kc);
  let h;
  if (xs(p, c))
    if (i === 6)
      h = Ob(c, p, i, s, o, a);
    else {
      const d = e();
      h = d.N(r, n, i), s === l && o === 1 || (h = Sb(h, p, i, s, o, a, d, r, On, _b));
    }
  else
    h = jn;
  return wn(t ? Ei(h) : h);
}
function GP(t, e, r, n) {
  const [i, s, o, a] = tf(t, n, 5, 5), l = ac(NA(e, r), lm(s, o), a), c = {
    ...jn,
    ...Pb(l, i)
  };
  return wn(t ? Ei(c) : c);
}
function Hxe(t, e, r, n, i, s) {
  const o = xs(n.epochNanoseconds, r.epochNanoseconds);
  return o ? i < 6 ? wz(r.epochNanoseconds, n.epochNanoseconds, i) : vz(e, t, r, n, o, i, s) : jn;
}
function Gxe(t, e, r, n, i) {
  const s = On(e), o = On(r), a = xs(o, s);
  return a ? n <= 6 ? wz(s, o, n) : bz(t, e, r, a, n, i) : jn;
}
function vz(t, e, r, n, i, s, o) {
  const [a, l, c] = ((d, v, m, b) => {
    function f() {
      return S = {
        ...qh(x, w++ * -b),
        ...A
      }, R = um(d, S), xs(g, R) === -b;
    }
    const E = Ss(v, d), A = fo(yo, E), x = Ss(m, d), g = m.epochNanoseconds;
    let w = 0;
    const _ = NA(E, x);
    let S, R;
    if (Math.sign(_) === -b && w++, f() && (b === -1 || f()))
      throw new RangeError(af);
    const L = Qo(qo(R, g));
    return [E, S, L];
  })(e, r, n, i);
  var p, h;
  return {
    ...s === 6 ? (p = a, h = l, {
      ...jn,
      days: xz(p, h)
    }) : t.N(a, l, s, o),
    ...Pb(c)
  };
}
function bz(t, e, r, n, i, s) {
  const [o, a, l] = ((c, p, h) => {
    let d = p, v = NA(c, p);
    return Math.sign(v) === -h && (d = qh(p, -h), v += zr * h), [c, d, v];
  })(e, r, n);
  return {
    ...t.N(o, a, i, s),
    ...Pb(l)
  };
}
function Ob(t, e, r, n, i, s) {
  return {
    ...jn,
    ...nf(Ab(qo(t, e), n, i, s), r)
  };
}
function wz(t, e, r) {
  return {
    ...jn,
    ...nf(qo(t, e), r)
  };
}
function xz(t, e) {
  return Tb(hi(t), hi(e));
}
function Tb(t, e) {
  return Math.trunc((e - t) / Fi);
}
function NA(t, e) {
  return oc(e) - oc(t);
}
function Lb(t, e) {
  if (t !== e)
    throw new RangeError(Vz);
  return t;
}
function Ez(t) {
  return this.m(t)[0];
}
function Sz(t) {
  return this.m(t)[1];
}
function DA(t) {
  const [e] = this.v(t);
  return Tb(this.p(e), hi(t)) + 1;
}
function $A(t) {
  const e = r6e.exec(t);
  if (!e)
    throw new RangeError(K4e(t));
  return [parseInt(e[1]), !!e[2]];
}
function hm(t, e) {
  return "M" + Vs(t) + (e ? "L" : "");
}
function u2(t, e, r) {
  return t + (e || r && t >= r ? 1 : 0);
}
function jA(t, e) {
  return t - (e && t >= e ? 1 : 0);
}
function Az(t, e) {
  return (e + t) * (Math.sign(e) || 1) || 0;
}
function O4(t) {
  return eU[_z(t)];
}
function kz(t) {
  return pEe[_z(t)];
}
function _z(t) {
  return Sh(t.id || hr);
}
function Wxe(t) {
  function e(i) {
    return ((s, o) => ({
      ...Cz(s, o),
      o: s.month,
      day: parseInt(s.day)
    }))(sA(r, i), n);
  }
  const r = ok(t), n = Sh(t);
  return {
    id: t,
    h: qxe(e),
    l: Qxe(e)
  };
}
function qxe(t) {
  return ws((e) => {
    const r = hi(e);
    return t(r);
  }, WeakMap);
}
function Qxe(t) {
  const e = t(0).year - SEe;
  return ws((r) => {
    let n, i = Jd(r - e), s = 0;
    const o = [], a = [];
    do
      i += 400 * Fi;
    while ((n = t(i)).year <= r);
    do
      if (i += (1 - n.day) * Fi, n.year === r && (o.push(i), a.push(n.o)), i -= Fi, ++s > 100 || i < -864e13)
        throw new RangeError(af);
    while ((n = t(i)).year >= r);
    return {
      i: o.reverse(),
      u: Wz(a.reverse())
    };
  });
}
function Cz(t, e) {
  let r, n, i = Iz(t);
  if (t.era) {
    const s = eU[e], o = tU[e] || {};
    s !== void 0 && (r = e === "islamic" ? "ah" : t.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), r === "bc" || r === "b" ? r = "bce" : r === "ad" || r === "a" ? r = "ce" : r === "beforeroc" && (r = "broc"), r = o[r] || r, n = i, i = Az(n, s[r] || 0));
  }
  return {
    era: r,
    eraYear: n,
    year: i
  };
}
function Iz(t) {
  return parseInt(t.relatedYear || t.year);
}
function h2(t) {
  const { year: e, o: r, day: n } = this.h(t), { u: i } = this.l(e);
  return [e, i[r] + 1, n];
}
function Q0(t, e = 1, r = 1) {
  return this.l(t).i[e - 1] + (r - 1) * Fi;
}
function Pz(t, e) {
  const r = j1.call(this, t);
  return [jA(e, r), r === e];
}
function j1(t) {
  const e = qP(this, t), r = qP(this, t - 1), n = e.length;
  if (n > r.length) {
    const i = kz(this);
    if (i < 0)
      return -i;
    for (let s = 0; s < n; s++)
      if (e[s] !== r[s])
        return s + 1;
  }
}
function Zm(t) {
  return Tb(Q0.call(this, t), Q0.call(this, t + 1));
}
function WP(t, e) {
  const { i: r } = this.l(t);
  let n = e + 1, i = r;
  return n > r.length && (n = 1, i = this.l(t + 1).i), Tb(r[e - 1], i[n - 1]);
}
function Jm(t) {
  return this.l(t).i.length;
}
function Rz(t) {
  const e = this.h(t);
  return [e.era, e.eraYear];
}
function qP(t, e) {
  return Object.keys(t.l(e).u);
}
function pm(t) {
  return Mb(ei(t));
}
function Mb(t) {
  if ((t = t.toLowerCase()) !== hr && t !== lf) {
    const e = ok(t).resolvedOptions().calendar;
    if (Sh(t) !== Sh(e))
      throw new RangeError(Uz(t));
    return e;
  }
  return t;
}
function Sh(t) {
  return t === "islamicc" && (t = "islamic"), t.split("-")[0];
}
function Oz(t, e) {
  return (r) => r === hr ? t : r === lf || r === cc ? Object.assign(Object.create(t), {
    id: r
  }) : Object.assign(Object.create(e), n6e(r));
}
function Kxe(t, e, r, n) {
  const i = Wc(r, n, al, [], Yz);
  if (i.timeZone !== void 0) {
    const s = r.F(i), o = dm(i), a = t(i.timeZone);
    return {
      epochNanoseconds: rf(e(a), {
        ...s,
        ...o
      }, i.offset !== void 0 ? Kh(i.offset) : void 0),
      timeZone: a
    };
  }
  return {
    ...r.F(i),
    ...Zi
  };
}
function Yxe(t, e, r, n, i, s) {
  const o = Wc(r, i, al, Qz, Yz), a = t(o.timeZone), [l, c, p] = bb(s), h = r.F(o, Eb(l)), d = dm(o, l);
  return go(rf(e(a), {
    ...h,
    ...d
  }, o.offset !== void 0 ? Kh(o.offset) : void 0, c, p), a, n);
}
function Zxe(t, e, r) {
  const n = Wc(t, e, al, [], ol), i = mr(r);
  return mo(Yi({
    ...t.F(n, Eb(i)),
    ...dm(n, i)
  }));
}
function Jxe(t, e, r, n = []) {
  const i = Wc(t, e, al, n);
  return t.F(i, r);
}
function Xxe(t, e, r, n) {
  const i = Wc(t, e, GA, n);
  return t.K(i, r);
}
function e4e(t, e, r, n) {
  const i = Wc(t, r, al, gm);
  return e && i.month !== void 0 && i.monthCode === void 0 && i.year === void 0 && (i.year = Ca), t._(i, n);
}
function t4e(t, e) {
  return la(dm(Es(t, N4, [], 1), mr(e)));
}
function r4e(t) {
  const e = Es(t, WA);
  return wn(Qh({
    ...jn,
    ...e
  }));
}
function Wc(t, e, r, n = [], i = []) {
  return Es(e, [...t.fields(r), ...i].sort(), n);
}
function Es(t, e, r, n = !r) {
  const i = {};
  let s, o = 0;
  for (const a of e) {
    if (a === s)
      throw new RangeError(z4e(a));
    if (a === "constructor" || a === "__proto__")
      throw new RangeError(F4e(a));
    let l = t[a];
    if (l !== void 0)
      o = 1, QP[a] && (l = QP[a](l, a)), i[a] = l;
    else if (r) {
      if (r.includes(a))
        throw new TypeError(FA(a));
      i[a] = Xz[a];
    }
    s = a;
  }
  if (n && !o)
    throw new TypeError(Bz(e));
  return i;
}
function dm(t, e) {
  return ef(ak({
    ...Xz,
    ...t
  }), e);
}
function n4e(t, e, r, n, i) {
  const { calendar: s, timeZone: o } = r, a = t(s), l = e(o), c = [...a.fields(al), ...Kz].sort(), p = ((E) => {
    const A = Ss(E, Yt), x = cm(A.offsetNanoseconds), g = Fb(E.calendar), [w, _, S] = g.v(A), [R, L] = g.q(w, _), F = hm(R, L);
    return {
      ...h6e(A),
      year: w,
      monthCode: F,
      day: S,
      offset: x
    };
  })(r), h = Es(n, c), d = a.k(p, h), v = {
    ...p,
    ...h
  }, [m, b, f] = bb(i, 2);
  return go(rf(l, {
    ...a.F(d, Eb(m)),
    ...ef(ak(v), m)
  }, Kh(v.offset), b, f), o, s);
}
function i4e(t, e, r, n) {
  const i = t(e.calendar), s = [...i.fields(al), ...ol].sort(), o = {
    ...Lz(a = e),
    hour: a.isoHour,
    minute: a.isoMinute,
    second: a.isoSecond,
    millisecond: a.isoMillisecond,
    microsecond: a.isoMicrosecond,
    nanosecond: a.isoNanosecond
  };
  var a;
  const l = Es(r, s), c = mr(n), p = i.k(o, l), h = {
    ...o,
    ...l
  };
  return mo(Yi({
    ...i.F(p, Eb(c)),
    ...ef(ak(h), c)
  }));
}
function s4e(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(al).sort(), o = Lz(e), a = Es(r, s), l = i.k(o, a);
  return i.F(l, n);
}
function o4e(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(GA).sort(), o = ((c) => {
    const p = Fb(c.calendar), [h, d] = p.v(c), [v, m] = p.q(h, d);
    return {
      year: h,
      monthCode: hm(v, m)
    };
  })(e), a = Es(r, s), l = i.k(o, a);
  return i.K(l, n);
}
function a4e(t, e, r, n) {
  const i = t(e.calendar), s = i.fields(al).sort(), o = ((c) => {
    const p = Fb(c.calendar), [h, d, v] = p.v(c), [m, b] = p.q(h, d);
    return {
      monthCode: hm(m, b),
      day: v
    };
  })(e), a = Es(r, s), l = i.k(o, a);
  return i._(l, n);
}
function l4e(t, e, r) {
  return la(((n, i, s) => dm({
    ...fo(N4, n),
    ...Es(i, N4)
  }, mr(s)))(t, e, r));
}
function c4e(t, e) {
  return wn((r = t, n = e, Qh({
    ...r,
    ...Es(n, WA)
  })));
  var r, n;
}
function Tz(t, e, r, n, i) {
  e = fo(r = t.fields(r), e), n = Es(n, i = t.fields(i), []);
  let s = t.k(e, n);
  return s = Es(s, [...r, ...i].sort(), []), t.F(s);
}
function G3(t, e) {
  const r = O4(t), n = tU[t.id || ""] || {};
  let { era: i, eraYear: s, year: o } = e;
  if (i !== void 0 || s !== void 0) {
    if (i === void 0 || s === void 0)
      throw new TypeError(G4e);
    if (!r)
      throw new RangeError(H4e);
    const a = r[n[i] || i];
    if (a === void 0)
      throw new RangeError(q4e(i));
    const l = Az(s, a);
    if (o !== void 0 && o !== l)
      throw new RangeError(W4e);
    o = l;
  } else if (o === void 0)
    throw new TypeError(Q4e(r));
  return o;
}
function Xm(t, e, r, n) {
  let { month: i, monthCode: s } = e;
  if (s !== void 0) {
    const o = ((a, l, c, p) => {
      const h = a.L(c), [d, v] = $A(l);
      let m = u2(d, v, h);
      if (v) {
        const b = kz(a);
        if (b === void 0)
          throw new RangeError(_f);
        if (b > 0) {
          if (m > b)
            throw new RangeError(_f);
          if (h === void 0) {
            if (p === 1)
              throw new RangeError(_f);
            m--;
          }
        } else {
          if (m !== -b)
            throw new RangeError(_f);
          if (h === void 0 && p === 1)
            throw new RangeError(_f);
        }
      }
      return m;
    })(t, s, r, n);
    if (i !== void 0 && i !== o)
      throw new RangeError(Y4e);
    i = o, n = 1;
  } else if (i === void 0)
    throw new TypeError(zz);
  return ja("month", i, 1, t.B(r), n);
}
function W3(t, e, r, n, i) {
  return Li(e, "day", 1, t.U(n, r), i);
}
function q3(t, e, r, n) {
  let i = 0;
  const s = [];
  for (const o of r)
    e[o] !== void 0 ? i = 1 : s.push(o);
  if (Object.assign(t, e), i)
    for (const o of n || s)
      delete t[o];
}
function Lz(t) {
  const e = Fb(t.calendar), [r, n, i] = e.v(t), [s, o] = e.q(r, n);
  return {
    year: r,
    monthCode: hm(s, o),
    day: i
  };
}
function u4e(t) {
  return nl(oa(tA(J8(t))));
}
function h4e(t, e, r, n, i = hr) {
  return go(oa(tA(J8(r))), e(n), t(i));
}
function p4e(t, e, r, n, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0, p = hr) {
  return mo(Yi(vb(Ba(oi, Zd(jb, [e, r, n, i, s, o, a, l, c])))), t(p));
}
function d4e(t, e, r, n, i = hr) {
  return il(Us(Wh(Ba(oi, {
    isoYear: e,
    isoMonth: r,
    isoDay: n
  }))), t(i));
}
function f4e(t, e, r, n = hr, i = 1) {
  const s = oi(e), o = oi(r), a = t(n);
  return G0(nA(Wh({
    isoYear: s,
    isoMonth: o,
    isoDay: oi(i)
  })), a);
}
function g4e(t, e, r, n = hr, i = Ca) {
  const s = oi(e), o = oi(r), a = t(n);
  return a2(Us(Wh({
    isoYear: oi(i),
    isoMonth: s,
    isoDay: o
  })), a);
}
function m4e(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0) {
  return la(ef(Ba(oi, Zd(yo, [t, e, r, n, i, s])), 1));
}
function y4e(t = 0, e = 0, r = 0, n = 0, i = 0, s = 0, o = 0, a = 0, l = 0, c = 0) {
  return wn(Qh(Ba(X8, Zd(xr, [t, e, r, n, i, s, o, a, l, c]))));
}
function v4e(t, e, r = hr) {
  return go(t.epochNanoseconds, e, r);
}
function b4e(t) {
  return nl(t.epochNanoseconds);
}
function Mz(t, e) {
  return mo(Ss(e, t));
}
function Nz(t, e) {
  return il(Ss(e, t));
}
function Dz(t, e) {
  return la(Ss(e, t));
}
function w4e(t, e, r, n) {
  const i = ((s, o, a, l) => {
    const c = ((p) => uU(aa(p)))(l);
    return um(s(o), a, c);
  })(t, r, e, n);
  return go(oa(i), r, e.calendar);
}
function x4e(t, e, r, n, i) {
  const s = t(i.timeZone), o = i.plainTime, a = o !== void 0 ? e(o) : void 0, l = r(s);
  let c;
  return c = a ? um(l, {
    ...n,
    ...a
  }) : lc(l, {
    ...n,
    ...Zi
  }), go(c, s, n.calendar);
}
function E4e(t, e = Zi) {
  return mo(Yi({
    ...t,
    ...e
  }));
}
function S4e(t, e, r) {
  return ((n, i) => {
    const s = Wc(n, i, Zz);
    return n.K(s, void 0);
  })(t(e.calendar), r);
}
function A4e(t, e, r) {
  return ((n, i) => {
    const s = Wc(n, i, Jz);
    return n._(s);
  })(t(e.calendar), r);
}
function k4e(t, e, r, n) {
  return ((i, s, o) => Tz(i, s, Zz, am(o), gm))(t(e.calendar), r, n);
}
function _4e(t, e, r, n) {
  return ((i, s, o) => Tz(i, s, Jz, am(o), UA))(t(e.calendar), r, n);
}
function C4e(t) {
  return nl(oa(s2(X8(t), sl)));
}
function I4e(t) {
  return nl(oa(tA(J8(t))));
}
function Yh(t, e, r) {
  const n = new Set(r);
  return (i, s) => {
    const o = r && yP(i, r);
    if (!yP(i = ((a, l) => {
      const c = {};
      for (const p in l)
        a.has(p) || (c[p] = l[p]);
      return c;
    })(n, i), t)) {
      if (s && o)
        throw new TypeError("Invalid formatting options");
      i = {
        ...e,
        ...i
      };
    }
    return r && (i.timeZone = Zh, ["full", "long"].includes(i.J) && (i.J = "medium")), i;
  };
}
function qc(t, e = $z, r = 0) {
  const [n, , , i] = t;
  return (s, o = R6e, ...a) => {
    const l = e(i && i(...a), s, o, n, r), c = l.resolvedOptions();
    return [l, ...P4e(t, c, a)];
  };
}
function $z(t, e, r, n, i) {
  if (r = n(r, i), t) {
    if (r.timeZone !== void 0)
      throw new TypeError(lEe);
    r.timeZone = t;
  }
  return new Hl(e, r);
}
function P4e(t, e, r) {
  const [, n, i] = t;
  return r.map((s) => (s.calendar && ((o, a, l) => {
    if ((l || o !== hr) && o !== a)
      throw new RangeError(Vz);
  })(s.calendar, e.calendar, i), n(s, e)));
}
function R4e(t, e, r) {
  const n = e.timeZone, i = t(n), s = {
    ...Ss(e, i),
    ...r || Zi
  };
  let o;
  return o = r ? rf(i, s, s.offsetNanoseconds, 2) : lc(i, s), go(o, n, e.calendar);
}
function O4e(t, e = Zi) {
  return mo(Yi({
    ...t,
    ...e
  }));
}
function BA(t, e) {
  return {
    ...t,
    calendar: e
  };
}
function T4e(t, e) {
  return {
    ...t,
    timeZone: e
  };
}
function Q3(t) {
  const e = T4();
  return Xd(e, t.R(e));
}
function T4() {
  return s2(Date.now(), sl);
}
function kf() {
  return KP || (KP = new Hl().resolvedOptions().timeZone);
}
const L4e = (t, e) => `Non-integer ${t}: ${e}`, M4e = (t, e) => `Non-positive ${t}: ${e}`, N4e = (t, e) => `Non-finite ${t}: ${e}`, D4e = (t) => `Cannot convert bigint to ${t}`, $4e = (t) => `Invalid bigint: ${t}`, j4e = "Cannot convert Symbol to string", B4e = "Invalid object", jz = (t, e, r, n, i) => i ? jz(t, i[e], i[r], i[n]) : Qc(t, e) + `; must be between ${r}-${n}`, Qc = (t, e) => `Invalid ${t}: ${e}`, FA = (t) => `Missing ${t}`, F4e = (t) => `Invalid field ${t}`, z4e = (t) => `Duplicate field ${t}`, Bz = (t) => "No valid fields: " + t.join(), U4e = "Invalid bag", Fz = (t, e, r) => Qc(t, e) + "; must be " + Object.keys(r).join(), V4e = "Cannot use valueOf", L4 = "Invalid calling context", H4e = "Forbidden era/eraYear", G4e = "Mismatching era/eraYear", W4e = "Mismatching year/eraYear", q4e = (t) => `Invalid era: ${t}`, Q4e = (t) => "Missing year" + (t ? "/era/eraYear" : ""), K4e = (t) => `Invalid monthCode: ${t}`, Y4e = "Mismatching month/monthCode", zz = "Missing month/monthCode", _f = "Invalid leap month", af = "Invalid protocol results", Uz = (t) => Qc("Calendar", t), Vz = "Mismatching Calendars", Hz = (t) => Qc("TimeZone", t), Gz = "Mismatching TimeZones", Z4e = "Forbidden ICU TimeZone", J4e = "Out-of-bounds offset", X4e = "Out-of-bounds TimeZone gap", eEe = "Invalid TimeZone offset", tEe = "Ambiguous offset", Kc = "Out-of-bounds date", rEe = "Out-of-bounds duration", nEe = "Cannot mix duration signs", Nb = "Missing relativeTo", iEe = "Cannot use large units", sEe = "Required smallestUnit or largestUnit", oEe = "smallestUnit > largestUnit", Di = (t) => `Cannot parse: ${t}`, _a = (t) => `Invalid substring: ${t}`, aEe = (t) => `Cannot format ${t}`, K3 = "Mismatching types for formatting", lEe = "Cannot specify TimeZone", Wz = /* @__PURE__ */ sr(db, (t, e) => e), od = /* @__PURE__ */ sr(db, (t, e, r) => r), Vs = /* @__PURE__ */ sr(i2, 2), M4 = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, zA = /* @__PURE__ */ Object.keys(M4), Fi = 864e5, qz = 1e3, fm = 1e3, sl = 1e6, $o = 1e9, Db = 6e10, $b = 36e11, zr = 864e11, Ko = [1, fm, sl, $o, Db, $b, zr], ol = /* @__PURE__ */ zA.slice(0, 6), N4 = /* @__PURE__ */ om(ol), cEe = ["offset"], Qz = ["timeZone"], Kz = /* @__PURE__ */ ol.concat(cEe), Yz = /* @__PURE__ */ Kz.concat(Qz), D4 = ["era", "eraYear"], uEe = /* @__PURE__ */ D4.concat(["year"]), UA = ["year"], VA = ["monthCode"], HA = /* @__PURE__ */ ["month"].concat(VA), gm = ["day"], GA = /* @__PURE__ */ HA.concat(UA), Zz = /* @__PURE__ */ VA.concat(UA), al = /* @__PURE__ */ gm.concat(GA), hEe = /* @__PURE__ */ gm.concat(HA), Jz = /* @__PURE__ */ gm.concat(VA), Xz = /* @__PURE__ */ od(ol, 0), hr = "iso8601", lf = "gregory", cc = "japanese", eU = {
  [lf]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [cc]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, tU = {
  [lf]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [cc]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
}, pEe = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, ei = /* @__PURE__ */ sr(Y8, "string"), dEe = /* @__PURE__ */ sr(Y8, "boolean"), fEe = /* @__PURE__ */ sr(Y8, "number"), xr = /* @__PURE__ */ zA.map((t) => t + "s"), WA = /* @__PURE__ */ om(xr), gEe = /* @__PURE__ */ xr.slice(0, 6), rU = /* @__PURE__ */ xr.slice(6), mEe = /* @__PURE__ */ rU.slice(1), yEe = /* @__PURE__ */ Wz(xr), jn = /* @__PURE__ */ od(xr, 0), qA = /* @__PURE__ */ od(gEe, 0), QA = /* @__PURE__ */ sr(CF, xr), yo = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"], KA = ["isoDay", "isoMonth", "isoYear"], jb = /* @__PURE__ */ yo.concat(KA), YA = /* @__PURE__ */ om(KA), nU = /* @__PURE__ */ om(yo), vEe = /* @__PURE__ */ om(jb), Zi = /* @__PURE__ */ od(nU, 0), bEe = /* @__PURE__ */ sr(CF, jb), iU = 1e8, wEe = iU * Fi, xEe = [iU, 0], EEe = [-1e8, 0], K0 = 275760, Y0 = -271821, Hl = Intl.DateTimeFormat, sU = "en-GB", SEe = 1970, Ca = 1972, vl = 12, AEe = /* @__PURE__ */ Jd(1868, 9, 8), kEe = /* @__PURE__ */ ws(sxe, WeakMap), p2 = "smallestUnit", $4 = "unit", t0 = "roundingIncrement", Y3 = "fractionalSecondDigits", oU = "relativeTo", Z3 = "direction", aU = {
  constrain: 0,
  reject: 1
}, _Ee = /* @__PURE__ */ Object.keys(aU), CEe = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}, IEe = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}, PEe = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}, REe = {
  auto: 0,
  never: 1,
  critical: 2
}, OEe = {
  auto: 0,
  never: 1
}, TEe = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}, LEe = {
  previous: -1,
  next: 1
}, mm = /* @__PURE__ */ sr(pA, p2), lU = /* @__PURE__ */ sr(pA, "largestUnit"), MEe = /* @__PURE__ */ sr(pA, $4), cU = /* @__PURE__ */ sr(Vc, "overflow", aU), uU = /* @__PURE__ */ sr(Vc, "disambiguation", CEe), NEe = /* @__PURE__ */ sr(Vc, "offset", IEe), ZA = /* @__PURE__ */ sr(Vc, "calendarName", PEe), DEe = /* @__PURE__ */ sr(Vc, "timeZoneName", REe), $Ee = /* @__PURE__ */ sr(Vc, "offset", OEe), ym = /* @__PURE__ */ sr(Vc, "roundingMode", TEe), JA = "PlainYearMonth", XA = "PlainMonthDay", vm = "PlainDate", cf = "PlainDateTime", ek = "PlainTime", Yc = "ZonedDateTime", tk = "Instant", rk = "Duration", jEe = [Math.floor, (t) => Ym(t) ? Math.floor(t) : Math.round(t), Math.ceil, (t) => Ym(t) ? Math.ceil(t) : Math.round(t), Math.trunc, (t) => Ym(t) ? Math.trunc(t) || 0 : Math.round(t), (t) => t < 0 ? Math.floor(t) : Math.ceil(t), (t) => Math.sign(t) * Math.round(Math.abs(t)) || 0, (t) => Ym(t) ? (t = Math.trunc(t) || 0) + t % 2 : Math.round(t)], Zh = "UTC", B1 = 5184e3, BEe = /* @__PURE__ */ o2(1847), FEe = /* @__PURE__ */ o2(/* @__PURE__ */ (/* @__PURE__ */ new Date()).getUTCFullYear() + 10), zEe = /0+$/, Ss = /* @__PURE__ */ ws(wxe, WeakMap), UEe = 2 ** 32 - 1, Yt = /* @__PURE__ */ ws((t) => {
  const e = LA(t);
  return typeof e == "object" ? new HEe(e) : new VEe(e || 0);
});
class VEe {
  constructor(e) {
    this.$ = e;
  }
  R() {
    return this.$;
  }
  I(e) {
    return ((r) => {
      const n = On({
        ...r,
        ...Zi
      });
      if (!n || Math.abs(n[0]) > 1e8)
        throw new RangeError(Kc);
    })(e), [iA(e, this.$)];
  }
  O() {
  }
}
class HEe {
  constructor(e) {
    this.nn = ((r) => {
      function n(c) {
        const p = H0(c, a, l), [h, d] = jP(p), v = s(h), m = s(d);
        return v === m ? v : i(o(h, d), v, m, c);
      }
      function i(c, p, h, d) {
        let v, m;
        for (; (d === void 0 || (v = d < c[0] ? p : d >= c[1] ? h : void 0) === void 0) && (m = c[1] - c[0]); ) {
          const b = c[0] + Math.floor(m / 2);
          r(b) === h ? c[1] = b : c[0] = b + 1;
        }
        return v;
      }
      const s = ws(r), o = ws(Axe);
      let a = BEe, l = FEe;
      return {
        tn(c) {
          const p = n(c - 86400), h = n(c + 86400), d = c - p, v = c - h;
          if (p === h)
            return [d];
          const m = n(d);
          return m === n(v) ? [c - m] : p > h ? [d, v] : [];
        },
        rn: n,
        O(c, p) {
          const h = H0(c, a, l);
          let [d, v] = jP(h);
          const m = B1 * p, b = p < 0 ? () => v > a || (a = h, 0) : () => d < l || (l = h, 0);
          for (; b(); ) {
            const f = s(d), E = s(v);
            if (f !== E) {
              const A = o(d, v);
              i(A, f, E);
              const x = A[0];
              if ((Vl(x, c) || 1) === p)
                return x;
            }
            d += m, v += m;
          }
        }
      };
    })(/* @__PURE__ */ ((r) => (n) => {
      const i = sA(r, n * qz);
      return o2(Iz(i), parseInt(i.month), parseInt(i.day), parseInt(i.hour), parseInt(i.minute), parseInt(i.second)) - n;
    })(e));
  }
  R(e) {
    return this.nn.rn(((r) => wP(r)[0])(e)) * $o;
  }
  I(e) {
    const [r, n] = [o2((i = e).isoYear, i.isoMonth, i.isoDay, i.isoHour, i.isoMinute, i.isoSecond), i.isoMillisecond * sl + i.isoMicrosecond * fm + i.isoNanosecond];
    var i;
    return this.nn.tn(r).map((s) => oa(xh(s2(s, $o), n)));
  }
  O(e, r) {
    const [n, i] = wP(e), s = this.nn.O(n + (r > 0 || i ? 1 : 0), r);
    if (s !== void 0)
      return s2(s, $o);
  }
}
const nk = "([+-])", F1 = "(?:[.,](\\d{1,9}))?", hU = `(?:(?:${nk}(\\d{6}))|(\\d{4}))-?(\\d{2})`, ik = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + F1 + ")?)?", sk = nk + ik, GEe = hU + "-?(\\d{2})(?:[T ]" + ik + "(Z|" + sk + ")?)?", pU = "\\[(!?)([^\\]]*)\\]", Bb = `((?:${pU}){0,9})`, WEe = /* @__PURE__ */ sf(hU + Bb), qEe = /* @__PURE__ */ sf("(?:--)?(\\d{2})-?(\\d{2})" + Bb), QEe = /* @__PURE__ */ sf(GEe + Bb), KEe = /* @__PURE__ */ sf("T?" + ik + "(?:" + sk + ")?" + Bb), YEe = /* @__PURE__ */ sf(sk), ZEe = /* @__PURE__ */ new RegExp(pU, "g"), JEe = /* @__PURE__ */ sf(`${nk}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${F1}H)?(?:(\\d+)${F1}M)?(?:(\\d+)${F1}S)?)?`), XEe = /* @__PURE__ */ ws((t) => new Hl(sU, {
  timeZone: t,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
})), e6e = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, t6e = /[^\w\/:+-]+/, r6e = /^M(\d{2})(L?)$/, n6e = /* @__PURE__ */ ws(Wxe), ok = /* @__PURE__ */ ws((t) => new Hl(sU, {
  calendar: t,
  timeZone: Zh,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
})), dU = {
  P(t, e, r) {
    const n = mr(r);
    let i, { years: s, months: o, weeks: a, days: l } = e;
    if (l += $n(e, 5)[0], s || o)
      i = ((c, p, h, d, v) => {
        let [m, b, f] = c.v(p);
        if (h) {
          const [E, A] = c.q(m, b);
          m += h, b = u2(E, A, c.L(m)), b = ja("month", b, 1, c.B(m), v);
        }
        return d && ([m, b] = c.un(m, b, d)), f = ja("day", f, 1, c.U(m, b), v), c.p(m, b, f);
      })(this, t, s, o, n);
    else {
      if (!a && !l)
        return t;
      i = hi(t);
    }
    if (i === void 0)
      throw new RangeError(Kc);
    return i += (7 * a + l) * Fi, Us(yb(i));
  },
  N(t, e, r) {
    if (r <= 7) {
      let l = 0, c = xz({
        ...t,
        ...Zi
      }, {
        ...e,
        ...Zi
      });
      return r === 7 && ([l, c] = sc(c, 7)), {
        ...jn,
        weeks: l,
        days: c
      };
    }
    const n = this.v(t), i = this.v(e);
    let [s, o, a] = ((l, c, p, h, d, v, m) => {
      let b = d - c, f = v - p, E = m - h;
      if (b || f) {
        const A = Math.sign(b || f);
        let x = l.U(d, v), g = 0;
        if (Math.sign(E) === -A) {
          const w = x;
          [d, v] = l.un(d, v, -A), b = d - c, f = v - p, x = l.U(d, v), g = A < 0 ? -w : x;
        }
        if (E = m - Math.min(h, x) + g, b) {
          const [w, _] = l.q(c, p), [S, R] = l.q(d, v);
          if (f = S - w || Number(R) - Number(_), Math.sign(f) === -A) {
            const L = A < 0 && -l.B(d);
            b = (d -= A) - c, f = v - u2(w, _, l.L(d)) + (L || l.B(d));
          }
        }
      }
      return [b, f, E];
    })(this, ...n, ...i);
    return r === 8 && (o += this.cn(s, n[0]), s = 0), {
      ...jn,
      years: s,
      months: o,
      days: a
    };
  },
  F(t, e) {
    const r = mr(e), n = G3(this, t), i = Xm(this, t, n, r), s = W3(this, t, i, n, r);
    return il(Us(this.V(n, i, s)), this.id || hr);
  },
  K(t, e) {
    const r = mr(e), n = G3(this, t), i = Xm(this, t, n, r);
    return G0(nA(this.V(n, i, 1)), this.id || hr);
  },
  _(t, e) {
    const r = mr(e);
    let n, i, s, o = t.eraYear !== void 0 || t.year !== void 0 ? G3(this, t) : void 0;
    const a = !this.id;
    if (o === void 0 && a && (o = Ca), o !== void 0) {
      const h = Xm(this, t, o, r);
      n = W3(this, t, h, o, r);
      const d = this.L(o);
      i = jA(h, d), s = h === d;
    } else {
      if (t.monthCode === void 0)
        throw new TypeError(zz);
      if ([i, s] = $A(t.monthCode), this.id && this.id !== lf && this.id !== cc)
        if (this.id && Sh(this.id) === "coptic" && r === 0) {
          const h = s || i !== 13 ? 30 : 6;
          n = t.day, n = H0(n, 1, h);
        } else if (this.id && Sh(this.id) === "chinese" && r === 0) {
          const h = !s || i !== 1 && i !== 9 && i !== 10 && i !== 11 && i !== 12 ? 30 : 29;
          n = t.day, n = H0(n, 1, h);
        } else
          n = t.day;
      else
        n = W3(this, t, Xm(this, t, Ca, r), Ca, r);
    }
    const l = this.G(i, s, n);
    if (!l)
      throw new RangeError("Cannot guess year");
    const [c, p] = l;
    return a2(Us(this.V(c, p, n)), this.id || hr);
  },
  fields(t) {
    return O4(this) && t.includes("year") ? [...t, ...D4] : t;
  },
  k(t, e) {
    const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
    return q3(r, e, HA), O4(this) && (q3(r, e, uEe), this.id === cc && q3(r, e, hEe, D4)), r;
  },
  inLeapYear(t) {
    const [e] = this.v(t);
    return this.sn(e);
  },
  monthsInYear(t) {
    const [e] = this.v(t);
    return this.B(e);
  },
  daysInMonth(t) {
    const [e, r] = this.v(t);
    return this.U(e, r);
  },
  daysInYear(t) {
    const [e] = this.v(t);
    return this.fn(e);
  },
  dayOfYear: DA,
  era(t) {
    return this.hn(t)[0];
  },
  eraYear(t) {
    return this.hn(t)[1];
  },
  monthCode(t) {
    const [e, r] = this.v(t), [n, i] = this.q(e, r);
    return hm(n, i);
  },
  dayOfWeek: FF,
  daysInWeek() {
    return 7;
  }
}, i6e = {
  v: oA,
  hn: zF,
  q: DF
}, s6e = {
  dayOfYear: DA,
  v: oA,
  p: Jd
}, o6e = /* @__PURE__ */ Object.assign({}, s6e, {
  weekOfYear: Ez,
  yearOfWeek: Sz,
  m(t) {
    function e(v) {
      return (7 - v < n ? 7 : 0) - v;
    }
    function r(v) {
      const m = BF(d + v), b = v || 1, f = e(e0(l + m * b, 7));
      return p = (m + (f - c) * b) / 7;
    }
    const n = this.id ? 1 : 4, i = FF(t), s = this.dayOfYear(t), o = e0(i - 1, 7), a = s - 1, l = e0(o - a, 7), c = e(l);
    let p, h = Math.floor((a - c) / 7) + 1, d = t.isoYear;
    return h ? h > r(0) && (h = 1, d++) : (h = r(-1), d--), [h, d, p];
  }
}), a6e = /* @__PURE__ */ Object.assign({}, dU, o6e, {
  v: oA,
  hn: zF,
  q: DF,
  G(t, e) {
    if (!e)
      return [Ca, t];
  },
  sn: aA,
  L() {
  },
  B: $F,
  cn: (t) => t * vl,
  U: jF,
  fn: BF,
  V: (t, e, r) => ({
    isoYear: t,
    isoMonth: e,
    isoDay: r
  }),
  p: Jd,
  un: (t, e, r) => (t += fb(r, vl), (e += Q8(r, vl)) < 1 ? (t--, e += vl) : e > vl && (t++, e -= vl), [t, e]),
  year(t) {
    return t.isoYear;
  },
  month(t) {
    return t.isoMonth;
  },
  day: (t) => t.isoDay
}), l6e = {
  v: h2,
  hn: Rz,
  q: Pz
}, c6e = {
  dayOfYear: DA,
  v: h2,
  p: Q0,
  weekOfYear: Ez,
  yearOfWeek: Sz,
  m() {
    return [];
  }
}, u6e = /* @__PURE__ */ Object.assign({}, dU, c6e, {
  v: h2,
  hn: Rz,
  q: Pz,
  G(t, e, r) {
    const n = this.id && Sh(this.id) === "chinese" ? ((c, p, h) => {
      if (p)
        switch (c) {
          case 1:
            return 1651;
          case 2:
            return h < 30 ? 1947 : 1765;
          case 3:
            return h < 30 ? 1966 : 1955;
          case 4:
            return h < 30 ? 1963 : 1944;
          case 5:
            return h < 30 ? 1971 : 1952;
          case 6:
            return h < 30 ? 1960 : 1941;
          case 7:
            return h < 30 ? 1968 : 1938;
          case 8:
            return h < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      return 1972;
    })(t, e, r) : Ca;
    let [i, s, o] = h2.call(this, {
      isoYear: n,
      isoMonth: vl,
      isoDay: 31
    });
    const a = j1.call(this, i), l = s === a;
    (Vl(t, jA(s, a)) || Vl(Number(e), Number(l)) || Vl(r, o)) === 1 && i--;
    for (let c = 0; c < 100; c++) {
      const p = i - c, h = j1.call(this, p), d = u2(t, e, h);
      if (e === (d === h) && r <= WP.call(this, p, d))
        return [p, d];
    }
  },
  sn(t) {
    const e = Zm.call(this, t);
    return e > Zm.call(this, t - 1) && e > Zm.call(this, t + 1);
  },
  L: j1,
  B: Jm,
  cn(t, e) {
    const r = e + t, n = Math.sign(t), i = n < 0 ? -1 : 0;
    let s = 0;
    for (let o = e; o !== r; o += n)
      s += Jm.call(this, o + i);
    return s;
  },
  U: WP,
  fn: Zm,
  V(t, e, r) {
    return yb(Q0.call(this, t, e, r));
  },
  p: Q0,
  un(t, e, r) {
    if (r) {
      if (e += r, !Number.isSafeInteger(e))
        throw new RangeError(Kc);
      if (r < 0)
        for (; e < 1; )
          e += Jm.call(this, --t);
      else {
        let n;
        for (; e > (n = Jm.call(this, t)); )
          e -= n, t++;
      }
    }
    return [t, e];
  },
  year(t) {
    return this.h(t).year;
  },
  month(t) {
    const { year: e, o: r } = this.h(t), { u: n } = this.l(e);
    return n[r] + 1;
  },
  day(t) {
    return this.h(t).day;
  }
}), Fb = /* @__PURE__ */ Oz(i6e, l6e), Ft = /* @__PURE__ */ Oz(a6e, u6e), QP = {
  era: $1,
  eraYear: oi,
  year: oi,
  month: bP,
  monthCode(t) {
    const e = $1(t);
    return $A(e), e;
  },
  day: bP,
  .../* @__PURE__ */ od(ol, oi),
  .../* @__PURE__ */ od(xr, X8),
  offset(t) {
    const e = $1(t);
    return Kh(e), e;
  }
}, ak = /* @__PURE__ */ sr(kF, ol, yo), h6e = /* @__PURE__ */ sr(kF, yo, ol), Gl = "numeric", bm = ["timeZoneName"], fU = {
  month: Gl,
  day: Gl
}, lk = {
  year: Gl,
  month: Gl
}, ck = /* @__PURE__ */ Object.assign({}, lk, {
  day: Gl
}), uk = {
  hour: Gl,
  minute: Gl,
  second: Gl
}, hk = /* @__PURE__ */ Object.assign({}, ck, uk), p6e = /* @__PURE__ */ Object.assign({}, hk, {
  timeZoneName: "short"
}), d6e = /* @__PURE__ */ Object.keys(lk), f6e = /* @__PURE__ */ Object.keys(fU), g6e = /* @__PURE__ */ Object.keys(ck), m6e = /* @__PURE__ */ Object.keys(uk), pk = ["dateStyle"], y6e = /* @__PURE__ */ d6e.concat(pk), v6e = /* @__PURE__ */ f6e.concat(pk), dk = /* @__PURE__ */ g6e.concat(pk, ["weekday"]), wm = /* @__PURE__ */ m6e.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]), fk = /* @__PURE__ */ dk.concat(wm), b6e = /* @__PURE__ */ bm.concat(wm), w6e = /* @__PURE__ */ bm.concat(dk), x6e = /* @__PURE__ */ bm.concat(["day", "weekday"], wm), E6e = /* @__PURE__ */ bm.concat(["year", "weekday"], wm), S6e = /* @__PURE__ */ Yh(fk, hk), A6e = /* @__PURE__ */ Yh(fk, p6e), k6e = /* @__PURE__ */ Yh(fk, hk, bm), _6e = /* @__PURE__ */ Yh(dk, ck, b6e), C6e = /* @__PURE__ */ Yh(wm, uk, w6e), I6e = /* @__PURE__ */ Yh(y6e, lk, x6e), P6e = /* @__PURE__ */ Yh(v6e, fU, E6e), R6e = {}, gU = new Hl(void 0, {
  calendar: hr
}).resolvedOptions().calendar === hr, mU = [S6e, dA], O6e = [A6e, dA, 0, (t, e) => {
  const r = t.timeZone;
  if (e && e.timeZone !== r)
    throw new RangeError(Gz);
  return r;
}], yU = [k6e, hi], vU = [_6e, hi], bU = [C6e, (t) => oc(t) / sl], wU = [I6e, hi, gU], xU = [P6e, hi, gU];
let KP;
function Zc(t, e, r, n, i) {
  function s(...l) {
    if (!(this instanceof s))
      throw new TypeError(L4);
    JP(this, e(...l));
  }
  function o(l, c) {
    return Object.defineProperties(function(...p) {
      return l.call(this, a(this), ...p);
    }, V0(c));
  }
  function a(l) {
    const c = Si(l);
    if (!c || c.branding !== t)
      throw new TypeError(L4);
    return c;
  }
  return Object.defineProperties(s.prototype, {
    ...rxe(Ba(o, r)),
    ...nd(Ba(o, n)),
    ...q8("Temporal." + t)
  }), Object.defineProperties(s, {
    ...nd(i),
    ...V0(t)
  }), [s, (l) => {
    const c = Object.create(s.prototype);
    return JP(c, l), c;
  }, a];
}
function uf(t) {
  if (Si(t) || t.calendar !== void 0 || t.timeZone !== void 0)
    throw new TypeError(U4e);
  return t;
}
function xm(t) {
  return EU(t) || hr;
}
function EU(t) {
  const { calendar: e } = t;
  if (e !== void 0)
    return zb(e);
}
function zb(t) {
  if (xi(t)) {
    const { calendar: e } = Si(t) || {};
    if (!e)
      throw new TypeError(Uz(t));
    return e;
  }
  return ((e) => Mb(Lxe(ei(e))))(t);
}
function gk(t) {
  const e = {};
  for (const r in t)
    e[r] = (n) => {
      const { calendar: i } = n;
      return Ft(i)[r](n);
    };
  return e;
}
function Jc() {
  throw new TypeError(V4e);
}
function as(t) {
  if (xi(t)) {
    const { timeZone: e } = Si(t) || {};
    if (!e)
      throw new TypeError(Hz(t));
    return e;
  }
  return ((e) => TA(Mxe(ei(e))))(t);
}
function un(t) {
  if (xi(t)) {
    const e = Si(t);
    return e && e.branding === rk ? e : r4e(t);
  }
  return Txe(t);
}
function Cf(t) {
  if (t !== void 0) {
    if (xi(t)) {
      const e = Si(t) || {};
      switch (e.branding) {
        case Yc:
        case vm:
          return e;
        case cf:
          return il(e);
      }
      const r = xm(t);
      return {
        ...Kxe(as, Yt, Ft(r), t),
        calendar: r
      };
    }
    return _xe(t);
  }
}
function bl(t, e) {
  if (xi(t)) {
    const n = Si(t) || {};
    switch (n.branding) {
      case ek:
        return mr(e), n;
      case cf:
        return mr(e), la(n);
      case Yc:
        return mr(e), Dz(Yt, n);
    }
    return t4e(t, e);
  }
  const r = Oxe(t);
  return mr(e), r;
}
function mk(t) {
  return t === void 0 ? void 0 : bl(t);
}
function dp(t, e) {
  if (xi(t)) {
    const n = Si(t) || {};
    switch (n.branding) {
      case cf:
        return mr(e), n;
      case vm:
        return mr(e), mo({
          ...n,
          ...Zi
        });
      case Yc:
        return mr(e), Mz(Yt, n);
    }
    return Zxe(Ft(xm(t)), t, e);
  }
  const r = Ixe(t);
  return mr(e), r;
}
function YP(t, e) {
  if (xi(t)) {
    const n = Si(t);
    if (n && n.branding === XA)
      return mr(e), n;
    const i = EU(t);
    return e4e(Ft(i || hr), !i, t, e);
  }
  const r = Rxe(Ft, t);
  return mr(e), r;
}
function fp(t, e) {
  if (xi(t)) {
    const n = Si(t);
    return n && n.branding === JA ? (mr(e), n) : Xxe(Ft(xm(t)), t, e);
  }
  const r = Pxe(Ft, t);
  return mr(e), r;
}
function gp(t, e) {
  if (xi(t)) {
    const n = Si(t) || {};
    switch (n.branding) {
      case vm:
        return mr(e), n;
      case cf:
        return mr(e), il(n);
      case Yc:
        return mr(e), Nz(Yt, n);
    }
    return Jxe(Ft(xm(t)), t, e);
  }
  const r = kA(t);
  return mr(e), r;
}
function mp(t, e) {
  if (xi(t)) {
    const r = Si(t);
    if (r && r.branding === Yc)
      return bb(e), r;
    const n = xm(t);
    return Yxe(as, Yt, Ft(n), n, t, e);
  }
  return Cxe(t, e);
}
function ZP(t) {
  return Ba((e) => (r) => e(j4(r)), t);
}
function j4(t) {
  return Ss(t, Yt);
}
function yp(t) {
  if (xi(t)) {
    const e = Si(t);
    if (e)
      switch (e.branding) {
        case tk:
          return e;
        case Yc:
          return nl(e.epochNanoseconds);
      }
  }
  return kxe(t);
}
function T6e() {
  function t(s, o) {
    return new e(s, o);
  }
  function e(s, o = /* @__PURE__ */ Object.create(null)) {
    f2.set(this, ((a, l) => {
      const c = new Hl(a, l), p = c.resolvedOptions(), h = p.locale, d = fo(Object.keys(l), p), v = ws(N6e), m = (b, ...f) => {
        if (b) {
          if (f.length !== 2)
            throw new TypeError(K3);
          for (const g of f)
            if (g === void 0)
              throw new TypeError(K3);
        }
        b || f[0] !== void 0 || (f = []);
        const E = f.map((g) => Si(g) || Number(g));
        let A, x = 0;
        for (const g of E) {
          const w = typeof g == "object" ? g.branding : void 0;
          if (x++ && w !== A)
            throw new TypeError(K3);
          A = w;
        }
        return A ? v(A)(h, d, ...E) : [c, ...E];
      };
      return m.X = c, m;
    })(s, o));
  }
  const r = Hl.prototype, n = Object.getOwnPropertyDescriptors(r), i = Object.getOwnPropertyDescriptors(Hl);
  for (const s in n) {
    const o = n[s], a = s.startsWith("format") && L6e(s);
    typeof o.value == "function" ? o.value = s === "constructor" ? t : a || M6e(s) : a && (o.get = function() {
      if (!f2.has(this))
        throw new TypeError(L4);
      return (...l) => a.apply(this, l);
    }, Object.defineProperties(o.get, V0(`get ${s}`)));
  }
  return i.prototype.value = e.prototype = Object.create({}, n), Object.defineProperties(t, i), t;
}
function L6e(t) {
  return Object.defineProperties(function(...e) {
    const r = f2.get(this), [n, ...i] = r(t.includes("Range"), ...e);
    return n[t](...i);
  }, V0(t));
}
function M6e(t) {
  return Object.defineProperties(function(...e) {
    return f2.get(this).X[t](...e);
  }, V0(t));
}
function N6e(t) {
  const e = z6e[t];
  if (!e)
    throw new TypeError(aEe(t));
  return qc(e, ws($z), 1);
}
const d2 = /* @__PURE__ */ new WeakMap(), Si = /* @__PURE__ */ d2.get.bind(d2), JP = /* @__PURE__ */ d2.set.bind(d2), SU = {
  era: nxe,
  eraYear: PF,
  year: K8,
  month: ga,
  daysInMonth: ga,
  daysInYear: ga,
  inLeapYear: dEe,
  monthsInYear: ga
}, yk = {
  monthCode: ei
}, AU = {
  day: ga
}, D6e = {
  dayOfWeek: ga,
  dayOfYear: ga,
  weekOfYear: ixe,
  yearOfWeek: PF,
  daysInWeek: ga
}, vk = /* @__PURE__ */ gk(/* @__PURE__ */ Object.assign({}, SU, yk, AU, D6e)), $6e = /* @__PURE__ */ gk({
  ...SU,
  ...yk
}), j6e = /* @__PURE__ */ gk({
  ...yk,
  ...AU
}), Em = {
  calendarId: (t) => t.calendar
}, B6e = /* @__PURE__ */ db((t) => (e) => e[t], xr.concat("sign")), bk = /* @__PURE__ */ db((t, e) => (r) => r[yo[e]], ol), kU = {
  epochMilliseconds: dA,
  epochNanoseconds: axe
}, [F6e, tn, VIe] = Zc(rk, y4e, {
  ...B6e,
  blank: Sxe
}, {
  with: (t, e) => tn(c4e(t, e)),
  negated: (t) => tn(AA(t)),
  abs: (t) => tn(Exe(t)),
  add: (t, e, r) => tn($P(Cf, Ft, Yt, 0, t, un(e), r)),
  subtract: (t, e, r) => tn($P(Cf, Ft, Yt, 1, t, un(e), r)),
  round: (t, e) => tn(xxe(Cf, Ft, Yt, t, e)),
  total: (t, e) => lxe(Cf, Ft, Yt, t, e),
  toLocaleString(t, e, r) {
    return Intl.DurationFormat ? new Intl.DurationFormat(e, r).format(this) : H3(t);
  },
  toString: H3,
  toJSON: (t) => H3(t),
  valueOf: Jc
}, {
  from: (t) => tn(un(t)),
  compare: (t, e, r) => Dxe(Cf, Ft, Yt, un(t), un(e), r)
}), z6e = {
  Instant: mU,
  PlainDateTime: yU,
  PlainDate: vU,
  PlainTime: bU,
  PlainYearMonth: wU,
  PlainMonthDay: xU
}, U6e = /* @__PURE__ */ qc(mU), V6e = /* @__PURE__ */ qc(O6e), H6e = /* @__PURE__ */ qc(yU), G6e = /* @__PURE__ */ qc(vU), W6e = /* @__PURE__ */ qc(bU), q6e = /* @__PURE__ */ qc(wU), Q6e = /* @__PURE__ */ qc(xU), [K6e, Cl] = Zc(ek, m4e, bk, {
  with(t, e, r) {
    return Cl(l4e(this, uf(e), r));
  },
  add: (t, e) => Cl(DP(0, t, un(e))),
  subtract: (t, e) => Cl(DP(1, t, un(e))),
  until: (t, e, r) => tn(GP(0, t, bl(e), r)),
  since: (t, e, r) => tn(GP(1, t, bl(e), r)),
  round: (t, e) => Cl(pxe(t, e)),
  equals: (t, e) => Vxe(t, bl(e)),
  toLocaleString(t, e, r) {
    const [n, i] = W6e(e, r, t);
    return n.format(i);
  },
  toString: PP,
  toJSON: (t) => PP(t),
  valueOf: Jc
}, {
  from: (t, e) => Cl(bl(t, e)),
  compare: (t, e) => MA(bl(t), bl(e))
}), [Y6e, _o] = Zc(cf, sr(p4e, pm), {
  ...Em,
  ...vk,
  ...bk
}, {
  with: (t, e, r) => _o(i4e(Ft, t, uf(e), r)),
  withCalendar: (t, e) => _o(BA(t, zb(e))),
  withPlainTime: (t, e) => _o(O4e(t, mk(e))),
  add: (t, e, r) => _o(LP(Ft, 0, t, un(e), r)),
  subtract: (t, e, r) => _o(LP(Ft, 1, t, un(e), r)),
  until: (t, e, r) => tn(UP(Ft, 0, t, dp(e), r)),
  since: (t, e, r) => tn(UP(Ft, 1, t, dp(e), r)),
  round: (t, e) => _o(hxe(t, e)),
  equals: (t, e) => Bxe(t, dp(e)),
  toZonedDateTime: (t, e, r) => ni(w4e(Yt, t, as(e), r)),
  toPlainDate: (t) => Oo(il(t)),
  toPlainTime: (t) => Cl(la(t)),
  toLocaleString(t, e, r) {
    const [n, i] = H6e(e, r, t);
    return n.format(i);
  },
  toString: kP,
  toJSON: (t) => kP(t),
  valueOf: Jc
}, {
  from: (t, e) => _o(dp(t, e)),
  compare: (t, e) => gz(dp(t), dp(e))
}), [Z6e, B4, HIe] = Zc(XA, sr(g4e, pm), {
  ...Em,
  ...j6e
}, {
  with: (t, e, r) => B4(a4e(Ft, t, uf(e), r)),
  equals: (t, e) => Uxe(t, YP(e)),
  toPlainDate(t, e) {
    return Oo(_4e(Ft, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = Q6e(e, r, t);
    return n.format(i);
  },
  toString: IP,
  toJSON: (t) => IP(t),
  valueOf: Jc
}, {
  from: (t, e) => B4(YP(t, e))
}), [J6e, Nf, GIe] = Zc(JA, sr(f4e, pm), {
  ...Em,
  ...$6e
}, {
  with: (t, e, r) => Nf(o4e(Ft, t, uf(e), r)),
  add: (t, e, r) => Nf(NP(Ft, 0, t, un(e), r)),
  subtract: (t, e, r) => Nf(NP(Ft, 1, t, un(e), r)),
  until: (t, e, r) => tn(HP(Ft, 0, t, fp(e), r)),
  since: (t, e, r) => tn(HP(Ft, 1, t, fp(e), r)),
  equals: (t, e) => zxe(t, fp(e)),
  toPlainDate(t, e) {
    return Oo(k4e(Ft, t, this, e));
  },
  toLocaleString(t, e, r) {
    const [n, i] = q6e(e, r, t);
    return n.format(i);
  },
  toString: CP,
  toJSON: (t) => CP(t),
  valueOf: Jc
}, {
  from: (t, e) => Nf(fp(t, e)),
  compare: (t, e) => of(fp(t), fp(e))
}), [X6e, Oo, WIe] = Zc(vm, sr(d4e, pm), {
  ...Em,
  ...vk
}, {
  with: (t, e, r) => Oo(s4e(Ft, t, uf(e), r)),
  withCalendar: (t, e) => Oo(BA(t, zb(e))),
  add: (t, e, r) => Oo(MP(Ft, 0, t, un(e), r)),
  subtract: (t, e, r) => Oo(MP(Ft, 1, t, un(e), r)),
  until: (t, e, r) => tn(VP(Ft, 0, t, gp(e), r)),
  since: (t, e, r) => tn(VP(Ft, 1, t, gp(e), r)),
  equals: (t, e) => Fxe(t, gp(e)),
  toZonedDateTime(t, e) {
    const r = xi(e) ? e : {
      timeZone: e
    };
    return ni(x4e(as, bl, Yt, t, r));
  },
  toPlainDateTime: (t, e) => _o(E4e(t, mk(e))),
  toPlainYearMonth(t) {
    return Nf(S4e(Ft, t, this));
  },
  toPlainMonthDay(t) {
    return B4(A4e(Ft, t, this));
  },
  toLocaleString(t, e, r) {
    const [n, i] = G6e(e, r, t);
    return n.format(i);
  },
  toString: _P,
  toJSON: (t) => _P(t),
  valueOf: Jc
}, {
  from: (t, e) => Oo(gp(t, e)),
  compare: (t, e) => of(gp(t), gp(e))
}), [e5e, ni] = Zc(Yc, sr(h4e, pm, Nxe), {
  ...kU,
  ...Em,
  ...ZP(vk),
  ...ZP(bk),
  offset: (t) => cm(j4(t).offsetNanoseconds),
  offsetNanoseconds: (t) => j4(t).offsetNanoseconds,
  timeZoneId: (t) => t.timeZone,
  hoursInDay: (t) => dxe(Yt, t)
}, {
  with: (t, e, r) => ni(n4e(Ft, Yt, t, uf(e), r)),
  withCalendar: (t, e) => ni(BA(t, zb(e))),
  withTimeZone: (t, e) => ni(T4e(t, as(e))),
  withPlainTime: (t, e) => ni(R4e(Yt, t, mk(e))),
  add: (t, e, r) => ni(TP(Ft, Yt, 0, t, un(e), r)),
  subtract: (t, e, r) => ni(TP(Ft, Yt, 1, t, un(e), r)),
  until: (t, e, r) => tn(wn(zP(Ft, Yt, 0, t, mp(e), r))),
  since: (t, e, r) => tn(wn(zP(Ft, Yt, 1, t, mp(e), r))),
  round: (t, e) => ni(uxe(Yt, t, e)),
  startOfDay: (t) => ni(fxe(Yt, t)),
  equals: (t, e) => jxe(t, mp(e)),
  toInstant: (t) => wl(b4e(t)),
  toPlainDateTime: (t) => _o(Mz(Yt, t)),
  toPlainDate: (t) => Oo(Nz(Yt, t)),
  toPlainTime: (t) => Cl(Dz(Yt, t)),
  toLocaleString(t, e, r = {}) {
    const [n, i] = V6e(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => AP(Yt, t, e),
  toJSON: (t) => AP(Yt, t),
  valueOf: Jc,
  getTimeZoneTransition(t, e) {
    const { timeZone: r, epochNanoseconds: n } = t, i = oxe(e), s = Yt(r).O(n, i);
    return s ? ni({
      ...t,
      epochNanoseconds: s
    }) : null;
  }
}, {
  from: (t, e) => ni(mp(t, e)),
  compare: (t, e) => fz(mp(t), mp(e))
}), [t5e, wl, qIe] = Zc(tk, u4e, kU, {
  add: (t, e) => wl(OP(0, t, un(e))),
  subtract: (t, e) => wl(OP(1, t, un(e))),
  until: (t, e, r) => tn(FP(0, t, yp(e), r)),
  since: (t, e, r) => tn(FP(1, t, yp(e), r)),
  round: (t, e) => wl(cxe(t, e)),
  equals: (t, e) => $xe(t, yp(e)),
  toZonedDateTimeISO: (t, e) => ni(v4e(t, as(e))),
  toLocaleString(t, e, r) {
    const [n, i] = U6e(e, r, t);
    return n.format(i);
  },
  toString: (t, e) => SP(as, Yt, t, e),
  toJSON: (t) => SP(as, Yt, t),
  valueOf: Jc
}, {
  from: (t) => wl(yp(t)),
  fromEpochMilliseconds: (t) => wl(C4e(t)),
  fromEpochNanoseconds: (t) => wl(I4e(t)),
  compare: (t, e) => dz(yp(t), yp(e))
}), r5e = /* @__PURE__ */ Object.defineProperties({}, {
  ...q8("Temporal.Now"),
  ...nd({
    timeZoneId: () => kf(),
    instant: () => wl(nl(T4())),
    zonedDateTimeISO: (t = kf()) => ni(go(T4(), as(t), hr)),
    plainDateTimeISO: (t = kf()) => _o(mo(Q3(Yt(as(t))), hr)),
    plainDateISO: (t = kf()) => Oo(il(Q3(Yt(as(t))), hr)),
    plainTimeISO: (t = kf()) => Cl(la(Q3(Yt(as(t)))))
  })
}), e1 = /* @__PURE__ */ Object.defineProperties({}, {
  ...q8("Temporal"),
  ...nd({
    PlainYearMonth: J6e,
    PlainMonthDay: Z6e,
    PlainDate: X6e,
    PlainTime: K6e,
    PlainDateTime: Y6e,
    ZonedDateTime: e5e,
    Instant: t5e,
    Duration: F6e,
    Now: r5e
  })
}), n5e = /* @__PURE__ */ T6e(), f2 = /* @__PURE__ */ new WeakMap();
nd({
  DateTimeFormat: n5e
});
var F4 = 9e15, Xc = 1e9, z4 = "0123456789abcdef", g2 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", m2 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", U4 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -9e15,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: F4,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, _U, ma, Mt = !0, Ub = "[DecimalError] ", Ah = Ub + "Invalid argument: ", CU = Ub + "Precision limit exceeded", IU = Ub + "crypto unavailable", Bn = Math.floor, An = Math.pow, i5e = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, s5e = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, o5e = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, a5e = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Hs = 1e7, wt = 7, l5e = 9007199254740991, c5e = g2.length - 1, V4 = m2.length - 1, Ue = { name: "[object Decimal]" };
Ue.absoluteValue = Ue.abs = function() {
  var t = new this.constructor(this);
  return t.s < 0 && (t.s = 1), mt(t);
};
Ue.ceil = function() {
  return mt(new this.constructor(this), this.e + 1, 2);
};
Ue.comparedTo = Ue.cmp = function(t) {
  var e, r, n, i, s = this, o = s.d, a = (t = new s.constructor(t)).d, l = s.s, c = t.s;
  if (!o || !a)
    return !l || !c ? NaN : l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? l : a[0] ? -c : 0;
  if (l !== c) return l;
  if (s.e !== t.e) return s.e > t.e ^ l < 0 ? 1 : -1;
  for (n = o.length, i = a.length, e = 0, r = n < i ? n : i; e < r; ++e)
    if (o[e] !== a[e]) return o[e] > a[e] ^ l < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
};
Ue.cosine = Ue.cos = function() {
  var t, e, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + wt, n.rounding = 1, r = u5e(n, LU(n, r)), n.precision = t, n.rounding = e, mt(ma == 2 || ma == 3 ? r.neg() : r, t, e, !0)) : new n(1) : new n(NaN);
};
Ue.cubeRoot = Ue.cbrt = function() {
  var t, e, r, n, i, s, o, a, l, c, p = this, h = p.constructor;
  if (!p.isFinite() || p.isZero()) return new h(p);
  for (Mt = !1, s = p.s * Math.pow(p.s * p, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = pn(p.d), t = p.e, (s = (t - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Math.pow(r, 1 / 3), t = Bn((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + t : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + t), n = new h(r), n.s = p.s) : n = new h(s.toString()), o = (t = h.precision) + 3; ; )
    if (a = n, l = a.times(a).times(a), c = l.plus(p), n = ar(c.plus(p).times(a), c.plus(l), o + 2, 1), pn(a.d).slice(0, o) === (r = pn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (mt(a, t + 1, 0), a.times(a).times(a).eq(p))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (mt(n, t + 1, 1), e = !n.times(n).times(n).eq(p));
        break;
      }
  return Mt = !0, mt(n, t, h.rounding, e);
};
Ue.decimalPlaces = Ue.dp = function() {
  var t, e = this.d, r = NaN;
  if (e) {
    if (t = e.length - 1, r = (t - Bn(this.e / wt)) * wt, t = e[t], t) for (; t % 10 == 0; t /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
Ue.dividedBy = Ue.div = function(t) {
  return ar(this, new this.constructor(t));
};
Ue.dividedToIntegerBy = Ue.divToInt = function(t) {
  var e = this, r = e.constructor;
  return mt(ar(e, new r(t), 0, 1, 1), r.precision, r.rounding);
};
Ue.equals = Ue.eq = function(t) {
  return this.cmp(t) === 0;
};
Ue.floor = function() {
  return mt(new this.constructor(this), this.e + 1, 3);
};
Ue.greaterThan = Ue.gt = function(t) {
  return this.cmp(t) > 0;
};
Ue.greaterThanOrEqualTo = Ue.gte = function(t) {
  var e = this.cmp(t);
  return e == 1 || e === 0;
};
Ue.hyperbolicCosine = Ue.cosh = function() {
  var t, e, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (t = Math.ceil(i / 3), e = Math.pow(4, -t).toString()) : (t = 16, e = "2.3283064365386962890625e-10"), s = ad(o, 1, s.times(e), new o(1), !0);
  for (var l, c = t, p = new o(8); c--; )
    l = s.times(s), s = a.minus(l.times(p.minus(l.times(p))));
  return mt(s, o.precision = r, o.rounding = n, !0);
};
Ue.hyperbolicSine = Ue.sinh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero()) return new s(i);
  if (e = s.precision, r = s.rounding, s.precision = e + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = ad(s, 2, i, i, !0);
  else {
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, i = i.times(Math.pow(5, -t)), i = ad(s, 2, i, i, !0);
    for (var o, a = new s(5), l = new s(16), c = new s(20); t--; )
      o = i.times(i), i = i.times(a.plus(o.times(l.times(o).plus(c))));
  }
  return s.precision = e, s.rounding = r, mt(i, e, r, !0);
};
Ue.hyperbolicTangent = Ue.tanh = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 7, n.rounding = 1, ar(r.sinh(), r.cosh(), n.precision = t, n.rounding = e)) : new n(r.s);
};
Ue.inverseCosine = Ue.acos = function() {
  var t, e = this, r = e.constructor, n = e.abs().cmp(1), i = r.precision, s = r.rounding;
  return n !== -1 ? n === 0 ? e.isNeg() ? Ms(r, i, s) : new r(0) : new r(NaN) : e.isZero() ? Ms(r, i + 4, s).times(0.5) : (r.precision = i + 6, r.rounding = 1, e = e.asin(), t = Ms(r, i + 4, s).times(0.5), r.precision = i, r.rounding = s, t.minus(e));
};
Ue.inverseHyperbolicCosine = Ue.acosh = function() {
  var t, e, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, Mt = !1, r = r.times(r).minus(1).sqrt().plus(r), Mt = !0, n.precision = t, n.rounding = e, r.ln()) : new n(r);
};
Ue.inverseHyperbolicSine = Ue.asinh = function() {
  var t, e, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, Mt = !1, r = r.times(r).plus(1).sqrt().plus(r), Mt = !0, n.precision = t, n.rounding = e, r.ln());
};
Ue.inverseHyperbolicTangent = Ue.atanh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (t = s.precision, e = s.rounding, n = i.sd(), Math.max(n, t) < 2 * -i.e - 1 ? mt(new s(i), t, e, !0) : (s.precision = r = n - i.e, i = ar(i.plus(1), new s(1).minus(i), r + t, 1), s.precision = t + 4, s.rounding = 1, i = i.ln(), s.precision = t, s.rounding = e, i.times(0.5))) : new s(NaN);
};
Ue.inverseSine = Ue.asin = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (e = i.abs().cmp(1), r = s.precision, n = s.rounding, e !== -1 ? e === 0 ? (t = Ms(s, r + 4, n).times(0.5), t.s = i.s, t) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
Ue.inverseTangent = Ue.atan = function() {
  var t, e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new p(c);
    if (c.abs().eq(1) && h + 4 <= V4)
      return o = Ms(p, h + 4, d).times(0.25), o.s = c.s, o;
  } else {
    if (!c.s) return new p(NaN);
    if (h + 4 <= V4)
      return o = Ms(p, h + 4, d).times(0.5), o.s = c.s, o;
  }
  for (p.precision = a = h + 10, p.rounding = 1, r = Math.min(28, a / wt + 2 | 0), t = r; t; --t) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (Mt = !1, e = Math.ceil(a / wt), n = 1, l = c.times(c), o = new p(c), i = c; t !== -1; )
    if (i = i.times(l), s = o.minus(i.div(n += 2)), i = i.times(l), o = s.plus(i.div(n += 2)), o.d[e] !== void 0) for (t = e; o.d[t] === s.d[t] && t--; ) ;
  return r && (o = o.times(2 << r - 1)), Mt = !0, mt(o, p.precision = h, p.rounding = d, !0);
};
Ue.isFinite = function() {
  return !!this.d;
};
Ue.isInteger = Ue.isInt = function() {
  return !!this.d && Bn(this.e / wt) > this.d.length - 2;
};
Ue.isNaN = function() {
  return !this.s;
};
Ue.isNegative = Ue.isNeg = function() {
  return this.s < 0;
};
Ue.isPositive = Ue.isPos = function() {
  return this.s > 0;
};
Ue.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
Ue.lessThan = Ue.lt = function(t) {
  return this.cmp(t) < 0;
};
Ue.lessThanOrEqualTo = Ue.lte = function(t) {
  return this.cmp(t) < 1;
};
Ue.logarithm = Ue.log = function(t) {
  var e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding, v = 5;
  if (t == null)
    t = new p(10), e = !0;
  else {
    if (t = new p(t), r = t.d, t.s < 0 || !r || !r[0] || t.eq(1)) return new p(NaN);
    e = t.eq(10);
  }
  if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1))
    return new p(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (e)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      s = i !== 1;
    }
  if (Mt = !1, a = h + v, o = Tl(c, a), n = e ? y2(p, a + 10) : Tl(t, a), l = ar(o, n, a, 1), Z0(l.d, i = h, d))
    do
      if (a += 10, o = Tl(c, a), n = e ? y2(p, a + 10) : Tl(t, a), l = ar(o, n, a, 1), !s) {
        +pn(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = mt(l, h + 1, 0));
        break;
      }
    while (Z0(l.d, i += 10, d));
  return Mt = !0, mt(l, h, d);
};
Ue.minus = Ue.sub = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, v = this, m = v.constructor;
  if (t = new m(t), !v.d || !t.d)
    return !v.s || !t.s ? t = new m(NaN) : v.d ? t.s = -t.s : t = new m(t.d || v.s !== t.s ? v : NaN), t;
  if (v.s != t.s)
    return t.s = -t.s, v.plus(t);
  if (c = v.d, d = t.d, a = m.precision, l = m.rounding, !c[0] || !d[0]) {
    if (d[0]) t.s = -t.s;
    else if (c[0]) t = new m(v);
    else return new m(l === 3 ? -0 : 0);
    return Mt ? mt(t, a, l) : t;
  }
  if (r = Bn(t.e / wt), p = Bn(v.e / wt), c = c.slice(), s = p - r, s) {
    for (h = s < 0, h ? (e = c, s = -s, o = d.length) : (e = d, r = p, o = c.length), n = Math.max(Math.ceil(a / wt), o) + 2, s > n && (s = n, e.length = 1), e.reverse(), n = s; n--; ) e.push(0);
    e.reverse();
  } else {
    for (n = c.length, o = d.length, h = n < o, h && (o = n), n = 0; n < o; n++)
      if (c[n] != d[n]) {
        h = c[n] < d[n];
        break;
      }
    s = 0;
  }
  for (h && (e = c, c = d, d = e, t.s = -t.s), o = c.length, n = d.length - o; n > 0; --n) c[o++] = 0;
  for (n = d.length; n > s; ) {
    if (c[--n] < d[n]) {
      for (i = n; i && c[--i] === 0; ) c[i] = Hs - 1;
      --c[i], c[n] += Hs;
    }
    c[n] -= d[n];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --r;
  return c[0] ? (t.d = c, t.e = Vb(c, r), Mt ? mt(t, a, l) : t) : new m(l === 3 ? -0 : 0);
};
Ue.modulo = Ue.mod = function(t) {
  var e, r = this, n = r.constructor;
  return t = new n(t), !r.d || !t.s || t.d && !t.d[0] ? new n(NaN) : !t.d || r.d && !r.d[0] ? mt(new n(r), n.precision, n.rounding) : (Mt = !1, n.modulo == 9 ? (e = ar(r, t.abs(), 0, 3, 1), e.s *= t.s) : e = ar(r, t, 0, n.modulo, 1), e = e.times(t), Mt = !0, r.minus(e));
};
Ue.naturalExponential = Ue.exp = function() {
  return H4(this);
};
Ue.naturalLogarithm = Ue.ln = function() {
  return Tl(this);
};
Ue.negated = Ue.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s, mt(t);
};
Ue.plus = Ue.add = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h = this, d = h.constructor;
  if (t = new d(t), !h.d || !t.d)
    return !h.s || !t.s ? t = new d(NaN) : h.d || (t = new d(t.d || h.s === t.s ? h : NaN)), t;
  if (h.s != t.s)
    return t.s = -t.s, h.minus(t);
  if (c = h.d, p = t.d, a = d.precision, l = d.rounding, !c[0] || !p[0])
    return p[0] || (t = new d(h)), Mt ? mt(t, a, l) : t;
  if (s = Bn(h.e / wt), n = Bn(t.e / wt), c = c.slice(), i = s - n, i) {
    for (i < 0 ? (r = c, i = -i, o = p.length) : (r = p, n = s, o = c.length), s = Math.ceil(a / wt), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = c.length, i = p.length, o - i < 0 && (i = o, r = p, p = c, c = r), e = 0; i; )
    e = (c[--i] = c[i] + p[i] + e) / Hs | 0, c[i] %= Hs;
  for (e && (c.unshift(e), ++n), o = c.length; c[--o] == 0; ) c.pop();
  return t.d = c, t.e = Vb(c, n), Mt ? mt(t, a, l) : t;
};
Ue.precision = Ue.sd = function(t) {
  var e, r = this;
  if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(Ah + t);
  return r.d ? (e = PU(r.d), t && r.e + 1 > e && (e = r.e + 1)) : e = NaN, e;
};
Ue.round = function() {
  var t = this, e = t.constructor;
  return mt(new e(t), t.e + 1, e.rounding);
};
Ue.sine = Ue.sin = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + wt, n.rounding = 1, r = p5e(n, LU(n, r)), n.precision = t, n.rounding = e, mt(ma > 2 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Ue.squareRoot = Ue.sqrt = function() {
  var t, e, r, n, i, s, o = this, a = o.d, l = o.e, c = o.s, p = o.constructor;
  if (c !== 1 || !a || !a[0])
    return new p(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (Mt = !1, c = Math.sqrt(+o), c == 0 || c == 1 / 0 ? (e = pn(a), (e.length + l) % 2 == 0 && (e += "0"), c = Math.sqrt(e), l = Bn((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? e = "1e" + l : (e = c.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + l), n = new p(e)) : n = new p(c.toString()), r = (l = p.precision) + 3; ; )
    if (s = n, n = s.plus(ar(o, s, r + 2, 1)).times(0.5), pn(s.d).slice(0, r) === (e = pn(n.d)).slice(0, r))
      if (e = e.slice(r - 3, r + 1), e == "9999" || !i && e == "4999") {
        if (!i && (mt(s, l + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (mt(n, l + 1, 1), t = !n.times(n).eq(o));
        break;
      }
  return Mt = !0, mt(n, l, p.rounding, t);
};
Ue.tangent = Ue.tan = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = ar(r, new n(1).minus(r.times(r)).sqrt(), t + 10, 0), n.precision = t, n.rounding = e, mt(ma == 2 || ma == 4 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Ue.times = Ue.mul = function(t) {
  var e, r, n, i, s, o, a, l, c, p = this, h = p.constructor, d = p.d, v = (t = new h(t)).d;
  if (t.s *= p.s, !d || !d[0] || !v || !v[0])
    return new h(!t.s || d && !d[0] && !v || v && !v[0] && !d ? NaN : !d || !v ? t.s / 0 : t.s * 0);
  for (r = Bn(p.e / wt) + Bn(t.e / wt), l = d.length, c = v.length, l < c && (s = d, d = v, v = s, o = l, l = c, c = o), s = [], o = l + c, n = o; n--; ) s.push(0);
  for (n = c; --n >= 0; ) {
    for (e = 0, i = l + n; i > n; )
      a = s[i] + v[n] * d[i - n - 1] + e, s[i--] = a % Hs | 0, e = a / Hs | 0;
    s[i] = (s[i] + e) % Hs | 0;
  }
  for (; !s[--o]; ) s.pop();
  return e ? ++r : s.shift(), t.d = s, t.e = Vb(s, r), Mt ? mt(t, h.precision, h.rounding) : t;
};
Ue.toBinary = function(t, e) {
  return wk(this, 2, t, e);
};
Ue.toDecimalPlaces = Ue.toDP = function(t, e) {
  var r = this, n = r.constructor;
  return r = new n(r), t === void 0 ? r : (pi(t, 0, Xc), e === void 0 ? e = n.rounding : pi(e, 0, 8), mt(r, t + r.e + 1, e));
};
Ue.toExponential = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Yo(n, !0) : (pi(t, 0, Xc), e === void 0 ? e = i.rounding : pi(e, 0, 8), n = mt(new i(n), t + 1, e), r = Yo(n, !0, t + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ue.toFixed = function(t, e) {
  var r, n, i = this, s = i.constructor;
  return t === void 0 ? r = Yo(i) : (pi(t, 0, Xc), e === void 0 ? e = s.rounding : pi(e, 0, 8), n = mt(new s(i), t + i.e + 1, e), r = Yo(n, !1, t + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
Ue.toFraction = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, v = this, m = v.d, b = v.constructor;
  if (!m) return new b(v);
  if (c = r = new b(1), n = l = new b(0), e = new b(n), s = e.e = PU(m) - v.e - 1, o = s % wt, e.d[0] = An(10, o < 0 ? wt + o : o), t == null)
    t = s > 0 ? e : c;
  else {
    if (a = new b(t), !a.isInt() || a.lt(c)) throw Error(Ah + a);
    t = a.gt(e) ? s > 0 ? e : c : a;
  }
  for (Mt = !1, a = new b(pn(m)), p = b.precision, b.precision = s = m.length * wt * 2; h = ar(a, e, 0, 1, 1), i = r.plus(h.times(n)), i.cmp(t) != 1; )
    r = n, n = i, i = c, c = l.plus(h.times(i)), l = i, i = e, e = a.minus(h.times(i)), a = i;
  return i = ar(t.minus(r), n, 0, 1, 1), l = l.plus(i.times(c)), r = r.plus(i.times(n)), l.s = c.s = v.s, d = ar(c, n, s, 1).minus(v).abs().cmp(ar(l, r, s, 1).minus(v).abs()) < 1 ? [c, n] : [l, r], b.precision = p, Mt = !0, d;
};
Ue.toHexadecimal = Ue.toHex = function(t, e) {
  return wk(this, 16, t, e);
};
Ue.toNearest = function(t, e) {
  var r = this, n = r.constructor;
  if (r = new n(r), t == null) {
    if (!r.d) return r;
    t = new n(1), e = n.rounding;
  } else {
    if (t = new n(t), e === void 0 ? e = n.rounding : pi(e, 0, 8), !r.d) return t.s ? r : t;
    if (!t.d)
      return t.s && (t.s = r.s), t;
  }
  return t.d[0] ? (Mt = !1, r = ar(r, t, 0, e, 1).times(t), Mt = !0, mt(r)) : (t.s = r.s, r = t), r;
};
Ue.toNumber = function() {
  return +this;
};
Ue.toOctal = function(t, e) {
  return wk(this, 8, t, e);
};
Ue.toPower = Ue.pow = function(t) {
  var e, r, n, i, s, o, a = this, l = a.constructor, c = +(t = new l(t));
  if (!a.d || !t.d || !a.d[0] || !t.d[0]) return new l(An(+a, c));
  if (a = new l(a), a.eq(1)) return a;
  if (n = l.precision, s = l.rounding, t.eq(1)) return mt(a, n, s);
  if (e = Bn(t.e / wt), e >= t.d.length - 1 && (r = c < 0 ? -c : c) <= l5e)
    return i = RU(l, a, r, n), t.s < 0 ? new l(1).div(i) : mt(i, n, s);
  if (o = a.s, o < 0) {
    if (e < t.d.length - 1) return new l(NaN);
    if (!(t.d[e] & 1) && (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = An(+a, c), e = r == 0 || !isFinite(r) ? Bn(c * (Math.log("0." + pn(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, e > l.maxE + 1 || e < l.minE - 1 ? new l(e > 0 ? o / 0 : 0) : (Mt = !1, l.rounding = a.s = 1, r = Math.min(12, (e + "").length), i = H4(t.times(Tl(a, n + r)), n), i.d && (i = mt(i, n + 5, 1), Z0(i.d, n, s) && (e = n + 10, i = mt(H4(t.times(Tl(a, e + r)), e), e + 5, 1), +pn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = mt(i, n + 1, 0)))), i.s = o, Mt = !0, l.rounding = s, mt(i, n, s));
};
Ue.toPrecision = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Yo(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (pi(t, 1, Xc), e === void 0 ? e = i.rounding : pi(e, 0, 8), n = mt(new i(n), t, e), r = Yo(n, t <= n.e || n.e <= i.toExpNeg, t)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ue.toSignificantDigits = Ue.toSD = function(t, e) {
  var r = this, n = r.constructor;
  return t === void 0 ? (t = n.precision, e = n.rounding) : (pi(t, 1, Xc), e === void 0 ? e = n.rounding : pi(e, 0, 8)), mt(new n(r), t, e);
};
Ue.toString = function() {
  var t = this, e = t.constructor, r = Yo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() && !t.isZero() ? "-" + r : r;
};
Ue.truncated = Ue.trunc = function() {
  return mt(new this.constructor(this), this.e + 1, 1);
};
Ue.valueOf = Ue.toJSON = function() {
  var t = this, e = t.constructor, r = Yo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() ? "-" + r : r;
};
function pn(t) {
  var e, r, n, i = t.length - 1, s = "", o = t[0];
  if (i > 0) {
    for (s += o, e = 1; e < i; e++)
      n = t[e] + "", r = wt - n.length, r && (s += xl(r)), s += n;
    o = t[e], n = o + "", r = wt - n.length, r && (s += xl(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function pi(t, e, r) {
  if (t !== ~~t || t < e || t > r)
    throw Error(Ah + t);
}
function Z0(t, e, r, n) {
  var i, s, o, a;
  for (s = t[0]; s >= 10; s /= 10) --e;
  return --e < 0 ? (e += wt, i = 0) : (i = Math.ceil((e + 1) / wt), e %= wt), s = An(10, wt - e), a = t[i] % s | 0, n == null ? e < 3 ? (e == 0 ? a = a / 100 | 0 : e == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 100 | 0) == An(10, e - 2) - 1 || (a == s / 2 || a == 0) && (t[i + 1] / s / 100 | 0) == 0 : e < 4 ? (e == 0 ? a = a / 1e3 | 0 : e == 1 ? a = a / 100 | 0 : e == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 1e3 | 0) == An(10, e - 3) - 1, o;
}
function z1(t, e, r) {
  for (var n, i = [0], s, o = 0, a = t.length; o < a; ) {
    for (s = i.length; s--; ) i[s] *= e;
    for (i[0] += z4.indexOf(t.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function u5e(t, e) {
  var r, n, i = e.d.length;
  i < 32 ? (r = Math.ceil(i / 3), n = Math.pow(4, -r).toString()) : (r = 16, n = "2.3283064365386962890625e-10"), t.precision += r, e = ad(t, 1, e.times(n), new t(1));
  for (var s = r; s--; ) {
    var o = e.times(e);
    e = o.times(o).minus(o).times(8).plus(1);
  }
  return t.precision -= r, e;
}
var ar = /* @__PURE__ */ function() {
  function t(n, i, s) {
    var o, a = 0, l = n.length;
    for (n = n.slice(); l--; )
      o = n[l] * i + a, n[l] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function e(n, i, s, o) {
    var a, l;
    if (s != o)
      l = s > o ? 1 : -1;
    else
      for (a = l = 0; a < s; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, o, a, l) {
    var c, p, h, d, v, m, b, f, E, A, x, g, w, _, S, R, L, F, z, j, W = n.constructor, te = n.s == i.s ? 1 : -1, le = n.d, ce = i.d;
    if (!le || !le[0] || !ce || !ce[0])
      return new W(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (le ? ce && le[0] == ce[0] : !ce) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          le && le[0] == 0 || !ce ? te * 0 : te / 0
        )
      );
    for (l ? (v = 1, p = n.e - i.e) : (l = Hs, v = wt, p = Bn(n.e / v) - Bn(i.e / v)), z = ce.length, L = le.length, E = new W(te), A = E.d = [], h = 0; ce[h] == (le[h] || 0); h++) ;
    if (ce[h] > (le[h] || 0) && p--, s == null ? (_ = s = W.precision, o = W.rounding) : a ? _ = s + (n.e - i.e) + 1 : _ = s, _ < 0)
      A.push(1), m = !0;
    else {
      if (_ = _ / v + 2 | 0, h = 0, z == 1) {
        for (d = 0, ce = ce[0], _++; (h < L || d) && _--; h++)
          S = d * l + (le[h] || 0), A[h] = S / ce | 0, d = S % ce | 0;
        m = d || h < L;
      } else {
        for (d = l / (ce[0] + 1) | 0, d > 1 && (ce = t(ce, d, l), le = t(le, d, l), z = ce.length, L = le.length), R = z, x = le.slice(0, z), g = x.length; g < z; ) x[g++] = 0;
        j = ce.slice(), j.unshift(0), F = ce[0], ce[1] >= l / 2 && ++F;
        do
          d = 0, c = e(ce, x, z, g), c < 0 ? (w = x[0], z != g && (w = w * l + (x[1] || 0)), d = w / F | 0, d > 1 ? (d >= l && (d = l - 1), b = t(ce, d, l), f = b.length, g = x.length, c = e(b, x, f, g), c == 1 && (d--, r(b, z < f ? j : ce, f, l))) : (d == 0 && (c = d = 1), b = ce.slice()), f = b.length, f < g && b.unshift(0), r(x, b, g, l), c == -1 && (g = x.length, c = e(ce, x, z, g), c < 1 && (d++, r(x, z < g ? j : ce, g, l))), g = x.length) : c === 0 && (d++, x = [0]), A[h++] = d, c && x[0] ? x[g++] = le[R] || 0 : (x = [le[R]], g = 1);
        while ((R++ < L || x[0] !== void 0) && _--);
        m = x[0] !== void 0;
      }
      A[0] || A.shift();
    }
    if (v == 1)
      E.e = p, _U = m;
    else {
      for (h = 1, d = A[0]; d >= 10; d /= 10) h++;
      E.e = h + p * v - 1, mt(E, a ? s + E.e + 1 : s, o, m);
    }
    return E;
  };
}();
function mt(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, v = t.constructor;
  e: if (e != null) {
    if (h = t.d, !h) return t;
    for (i = 1, a = h[0]; a >= 10; a /= 10) i++;
    if (s = e - i, s < 0)
      s += wt, o = e, p = h[d = 0], l = p / An(10, i - o - 1) % 10 | 0;
    else if (d = Math.ceil((s + 1) / wt), a = h.length, d >= a)
      if (n) {
        for (; a++ <= d; ) h.push(0);
        p = l = 0, i = 1, s %= wt, o = s - wt + 1;
      } else
        break e;
    else {
      for (p = a = h[d], i = 1; a >= 10; a /= 10) i++;
      s %= wt, o = s - wt + i, l = o < 0 ? 0 : p / An(10, i - o - 1) % 10 | 0;
    }
    if (n = n || e < 0 || h[d + 1] !== void 0 || (o < 0 ? p : p % An(10, i - o - 1)), c = r < 4 ? (l || n) && (r == 0 || r == (t.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? p / An(10, i - o) : 0 : h[d - 1]) % 10 & 1 || r == (t.s < 0 ? 8 : 7)), e < 1 || !h[0])
      return h.length = 0, c ? (e -= t.e + 1, h[0] = An(10, (wt - e % wt) % wt), t.e = -e || 0) : h[0] = t.e = 0, t;
    if (s == 0 ? (h.length = d, a = 1, d--) : (h.length = d + 1, a = An(10, wt - s), h[d] = o > 0 ? (p / An(10, i - o) % An(10, o) | 0) * a : 0), c)
      for (; ; )
        if (d == 0) {
          for (s = 1, o = h[0]; o >= 10; o /= 10) s++;
          for (o = h[0] += a, a = 1; o >= 10; o /= 10) a++;
          s != a && (t.e++, h[0] == Hs && (h[0] = 1));
          break;
        } else {
          if (h[d] += a, h[d] != Hs) break;
          h[d--] = 0, a = 1;
        }
    for (s = h.length; h[--s] === 0; ) h.pop();
  }
  return Mt && (t.e > v.maxE ? (t.d = null, t.e = NaN) : t.e < v.minE && (t.e = 0, t.d = [0])), t;
}
function Yo(t, e, r) {
  if (!t.isFinite()) return TU(t);
  var n, i = t.e, s = pn(t.d), o = s.length;
  return e ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + xl(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (t.e < 0 ? "e" : "e+") + t.e) : i < 0 ? (s = "0." + xl(-i - 1) + s, r && (n = r - o) > 0 && (s += xl(n))) : i >= o ? (s += xl(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + xl(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += xl(n))), s;
}
function Vb(t, e) {
  var r = t[0];
  for (e *= wt; r >= 10; r /= 10) e++;
  return e;
}
function y2(t, e, r) {
  if (e > c5e)
    throw Mt = !0, r && (t.precision = r), Error(CU);
  return mt(new t(g2), e, 1, !0);
}
function Ms(t, e, r) {
  if (e > V4) throw Error(CU);
  return mt(new t(m2), e, r, !0);
}
function PU(t) {
  var e = t.length - 1, r = e * wt + 1;
  if (e = t[e], e) {
    for (; e % 10 == 0; e /= 10) r--;
    for (e = t[0]; e >= 10; e /= 10) r++;
  }
  return r;
}
function xl(t) {
  for (var e = ""; t--; ) e += "0";
  return e;
}
function RU(t, e, r, n) {
  var i, s = new t(1), o = Math.ceil(n / wt + 4);
  for (Mt = !1; ; ) {
    if (r % 2 && (s = s.times(e), tR(s.d, o) && (i = !0)), r = Bn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    e = e.times(e), tR(e.d, o);
  }
  return Mt = !0, s;
}
function XP(t) {
  return t.d[t.d.length - 1] & 1;
}
function OU(t, e, r) {
  for (var n, i = new t(e[0]), s = 0; ++s < e.length; )
    if (n = new t(e[s]), n.s)
      i[r](n) && (i = n);
    else {
      i = n;
      break;
    }
  return i;
}
function H4(t, e) {
  var r, n, i, s, o, a, l, c = 0, p = 0, h = 0, d = t.constructor, v = d.rounding, m = d.precision;
  if (!t.d || !t.d[0] || t.e > 17)
    return new d(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
  for (e == null ? (Mt = !1, l = m) : l = e, a = new d(0.03125); t.e > -2; )
    t = t.times(a), h += 5;
  for (n = Math.log(An(2, h)) / Math.LN10 * 2 + 5 | 0, l += n, r = s = o = new d(1), d.precision = l; ; ) {
    if (s = mt(s.times(t), l, 1), r = r.times(++p), a = o.plus(ar(s, r, l, 1)), pn(a.d).slice(0, l) === pn(o.d).slice(0, l)) {
      for (i = h; i--; ) o = mt(o.times(o), l, 1);
      if (e == null)
        if (c < 3 && Z0(o.d, l - n, v, c))
          d.precision = l += 10, r = s = a = new d(1), p = 0, c++;
        else
          return mt(o, d.precision = m, v, Mt = !0);
      else
        return d.precision = m, o;
    }
    o = a;
  }
}
function Tl(t, e) {
  var r, n, i, s, o, a, l, c, p, h, d, v = 1, m = 10, b = t, f = b.d, E = b.constructor, A = E.rounding, x = E.precision;
  if (b.s < 0 || !f || !f[0] || !b.e && f[0] == 1 && f.length == 1)
    return new E(f && !f[0] ? -1 / 0 : b.s != 1 ? NaN : f ? 0 : b);
  if (e == null ? (Mt = !1, p = x) : p = e, E.precision = p += m, r = pn(f), n = r.charAt(0), Math.abs(s = b.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      b = b.times(t), r = pn(b.d), n = r.charAt(0), v++;
    s = b.e, n > 1 ? (b = new E("0." + r), s++) : b = new E(n + "." + r.slice(1));
  } else
    return c = y2(E, p + 2, x).times(s + ""), b = Tl(new E(n + "." + r.slice(1)), p - m).plus(c), E.precision = x, e == null ? mt(b, x, A, Mt = !0) : b;
  for (h = b, l = o = b = ar(b.minus(1), b.plus(1), p, 1), d = mt(b.times(b), p, 1), i = 3; ; ) {
    if (o = mt(o.times(d), p, 1), c = l.plus(ar(o, new E(i), p, 1)), pn(c.d).slice(0, p) === pn(l.d).slice(0, p))
      if (l = l.times(2), s !== 0 && (l = l.plus(y2(E, p + 2, x).times(s + ""))), l = ar(l, new E(v), p, 1), e == null)
        if (Z0(l.d, p - m, A, a))
          E.precision = p += m, c = o = b = ar(h.minus(1), h.plus(1), p, 1), d = mt(b.times(b), p, 1), i = a = 1;
        else
          return mt(l, E.precision = x, A, Mt = !0);
      else
        return E.precision = x, l;
    l = c, i += 2;
  }
}
function TU(t) {
  return String(t.s * t.s / 0);
}
function eR(t, e) {
  var r, n, i;
  for ((r = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (r = e.length), n = 0; e.charCodeAt(n) === 48; n++) ;
  for (i = e.length; e.charCodeAt(i - 1) === 48; --i) ;
  if (e = e.slice(n, i), e) {
    if (i -= n, t.e = r = r - n - 1, t.d = [], n = (r + 1) % wt, r < 0 && (n += wt), n < i) {
      for (n && t.d.push(+e.slice(0, n)), i -= wt; n < i; ) t.d.push(+e.slice(n, n += wt));
      e = e.slice(n), n = wt - e.length;
    } else
      n -= i;
    for (; n--; ) e += "0";
    t.d.push(+e), Mt && (t.e > t.constructor.maxE ? (t.d = null, t.e = NaN) : t.e < t.constructor.minE && (t.e = 0, t.d = [0]));
  } else
    t.e = 0, t.d = [0];
  return t;
}
function h5e(t, e) {
  var r, n, i, s, o, a, l, c, p;
  if (e === "Infinity" || e === "NaN")
    return +e || (t.s = NaN), t.e = NaN, t.d = null, t;
  if (s5e.test(e))
    r = 16, e = e.toLowerCase();
  else if (i5e.test(e))
    r = 2;
  else if (o5e.test(e))
    r = 8;
  else
    throw Error(Ah + e);
  for (s = e.search(/p/i), s > 0 ? (l = +e.slice(s + 1), e = e.substring(2, s)) : e = e.slice(2), s = e.indexOf("."), o = s >= 0, n = t.constructor, o && (e = e.replace(".", ""), a = e.length, s = a - s, i = RU(n, new n(r), s, s * 2)), c = z1(e, r, Hs), p = c.length - 1, s = p; c[s] === 0; --s) c.pop();
  return s < 0 ? new n(t.s * 0) : (t.e = Vb(c, p), t.d = c, Mt = !1, o && (t = ar(t, i, a * 4)), l && (t = t.times(Math.abs(l) < 54 ? Math.pow(2, l) : Hb.pow(2, l))), Mt = !0, t);
}
function p5e(t, e) {
  var r, n = e.d.length;
  if (n < 3) return ad(t, 2, e, e);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, e = e.times(Math.pow(5, -r)), e = ad(t, 2, e, e);
  for (var i, s = new t(5), o = new t(16), a = new t(20); r--; )
    i = e.times(e), e = e.times(s.plus(i.times(o.times(i).minus(a))));
  return e;
}
function ad(t, e, r, n, i) {
  var s, o, a, l, c = t.precision, p = Math.ceil(c / wt);
  for (Mt = !1, l = r.times(r), a = new t(n); ; ) {
    if (o = ar(a.times(l), new t(e++ * e++), c, 1), a = i ? n.plus(o) : n.minus(o), n = ar(o.times(l), new t(e++ * e++), c, 1), o = a.plus(n), o.d[p] !== void 0) {
      for (s = p; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = n, n = o, o = s;
  }
  return Mt = !0, o.d.length = p + 1, o;
}
function LU(t, e) {
  var r, n = e.s < 0, i = Ms(t, t.precision, 1), s = i.times(0.5);
  if (e = e.abs(), e.lte(s))
    return ma = n ? 4 : 1, e;
  if (r = e.divToInt(i), r.isZero())
    ma = n ? 3 : 2;
  else {
    if (e = e.minus(r.times(i)), e.lte(s))
      return ma = XP(r) ? n ? 2 : 3 : n ? 4 : 1, e;
    ma = XP(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return e.minus(i).abs();
}
function wk(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, v = t.constructor, m = r !== void 0;
  if (m ? (pi(r, 1, Xc), n === void 0 ? n = v.rounding : pi(n, 0, 8)) : (r = v.precision, n = v.rounding), !t.isFinite())
    p = TU(t);
  else {
    for (p = Yo(t), o = p.indexOf("."), m ? (i = 2, e == 16 ? r = r * 4 - 3 : e == 8 && (r = r * 3 - 2)) : i = e, o >= 0 && (p = p.replace(".", ""), d = new v(1), d.e = p.length - o, d.d = z1(Yo(d), 10, i), d.e = d.d.length), h = z1(p, 10, i), s = l = h.length; h[--l] == 0; ) h.pop();
    if (!h[0])
      p = m ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (t = new v(t), t.d = h, t.e = s, t = ar(t, d, r, n, 0, i), h = t.d, s = t.e, c = _U), o = h[r], a = i / 2, c = c || h[r + 1] !== void 0, c = n < 4 ? (o !== void 0 || c) && (n === 0 || n === (t.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || c || n === 6 && h[r - 1] & 1 || n === (t.s < 0 ? 8 : 7)), h.length = r, c)
        for (; ++h[--r] > i - 1; )
          h[r] = 0, r || (++s, h.unshift(1));
      for (l = h.length; !h[l - 1]; --l) ;
      for (o = 0, p = ""; o < l; o++) p += z4.charAt(h[o]);
      if (m) {
        if (l > 1)
          if (e == 16 || e == 8) {
            for (o = e == 16 ? 4 : 3, --l; l % o; l++) p += "0";
            for (h = z1(p, i, e), l = h.length; !h[l - 1]; --l) ;
            for (o = 1, p = "1."; o < l; o++) p += z4.charAt(h[o]);
          } else
            p = p.charAt(0) + "." + p.slice(1);
        p = p + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) p = "0" + p;
        p = "0." + p;
      } else if (++s > l) for (s -= l; s--; ) p += "0";
      else s < l && (p = p.slice(0, s) + "." + p.slice(s));
    }
    p = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + p;
  }
  return t.s < 0 ? "-" + p : p;
}
function tR(t, e) {
  if (t.length > e)
    return t.length = e, !0;
}
function d5e(t) {
  return new this(t).abs();
}
function f5e(t) {
  return new this(t).acos();
}
function g5e(t) {
  return new this(t).acosh();
}
function m5e(t, e) {
  return new this(t).plus(e);
}
function y5e(t) {
  return new this(t).asin();
}
function v5e(t) {
  return new this(t).asinh();
}
function b5e(t) {
  return new this(t).atan();
}
function w5e(t) {
  return new this(t).atanh();
}
function x5e(t, e) {
  t = new this(t), e = new this(e);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !t.s || !e.s ? r = new this(NaN) : !t.d && !e.d ? (r = Ms(this, s, 1).times(e.s > 0 ? 0.25 : 0.75), r.s = t.s) : !e.d || t.isZero() ? (r = e.s < 0 ? Ms(this, n, i) : new this(0), r.s = t.s) : !t.d || e.isZero() ? (r = Ms(this, s, 1).times(0.5), r.s = t.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(ar(t, e, s, 1)), e = Ms(this, s, 1), this.precision = n, this.rounding = i, r = t.s < 0 ? r.minus(e) : r.plus(e)) : r = this.atan(ar(t, e, s, 1)), r;
}
function E5e(t) {
  return new this(t).cbrt();
}
function S5e(t) {
  return mt(t = new this(t), t.e + 1, 2);
}
function A5e(t) {
  if (!t || typeof t != "object") throw Error(Ub + "Object expected");
  var e, r, n, i = t.defaults === !0, s = [
    "precision",
    1,
    Xc,
    "rounding",
    0,
    8,
    "toExpNeg",
    -9e15,
    0,
    "toExpPos",
    0,
    F4,
    "maxE",
    0,
    F4,
    "minE",
    -9e15,
    0,
    "modulo",
    0,
    9
  ];
  for (e = 0; e < s.length; e += 3)
    if (r = s[e], i && (this[r] = U4[r]), (n = t[r]) !== void 0)
      if (Bn(n) === n && n >= s[e + 1] && n <= s[e + 2]) this[r] = n;
      else throw Error(Ah + r + ": " + n);
  if (r = "crypto", i && (this[r] = U4[r]), (n = t[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(IU);
      else
        this[r] = !1;
    else
      throw Error(Ah + r + ": " + n);
  return this;
}
function k5e(t) {
  return new this(t).cos();
}
function _5e(t) {
  return new this(t).cosh();
}
function MU(t) {
  var e, r, n;
  function i(s) {
    var o, a, l, c = this;
    if (!(c instanceof i)) return new i(s);
    if (c.constructor = i, s instanceof i) {
      c.s = s.s, c.e = s.e, c.d = (s = s.d) ? s.slice() : s;
      return;
    }
    if (l = typeof s, l === "number") {
      if (s === 0) {
        c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        c.e = o, c.d = [s];
        return;
      } else if (s * 0 !== 0) {
        s || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return eR(c, s.toString());
    } else if (l !== "string")
      throw Error(Ah + s);
    return s.charCodeAt(0) === 45 ? (s = s.slice(1), c.s = -1) : c.s = 1, a5e.test(s) ? eR(c, s) : h5e(c, s);
  }
  if (i.prototype = Ue, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = A5e, i.clone = MU, i.isDecimal = O5e, i.abs = d5e, i.acos = f5e, i.acosh = g5e, i.add = m5e, i.asin = y5e, i.asinh = v5e, i.atan = b5e, i.atanh = w5e, i.atan2 = x5e, i.cbrt = E5e, i.ceil = S5e, i.cos = k5e, i.cosh = _5e, i.div = C5e, i.exp = I5e, i.floor = P5e, i.hypot = R5e, i.ln = T5e, i.log = L5e, i.log10 = N5e, i.log2 = M5e, i.max = D5e, i.min = $5e, i.mod = j5e, i.mul = B5e, i.pow = F5e, i.random = z5e, i.round = U5e, i.sign = V5e, i.sin = H5e, i.sinh = G5e, i.sqrt = W5e, i.sub = q5e, i.tan = Q5e, i.tanh = K5e, i.trunc = Y5e, t === void 0 && (t = {}), t && t.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; ) t.hasOwnProperty(r = n[e++]) || (t[r] = this[r]);
  return i.config(t), i;
}
function C5e(t, e) {
  return new this(t).div(e);
}
function I5e(t) {
  return new this(t).exp();
}
function P5e(t) {
  return mt(t = new this(t), t.e + 1, 3);
}
function R5e() {
  var t, e, r = new this(0);
  for (Mt = !1, t = 0; t < arguments.length; )
    if (e = new this(arguments[t++]), e.d)
      r.d && (r = r.plus(e.times(e)));
    else {
      if (e.s)
        return Mt = !0, new this(1 / 0);
      r = e;
    }
  return Mt = !0, r.sqrt();
}
function O5e(t) {
  return t instanceof Hb || t && t.name === "[object Decimal]" || !1;
}
function T5e(t) {
  return new this(t).ln();
}
function L5e(t, e) {
  return new this(t).log(e);
}
function M5e(t) {
  return new this(t).log(2);
}
function N5e(t) {
  return new this(t).log(10);
}
function D5e() {
  return OU(this, arguments, "lt");
}
function $5e() {
  return OU(this, arguments, "gt");
}
function j5e(t, e) {
  return new this(t).mod(e);
}
function B5e(t, e) {
  return new this(t).mul(e);
}
function F5e(t, e) {
  return new this(t).pow(e);
}
function z5e(t) {
  var e, r, n, i, s = 0, o = new this(1), a = [];
  if (t === void 0 ? t = this.precision : pi(t, 1, Xc), n = Math.ceil(t / wt), this.crypto)
    if (crypto.getRandomValues)
      for (e = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = e[s], i >= 429e7 ? e[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (e = crypto.randomBytes(n *= 4); s < n; )
        i = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((e[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(IU);
  else for (; s < n; ) a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], t %= wt, n && t && (i = An(10, wt - t), a[s] = (n / i | 0) * i); a[s] === 0; s--) a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= wt) a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
    n < wt && (r -= wt - n);
  }
  return o.e = r, o.d = a, o;
}
function U5e(t) {
  return mt(t = new this(t), t.e + 1, this.rounding);
}
function V5e(t) {
  return t = new this(t), t.d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN;
}
function H5e(t) {
  return new this(t).sin();
}
function G5e(t) {
  return new this(t).sinh();
}
function W5e(t) {
  return new this(t).sqrt();
}
function q5e(t, e) {
  return new this(t).sub(e);
}
function Q5e(t) {
  return new this(t).tan();
}
function K5e(t) {
  return new this(t).tanh();
}
function Y5e(t) {
  return mt(t = new this(t), t.e + 1, 1);
}
var Hb = MU(U4);
g2 = new Hb(g2);
m2 = new Hb(m2);
var G4 = /* @__PURE__ */ ((t) => (t[t.UP = 1] = "UP", t[t.NONE = 0] = "NONE", t[t.DOWN = -1] = "DOWN", t))(G4 || {});
const W4 = {
  dollar: D1.DOLLAR,
  "U.S. dollar": D1.US_DOLLAR,
  "South Korean won": D1.SK_WON
}, v2 = {
  year: { ...we.noun("year"), subtype: "unit" },
  quarter: { ...we.noun("quarter"), subtype: "unit" }
}, q4 = {
  "0.01": { type: "simple-category", subtype: "scale", noun: we.en("percent") },
  1: { type: "simple-category", subtype: "scale", noun: we.en("number") },
  1e3: { type: "simple-category", subtype: "scale", noun: we.en("thousand") },
  1e6: { type: "simple-category", subtype: "scale", noun: we.en("million") },
  1e9: { type: "simple-category", subtype: "scale", noun: we.en("billion") },
  1e12: { type: "simple-category", subtype: "scale", noun: we.en("trillion") }
};
function ya(t, e) {
  if (e in v2)
    return {
      type: "plain-date-time",
      datetime: t,
      unit: e
    };
  if (e === "point")
    return we.quantValue(t, Ol[1], we.unit("point"));
  throw new Error(`Undefined X unit ${e}`);
}
class Gb {
  constructor(e, r, n, i) {
    this.start = e, this.end = r, this.unit = n, this.approx = i;
  }
  path() {
    return this.approx ? {
      type: "point-location",
      direction: Oe.BETWEEN,
      point: we.and(ya(this.start, this.unit), ya(this.end, this.unit))
    } : we.path(
      ya(this.start, this.unit),
      ya(this.end, this.unit)
    );
  }
}
function xk(t, e) {
  return t instanceof Gb ? t.path() : we.in_(ya(t, e));
}
function Z5e(t, e, r) {
  const n = t.indepBox.value, i = e.indepBox.value;
  return n.equals(i.subtract(r));
}
function J5e(t, e, r) {
  return Ere(
    t,
    (n, i) => Z5e(n, i, e)
  ).map((n) => {
    if (n instanceof Mx) {
      if (n.points.length < 2)
        throw new Qr("Internal: Ranges must have 2 or more points.");
      return new NU(n.points, r);
    }
    return n;
  });
}
class NU {
  constructor(e, r, n) {
    Ut(this, "start"), Ut(this, "end"), Ut(this, "startTime"), Ut(this, "endTime"), this.points = e, this.unit = r, this.approx = n, this.start = this.points[0], this.end = this.points.at(-1), this.startTime = this.start.indepBox.value, this.endTime = this.end.indepBox.value;
  }
  path() {
    return this.toTimeRange().path();
  }
  toTimeRange() {
    return new Gb(this.startTime, this.endTime, this.unit, this.approx);
  }
  getNavcode() {
    return this.points.reduce((e, r) => e + `-${r.datapointIndex}`, `datapoint-${this.start.seriesKey}`);
  }
}
class X5e {
  constructor(e, r, n, i, s, o) {
    this.startPoint = e, this.endPoint = r, this.timeUnit = n, this.startValue = i, this.endValue = s, this.depUnits = o;
  }
  path() {
    const e = this.startPoint.indepBox.value, r = this.endPoint.indepBox.value, n = Jt(
      b2(e, this.timeUnit, this.startValue, this.depUnits),
      this.startPoint.getNavcode()
    ), i = Jt(
      b2(r, this.timeUnit, this.endValue, this.depUnits),
      this.endPoint.getNavcode()
    );
    return {
      type: "path-location",
      start: n,
      end: i,
      startTag: U0(this.startPoint.getNavcode()),
      endTag: U0(this.endPoint.getNavcode())
    };
  }
}
function DU(t, e) {
  let r = null, n = null;
  if (e !== "number") {
    if (e !== void 0 && e in W4)
      n = W4[e];
    else if (e !== void 0 && e in v2)
      r = v2[e];
    else if (e === "point")
      r = Oe.POINT;
    else if (e !== void 0) throw new Error(`[ParaSummary]: Undefined dependent unit ${e}`);
  }
  let i = we.numberEntity(
    t.number,
    q4[t.scale]
  );
  return t.roundingDirection === G4.UP && (i.quantifier = Oe.ALMOST), t.roundingDirection === G4.DOWN && (i.quantifier = Oe.MORE_THAN), n !== null ? i = {
    ...i,
    type: "simple-entity",
    subtype: "money-value",
    detType: "bare",
    category: n
  } : r !== null && (i = {
    ...i,
    type: "simple-entity",
    subtype: "quant-value",
    detType: "indefinite",
    category: r
  }), i;
}
function b2(t, e, r, n) {
  const i = xk(t, e), s = DU(r, n);
  return s.mods = [i], s;
}
function $U(t, e) {
  return t.record.labelValue === null ? new Gb(
    Wf(t.record.beforeValue),
    Wf(t.record.afterValue),
    e,
    !0
  ) : Wf(t.record.labelValue);
}
function eSe(t, e) {
  return xk($U(t, e), e);
}
function tSe(t, e, r, n) {
  return we.at(b2(
    $U(t, e),
    e,
    r,
    n.units
  ));
}
function is(t, e) {
  const r = t.messageSeqs[e].start, n = t.messageSeqs[e].end;
  return `sequence-${t.seriesKey}-${r}-${n}`;
}
const Df = Oe.FALL, t1 = Oe.RISE, r1 = { ...Oe.PERIOD, mods: [Oe.STABLE] };
function rSe(t) {
  return t === "Rise" || t === "Fall" || t === "Stable";
}
function nSe(t) {
  return t === "BigJump" || t === "BigFall";
}
function iSe(t) {
  return t === "ReversalToRise" || t === "ReversalToFall";
}
function sSe(t) {
  return t === "PossibleReversalToRise" || t === "PossibleReversalToFall";
}
function oSe(t) {
  return t === "EmergingRise" || t === "EmergingFall";
}
function aSe(t) {
  return t === "PossibleEmergingRise" || t === "PossibleEmergingFall";
}
function lSe(t) {
  return t === "RiseToStable" || t === "FallToStable";
}
function cSe(t) {
  return t === "PossibleRiseToStable" || t === "PossibleFallToStable";
}
function uSe(t) {
  return iSe(t) || oSe(t) || lSe(t);
}
function hSe(t) {
  return sSe(t) || aSe(t) || cSe(t);
}
function pSe(t) {
  return t === "Rebound" || t === "TemporaryJump";
}
function dSe(t) {
  return t === "PossibleRebound" || t === "PossibleTemporaryJump";
}
const fSe = {
  Rise: { ...Oe.RISE, force: "participle" },
  Fall: { ...Oe.FALL, force: "participle" },
  Stable: Oe.STABLE
};
function gSe(t, e, r) {
  const n = { ...Oe.TREND, mods: [Oe.OVERALL, fSe[t]] };
  let i = we.a("singular", n);
  return r && (i = Jt(i, is(e, 0))), i;
}
const mSe = {
  BigJump: Oe.JUMP,
  BigFall: Df
};
function ySe(t, e, r) {
  const n = {
    ...mSe[t],
    mods: [Oe.LARGE]
  };
  let i = we.a("singular", n);
  return r && (i = Jt(i, is(e, 0))), i;
}
const vSe = {
  ReversalToRise: [Df, t1],
  ReversalToFall: [t1, Df],
  EmergingRise: [r1, t1],
  EmergingFall: [r1, Df],
  RiseToStable: [t1, r1],
  FallToStable: [Df, r1]
};
function rR(t, e, r, n) {
  const [i, s] = vSe[t], o = [we.by(we.a("singular", s))];
  n && o.unshift(Oe.POSSIBLY);
  let a = {
    type: "relative-clause",
    relativizer: "zero",
    clause: {
      type: "simple-clause",
      pred: null,
      object: { ...Oe.FOLLOWED, mods: o }
    },
    restrictive: !1
  }, l = Oe.HAS, c = we.a("singular", i);
  return r && (a = Jt(a, is(e, 1)), l = Jt(l, is(e, 0)), c = Jt(c, is(e, 0))), {
    type: "simple-clause",
    pred: l,
    object: c,
    mods: [a]
  };
}
const $f = {
  Rebound: {
    first: { ...Oe.RISE, force: "participle" },
    second: {
      type: "simple-clause",
      pred: { ...Oe.FALL_pred, tense: "present-participle" },
      object: null
    },
    third: {
      type: "simple-clause",
      pred: { ...Oe.REBOUND, tense: "present-participle" },
      object: null,
      mods: [Oe.BACK_UP]
    }
  },
  TemporaryJump: {
    first: { ...Oe.FALL, force: "participle" },
    second: {
      type: "simple-clause",
      pred: { ...Oe.RISE_pred, tense: "present-participle" },
      object: null,
      mods: [Oe.TEMPORARILY]
    },
    third: {
      type: "simple-clause",
      pred: { ...Oe.FALL_pred, tense: "present-participle" },
      object: null,
      mods: [Oe.AGAIN]
    }
  }
}, bSe = {
  Rebound: {
    ...$f.Rebound,
    third: {
      ...$f.Rebound.third,
      mods: [Oe.POSSIBLY, Oe.BACK_UP]
    }
  },
  TemporaryJump: {
    ...$f.TemporaryJump,
    third: {
      ...$f.TemporaryJump.third,
      mods: [Oe.POSSIBLY, Oe.AGAIN]
    }
  }
};
function nR(t, e, r, n) {
  const i = n ? bSe[t] : $f[t];
  let s = {
    type: "simple-clause",
    pred: Oe.HAS,
    object: we.a("singular", { ...Oe.TREND, mods: [i.first] })
  };
  r && (s = Jt(s, is(e, 0)));
  const o = r ? Jt(Oe.BEFORE, is(e, 1)) : Oe.BEFORE, a = r ? Jt(i.second, is(e, 1)) : i.second, l = {
    ...we.coord(o, s, a),
    firstComma: !0
  }, c = r ? Jt(Oe.AND_THEN, is(e, 2)) : Oe.AND_THEN, p = r ? Jt(i.third, is(e, 2)) : i.third;
  return we.coord(c, l, p);
}
function iR(t, e = !0) {
  const r = t.message;
  if (pSe(r))
    return nR(r, t, e);
  if (dSe(r))
    return nR(r.substring(8), t, e, !0);
  if (uSe(r))
    return rR(r, t, e);
  if (hSe(r))
    return rR(r.substring(8), t, e, !0);
  let n;
  return rSe(r) ? n = gSe(r, t, e) : nSe(r) && (n = ySe(r, t, e)), {
    type: "simple-clause",
    pred: e ? Jt(Oe.HAS, is(t, 0)) : Oe.HAS,
    object: n
  };
}
const jU = ["entity", "items", "locale"], wSe = {
  entity: "genus",
  items: "genus",
  locale: "genus"
};
function J3(t, e) {
  const r = new Set(
    t.series.map((n) => t.getSeriesTheme(n.key)[e]).filter((n) => n !== void 0)
  );
  return r.size === 1 ? "genus" : r.size === t.numSeries ? "differentia" : "neither";
}
function BU(t) {
  const e = {
    entity: J3(t, "entity"),
    items: J3(t, "items"),
    locale: J3(t, "locale")
  };
  for (const r in e) {
    const n = t.getChartTheme();
    n && r in n && e[r] === "neither" && (e[r] = "genus");
  }
  return e;
}
function Sm(t) {
  return Array.isArray(t) ? we.and(...t.map(we.noun)) : we.noun(t);
}
function xSe(t, e, r) {
  if (t[e] === void 0 || r === "neither")
    return null;
  const n = r === "differentia", i = {
    type: "simple-entity",
    detType: {
      entity: n ? "indefinite" : "proper",
      items: "indefinite",
      locale: n ? "indefinite" : "proper"
    }[e],
    number: n || e === "items" ? "plural" : "singular",
    category: Sm(t[e])
  };
  return n && (i.mods = [Oe.DIFFERENT]), i;
}
function ESe(t, e, r) {
  if (r !== "differentia")
    return null;
  const n = t.series.map((s) => {
    const o = t.getSeriesTheme(s.key)[e];
    return Jt(
      Sm(o),
      `series-${s.key}`
    );
  });
  let i;
  return Array.isArray(n) ? (i = we.and(...n), i.conn = Jt(i.conn, `series-${t.series.at(-1).key}`)) : i = n, {
    type: "simple-entity",
    detType: "bare",
    number: e === "items" ? "plural" : "singular",
    category: i
  };
}
function SSe(t, e, r) {
  let n = wSe;
  r && (n = BU(r));
  const i = jU.flatMap((s) => {
    const o = xSe(e, s, n[s]);
    return o === null ? [] : [s === "locale" ? { ...we.in_(o), inessential: !0 } : we.of(o)];
  });
  t.mods.push(...i);
}
function ASe(t, e) {
  var r;
  const n = BU(e), i = jU.flatMap((o) => {
    const a = ESe(e, o, n[o]);
    if (a === null)
      return [];
    const l = [];
    if (o === "locale") {
      const c = we.in_(a);
      c.direction = Jt(c.direction, `series-${e[0].key}`), l.push(c);
    } else {
      const c = we.of(a);
      c.auxTag = U0(`series-${e[0].key}`), l.push(c);
    }
    return l;
  });
  t.mods.push(...i);
  const s = (r = e.getChartTheme()) == null ? void 0 : r.aggregate;
  if (s) {
    const o = Array.isArray(s) ? s : [s];
    t.mods.push(...o.map((a) => we.adj(a)));
  }
}
function kSe(t, e) {
  return {
    type: "simple-entity",
    detType: "definite",
    number: e ? "plural" : "singular",
    category: Sm(t.baseQuantity),
    mods: []
  };
}
function _Se(t, e) {
  const r = Sm(t.baseQuantity);
  return {
    type: "simple-entity",
    detType: "definite",
    number: e || Array.isArray(t.baseQuantity) ? "plural" : "singular",
    category: Oe.RATE,
    mods: [r]
  };
}
function CSe(t, e) {
  return {
    type: "simple-entity",
    detType: "definite",
    number: e || Array.isArray(t.baseQuantity) ? "plural" : "singular",
    category: Ol[1]
  };
}
function ISe(t, e) {
  let r;
  return Array.isArray(t.baseQuantity) ? r = we.and(...t.baseQuantity.map((n) => we.a("plural", we.noun(n)))) : r = we.a("plural", we.noun(t.baseQuantity)), { ...CSe(t, e), mods: [we.of(r)] };
}
function PSe(t, e) {
  const r = Sm(t.baseQuantity);
  return {
    type: "simple-entity",
    detType: "definite",
    number: "singular",
    category: Oe.DISTRIBUTION,
    mods: [we.of(we.the("singular", r))]
  };
}
function Ek(t, e) {
  switch (t.baseKind) {
    case "dimensioned":
      return kSe(t, e);
    case "rate":
      return _Se(t, e);
    case "number":
      return ISe(t, e);
    case "proportion":
      return PSe(t);
  }
}
function RSe(t) {
  return t.baseKind === "proportion" ? {
    type: "simple-entity",
    detType: "definite",
    //'bare',
    number: "singular",
    category: Oe.DISTRIBUTION
    //D.PERCENTAGE
  } : {
    ...Ek(t, !1)
    /*detType: 'bare'*/
  };
}
function Sk(t, e) {
  const r = Ek(t, e !== void 0);
  if (SSe(r, t, e), t.aggregate !== void 0) {
    const n = Array.isArray(t.aggregate) ? t.aggregate : [t.aggregate];
    r.mods.push(...n.map((i) => we.adj(i)));
  }
  return r;
}
function Q4(t) {
  return Sk(t.getChartTheme(), t);
}
function FU(t) {
  return Sk(t);
}
function zU(t, e, r) {
  const n = Sk(t, e);
  return n.mods.push({ type: "quote", text: r }), n;
}
const UU = we.over({
  type: "simple-entity",
  detType: "bare",
  number: "singular",
  category: Oe.TIME
}), X3 = { ...Oe.HIGH, comparative: "superlative" }, VU = {
  type: "point-location",
  direction: we.dir("across"),
  point: we.the("singular", Oe.CHART, [we.adj("whole")])
}, HU = {
  line: we.this_("singular", { ...Oe.CHART, mods: [Oe.LINE] }),
  stepline: we.this_("singular", { ...Oe.CHART, mods: [we.adj("stepped"), Oe.LINE] }),
  bar: we.this_("singular", { ...Oe.CHART, mods: [we.noun("bar")] }),
  column: we.this_("singular", { ...Oe.CHART, mods: [we.noun("bar")] }),
  lollipop: we.this_("singular", { ...Oe.CHART, mods: [we.noun("bar")] }),
  histogram: we.this_("singular", we.noun("histogram"))
  // FIXME: add scatter
}, OSe = {
  line: we.this_("singular", Oe.LINE),
  stepline: we.this_("singular", Oe.LINE, [we.adj("stepped")]),
  bar: we.this_("plural", we.noun("bar")),
  //H.this_('plural', H.noun('segment'), [H.adj('bar')]);
  lollipop: we.this_("plural", we.noun("bar")),
  //H.this_('plural', H.noun('segment'), [H.adj('bar')]);
  column: we.this_("plural", we.noun("bar")),
  //H.this_('plural', H.noun('segment'), [H.adj('bar')]);
  histogram: we.this_("plural", we.noun("bar"))
  // FIXME: add scatter
};
class TSe {
  constructor(e, r, n, i, s, o, a, l, c, p, h, d, v) {
    Ut(this, "seriesTheme"), Ut(this, "isTimeSeries"), Ut(this, "seriesLabel"), this.key = e, this.seriesMetadata = r, this.model = n, this.values = i, this.statsValues = s, this.indepUnit = o, this.firstPoint = a, this.lastPoint = l, this.depFacet = c, this.depFacetKey = p, this.indepFacet = h, this.indepFacetKey = d, this.intersectionValues = v, this.seriesTheme = FU(this.model.getSeriesTheme(e)), this.isTimeSeries = this.indepFacet.datatype === "date", this.seriesLabel = this.seriesMetadata.getLabel();
  }
  // Data Helpers
  /*private _getSubSeriesMetadata<T extends object>(request: string): T {
    const requestResult = jp.query(this.fullMetadata, request);
    if (requestResult.length === 0) {
      throw new ChartDataError(`The series key "${this.key}" does not exist in this graph`);
    }
    if (requestResult.length > 1) {
      throw new ChartDataError(`Request matches multiple series in this graph`);
    }
    return requestResult[0];
  }*/
  _getEarliestTime(e) {
    const r = e.map((n) => n.indepBox.value);
    return r.sort(e1.PlainDateTime.compare), r[0];
  }
  _determineFirstExtremeDirection() {
    const e = this.seriesMetadata.getFacetStats(this.depFacetKey).min, r = this.seriesMetadata.getFacetStats(this.depFacetKey).max, n = this._getEarliestTime(e.datapoints), i = this._getEarliestTime(r.datapoints);
    return e1.PlainDateTime.compare(n, i) === -1 ? "min" : "max";
  }
  // Subsentential
  _fromTo(e, r) {
    return new X5e(
      this.firstPoint,
      this.lastPoint,
      this.indepUnit,
      e,
      r,
      this.depFacet.units
    ).path();
  }
  // Sentences
  // Overall Series Summary Sentence
  summarizeSeries(e = !1) {
    const r = e ? HU[this.model.type] : OSe[this.model.type];
    if (!r)
      return console.error(`[ParaSummary]: series summaries are not implemented for ${this.model.type} charts yet`), [];
    let n = [];
    return this.isTimeSeries ? n = [UU, this._fromTo(this.statsValues.start, this.statsValues.end)] : n = [we.over({
      type: "simple-entity",
      detType: "bare",
      number: "singular",
      category: we.noun(this.indepFacet.description),
      mods: [we.adj("several")]
    })], [{
      type: "simple-statement",
      subject: r,
      clause: {
        type: "simple-clause",
        pred: Oe.SHOW,
        object: this.seriesTheme,
        mods: n
      }
    }];
  }
  _extremeTimeSeriesClause(e) {
    const r = this.seriesMetadata.getFacetStats(this.depFacetKey)[e];
    let n = !1;
    const i = this.indepUnit === "year" ? e1.Duration.from({ years: 1 }) : e1.Duration.from({ months: 3 }), s = J5e(
      r.datapoints,
      i,
      this.indepUnit
    ).map((h) => h instanceof NU ? (n = !0, h.toTimeRange()) : h.indepBox.value).map((h) => xk(
      h,
      this.indepUnit
    ));
    let o;
    if (s.length === 1)
      o = s[0];
    else if (n)
      o = we.and(...s);
    else {
      const h = s.map(
        (d) => d.point
      );
      o = we.in_(we.and(...h));
    }
    const a = this.statsValues[e], l = DU(a, this.depFacet.units);
    l.mods = [o];
    const c = {
      type: "simple-clause",
      pred: e === "min" ? Oe.BOTTOM_OUT : Oe.PEAK,
      object: we.at(l)
    }, p = r.datapoints.map((h) => h.datapointIndex);
    return Jt(c, `datapoint-${this.key}-${p.join("-")}`);
  }
  _extremeTimeBoth() {
    const e = this._determineFirstExtremeDirection(), r = e === "min" ? "max" : "min", n = this._extremeTimeSeriesClause(e), i = this._extremeTimeSeriesClause(r);
    return {
      type: "simple-statement",
      subject: {
        ...this.seriesTheme,
        tag: n.tag
      },
      clause: {
        type: "coordinated-phrase",
        conn: { ...Oe.AND, tag: i.tag },
        coords: [n, i]
      }
    };
  }
  // "The {theme} {"bottoms out"/"peaks"} at {value} {"in" {time}}*. "
  _extremeTimeSeries(e) {
    if (e === "both")
      return this._extremeTimeBoth();
    const r = this._extremeTimeSeriesClause(e), n = {
      type: "simple-statement",
      subject: this.seriesTheme,
      clause: r
    };
    return n.tag = r.tag, n;
  }
  // TODO: Add back rating comparisons: https://github.com/fizzstudio/ParaSummary/issues/9
  _extremeNonTimeSeries(e) {
    if (e === "both") {
      const l = this._determineFirstExtremeDirection(), c = l === "min" ? "max" : "min", p = this._extremeNonTimeSeries(l), h = this._extremeNonTimeSeries(c);
      return we.and(p, h);
    }
    const r = e === "min" ? { ...Oe.LOW, comparative: "superlative" } : { ...Oe.HIGH, comparative: "superlative" }, n = we.noun(this.indepFacet.label.toLocaleLowerCase()), i = we.the("singular", n, [r]), s = this.seriesMetadata.getFacetStats(this.depFacetKey)[e], o = s.datapoints[0].facetValue(this.indepFacetKey), a = s.value;
    return we.svo(
      i,
      Oe.COPULA,
      we.proper(we.noun(o)),
      we.at({
        type: "simple-entity",
        subtype: "quant-value",
        detType: "indefinite",
        number: a,
        category: we.unit("point")
      })
      //{ type: 'quote', text: `, where ${closestPoint} is ${closestRating}.` }
    );
  }
  extreme(e) {
    return this.isTimeSeries ? [this._extremeTimeSeries(e)] : [this._extremeNonTimeSeries(e)];
  }
  datapoint(e) {
    if (e >= this.values.length)
      throw new Qr(`The datapoint index ${e} is too large`);
    const r = { type: "label", text: this.seriesMetadata.getLabel() }, n = this.seriesMetadata.datapoints[e].facetValue("x"), i = this.values[e], s = b2(n, this.indepUnit, i, this.depFacet.units);
    return [r, s];
  }
  intersections() {
    const e = v4.query(this.model, `$.intersections[?(@.series.includes('${this.key}'))]`);
    return [{
      type: "simple-statement",
      subject: we.this_("singular", Oe.LINE),
      clause: {
        type: "simple-clause",
        pred: Oe.HAS,
        object: {
          type: "simple-entity",
          detType: "indefinite",
          number: e.length,
          category: Oe.INTERSECTION
        }
      }
    }];
  }
  recordCount() {
    return this.model.family === "line" ? this._recordCountLine() : this.model.family === "bar" ? this._recordCountBar() : (console.error(`[ParaSummary]: record count summaries are not implemented for ${this.model.type} charts yet`), []);
  }
  _recordCountLine() {
    return [{
      type: "simple-statement",
      subject: we.this_("singular", Oe.LINE),
      clause: {
        type: "simple-clause",
        pred: Oe.HAS,
        object: {
          type: "simple-entity",
          detType: "indefinite",
          number: this.seriesMetadata.length,
          category: Oe.RECORD
        }
      }
    }];
  }
  // There are _ bars for this category
  _recordCountBar() {
    const e = (
      /*this.fullMetadata.series.length === 1 
      ?*/
      we.noun("bar")
    );
    return [{
      type: "simple-statement",
      subject: null,
      clause: {
        type: "simple-clause",
        pred: { ...Oe.COPULA },
        //number: 'plural'
        object: {
          type: "simple-entity",
          detType: "indefinite",
          number: this.seriesMetadata.length,
          category: e,
          mods: [we.for_(we.this_("singular", we.noun("category")))]
        }
      }
    }];
  }
  async trend() {
    if (this.model.family === "scatter")
      return sn("Trend summaries are not implemented for these chart families");
    const e = await this.model.getSeriesAnalysis(this.key);
    if (e === null)
      return sn(`The series "${this.key}" does not have an analysis`);
    const r = e.message;
    if (r === null)
      return sn(`The series "${this.key}" does not convey a trend message`);
    const n = e.messageSeqs.map(
      (a) => e.sequences[a]
    ), i = {
      seriesKey: this.key,
      message: r,
      messageSeqs: n
    }, s = iR(i), o = this.seriesTheme;
    return [{
      type: "simple-statement",
      subject: Jt(o, is(i, 0)),
      clause: s
    }];
  }
  _rankingOrdinal(e) {
    return e === 1 ? [] : [we.ordinal(e)];
  }
  // Full: "{this-label} starts as the {Nth} highest line, (intersects with {label} {at time})*, 
  //   and ends as the {Mth} highest line." For series summaries
  // Abbrev: "{this-label} starts as the {Nth} highest line, ({"crosses over"/"touches"} {label})*, 
  //   and ends as the {Mth} highest line." For whole chart summaries
  // Special case (highest throughout chart): "{this-label} is the highest across the whole chart"
  ranking(e) {
    const r = we.proper(we.noun(this.seriesLabel)), n = this.model.getChordAt(
      this.indepFacetKey,
      this.seriesMetadata.datapoints[0].facetBox(this.indepFacetKey)
    );
    n.sort(
      (d, v) => v.facetValueNumericized(this.depFacetKey) - d.facetValueNumericized(this.depFacetKey)
    );
    const i = n.findIndex((d) => d.seriesKey === this.key) + 1, s = v4.query(this.model, `$.intersections[?(@.series.includes('${this.key}'))]`);
    s.sort((d, v) => d.value - v.value);
    const o = this.model.getChordAt(
      this.indepFacetKey,
      this.seriesMetadata.datapoints.at(-1).facetBox(this.indepFacetKey)
    );
    o.sort(
      (d, v) => v.facetValueNumericized(this.depFacetKey) - d.facetValueNumericized(this.depFacetKey)
    );
    const a = o.findIndex((d) => d.seriesKey === this.key) + 1;
    if (i === 1 && a === 1 && s.length === 0)
      return [Jt(we.svo(r, Oe.COPULA, X3, VU), `series-${this.key}`)];
    const l = Jt({
      type: "simple-clause",
      pred: Oe.START,
      object: {
        type: "purpose",
        subtype: "as",
        purpose: we.the(
          "singular",
          { ...Oe.LINE, mods: [X3] },
          this._rankingOrdinal(i)
        )
      }
    }, `datapoint-${this.key}-0`), c = [];
    for (const [d, v] of Wn(s)) {
      const m = d.series.filter((A) => A !== this.key)[0], b = this.model.atKey(m).getLabel();
      let f;
      e ? f = {
        type: "simple-clause",
        pred: d.transversality.kind === "touch" ? we.pred("touch") : we.pred("cross", "over"),
        object: we.proper(we.noun(b))
      } : f = {
        type: "simple-clause",
        pred: Oe.INTERSECT,
        object: we.with(
          we.proper(we.noun(b))
        ),
        mods: [eSe(d, this.indepUnit)]
      };
      let E = `intersection-${this.key}-${v}`;
      if (d.record.labelValue !== null) {
        const A = this.seriesMetadata.datapoints.findIndex(
          (x) => x.indepBox.asNumber() === d.record.labelValue
        );
        `${this.key}${A}`;
      }
      c.push(Jt(f, E));
    }
    const p = Jt({
      type: "simple-clause",
      pred: Oe.END,
      object: {
        type: "purpose",
        subtype: "as",
        purpose: we.the(
          "singular",
          { ...Oe.LINE, mods: [X3] },
          this._rankingOrdinal(a)
        )
      }
    }, `datapoint-${this.key}-${this.seriesMetadata.length - 1}`), h = we.and(l, ...c, p);
    return [{
      type: "simple-statement",
      subject: r,
      clause: h
    }];
  }
  // "The {Nth} {"and final"}? sequence goes from {start-time} to {end-time} and has a {trend-direction} trend."
  async sequence(e, r) {
    const n = this.seriesMetadata.datapoints[e].facetValue(this.indepFacetKey), i = this.seriesMetadata.datapoints[r - 1].facetValue(this.indepFacetKey), s = await this.model.getSeriesAnalysis(this.key), o = s.sequences.findIndex(
      (v) => v.start === e && v.end === r
    );
    if (o < 0)
      throw new Qr(`sequence in ${this.key} could not be found at start point ${e} and end point ${r}`);
    const a = s.sequences[o];
    let l = null;
    a.message !== null && (l = {
      seriesKey: this.key,
      message: a.message,
      messageSeqs: [a]
    });
    const c = o === s.sequences.length - 1 ? we.and(we.ordinal(o + 1), we.adj("final")) : we.ordinal(o + 1), p = we.the("singular", we.noun("sequence"), [c]), h = {
      type: "simple-clause",
      pred: we.pred("go"),
      object: we.path(
        ya(n, this.indepUnit),
        ya(i, this.indepUnit)
      )
    }, d = l === null ? [] : [iR(l, !1)];
    return {
      type: "simple-statement",
      subject: p,
      clause: we.and(
        h,
        ...d
      )
    };
  }
}
var LSe = Object.defineProperty, MSe = Object.getOwnPropertyDescriptor, GU = (t, e, r, n) => {
  for (var i = MSe(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && LSe(e, r, i), i;
};
const NSe = we.the("plural", Oe.LINE), sR = {
  type: "simple-entity",
  quantifier: Oe.ALL,
  detType: "definite",
  number: "plural",
  category: Oe.LINE
}, DSe = [
  "$.datasets[0]",
  "$.datasets[0].trend",
  "$.datasets[0].stats.extremes",
  "$.datasets[0].axes.dependent",
  "$.datasets[0].axes.independent",
  "$.datasets[0].labels"
], $Se = [
  "$.datasets[0]",
  "$.datasets[0].series.*",
  "$.datasets[0].axes.dependent",
  "$.datasets[0].axes.independent",
  "$.datasets[0].labels"
  //'$.datasets[0].series.highestAverage',
], jSe = [
  "$.datasets[0]",
  "$.datasets[0].series.*",
  "$.datasets[0].clusters.*",
  "$.datasets[0].trackingGroups.*",
  "$.datasets[0].highestRanking"
  //'$.datasets[0].axes.dependent',
  //'$.datasets[0].axes.independent',
  //'$.datasets[0].labels',
  //'$.datasets[0].series.highestAverage',
], BSe = [
  "$.datasets[0].series[?(@.key === '${seriesKey}')]",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].trend",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.extremes",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].record_count"
], FSe = [
  "$.datasets[0].series[?(@.key === '${seriesKey}')]",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].trend",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.extremes"
  //"$.datasets[0].intersections[?(@.series.includes('${seriesKey}'))]",
  //"$.datasets[0].series[?(@.key === '${seriesKey}')].record_count",
], zSe = [
  "$.datasets[0].series[?(@.key === '${seriesKey}')]",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].trend",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.max",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].stats.min",
  //"$.datasets[0].intersections[?(@.series.includes('${seriesKey}'))]",
  //"$.datasets[0].series[?(@.key === '${seriesKey}')].record_count",
  "$.datasets[0].series[?(@.key === '${seriesKey}')].ranking"
];
class Wb extends pb {
  /**
   * @param model - The data model for the chart
   */
  constructor(e) {
    super(e), Ut(this, "summarizer"), this.summarizer = new USe(e);
  }
  getSummarizer() {
    return this.summarizer;
  }
  async getChartSummary() {
    if (this._model.description)
      return { text: this._model.description, html: this._model.description };
    let e;
    return this._model.multi ? this._model.family === "line" ? e = jSe : e = $Se : e = DSe, this.highlightSummaries(e);
  }
  async getSeriesSummary(e) {
    let r;
    this._model.multi ? this._model.family === "line" ? r = zSe : r = FSe : r = BSe;
    const n = r.map((s) => s.replaceAll("${seriesKey}", e)), i = this._model.atKey(e).getLabel();
    return this.grammatizeSummaries(n).then((s) => `${i}: ${s}`).then((s) => R4(s));
  }
  async getSequenceSummary(e) {
    if (!this._model.seriesKeys.includes(e.seriesKey))
      throw new Qr(`No series with the key ${e.seriesKey} exists in this chart.`);
    const r = await this.summarizer.sequence(e.seriesKey, `${e.start}`, `${e.end}`);
    return this.highlightComponents(r);
  }
}
GU([
  $d()
], Wb.prototype, "getChartSummary");
GU([
  $d()
], Wb.prototype, "getSeriesSummary");
class USe {
  //private spanIndex = -1;
  // * Initialization *
  constructor(e) {
    Ut(this, "multi"), Ut(this, "indepFacetKey"), Ut(this, "indepFacet"), Ut(this, "indepUnit"), Ut(this, "firstPoint"), Ut(this, "lastPoint"), Ut(this, "indepAxisOrient"), Ut(this, "depFacetKey"), Ut(this, "depFacet"), Ut(this, "seriesKeys"), Ut(this, "seriesValues"), Ut(this, "seriesStatsValues"), Ut(this, "seriesMetadata"), Ut(this, "seriesSummarizers"), Ut(this, "intersectionValues"), Ut(this, "isTimeSeries"), this.model = e, this.indepFacetKey = this.model.independentFacetKeys[0], this.indepFacet = this.model.getFacet(this.indepFacetKey), this.indepUnit = this.indepFacet.units ?? "NO-UNIT", this.isTimeSeries = this.indepFacet.datatype === "date", this.firstPoint = this.model[0][0], this.lastPoint = this.model[0][this.model[0].length - 1];
    const r = this.model.getAxisFacet("horiz") ?? this.indepFacet;
    this.indepAxisOrient = r.label === this.indepFacet.label ? "horiz" : "vert", this.depFacetKey = this.model.dependentFacetKeys[0], this.depFacet = this.model.getFacet(this.depFacetKey), this.multi = this.model.multi, this.seriesKeys = this.model.seriesKeys, this.seriesSummarizers = {}, this.seriesMetadata = {}, this.seriesValues = this.model.seriesScaledValues ?? this.makeEmptyMap(), this.seriesStatsValues = this.model.seriesStatsScaledValues ?? this.makeEmptyMap(), this.intersectionValues = this.model.intersectionScaledValues ?? [];
    for (const n of this.seriesKeys)
      this.seriesMetadata[n] = this.model.atKey(n), this.seriesSummarizers[n] = new TSe(
        n,
        this.seriesMetadata[n],
        this.model,
        this.seriesValues[n],
        this.seriesStatsValues[n],
        this.indepUnit,
        this.firstPoint,
        this.lastPoint,
        this.depFacet,
        this.depFacetKey,
        this.indepFacet,
        this.indepFacetKey,
        this.intersectionValues
      );
  }
  makeEmptyMap() {
    const e = {};
    for (const r of this.seriesKeys)
      e[r] = null;
    return e;
  }
  // @simonvarey: This can be deleted when we feel that we won't need span indexes set in summarizers, instead of in `convertToHighlighted`
  /*private newSpanIndex(): number {
    this.spanIndex += 1;
    return this.spanIndex;
  }*/
  // * Data Helpers *
  _getOnlySeriesSummarizer() {
    if (this.multi)
      throw new Qr("Cannot call `_getOnlySeriesSummarizer` on multi series chart.");
    return this.seriesSummarizers[this.seriesKeys[0]];
  }
  // * Summary Helpers *
  // Substatement
  // "___, _____, and _________" (main case) 
  // OR "the lines" (if group.length === series.length === 2)
  // OR "all the lines" (if group.length === series.length > 2)
  // @simonvarey: `tag` was originally added for `allCluster` sentences, but then I decided I didn't
  //   need it there, but I have kept it in this method in case it is useful in the future
  _seriesGroupLine(e, r) {
    if (e.length < 2)
      throw new Qr("Cannot call `_seriesGroupLine` with fewer than 2 keys.");
    const n = `series-${e.join("-")}`;
    if (e.length === this.model.numSeries) {
      const o = e.length === 2 ? NSe : sR;
      return r ? Jt(o, n) : o;
    }
    const i = e.map((o) => {
      const a = this.model.atKey(o).getLabel();
      return we.proper(we.noun(a));
    }), s = we.and(...i);
    return r ? Jt(s, n) : s;
  }
  _allSeriesSubjectsBar() {
    return this.model.grouped ? {
      ...Oe.BAR,
      mods: [we.of({
        type: "simple-entity",
        quantifier: Oe.EACH,
        detType: "bare",
        number: "singular",
        category: Oe.GROUP
      })]
    } : {
      type: "simple-category",
      noun: we.en("segment"),
      mods: [we.of({
        type: "simple-entity",
        quantifier: Oe.EACH,
        detType: "bare",
        number: "singular",
        category: Oe.BAR
      })]
    };
  }
  _allSeriesSubjects() {
    return this.model.family === "line" ? Oe.LINE : this.model.family === "bar" ? this._allSeriesSubjectsBar() : null;
  }
  // Statement
  // Overall Chart Summary Sentence
  // 'This {chart type} chart compares the {quantity type}s of different {topic}s over time from {start x} to {end x}.'
  _chartMultiTimeSeries(e) {
    return {
      type: "simple-statement",
      subject: e,
      clause: {
        type: "simple-clause",
        pred: Oe.COMPARE,
        object: Q4(
          this.model
          /*, this.differentia!*/
        ),
        mods: [UU, we.path(
          ya(this.firstPoint.indepBox.value, this.indepUnit),
          ya(this.lastPoint.indepBox.value, this.indepUnit)
        )]
      }
      //tag: makeSpan(`nochart-${this.newSpanIndex()}`)
    };
  }
  _chartMultiNonTimeSeries(e) {
    return {
      type: "simple-statement",
      subject: e,
      clause: {
        type: "simple-clause",
        pred: Oe.COMPARE,
        object: zU(
          this.model.getChartTheme(),
          this.model,
          `of ${this.model.getChartTheme().entity}`
        )
      }
    };
  }
  _chartMultiSeries() {
    const e = HU[this.model.type];
    return e ? this.isTimeSeries ? [this._chartMultiTimeSeries(e)] : [this._chartMultiNonTimeSeries(e)] : (console.error(`[ParaSummary]: whole chart summaries are not implemented for ${this.model.type} charts yet`), []);
  }
  _extreme(e) {
    throw new n2("extreme");
  }
  _intersectionAtIndex(e) {
    const r = this.model.intersections[e], n = we.and(we.proper(we.noun(r.series[0])), we.proper(we.noun(r.series[1]))), i = this.intersectionValues[e];
    return we.svo(
      n,
      { ...Oe.INTERSECT },
      tSe(r, this.indepUnit, i, this.depFacet)
    );
  }
  // ___, _____, and ______ track each other from ________ to ______
  _trackingGroup(e) {
    const r = e.valueInterval[0], n = this.model.series[0].datapoints[0].facetValueAsNumber(this.indepFacetKey), i = e.valueInterval[1], s = this.model.series[0].datapoints.at(-1).facetValueAsNumber(this.indepFacetKey);
    let o;
    if (r === n && i === s)
      o = VU;
    else {
      const l = Wf(r), c = Wf(i);
      o = new Gb(
        l,
        c,
        this.indepUnit
      ).path();
    }
    const a = this._seriesGroupLine(e.keys);
    return Jt(we.svo(
      a,
      Oe.TRACK,
      //number: 'p'
      Oe.EACH_OTHER,
      o
    ), `series-${e.keys.join("-")}`);
  }
  // * Summary Generation *
  // All Chart
  chart() {
    return this.multi ? this._chartMultiSeries() : this._getOnlySeriesSummarizer().summarizeSeries(!0);
  }
  // Series Topics Sentence
  //The {number of series} {lines/segments of each bar/bars of each group} show the {quantity type}s of {series 1 topic}, {series 2 topic} ... 
  allSeries() {
    var e;
    const r = this._allSeriesSubjects();
    if (!r)
      return sn(`[ParaSummary]: all series summaries are not implemented for ${this.model.type} charts yet`);
    const n = `series-${this.model[0].key}`, i = Ek(this.model.getChartTheme(), !0);
    i.detTag = U0(n), i.category = Jt(i.category, n), i.mods = (e = i.mods) == null ? void 0 : e.map((o) => Jt(o, n)), ASe(i, this.model);
    const s = {
      type: "simple-clause",
      pred: Jt(Oe.SHOW, n),
      object: i
    };
    return [{
      type: "simple-statement",
      subject: Jt(we.the(this.model.numSeries, r), n),
      clause: s
    }];
  }
  chartMin() {
    return this.multi ? this._extreme("min") : this._getOnlySeriesSummarizer().extreme("min");
  }
  chartMax() {
    return this.multi ? this._extreme("max") : this._getOnlySeriesSummarizer().extreme("max");
  }
  chartExtremes() {
    return this.multi ? this._extreme("both") : this._getOnlySeriesSummarizer().extreme("both");
  }
  onlySeriesTrend() {
    if (this.multi)
      throw new Qr("`onlySeriesTrend` cannot be called on charts with multiple series.");
    return this._getOnlySeriesSummarizer().trend();
  }
  // Series
  specificSeries(e) {
    return this.seriesSummarizers[e].summarizeSeries();
  }
  seriesTrend(e) {
    return this.seriesSummarizers[e].trend();
  }
  seriesMax(e) {
    return this.seriesSummarizers[e].extreme("max");
  }
  seriesMin(e) {
    return this.seriesSummarizers[e].extreme("min");
  }
  seriesExtremes(e) {
    return this.seriesSummarizers[e].extreme("both");
  }
  seriesDatapoint(e, r) {
    const n = this.seriesSummarizers[e], i = parseInt(r);
    return n.datapoint(i);
  }
  seriesIntersections(e) {
    if (!this.multi)
      throw new Qr("Series-Intersection can not be requested in single-series charts.");
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].intersections(
      /*this.differentia!*/
    );
  }
  seriesRecordCount(e) {
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].recordCount(
      /*this.differentia!*/
    );
  }
  seriesRanking(e) {
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].ranking(!1);
  }
  // Other
  dependentAxis() {
    if (this.model.type === "pie")
      return [];
    const e = this.indepAxisOrient === "horiz" ? Oe.YAXIS : Oe.XAXIS;
    return [we.svo(
      we.the("singular", e),
      Oe.SHOW,
      this.dependentAxisLabel()[0]
    )];
  }
  independentAxis() {
    if (this.model.type === "pie")
      return [];
    const e = this.indepAxisOrient === "horiz" ? Oe.XAXIS : Oe.YAXIS;
    let r;
    return this.isTimeSeries ? r = {
      type: "simple-entity",
      detType: "definite",
      number: "singular",
      category: we.noun("time"),
      mods: [we.in_(we.a("plural", we.noun(this.indepUnit)))]
    } : r = {
      type: "simple-entity",
      detType: "definite",
      number: "singular",
      category: we.noun(this.indepFacet.label.toLocaleLowerCase())
    }, [we.svo(
      we.the("singular", e),
      Oe.SHOW,
      r
    )];
  }
  intersection(e) {
    if (!this.multi)
      throw new Qr("No intersections on single series charts.");
    const r = parseInt(e);
    if (r < 0 || r > this.model.intersections.length)
      throw new Qr(`No intersection with the index ${r} exists on this chart.`);
    return [this._intersectionAtIndex(r)];
  }
  allIntersection() {
    if (!this.multi)
      throw new Qr("No intersections on single series charts.");
    return txe(this.model.intersections.length, this._intersectionAtIndex.bind(this));
  }
  //The lines for {series topic}, {series topic} ... cluster together while the line for {series topic} is an outlier.
  // OR All the lines except {series topic} cluster together.
  allCluster() {
    if (!this.multi)
      return sn("No clusters on single series charts.");
    if (this.model.clusters.length !== 1)
      return sn("All cluster when there are more than 1 cluster are not implemented.");
    const e = this.model.clusters[0], r = e.map((h) => this.seriesMetadata[h].facetAverage(this.depFacetKey)), n = exe(r), i = this.model.clusterOutliers.length === 1, s = {
      type: "simple-clause",
      pred: Oe.CLUSTER,
      object: null,
      mods: [Oe.TOGETHER]
    }, o = `series-${e.join("-")}`;
    let a, l, c;
    if (i) {
      a = this.model.clusterOutliers[0];
      const h = this.seriesMetadata[a];
      l = we.proper(we.noun(h.getLabel())), c = h.facetAverage(this.depFacetKey) > n ? we.dir("above") : we.dir("below");
    }
    if (i && e.length + 1 === this.model.series.length && e.length > 2) {
      const h = {
        ...sR,
        mods: [{
          type: "point-location",
          direction: Oe.EXCEPT,
          point: l
        }]
      }, d = Jt({
        type: "simple-statement",
        subject: h,
        clause: s
      }, o), v = Jt(we.svo(l, we.pred("lie"), c), `series-${a}`), m = we.coord(Oe.WHILE, d, v);
      return m.conn = Jt(m.conn, `series-${a}`), [m];
    }
    let p = Jt({
      type: "simple-statement",
      subject: this._seriesGroupLine(e),
      clause: s
    }, o);
    if (this.model.clusterOutliers.length === 1) {
      const h = `series-${this.model.clusterOutliers[0]}`, d = Jt(we.svo(
        l,
        Oe.COPULA,
        we.a("singular", Oe.OUTLIER),
        c
      ), h);
      p = we.coord({ ...Oe.WHILE, tag: U0(h) }, p, d);
    }
    return [p];
  }
  allTrackingGroup() {
    return this.multi ? this.model.trackingGroups.map((e) => this._trackingGroup(e)) : sn("No tracking groups on single series charts.");
  }
  datapoint(e, r) {
    const n = this.model.allPoints.filter((i) => i.facetValue("x") === e && i.facetValue("y") === r).map((i) => i.seriesKey).map((i) => this.model.atKey(i).getLabel());
    return [{
      type: "label",
      text: `X: ${e}, Y: ${r}, Series: ${n.join(", ")}`
    }];
  }
  async sequence(e, r, n) {
    return [await this.seriesSummarizers[e].sequence(parseInt(r), parseInt(n))];
  }
  chartLabels() {
    const e = this.indepAxisOrient === "horiz" ? Oe.XAXIS : Oe.YAXIS;
    let r;
    return this.model.type === "pie" ? r = {
      type: "simple-entity",
      detType: "indefinite",
      number: this.model[0].length,
      category: we.noun("slice")
    } : r = {
      type: "simple-entity",
      detType: "indefinite",
      number: this.model[0].length,
      category: Oe.RECORD,
      mods: [{ type: "point-location", direction: Oe.ALONG, point: we.the("singular", e) }]
    }, [{
      type: "simple-statement",
      subject: we.the("singular", Oe.CHART),
      clause: {
        type: "simple-clause",
        pred: Oe.HAS,
        object: r
      }
    }];
  }
  highestRanking() {
    const e = this.model.series.toSorted((r, n) => n.facetAverage(this.depFacetKey) - r.facetAverage(this.depFacetKey))[0].key;
    return this.seriesSummarizers[e].ranking(!0);
  }
  // Substatement
  chartTheme() {
    return [Q4(this.model)];
  }
  dependentAxisLabel() {
    const e = RSe(this.model.getChartTheme());
    if (this.depFacet.units !== void 0 && (this.depFacet.units in W4 || this.depFacet.units in v2)) {
      let r = we.a("plural", we.noun(this.depFacet.units));
      this.depFacet.multiplier !== void 0 && (r = {
        type: "simple-entity",
        detType: "indefinite",
        number: "plural",
        category: q4[this.depFacet.multiplier],
        mods: [we.of(r)]
      }), e.mods = [we.in_(r)];
    } else if (this.depFacet.multiplier !== void 0 && this.model.getChartTheme().baseKind === "number") {
      const r = {
        type: "simple-entity",
        detType: "indefinite",
        number: "plural",
        category: q4[this.depFacet.multiplier]
      };
      e.mods ?? (e.mods = []), e.mods.push(we.in_(r));
    }
    return [e];
  }
}
const VSe = {
  pie: we.this_("singular", we.noun("slice")),
  donut: we.this_("singular", we.noun("slice"))
}, WU = {
  pie: we.this_("singular", { ...Oe.CHART, mods: [we.noun("pie")] }),
  donut: we.this_("singular", { ...Oe.CHART, mods: [we.noun("donut")] })
};
class HSe {
  constructor(e, r, n, i, s) {
    Ut(this, "seriesThemePhrase"), Ut(this, "seriesLabel"), this.key = e, this.seriesMetadata = r, this.model = n, this.depFacetKey = i, this.indepFacetKey = s, this.seriesThemePhrase = FU(this.model.getSeriesTheme(this.key)), this.seriesLabel = this.seriesMetadata.getLabel();
  }
  // Sentences
  // Overall Series Summary Sentence
  summarizeSeries(e = !1) {
    const r = e ? WU[this.model.type] : VSe[this.model.type];
    return r ? [{
      type: "simple-statement",
      subject: r,
      clause: {
        type: "simple-clause",
        pred: Oe.SHOW,
        object: this.seriesThemePhrase
      }
    }] : (console.error(`[ParaSummary]: series summaries are not implemented for ${this.model.type} charts yet`), []);
  }
  _extremePie(e) {
    if (e === "both")
      return we.and(this._extremePie("max"), this._extremePie("min"));
    const r = this.seriesMetadata.getFacetStats(this.depFacetKey)[e], n = r.datapoints.map(
      (p) => we.proper(we.noun(p.facetValue(this.indepFacetKey)))
    ), i = n.length, s = i === 1 ? n[0] : we.and(...n), o = i === 1 ? "singular" : "plural", a = r.value, l = e === "min" ? { ...we.adj("small"), comparative: "superlative" } : { ...Oe.LARGE, comparative: "superlative" }, c = we.the(o, we.noun("slice"), [l]);
    return we.svo(
      c,
      {
        ...Oe.COPULA
        /*number: extremeGramNumber*/
      },
      s,
      we.at({
        type: "number-entity",
        number: a,
        scale: Ol[0.01]
      })
    );
  }
  extreme(e) {
    return [this._extremePie(e)];
  }
  datapoint(e) {
    if (e >= this.seriesMetadata.length)
      throw new Qr(`The datapoint index ${e} is too large`);
    const r = { type: "label", text: this.seriesLabel }, n = this.seriesMetadata.datapoints[e].facetValue(this.indepFacetKey), i = { type: "quote", text: `${this.seriesMetadata.datapoints[e].facetValue(this.depFacetKey)} at ${n}.` };
    return [r, i];
  }
  intersections() {
    return console.error("Pastry charts do not have intersections and therefore do not have intersection summaries"), [];
  }
  recordCount() {
    return console.error(`[ParaSummary]: record count summaries are not implemented for ${this.model.type} charts yet`), [];
  }
  async trend() {
    return console.error("Pastry charts do not have trends and therefore do not have trends summaries"), [];
  }
}
var GSe = Object.defineProperty, WSe = Object.getOwnPropertyDescriptor, qU = (t, e, r, n) => {
  for (var i = WSe(e, r), s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && GSe(e, r, i), i;
};
const qSe = [
  "$.datasets[0]",
  "$.datasets[0].stats.extremes",
  "$.datasets[0].labels"
];
class qb extends pb {
  /**
   * @param model - The data model for the chart
   */
  constructor(e) {
    super(e), Ut(this, "summarizer"), this.summarizer = new QSe(e);
  }
  getSummarizer() {
    return this.summarizer;
  }
  async getChartSummary() {
    return this._model.multi ? V3("Summaries are not implemented for multi-series pastry charts") : this._model.description ? { text: this._model.description, html: this._model.description } : this.highlightSummaries(qSe);
  }
  async getSeriesSummary(e) {
    return V3("Series summaries are not implemented for pastry charts");
  }
  async getSequenceSummary(e) {
    return V3("sequence is not defined for pastry charts");
  }
}
qU([
  $d()
], qb.prototype, "getChartSummary");
qU([
  $d()
], qb.prototype, "getSeriesSummary");
class QSe {
  // * Initialization *
  constructor(e) {
    Ut(this, "multi"), Ut(this, "indepFacetKey"), Ut(this, "depFacetKey"), Ut(this, "seriesKeys"), Ut(this, "seriesMetadata"), Ut(this, "seriesSummarizers"), this.model = e, this.multi = this.model.multi, this.indepFacetKey = this.model.independentFacetKeys[0], this.depFacetKey = this.model.dependentFacetKeys[0], this.seriesKeys = this.model.seriesKeys, this.seriesSummarizers = {}, this.seriesMetadata = {};
    for (const r of this.seriesKeys)
      this.seriesMetadata[r] = this.model.atKey(r), this.seriesSummarizers[r] = new HSe(
        r,
        this.seriesMetadata[r],
        this.model,
        this.depFacetKey,
        this.indepFacetKey
      );
  }
  // * Data Helpers *
  _getOnlySeriesSummarizer() {
    if (this.multi)
      throw new Qr("Cannot call `_getOnlySeriesSummarizer` on multi series chart.");
    return this.seriesSummarizers[this.seriesKeys[0]];
  }
  // * Summary Helpers *
  // Statement
  // Overall Chart Summary Sentence
  // 'This {chart type} chart compares {theme of entity}.'
  _chartMultiNonTimeSeries(e) {
    return {
      type: "simple-statement",
      subject: e,
      clause: {
        type: "simple-clause",
        pred: Oe.COMPARE,
        object: zU(
          this.model.getChartTheme(),
          this.model,
          `of ${this.model.getChartTheme().entity}`
        )
      }
    };
  }
  _extreme(e) {
    throw new n2("extreme");
  }
  // * Summary Generation *
  // All Chart
  chart() {
    if (this.multi) {
      const e = WU[this.model.type];
      return e ? [this._chartMultiNonTimeSeries(e)] : (console.error(`[ParaSummary]: whole chart summaries are not implemented for ${this.model.type} charts yet`), []);
    } else
      return this._getOnlySeriesSummarizer().summarizeSeries(!0);
  }
  // Series Topics Sentence
  //The {number of series} {lines/bar segments} show the {quantity type}s of {series 1 topic}, {series 2 topic} ... 
  allSeries() {
    return console.error(`[ParaSummary]: all series summaries are not implemented for ${this.model.type} charts yet`), [];
  }
  chartMin() {
    return this.multi ? this._extreme("min") : this._getOnlySeriesSummarizer().extreme("min");
  }
  chartMax() {
    return this.multi ? this._extreme("max") : this._getOnlySeriesSummarizer().extreme("max");
  }
  chartExtremes() {
    return this.multi ? this._extreme("both") : this._getOnlySeriesSummarizer().extreme("both");
  }
  async onlySeriesTrend() {
    return sn("onlySeriesTrend is not defined for pastry charts");
  }
  // Series
  specificSeries(e) {
    return this.seriesSummarizers[e].summarizeSeries();
  }
  seriesMax(e) {
    return this.seriesSummarizers[e].extreme("max");
  }
  seriesMin(e) {
    return this.seriesSummarizers[e].extreme("min");
  }
  seriesExtremes(e) {
    return this.seriesSummarizers[e].extreme("both");
  }
  seriesDatapoint(e, r) {
    const n = this.seriesSummarizers[e], i = parseInt(r);
    return n.datapoint(i);
  }
  seriesIntersections(e) {
    if (!this.multi)
      throw new Qr("Series-Intersection can not be requested in single-series charts.");
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].intersections(
      /*this.differentia!*/
    );
  }
  seriesRecordCount(e) {
    if (!this.seriesKeys.includes(e))
      throw new Qr(`No series with the key ${e} exists in this chart.`);
    return this.seriesSummarizers[e].recordCount(
      /*this.differentia!*/
    );
  }
  async seriesTrend(e) {
    return sn("seriesTrend is not defined for pastry charts");
  }
  seriesRanking(e) {
    return sn("seriesRanking is not defined for pastry charts");
  }
  // Other
  dependentAxis() {
    return sn("Pastry charts do not have axes and therefore do not have dependent axis summaries");
  }
  independentAxis() {
    return sn("Pastry charts do not have axes and therefore do not have independent axis summaries");
  }
  intersection(e) {
    return sn("Pastry charts do not have intersections and therefore do not have intersection summaries");
  }
  allIntersection() {
    return sn("Pastry charts do not have intersections and therefore do not have intersection summaries");
  }
  allCluster() {
    return sn("Pastry charts do not have clusters and therefore do not have cluster summaries");
  }
  allTrackingGroup() {
    return sn("Pastry charts do not have tracking groups and therefore do not have cluster summaries");
  }
  datapoint(e, r) {
    const n = this.model.allPoints.filter((i) => i.facetValue("x") === e && i.facetValue("y") === r).map((i) => i.seriesKey).map((i) => this.model.atKey(i).getLabel());
    return [{
      type: "label",
      text: `X: ${e}, Y: ${r}, Series: ${n.join(", ")}`
    }];
  }
  async sequence(e, r, n) {
    return sn("Sequence summaries not implemented for pastry charts");
  }
  chartLabels() {
    const e = {
      type: "simple-entity",
      detType: "indefinite",
      number: this.model[0].length,
      category: we.noun("slice")
    };
    return [{
      type: "simple-statement",
      subject: we.the("singular", Oe.CHART),
      clause: {
        type: "simple-clause",
        pred: Oe.HAS,
        object: e
      }
    }];
  }
  highestRanking() {
    return sn("highestRanking is not defined for pastry charts");
  }
  // Substatement
  chartTheme() {
    return [Q4(this.model)];
  }
  dependentAxisLabel() {
    return console.error("Pastry charts do not have axes and therefore do not have dependent axis labels"), [];
  }
}
const KSe = ["up", "down", "left", "right", "in", "out"], YSe = {
  horizTick: "axis.horiz.ticks.labelFormat",
  vertTick: "axis.vert.ticks.labelFormat",
  linePoint: "type.line.pointLabelFormat",
  scatterPoint: "type.scatter.pointLabelFormat",
  histogramPoint: "type.histogram.pointLabelFormat",
  heatmapPoint: "type.histogram.pointLabelFormat",
  barCluster: "type.bar.clusterLabelFormat",
  pieSliceLabel: "type.pie.sliceLabelFormat",
  pieSliceValue: "type.pie.sliceValueFormat",
  donutSliceLabel: "type.donut.sliceLabelFormat",
  gaugeSliceLabel: "type.gauge.sliceLabelFormat",
  steplinePoint: "type.stepline.pointLabelFormat",
  lollipopPoint: "type.lollipop.pointLabelFormat",
  lollipopCluster: "type.lollipop.clusterLabelFormat",
  jimX: "jim.xValueFormat",
  dataTableX: "dataTable.xValueFormat",
  dataTableY: "dataTable.yValueFormat",
  statusBar: "statusBar.valueFormat",
  domId: "NA"
};
class vr {
  static hydrateInput(e) {
    const r = {};
    for (const [n, i] of Object.entries(e))
      vr.set(n, i, r, !0);
    return r;
  }
  /**
   * Generate a list of setting [key, value] pairs that would need to be applied
   * to `this` to turn it into `other`.
   * @param other - Another setting store object.
   * @returns List of [key, value] pairs. 
   */
  /*diff(other: SettingStore): [string, Setting | undefined][] {
      return this.diffGroup(this.settings, other.settings);
    }
  
    private diffGroup<T extends SettingGroup>(group: Partial<T>, withGroup: T, path = '') {
      let diff: [string, Setting | undefined][] = [];
      const keys = Object.keys(withGroup) as (keyof T)[];
      for (const key of keys) {
        const pathPlusKey = `${path ? path + '.' : ''}${key as string}`;
        if (group.hasOwnProperty(key)) {
          if (typeof group[key] === 'object') {
            if (typeof withGroup[key] !== 'object') {
              throw new Error(`type of setting '${key as string}' must be ${typeof withGroup[key]}`);
            }
            diff = diff.concat(this.diffGroup(group[key] as SettingGroup, withGroup[key] as SettingGroup, 
              pathPlusKey));
          } else if (group[key] !== withGroup[key]) {
            diff.push([pathPlusKey, withGroup[key] as Setting | undefined]);
          } 
        } else {
          // withGroup is guaranteed to have the key
          if (typeof withGroup[key] === 'object') {
            diff = diff.concat(this.diffGroup({}, withGroup[key] as SettingGroup, 
              `${path}.${key as string}`));
          } else {
            diff.push([pathPlusKey, withGroup[key] as Setting | undefined]);
          }
        }
      }
      return diff;
    }
  
    /**
     * Given a group path, return the object for it.
     * @param path - Dotted path to the group.
     * @param group - Optional group to start search from (default: root of the setting tree).
     * @param create - Optionally create groups that don't exist.
     * @returns Setting group object.
     */
  static getGroup(e, r, n = !1) {
    const i = e.split(".");
    let s = r, o = null;
    for (const a of i)
      if (o = s, s = s[a], typeof s != "object")
        if (n && s === void 0)
          s = {}, o[a] = s;
        else
          throw new Error(`invalid setting group type '${typeof s}' in '${e}'`);
    return s;
  }
  static getGroupLink(e, r) {
    return vr.getGroup(e, r);
  }
  /**
   * Given a full setting path, return the group that immediately
   * contains the setting.
   * @param path - Dotted path to the setting.
   * @param group - Optional group to start search from (default: root of the setting tree).
   * @param create - Optionally create groups that don't exist.
   * @returns Setting group.
   */
  static getGroupForSetting(e, r, n = !1) {
    const i = e.split(".");
    if (i.length < 2)
      throw new Error("setting path must have at least two elements");
    return vr.getGroup(i.slice(0, -1).join("."), r, n);
  }
  static get(e, r) {
    const n = vr.getGroupForSetting(e, r)[e.split(".").at(-1)];
    if (typeof n == "object")
      throw new Error("can only get settings, not groups");
    return n;
  }
  static set(e, r, n, i = !1) {
    const s = e.split("."), o = vr.getGroupForSetting(e, n, i);
    o[s.at(-1)] = r;
  }
  static cloneSettings(e) {
    const r = {}, n = Object.keys(e);
    for (const i of n)
      vr.cloneProp(r, e, i);
    return r;
  }
  static cloneProp(e, r, n) {
    typeof r[n] == "object" ? e[n] = vr.cloneSettings(r[n]) : e[n] = r[n];
  }
  static suppleteSettings(e, r) {
    const n = Object.keys(r);
    for (const i of n)
      if (e.hasOwnProperty(i))
        if (typeof e[i] == "object") {
          if (typeof r[i] != "object")
            throw new Error(`type of setting '${i}' must be ${typeof r[i]}`);
          this.suppleteSettings(e[i], r[i]);
        } else if (e[i] === void 0)
          vr.cloneProp(e, r, i);
        else
          continue;
      else
        vr.cloneProp(e, r, i);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const QU = Symbol.for(""), ZSe = (t) => {
  if ((t == null ? void 0 : t.r) === QU) return t == null ? void 0 : t._$litStatic$;
}, Lu = (t, ...e) => ({ _$litStatic$: e.reduce((r, n, i) => r + ((s) => {
  if (s._$litStatic$ !== void 0) return s._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${s}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(n) + t[i + 1], t[0]), r: QU }), oR = /* @__PURE__ */ new Map(), KU = (t) => (e, ...r) => {
  const n = r.length;
  let i, s;
  const o = [], a = [];
  let l, c = 0, p = !1;
  for (; c < n; ) {
    for (l = e[c]; c < n && (s = r[c], (i = ZSe(s)) !== void 0); ) l += i + e[++c], p = !0;
    c !== n && a.push(s), o.push(l), c++;
  }
  if (c === n && o.push(e[n]), p) {
    const h = o.join("$$lit$$");
    (e = oR.get(h)) === void 0 && (o.raw = o, oR.set(h, e = o)), r = a;
  }
  return t(e, ...r);
}, JSe = KU(We), XSe = KU(Tt);
var e8e = Object.defineProperty, t8e = (t, e, r, n) => {
  for (var i = void 0, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && e8e(e, r, i), i;
};
const r8e = {
  textfield: Lu`para-textfield-setting-control`,
  dropdown: Lu`para-dropdown-setting-control`,
  checkbox: Lu`para-checkbox-setting-control`,
  radio: Lu`para-radio-setting-control`,
  slider: Lu`para-slider-setting-control`,
  button: Lu`para-button-setting-control`
};
class YU extends Ay {
  constructor(e) {
    super(), this._store = e, this.log = qt("SettingControlManager"), this._settingControlInfo = {};
  }
  add(e) {
    this._settingControlInfo = Gse(this._settingControlInfo, (r) => {
      const n = {}, i = r8e[e.type];
      n.key = e.key, n.parentView = e.parentView, n.options = e.options, n.validator = e.validator, n.render = () => JSe`
        <${i}
          .value=${e.value ?? vr.get(e.key, this._store.settings)}
          .label=${e.label}
          .info=${n}
          .store=${this._store}
          ?hidden=${e.hidden}
          id="setting-${Yn(e.key)}"
        ></${i}>
      `, r[e.key] = n;
    });
  }
  info(e) {
    return this._settingControlInfo[e];
  }
  // value<T extends Setting>(key: string) {
  //   const controlInfo = this.info(key);
  //   if (!controlInfo) {
  //     throw new Error(`no setting control info for key '${key}'`);
  //   }
  //   return controlInfo.settingControlRef.value!.value as T;
  // }
  // setVisible(key: string, visible: boolean) {
  //   const controlInfo = this.info(key);
  //   if (!controlInfo) {
  //     throw new Error(`no setting control info for key '${key}'`);
  //   }
  //   if (visible) {
  //     controlInfo.settingControlRef.value!.removeAttribute('hidden');
  //   } else {
  //     controlInfo.settingControlRef.value!.setAttribute('hidden', 'hidden');
  //   }
  // }
  getContent(e) {
    return Object.values(this._settingControlInfo).filter((r) => r.parentView === e).map((r) => r.render());
  }
  /**
   * Update the control (if any) for a setting with a new value.
   * @returns Setting keys.
   */
  // update(key: string, value: Setting | undefined) {
  //   const controlInfo = this._settingControlInfo[key];
  //   if (controlInfo) {
  //     const control = controlInfo.settingControlRef.value!;
  //     if (control) {
  //       control.value = value;
  //     }
  //   } else {
  //     this.log.info(`no setting control for key '${key}'`);
  //   }
  // }
  // updateOptions(key: string, options: SettingControlOptionsType<any>) {
  //   const controlInfo = this._settingControlInfo[key];
  //   if (controlInfo) {
  //     const control = controlInfo.settingControlRef.value!;
  //     if (control) {
  //       if (!controlInfo.options) {
  //         controlInfo.options = {};
  //       }
  //       for (const prop in options) {
  //         const key = prop as keyof typeof options;
  //         controlInfo.options[key] = options[key];
  //       }
  //       control.requestUpdate();
  //     }
  //   } else {
  //     this.log.info(`no setting control for key '${key}'`);
  //   }
  // }
}
t8e([
  Ar()
], YU.prototype, "_settingControlInfo");
const K4 = [
  16.3516,
  17.32391,
  18.35405,
  19.44544,
  20.60172,
  21.82676,
  23.12465,
  24.49971,
  25.95654,
  27.5,
  29.13524,
  30.86771,
  // octave 0
  32.7032,
  34.64783,
  36.7081,
  38.89087,
  41.20344,
  43.65353,
  46.2493,
  48.99943,
  51.91309,
  55,
  58.27047,
  61.73541,
  // octave 1
  65.40639,
  69.29566,
  73.41619,
  77.78175,
  82.40689,
  87.30706,
  92.49861,
  97.99886,
  103.8262,
  110,
  116.5409,
  123.4708,
  // octave 2
  130.8128,
  138.5913,
  146.8324,
  155.5635,
  164.8138,
  174.6141,
  184.9972,
  195.9977,
  207.6523,
  220,
  233.0819,
  246.9417,
  // octave 3
  261.6256,
  277.1826,
  293.6648,
  311.127,
  329.6276,
  349.2282,
  369.9944,
  391.9954,
  415.3047,
  440,
  466.1638,
  493.8833,
  // octave 4
  523.2511,
  554.3653,
  587.3295,
  622.254,
  659.2551,
  698.4565,
  739.9888,
  783.9909,
  830.6094,
  880,
  932.3275,
  987.7666,
  // octave 5
  1046.502,
  1108.731,
  1174.659,
  1244.508,
  1318.51,
  1396.913,
  1479.978,
  1567.982,
  1661.219,
  1760,
  1864.655,
  1975.533,
  // octave 6
  2093.005,
  2217.461,
  2349.318,
  2489.016,
  2637.02,
  2793.826,
  2959.955,
  3135.963,
  3322.438,
  3520,
  3729.31,
  3951.066,
  // octave 7
  4186.009,
  4434.922,
  4698.636,
  4978.032,
  5274.041,
  5587.652,
  5919.911,
  6271.927,
  6644.875,
  7040,
  7458.62,
  7902.133
  // octave 8
], Cp = "http://www.w3.org/2000/svg", aR = {
  bar: {
    "chart.orientation": "east",
    "axis.vert.labelOrder": "northToSouth",
    "axis.horiz.ticks.isDrawTicks": !1,
    "grid.isDrawHorizLines": !1
  },
  column: {
    "axis.horiz.ticks.isDrawTicks": !0,
    "axis.vert.line.isDrawOverhang": !0,
    "grid.isDrawVertLines": !1
  },
  line: {
    "grid.isDrawVertLines": !1
  }
}, n8e = {
  chart: {
    type: "bar",
    size: {
      width: 600,
      height: 450
    },
    title: {
      isDrawTitle: !0,
      margin: 40,
      fontSize: "12pt",
      align: "center",
      position: "top"
    },
    orientation: "north",
    padding: "8 20",
    //chartType: 'line'
    fontFamily: "Helvetica, sans-serif",
    fontWeight: "300",
    fontScale: 1,
    stroke: "purple",
    strokeWidth: 4,
    strokeHighlightScale: 1.5,
    symbolStrokeWidth: 2,
    symbolHighlightScale: 1.5,
    hasDirectLabels: !0,
    directLabelFontSize: "10pt",
    hasLegendWithDirectLabels: !1,
    isDrawSymbols: !0,
    isStatic: !1,
    isShowVisitedDatapointsOnly: !1,
    showPopups: !1
  },
  axis: {
    minInterval: 25,
    datapointMargin: 3,
    horiz: {
      isDrawAxis: !0,
      position: "south",
      title: {
        isDrawTitle: !1,
        gap: 8,
        fontSize: "12pt"
      },
      ticks: {
        isDrawTicks: !1,
        padding: 3,
        opacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        length: 10,
        labelFormat: "raw",
        labels: {
          isDrawTickLabels: !0,
          fontSize: "10pt",
          angle: -45,
          offsetGap: 4,
          gap: 0
        },
        step: 1
      },
      line: {
        isDrawAxisLine: !0,
        isDrawOverhang: !0,
        strokeWidth: 2,
        strokeLinecap: "round"
      },
      labelOrder: "westToEast",
      interval: "unset"
    },
    vert: {
      isDrawAxis: !0,
      position: "west",
      title: {
        isDrawTitle: !0,
        gap: 8,
        fontSize: "12pt"
      },
      ticks: {
        isDrawTicks: !0,
        padding: 3,
        opacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        length: 10,
        labelFormat: "raw",
        labels: {
          isDrawTickLabels: !0,
          fontSize: "10pt",
          angle: 0,
          offsetGap: 0,
          gap: 0
        },
        step: 1
      },
      line: {
        isDrawAxisLine: !0,
        isDrawOverhang: !0,
        strokeWidth: 2,
        strokeLinecap: "round"
      },
      labelOrder: "southToNorth"
    },
    x: {
      minValue: "unset",
      maxValue: "unset",
      interval: "unset"
    },
    y: {
      minValue: "unset",
      maxValue: "unset",
      interval: "unset"
    }
  },
  legend: {
    isDrawLegend: !0,
    isDrawLegendWhenNeeded: !0,
    isAlwaysDrawLegend: !1,
    boxStyle: {
      outline: "none",
      //outline: 'gray',
      outlineWidth: 1,
      fill: "none"
      //fill: 'aliceblue',
    },
    padding: 10,
    symbolLabelGap: 5,
    pairGap: 30,
    position: "east",
    margin: 20,
    itemOrder: "series",
    fontSize: "10pt"
  },
  plotArea: {
    size: {
      width: 600,
      height: 250
    }
  },
  popup: {
    opacity: 1,
    leftPadding: 10,
    rightPadding: 10,
    upPadding: 10,
    downPadding: 10,
    margin: 40,
    maxWidth: 175,
    shape: "boxWithArrow",
    activation: "onHover",
    borderRadius: 10,
    backgroundColor: "dark"
  },
  type: {
    bar: {
      stacking: "standard",
      barWidth: 20,
      colorByDatapoint: !1,
      isDrawTotalLabels: !0,
      stackLabelGap: 10,
      isDrawRecordLabels: !1,
      isDrawDataLabels: !1,
      dataLabelPosition: "center",
      clusterBy: void 0,
      clusterGap: 0,
      isAbbrevSeries: !0,
      orderBy: void 0,
      barGap: 2,
      //stackInsideGap: 4,
      clusterLabelFormat: "raw",
      lineWidth: 5,
      showPopups: !1,
      labelFontSize: "8pt"
    },
    column: {
      stacking: "standard",
      barWidth: 10,
      colorByDatapoint: !1,
      isDrawTotalLabels: !1,
      isDrawRecordLabels: !1,
      isDrawDataLabels: !1,
      dataLabelPosition: "center",
      stackLabelGap: 10,
      clusterBy: void 0,
      clusterGap: 2,
      isAbbrevSeries: !0,
      orderBy: void 0,
      barGap: 20,
      //stackInsideGap: 0,
      clusterLabelFormat: "raw",
      lineWidth: 5,
      showPopups: !1,
      labelFontSize: "8pt"
    },
    line: {
      lineWidth: 5,
      lineWidthMax: 25,
      lowVisionLineWidth: 15,
      lineHighlightScale: 1.5,
      baseSymbolSize: 10,
      seriesLabelPadding: 5,
      pointLabelFormat: "raw",
      leaderLineLength: 30,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      },
      isDrawSymbols: !0,
      showPopups: !1,
      isTrendNavigationModeEnabled: !1
    },
    scatter: {
      isDrawTrendLine: !1,
      isShowOutliers: !1,
      pointLabelFormat: "raw",
      symbolStrokeWidth: 2,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      }
    },
    histogram: {
      pointLabelFormat: "raw",
      bins: 20,
      displayAxis: "x",
      groupingAxis: "",
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      },
      relativeAxes: "Counts"
    },
    heatmap: {
      pointLabelFormat: "raw",
      resolution: 20,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      }
    },
    pie: {
      outsideLabels: {
        vertGap: 10,
        arcGap: 10,
        horizShift: 15,
        horizPadding: 10,
        leaderStyle: "direct",
        format: "raw",
        underlineGap: 2,
        contents: "percentage:(value)"
      },
      insideLabels: {
        format: "raw",
        position: 0.9,
        contents: "category"
      },
      isRenderCenterLabel: !0,
      annularThickness: 1,
      centerLabel: "none",
      centerLabelPadding: 10,
      orientationAngleOffset: 90,
      explode: "",
      explodeDistance: 20
    },
    donut: {
      outsideLabels: {
        vertGap: 10,
        arcGap: 10,
        horizShift: 15,
        horizPadding: 10,
        leaderStyle: "direct",
        format: "raw",
        underlineGap: 2,
        contents: "percentage:(value)"
      },
      insideLabels: {
        format: "raw",
        position: 0.85,
        contents: "category"
      },
      isRenderCenterLabel: !0,
      annularThickness: 0.5,
      centerLabel: "title",
      centerLabelPadding: 15,
      orientationAngleOffset: 90,
      explode: "",
      explodeDistance: 20
    },
    gauge: {
      outsideLabels: {
        vertGap: 4,
        arcGap: 10,
        horizShift: 15,
        horizPadding: 10,
        leaderStyle: "direct",
        format: "raw",
        underlineGap: 6,
        contents: "percentage:(value)"
      },
      insideLabels: {
        format: "raw",
        position: 0.85,
        contents: "category"
      },
      isRenderCenterLabel: !0,
      annularThickness: 0.5,
      centerLabel: "none",
      centerLabelPadding: 10,
      orientationAngleOffset: 90,
      explode: "",
      explodeDistance: 20
    },
    stepline: {
      lineWidth: 5,
      lineWidthMax: 25,
      baseSymbolSize: 10,
      seriesLabelPadding: 5,
      pointLabelFormat: "raw",
      leaderLineLength: 30,
      symbolStrokeWidth: 2,
      selectedPointMarkerSize: {
        width: 20,
        height: 20
      }
    },
    lollipop: {
      stacking: "standard",
      barWidth: 10,
      minBarWidth: 6,
      colorByDatapoint: !1,
      isDrawTotalLabels: !1,
      stackLabelGap: 10,
      isDrawRecordLabels: !1,
      isDrawDataLabels: !1,
      dataLabelPosition: "end",
      lineWidth: 5,
      clusterBy: void 0,
      clusterGap: 5,
      isAbbrevSeries: !0,
      orderBy: void 0,
      barGap: 0.25,
      //stackInsideGap: 4,
      clusterLabelFormat: "raw",
      showPopups: !1,
      labelFontSize: "8pt"
    }
  },
  grid: {
    isDrawHorizLines: !0,
    isDrawVertLines: !0,
    isDrawHorizAxisOppositeLine: !0,
    isDrawVertAxisOppositeLine: !0
  },
  ui: {
    isVoicingEnabled: !1,
    isNarrativeHighlightEnabled: !1,
    isNarrativeHighlightPaused: !1,
    isAnnouncementEnabled: !0,
    speechRate: 1,
    isFullscreenEnabled: !1,
    isLowVisionModeEnabled: !1,
    isFocusRingEnabled: !1,
    focusRingGap: 10,
    navRunTimeoutMs: 125
  },
  animation: {
    isAnimationEnabled: !0,
    animateRevealTimeMs: 2500,
    popInAnimateRevealTimeMs: 1500,
    animationType: "uniform",
    animationOrigin: "initialValue",
    animationOriginValue: 0,
    expandPoints: !0,
    lineSnake: !1,
    symbolPopIn: !1
  },
  scrollytelling: {
    isScrollytellingEnabled: !0,
    isScrollyAnnouncementsEnabled: !0,
    isScrollySoniEnabled: !0
  },
  controlPanel: {
    isControlPanelDefaultOpen: !0,
    tabLabelStyle: "label",
    isCaptionVisible: !0,
    isExplorationBarVisible: !0,
    caption: {
      isCaptionExternalWhenControlPanelClosed: !0,
      hasBorder: !1,
      isExplorationBarBeside: !0
    },
    isSparkBrailleVisible: !1,
    isSparkBrailleControlVisible: !0,
    isMDRAnnotationsVisible: !1,
    isDataTabVisible: !0,
    isColorsTabVisible: !0,
    isAudioTabVisible: !0,
    isControlsTabVisible: !0,
    isChartTabVisible: !0,
    isAnnotationsTabVisible: !0,
    isAnalysisTabVisible: !0,
    isColorPaletteControlVisible: !0,
    isCVDControlVisible: !0
  },
  color: {
    colorVisionMode: "normal",
    isDarkModeEnabled: !1,
    contrastLevel: 1,
    colorPalette: "diva"
  },
  jim: {
    xValueFormat: "raw"
  },
  dataTable: {
    xValueFormat: "raw",
    yValueFormat: "raw"
  },
  statusBar: {
    valueFormat: "raw"
  },
  sonification: {
    isSoniEnabled: !1,
    isRiffEnabled: !0,
    isNotificationEnabled: !0,
    hertzLower: 35,
    hertzUpper: K4.length - 12,
    soniPlaySpeed: 3,
    riffSpeed: "medium",
    riffSpeedIndex: 2,
    isArpeggiateChords: !0
  },
  dev: {
    isDebug: !1,
    isShowGridTerritories: !1
  }
};
class ZU {
  constructor(e) {
    this._store = e, this.keys = /* @__PURE__ */ new Map(), this._colorMap = null, this.primary = "hsl(270, 50%, 50%)", this.accent = "hsl(270, 50%, 25%)", this.active = "hsl(270, 50%, 65%)", this._prevSelectedColor = "", this.palettes = [
      {
        key: "diva",
        title: "diva (color-blind safe)",
        colors: [
          {
            value: "hsl(227, 26%, 52%)",
            name: "blue-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(13, 58%, 35%)",
            name: "red-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(109, 93%, 24%)",
            name: "green-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(300, 50%, 50%)",
            name: "purple-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(180, 100%, 25%)",
            name: "blue-green-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(40, 98%, 69%)",
            name: "yellow",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(215, 37%, 66%)",
            name: "light blue",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(63, 100%, 23%)",
            name: "olive green",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(34, 57%, 46%)",
            name: "caramel",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(51, 56%, 64%)",
            name: "tan",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(85, 65%, 36%)",
            name: "forest green"
          },
          {
            value: "hsl(12, 56%, 51%)",
            name: "red-orange"
          },
          {
            value: "hsl(30, 42%, 35%)",
            name: "brown"
          },
          {
            value: "hsl(240, 100%, 50%)",
            name: "bright blue"
          },
          {
            value: "hsl(120, 100%, 50%)",
            name: "lime green"
          },
          {
            value: "hsl(39, 100%, 50%)",
            name: "orange",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(300, 100%, 25%)",
            name: "royal purple"
          },
          {
            value: "hsl(51, 100%, 50%)",
            name: "lemon yellow"
          },
          {
            value: "hsl(328, 100%, 54%)",
            name: "fuschia"
          },
          {
            value: "hsl(177, 70%, 41%)",
            name: "cyan"
          },
          {
            value: "hsl(234, 20.5%, 47.8%)",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "warm",
        title: "warm hues (color-blind safe)",
        colors: [
          {
            value: "hsl(38, 96%, 58%)",
            name: "orange"
          },
          {
            value: "hsl(82, 77%, 40%)",
            name: "green"
          },
          {
            value: "hsl(54, 81%, 73%)",
            name: "yellow"
          },
          {
            value: "hsl(22, 97%, 51%)",
            name: "red"
          },
          {
            value: "hsl(77, 98%, 25%)",
            name: "forest green"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "cold",
        title: "cold hues (color-blind safe)",
        colors: [
          {
            value: "hsl(223, 100%, 70%)",
            name: "blue"
          },
          {
            value: "hsl(331, 72%, 51%)",
            name: "pink"
          },
          {
            value: "hsl(23, 100%, 50%)",
            name: "tangerine"
          },
          {
            value: "hsl(251, 83%, 65%)",
            name: "purple"
          },
          {
            value: "hsl(41, 100%, 50%)",
            name: "orange"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "rainbow",
        title: "rainbow (color-blind safe)",
        colors: [
          {
            value: "hsl(270, 100%, 29%)",
            name: "purple"
          },
          {
            value: "hsl(330, 100%, 71%)",
            name: "pink"
          },
          {
            value: "hsl(30, 100%, 43%)",
            name: "cinnamon"
          },
          {
            value: "hsl(180, 100%, 14%)",
            name: "green"
          },
          {
            value: "hsl(210, 100%, 43%)",
            name: "blue"
          },
          {
            value: "hsl(0, 100%, 29%)",
            name: "red"
          },
          {
            value: "hsl(120, 100%, 57%)",
            name: "pale green"
          },
          {
            value: "hsl(60, 100%, 71%)",
            name: "pale yellow"
          },
          {
            value: "hsl(330, 100%, 86%)",
            name: "pale pink"
          },
          {
            value: "hsl(210, 100%, 86%)",
            name: "pale blue"
          },
          {
            value: "hsl(30, 100%, 29%)",
            name: "brown"
          },
          {
            value: "hsl(180, 100%, 29%)",
            name: "blue-gree"
          },
          {
            value: "hsl(270, 100%, 71%)",
            name: "lavendar"
          },
          {
            value: "hsl(210, 100%, 71%)",
            name: "light blue"
          },
          {
            value: "hsl(0, 0%, 0%)",
            name: "black"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "ffb",
        title: "FFB",
        colors: [
          {
            value: "hsl(4, 50%, 52%)",
            //'rgb(210,67,62)',
            name: "red",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(39, 70%, 44%)",
            // rgb(246,171,6)',
            name: "yellow",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(131, 100%, 18%)",
            // 'rgb(33,131,57)',
            name: "green",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(210, 25%, 25%)",
            //'rgb(38,121,153)',
            name: "blue",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(4, 50%, 52%)",
            //'rgb(42,64,81)',
            name: "indigo",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "rgb(13,53,67)",
            name: "slate",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "rgb(48,64,69)",
            name: "dark gray",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(0, 0%, 80%)",
            // 'rgb(204,204,204)',
            name: "light gray",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            name: "no_opinion",
            value: "hsl(0, 0%, 80%)",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            name: "very_unrewarding",
            value: "hsl(4, 50%, 52%)"
          },
          {
            name: "neutral",
            value: "hsl(39, 70%, 44%)"
          },
          {
            name: "somewhat_rewarding",
            value: "hsl(131, 100%, 18%)"
          },
          {
            name: "very_rewarding",
            value: "hsl(210, 25%, 25%)"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "deutan",
        title: "deutan",
        cvd: !0,
        colors: [
          {
            value: "hsl(300, 100%, 25%)",
            name: ""
          },
          {
            value: "hsl(300, 100%, 50%)",
            name: ""
          },
          {
            value: "hsl(320, 100%, 40%)",
            name: ""
          },
          {
            value: "hsl(329, 100%, 49%)",
            name: ""
          },
          {
            value: "hsl(300, 100%, 35%)",
            name: ""
          },
          {
            value: "hsl(210, 43%, 47%)",
            name: ""
          },
          {
            value: "hsl(353, 80%, 67%)",
            name: ""
          },
          {
            value: "hsl(130, 60%, 33%)",
            name: ""
          },
          {
            value: "hsl(52, 57%, 53%)",
            name: ""
          },
          {
            value: "hsl(195, 80%, 67%)",
            name: ""
          },
          {
            value: "hsl(326, 54%, 43%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "protan",
        title: "protan",
        cvd: !0,
        colors: [
          {
            value: "hsl(39, 70%, 54%)",
            name: ""
          },
          {
            value: "hsl(206, 68%, 66%)",
            name: ""
          },
          {
            value: "hsl(154, 39%, 44%)",
            name: ""
          },
          {
            value: "hsl(56, 81%, 66%)",
            name: ""
          },
          {
            value: "hsl(209, 57%, 43%)",
            name: ""
          },
          {
            value: "hsl(24, 68%, 46%)",
            name: ""
          },
          {
            value: "hsl(324, 35%, 62%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "tritan",
        title: "tritan",
        cvd: !0,
        colors: [
          {
            value: "hsl(210, 60%, 67%)",
            name: ""
          },
          {
            value: "hsl(200, 100%, 80%)",
            name: ""
          },
          {
            value: "hsl(163, 47%, 50%)",
            name: ""
          },
          {
            value: "hsl(67, 60%, 50%)",
            name: ""
          },
          {
            value: "hsl(60, 100%, 33%)",
            name: ""
          },
          {
            value: "hsl(50, 75%, 73%)",
            name: ""
          },
          {
            value: "hsl(348, 100%, 83%)",
            name: ""
          },
          {
            value: "hsl(210, 60%, 67%)",
            name: ""
          },
          {
            value: "hsl(200, 100%, 80%)",
            name: ""
          },
          {
            value: "hsl(163, 47%, 50%)",
            name: ""
          },
          {
            value: "hsl(67, 60%, 50%)",
            name: ""
          },
          {
            value: "hsl(60, 100%, 33%)",
            name: ""
          },
          {
            value: "hsl(50, 75%, 73%)",
            name: ""
          },
          {
            value: "hsl(348, 100%, 83%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "grayscale",
        title: "grayscale",
        cvd: !0,
        colors: [
          {
            value: "hsl(0, 0%, 15%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 35%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 50%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 63%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 73%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 83%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 93%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 15%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 35%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 50%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 63%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 73%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 83%)",
            name: ""
          },
          {
            value: "hsl(0, 0%, 93%)",
            name: ""
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      },
      {
        key: "pattern",
        title: "pattern",
        isPattern: !0,
        colors: [
          {
            value: "hsl(225, 30%, 52%)",
            name: "blue"
          },
          {
            value: "hsl(12, 69%, 35%)",
            name: "red"
          },
          {
            value: "hsl(75, 43%, 45%)",
            name: "green"
          },
          {
            value: "hsl(40, 98%, 69%)",
            name: "yellow"
          },
          {
            value: "hsl(215, 37%, 66%)",
            name: "light blue"
          },
          {
            value: "hsl(63, 100%, 23%)",
            name: "olive green"
          },
          {
            value: "hsl(34, 57%, 46%)",
            name: "caramel"
          },
          {
            value: "hsl(51, 56%, 64%)",
            name: "tan"
          },
          {
            value: "hsl(253, 26%, 43%)",
            name: "purple"
          },
          {
            value: "hsl(85, 65%, 36%)",
            name: "forest green"
          },
          {
            value: "hsl(12, 56%, 51%)",
            name: "red-orange"
          },
          {
            value: "hsl(30, 42%, 35%)",
            name: "brown"
          },
          {
            value: "hsl(240, 100%, 50%)",
            name: "bright blue"
          },
          {
            value: "hsl(120, 100%, 50%)",
            name: "lime green"
          },
          {
            value: "hsl(39, 100%, 50%)",
            name: "orange"
          },
          {
            value: "hsl(300, 100%, 25%)",
            name: "royal purple"
          },
          {
            value: "hsl(51, 100%, 50%)",
            name: "lemon yellow"
          },
          {
            value: "hsl(328, 100%, 54%)",
            name: "fuschia"
          },
          {
            value: "hsl(177, 70%, 41%)",
            name: "cyan"
          },
          {
            value: "cyan",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ],
        patterns: [
          {
            value: Tt`
              <pattern id="Pattern0"  patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(45)">
                <line class="pattern" x1="0" y="0" x2="0" y2="10" stroke='hsl(225, 30%, 52%)' stroke-width="5" />
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "diagonal_lines"
          },
          {
            value: Tt`
              <pattern id="Pattern1" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10">
                <circle cx="5" cy="5" r="2" fill='hsl(12, 69%, 35%)' />
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "dots"
          },
          {
            value: Tt`
              <pattern id="Pattern2" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10">
                <path d="M 10 0 L 0 0 0 10" fill="none" stroke='hsl(75, 43%, 45%)' stroke-width="5"/>
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "grid"
          },
          {
            value: Tt`
              <pattern id="Pattern3" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10">
                <path d="M 0 0 L 10 10 M 10 0 L 0 10" stroke='hsl(40, 98%, 69%)' stroke-width="3"/>
              </pattern>
               `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "crosshatch"
          },
          {
            value: Tt`
              <pattern id="Pattern4" class="pattern" patternUnits="userSpaceOnUse" width="20" height="10">
                <path d="M 0 5 Q 5 0, 10 5 T 20 5" fill="none" stroke='hsl(215, 37%, 66%)' stroke-width="3"/>
              </pattern>
              `,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "waves"
          },
          {
            value: Tt`
              <pattern id="Pattern5" class="pattern" patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(135)">
                <line x1="0" y="0" x2="0" y2="10" stroke='hsl(63, 100%, 23%)' stroke-width="5" />
              </pattern>`,
            contrastValue: "hsl(0, 0%, 0%)",
            name: "diagonal_lines2"
          },
          {
            value: Tt`
              <pattern id="Pattern6" class="pattern" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
              <circle cx="10" cy="10" r="10" fill='hsl(34, 57%, 46%)'" />
              </pattern>`,
            contrastValue: "hsl(0, 0%, 0%)",
            name: ""
          },
          {
            value: Tt`hsl(0, 100%, 50%)`,
            name: "visit"
          }
        ]
      },
      {
        key: "low-vision",
        title: "low-vision",
        colors: [
          {
            value: "hsl(240, 100%, 60%)",
            name: "blue-2",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(13, 58%, 35%)",
            name: "red-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(120, 100%, 33%)",
            name: "green-2",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(300, 77%, 54%)",
            name: "magenta-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(39, 100%, 31%)",
            name: "brown-1",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(40, 98%, 69%)",
            name: "yellow",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(215, 37%, 66%)",
            name: "light blue",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(63, 100%, 23%)",
            name: "olive green",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(34, 57%, 46%)",
            name: "caramel",
            contrastValue: "hsl(0, 0%, 100%)"
          },
          {
            value: "hsl(51, 56%, 64%)",
            name: "tan",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(85, 65%, 36%)",
            name: "forest green"
          },
          {
            value: "hsl(12, 56%, 51%)",
            name: "red-orange"
          },
          {
            value: "hsl(30, 42%, 35%)",
            name: "brown"
          },
          {
            value: "hsl(240, 100%, 50%)",
            name: "bright blue"
          },
          {
            value: "hsl(120, 100%, 50%)",
            name: "lime green"
          },
          {
            value: "hsl(39, 100%, 50%)",
            name: "orange",
            contrastValue: "hsl(0, 0%, 0%)"
          },
          {
            value: "hsl(300, 100%, 25%)",
            name: "royal purple"
          },
          {
            value: "hsl(51, 100%, 50%)",
            name: "lemon yellow"
          },
          {
            value: "hsl(328, 100%, 54%)",
            name: "fuschia"
          },
          {
            value: "hsl(177, 70%, 41%)",
            name: "cyan"
          },
          {
            value: "hsl(234, 20.5%, 47.8%)",
            name: "highlight"
          },
          {
            value: "hsl(0, 100%, 50%)",
            name: "visit"
          }
        ]
      }
    ], e.settings.color.colorMap && this.setColorMap(...e.settings.color.colorMap.split(",").map((r) => r.trim()));
  }
  get paletteKey() {
    return this._store.settings.color.colorVisionMode === "normal" ? this._store.settings.color.colorPalette : this._store.settings.color.colorVisionMode;
  }
  get palette() {
    const e = this.palettes[this.indexOfPalette(this.paletteKey)];
    if (e)
      return e;
    throw new Error(`no palette named '${this.paletteKey}'`);
  }
  get prevSelectedColor() {
    return this._prevSelectedColor;
  }
  setColorMap(...e) {
    e.includes("visit") || e.push("visit");
    for (const r of e) {
      const n = this.colorIndex(r);
      if (n === -1)
        throw new Error(`no color named '${r}' in current palette`);
      this._colorMap || (this._colorMap = []), this._colorMap.push(n);
    }
  }
  addPalette(e) {
    this.palettes.push(e);
  }
  indexOfPalette(e) {
    return this.palettes.findIndex((r) => r.key === e);
  }
  colorAt(e) {
    var r;
    return ((r = this.palette.colors[e]) == null ? void 0 : r.name) ?? "default";
  }
  /**
   * Wrap color index if out of range.
   * @param index
   * @returns valid index
   */
  wrapColorIndex(e) {
    return e % this.palette.colors.length;
  }
  /**
   * Get palette index of a color.
   * @param name
   * @returns index or -1 if not found
   */
  colorIndex(e) {
    return this.palette.colors.findIndex((r) => r.name === e);
  }
  /**
   * Get palette index of a color value.
   * @param value
   * @returns index or -1 if not found
   */
  colorValueIndex(e) {
    return this.palette.colors.findIndex((r) => r.value === e);
  }
  colorValue(e) {
    if (e === "default")
      return "hsl(0, 0%, 50%)";
    const r = this.palette.colors.find((n) => n.name === e);
    if (!r)
      throw new Error(`no color named '${e}'`);
    return r.value;
  }
  colorValueAt(e) {
    const r = this._colorMap ? this._colorMap.map((n) => this.palette.colors[n]) : this.palette.colors;
    return e === -1 ? r.at(-1).value : e === -2 ? r.at(-2).value : r[e % (r.length - 1)].value;
  }
  patternValueAt(e) {
    const r = this.palette.patterns;
    return e === -1 ? r.at(-1).value : r[e % (r.length - 1)].value;
  }
  contrastValueAt(e) {
    const r = this.palette.isPattern ? this.palette.patterns : this._colorMap ? this._colorMap.map((n) => this.palette.colors[n]) : this.palette.colors;
    return e === -1 ? r.at(-1).contrastValue : r[e % (r.length - 1)].contrastValue ?? "hsl(0, 0%, 100%)";
  }
  registerKey(e) {
    this.keys.has(e) || this.keys.set(e, {
      index: this.keys.size,
      base: null,
      light: null,
      dark: null
    });
  }
  getPaletteList() {
  }
  // set_colors(color_obj: Colors) {
  //   if (!color_obj.palette) {
  //     // if no palette, use the default palette
  //     this.setPalette(0);
  //   } else {
  //     // if palette, append the default palette to the supplied palette, for more values
  //     this.palette = color_obj.palette.concat(this.palette);
  //   }
  //   this.primary = color_obj.primary;
  //   this.accent = color_obj.accent;
  //   this.active = color_obj.active;
  // }
  selectPaletteWithKey(e) {
    this._prevSelectedColor = this.paletteKey, this._store.updateSettings((r) => {
      r.color.colorPalette = e;
    });
  }
  /*get_palettes  ( palette_ids ) {
      if (!palette_ids) {
        return this.palettes;
      }
  
      if ( `string` === typeof palette_ids) {
        return this.palettes[palette_ids];
      }
  
      let palettes = [];
      for (let i = 0, i_len = palette_ids.length; i_len > i; ++i) {
        let palette = this.palettes[palette_ids[i]];
        if (!palette) {
          palette = this.palettes[`palette-${palette_ids[i]}`];
        }
  
        if (palette) {
          palettes.push(palette);
        }
      }
      return palettes;
    }*/
  /*set_palette_color_by_index  ( palette_id, index, color ) {
    let palette = this.palettes[palette_id];
    if (palette) {
      palette[index] = color;
    }
  }*/
  /*create_palette  ( id, colors, metadata ) {
    let palette = this.palettes[id];
    if (!palette) {
      this.palettes[id] = {};
      palette = this.palettes[id];
    }
    palette.name = metadata.name;
    palette.title = metadata.title;
    palette.type = metadata.type;
    palette.colors = colors;
  }*/
  getHslComponents(e) {
    let r = /hsl[a]?\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/, n = e.match(r);
    return {
      hue: +n[1],
      h: +n[1],
      saturation: +n[2],
      s: +n[2],
      lightness: +n[3],
      l: +n[3],
      alpha: 1,
      a: 1
    };
  }
  lighten(e, r) {
    let n = this.getHslComponents(e), i = n.hue, s = n.saturation, o = n.lightness;
    const a = Math.min(o + r * 5, 100);
    return `hsl(${i}, ${s}%, ${a}%)`;
  }
  generateSequentialPalette(e, r, n) {
    let i = this.getHslComponents(e), s = i.hue, o = i.saturation, a = i.lightness, l = o - 15;
    n && (l = 85 - o);
    let c = Math.round(l / r / 5), p = a - 15;
    n && (p = 85 - a);
    let h = Math.round(p / r), d = [];
    for (let v = 0, m = r; m > v; ++v)
      d.push(`hsl(${s}, ${o}%, ${a}%)`), n ? (o += c, a += h) : (o -= c, a -= h);
    return d;
  }
  /*generate_interpolation_palette  ( hsl1, hsl2, count, palette_id ) {
      let hsl_comp1 = this.getHslComponents(hsl1);
      let h1 = hsl_comp1.hue;
      let s1 = hsl_comp1.saturation;
      let l1 = hsl_comp1.lightness;
  
      let hsl_comp2 = this.getHslComponents(hsl2);
      let h2 = hsl_comp2.hue;
      let s2 = hsl_comp2.saturation;
      let l2 = hsl_comp2.lightness;
  
      count -= 1;
  
      let h_range = h1 - h2;
      let h_interval = h_range/count;
  
      let s_range = s1 - s2;
      let s_interval = s_range/count;
  
      let l_range = l1 - l2;
      let l_interval = l_range/count;
  
      let palette = [];
      for (let i = 0, i_len = count; i_len > i; ++i) {
        palette.push(`hsl(${Math.round(h1)}, ${Math.round(s1)}%, ${Math.round(l1)}%)`);
        h1 -= h_interval;
        s1 -= s_interval;
        l1 -= l_interval;
      }
      palette.push(`hsl(${h2}, ${s2}%, ${l2}% )`);
  
      this.create_palette( palette_id, palette,
        {
          name: palette_id,
          title: palette_id,
          type: `numeric`
        }
      )
    }*/
  /*hsl_to_hex (h, s, l) {
    // function credit to https://stackoverflow.com/questions/7609130/set-the-value-of-an-input-field
    h /= 360;
    s /= 100;
    l /= 100;
    let r, g, b;
    if (s === 0) {
      r = g = b = l; // achromatic
    } else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    const toHex = x => {
      const hex = Math.round(x * 255).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }*/
  //https://stackoverflow.com/questions/46432335/hex-to-hsl-convert-javascript
  /*hex_to_hsl (hex, is_formatted) {
      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  
      let r = parseInt(result[1], 16);
      let g = parseInt(result[2], 16);
      let b = parseInt(result[3], 16);
  
      r /= 255, g /= 255, b /= 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
  
      if(max == min){
          h = s = 0; // achromatic
      } else {
          let d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch(max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
      }
  
      s = s*100;
      s = Math.round(s);
      l = l*100;
      l = Math.round(l);
      h = Math.round(360*h);
  
      let colorInHSL=[h,s,l];
      if (!is_formatted) {
        return colorInHSL;
      } else {
        return `hsl(${h}, ${s}%, ${l}%)`;
      }
    }*/
}
const i8e = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left",
  topLeft: "bottomRight",
  topRight: "bottomLeft",
  bottomRight: "topLeft",
  bottomLeft: "topRight"
};
function s8e(t, e = 2, r = !0) {
  return r && Math.trunc(t) === t ? t.toString() : t.toFixed(e);
}
function nt(t, ...e) {
  if (e.length === 0)
    return t[0];
  const r = t.slice(0, -1).map((n, i) => n + (typeof e[i] == "number" ? s8e(e[i]) : e[i]));
  return r.push(t.at(-1)), r.join("");
}
function QIe(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function o8e(t, e) {
  t = t.replace(/\s+/g, "_").replace(/[^\w-]+/g, "");
  let r = 0, n = t;
  for (; e.idList[n]; )
    n = t + "-" + ++r;
  return e.idList[n] = !0, n;
}
function KIe() {
  return null;
}
function YIe(...t) {
  return new DOMRect(
    Math.min(...t.map((e) => e.left)),
    Math.min(...t.map((e) => e.top)),
    Math.max(...t.map((e) => e.width)),
    Math.max(...t.map((e) => e.height))
  );
}
function Y4(...t) {
  const e = Math.min(...t.map((s) => s.left)), r = Math.max(...t.map((s) => s.right)), n = Math.min(...t.map((s) => s.top)), i = Math.max(...t.map((s) => s.bottom));
  return new DOMRect(
    e,
    n,
    r - e,
    i - n
  );
}
function ZIe(t, e, r) {
  return t.seriesKey === e && t.index === r;
}
function a8e(t) {
  return i8e[t];
}
function l8e(t, e) {
  return !(e.offsetX - t.documentView.padding.left - t.documentView.chartLayers.x < 0 || e.offsetX - t.documentView.padding.left - t.documentView.chartLayers.x > t.documentView.chartLayers.width || e.offsetY - t.documentView.padding.top - t.documentView.chartLayers.y < 0 || e.offsetY - t.documentView.padding.top - t.documentView.chartLayers.y > t.documentView.chartLayers.height);
}
class Ye {
  constructor(e = 0, r = 0) {
    this._x = e, this._y = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e;
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e;
  }
  clone() {
    return new Ye(this._x, this._y);
  }
  equal(e) {
    return this._x === e._x && this._y === e._y;
  }
  setX(e) {
    return new Ye(e, this._y);
  }
  setY(e) {
    return new Ye(this._x, e);
  }
  add(e) {
    return new Ye(
      this._x + e._x,
      this._y + e._y
    );
  }
  addScalar(e) {
    return new Ye(
      this._x + e,
      this._y + e
    );
  }
  addX(e) {
    return new Ye(
      this._x + e,
      this._y
    );
  }
  addY(e) {
    return new Ye(
      this._x,
      this._y + e
    );
  }
  subtract(e) {
    return new Ye(
      this._x - e._x,
      this._y - e._y
    );
  }
  subtractScalar(e) {
    return new Ye(
      this._x - e,
      this._y - e
    );
  }
  subtractX(e) {
    return new Ye(
      this._x - e,
      this._y
    );
  }
  subtractY(e) {
    return new Ye(
      this._x,
      this._y - e
    );
  }
  multiply(e) {
    return new Ye(
      this._x * e._x,
      this._y * e._y
    );
  }
  multiplyScalar(e) {
    return new Ye(
      this._x * e,
      this._y * e
    );
  }
  divide(e) {
    return new Ye(
      this._x / e._x,
      this._y / e._y
    );
  }
  divideScalar(e) {
    return new Ye(
      this._x / e,
      this._y / e
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y;
  }
  length() {
    return Math.sqrt(this.dot(this));
  }
  normalize() {
    return this.divideScalar(this.length());
  }
  project(e) {
    return e.multiplyScalar(this.dot(e) / e.dot(e));
  }
  rotate(e) {
    const r = Math.cos(e), n = Math.sin(e), i = -n, s = r;
    return new Ye(
      this._x * r + this._y * n,
      this._x * i + this._y * s
    );
  }
  lerp(e, r) {
    return new Ye(
      this._x * (1 - r) + e._x * r,
      this._y * (1 - r) + e._y * r
    );
  }
}
class c8e {
  constructor(e, r, n, i) {
    this._centerDiffX = e, this._centerDiffY = r, this._rSumX = n, this._rSumY = i;
  }
  // {+x, -x, +y, -y}, shortest
  escape() {
    const r = [0, 0, 0, 0];
    this._centerDiffX > 0 ? (r[0] = this._rSumX - this._centerDiffX + 1e-3, r[1] = -(this._rSumX + this._centerDiffX + 1e-3)) : (r[0] = this._rSumX - this._centerDiffX + 1e-3, r[1] = -(this._rSumX + this._centerDiffX + 1e-3)), this._centerDiffY > 0 ? (r[2] = this._rSumY - this._centerDiffY + 1e-3, r[3] = -(this._rSumY + this._centerDiffY + 1e-3)) : (r[2] = this._rSumY - this._centerDiffY + 1e-3, r[3] = -(this._rSumY + this._centerDiffY + 1e-3));
    let n = 0;
    for (let i = 1; i < 4; i++)
      Math.abs(r[i]) < Math.abs(r[n]) && (n = i);
    return {
      dists: r,
      shortest: n
    };
  }
  escapeVector() {
    const r = this._rSumX - Math.abs(this._centerDiffX), n = this._rSumY - Math.abs(this._centerDiffY), i = { x: 0, y: 0 };
    return r < n ? i.x = this._centerDiffX > 0 ? r + 1e-3 : -r - 1e-3 : i.y = this._centerDiffY > 0 ? n + 1e-3 : -n - 1e-3, i;
  }
}
class u8e {
  constructor() {
    this.log = qt("BaseView"), this.isContainer = !1;
  }
  get id() {
    return "";
  }
  get x() {
    return 0;
  }
  get y() {
    return 0;
  }
  get width() {
    return 0;
  }
  get height() {
    return 0;
  }
  set width(e) {
  }
  set height(e) {
  }
  get children() {
    return [];
  }
  get padding() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  set padding(e) {
  }
  get hidden() {
    return !1;
  }
  set hidden(e) {
  }
  get el() {
    return null;
  }
  get styleInfo() {
    return {};
  }
  get classInfo() {
    return {};
  }
  renderChildren() {
    return Tt`${this.children.map((e) => e.render())}`;
  }
  content(...e) {
    return this.renderChildren();
  }
  render(...e) {
    return this.hidden ? Tt`` : this.content(...e);
  }
}
class Pr extends u8e {
  constructor(e) {
    super(), this.paraview = e, this._parent = null, this._prev = null, this._next = null, this._children = [], this._loc = new Ye(), this._locOffset = new Ye(), this._width = -1, this._height = -1, this._canWidthFlex = !1, this._canHeightFlex = !1, this._isBubbleSizeChange = !1, this._currFocus = null, this._padding = { top: 0, bottom: 0, left: 0, right: 0 }, this._hidden = !1, this._styleInfo = {}, this._classInfo = {}, this._isObserveStore = !1, this._isObserveNotices = !1;
  }
  get id() {
    return this._id;
  }
  set id(e) {
    this._id = e, this.paraview.requestUpdate();
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    if (e && this._parent)
      throw new Error("parent already set");
    if (!e) {
      if (this._parent) {
        this._parent._children.splice(this.index, 1);
        const r = this._parent;
        this._parent = null, this._prev && (this._prev._next = this._next), this._next && (this._next._prev = this._prev), this._prev = null, this._next = null, this._removedFromParent(), r._didRemoveChild(this);
      }
      return;
    }
    this._width === -1 && this._height === -1 && this.updateSize(), this._parent = e, this.index && (this._prev = e.children[this.index - 1], this._prev._next = this), this._next = e._children[this.index + 1] ?? null, this._next && (this._next._prev = this), this._addedToParent(), this._parent._didAddChild(this), this._id || (this.id = this._createId());
  }
  _createId(...e) {
    return "";
  }
  _addedToParent() {
  }
  _removedFromParent() {
  }
  _didAddChild(e) {
  }
  _didRemoveChild(e) {
  }
  get children() {
    return this._children;
  }
  get index() {
    var e;
    return ((e = this._parent) == null ? void 0 : e._children.indexOf(this)) ?? -1;
  }
  get isFocused() {
    return this._parent.currFocus === this;
  }
  get loc() {
    return this._loc.clone();
  }
  set loc(e) {
    this._loc = e;
  }
  get locOffset() {
    return this._locOffset.clone();
  }
  set locOffset(e) {
    this._locOffset = e;
  }
  // XXX These next 4 accessors are for legacy compatibility
  get _x() {
    return this._loc.x;
  }
  set _x(e) {
    this._loc.x = e;
  }
  get _y() {
    return this._loc.y;
  }
  set _y(e) {
    this._loc.y = e;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(e) {
    this._x = e;
  }
  set y(e) {
    this._y = e;
  }
  get width() {
    return this._hidden ? 0 : this._width;
  }
  get height() {
    return this._hidden ? 0 : this._height;
  }
  set width(e) {
    const r = this._width;
    this._width = e, r !== e && this._boundingSizeDidChange(r, this._height);
  }
  set height(e) {
    const r = this._height;
    this._height = e, r !== e && this._boundingSizeDidChange(this._width, r);
  }
  get paddedWidth() {
    return this._hidden ? 0 : this.width + this._padding.left + this._padding.right;
  }
  get paddedHeight() {
    return this._hidden ? 0 : this.height + this._padding.top + this._padding.bottom;
  }
  get padding() {
    return this._padding;
  }
  set padding(e) {
    const r = this._padding.top + this._padding.bottom, n = this._padding.left + this._padding.right;
    this._padding = this._expandPadding(e), (r !== this._padding.top + this._padding.bottom || n !== this._padding.left + this._padding.right) && this._boundingSizeDidChange(n + this._width, r + this._height);
  }
  _expandPadding(e, r) {
    if (typeof e == "number")
      return { top: e, bottom: e, left: e, right: e };
    {
      let n = {};
      return e.all !== void 0 && (n = { top: e.all, bottom: e.all, left: e.all, right: e.all }), e.horiz !== void 0 && (n.left = e.horiz, n.right = e.horiz), e.vert !== void 0 && (n.top = e.vert, n.bottom = e.vert), e.top !== void 0 && (n.top = e.top), e.bottom !== void 0 && (n.bottom = e.bottom), e.left !== void 0 && (n.left = e.left), e.right !== void 0 && (n.right = e.right), n.left === void 0 && (n.left = (r == null ? void 0 : r.left) ?? 0), n.right === void 0 && (n.right = (r == null ? void 0 : r.right) ?? 0), n.top === void 0 && (n.top = (r == null ? void 0 : r.top) ?? 0), n.bottom === void 0 && (n.bottom = (r == null ? void 0 : r.bottom) ?? 0), n;
    }
  }
  get canWidthFlex() {
    return this._canWidthFlex;
  }
  set canWidthFlex(e) {
    this._canWidthFlex = e;
  }
  get canHeightFlex() {
    return this._canHeightFlex;
  }
  set canHeightFlex(e) {
    this._canHeightFlex = e;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(e) {
    const r = this.paddedWidth, n = this.paddedHeight;
    this._hidden = e, (r || n) && this._boundingSizeDidChange(r, n);
  }
  get left() {
    return this._x - this._locOffset.x;
  }
  set left(e) {
    this._x = e + this._locOffset.x;
  }
  get paddedLeft() {
    return this.left - this._padding.left;
  }
  set paddedLeft(e) {
    this._x = e + this._padding.left + this._locOffset.x;
  }
  get right() {
    return this.left + this.width;
  }
  set right(e) {
    this._x = e - this.width + this._locOffset.x;
  }
  get paddedRight() {
    return this.right + this._padding.right;
  }
  set paddedRight(e) {
    this._x = e - this._padding.right - this.width + this._locOffset.x;
  }
  get centerX() {
    return this.left + this.width / 2;
  }
  set centerX(e) {
    this._x = e - this.width / 2 + this._locOffset.x;
  }
  get top() {
    return this._y - this._locOffset.y;
  }
  set top(e) {
    this._y = e + this._locOffset.y;
  }
  get paddedTop() {
    return this.top - this._padding.top;
  }
  set paddedTop(e) {
    this._y = e + this._padding.top + this._locOffset.y;
  }
  get bottom() {
    return this.top + this.height;
  }
  set bottom(e) {
    this._y = e - this.height + this._locOffset.y;
  }
  get paddedBottom() {
    return this.bottom + this._padding.bottom;
  }
  set paddedBottom(e) {
    this._y = e - this._padding.bottom - this.height + this._locOffset.y;
  }
  get centerY() {
    return this.top + this.height / 2;
  }
  set centerY(e) {
    this._y = e - this.height / 2 + this._locOffset.y;
  }
  get bbox() {
    return new DOMRect(this.left, this.top, this.width, this.height);
  }
  /**
   * Bounding box inclusive of stroke width
   */
  get outerBbox() {
    return this.bbox;
  }
  computeSize() {
    return [this.width, this.height];
  }
  setSize(e, r, n = !0) {
    const i = this._width, s = this._height;
    this._width = e, this._height = r, (i !== this._width || s !== this._height) && this._boundingSizeDidChange(i, s, n);
  }
  resize(e, r) {
    this.setSize(e, r);
  }
  get isBubbleSizeChange() {
    return this._isBubbleSizeChange;
  }
  set isBubbleSizeChange(e) {
    this._isBubbleSizeChange = e;
  }
  _boundingSizeDidChange(e, r, n = !0) {
  }
  _bubbleSizeChange() {
    this._parent._childDidResize(this);
  }
  updateSize(e = !0) {
    this.setSize(...this.computeSize(), e);
  }
  _childDidResize(e) {
  }
  snapXTo(e, r) {
    r === "start" ? this.left = e.left : r === "end" ? this.right = e.right : this.centerX = e.centerX;
  }
  snapYTo(e, r) {
    r === "start" ? this.top = e.top : r === "end" ? this.bottom = e.bottom : this.centerY = e.centerY;
  }
  get styleInfo() {
    return { ...this._styleInfo };
  }
  set styleInfo(e) {
    this._styleInfo = { ...e };
  }
  get classInfo() {
    return { ...this._classInfo };
  }
  set classInfo(e) {
    this._classInfo = { ...e };
  }
  get prev() {
    return this._prev;
  }
  get next() {
    return this._next;
  }
  get siblings() {
    return this._parent.children.filter((e) => e !== this);
  }
  get withSiblings() {
    return this._parent.children;
  }
  get cousins() {
    return this._parent.siblings.map((e) => e.children[this.index]);
  }
  get withCousins() {
    return this._parent.withSiblings.map((e) => e.children[this.index]);
  }
  get nextCousin() {
    return this._parent.next ? this.cousins[this._parent.index] : null;
  }
  get prevCousin() {
    return this._parent.prev ? this.cousins[this._parent.index - 1] : null;
  }
  get currFocus() {
    return this._currFocus;
  }
  set currFocus(e) {
    this._currFocus = e;
  }
  /*get eventActionManager() {
      return this._eventActionManager;
    }
  
    get hotkeyActionManager() {
      return this._hotkeyActionManager;
    }
  
    protected get _eventActions(): Actions<this> {
      return {};
    }
  
    protected get _hotkeyActions(): Actions<this> {
      return {};
    }
  
    get keymap(): KeyRegistrations {
      return {};
    }
  
    protected _setActions() {
      const eventActions = this._eventActions;
      if (Object.keys(eventActions).length) {
        this._eventActionManager = new EventActionManager(this, eventActions);
      }
      this._hotkeyActionManager = new HotkeyActionManager(this, this._hotkeyActions);
    }
  
    updateKeymap() {
      const keyMap = this.keymap;
      if (Object.keys(keyMap).length) {
        this._keymapManager = new KeymapManager(this);
      }
    }
  
    hotkeyInfo(key: string): HotkeyInfo | undefined {
      const action = this._keymapManager?.actionForKey(key);
      if (action) {
        return todo().canvas.hotkeyInfo(key, action, this);
      }
      if (this._parent) {
        return this._parent.hotkeyInfo(key);
      }
      return undefined;
    }*/
  intersects(e) {
    const r = this.centerX - e.centerX, n = e.paddedWidth / 2 + this.paddedWidth / 2;
    if (Math.abs(r) >= n)
      return null;
    const i = this.centerY - e.centerY, s = e.paddedHeight / 2 + this.paddedHeight / 2;
    return Math.abs(i) >= s ? null : new c8e(r, i, n, s);
  }
  async focus(e = !1, r = 0) {
    this._parent && (this._parent.currFocus && this._parent.currFocus !== this && !r && await this._parent.currFocus.blur(!1), this._parent.currFocus = this, await this._parent.focus(e, r + 1), this._currFocus ? r || await this.focusLeaf.onFocus(e) : await this.onFocus(e));
  }
  async onFocus(e = !1) {
  }
  async blur(e = !0) {
    this._parent.currFocus = null, await this.onBlur(), e && await this._parent.onFocus();
  }
  async onBlur() {
  }
  get focusLeaf() {
    return this._currFocus ? this._currFocus.focusLeaf : this;
  }
  _didAddChildToList(e) {
  }
  append(e) {
    this._children.push(e), this._didAddChildToList(e), e.parent = this;
  }
  prepend(e) {
    this._children.unshift(e), this._didAddChildToList(e), e.parent = this;
  }
  insert(e, r) {
    this._children.splice(r, 0, e), this._didAddChildToList(e), e.parent = this;
  }
  remove() {
    this.parent = null;
  }
  reverseChildren() {
    this._children.reverse(), this._children.forEach((e, r) => {
      const n = e._prev;
      e._prev = e._next, e._next = n;
    });
  }
  sortChildren(e) {
    this._children.sort(e), this._children.forEach((r, n) => {
      n === 0 ? r._prev = null : (n === this._children.length - 1 && (r._next = null), r._prev = this._children[n - 1], r._prev._next = r);
    });
  }
  clearChildren() {
    [...this._children].forEach((e) => {
      e.remove();
    });
  }
  replaceChild(e, r) {
    const n = e.index;
    e.remove(), this.insert(r, n);
  }
  settingDidChange(e, r, n) {
    this._children.forEach((i) => i.settingDidChange(e, r, n));
  }
  get isObserveStore() {
    return this._isObserveStore;
  }
  observeStore() {
    this._isObserveStore = !0, this._parent && this._parent.observeStore();
  }
  async storeDidChange(e, r) {
    this._isObserveStore && this._children.forEach((n) => {
      n.isObserveStore && n.storeDidChange(e, r);
    });
  }
  get isObserveNotices() {
    return this._isObserveNotices;
  }
  observeNotices() {
    this._isObserveNotices = !0, this._parent && this._parent.observeNotices();
  }
  noticePosted(e, r) {
    this._isObserveNotices && this._children.forEach((n) => {
      n.isObserveNotices && n.noticePosted(e, r);
    });
  }
  focusRingShape() {
    return null;
  }
  focusRingBbox() {
    return null;
  }
}
function vo(t) {
  return class extends t {
    constructor() {
      super(...arguments), this.isContainer = !0;
    }
    render() {
      if (this.hidden)
        return Tt``;
      const r = this.x + this.padding.left, n = this.y + this.padding.top;
      return XSe`
        <g
          ${this.ref}
          id=${this.id || Ne}
          class=${Object.keys(this.classInfo).length ? Br(this.classInfo) : Ne}
          style=${Object.keys(this.styleInfo).length ? mn(this.styleInfo) : Ne}
          role=${this.role || Ne}
          aria-roledescription=${this.roleDescription || Ne}
          transform=${r || n ? nt`translate(${r},${n})` : Ne}
        >
          ${this.content()}
        </g>
      `;
    }
  };
}
class h8e extends Pr {
  _createId() {
    return "chart-landing";
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get children() {
    return this._children;
  }
  get datapointViews() {
    return this._children.flatMap((e) => e.children);
  }
  get focusLeaf() {
    return super.focusLeaf;
  }
  getSeriesView(e) {
    return this._children.find((r) => r.series.key === e);
  }
  chartSummary() {
    return "At top level.";
  }
}
let JU = class Z4 extends Pr {
  constructor(e, r) {
    super(e.paraview), this.chart = e, this.seriesKey = r, this._isStyleEnabled = !1, this._series = this.chart.paraview.store.model.atKey(r);
  }
  get series() {
    return this._series;
  }
  get seriesProps() {
    return this.chart.paraview.store.seriesProperties.properties(this.seriesKey);
  }
  get siblings() {
    return super.siblings.filter((e) => e instanceof Z4);
  }
  get withSiblings() {
    return super.withSiblings.filter((e) => e instanceof Z4);
  }
  get prev() {
    return super.prev;
  }
  get next() {
    return super.next;
  }
  get currFocus() {
    return this._currFocus;
  }
  set currFocus(e) {
    super.currFocus = e;
  }
  get prevFocus() {
    return this._prevFocus;
  }
  get color() {
    return this.seriesProps.color;
  }
  get styleInfo() {
    const e = super.styleInfo;
    return this._isStyleEnabled && this._updateStyleInfo(e), e;
  }
  set styleInfo(e) {
    super.styleInfo = e;
  }
  _updateStyleInfo(e) {
    let r = this.chart.paraview.store.colors.colorValueAt(this.color);
    e.fill = r, e.stroke = r, e.strokeWidth = this.paraview.store.settings.chart.strokeWidth;
  }
  async onFocus(e = !1) {
  }
  select(e) {
  }
};
class Qb extends Pr {
  constructor(e, r) {
    super(e), this._role = "", this._ref = null, this._isPattern = !1, this._x = r.x ?? this._x, this._y = r.y ?? this._y, this._scale = r.scale ?? 1, r.strokeWidth && (this._styleInfo.strokeWidth = r.strokeWidth), r.stroke && (this._styleInfo.stroke = r.stroke), r.fill && (this._styleInfo.fill = r.fill), r.opacity !== void 0 && (this._styleInfo.opacity = r.opacity), this._isClip = !!r.isClip;
  }
  get _options() {
    return {
      x: this._x,
      y: this._y,
      fill: this._styleInfo.fill,
      stroke: this._styleInfo.stroke,
      opacity: this._styleInfo.opacity,
      strokeWidth: this._styleInfo.strokeWidth,
      scale: this._scale,
      isClip: this._isClip
    };
  }
  get role() {
    return this._role;
  }
  set role(e) {
    this._role = e;
  }
  get stroke() {
    if (this._styleInfo.stroke)
      return this._styleInfo.stroke;
    let e = this._parent;
    for (; e; ) {
      if (e.styleInfo.stroke)
        return e.styleInfo.stroke;
      e = e.parent;
    }
    return this.paraview.store.settings.chart.stroke;
  }
  set stroke(e) {
    this._styleInfo.stroke = e;
  }
  get strokeWidth() {
    if (this._styleInfo.strokeWidth !== void 0)
      return this._styleInfo.strokeWidth;
    let e = this._parent;
    for (; e; ) {
      if (e.styleInfo.strokeWidth !== void 0)
        return e.styleInfo.strokeWidth;
      e = e.parent;
    }
    return this.paraview.store.settings.chart.strokeWidth;
  }
  set strokeWidth(e) {
    this._styleInfo.strokeWidth = e;
  }
  get effectiveStrokeWidth() {
    return this.stroke === "none" ? 0 : this.strokeWidth;
  }
  get fill() {
    return this._styleInfo.fill;
  }
  set fill(e) {
    this._styleInfo.fill = e;
  }
  get outerBbox() {
    return new DOMRect(
      this.left - this.effectiveStrokeWidth / 2,
      this.top - this.effectiveStrokeWidth / 2,
      this.width + this.effectiveStrokeWidth,
      this.height + this.effectiveStrokeWidth
    );
  }
  get scale() {
    return this._scale;
  }
  set scale(e) {
    this._scale = e;
  }
  get isClip() {
    return this._isClip;
  }
  set isClip(e) {
    this._isClip = e;
  }
  get ref() {
    return this._ref;
  }
  set ref(e) {
    this._ref = e;
  }
}
class nn extends Qb {
  constructor(e, r) {
    super(e, r), this.options = r, this._width = r.width, this._height = r.height, r.isPattern && (this._isPattern = r.isPattern);
  }
  get _options() {
    let e = super._options;
    return e.width = this._width, e.height = this._height, e.isPattern = this._isPattern, e;
  }
  clone() {
    return new nn(this.paraview, this._options);
  }
  render() {
    if (this._options.isPattern) {
      let e = this.parent.parent.index;
      return this._styleInfo.fill = `url(#Pattern${e})`, Tt`
      <defs>${this.paraview.store.colors.patternValueAt(e)}</defs>
      <rect
        x=${nt`${this._x}`}
        y=${nt`${this._y}`}
        width=${nt`${this.width}`}
        height=${nt`${this.height}`}
        fill="white"
        stroke-width=2
      ></rect>
      <rect
        ${this._ref ? yt(this._ref) : void 0}
        id=${this._id || Ne}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : Ne}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : Ne}
        role=${this._role || Ne}
        x=${nt`${this._x}`}
        y=${nt`${this._y}`}
        width=${nt`${this.width}`}
        height=${nt`${this.height}`}
        @pointerenter=${this.options.pointerEnter ?? Ne}
        @pointerleave=${this.options.pointerLeave ?? Ne}
      ></rect>
    `;
    } else
      return Tt`
      <rect
        ${this._ref ? yt(this._ref) : void 0}
        id=${this._id || Ne}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : Ne}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : Ne}
        role=${this._role || Ne}
        x=${nt`${this._x}`}
        y=${nt`${this._y}`}
        width=${nt`${this.width}`}
        height=${nt`${this.height}`}
        clip-path=${this._options.isClip ? "url(#clip-path)" : Ne}
        @pointerenter=${this.options.pointerEnter ?? Ne}
        @pointerleave=${this.options.pointerLeave ?? Ne}
      ></rect>
    `;
  }
}
class hf extends JU {
  constructor(e) {
    super(e.chart, e.series.key), this._shapes = [], this._symbol = null, this._baseSymbolScale = 1, this._animStartState = {}, this._animEndState = {};
  }
  _addedToParent() {
    super._addedToParent();
  }
  _removedFromParent() {
    super._removedFromParent(), this._parent.chart.unregisterDatapoint(this);
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get cousins() {
    return super.cousins;
  }
  get withCousins() {
    return super.withCousins;
  }
  get nextSeriesLanding() {
    return this._parent.next;
  }
  get prevSeriesLanding() {
    return this._parent.prev;
  }
  get datapoint() {
    return this.series.datapoints[this.index];
  }
  /**
   * Identifier of the form: `${seriesKey}-${index}`
   * NB: *NOT* the same as the `id` property (the DOM ID)
   */
  get datapointId() {
    return `${this.seriesKey}-${this.index}`;
  }
  get selectedMarker() {
    return new nn(this.paraview, {
      width: this._width / 2,
      height: this._width / 2,
      x: this._x - this._width / 4,
      y: this._y - this._width / 4,
      fill: "none",
      stroke: "black",
      strokeWidth: 2,
      isClip: this.shouldClip
    });
  }
  get shapes() {
    return [...this._shapes];
  }
  get symbol() {
    return this._symbol;
  }
  set baseSymbolScale(e) {
    this._baseSymbolScale = e;
  }
  get classInfo() {
    return {
      datapoint: !0,
      visited: this.paraview.store.isVisited(this.seriesKey, this.index),
      selected: this.paraview.store.isSelected(this.seriesKey, this.index),
      highlighted: this.chart.chartInfo.isHighlighted(this.seriesKey, this.index)
    };
  }
  get color() {
    return this._isStyleEnabled ? this.index : this._parent.color;
  }
  /**
   * May be overridden to apply shape-specific style info
   * (e.g., if only a particular shape should be highlighted on visitation)
   * @param shapeIndex - Index of the shape in `_shapes`.
   * @returns Style info
   */
  _shapeStyleInfo(e) {
    return this.styleInfo;
  }
  get ref() {
    return this.chart.paraview.ref(this._id);
  }
  get el() {
    return this.ref.value;
  }
  get x() {
    return super.x;
  }
  set x(e) {
    this._shapes.forEach((r) => {
      r.x += e - this._x;
    }), this._symbol && (this._symbol.x += e - this._x), super.x = e;
  }
  get y() {
    return super.y;
  }
  set y(e) {
    this._shapes.forEach((r) => {
      r.y += e - this._y;
    }), this._symbol && (this._symbol.y += e - this._y), super.y = e;
  }
  get shouldClip() {
    const e = this.outerBbox;
    return this.paraview.store.settings.animation.isAnimationEnabled && this.paraview.store.settings.animation.lineSnake ? !0 : e.right < this.chart.x || e.bottom < this.chart.y || e.left > this.chart.right || e.top > this.chart.bottom;
  }
  _createId(...e) {
    const r = this._parent.modelIndex * this._series.length + this.index + 1;
    return this.paraview.store.jimerator.jim.selectors[`datapoint${r}`].dom.slice(1);
  }
  get id() {
    return super.id;
  }
  set id(e) {
    super.id = e, this._parent.chart.registerDatapoint(this);
  }
  /** Compute and set `x` and `y` */
  computeLocation() {
  }
  /** Do any other layout (which may depend on the location being set) */
  completeLayout() {
    if (this._createShapes(), this._createSymbol(), this._children.length === 1) {
      const e = this._children[0];
      e.id = this._id, e.role = "datapoint";
    } else
      this._children.forEach((e, r) => {
        const n = e instanceof Qb ? `${r}` : "sym";
        e.id = `${this._id}-${n}`;
      });
    this.layoutSymbol();
  }
  /**
   *
   * @param t - Value between 0 and 1
   */
  beginAnimStep(e) {
  }
  /**
   *
   * @param t - Value between 0 and 1
   */
  endAnimStep(e) {
    this.completeLayout();
  }
  /**
   * Subclasses should override this;
   * If there will be shapes, add them to `this._shapes` first,
   * THEN call `super._createShapes()`.
   * Otherwise, override with an empty method.
   */
  _createShapes() {
    this._shapes.forEach((e) => {
      this.append(e);
    });
  }
  _createSymbol() {
    var n;
    let r = this.seriesProps.symbol;
    (n = this._symbol) == null || n.remove(), this._symbol = Fa.fromType(this.paraview, r), this.append(this._symbol);
  }
  layoutSymbol() {
    this._symbol && (this._symbol.x = this._x, this._symbol.y = this._y);
  }
  get symbolScale() {
    return this.paraview.store.isVisited(this.seriesKey, this.index) ? this.paraview.store.settings.chart.symbolHighlightScale : this.chart.chartInfo.isHighlighted(this.seriesKey, this.index) ? 1 : this._baseSymbolScale;
  }
  get _symbolColor() {
    return this.paraview.store.isVisited(this.seriesKey, this.index) ? -1 : this.color;
  }
  _contentUpdateShapes() {
    this._shapes.forEach((e, r) => {
      e.styleInfo = this._shapeStyleInfo(r);
    });
  }
  _contentUpdateSymbol() {
    this._symbol && (this._symbol.scale = this.symbolScale, this._symbol.color = this._symbolColor, this._symbol.hidden = !this.paraview.store.settings.chart.isDrawSymbols);
  }
  content() {
    if (this._contentUpdateShapes(), this._contentUpdateSymbol(), this._children.length === 1) {
      const e = this._children[0];
      return e.classInfo = this.classInfo, super.content();
    } else
      return Tt`
        <g
          id=${this._id}
          class=${Br(this.classInfo)}
          role="datapoint"
        >
          ${super.content()}
        </g>`;
  }
  equals(e) {
    return this.datapoint.seriesKey === e.datapoint.seriesKey && this.datapoint.datapointIndex === e.datapoint.datapointIndex;
  }
  addPopup(e) {
  }
  removePopup(e) {
  }
}
class Ak extends vo(JU) {
  constructor(e, r, n) {
    super(e, r), this._isStyleEnabled = n ?? !0;
  }
  _createId() {
    return `series-${Yn(this.seriesKey)}`;
  }
  _seriesRef(e) {
    return this.chart.paraview.ref(`series.${e}`);
  }
  get ref() {
    return yt(this._seriesRef(this._series.key));
  }
  get class() {
    return "series";
  }
  get classInfo() {
    return {
      series: !0,
      lowlight: this.paraview.store.isSeriesLowlighted(this._series.key),
      hidden: this.paraview.store.hiddenSeriesList.includes(this._series.key)
    };
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  // @ts-ignore
  get children() {
    return this._children;
  }
  get modelIndex() {
    return this.paraview.store.model.seriesKeys.indexOf(this.seriesKey);
  }
  _updateStyleInfo(e) {
    super._updateStyleInfo(e), this.chart.updateSeriesStyle(e);
  }
  nextSeriesLanding() {
    return this._next;
  }
  prevSeriesLanding() {
    return this._prev;
  }
}
const eu = 100;
function p8e() {
  const t = Math.sqrt(eu / Math.PI), e = t * 2;
  return {
    path: nt`m0,${-t} a${t},${t} 0 1,1 0,${e} a${t},${t} 0 1,1 0,${-e}`,
    baseWidth: e,
    baseHeight: e
  };
}
function d8e() {
  const t = Math.sqrt(eu), e = t / 2;
  return {
    path: `m${-e},${-e} h${t} v${t} h${-t} z`,
    baseWidth: t,
    baseHeight: t
  };
}
function f8e() {
  const t = Math.sqrt(0.75), e = Math.sqrt(2 * eu / t), r = e * t;
  return {
    path: nt`m${-e / 2},${r / 2.5} h${e} l${-e / 2},${-r} z`,
    baseWidth: e,
    baseHeight: r
  };
}
function g8e() {
  const t = Math.sqrt(0.75), e = Math.sqrt(2 * eu / t), r = e * t;
  return {
    path: nt`m${-e / 2},-${r / 2.5} h${e} l${-e / 2},${r} z`,
    baseWidth: e,
    baseHeight: r
  };
}
function m8e() {
  const t = Math.sqrt(eu), e = Math.sqrt(2 * t ** 2) / 2;
  return {
    path: nt`
      m0,-${e}
      l${e},${e}
      l-${e},${e}
      l-${e},-${e} z`,
    baseWidth: e * 2,
    baseHeight: e * 2
  };
}
function y8e() {
  const t = eu / 5, e = Math.sqrt(t);
  return {
    path: nt`
      m${-e * 1.5},${e / 2}
      h${e}
      v${e}
      h${e}
      v${-e}
      h${e}
      v${-e}
      h${-e}
      v${-e}
      h${-e}
      v${e}
      h${-e} z`,
    baseWidth: e * 3,
    baseHeight: e * 3
  };
}
function v8e() {
  const t = eu / 5, e = Math.sqrt(t), r = Math.sqrt(2 * e ** 2) / 2;
  return {
    path: nt`
      m-${r},0
      l-${r},-${r}
      l${r},-${r}
      l${r},${r}
      l${r},-${r}
      l${r},${r}
      l-${r},${r}
      l${r},${r}
      l-${r},${r}
      l-${r},-${r}
      l-${r},${r}
      l-${r},-${r} z`,
    baseWidth: r * 3,
    baseHeight: r * 3
  };
}
function b8e() {
  const t = eu / 2, e = Math.sqrt(t / 1.72), n = (100 - t) / 5 * 2 / e, i = Math.sqrt((e / 2) ** 2 + n ** 2), s = 2 * 180 * Math.atan(e / 2 / n) / Math.PI, o = s + 72, a = o - s / 2 - 90, l = Math.cos(a * Math.PI / 180) * i, c = Math.sin(a * Math.PI / 180) * i, h = 180 - (90 - a) - s, d = 90 - h, v = o - d, m = Math.sin(h * Math.PI / 180) * i, b = Math.cos(h * Math.PI / 180) * i, f = Math.cos(v * Math.PI / 180) * i, E = Math.sin(v * Math.PI / 180) * i, A = Math.sin(o / 2 * Math.PI / 180) * i, x = Math.cos(o / 2 * Math.PI / 180) * i, g = 0.6682 * e;
  return {
    path: nt`
      m-${e / 2},-${g}
      l${e / 2},-${n}
      l${e / 2},${n}
      l${l},${c}
      l-${m},${b}
      l${f},${E}
      l-${A},-${x}
      l-${A},${x}
      l${f},-${E}
      l-${m},-${b} z`,
    baseWidth: l * 2 + e,
    baseHeight: n + c + +b + E
  };
}
const ex = {
  circle: p8e(),
  square: d8e(),
  triangle_up: f8e(),
  triangle_down: g8e(),
  diamond: m8e(),
  plus: y8e(),
  x: v8e(),
  star: b8e()
};
class Fa extends Pr {
  constructor(e, r, n, i) {
    super(e), this._role = "", this._options = {
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? this.paraview.store.settings.chart.symbolStrokeWidth,
      scale: (i == null ? void 0 : i.scale) ?? 1,
      color: i == null ? void 0 : i.color,
      opacity: i == null ? void 0 : i.opacity,
      dashed: (i == null ? void 0 : i.dashed) ?? !1,
      lighten: (i == null ? void 0 : i.lighten) ?? !1,
      isClip: (i == null ? void 0 : i.isClip) ?? !1,
      pointerEnter: i == null ? void 0 : i.pointerEnter,
      pointerLeave: i == null ? void 0 : i.pointerLeave
    }, this.type = `${r}.${n}`, this._locOffset.x = this.width / 2, this._locOffset.y = this.height / 2, this._updateStyleInfo(), this._classInfo = {
      symbol: !0,
      [n]: !0
    };
  }
  static fromType(e, r, n) {
    let i, s;
    return r === "default" ? (i = "circle", s = "outline", n ?? (n = {}), n.dashed = !0) : [i, s] = r.split("."), new Fa(e, i, s, n);
  }
  get type() {
    return this._type;
  }
  set type(e) {
    this._type = e;
    const [r, n] = e.split(".");
    this._defsKey = `sym-${r}-${n}`, this.paraview.defs[this._defsKey] || this.paraview.addDef(this._defsKey, Tt`
        <path
          id=${this._defsKey}
          d=${ex[this.shape].path}
        />
      `), this._updateStyleInfo();
  }
  get width() {
    return ex[this.shape].baseWidth * this._options.scale;
  }
  get height() {
    return ex[this.shape].baseHeight * this._options.scale;
  }
  get outerBbox() {
    return new DOMRect(
      this._x - this.width / 2 - this._options.scale * this._options.strokeWidth / 2,
      this._y - this.height / 2 - this._options.scale * this._options.strokeWidth / 2,
      this.width + this._options.scale * this._options.strokeWidth,
      this.height + this._options.scale * this._options.strokeWidth
    );
  }
  get shape() {
    return this._type.split(".")[0];
  }
  set shape(e) {
    this.type = e + "." + this._type.split(".")[1];
  }
  get fill() {
    return this._type.split(".")[1];
  }
  set fill(e) {
    this.type = this._type.split(".")[0] + "." + e, this._updateStyleInfo();
  }
  get color() {
    return this._options.color;
  }
  set color(e) {
    this._options.color = e, this._updateStyleInfo();
  }
  get opacity() {
    return this._options.opacity;
  }
  set opacity(e) {
    this._options.opacity = e, this._updateStyleInfo();
  }
  get scale() {
    return this._options.scale;
  }
  set scale(e) {
    this._options.scale = e;
  }
  get role() {
    return this._role;
  }
  set role(e) {
    this._role = e;
  }
  clone() {
    const e = Fa.fromType(this.paraview, this._type, this._options);
    return e.x = this._x, e.y = this._y, e;
  }
  _updateStyleInfo() {
    if (this._styleInfo = {
      strokeWidth: this._options.strokeWidth
    }, this._options.dashed && (this._styleInfo.strokeDasharray = "1px 2px"), this._options.color !== void 0) {
      if (this.fill === "solid")
        if (this._options.lighten) {
          const e = this.paraview.store.colors.colorValueAt(
            this._options.color
          ).match(/\d+/g).map(Number);
          e[1] -= Math.min(10, e[1]), e[2] += Math.min(25, 100 - e[2]), this._styleInfo.fill = `hsl(${e[0]}, ${e[1]}%, ${e[2]}%)`;
        } else
          this._styleInfo.fill = this.paraview.store.colors.colorValueAt(
            this._options.color
          );
      else this.fill === "outline" ? this._styleInfo.fill = "white" : this._styleInfo.fill = "none";
      this._options.opacity !== void 0 && (this._styleInfo.opacity = this._options.opacity), this._styleInfo.stroke = this.paraview.store.colors.colorValueAt(
        this._options.color
      );
    }
  }
  content() {
    let e = nt`translate(${this._x},${this._y})`;
    return this._options.scale !== 1 && (e += nt` scale(${this._options.scale})`), this.paraview.store.type, this.parent instanceof hf && (this._y < 0 || this._y > this.parent.chart.parent.logicalHeight) && (this.hidden = !0), this.hidden ? Tt`` : Tt`
      <use
        href="#${this._defsKey}"
        id=${this._id || Ne}
        role=${this._role || Ne}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : Ne}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : Ne}
        transform=${e}
        @pointerenter=${this._options.pointerEnter ?? Ne}
        @pointerleave=${this._options.pointerLeave ?? Ne}
        clip-path=${/*this._options.isClip ? 'url(#clip-path)' :*/
    Ne}
      />
    `;
  }
}
class XU {
  constructor() {
    this.shapes = [
      "circle",
      "square",
      "triangle_up",
      "diamond",
      "plus",
      "star",
      "triangle_down",
      "x"
    ], this.fills = [
      "outline",
      "solid"
    ], this.types = this.fills.flatMap((e) => this.shapes.map((r) => `${r}.${e}`));
  }
  symbolAt(e) {
    return this.types[e] ?? "default";
  }
}
class lR {
  constructor(e) {
    this.store = e, this.seriesList = e.model.series.map((r, n) => new w8e(r.key, e.colors.wrapColorIndex(n), e.symbols.symbolAt(n)));
  }
  properties(e) {
    const r = this.seriesList.find((n) => n.key === e);
    if (!r)
      throw new Error(`no properties for series key '${e}'`);
    return r;
  }
}
class w8e {
  constructor(e, r, n) {
    this.key = e, this.color = r, this.symbol = n;
  }
}
const x8e = {
  label: "Add an annotation",
  hotkeys: [
    "a"
  ]
}, E8e = {
  label: "Toggle screen reader announcements",
  hotkeys: [
    "b"
  ]
}, S8e = {
  label: "Jump to chord landing",
  hotkeys: [
    "c"
  ]
}, A8e = {
  label: "Show the help dialog",
  hotkeys: [
    "h"
  ]
}, k8e = {
  label: "Toggle dark mode",
  hotkeys: [
    "k"
  ]
}, _8e = {
  label: "Toggle low-vision mode",
  hotkeys: [
    "l"
  ]
}, C8e = {
  label: "Toggle narrative highlight mode",
  hotkeys: [
    "n"
  ]
}, I8e = {
  label: "Query data",
  hotkeys: [
    "q"
  ]
}, P8e = {
  label: "Repeat last message",
  hotkeys: [
    "r"
  ]
}, R8e = {
  label: "Toggle sonification mode",
  hotkeys: [
    "s"
  ]
}, O8e = {
  label: "Toggle trend navigation mode",
  hotkeys: [
    "t"
  ]
}, T8e = {
  label: "Clear the datapoint selection",
  hotkeys: [
    "u"
  ]
}, L8e = {
  label: "Toggle self-voicing mode",
  hotkeys: [
    "v"
  ]
}, M8e = {
  label: "Move the cursor",
  parameters: {
    direction: "string"
  },
  hotkeys: [
    {
      keyID: "arrowright",
      args: {
        direction: "right"
      }
    },
    {
      keyID: "arrowleft",
      args: {
        direction: "left"
      }
    },
    {
      keyID: "arrowup",
      args: {
        direction: "up"
      }
    },
    {
      keyID: "arrowdown",
      args: {
        direction: "down"
      }
    },
    {
      keyID: "Shift+arrowup",
      args: {
        direction: "out"
      }
    },
    {
      keyID: "Shift+arrowdown",
      args: {
        direction: "in"
      }
    }
  ]
}, N8e = {
  label: "Play datapoints to the right",
  hotkeys: [
    "Shift+end"
  ]
}, D8e = {
  label: "Play datapoints to the left",
  hotkeys: [
    "Shift+home"
  ]
}, $8e = {
  label: "Stop playing",
  hotkeys: [
    "Ctrl+control"
  ]
}, j8e = {
  label: "Go to first point in series",
  hotkeys: [
    "home",
    ";"
  ]
}, B8e = {
  label: "Go to last point in series",
  hotkeys: [
    "end",
    "'"
  ]
}, F8e = {
  label: "Play or pause audio",
  hotkeys: [
    " "
  ]
}, z8e = {
  label: "Reset the chart",
  hotkeys: [
    "Shift+ "
  ]
}, U8e = {
  label: "Select a datapoint",
  hotkeys: [
    "enter"
  ]
}, V8e = {
  label: "Extend the datapoint selection",
  hotkeys: [
    "Shift+enter"
  ]
}, H8e = {
  label: "Go to the series minimum",
  hotkeys: [
    "["
  ]
}, G8e = {
  label: "Go to the series maximum",
  hotkeys: [
    "]"
  ]
}, W8e = {
  label: "Go to the chart minimum",
  hotkeys: [
    "Shift+{"
  ]
}, q8e = {
  label: "Go to the chart maximum",
  hotkeys: [
    "Shift+}"
  ]
}, Q8e = {
  label: "Announce version info",
  hotkeys: [
    "Ctrl+Shift+v"
  ]
}, K8e = {
  label: "Stop speaking (self-voicing mode)",
  hotkeys: [
    "Ctrl",
    "escape"
  ]
}, Y8e = {
  addAnnotation: x8e,
  toggleAnnouncementMode: E8e,
  jumpToChordLanding: S8e,
  openHelp: A8e,
  toggleDarkMode: k8e,
  toggleLowVisionMode: _8e,
  toggleNarrativeHighlightMode: C8e,
  queryData: I8e,
  repeatLastAnnouncement: P8e,
  toggleSonificationMode: R8e,
  toggleTrendNavigationMode: O8e,
  clearSelection: T8e,
  toggleVoicingMode: L8e,
  move: M8e,
  playRight: N8e,
  playLeft: D8e,
  stopPlay: $8e,
  goFirst: j8e,
  goLast: B8e,
  playPauseMedia: F8e,
  reset: z8e,
  select: U8e,
  extendSelection: V8e,
  goMinimum: H8e,
  goMaximum: G8e,
  goTotalMinimum: W8e,
  goTotalMaximum: q8e,
  announceVersionInfo: Q8e,
  shutUp: K8e
}, eV = Y8e;
class Z8e extends Event {
  constructor(e, r, n) {
    super("hotkeypress", { bubbles: !0, cancelable: !0, composed: !0 }), this.key = e, this.action = r, this.args = n;
  }
}
class J8e extends EventTarget {
  constructor(e) {
    super(), this.log = qt("KeymapManager"), this._keyDetails = {}, this.registerHotkeys(e);
  }
  /**
   * Handle the keydown event
   * @param event - keydown event
   */
  // handleKeyEvents(event: CustomEvent) {
  //   if (event.detail in this._keymap) {
  //     this.view.actionManager!.call(this._keymap[keyPress].action);
  //   } else if (keyPress.toUpperCase() in this._keymap) {
  //     this.view.actionManager!.call(this._keymap[keyPress.toUpperCase()].action);
  //   }
  // }
  /**
   * Register a hotkey.
   * @param keyInfo - the key ID string or key with args object
   * @param action - the action to perform if the key is pressed
   */
  registerHotkey(e, r) {
    const n = typeof e == "string" ? e : e.keyID;
    try {
      this._keyDetails[n] = {
        key: n,
        //title: this.todo.controller.translator.translate(titleId),
        //description,
        action: r
        //keyDescription
      }, typeof e != "string" && (this._keyDetails[n].args = e.args), n.length === 1 && n.toLocaleUpperCase() !== n && (this._keyDetails[`Shift+${n}`] = {
        key: n,
        //title: this.todo.controller.translator.translate(titleId),
        //description,
        action: r
        //keyDescription
      });
    } catch (i) {
      i instanceof Error && this.log.warn(i.message);
    }
  }
  /**
   * Register multiple hotkeys.
   * Effectively a shortcut to calling `.registerHotkey()` multiple times
   * @param keyRegistrations - hotkey registration info
   */
  registerHotkeys(e) {
    for (const [r, n] of Object.entries(e))
      for (const i of n.hotkeys)
        this.registerHotkey(i, r);
  }
  onKeydown(e) {
    const r = this._keyDetails[e];
    return r ? (this.dispatchEvent(new Z8e(e, r.action, r.args)), !0) : !1;
  }
  /**
   * Build a help dialog
   * @param lang Language of the dialog - used in attribute, and for i18n
   * @param translationCallback - get language-specific verbiage
   */
  /*generateHelpDialog(
      lang: string,
      translationCallback: (
        code: string,
        //evaluators?: translateEvaluators
      ) => string
    ) {
      const dialog = document.createElement("dialog");
      dialog.setAttribute("lang", lang);
  
      const closeButton = document.createElement("button");
      closeButton.textContent = 'X';
      closeButton.ariaLabel = translationCallback("close");
      closeButton.style.position = 'absolute';
      closeButton.style.top = '10px';
      closeButton.style.right = '10px';
      closeButton.addEventListener("click", () => {
        dialog.close();
      });
      dialog.appendChild(closeButton);
  
      const heading = translationCallback("kbmg-title");
      const h1 = document.createElement("h1");
      h1.textContent = heading;
      dialog.setAttribute("aria-live", heading);
      dialog.appendChild(h1);
  
      const table = document.createElement("table");
      const tbody = document.createElement("tbody");
      Object.entries(this._keyMap).forEach(([keystroke, details]) => {
        const tr = document.createElement("tr");
        const th = document.createElement("th");
        th.scope = 'row';
        th.textContent = details.title;
        tr.appendChild(th);
  
        const td1 = document.createElement("td");
        td1.textContent = details.keyDescription ?? keystroke;
        tr.appendChild(td1);
  
        const td2 = document.createElement("td");
        td2.textContent = details.description;
        tr.appendChild(td2);
  
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
  
      dialog.appendChild(table);
      return dialog;
    }*/
  /**
   * Launch help dialog
   * @param lang Language of the dialog - used in attribute, and for i18n
   * @param translationCallback - get language-specific verbiage
   */
  /*launchHelpDialog(
    lang: string,
    translationCallback: (
      code: string,
      evaluators?: translateEvaluators
    ) => string
  ) {
    if (this._dialog === null) {
      this._dialog = this.generateHelpDialog(lang, translationCallback);
      document.body.appendChild(this._dialog);
    }
    this._dialog.showModal();
    this._dialog.focus();
  }*/
}
var X8e = Object.defineProperty, Rr = (t, e, r, n) => {
  for (var i = void 0, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(e, r, i) || i);
  return i && X8e(e, r, i), i;
};
Hse();
function on(t) {
  const [e, r] = t.split("-");
  return {
    seriesKey: e,
    index: parseInt(r)
  };
}
class Cr extends Ay {
  constructor(e, r, n, i, s) {
    super(), this.paraChart = e, this.symbols = new XU(), this.dataState = "initial", this.darkMode = !1, this.announcement = { text: "", html: "", highlights: [], startFrom: 0 }, this.annotations = [], this.popups = [], this.sparkBrailleInfo = null, this.seriesAnalyses = {}, this.frontSeries = "", this._lowlightSeries = [], this._hiddenSeriesList = [], this.data = null, this.focused = "chart", this.selected = null, this.queryLevel = "default", this._visitedDatapoints = /* @__PURE__ */ new Set(), this._prevVisitedDatapoints = /* @__PURE__ */ new Set(), this._everVisitedDatapoints = /* @__PURE__ */ new Set(), this._highlightedSelector = "", this._selectedDatapoints = /* @__PURE__ */ new Set(), this._prevSelectedDatapoints = /* @__PURE__ */ new Set(), this._rangeHighlights = [], this._modelLineBreaks = [], this._userLineBreaks = [], this._modelTrendLines = [], this._userTrendLines = [], this._settingControls = new YU(this), this._settingObservers = {}, this._manifest = null, this._jimerator = null, this._model = null, this._facets = null, this._type = "line", this._title = "", this._seriesProperties = null, this._keymapManager = new J8e(eV), this.annotID = 0, this.log = qt("ParaStore"), this.idList = {};
    const o = vr.hydrateInput(r);
    vr.suppleteSettings(o, n ?? n8e), this.settings = o, this.subscribe((a, l) => this._propertyChanged(a, l)), this._colors = new ZU(this), this._seriesAnalyzerConstructor = i, this._pairAnalyzerConstructor = s, this._getUrlAnnotations();
  }
  get settingControls() {
    return this._settingControls;
  }
  get type() {
    return this._type;
  }
  get model() {
    return this._model;
  }
  get title() {
    return this._title;
  }
  get jimerator() {
    return this._jimerator;
  }
  get seriesProperties() {
    return this._seriesProperties;
  }
  get colors() {
    return this._colors;
  }
  get keymapManager() {
    return this._keymapManager;
  }
  get rangeHighlights() {
    return this._rangeHighlights;
  }
  get modelLineBreaks() {
    return this._modelLineBreaks;
  }
  get userLineBreaks() {
    return this._userLineBreaks;
  }
  get modelTrendLines() {
    return this._modelTrendLines;
  }
  get userTrendLines() {
    return this._userTrendLines;
  }
  get hiddenSeriesList() {
    return this._hiddenSeriesList;
  }
  setManifest(e, r) {
    this._manifest = e;
    const n = this._manifest.datasets[0];
    if (aR[n.type] && Object.entries(aR[n.type]).forEach(([i, s]) => this.updateSettings((o) => {
      vr.set(i, s, o);
    })), n.settings && (Object.entries(n.settings).forEach(([i, s]) => this.updateSettings((o) => {
      vr.set(i, s, o);
    })), this.settings.color.colorMap && this._colors.setColorMap(...this.settings.color.colorMap.split(",").map((i) => i.trim()))), this._jimerator = new oye(this._manifest, r), this._jimerator.render(), this._type = n.type, this._title = n.title, this._facets = Cg(n), n.data.source === "inline")
      t_(n.type) ? this._model = tie(e) : this._model = nie(
        e,
        this._seriesAnalyzerConstructor,
        this._pairAnalyzerConstructor
      ), this._seriesProperties = new lR(this), this.data = Ape(e);
    else if (r)
      t_(n.type) ? this._model = rie(r, e) : this._model = iie(
        r,
        e,
        this._seriesAnalyzerConstructor,
        this._pairAnalyzerConstructor
      ), this._seriesProperties = new lR(this), this.data = r;
    else
      throw new Error("store lacks external or inline chart data");
    this._model instanceof _c && this._model.seriesKeys.forEach(async (i) => {
      this.seriesAnalyses = {
        [i]: await this._model.getSeriesAnalysis(i),
        ...this.seriesAnalyses
      };
    });
  }
  _propertyChanged(e, r) {
  }
  updateSettings(e, r = !1) {
    var a;
    const [n, i, s] = Wse(this.settings, e);
    if (this.settings = n, r)
      return;
    const o = {};
    for (const l of i) {
      if (l.op !== "replace") {
        this.log.error(`unexpected patch op '${l.op}' (${l.path})`);
        continue;
      }
      o[l.path.join(".")] = { newValue: l.value };
    }
    for (const l of s) {
      if (l.op !== "replace") {
        this.log.error(`unexpected patch op '${l.op}' (${l.path})`);
        continue;
      }
      o[l.path.join(".")].oldValue = l.value;
    }
    for (const [l, c] of Object.entries(o))
      (a = this._settingObservers[l]) == null || a.forEach(
        (p) => p(c.oldValue, c.newValue)
      ), this.paraChart.settingDidChange(l, c.oldValue, c.newValue);
  }
  observeSetting(e, r) {
    if (this._settingObservers[e] || (this._settingObservers[e] = []), this._settingObservers[e].includes(r))
      throw new Error(`observer already registered for setting '${e}'`);
    this._settingObservers[e].push(r);
  }
  observeSettings(e, r) {
    for (let n of e)
      this.observeSetting(n, r);
  }
  unobserveSetting(e, r) {
    if (!this._settingObservers[e])
      throw new Error(`no observers for setting '${e}'`);
    const n = this._settingObservers[e].indexOf(r);
    if (n === -1)
      throw new Error(`observer not registered for setting '${e}'`);
    this._settingObservers[e].splice(n, 1), this._settingObservers[e].length === 0 && delete this._settingObservers[e];
  }
  lowlightSeries(e) {
    this._lowlightSeries.includes(e) || (this._lowlightSeries = [...this._lowlightSeries, e]);
  }
  clearSeriesLowlight(e) {
    this._lowlightSeries.includes(e) && (this._lowlightSeries = this._lowlightSeries.filter((r) => r !== e));
  }
  isSeriesLowlighted(e) {
    return this._lowlightSeries.includes(e);
  }
  lowlightOtherSeries(...e) {
    this._lowlightSeries = this._model.seriesKeys.filter((r) => !e.includes(r));
  }
  clearAllSeriesLowlights() {
    this._lowlightSeries = [];
  }
  announce(e, r = !1, n = 0) {
    let i = "", s = "";
    const o = `\r
`;
    let a = [];
    typeof e == "string" ? (i = e, s = e) : Array.isArray(e) ? (i = this._joinStrArray(e, o), s = i) : (i = e.text, s = e.html, a = e.highlights ?? []), this.settings.ui.isAnnouncementEnabled && (this.announcement = { text: i, html: s, highlights: a, clear: r, startFrom: n }, this.log.info("ANNOUNCE:", this.announcement.text));
  }
  _joinStrArray(e, r) {
    if (e = e.filter((n) => /\S/.test(n)), e.length) {
      const n = e.length - 1;
      return e.reduce((i, s, o) => {
        const a = o === n ? "." : "", l = i ? ` ${r}` : "";
        return `${i.match(/[.,?:;]$/) ? i : `${i}.`} ${l}${s}${a}`;
      });
    }
    return "";
  }
  hide(e) {
    this._hiddenSeriesList.includes(e) || (this._hiddenSeriesList = [...this._hiddenSeriesList, e]);
  }
  get visitedDatapoints() {
    return this._visitedDatapoints;
  }
  get prevVisitedDatapoints() {
    return this._prevVisitedDatapoints;
  }
  get everVisitedDatapoints() {
    return this._everVisitedDatapoints;
  }
  visit(e) {
    this._prevVisitedDatapoints = this._visitedDatapoints, this._visitedDatapoints = /* @__PURE__ */ new Set(), e.forEach((r) => {
      this._visitedDatapoints.add(`${r.seriesKey}-${r.datapointIndex}`);
    });
    for (const r of e)
      this._everVisitedDatapoints.add(`${r.seriesKey}-${r.datapointIndex}`);
    this.settings.controlPanel.isMDRAnnotationsVisible && (this.removeMDRAnnotations(this._prevVisitedDatapoints), this.showMDRAnnotations()), this.paraChart.paraView.requestUpdate();
  }
  _datapointSetHas(e, r, n) {
    return n.has(`${e}-${r}`);
  }
  isVisited(e, r) {
    return this._datapointSetHas(e, r, this._visitedDatapoints);
  }
  isVisitedSeries(e) {
    return this._visitedDatapoints.values().some((r) => r.startsWith(e));
  }
  wasVisited(e, r) {
    return this._datapointSetHas(e, r, this._prevVisitedDatapoints);
  }
  wasVisitedSeries(e) {
    return this._prevVisitedDatapoints.values().some((r) => r.startsWith(e));
  }
  everVisited(e, r) {
    return this._datapointSetHas(e, r, this._everVisitedDatapoints);
  }
  everVisitedSeries(e) {
    return this._everVisitedDatapoints.values().some((r) => r.startsWith(e));
  }
  clearVisited() {
    this._prevVisitedDatapoints = this._visitedDatapoints, this._visitedDatapoints = /* @__PURE__ */ new Set();
  }
  get highlightedSelector() {
    return this._highlightedSelector;
  }
  highlight(e) {
    this._highlightedSelector = e;
  }
  clearHighlight() {
    this.popups.splice(0, this.popups.length), this._highlightedSelector = "";
  }
  get selectedDatapoints() {
    return this._selectedDatapoints;
  }
  get prevSelectedDatapoints() {
    return this._prevSelectedDatapoints;
  }
  select() {
    let e = /* @__PURE__ */ new Set();
    if (this._visitedDatapoints.size === 1) {
      const r = [...this._visitedDatapoints.values()][0], { seriesKey: n, index: i } = on(r);
      (!this.isSelected(n, i) || this._selectedDatapoints.size > 1) && e.add(r);
    } else
      for (const r of this._visitedDatapoints) {
        const { seriesKey: n, index: i } = on(r);
        this.isSelected(n, i) || e.add(r);
      }
    this._prevSelectedDatapoints = this._selectedDatapoints, this._selectedDatapoints = e;
  }
  extendSelection() {
    const e = new Set(this._selectedDatapoints);
    for (const r of this._visitedDatapoints) {
      const { seriesKey: n, index: i } = on(r);
      this.isSelected(n, i) ? e.delete(r) : e.add(r);
    }
    this._prevSelectedDatapoints = this._selectedDatapoints, this._selectedDatapoints = e;
  }
  isSelected(e, r) {
    return this._datapointSetHas(e, r, this._selectedDatapoints);
  }
  isSelectedSeries(e) {
    return this._selectedDatapoints.values().some((r) => r.startsWith(e));
  }
  wasSelected(e, r) {
    return this._datapointSetHas(e, r, this._prevSelectedDatapoints);
  }
  wasSelectedSeries(e) {
    return this._prevSelectedDatapoints.values().some((r) => r.startsWith(e));
  }
  clearSelected() {
    this._prevSelectedDatapoints = this._selectedDatapoints, this._selectedDatapoints = /* @__PURE__ */ new Set();
  }
  getFormatType(e) {
    return e === "domId" ? "domId" : vr.get(YSe[e], this.settings);
  }
  addAnnotation() {
    const e = [];
    this._visitedDatapoints.forEach((r) => {
      const { seriesKey: n, index: i } = on(r), s = Zf(
        this._model.atKeyAndIndex(n, i),
        "raw"
      ), o = prompt("Annotation:");
      o && (e.push({
        type: "datapoint",
        seriesKey: n,
        index: i,
        annotation: `${n}, ${s}: ${o}`,
        text: o,
        id: `${n}-${s}-${this.annotID}`
      }), this.annotID += 1);
    }), this.annotations = [...this.annotations, ...e];
  }
  annotatePoint(e, r, n) {
    if (this.annotations.find((s) => s.seriesKey === e && s.index === r && s.text === n))
      return;
    const i = Zf(
      this._model.atKeyAndIndex(e, r),
      "raw"
    );
    this.annotations = [...this.annotations, {
      type: "datapoint",
      seriesKey: e,
      index: r,
      annotation: `${e}, ${i}: ${n}`,
      text: n,
      id: `${e}-${i}-${this.annotID}`
    }], this.annotID++;
  }
  async showMDRAnnotations() {
    if (this.type === "line")
      if (this.settings.controlPanel.isMDRAnnotationsVisible) {
        let e, r;
        if (this.visitedDatapoints.size > 0 ? (r = on(this.visitedDatapoints.keys().toArray()[0]).seriesKey, e = this.model ? await this.model.getSeriesAnalysis(r) : void 0) : (r = this.model.series[0][0].seriesKey, e = this.model ? await this.model.getSeriesAnalysis(r) : void 0), !e) {
          this.log.info("This chart does not support AI trend annotations"), this.updateSettings((o) => {
            o.controlPanel.isMDRAnnotationsVisible = !this.settings.controlPanel.isMDRAnnotationsVisible;
          });
          return;
        }
        const n = this.model.series[0].length - 1;
        let i = e == null ? void 0 : e.messageSeqs.map((o) => e.sequences[o]);
        for (let o of i)
          this.highlightRange(o.start / n, (o.end - 1) / n);
        this.addModelLineBreaks(e.sequences, r), this.addModelTrendLines(e.sequences, r);
        let s = `Detected trend: ${e == null ? void 0 : e.message}, consisting of ${e == null ? void 0 : e.messageSeqs.length} datapoint sequences from`;
        for (let o of i)
          s += ` ${this.model.allPoints[o.start].facetValueNumericized("x")} to ${this.model.allPoints[o.end - 1].facetValueNumericized("x")} (${o.message}),`;
        if (this.annotations.some((o) => o.id == "trend-analysis-annotation")) {
          const o = this.annotations.findIndex((a) => a.id == "trend-analysis-annotation");
          this.annotations.splice(o, 1);
        }
        this.annotations.push({
          type: "trend",
          annotation: s,
          id: "trend-analysis-annotation"
        });
      } else
        this.removeMDRAnnotations();
    else
      this.log.info("Trend annotations not currently supported for this chart type"), this.updateSettings((e) => {
        e.controlPanel.isMDRAnnotationsVisible = !this.settings.controlPanel.isMDRAnnotationsVisible;
      });
  }
  async removeMDRAnnotations(e) {
    let r = null, n = null;
    e || (e = this.visitedDatapoints), this.type !== "line" || (e.size > 0 ? (n = on(this.visitedDatapoints.keys().toArray()[0]).seriesKey, r = this.model ? await this.model.getSeriesAnalysis(n) : null) : (n = this.model.series[0][0].seriesKey, r = this.model ? await this.model.getSeriesAnalysis(n) : null));
    const i = this.model.series[0].length - 1;
    let s = r == null ? void 0 : r.messageSeqs.map((o) => r.sequences[o]);
    for (let o of s)
      this.unhighlightRange(o.start / i, (o.end - 1) / i);
    if (n !== null && (this.removeModelLineBreaks(r.sequences, n), this.removeModelTrendLines(r.sequences, n)), this.annotations.some((o) => o.id == "trend-analysis-annotation")) {
      const o = this.annotations.findIndex((a) => a.id == "trend-analysis-annotation");
      this.annotations.splice(o, 1);
    }
  }
  _getUrlAnnotations() {
    const e = (s) => s.replace(/(\r\n|\n|\r)/gm, "").replace(/\s+/g, " ").trim();
    let n = window.location.search;
    if (n) {
      var i = new URLSearchParams(n);
      let s = i.get("text");
      i.get("note"), s && (s = e(s));
    }
  }
  highlightRange(e, r) {
    if (this._rangeHighlights.find((n) => n.startPortion === e && n.endPortion === r))
      throw new Error("range already highlighted");
    this._rangeHighlights = [...this._rangeHighlights, { startPortion: e, endPortion: r }];
  }
  unhighlightRange(e, r) {
    const n = this._rangeHighlights.findIndex((i) => i.startPortion === e && i.endPortion === r);
    if (n === -1)
      throw new Error("range not highlighted");
    this._rangeHighlights = this._rangeHighlights.toSpliced(n, 1);
  }
  getModelCsv() {
    const e = this._model.getFacet(this.model.independentFacetKeys[0]).label;
    return RN.unparse(this.model.series[0].datapoints.map((r, n) => ({
      [e]: Zf(r, "raw"),
      ...Object.fromEntries(this.model.series.map((i) => [i.key, bS(i[n], "value")]))
    })));
  }
  addModelLineBreaks(e, r) {
    const i = this.model.series.filter((s) => s[0].seriesKey == r)[0].length - 1;
    for (let s of e)
      this.addLineBreak(s.start / i, s.start, r, !0);
    this.addLineBreak((e[e.length - 1].end - 1) / i, e[e.length - 1].end - 1, r, !0);
  }
  removeModelLineBreaks(e, r) {
    const i = this.model.series.filter((o) => o[0].seriesKey == r)[0].length - 1;
    for (let o of e) {
      const a = this._modelLineBreaks.findIndex((l) => l.startPortion === o.start / i);
      a === -1 || (this._modelLineBreaks = this._modelLineBreaks.toSpliced(a, 1));
    }
    const s = this._modelLineBreaks.findIndex((o) => o.startPortion === (e[e.length - 1].end - 1) / i);
    s === -1 || (this._modelLineBreaks = this._modelLineBreaks.toSpliced(s, 1));
  }
  addLineBreak(e, r, n, i) {
    i ? this._modelLineBreaks.find((s) => s.startPortion === e) || (this._modelLineBreaks = [...this._modelLineBreaks, { startPortion: e, seriesKey: n, index: r }]) : this._userLineBreaks.find((s) => s.startPortion === e && s.seriesKey === n) || this._userLineBreaks.push({ startPortion: e, seriesKey: n, index: r });
  }
  addUserLineBreaks() {
    for (const e of this.selectedDatapoints) {
      const { seriesKey: r, index: n } = on(e), i = this.model.series.filter((o) => o[0].seriesKey === r)[0], s = i.length - 1;
      this.addLineBreak(n / s, n, r, !1), this.annotations.push({
        type: "lineBreak",
        seriesKey: r,
        index: n,
        annotation: `${i.key}, ${i.rawData[n].x}: Added line break`,
        id: `line-break-${n}`
      }), this.paraChart.postNotice("addLineBreak", { seriesKey: r, index: n });
    }
    if (this.userLineBreaks.length) {
      this.clearUserTrendLines();
      for (let e of new Set(this.userLineBreaks.map((r) => r.seriesKey))) {
        let r = this.userLineBreaks.filter((s) => s.seriesKey === e).sort((s, o) => s.index - o.index);
        this.addTrendLine(0, r[0].startPortion, 0, r[0].index + 1, e, !1);
        for (let s = 0; s < r.length - 1; s++)
          this.addTrendLine(r[s].startPortion, r[s + 1].startPortion, r[s].index, r[s + 1].index + 1, e, !1);
        const i = this.model.series.filter((s) => s[0].seriesKey == e)[0].length - 1;
        this.addTrendLine(r[r.length - 1].startPortion, 1, r[r.length - 1].index, i + 1, e, !1);
      }
    }
  }
  addModelTrendLines(e, r) {
    const i = this.model.series.filter((s) => s[0].seriesKey == r)[0].length - 1;
    for (let s of e)
      this.addTrendLine(s.start / i, (s.end - 1) / i, s.start, s.end, r, !0);
  }
  addTrendLine(e, r, n, i, s, o) {
    o ? this._modelTrendLines.find((a) => a.startPortion === e && a.endPortion === r) || (this._modelTrendLines = [...this._modelTrendLines, { startPortion: e, endPortion: r, startIndex: n, endIndex: i, seriesKey: s }]) : this._userTrendLines.find((a) => a.startPortion === e && a.endPortion === r && a.seriesKey === s) || (this._userTrendLines = [...this._userTrendLines, { startPortion: e, endPortion: r, startIndex: n, endIndex: i, seriesKey: s }]);
  }
  removeModelTrendLines(e, r) {
    const i = this.model.series.filter((s) => s[0].seriesKey == r)[0].length - 1;
    for (let s of e) {
      const o = this._modelTrendLines.findIndex((a) => a.startPortion === s.start / i && a.endPortion === (s.end - 1) / i);
      o === -1 || (this._modelTrendLines = this._modelTrendLines.toSpliced(o, 1));
    }
  }
  clearUserLineBreaks() {
    this._userLineBreaks = [], this.annotations = this.annotations.filter((e) => !/line-break/.test(e.id)), this.paraChart.postNotice("clearLineBreaks", null);
  }
  clearUserTrendLines() {
    this._userTrendLines = [];
  }
}
Rr([
  Ar()
], Cr.prototype, "dataState");
Rr([
  Ar()
], Cr.prototype, "settings");
Rr([
  Ar()
], Cr.prototype, "darkMode");
Rr([
  Ar()
], Cr.prototype, "announcement");
Rr([
  Ar()
], Cr.prototype, "annotations");
Rr([
  Ar()
], Cr.prototype, "popups");
Rr([
  Ar()
], Cr.prototype, "sparkBrailleInfo");
Rr([
  Ar()
], Cr.prototype, "seriesAnalyses");
Rr([
  Ar()
], Cr.prototype, "frontSeries");
Rr([
  Ar()
], Cr.prototype, "_lowlightSeries");
Rr([
  Ar()
], Cr.prototype, "_hiddenSeriesList");
Rr([
  Ar()
], Cr.prototype, "data");
Rr([
  Ar()
], Cr.prototype, "focused");
Rr([
  Ar()
], Cr.prototype, "selected");
Rr([
  Ar()
], Cr.prototype, "queryLevel");
Rr([
  Ar()
], Cr.prototype, "_highlightedSelector");
Rr([
  Ar()
], Cr.prototype, "_selectedDatapoints");
Rr([
  Ar()
], Cr.prototype, "_prevSelectedDatapoints");
Rr([
  Ar()
], Cr.prototype, "_rangeHighlights");
Rr([
  Ar()
], Cr.prototype, "_modelLineBreaks");
Rr([
  Ar()
], Cr.prototype, "_userLineBreaks");
Rr([
  Ar()
], Cr.prototype, "_modelTrendLines");
Rr([
  Ar()
], Cr.prototype, "_userTrendLines");
var eAe = Object.defineProperty, tAe = Object.getOwnPropertyDescriptor, kk = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? tAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && eAe(e, r, i), i;
};
const Uk = class Uk extends ts {
  constructor() {
    super(...arguments), this.log = qt("SettingControl"), this.hidden = !1;
  }
  set value(e) {
    this._value = e;
  }
  get value() {
    return this._value;
  }
  _updateSetting(e, r) {
    this._store.updateSettings((n) => vr.set(e, r, n));
  }
  _validateInput(e, r) {
    if (this.info.validator) {
      const n = this.info.validator(e);
      if (n.err)
        return r.dispatchEvent(
          new CustomEvent(
            "invalidvalue",
            { bubbles: !0, composed: !0, detail: n.err }
          )
        ), !1;
    }
    return !0;
  }
  render() {
    return We`
      <div
        class="setting"
      >
        ${this.content()}
      </div>
    `;
  }
};
Uk.styles = [
  //styles,
  Nt`
    `
];
let Ks = Uk;
kk([
  Ur()
], Ks.prototype, "label", 2);
kk([
  Ur()
], Ks.prototype, "value", 1);
kk([
  Ke({ type: Boolean })
], Ks.prototype, "hidden", 2);
var rAe = Object.getOwnPropertyDescriptor, nAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? rAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let cR = class extends Ks {
  content() {
    const t = this.info.options;
    return We`
      <label>
        ${this.label}
        <input 
          type=${(t == null ? void 0 : t.inputType) ?? "text"}
          .value=${this._value} 
          min=${(t == null ? void 0 : t.inputType) === "number" ? t.min : Ne}
          max=${(t == null ? void 0 : t.inputType) === "number" ? t.max : Ne}
          size=${(t == null ? void 0 : t.size) ?? "8"}
          @change=${(e) => {
      const r = e.target, n = (t == null ? void 0 : t.inputType) === "number" ? parseFloat(r.value) : r.value;
      this._validateInput(n, r) ? (this._value = n, this._updateSetting(this.info.key, n)) : r.value = this._value.toString();
    }}
        />
      </label>
    `;
  }
};
cR = nAe([
  Dt("para-textfield-setting-control")
], cR);
var iAe = Object.getOwnPropertyDescriptor, sAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? iAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let uR = class extends Ks {
  connectedCallback() {
    super.connectedCallback(), this.values = this.info.options.values ?? this.info.options.options;
  }
  content() {
    return We`
      <fizz-dropdown 
        label=${this.label} 
        .options=${this.info.options.options}
        selected=${this.values.indexOf(this._value)}
        @select=${(t) => {
      const e = t.target.selectedIndex;
      this._updateSetting(this.info.key, this.values[e]);
    }}
      ></fizz-dropdown>
    `;
  }
};
uR = sAe([
  Dt("para-dropdown-setting-control")
], uR);
var oAe = Object.getOwnPropertyDescriptor, aAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? oAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let hR = class extends Ks {
  content() {
    return We`
      <label>
        <input 
          type="checkbox"
          .checked=${!!this._value}
          @change=${(t) => {
      this._updateSetting(
        this.info.key,
        t.target.checked
      );
    }}
        >
          ${this.label} 
      </label>
    `;
  }
};
hR = aAe([
  Dt("para-checkbox-setting-control")
], hR);
var lAe = Object.getOwnPropertyDescriptor, cAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? lAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let pR = class extends Ks {
  content() {
    const t = this.info.options;
    return We`
      <fizz-radiogroup
        .buttons=${t.buttons}
        selected=${this._value}
        layout=${t.layout ?? Ne}
        ?wrap=${t.wrap}
        @select=${(e) => this._updateSetting(
      this.info.key,
      e.detail
    )}
      >
        <span slot="legend">${this.label}</span>
      </fizz-radiogroup>
    `;
  }
};
pR = cAe([
  Dt("para-radio-setting-control")
], pR);
var uAe = Object.getOwnPropertyDescriptor, hAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? uAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let dR = class extends Ks {
  content() {
    const t = this.info.options, e = Et(), r = t != null && t.width ? {
      "--width": t.width
    } : {};
    return We`
      <fizz-slider
        ${yt(e)}
        style=${mn(r)}
        label=${this.label}
        key=${Yn(this.info.key)}
        value=${this._value}
        min=${(t == null ? void 0 : t.min) ?? Ne}
        max=${(t == null ? void 0 : t.max) ?? Ne}
        step=${(t == null ? void 0 : t.step) ?? Ne}
        lowbound=${(t == null ? void 0 : t.lowBound) ?? Ne}
        highbound=${(t == null ? void 0 : t.highBound) ?? Ne}
        ?percent=${t == null ? void 0 : t.percent}
        ?showvalue=${t == null ? void 0 : t.showValue}
        ?compact=${t == null ? void 0 : t.compact}
        @update=${(n) => this._updateSetting(
      this.info.key,
      n.detail
    )}
      ></fizz-slider>
    `;
  }
};
dR = hAe([
  Dt("para-slider-setting-control")
], dR);
var pAe = Object.getOwnPropertyDescriptor, dAe = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? pAe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let fR = class extends Ks {
  content() {
    return We`
      <label>
        <button
          type="button"
          @click=${(t) => {
      this._value = !this._value, this._updateSetting(this.info.key, this._value);
    }}
        >
          ${this.label}
        </button> 
      </label>
    `;
  }
};
fR = dAe([
  Dt("para-button-setting-control")
], fR);
class fAe {
  constructor(e) {
    this._store = e, this.log = qt("ParaViewController");
  }
  handleKeyEvent(e) {
    if (this._store.settings.chart.isStatic)
      return;
    let r = e.key === "Control" ? "Ctrl" : e.key.toLocaleLowerCase(), n = [
      e.altKey ? "Alt" : "",
      e.ctrlKey ? "Ctrl" : "",
      e.shiftKey ? "Shift" : "",
      e.metaKey ? "Meta" : ""
    ].filter((s) => s);
    n.includes(r) && (r = "");
    const i = (r ? [...n, r] : n).join("+");
    this._store.keymapManager.onKeydown(i) && (e.stopPropagation(), e.preventDefault());
  }
}
class gAe {
  constructor(e) {
    this._paraView = e, this.log = qt("PointerEventManager"), this._touchArray = [], this._currentTarget = null, this._selectedElement = null, this._selectedElements = [], this._highlightBoxes = /* @__PURE__ */ new WeakMap(), this._coords = null, this._dataRoot = null, this._dataRect = null;
  }
  get coords() {
    return this._coords;
  }
  /**
   * Records pointer event info.
   * @param event - The event on the element.
   */
  _registerPointerEvent(e) {
    return {
      id: e.pointerId,
      target: e.target,
      x: e.clientX,
      y: e.clientY,
      offsetX: e.offsetX,
      offsetY: e.offsetY
    };
  }
  /**
   * Starts pointer events.
   * @param event - The event on the element.
   */
  handleStart(e) {
    const r = this._registerPointerEvent(e);
    this._touchArray.push(r);
  }
  /**
   * Ends pointer events.
   * @param event - The event on the element.
   */
  handleEnd(e) {
    this.handleCancel(e);
  }
  /**
   * Cancels pointer events.
   * @param event - The event on the element.
   */
  handleCancel(e) {
    const r = e.pointerId, n = this._touchArray.findIndex((i) => i.id === r);
    n >= 0 && this._touchArray.splice(n, 1);
  }
  /**
   * Reads element labels and default settings, and triggers speech.
   * @param event - The event on the element.
   */
  handleMove(e) {
    const r = e.target;
    if (r.releasePointerCapture(e.pointerId), this._coords = this._localCoords(e), r === this._paraView.root || r === this._dataRoot)
      this._currentTarget = null;
    else if (r !== this._currentTarget) {
      if (r !== this._currentTarget) {
        this._currentTarget = r, this._selectedElements.includes(r);
        const n = e.pointerId, i = this._touchArray.findIndex((s) => s.id === n);
        if (i >= 0) {
          this._touchArray[i];
          const s = this._registerPointerEvent(e);
          this._touchArray[i] = s;
        }
      }
    }
  }
  /**
   * .
   * @param event - The event on the element.
   */
  _updateTouchArray(e) {
    const r = e.pointerId, n = this._touchArray.findIndex((i) => i.id === r);
    if (n >= 0) {
      this._touchArray[n];
      const i = this._registerPointerEvent(e);
      this._touchArray[n] = i, this._coords = this._localCoords(e);
    }
  }
  /**
   * Reads element labels and default settings, and triggers speech.
   * @param event - The event on the element.
   */
  handleClick(e) {
    const r = e.target;
    e.detail < 2 && (r === this._paraView.frame || r === this._dataRect ? this.log.info("clicked backdrop!") : this._selectElement(r, e.shiftKey));
  }
  /**
   * Double click handler.
   * @param event - The event on the element.
   */
  handleDoubleClick(e) {
    const r = e.target;
    e.preventDefault(), r === this._paraView.root || this._dataRoot;
  }
  /**
   * Set selected element and add a highlight box.
   * @param target - The element to be selected; deselects if absent or `null`.
   */
  async _selectElement(e, r) {
    if (!e)
      this._clearSelectedElements();
    else {
      r || this._clearSelectedElements();
      const n = e.closest('[role="datapoint"]');
      if (n) {
        const i = n.id.endsWith("-sym") || n.id.endsWith("-rlb") || n.id.endsWith("-blb") || n.id.endsWith("-ilb") ? n.id.slice(0, -4) : n.id, s = this._paraView.documentView.chartLayers.dataLayer.datapointViewForId(i), o = this._paraView.documentView.chartInfo;
        o.navMap.goTo(o.navDatapointType, {
          seriesKey: s.seriesKey,
          index: s.index
        }), this._paraView.documentView.chartInfo.selectCurrent(!!r), this._selectedElement = e, this._selectedElements.push(e);
      } else
        this.log.info("not a datapoint!");
    }
  }
  // /**
  //  * Set selected element and add a highlight box.
  //  * @param {Element} target The element to be selected; deselects if absent or `null`.
  //  * @private
  //  * @memberOf module:@fizz/touchUI
  //  */
  // _createSelectBox(target: SVGGraphicsElement) {
  //   // this.log.info('_selectElement');
  //   if (target) {
  //     // highlight box
  //     const bbox = target.getBBox();
  //     let x = bbox.x;
  //     let y = bbox.y;
  //     // find any transforms on the element
  //     // TODO: fix this hack
  //     const transforms = (target.parentNode! as SVGGraphicsElement).getAttribute('transform');
  //     if (transforms) {
  //       // highlightBox.setAttribute('transform', transforms );
  //       // x += transforms.e;
  //       // y += transforms.f;
  //       let translate = transforms.split('translate(')[1].split(')')[0].split(',');
  //       x += parseFloat(translate[0]);
  //       y += parseFloat(translate[1]);
  //       // const transformMatrix = target.transform.baseVal.consolidate().matrix;
  //       // this.log.info('target.transform.baseVal.consolidate()', target.transform.baseVal.consolidate());
  //     }
  //     const highlightBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  //     highlightBox.classList.add('_highlight_box');
  //     highlightBox.setAttribute('x', (x - 2.5).toString());
  //     highlightBox.setAttribute('y', (y - 2.5).toString());
  //     highlightBox.setAttribute('width', (bbox.width + 5).toString());
  //     highlightBox.setAttribute('height', (bbox.height + 5).toString());
  //     // this.canvasContainer.firstElementChild.append(highlightBox);
  //     this._highlightBoxes.set(target, highlightBox);
  //   }
  // }
  /**
   * Remove selected element and remove its highlight box.
   * @param target - The element to be selected; deselects if absent or `null`.
   */
  _deselectElement(e) {
  }
  /**
   * Deselect all elements.
   */
  _clearSelectedElements() {
    this._selectedElement = null;
  }
  /**
  * Adjust the coordinates for transforms
  * @param event - The mouse event with the coordinates
  * @returns A coordinate point object with the proper transforms, as a 2-precision float
  */
  _localCoords(e) {
    var n, i;
    let r = {
      x: 0,
      y: 0
    };
    if (e.isTrusted) {
      let s = this._paraView.root.createSVGPoint();
      s.x = e.clientX, s.y = e.clientY, s = s.matrixTransform((i = (n = this._paraView.frame) == null ? void 0 : n.getScreenCTM()) == null ? void 0 : i.inverse()), r = {
        x: +s.x.toFixed(2),
        y: +s.y.toFixed(2)
      };
    }
    return r;
  }
}
const gR = {
  up: "down",
  down: "up",
  left: "right",
  right: "left",
  in: "out",
  out: "in"
};
function mAe(t, e) {
  for (const r in t)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function yAe(t, e) {
  if (!Object.keys(t).length)
    return !0;
  for (const r in t)
    if (t[r] === e[r])
      return !0;
  return !1;
}
class _k {
  constructor(e, r) {
    this._store = e, this._chart = r, this._layers = /* @__PURE__ */ new Map(), this._runTimer = null, this._currentLayer = "root";
    const n = new w2(this, this._currentLayer);
    this._layers.set(this._currentLayer, n);
  }
  get currentLayer() {
    return this._currentLayer;
  }
  set currentLayer(e) {
    this._currentLayer = e;
  }
  get cursor() {
    return this.layer(this._currentLayer).cursor;
  }
  get root() {
    return this._layers.get("root");
  }
  get chartInfo() {
    return this._chart;
  }
  clone() {
    const e = new _k(this._store, this._chart);
    return e._layers = new Map(this._layers.entries().map(([r, n]) => [r, n.clone(e)])), e._currentLayer = this._currentLayer, e;
  }
  layer(e) {
    return this._layers.get(e);
  }
  registerLayer(e) {
    this._layers.has(e.id) || this._layers.set(e.id, e);
  }
  async visitDatapoints() {
    this._store.visit(this.cursor.datapoints), this._runTimer ? clearTimeout(this._runTimer) : await this._chart.navRunDidStart(this.cursor), this._runTimer = setTimeout(() => {
      this._runTimer = null, this._chart.navRunDidEnd(this.cursor);
    }, this._store.settings.ui.navRunTimeoutMs);
  }
  node(e, r) {
    for (const n of this._layers.values()) {
      const i = n.get(e, r);
      if (i)
        return i;
    }
  }
  goTo(e, r) {
    const n = this.node(e, r);
    if (n)
      n.layer.cursor = n, this._currentLayer = n.layer.id, this.visitDatapoints();
    else
      throw new Error("nav node not found");
  }
  datapointsForSelector(e, r) {
    const n = this._layers.get(e);
    if (!n)
      throw new Error(`no such layer '${e}'`);
    const i = r.split(/-/), s = i[0];
    let o;
    if (s === "datapoint")
      o = n.get("datapoint", {
        seriesKey: i[1],
        index: parseInt(i[2])
      });
    else if (s === "sequence")
      o = n.get("sequence", {
        seriesKey: i[1],
        start: parseInt(i[2]),
        end: parseInt(i[3])
      });
    else if (s === "series")
      o = n.get("series", { seriesKey: i[1] });
    else
      return [];
    return o ? o.datapoints : [];
  }
}
const B2 = class B2 {
  constructor(e, r) {
    this._map = e, this._id = r, this._nodes = /* @__PURE__ */ new Map(), this._nodesById = /* @__PURE__ */ new Map(), e.registerLayer(this);
  }
  get map() {
    return this._map;
  }
  get id() {
    return this._id;
  }
  get cursor() {
    return this._nodesById.get(this._cursor);
  }
  set cursor(e) {
    this._cursor = e.id;
  }
  clone(e) {
    const r = new B2(e, this._id);
    return r._nodesById = new Map(this._nodesById.entries().map(([n, i]) => [n, i.clone(r)])), r._nodes = new Map(this._nodes.entries().map(([n, i]) => [n, [...i]])), r._cursor = this._cursor, r;
  }
  registerNode(e) {
    if (e.index !== -1)
      return;
    this._nodesById.set(e.id, e);
    let r = this._nodes.get(e.type);
    r || (r = [], this._nodes.set(e.type, r)), r.push(e.id), e.index = r.length - 1, this._cursor || (this._cursor = e.id);
  }
  /** Get a node from its ID. */
  node(e) {
    return this._nodesById.get(e);
  }
  /** Get a node from its options or index. */
  get(e, r = 0) {
    const n = this._nodes.get(e);
    if (n)
      return this._nodesById.get(typeof r == "number" ? n[r] : n.find((i) => mAe(r, this._nodesById.get(i).options)));
  }
  /** Get all nodes matching partial options. */
  query(e, r = {}) {
    const n = this._nodes.get(e);
    return n ? n.filter((i) => yAe(r, this._nodesById.get(i).options)).map((i) => this._nodesById.get(i)) : [];
  }
  goToNode(e) {
    this._cursor = e.id, this.map.visitDatapoints();
  }
  goTo(e, r) {
    const n = this.get(e, r);
    if (n)
      this.goToNode(n);
    else
      throw new Error(`nav node not found (type='${e}')`);
  }
};
B2.nextId = 0;
let w2 = B2;
const Pp = class Pp {
  constructor(e, r, n, i) {
    this._layer = e, this._type = r, this._options = n, this._store = i, this._links = /* @__PURE__ */ new Map(), this._index = -1, this._id = `:${Pp.nextId++}`, e.registerNode(this);
  }
  // get datapoints(): readonly DatapointCursor[] {
  //   return this._datapoints;
  // }
  get id() {
    return this._id;
  }
  get type() {
    return this._type;
  }
  get options() {
    return this._options;
  }
  get layer() {
    return this._layer;
  }
  get index() {
    return this._index;
  }
  set index(e) {
    this._index = e;
  }
  get datapoints() {
    const e = [];
    if (this.isNodeType("datapoint") || this.isNodeType("scatterpoint"))
      e.push(this._store.model.atKeyAndIndex(this._options.seriesKey, this._options.index));
    else if (this.isNodeType("series")) {
      const r = this._store.model.atKey(this._options.seriesKey).length;
      for (let n = 0; n < r; n++)
        e.push(this._store.model.atKeyAndIndex(this._options.seriesKey, n));
    } else if (this.isNodeType("chord"))
      e.push(...this._layer.map.chartInfo.seriesInNavOrder().map((r) => r.datapoints[this._options.index]));
    else if (this.isNodeType("sequence"))
      for (let r = this._options.start; r < this._options.end; r++)
        e.push(this._store.model.atKeyAndIndex(this._options.seriesKey, r));
    else this.isNodeType("cluster") && e.push(...this._store.model.atKey(this._options.seriesKey).datapoints.filter((r) => this._options.datapoints.includes(r.datapointIndex)));
    return e;
  }
  clone(e) {
    const r = new Pp(e, this._type, this._options, this._store);
    return r._links = new Map(this._links), r._index = this._index, r._id = this._id, r;
  }
  getLink(e) {
    return this._links.get(e);
  }
  setLink(e, r) {
    this._links.set(e, r.id);
  }
  removeLink(e) {
    this._links.delete(e);
  }
  connect(e, r, n = !0) {
    this.setLink(e, r), r instanceof Pp && n && r.setLink(gR[e], this);
  }
  disconnect(e, r = !0) {
    const n = this._links.get(e);
    n && (this.removeLink(e), n[0] === ":" && r && this._layer.node(n).removeLink(gR[e]));
  }
  peekNode(e, r) {
    let n = this._id;
    for (; n && r--; ) {
      const i = this._layer.node(n).getLink(e);
      n = i && i[0] !== ":" ? void 0 : i;
    }
    return n ? this._layer.node(n) : void 0;
  }
  allNodes(e, r) {
    let n = 1, i;
    const s = [];
    for (; i = this.peekNode(e, n++), i && (!r || r === i.type); ) {
      if (s.includes(i))
        break;
      s.push(i);
    }
    return s;
  }
  async move(e) {
    const r = this._links.get(e);
    r && (r[0] === ":" ? this.layer.cursor = this._layer.node(r) : this._layer.map.currentLayer = r, this._layer.map.visitDatapoints());
  }
  go() {
    this.layer.goToNode(this);
  }
  isNodeType(e) {
    return this.type === e;
  }
  isDatapointNode() {
    return this.type === "datapoint";
  }
};
Pp.nextId = 0;
let Ia = Pp;
var kn = /* @__PURE__ */ ((t) => (t.Annotation = "annotation", t.Bumper = "bumper", t.Threshold = "threshold", t.Intersection = "intersection", t.High = "high", t.Low = "low", t.Series = "series", t))(kn || {});
const jf = 130.8128, Bf = 195.9977, tx = jf * 2, U1 = Bf * 2, mR = U1 * 2;
class vAe {
  /**
   * Create a new OscillatorAudioEngine.
   * @param context - the audio context
   */
  constructor(e) {
    this._audioContext = e, this._masterCompressor = e.createDynamicsCompressor(), this._masterCompressor.connect(this._audioContext.destination), this._masterCompressor.threshold.value = -50, this._masterCompressor.knee.value = 40, this._masterCompressor.ratio.value = 12, this._masterCompressor.attack.value = 0, this._masterCompressor.release.value = 0.25, this._masterGain = this._audioContext.createGain(), this._masterGain.gain.value = 0.5, this._masterCompressor.connect(this._masterGain), this._masterGain.connect(this._audioContext.destination);
  }
  get masterGain() {
    return this._masterGain.gain.value;
  }
  /**
   *The overall loudness of the audio engine.
   */
  set masterGain(e) {
    this._masterGain.gain.value = e;
  }
  /**
   * Play a sound to represent a data point.
   * @param frequency - the fundimental frequency
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds, defaults to 0.2
   */
  playDataPoint(e, r, n = 0.2) {
    this._playNote(
      e,
      r,
      n,
      this._masterCompressor
    );
  }
  /**
   * Play an audio notification.
   * @param notificationType - the type of audio notification
   * @param [panning] - where to play the sound (-1 <= 0 <= 1, 0 == center). Default: 0
   * @param [duration] - the duration of the notification in seconds. Default: 0.15
   */
  playNotification(e, r = 0, n = 0.15) {
    switch (e) {
      case kn.Annotation:
        this._playAnnotation(r, n);
        break;
      case kn.Bumper:
        this._playBumper(r, n);
        break;
      case kn.Intersection:
        this._playIntersection(r, n);
        break;
      case kn.High:
        this._playHigh(r, n);
        break;
      case kn.Low:
        this._playLow(r, n);
        break;
      case kn.Series:
        this._playSeriesChange(r, n);
        break;
      case kn.Threshold:
        this._playThreshold(r, n);
        break;
    }
  }
  /**
   * Play a data point, sending the audio to the given destination node.
   * @param frequency - the fundimental frequency
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   * @param destinationNode - the node to receive the audio
   */
  _playNote(e, r, n, i) {
    const s = this._audioContext.currentTime, o = this._audioContext.createOscillator();
    o.frequency.value = e, o.start();
    const {
      carrier: a,
      amp: l,
      modulator: c,
      filter: p,
      adsr: h
    } = bAe(
      this._audioContext,
      e * 0.5,
      e * 3,
      e * 2
    );
    a.type = "triangle", h.gain.setValueCurveAtTime([0.2, 0.1], s, n * 0.75), p.frequency.value = e, p.type = "lowpass";
    const d = this._audioContext.createGain();
    d.gain.setValueCurveAtTime(
      [0.5, 1, 0.5, 0.5, 0.5, 0.1, 1e-4],
      s,
      n
    );
    const v = this._audioContext.createStereoPanner();
    v.pan.value = r, o.connect(d), h.connect(d), d.connect(v), v.connect(i), setTimeout(
      () => {
        v.disconnect(), d.disconnect(), h.disconnect(), o.stop(), o.disconnect(), c.stop(), c.disconnect(), a.stop(), a.disconnect(), l.disconnect(), p.disconnect();
      },
      n * 1e3 * 2
    );
  }
  /**
   * Play a sound that means that an annotation is present.
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playAnnotation(e, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = e;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(jf, 0, r / 4, i), this._playNote(tx, 0, r / 4, i), setTimeout(
      () => {
        this._playNote(Bf, 0, r / 4, i), this._playNote(U1, 0, r / 4, i), this._playNote(mR, 0, r / 4, i);
      },
      r * 1e3 * 0.25
    ), setTimeout(
      () => {
        this._playNote(jf, 0, r / 4, i), this._playNote(tx, 0, r / 4, i);
      },
      r * 1e3 * 0.5
    ), setTimeout(
      () => {
        this._playNote(Bf, 0, r / 4, i), this._playNote(U1, 0, r / 4, i), this._playNote(mR, 0, r / 4, i);
      },
      r * 1e3 * 0.75
    ), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
   * Play a sound that means that an annotation is present.
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playBumper(e, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = e;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(jf, 0, r / 4, i), this._playNote(tx, 0, r / 4, i), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
   * Play a sound that means that an annotation is present.
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playSeriesChange(e, r) {
  }
  /**
   * Play a sound to indicate this is the series or chart low
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playLow(e, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = e;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(Bf, 0, r / 4, i), setTimeout(
      () => {
        this._playNote(jf, 0, r / 4, i);
      },
      r * 1e3 * 0.5
    ), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
   * Play a sound to indicate this is the series or chart high
   * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
   * @param duration - the duration of the note in seconds
   */
  _playHigh(e, r) {
    const n = this._audioContext.createStereoPanner();
    n.pan.value = e;
    const i = this._audioContext.createGain();
    i.gain.value = 0.5, i.connect(n), n.connect(this._masterCompressor), this._playNote(Bf, 0, r / 4, i), setTimeout(
      () => {
        this._playNote(U1, 0, r / 4, i);
      },
      r * 1e3 * 0.5
    ), setTimeout(
      () => {
        i.disconnect();
      },
      r * 1e3 * 2
    );
  }
  /**
  * Play a sound to indicate that this section contains an intersection
  * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
  * @param duration - the duration of the note in seconds
  */
  _playIntersection(e, r) {
  }
  /**
  * Play a sound to indicate that this section intersects a threshold line or point
  * @param panning - where to play the sound (-1 <= 0 <= 1, 0 == center)
  * @param duration - the duration of the note in seconds
  */
  _playThreshold(e, r) {
  }
}
function bAe(t, e, r, n) {
  const i = t.createOscillator(), s = t.createGain(), o = t.createOscillator(), a = t.createBiquadFilter(), l = t.createGain();
  return i.frequency.value = e, o.frequency.value = r, s.gain.value = n, o.connect(s), s.connect(i.frequency), i.connect(a), a.connect(l), i.start(), o.start(), { carrier: i, amp: s, modulator: o, filter: a, adsr: l };
}
const wAe = [
  16.3516,
  17.32391,
  18.35405,
  19.44544,
  20.60172,
  21.82676,
  23.12465,
  24.49971,
  25.95654,
  27.5,
  29.13524,
  30.86771,
  // octave 0
  32.7032,
  34.64783,
  36.7081,
  38.89087,
  41.20344,
  43.65353,
  46.2493,
  48.99943,
  51.91309,
  55,
  58.27047,
  61.73541,
  // octave 1
  65.40639,
  69.29566,
  73.41619,
  77.78175,
  82.40689,
  87.30706,
  92.49861,
  97.99886,
  103.8262,
  110,
  116.5409,
  123.4708,
  // octave 2
  130.8128,
  138.5913,
  146.8324,
  155.5635,
  164.8138,
  174.6141,
  184.9972,
  195.9977,
  207.6523,
  220,
  233.0819,
  246.9417,
  // octave 3
  261.6256,
  277.1826,
  293.6648,
  311.127,
  329.6276,
  349.2282,
  369.9944,
  391.9954,
  415.3047,
  440,
  466.1638,
  493.8833,
  // octave 4
  523.2511,
  554.3653,
  587.3295,
  622.254,
  659.2551,
  698.4565,
  739.9888,
  783.9909,
  830.6094,
  880,
  932.3275,
  987.7666,
  // octave 5
  1046.502,
  1108.731,
  1174.659,
  1244.508,
  1318.51,
  1396.913,
  1479.978,
  1567.982,
  1661.219,
  1760,
  1864.655,
  1975.533,
  // octave 6
  2093.005,
  2217.461,
  2349.318,
  2489.016,
  2637.02,
  2793.826,
  2959.955,
  3135.963,
  3322.438,
  3520,
  3729.31,
  3951.066,
  // octave 7
  4186.009,
  4434.922,
  4698.636,
  4978.032,
  5274.041,
  5587.652,
  5919.911,
  6271.927,
  6644.875,
  7040,
  7458.62,
  7902.133
  // octave 8
], yR = 0.25, xAe = (t, e, r) => isNaN(t) || t < e || t > r, vR = (t) => isNaN(t) ? 0 : (t * 2 - 1) * 0.98, EAe = ({
  point: t,
  min: e,
  max: r,
  bins: n,
  scale: i
}) => SAe({ point: t, min: e, max: r, bins: n }), SAe = ({
  point: t,
  min: e,
  max: r,
  bins: n
}) => {
  const i = (t - e) / (r - e);
  return Math.floor(n * i);
};
class AAe {
  //private _playListContinuous: NodeJS.Timeout[] = [];
  constructor(e, r) {
    this._chartInfo = e, this._store = r, this.context = null, this._audioEngine = null;
  }
  /**
   * Confirm the audio engine was initialized
   */
  _checkAudioEngine() {
    this.context || (this.context = new AudioContext()), !this._audioEngine && this.context && (this._audioEngine = this._providedAudioEngine ?? new vAe(this.context));
  }
  /**
   * Get the available hertzes
   * @returns number[]
   */
  _getHertzRange() {
    return wAe.slice(
      this._store.settings.sonification.hertzLower,
      this._store.settings.sonification.hertzUpper
    );
  }
  /**
   * Play a given data point
   * @param datapoint - the data point to play
   */
  playDatapoints(e, {
    cont: r = !1,
    invert: n = !1,
    durationVariable: i = !1
  } = {}) {
    if (this._checkAudioEngine(), !this._audioEngine)
      return;
    const s = this._getHertzRange(), o = this._store.model.getFacet("x").datatype === "string";
    e.forEach((a, l) => {
      const c = a.facetValueNumericized(a.indepKey ?? "x");
      let p = a.facetValueNumericized(a.depKey ?? "y");
      const h = o ? l : c - this._chartInfo.axisInfo.xLabelInfo.min, d = o ? e.length - 1 : this._chartInfo.axisInfo.xLabelInfo.range, v = (
        /*this._xAxis.type === 'log10'
          ? calcPan(
            (Math.log10(current.x) -
              Math.log10(this._xAxis.minimum)) /
            (Math.log10(this._xAxis.maximum) -
              Math.log10(this._xAxis.minimum))
          )
          :*/
        vR(
          h / d
        )
      );
      let m, b;
      if (this._chartInfo.axisInfo)
        m = this._chartInfo.axisInfo.yLabelInfo.min, b = this._chartInfo.axisInfo.yLabelInfo.max;
      else {
        const E = this._store.model.getFacetInterval("y");
        m = E.start, b = E.end;
      }
      const f = p;
      if (n && (p = b - (p - m)), !xAe(p, m, b))
        if (r) {
          let E = Math.min(...s);
          const A = (p - m) / (b - m), x = E * 1.05946 ** (A * s.length);
          let g = vR((c - this._chartInfo.axisInfo.xLabelInfo.min) / this._chartInfo.axisInfo.xLabelInfo.range);
          this._audioEngine.playDataPoint(x, g, yR);
        } else {
          const E = EAe({
            point: p,
            min: m,
            max: b,
            bins: s.length - 1,
            scale: "linear"
          }), A = i ? 0.1 + (f - m) / (b - m) : yR;
          this._audioEngine.playDataPoint(s[E], v, A);
        }
    });
  }
  /**
   * Play an audio notification
   * @param earcon - the type of notification to play
   */
  playNotification(e) {
    if (this._store.settings.sonification.isNotificationEnabled) {
      if (this._checkAudioEngine(), !this._audioEngine)
        return;
      let r = kn.Annotation, n = 0.5;
      switch (e) {
        case "annotation":
          r = kn.Annotation;
          break;
        case "bumper":
          r = kn.Bumper, n = 0.25;
          break;
        case "high":
          r = kn.High;
          break;
        case "low":
          r = kn.Low;
          break;
        case "series":
          r = kn.Series, n = 0.3;
          break;
        case "intersection":
          r = kn.Intersection;
          break;
        case "threshold":
          r = kn.Threshold;
          break;
      }
      this._audioEngine.playNotification(r, 0, n);
    }
  }
}
class tV {
  constructor(e, r) {
    this._type = e, this._store = r, this.log = qt("BaseChartInfo"), this._navMap = null, this._axisInfo = null, this._chordPrevSeriesKey = "", this._soniInterval = null, this._soniRiffInterval = null, this._init(), this._addSettingControls();
  }
  _addSettingControls() {
    this._store.settingControls.add({
      type: "textfield",
      key: "chart.size.width",
      label: "Width",
      options: {
        inputType: "number",
        min: 1,
        max: 1e3
      },
      parentView: "controlPanel.tabs.chart.general.width"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "chart.size.height",
      label: "Height",
      options: {
        inputType: "number",
        min: 1,
        max: 1e3
      },
      parentView: "controlPanel.tabs.chart.general.height"
    });
  }
  _init() {
    this._createNavMap(), this._sonifier = new AAe(this, this._store), this._storeChangeUnsub = this._store.subscribe(async (e, r) => {
      e === "data" && this._createSummarizer();
    }), this._createSummarizer();
  }
  _createSummarizer() {
    this._summarizer = this._type === "pie" || this._type === "donut" ? new qb(this._store.model) : new Wb(this._store.model);
  }
  get summarizer() {
    return this._summarizer;
  }
  get managedSettingKeys() {
    return [`type.${this._type}`];
  }
  get settings() {
    return vr.getGroupLink(this.managedSettingKeys[0], this._store.settings);
  }
  get navMap() {
    return this._navMap;
  }
  /** Overridden by ScatterChartInfo */
  get navDatapointType() {
    return "datapoint";
  }
  get axisInfo() {
    return this._axisInfo;
  }
  settingDidChange(e, r, n) {
  }
  async storeDidChange(e, r) {
  }
  noticePosted(e, r) {
  }
  _createNavMap() {
    this._navMap = new _k(this._store, this);
    const e = this._navMap.layer("root"), r = new Ia(e, "top", {}, this._store);
    e.registerNode(r), e.cursor = r;
  }
  didAddHighlight(e) {
  }
  didRemoveHighlight(e) {
  }
  legend() {
    return [];
  }
  popuplegend() {
    return this.seriesInNavOrder().map((r) => r.key).map((r, n) => ({
      label: "",
      color: this._store.seriesProperties.properties(r).color,
      symbol: this._store.seriesProperties.properties(r).symbol
    }));
  }
  navToDatapoint(e, r) {
    this._navMap.goTo(this.navDatapointType, { seriesKey: e, index: r });
  }
  async move(e) {
    await this._navMap.cursor.move(e), this._store.paraChart.postNotice("move", { dir: e, options: this._navMap.cursor.options });
  }
  /**
   * Navigate to the series minimum/maximum datapoint
   * @param isMin - If true, go the the minimum. Otherwise, go to the maximum
   */
  goSeriesMinMax(e) {
    const r = this._navMap.cursor;
    if (r.isNodeType("top") || r.isNodeType("chord"))
      this.goChartMinMax(e);
    else if (r.isNodeType(this.navDatapointType) || r.isNodeType("series") || r.isNodeType("sequence") || r.isNodeType("cluster")) {
      let n = null;
      const i = r.options.seriesKey;
      r.isNodeType(this.navDatapointType) && (n = this._store.model.atKeyAndIndex(r.options.seriesKey, r.options.index));
      const s = this._store.model.dependentFacetKeys[0], o = this._store.model.atKey(i).getFacetStats(s);
      let a = e ? o.min.datapoints : o.max.datapoints;
      if (n && a.length > 1) {
        const l = a.findIndex((c) => c === n);
        l !== -1 && l !== a.length + 1 && (a = a.toSpliced(0, l));
      }
      this._navMap.goTo(this.navDatapointType, {
        seriesKey: a[0].seriesKey,
        index: a[0].datapointIndex
      }), this._store.paraChart.postNotice("goSeriesMinMax", { isMin: e, options: this._navMap.cursor.options });
    }
  }
  /**
   * Navigate to (one of) the chart minimum/maximum datapoint(s)
   * @param isMin - If true, go the the minimum. Otherwise, go to the maximum
   */
  goChartMinMax(e) {
    const r = this._store.model.getFacetStats("y"), n = e ? r.min.value : r.max.value, i = this._store.model.allPoints.find((s) => s.facetValueAsNumber("y") === n);
    this._navMap.goTo(this.navDatapointType, {
      seriesKey: i == null ? void 0 : i.seriesKey,
      index: i == null ? void 0 : i.datapointIndex
    }), this._store.paraChart.postNotice("goChartMinMax", { isMin: e, options: this._navMap.cursor.options });
  }
  _composePointSelectionAnnouncement(e) {
    const r = (c) => {
      const { seriesKey: p, index: h } = on(c), d = this._store.model.atKeyAndIndex(p, h);
      return `${p} (${Wr(d.facetBox("x"), this._store.getFormatType("statusBar"))}, ${Wr(d.facetBox("y"), this._store.getFormatType("statusBar"))})`;
    }, n = this._store.selectedDatapoints.size, i = this._store.prevSelectedDatapoints.size, s = this._store.selectedDatapoints.difference(
      this._store.prevSelectedDatapoints
    ), o = this._store.prevSelectedDatapoints.difference(
      this._store.selectedDatapoints
    ), l = `${n} point${n === 1 ? "" : "s"} selected.`;
    return i === 0 ? `Selected ${r(s.values().toArray()[0])}` : i === 1 && !n ? `Deselected ${r(o.values().toArray()[0])}. No points selected.` : !e && s.size && i ? `Selected ${r(s.values().toArray()[0])}. 1 point selected.` : !e && n && i ? `Deselected ${r(o.values().toArray()[0])}. 1 point selected.` : e && o.size ? `Deselected ${r(o.values().toArray()[0])}. ${l}` : e && s.size ? `Selected ${r(s.values().toArray()[0])}. ${l}` : "ERROR";
  }
  _composeSeriesSelectionAnnouncement() {
    const e = this._store.selectedDatapoints.size, r = this._store.prevSelectedDatapoints.size, n = this._store.selectedDatapoints.values().filter((a) => {
      const l = on(a);
      return !this._store.wasSelected(l.seriesKey, l.index);
    }).toArray();
    let i = e === 1 ? "" : "s";
    const s = `${e} point${i} selected.`;
    i = n.length === 1 ? "" : "s";
    const o = `Selected ${n.length} point${i}.`;
    return r === 0 ? o : `${o} ${s}`;
  }
  selectCurrent(e = !1) {
    e ? this._store.extendSelection() : this._store.select();
    const r = this._navMap.cursor.isNodeType("datapoint") ? this._composePointSelectionAnnouncement(e) : this._navMap.cursor.isNodeType("series") ? this._composeSeriesSelectionAnnouncement() : "";
    r && this._store.announce(r), this._store.paraChart.postNotice("select", { isExtend: e, options: this._navMap.cursor.options });
  }
  clearDatapointSelection(e = !1) {
    this._store.clearSelected(), e || this._store.announce("No items selected."), this._store.paraChart.postNotice("clearSelection", null);
  }
  // NOTE: This should be overriden in subclasses
  queryData() {
    const e = this._navMap.cursor.type;
    this._store.announce(
      `[ParaChart/Internal] Error: DataLayer.queryData should be overriden. Query Type: ${e}`
    );
  }
  navFirst() {
    var r;
    const e = this._navMap.cursor.type;
    if ([this.navDatapointType, "chord", "series"].includes(e)) {
      const n = {
        datapoint: "left",
        chord: "left",
        series: "up"
      };
      (r = this._navMap.cursor.allNodes(n[e], e).at(-1)) == null || r.go(), this._store.paraChart.postNotice("goFirst", { options: this._navMap.cursor.options });
    }
  }
  navLast() {
    var r;
    const e = this._navMap.cursor.type;
    if ([this.navDatapointType, "chord", "series"].includes(e)) {
      const n = {
        datapoint: "right",
        chord: "right",
        series: "down"
      };
      (r = this._navMap.cursor.allNodes(n[e], e).at(-1)) == null || r.go(), this._store.paraChart.postNotice("goLast", { options: this._navMap.cursor.options });
    }
  }
  navToChordLanding() {
    if (["line", "bar", "column"].includes(this._store.type) && this._store.model.series.length > 1)
      if (this._navMap.cursor.isNodeType(this.navDatapointType)) {
        const e = this._navMap.cursor.options.seriesKey;
        this._navMap.cursor.layer.goTo("chord", this._navMap.cursor.options.index), this._chordPrevSeriesKey = e, this._store.paraChart.postNotice("enterChordMode", { options: this._navMap.cursor.options });
      } else this._navMap.cursor.isNodeType("chord") && (this._navMap.cursor.layer.goTo(
        this.navDatapointType,
        {
          seriesKey: this._chordPrevSeriesKey,
          index: this._navMap.cursor.options.index
        }
      ), this._store.paraChart.postNotice("exitChordMode", { options: this._navMap.cursor.options }));
    else
      this.log.info("Chord mode not supported for this chart type");
  }
  async navRunDidStart(e) {
    (e.isNodeType("series") || e.isNodeType(this.navDatapointType)) && (this._store.frontSeries = e.options.seriesKey);
  }
  async navRunDidEnd(e) {
    if (e.isNodeType("top"))
      this._store.announce(await this._summarizer.getChartSummary());
    else if (e.isNodeType("series"))
      this._store.announce(
        await this._summarizer.getSeriesSummary(e.options.seriesKey)
      ), this._playCurrentRiff(), this._store.sparkBrailleInfo = this._sparkBrailleInfo();
    else if (e.isNodeType(this.navDatapointType)) {
      const r = this._store.everVisitedSeries(e.options.seriesKey), n = this._store.model.atKeyAndIndex(e.options.seriesKey, e.options.index), i = [this._summarizer.getDatapointSummary(n, "statusBar")];
      if (!this._store.wasVisitedSeries(e.options.seriesKey) && (i[0] = `${this._store.model.atKey(e.options.seriesKey).getLabel()}: ${i[0]}`, !r)) {
        const o = await this._summarizer.getSeriesSummary(e.options.seriesKey);
        i.push(o.text);
      }
      this._store.announce(i), this._store.settings.sonification.isSoniEnabled && this.playDatapoints([n]), this._store.sparkBrailleInfo = this._sparkBrailleInfo();
    } else if (e.isNodeType("chord")) {
      if (this._store.settings.sonification.isSoniEnabled)
        if (this._store.settings.sonification.isArpeggiateChords)
          this._playCurrentRiff(this._chordRiffOrder());
        else {
          const r = e.datapoints.map((n) => this._store.model.atKeyAndIndex(n.seriesKey, n.datapointIndex));
          this.playDatapoints(r);
        }
    } else e.isNodeType("sequence") && (this._store.announce(
      await this._summarizer.getSequenceSummary({
        seriesKey: e.options.seriesKey,
        start: e.options.start,
        end: e.options.end
      })
    ), this._playCurrentRiff());
  }
  /** Can be overridden by subclasses. */
  seriesInNavOrder() {
    return this._store.model.series;
  }
  /** Nav map layer from which to interpret selectors */
  get selectorLayer() {
    return "root";
  }
  datapointsForSelector(e) {
    return this._navMap.datapointsForSelector(this.selectorLayer, e);
  }
  isHighlighted(e, r) {
    if (this._store.highlightedSelector) {
      const n = this.datapointsForSelector(this._store.highlightedSelector);
      for (const i of n)
        if (i.seriesKey === e && i.datapointIndex === r)
          return !0;
    }
    return !1;
  }
  get shouldDrawFocusRing() {
    return this._navMap.cursor.type !== "top";
  }
  /** Play a riff for the current nav node */
  _playCurrentRiff(e) {
    this._store.settings.sonification.isSoniEnabled && this._store.settings.sonification.isRiffEnabled && this.playRiff(this._navMap.cursor.datapoints, e);
  }
  _chordRiffOrder() {
    return "normal";
  }
  /**
   * Clear outstanding play intervals/timeouts
   */
  clearPlay() {
    clearInterval(this._soniInterval), clearInterval(this._soniRiffInterval);
  }
  getXAxisInterval() {
    let e = [];
    if (this._store.model.getFacet("x").datatype === "number" || this._store.model.getFacet("x").datatype === "date")
      e = this._store.model.allFacetValues("x").map((r) => r.asNumber());
    else
      throw new Error("axis must be of type number or date to take interval");
    return { start: Math.min(...e), end: Math.max(...e) };
  }
  getYAxisInterval() {
    if (!this.axisInfo)
      throw new Error("chart is missing `axisInfo` object");
    return {
      start: this.axisInfo.yLabelInfo.min,
      end: this.axisInfo.yLabelInfo.max
    };
  }
  getAxisInterval(e) {
    return e === "x" ? this.getXAxisInterval() : this.getYAxisInterval();
  }
}
const kAe = [1e3, 250, 100, 50, 25], rV = [450, 300, 150, 100, 75];
class Ck extends tV {
  constructor(e, r) {
    super(e, r), this._soniSequenceIndex = 0, this._soniNoteIndex = 0, this._soniSpeedRateIndex = 1;
  }
  _createNavMap() {
    super._createNavMap(), this._createPrimaryNavNodes(), this._store.model.seriesKeys.length > 1 && (this._createVerticalNavLinks(), this._createChordNavNodes());
  }
  get _datapointNavNodeType() {
    return "datapoint";
  }
  _datapointNavNodeOptions(e) {
    return {
      seriesKey: e.seriesKey,
      index: e.datapointIndex
    };
  }
  _createPrimaryNavNodes() {
    let e = this._navMap.root.get("top");
    this._store.model.dependentFacetKeys[0], this.seriesInNavOrder().forEach((n, i) => {
      const s = new Ia(this._navMap.root, "series", {
        seriesKey: n.key
      }, this._store);
      s.connect("left", e), e = s, n.datapoints.forEach((o, a) => {
        const l = new Ia(
          this._navMap.root,
          this._datapointNavNodeType,
          this._datapointNavNodeOptions(o),
          this._store
        );
        l.connect("left", e), e = l;
      });
    });
  }
  _createVerticalNavLinks() {
    this._store.model.series.slice(0, -1).forEach((e, r) => {
      const n = this._navMap.root.get("series", r), i = this._navMap.root.get("series", r + 1);
      n.connect("down", i);
      for (let s = 1; s <= e.datapoints.length; s++)
        n.peekNode("right", s).connect(
          "down",
          i.peekNode("right", s)
        );
    });
  }
  _createChordNavNodes() {
    this._navMap.root.query(this._datapointNavNodeType, {
      seriesKey: this.seriesInNavOrder()[0].key
    }).forEach((e) => {
      new Ia(
        this._navMap.root,
        "chord",
        { index: e.options.index },
        this._store
      );
    }), this._navMap.root.query("chord").slice(0, -1).forEach((e, r) => {
      e.connect("right", this._navMap.root.get("chord", r + 1));
    });
  }
  playRiff(e, r) {
    r === "sorted" ? e.sort((n, i) => n.facetValueAsNumber("y") - i.facetValueAsNumber("y")) : r === "reversed" && e.reverse(), e.length && (this._soniRiffInterval && clearInterval(this._soniRiffInterval), this._soniSequenceIndex++, this._soniRiffInterval = setInterval(() => {
      const n = e.shift();
      n ? (this._sonifier.playDatapoints([n]), this._soniNoteIndex++) : clearInterval(this._soniRiffInterval);
    }, rV.at(this._store.settings.sonification.riffSpeedIndex)));
  }
  playDatapoints(e) {
    this._sonifier.playDatapoints(e);
  }
  playDir(e) {
    if (this._navMap.cursor.type !== this._datapointNavNodeType)
      return;
    this.clearPlay();
    let r = this._navMap.cursor;
    this._soniInterval = setInterval(() => {
      const n = r.peekNode(e, 1);
      n && n.type === this._datapointNavNodeType ? (this.playDatapoints([n.datapoints[0]]), r = n) : this.clearPlay();
    }, kAe.at(this._soniSpeedRateIndex));
  }
  _sparkBrailleInfo() {
    return {
      data: this._navMap.cursor.isNodeType(this._datapointNavNodeType) || this._navMap.cursor.isNodeType("series") || this._navMap.cursor.isNodeType("sequence") ? this._store.model.atKey(this._navMap.cursor.options.seriesKey).datapoints.map((e) => e.facetValueAsNumber("y")).join(" ") : "0",
      isBar: this._type === "bar" || this._type === "column"
    };
  }
}
/*!
 *  decimal.js v10.5.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var J4 = 9e15, tu = 1e9, X4 = "0123456789abcdef", x2 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", E2 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", eE = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -9e15,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: J4,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, nV, va, _t = !0, Kb = "[DecimalError] ", uc = Kb + "Invalid argument: ", iV = Kb + "Precision limit exceeded", sV = Kb + "crypto unavailable", oV = "[object Decimal]", Fn = Math.floor, Kr = Math.pow, _Ae = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, CAe = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, IAe = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, aV = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Gs = 1e7, xt = 7, PAe = 9007199254740991, RAe = x2.length - 1, tE = E2.length - 1, Be = { toStringTag: oV };
Be.absoluteValue = Be.abs = function() {
  var t = new this.constructor(this);
  return t.s < 0 && (t.s = 1), ft(t);
};
Be.ceil = function() {
  return ft(new this.constructor(this), this.e + 1, 2);
};
Be.clampedTo = Be.clamp = function(t, e) {
  var r, n = this, i = n.constructor;
  if (t = new i(t), e = new i(e), !t.s || !e.s) return new i(NaN);
  if (t.gt(e)) throw Error(uc + e);
  return r = n.cmp(t), r < 0 ? t : n.cmp(e) > 0 ? e : new i(n);
};
Be.comparedTo = Be.cmp = function(t) {
  var e, r, n, i, s = this, o = s.d, a = (t = new s.constructor(t)).d, l = s.s, c = t.s;
  if (!o || !a)
    return !l || !c ? NaN : l !== c ? l : o === a ? 0 : !o ^ l < 0 ? 1 : -1;
  if (!o[0] || !a[0]) return o[0] ? l : a[0] ? -c : 0;
  if (l !== c) return l;
  if (s.e !== t.e) return s.e > t.e ^ l < 0 ? 1 : -1;
  for (n = o.length, i = a.length, e = 0, r = n < i ? n : i; e < r; ++e)
    if (o[e] !== a[e]) return o[e] > a[e] ^ l < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
};
Be.cosine = Be.cos = function() {
  var t, e, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + xt, n.rounding = 1, r = OAe(n, pV(n, r)), n.precision = t, n.rounding = e, ft(va == 2 || va == 3 ? r.neg() : r, t, e, !0)) : new n(1) : new n(NaN);
};
Be.cubeRoot = Be.cbrt = function() {
  var t, e, r, n, i, s, o, a, l, c, p = this, h = p.constructor;
  if (!p.isFinite() || p.isZero()) return new h(p);
  for (_t = !1, s = p.s * Kr(p.s * p, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = dn(p.d), t = p.e, (s = (t - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Kr(r, 1 / 3), t = Fn((t + 1) / 3) - (t % 3 == (t < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + t : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + t), n = new h(r), n.s = p.s) : n = new h(s.toString()), o = (t = h.precision) + 3; ; )
    if (a = n, l = a.times(a).times(a), c = l.plus(p), n = lr(c.plus(p).times(a), c.plus(l), o + 2, 1), dn(a.d).slice(0, o) === (r = dn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (ft(a, t + 1, 0), a.times(a).times(a).eq(p))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (ft(n, t + 1, 1), e = !n.times(n).times(n).eq(p));
        break;
      }
  return _t = !0, ft(n, t, h.rounding, e);
};
Be.decimalPlaces = Be.dp = function() {
  var t, e = this.d, r = NaN;
  if (e) {
    if (t = e.length - 1, r = (t - Fn(this.e / xt)) * xt, t = e[t], t) for (; t % 10 == 0; t /= 10) r--;
    r < 0 && (r = 0);
  }
  return r;
};
Be.dividedBy = Be.div = function(t) {
  return lr(this, new this.constructor(t));
};
Be.dividedToIntegerBy = Be.divToInt = function(t) {
  var e = this, r = e.constructor;
  return ft(lr(e, new r(t), 0, 1, 1), r.precision, r.rounding);
};
Be.equals = Be.eq = function(t) {
  return this.cmp(t) === 0;
};
Be.floor = function() {
  return ft(new this.constructor(this), this.e + 1, 3);
};
Be.greaterThan = Be.gt = function(t) {
  return this.cmp(t) > 0;
};
Be.greaterThanOrEqualTo = Be.gte = function(t) {
  var e = this.cmp(t);
  return e == 1 || e === 0;
};
Be.hyperbolicCosine = Be.cosh = function() {
  var t, e, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite()) return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero()) return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (t = Math.ceil(i / 3), e = (1 / Zb(4, t)).toString()) : (t = 16, e = "2.3283064365386962890625e-10"), s = ld(o, 1, s.times(e), new o(1), !0);
  for (var l, c = t, p = new o(8); c--; )
    l = s.times(s), s = a.minus(l.times(p.minus(l.times(p))));
  return ft(s, o.precision = r, o.rounding = n, !0);
};
Be.hyperbolicSine = Be.sinh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero()) return new s(i);
  if (e = s.precision, r = s.rounding, s.precision = e + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = ld(s, 2, i, i, !0);
  else {
    t = 1.4 * Math.sqrt(n), t = t > 16 ? 16 : t | 0, i = i.times(1 / Zb(5, t)), i = ld(s, 2, i, i, !0);
    for (var o, a = new s(5), l = new s(16), c = new s(20); t--; )
      o = i.times(i), i = i.times(a.plus(o.times(l.times(o).plus(c))));
  }
  return s.precision = e, s.rounding = r, ft(i, e, r, !0);
};
Be.hyperbolicTangent = Be.tanh = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 7, n.rounding = 1, lr(r.sinh(), r.cosh(), n.precision = t, n.rounding = e)) : new n(r.s);
};
Be.inverseCosine = Be.acos = function() {
  var t = this, e = t.constructor, r = t.abs().cmp(1), n = e.precision, i = e.rounding;
  return r !== -1 ? r === 0 ? t.isNeg() ? Mo(e, n, i) : new e(0) : new e(NaN) : t.isZero() ? Mo(e, n + 4, i).times(0.5) : (e.precision = n + 6, e.rounding = 1, t = new e(1).minus(t).div(t.plus(1)).sqrt().atan(), e.precision = n, e.rounding = i, t.times(2));
};
Be.inverseHyperbolicCosine = Be.acosh = function() {
  var t, e, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (t = n.precision, e = n.rounding, n.precision = t + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, _t = !1, r = r.times(r).minus(1).sqrt().plus(r), _t = !0, n.precision = t, n.rounding = e, r.ln()) : new n(r);
};
Be.inverseHyperbolicSine = Be.asinh = function() {
  var t, e, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, _t = !1, r = r.times(r).plus(1).sqrt().plus(r), _t = !0, n.precision = t, n.rounding = e, r.ln());
};
Be.inverseHyperbolicTangent = Be.atanh = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (t = s.precision, e = s.rounding, n = i.sd(), Math.max(n, t) < 2 * -i.e - 1 ? ft(new s(i), t, e, !0) : (s.precision = r = n - i.e, i = lr(i.plus(1), new s(1).minus(i), r + t, 1), s.precision = t + 4, s.rounding = 1, i = i.ln(), s.precision = t, s.rounding = e, i.times(0.5))) : new s(NaN);
};
Be.inverseSine = Be.asin = function() {
  var t, e, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (e = i.abs().cmp(1), r = s.precision, n = s.rounding, e !== -1 ? e === 0 ? (t = Mo(s, r + 4, n).times(0.5), t.s = i.s, t) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
Be.inverseTangent = Be.atan = function() {
  var t, e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding;
  if (c.isFinite()) {
    if (c.isZero())
      return new p(c);
    if (c.abs().eq(1) && h + 4 <= tE)
      return o = Mo(p, h + 4, d).times(0.25), o.s = c.s, o;
  } else {
    if (!c.s) return new p(NaN);
    if (h + 4 <= tE)
      return o = Mo(p, h + 4, d).times(0.5), o.s = c.s, o;
  }
  for (p.precision = a = h + 10, p.rounding = 1, r = Math.min(28, a / xt + 2 | 0), t = r; t; --t) c = c.div(c.times(c).plus(1).sqrt().plus(1));
  for (_t = !1, e = Math.ceil(a / xt), n = 1, l = c.times(c), o = new p(c), i = c; t !== -1; )
    if (i = i.times(l), s = o.minus(i.div(n += 2)), i = i.times(l), o = s.plus(i.div(n += 2)), o.d[e] !== void 0) for (t = e; o.d[t] === s.d[t] && t--; ) ;
  return r && (o = o.times(2 << r - 1)), _t = !0, ft(o, p.precision = h, p.rounding = d, !0);
};
Be.isFinite = function() {
  return !!this.d;
};
Be.isInteger = Be.isInt = function() {
  return !!this.d && Fn(this.e / xt) > this.d.length - 2;
};
Be.isNaN = function() {
  return !this.s;
};
Be.isNegative = Be.isNeg = function() {
  return this.s < 0;
};
Be.isPositive = Be.isPos = function() {
  return this.s > 0;
};
Be.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
Be.lessThan = Be.lt = function(t) {
  return this.cmp(t) < 0;
};
Be.lessThanOrEqualTo = Be.lte = function(t) {
  return this.cmp(t) < 1;
};
Be.logarithm = Be.log = function(t) {
  var e, r, n, i, s, o, a, l, c = this, p = c.constructor, h = p.precision, d = p.rounding, v = 5;
  if (t == null)
    t = new p(10), e = !0;
  else {
    if (t = new p(t), r = t.d, t.s < 0 || !r || !r[0] || t.eq(1)) return new p(NaN);
    e = t.eq(10);
  }
  if (r = c.d, c.s < 0 || !r || !r[0] || c.eq(1))
    return new p(r && !r[0] ? -1 / 0 : c.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (e)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; ) i /= 10;
      s = i !== 1;
    }
  if (_t = !1, a = h + v, o = Ll(c, a), n = e ? S2(p, a + 10) : Ll(t, a), l = lr(o, n, a, 1), J0(l.d, i = h, d))
    do
      if (a += 10, o = Ll(c, a), n = e ? S2(p, a + 10) : Ll(t, a), l = lr(o, n, a, 1), !s) {
        +dn(l.d).slice(i + 1, i + 15) + 1 == 1e14 && (l = ft(l, h + 1, 0));
        break;
      }
    while (J0(l.d, i += 10, d));
  return _t = !0, ft(l, h, d);
};
Be.minus = Be.sub = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, v = this, m = v.constructor;
  if (t = new m(t), !v.d || !t.d)
    return !v.s || !t.s ? t = new m(NaN) : v.d ? t.s = -t.s : t = new m(t.d || v.s !== t.s ? v : NaN), t;
  if (v.s != t.s)
    return t.s = -t.s, v.plus(t);
  if (c = v.d, d = t.d, a = m.precision, l = m.rounding, !c[0] || !d[0]) {
    if (d[0]) t.s = -t.s;
    else if (c[0]) t = new m(v);
    else return new m(l === 3 ? -0 : 0);
    return _t ? ft(t, a, l) : t;
  }
  if (r = Fn(t.e / xt), p = Fn(v.e / xt), c = c.slice(), s = p - r, s) {
    for (h = s < 0, h ? (e = c, s = -s, o = d.length) : (e = d, r = p, o = c.length), n = Math.max(Math.ceil(a / xt), o) + 2, s > n && (s = n, e.length = 1), e.reverse(), n = s; n--; ) e.push(0);
    e.reverse();
  } else {
    for (n = c.length, o = d.length, h = n < o, h && (o = n), n = 0; n < o; n++)
      if (c[n] != d[n]) {
        h = c[n] < d[n];
        break;
      }
    s = 0;
  }
  for (h && (e = c, c = d, d = e, t.s = -t.s), o = c.length, n = d.length - o; n > 0; --n) c[o++] = 0;
  for (n = d.length; n > s; ) {
    if (c[--n] < d[n]) {
      for (i = n; i && c[--i] === 0; ) c[i] = Gs - 1;
      --c[i], c[n] += Gs;
    }
    c[n] -= d[n];
  }
  for (; c[--o] === 0; ) c.pop();
  for (; c[0] === 0; c.shift()) --r;
  return c[0] ? (t.d = c, t.e = Yb(c, r), _t ? ft(t, a, l) : t) : new m(l === 3 ? -0 : 0);
};
Be.modulo = Be.mod = function(t) {
  var e, r = this, n = r.constructor;
  return t = new n(t), !r.d || !t.s || t.d && !t.d[0] ? new n(NaN) : !t.d || r.d && !r.d[0] ? ft(new n(r), n.precision, n.rounding) : (_t = !1, n.modulo == 9 ? (e = lr(r, t.abs(), 0, 3, 1), e.s *= t.s) : e = lr(r, t, 0, n.modulo, 1), e = e.times(t), _t = !0, r.minus(e));
};
Be.naturalExponential = Be.exp = function() {
  return rE(this);
};
Be.naturalLogarithm = Be.ln = function() {
  return Ll(this);
};
Be.negated = Be.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s, ft(t);
};
Be.plus = Be.add = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h = this, d = h.constructor;
  if (t = new d(t), !h.d || !t.d)
    return !h.s || !t.s ? t = new d(NaN) : h.d || (t = new d(t.d || h.s === t.s ? h : NaN)), t;
  if (h.s != t.s)
    return t.s = -t.s, h.minus(t);
  if (c = h.d, p = t.d, a = d.precision, l = d.rounding, !c[0] || !p[0])
    return p[0] || (t = new d(h)), _t ? ft(t, a, l) : t;
  if (s = Fn(h.e / xt), n = Fn(t.e / xt), c = c.slice(), i = s - n, i) {
    for (i < 0 ? (r = c, i = -i, o = p.length) : (r = p, n = s, o = c.length), s = Math.ceil(a / xt), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; ) r.push(0);
    r.reverse();
  }
  for (o = c.length, i = p.length, o - i < 0 && (i = o, r = p, p = c, c = r), e = 0; i; )
    e = (c[--i] = c[i] + p[i] + e) / Gs | 0, c[i] %= Gs;
  for (e && (c.unshift(e), ++n), o = c.length; c[--o] == 0; ) c.pop();
  return t.d = c, t.e = Yb(c, n), _t ? ft(t, a, l) : t;
};
Be.precision = Be.sd = function(t) {
  var e, r = this;
  if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(uc + t);
  return r.d ? (e = lV(r.d), t && r.e + 1 > e && (e = r.e + 1)) : e = NaN, e;
};
Be.round = function() {
  var t = this, e = t.constructor;
  return ft(new e(t), t.e + 1, e.rounding);
};
Be.sine = Be.sin = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + Math.max(r.e, r.sd()) + xt, n.rounding = 1, r = LAe(n, pV(n, r)), n.precision = t, n.rounding = e, ft(va > 2 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Be.squareRoot = Be.sqrt = function() {
  var t, e, r, n, i, s, o = this, a = o.d, l = o.e, c = o.s, p = o.constructor;
  if (c !== 1 || !a || !a[0])
    return new p(!c || c < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (_t = !1, c = Math.sqrt(+o), c == 0 || c == 1 / 0 ? (e = dn(a), (e.length + l) % 2 == 0 && (e += "0"), c = Math.sqrt(e), l = Fn((l + 1) / 2) - (l < 0 || l % 2), c == 1 / 0 ? e = "5e" + l : (e = c.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + l), n = new p(e)) : n = new p(c.toString()), r = (l = p.precision) + 3; ; )
    if (s = n, n = s.plus(lr(o, s, r + 2, 1)).times(0.5), dn(s.d).slice(0, r) === (e = dn(n.d)).slice(0, r))
      if (e = e.slice(r - 3, r + 1), e == "9999" || !i && e == "4999") {
        if (!i && (ft(s, l + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+e || !+e.slice(1) && e.charAt(0) == "5") && (ft(n, l + 1, 1), t = !n.times(n).eq(o));
        break;
      }
  return _t = !0, ft(n, l, p.rounding, t);
};
Be.tangent = Be.tan = function() {
  var t, e, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (t = n.precision, e = n.rounding, n.precision = t + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = lr(r, new n(1).minus(r.times(r)).sqrt(), t + 10, 0), n.precision = t, n.rounding = e, ft(va == 2 || va == 4 ? r.neg() : r, t, e, !0)) : new n(NaN);
};
Be.times = Be.mul = function(t) {
  var e, r, n, i, s, o, a, l, c, p = this, h = p.constructor, d = p.d, v = (t = new h(t)).d;
  if (t.s *= p.s, !d || !d[0] || !v || !v[0])
    return new h(!t.s || d && !d[0] && !v || v && !v[0] && !d ? NaN : !d || !v ? t.s / 0 : t.s * 0);
  for (r = Fn(p.e / xt) + Fn(t.e / xt), l = d.length, c = v.length, l < c && (s = d, d = v, v = s, o = l, l = c, c = o), s = [], o = l + c, n = o; n--; ) s.push(0);
  for (n = c; --n >= 0; ) {
    for (e = 0, i = l + n; i > n; )
      a = s[i] + v[n] * d[i - n - 1] + e, s[i--] = a % Gs | 0, e = a / Gs | 0;
    s[i] = (s[i] + e) % Gs | 0;
  }
  for (; !s[--o]; ) s.pop();
  return e ? ++r : s.shift(), t.d = s, t.e = Yb(s, r), _t ? ft(t, h.precision, h.rounding) : t;
};
Be.toBinary = function(t, e) {
  return Ik(this, 2, t, e);
};
Be.toDecimalPlaces = Be.toDP = function(t, e) {
  var r = this, n = r.constructor;
  return r = new n(r), t === void 0 ? r : (di(t, 0, tu), e === void 0 ? e = n.rounding : di(e, 0, 8), ft(r, t + r.e + 1, e));
};
Be.toExponential = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Zo(n, !0) : (di(t, 0, tu), e === void 0 ? e = i.rounding : di(e, 0, 8), n = ft(new i(n), t + 1, e), r = Zo(n, !0, t + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Be.toFixed = function(t, e) {
  var r, n, i = this, s = i.constructor;
  return t === void 0 ? r = Zo(i) : (di(t, 0, tu), e === void 0 ? e = s.rounding : di(e, 0, 8), n = ft(new s(i), t + i.e + 1, e), r = Zo(n, !1, t + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
Be.toFraction = function(t) {
  var e, r, n, i, s, o, a, l, c, p, h, d, v = this, m = v.d, b = v.constructor;
  if (!m) return new b(v);
  if (c = r = new b(1), n = l = new b(0), e = new b(n), s = e.e = lV(m) - v.e - 1, o = s % xt, e.d[0] = Kr(10, o < 0 ? xt + o : o), t == null)
    t = s > 0 ? e : c;
  else {
    if (a = new b(t), !a.isInt() || a.lt(c)) throw Error(uc + a);
    t = a.gt(e) ? s > 0 ? e : c : a;
  }
  for (_t = !1, a = new b(dn(m)), p = b.precision, b.precision = s = m.length * xt * 2; h = lr(a, e, 0, 1, 1), i = r.plus(h.times(n)), i.cmp(t) != 1; )
    r = n, n = i, i = c, c = l.plus(h.times(i)), l = i, i = e, e = a.minus(h.times(i)), a = i;
  return i = lr(t.minus(r), n, 0, 1, 1), l = l.plus(i.times(c)), r = r.plus(i.times(n)), l.s = c.s = v.s, d = lr(c, n, s, 1).minus(v).abs().cmp(lr(l, r, s, 1).minus(v).abs()) < 1 ? [c, n] : [l, r], b.precision = p, _t = !0, d;
};
Be.toHexadecimal = Be.toHex = function(t, e) {
  return Ik(this, 16, t, e);
};
Be.toNearest = function(t, e) {
  var r = this, n = r.constructor;
  if (r = new n(r), t == null) {
    if (!r.d) return r;
    t = new n(1), e = n.rounding;
  } else {
    if (t = new n(t), e === void 0 ? e = n.rounding : di(e, 0, 8), !r.d) return t.s ? r : t;
    if (!t.d)
      return t.s && (t.s = r.s), t;
  }
  return t.d[0] ? (_t = !1, r = lr(r, t, 0, e, 1).times(t), _t = !0, ft(r)) : (t.s = r.s, r = t), r;
};
Be.toNumber = function() {
  return +this;
};
Be.toOctal = function(t, e) {
  return Ik(this, 8, t, e);
};
Be.toPower = Be.pow = function(t) {
  var e, r, n, i, s, o, a = this, l = a.constructor, c = +(t = new l(t));
  if (!a.d || !t.d || !a.d[0] || !t.d[0]) return new l(Kr(+a, c));
  if (a = new l(a), a.eq(1)) return a;
  if (n = l.precision, s = l.rounding, t.eq(1)) return ft(a, n, s);
  if (e = Fn(t.e / xt), e >= t.d.length - 1 && (r = c < 0 ? -c : c) <= PAe)
    return i = cV(l, a, r, n), t.s < 0 ? new l(1).div(i) : ft(i, n, s);
  if (o = a.s, o < 0) {
    if (e < t.d.length - 1) return new l(NaN);
    if (t.d[e] & 1 || (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = Kr(+a, c), e = r == 0 || !isFinite(r) ? Fn(c * (Math.log("0." + dn(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, e > l.maxE + 1 || e < l.minE - 1 ? new l(e > 0 ? o / 0 : 0) : (_t = !1, l.rounding = a.s = 1, r = Math.min(12, (e + "").length), i = rE(t.times(Ll(a, n + r)), n), i.d && (i = ft(i, n + 5, 1), J0(i.d, n, s) && (e = n + 10, i = ft(rE(t.times(Ll(a, e + r)), e), e + 5, 1), +dn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = ft(i, n + 1, 0)))), i.s = o, _t = !0, l.rounding = s, ft(i, n, s));
};
Be.toPrecision = function(t, e) {
  var r, n = this, i = n.constructor;
  return t === void 0 ? r = Zo(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (di(t, 1, tu), e === void 0 ? e = i.rounding : di(e, 0, 8), n = ft(new i(n), t, e), r = Zo(n, t <= n.e || n.e <= i.toExpNeg, t)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Be.toSignificantDigits = Be.toSD = function(t, e) {
  var r = this, n = r.constructor;
  return t === void 0 ? (t = n.precision, e = n.rounding) : (di(t, 1, tu), e === void 0 ? e = n.rounding : di(e, 0, 8)), ft(new n(r), t, e);
};
Be.toString = function() {
  var t = this, e = t.constructor, r = Zo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() && !t.isZero() ? "-" + r : r;
};
Be.truncated = Be.trunc = function() {
  return ft(new this.constructor(this), this.e + 1, 1);
};
Be.valueOf = Be.toJSON = function() {
  var t = this, e = t.constructor, r = Zo(t, t.e <= e.toExpNeg || t.e >= e.toExpPos);
  return t.isNeg() ? "-" + r : r;
};
function dn(t) {
  var e, r, n, i = t.length - 1, s = "", o = t[0];
  if (i > 0) {
    for (s += o, e = 1; e < i; e++)
      n = t[e] + "", r = xt - n.length, r && (s += El(r)), s += n;
    o = t[e], n = o + "", r = xt - n.length, r && (s += El(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; ) o /= 10;
  return s + o;
}
function di(t, e, r) {
  if (t !== ~~t || t < e || t > r)
    throw Error(uc + t);
}
function J0(t, e, r, n) {
  var i, s, o, a;
  for (s = t[0]; s >= 10; s /= 10) --e;
  return --e < 0 ? (e += xt, i = 0) : (i = Math.ceil((e + 1) / xt), e %= xt), s = Kr(10, xt - e), a = t[i] % s | 0, n == null ? e < 3 ? (e == 0 ? a = a / 100 | 0 : e == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 100 | 0) == Kr(10, e - 2) - 1 || (a == s / 2 || a == 0) && (t[i + 1] / s / 100 | 0) == 0 : e < 4 ? (e == 0 ? a = a / 1e3 | 0 : e == 1 ? a = a / 100 | 0 : e == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (t[i + 1] / s / 1e3 | 0) == Kr(10, e - 3) - 1, o;
}
function V1(t, e, r) {
  for (var n, i = [0], s, o = 0, a = t.length; o < a; ) {
    for (s = i.length; s--; ) i[s] *= e;
    for (i[0] += X4.indexOf(t.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function OAe(t, e) {
  var r, n, i;
  if (e.isZero()) return e;
  n = e.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Zb(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), t.precision += r, e = ld(t, 1, e.times(i), new t(1));
  for (var s = r; s--; ) {
    var o = e.times(e);
    e = o.times(o).minus(o).times(8).plus(1);
  }
  return t.precision -= r, e;
}
var lr = /* @__PURE__ */ function() {
  function t(n, i, s) {
    var o, a = 0, l = n.length;
    for (n = n.slice(); l--; )
      o = n[l] * i + a, n[l] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function e(n, i, s, o) {
    var a, l;
    if (s != o)
      l = s > o ? 1 : -1;
    else
      for (a = l = 0; a < s; a++)
        if (n[a] != i[a]) {
          l = n[a] > i[a] ? 1 : -1;
          break;
        }
    return l;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; ) n.shift();
  }
  return function(n, i, s, o, a, l) {
    var c, p, h, d, v, m, b, f, E, A, x, g, w, _, S, R, L, F, z, j, W = n.constructor, te = n.s == i.s ? 1 : -1, le = n.d, ce = i.d;
    if (!le || !le[0] || !ce || !ce[0])
      return new W(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (le ? ce && le[0] == ce[0] : !ce) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          le && le[0] == 0 || !ce ? te * 0 : te / 0
        )
      );
    for (l ? (v = 1, p = n.e - i.e) : (l = Gs, v = xt, p = Fn(n.e / v) - Fn(i.e / v)), z = ce.length, L = le.length, E = new W(te), A = E.d = [], h = 0; ce[h] == (le[h] || 0); h++) ;
    if (ce[h] > (le[h] || 0) && p--, s == null ? (_ = s = W.precision, o = W.rounding) : a ? _ = s + (n.e - i.e) + 1 : _ = s, _ < 0)
      A.push(1), m = !0;
    else {
      if (_ = _ / v + 2 | 0, h = 0, z == 1) {
        for (d = 0, ce = ce[0], _++; (h < L || d) && _--; h++)
          S = d * l + (le[h] || 0), A[h] = S / ce | 0, d = S % ce | 0;
        m = d || h < L;
      } else {
        for (d = l / (ce[0] + 1) | 0, d > 1 && (ce = t(ce, d, l), le = t(le, d, l), z = ce.length, L = le.length), R = z, x = le.slice(0, z), g = x.length; g < z; ) x[g++] = 0;
        j = ce.slice(), j.unshift(0), F = ce[0], ce[1] >= l / 2 && ++F;
        do
          d = 0, c = e(ce, x, z, g), c < 0 ? (w = x[0], z != g && (w = w * l + (x[1] || 0)), d = w / F | 0, d > 1 ? (d >= l && (d = l - 1), b = t(ce, d, l), f = b.length, g = x.length, c = e(b, x, f, g), c == 1 && (d--, r(b, z < f ? j : ce, f, l))) : (d == 0 && (c = d = 1), b = ce.slice()), f = b.length, f < g && b.unshift(0), r(x, b, g, l), c == -1 && (g = x.length, c = e(ce, x, z, g), c < 1 && (d++, r(x, z < g ? j : ce, g, l))), g = x.length) : c === 0 && (d++, x = [0]), A[h++] = d, c && x[0] ? x[g++] = le[R] || 0 : (x = [le[R]], g = 1);
        while ((R++ < L || x[0] !== void 0) && _--);
        m = x[0] !== void 0;
      }
      A[0] || A.shift();
    }
    if (v == 1)
      E.e = p, nV = m;
    else {
      for (h = 1, d = A[0]; d >= 10; d /= 10) h++;
      E.e = h + p * v - 1, ft(E, a ? s + E.e + 1 : s, o, m);
    }
    return E;
  };
}();
function ft(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, v = t.constructor;
  e: if (e != null) {
    if (h = t.d, !h) return t;
    for (i = 1, a = h[0]; a >= 10; a /= 10) i++;
    if (s = e - i, s < 0)
      s += xt, o = e, p = h[d = 0], l = p / Kr(10, i - o - 1) % 10 | 0;
    else if (d = Math.ceil((s + 1) / xt), a = h.length, d >= a)
      if (n) {
        for (; a++ <= d; ) h.push(0);
        p = l = 0, i = 1, s %= xt, o = s - xt + 1;
      } else
        break e;
    else {
      for (p = a = h[d], i = 1; a >= 10; a /= 10) i++;
      s %= xt, o = s - xt + i, l = o < 0 ? 0 : p / Kr(10, i - o - 1) % 10 | 0;
    }
    if (n = n || e < 0 || h[d + 1] !== void 0 || (o < 0 ? p : p % Kr(10, i - o - 1)), c = r < 4 ? (l || n) && (r == 0 || r == (t.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (s > 0 ? o > 0 ? p / Kr(10, i - o) : 0 : h[d - 1]) % 10 & 1 || r == (t.s < 0 ? 8 : 7)), e < 1 || !h[0])
      return h.length = 0, c ? (e -= t.e + 1, h[0] = Kr(10, (xt - e % xt) % xt), t.e = -e || 0) : h[0] = t.e = 0, t;
    if (s == 0 ? (h.length = d, a = 1, d--) : (h.length = d + 1, a = Kr(10, xt - s), h[d] = o > 0 ? (p / Kr(10, i - o) % Kr(10, o) | 0) * a : 0), c)
      for (; ; )
        if (d == 0) {
          for (s = 1, o = h[0]; o >= 10; o /= 10) s++;
          for (o = h[0] += a, a = 1; o >= 10; o /= 10) a++;
          s != a && (t.e++, h[0] == Gs && (h[0] = 1));
          break;
        } else {
          if (h[d] += a, h[d] != Gs) break;
          h[d--] = 0, a = 1;
        }
    for (s = h.length; h[--s] === 0; ) h.pop();
  }
  return _t && (t.e > v.maxE ? (t.d = null, t.e = NaN) : t.e < v.minE && (t.e = 0, t.d = [0])), t;
}
function Zo(t, e, r) {
  if (!t.isFinite()) return hV(t);
  var n, i = t.e, s = dn(t.d), o = s.length;
  return e ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + El(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (t.e < 0 ? "e" : "e+") + t.e) : i < 0 ? (s = "0." + El(-i - 1) + s, r && (n = r - o) > 0 && (s += El(n))) : i >= o ? (s += El(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + El(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += El(n))), s;
}
function Yb(t, e) {
  var r = t[0];
  for (e *= xt; r >= 10; r /= 10) e++;
  return e;
}
function S2(t, e, r) {
  if (e > RAe)
    throw _t = !0, r && (t.precision = r), Error(iV);
  return ft(new t(x2), e, 1, !0);
}
function Mo(t, e, r) {
  if (e > tE) throw Error(iV);
  return ft(new t(E2), e, r, !0);
}
function lV(t) {
  var e = t.length - 1, r = e * xt + 1;
  if (e = t[e], e) {
    for (; e % 10 == 0; e /= 10) r--;
    for (e = t[0]; e >= 10; e /= 10) r++;
  }
  return r;
}
function El(t) {
  for (var e = ""; t--; ) e += "0";
  return e;
}
function cV(t, e, r, n) {
  var i, s = new t(1), o = Math.ceil(n / xt + 4);
  for (_t = !1; ; ) {
    if (r % 2 && (s = s.times(e), wR(s.d, o) && (i = !0)), r = Fn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    e = e.times(e), wR(e.d, o);
  }
  return _t = !0, s;
}
function bR(t) {
  return t.d[t.d.length - 1] & 1;
}
function uV(t, e, r) {
  for (var n, i, s = new t(e[0]), o = 0; ++o < e.length; ) {
    if (i = new t(e[o]), !i.s) {
      s = i;
      break;
    }
    n = s.cmp(i), (n === r || n === 0 && s.s === r) && (s = i);
  }
  return s;
}
function rE(t, e) {
  var r, n, i, s, o, a, l, c = 0, p = 0, h = 0, d = t.constructor, v = d.rounding, m = d.precision;
  if (!t.d || !t.d[0] || t.e > 17)
    return new d(t.d ? t.d[0] ? t.s < 0 ? 0 : 1 / 0 : 1 : t.s ? t.s < 0 ? 0 : t : NaN);
  for (e == null ? (_t = !1, l = m) : l = e, a = new d(0.03125); t.e > -2; )
    t = t.times(a), h += 5;
  for (n = Math.log(Kr(2, h)) / Math.LN10 * 2 + 5 | 0, l += n, r = s = o = new d(1), d.precision = l; ; ) {
    if (s = ft(s.times(t), l, 1), r = r.times(++p), a = o.plus(lr(s, r, l, 1)), dn(a.d).slice(0, l) === dn(o.d).slice(0, l)) {
      for (i = h; i--; ) o = ft(o.times(o), l, 1);
      if (e == null)
        if (c < 3 && J0(o.d, l - n, v, c))
          d.precision = l += 10, r = s = a = new d(1), p = 0, c++;
        else
          return ft(o, d.precision = m, v, _t = !0);
      else
        return d.precision = m, o;
    }
    o = a;
  }
}
function Ll(t, e) {
  var r, n, i, s, o, a, l, c, p, h, d, v = 1, m = 10, b = t, f = b.d, E = b.constructor, A = E.rounding, x = E.precision;
  if (b.s < 0 || !f || !f[0] || !b.e && f[0] == 1 && f.length == 1)
    return new E(f && !f[0] ? -1 / 0 : b.s != 1 ? NaN : f ? 0 : b);
  if (e == null ? (_t = !1, p = x) : p = e, E.precision = p += m, r = dn(f), n = r.charAt(0), Math.abs(s = b.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      b = b.times(t), r = dn(b.d), n = r.charAt(0), v++;
    s = b.e, n > 1 ? (b = new E("0." + r), s++) : b = new E(n + "." + r.slice(1));
  } else
    return c = S2(E, p + 2, x).times(s + ""), b = Ll(new E(n + "." + r.slice(1)), p - m).plus(c), E.precision = x, e == null ? ft(b, x, A, _t = !0) : b;
  for (h = b, l = o = b = lr(b.minus(1), b.plus(1), p, 1), d = ft(b.times(b), p, 1), i = 3; ; ) {
    if (o = ft(o.times(d), p, 1), c = l.plus(lr(o, new E(i), p, 1)), dn(c.d).slice(0, p) === dn(l.d).slice(0, p))
      if (l = l.times(2), s !== 0 && (l = l.plus(S2(E, p + 2, x).times(s + ""))), l = lr(l, new E(v), p, 1), e == null)
        if (J0(l.d, p - m, A, a))
          E.precision = p += m, c = o = b = lr(h.minus(1), h.plus(1), p, 1), d = ft(b.times(b), p, 1), i = a = 1;
        else
          return ft(l, E.precision = x, A, _t = !0);
      else
        return E.precision = x, l;
    l = c, i += 2;
  }
}
function hV(t) {
  return String(t.s * t.s / 0);
}
function H1(t, e) {
  var r, n, i;
  for ((r = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (n = e.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +e.slice(n + 1), e = e.substring(0, n)) : r < 0 && (r = e.length), n = 0; e.charCodeAt(n) === 48; n++) ;
  for (i = e.length; e.charCodeAt(i - 1) === 48; --i) ;
  if (e = e.slice(n, i), e) {
    if (i -= n, t.e = r = r - n - 1, t.d = [], n = (r + 1) % xt, r < 0 && (n += xt), n < i) {
      for (n && t.d.push(+e.slice(0, n)), i -= xt; n < i; ) t.d.push(+e.slice(n, n += xt));
      e = e.slice(n), n = xt - e.length;
    } else
      n -= i;
    for (; n--; ) e += "0";
    t.d.push(+e), _t && (t.e > t.constructor.maxE ? (t.d = null, t.e = NaN) : t.e < t.constructor.minE && (t.e = 0, t.d = [0]));
  } else
    t.e = 0, t.d = [0];
  return t;
}
function TAe(t, e) {
  var r, n, i, s, o, a, l, c, p;
  if (e.indexOf("_") > -1) {
    if (e = e.replace(/(\d)_(?=\d)/g, "$1"), aV.test(e)) return H1(t, e);
  } else if (e === "Infinity" || e === "NaN")
    return +e || (t.s = NaN), t.e = NaN, t.d = null, t;
  if (CAe.test(e))
    r = 16, e = e.toLowerCase();
  else if (_Ae.test(e))
    r = 2;
  else if (IAe.test(e))
    r = 8;
  else
    throw Error(uc + e);
  for (s = e.search(/p/i), s > 0 ? (l = +e.slice(s + 1), e = e.substring(2, s)) : e = e.slice(2), s = e.indexOf("."), o = s >= 0, n = t.constructor, o && (e = e.replace(".", ""), a = e.length, s = a - s, i = cV(n, new n(r), s, s * 2)), c = V1(e, r, Gs), p = c.length - 1, s = p; c[s] === 0; --s) c.pop();
  return s < 0 ? new n(t.s * 0) : (t.e = Yb(c, p), t.d = c, _t = !1, o && (t = lr(t, i, a * 4)), l && (t = t.times(Math.abs(l) < 54 ? Kr(2, l) : Ns.pow(2, l))), _t = !0, t);
}
function LAe(t, e) {
  var r, n = e.d.length;
  if (n < 3)
    return e.isZero() ? e : ld(t, 2, e, e);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, e = e.times(1 / Zb(5, r)), e = ld(t, 2, e, e);
  for (var i, s = new t(5), o = new t(16), a = new t(20); r--; )
    i = e.times(e), e = e.times(s.plus(i.times(o.times(i).minus(a))));
  return e;
}
function ld(t, e, r, n, i) {
  var s, o, a, l, c = t.precision, p = Math.ceil(c / xt);
  for (_t = !1, l = r.times(r), a = new t(n); ; ) {
    if (o = lr(a.times(l), new t(e++ * e++), c, 1), a = i ? n.plus(o) : n.minus(o), n = lr(o.times(l), new t(e++ * e++), c, 1), o = a.plus(n), o.d[p] !== void 0) {
      for (s = p; o.d[s] === a.d[s] && s--; ) ;
      if (s == -1) break;
    }
    s = a, a = n, n = o, o = s;
  }
  return _t = !0, o.d.length = p + 1, o;
}
function Zb(t, e) {
  for (var r = t; --e; ) r *= t;
  return r;
}
function pV(t, e) {
  var r, n = e.s < 0, i = Mo(t, t.precision, 1), s = i.times(0.5);
  if (e = e.abs(), e.lte(s))
    return va = n ? 4 : 1, e;
  if (r = e.divToInt(i), r.isZero())
    va = n ? 3 : 2;
  else {
    if (e = e.minus(r.times(i)), e.lte(s))
      return va = bR(r) ? n ? 2 : 3 : n ? 4 : 1, e;
    va = bR(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return e.minus(i).abs();
}
function Ik(t, e, r, n) {
  var i, s, o, a, l, c, p, h, d, v = t.constructor, m = r !== void 0;
  if (m ? (di(r, 1, tu), n === void 0 ? n = v.rounding : di(n, 0, 8)) : (r = v.precision, n = v.rounding), !t.isFinite())
    p = hV(t);
  else {
    for (p = Zo(t), o = p.indexOf("."), m ? (i = 2, e == 16 ? r = r * 4 - 3 : e == 8 && (r = r * 3 - 2)) : i = e, o >= 0 && (p = p.replace(".", ""), d = new v(1), d.e = p.length - o, d.d = V1(Zo(d), 10, i), d.e = d.d.length), h = V1(p, 10, i), s = l = h.length; h[--l] == 0; ) h.pop();
    if (!h[0])
      p = m ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (t = new v(t), t.d = h, t.e = s, t = lr(t, d, r, n, 0, i), h = t.d, s = t.e, c = nV), o = h[r], a = i / 2, c = c || h[r + 1] !== void 0, c = n < 4 ? (o !== void 0 || c) && (n === 0 || n === (t.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || c || n === 6 && h[r - 1] & 1 || n === (t.s < 0 ? 8 : 7)), h.length = r, c)
        for (; ++h[--r] > i - 1; )
          h[r] = 0, r || (++s, h.unshift(1));
      for (l = h.length; !h[l - 1]; --l) ;
      for (o = 0, p = ""; o < l; o++) p += X4.charAt(h[o]);
      if (m) {
        if (l > 1)
          if (e == 16 || e == 8) {
            for (o = e == 16 ? 4 : 3, --l; l % o; l++) p += "0";
            for (h = V1(p, i, e), l = h.length; !h[l - 1]; --l) ;
            for (o = 1, p = "1."; o < l; o++) p += X4.charAt(h[o]);
          } else
            p = p.charAt(0) + "." + p.slice(1);
        p = p + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; ) p = "0" + p;
        p = "0." + p;
      } else if (++s > l) for (s -= l; s--; ) p += "0";
      else s < l && (p = p.slice(0, s) + "." + p.slice(s));
    }
    p = (e == 16 ? "0x" : e == 2 ? "0b" : e == 8 ? "0o" : "") + p;
  }
  return t.s < 0 ? "-" + p : p;
}
function wR(t, e) {
  if (t.length > e)
    return t.length = e, !0;
}
function MAe(t) {
  return new this(t).abs();
}
function NAe(t) {
  return new this(t).acos();
}
function DAe(t) {
  return new this(t).acosh();
}
function $Ae(t, e) {
  return new this(t).plus(e);
}
function jAe(t) {
  return new this(t).asin();
}
function BAe(t) {
  return new this(t).asinh();
}
function FAe(t) {
  return new this(t).atan();
}
function zAe(t) {
  return new this(t).atanh();
}
function UAe(t, e) {
  t = new this(t), e = new this(e);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !t.s || !e.s ? r = new this(NaN) : !t.d && !e.d ? (r = Mo(this, s, 1).times(e.s > 0 ? 0.25 : 0.75), r.s = t.s) : !e.d || t.isZero() ? (r = e.s < 0 ? Mo(this, n, i) : new this(0), r.s = t.s) : !t.d || e.isZero() ? (r = Mo(this, s, 1).times(0.5), r.s = t.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(lr(t, e, s, 1)), e = Mo(this, s, 1), this.precision = n, this.rounding = i, r = t.s < 0 ? r.minus(e) : r.plus(e)) : r = this.atan(lr(t, e, s, 1)), r;
}
function VAe(t) {
  return new this(t).cbrt();
}
function HAe(t) {
  return ft(t = new this(t), t.e + 1, 2);
}
function GAe(t, e, r) {
  return new this(t).clamp(e, r);
}
function WAe(t) {
  if (!t || typeof t != "object") throw Error(Kb + "Object expected");
  var e, r, n, i = t.defaults === !0, s = [
    "precision",
    1,
    tu,
    "rounding",
    0,
    8,
    "toExpNeg",
    -9e15,
    0,
    "toExpPos",
    0,
    J4,
    "maxE",
    0,
    J4,
    "minE",
    -9e15,
    0,
    "modulo",
    0,
    9
  ];
  for (e = 0; e < s.length; e += 3)
    if (r = s[e], i && (this[r] = eE[r]), (n = t[r]) !== void 0)
      if (Fn(n) === n && n >= s[e + 1] && n <= s[e + 2]) this[r] = n;
      else throw Error(uc + r + ": " + n);
  if (r = "crypto", i && (this[r] = eE[r]), (n = t[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(sV);
      else
        this[r] = !1;
    else
      throw Error(uc + r + ": " + n);
  return this;
}
function qAe(t) {
  return new this(t).cos();
}
function QAe(t) {
  return new this(t).cosh();
}
function dV(t) {
  var e, r, n;
  function i(s) {
    var o, a, l, c = this;
    if (!(c instanceof i)) return new i(s);
    if (c.constructor = i, xR(s)) {
      c.s = s.s, _t ? !s.d || s.e > i.maxE ? (c.e = NaN, c.d = null) : s.e < i.minE ? (c.e = 0, c.d = [0]) : (c.e = s.e, c.d = s.d.slice()) : (c.e = s.e, c.d = s.d ? s.d.slice() : s.d);
      return;
    }
    if (l = typeof s, l === "number") {
      if (s === 0) {
        c.s = 1 / s < 0 ? -1 : 1, c.e = 0, c.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, c.s = -1) : c.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10) o++;
        _t ? o > i.maxE ? (c.e = NaN, c.d = null) : o < i.minE ? (c.e = 0, c.d = [0]) : (c.e = o, c.d = [s]) : (c.e = o, c.d = [s]);
        return;
      }
      if (s * 0 !== 0) {
        s || (c.s = NaN), c.e = NaN, c.d = null;
        return;
      }
      return H1(c, s.toString());
    }
    if (l === "string")
      return (a = s.charCodeAt(0)) === 45 ? (s = s.slice(1), c.s = -1) : (a === 43 && (s = s.slice(1)), c.s = 1), aV.test(s) ? H1(c, s) : TAe(c, s);
    if (l === "bigint")
      return s < 0 ? (s = -s, c.s = -1) : c.s = 1, H1(c, s.toString());
    throw Error(uc + s);
  }
  if (i.prototype = Be, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = WAe, i.clone = dV, i.isDecimal = xR, i.abs = MAe, i.acos = NAe, i.acosh = DAe, i.add = $Ae, i.asin = jAe, i.asinh = BAe, i.atan = FAe, i.atanh = zAe, i.atan2 = UAe, i.cbrt = VAe, i.ceil = HAe, i.clamp = GAe, i.cos = qAe, i.cosh = QAe, i.div = KAe, i.exp = YAe, i.floor = ZAe, i.hypot = JAe, i.ln = XAe, i.log = eke, i.log10 = rke, i.log2 = tke, i.max = nke, i.min = ike, i.mod = ske, i.mul = oke, i.pow = ake, i.random = lke, i.round = cke, i.sign = uke, i.sin = hke, i.sinh = pke, i.sqrt = dke, i.sub = fke, i.sum = gke, i.tan = mke, i.tanh = yke, i.trunc = vke, t === void 0 && (t = {}), t && t.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], e = 0; e < n.length; ) t.hasOwnProperty(r = n[e++]) || (t[r] = this[r]);
  return i.config(t), i;
}
function KAe(t, e) {
  return new this(t).div(e);
}
function YAe(t) {
  return new this(t).exp();
}
function ZAe(t) {
  return ft(t = new this(t), t.e + 1, 3);
}
function JAe() {
  var t, e, r = new this(0);
  for (_t = !1, t = 0; t < arguments.length; )
    if (e = new this(arguments[t++]), e.d)
      r.d && (r = r.plus(e.times(e)));
    else {
      if (e.s)
        return _t = !0, new this(1 / 0);
      r = e;
    }
  return _t = !0, r.sqrt();
}
function xR(t) {
  return t instanceof Ns || t && t.toStringTag === oV || !1;
}
function XAe(t) {
  return new this(t).ln();
}
function eke(t, e) {
  return new this(t).log(e);
}
function tke(t) {
  return new this(t).log(2);
}
function rke(t) {
  return new this(t).log(10);
}
function nke() {
  return uV(this, arguments, -1);
}
function ike() {
  return uV(this, arguments, 1);
}
function ske(t, e) {
  return new this(t).mod(e);
}
function oke(t, e) {
  return new this(t).mul(e);
}
function ake(t, e) {
  return new this(t).pow(e);
}
function lke(t) {
  var e, r, n, i, s = 0, o = new this(1), a = [];
  if (t === void 0 ? t = this.precision : di(t, 1, tu), n = Math.ceil(t / xt), this.crypto)
    if (crypto.getRandomValues)
      for (e = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = e[s], i >= 429e7 ? e[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (e = crypto.randomBytes(n *= 4); s < n; )
        i = e[s] + (e[s + 1] << 8) + (e[s + 2] << 16) + ((e[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(e, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(sV);
  else for (; s < n; ) a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], t %= xt, n && t && (i = Kr(10, xt - t), a[s] = (n / i | 0) * i); a[s] === 0; s--) a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= xt) a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10) n++;
    n < xt && (r -= xt - n);
  }
  return o.e = r, o.d = a, o;
}
function cke(t) {
  return ft(t = new this(t), t.e + 1, this.rounding);
}
function uke(t) {
  return t = new this(t), t.d ? t.d[0] ? t.s : 0 * t.s : t.s || NaN;
}
function hke(t) {
  return new this(t).sin();
}
function pke(t) {
  return new this(t).sinh();
}
function dke(t) {
  return new this(t).sqrt();
}
function fke(t, e) {
  return new this(t).sub(e);
}
function gke() {
  var t = 0, e = arguments, r = new this(e[t]);
  for (_t = !1; r.s && ++t < e.length; ) r = r.plus(e[t]);
  return _t = !0, ft(r, this.precision, this.rounding);
}
function mke(t) {
  return new this(t).tan();
}
function yke(t) {
  return new this(t).tanh();
}
function vke(t) {
  return ft(t = new this(t), t.e + 1, 1);
}
Be[Symbol.for("nodejs.util.inspect.custom")] = Be.toString;
Be[Symbol.toStringTag] = "Decimal";
var Ns = Be.constructor = dV(eE);
x2 = new Ns(x2);
E2 = new Ns(E2);
function A2(t, e, r, n = !0) {
  const i = new Ns(t), s = new Ns(e), o = s.sub(i), a = o.div(10);
  let l, c, p;
  l = new Ns(10).pow(a.log(10).ceil()), l.div(o).gte(0.8) ? l = l.div(10) : l.div(o).gte(0.5) ? l = l.div(4) : l.div(o).gte(0.2) && (l = l.div(2)), c = i.div(l).floor().mul(l), p = s.div(l).ceil().mul(l);
  const h = new Intl.NumberFormat(void 0, { maximumFractionDigits: 5, useGrouping: n }), d = new Array(p.sub(c).div(l).toNumber() + 1).fill(0).map((v, m) => h.format(+c.add(l.mul(m))) + (r ? "%" : ""));
  return {
    min: c.toNumber(),
    max: p.toNumber(),
    range: p.sub(c).toNumber(),
    labelTiers: [d]
  };
}
function bke(t, e, r, n, i = !0) {
  if (r < 0)
    throw new Error("tick interval must be > 0");
  const s = t - t % r, o = e + (r - e % r), a = new Intl.NumberFormat(void 0, { maximumFractionDigits: 5, useGrouping: i });
  return {
    min: s,
    max: o,
    range: o - s,
    labelTiers: [new Array((o - s) / r + 1).fill(0).map((l, c) => a.format(s + r * c) + "")]
  };
}
class Jb {
  constructor(e, r) {
    this._store = e, this._options = r, r.xTiers ? this._xLabelInfo = { labelTiers: r.xTiers } : this._computeXLabelInfo(), r.yTiers ? this._yLabelInfo = { labelTiers: r.yTiers } : this._computeYLabelInfo();
  }
  get xLabelInfo() {
    return this._xLabelInfo;
  }
  get yLabelInfo() {
    return this._yLabelInfo;
  }
  get options() {
    return this._options;
  }
  get horizFacet() {
    return this._store.model.getAxisFacet(
      this._options.isXVertical ? "vert" : "horiz"
    );
  }
  get vertFacet() {
    return this._store.model.getAxisFacet(
      this._options.isXVertical ? "horiz" : "vert"
    );
  }
  getFacetForOrientation(e) {
    return e === "horiz" ? this.horizFacet : this.vertFacet;
  }
  updateYRange() {
    this._computeYLabelInfo();
  }
  _computeXLabels(e, r) {
    return A2(
      this._store.settings.axis.x.minValue === "unset" ? e : this._store.settings.axis.x.minValue,
      this._store.settings.axis.x.maxValue === "unset" ? r : this._store.settings.axis.x.maxValue,
      !1
    );
  }
  _computeYLabels(e, r) {
    return this._store.settings.axis.y.interval !== "unset" ? bke(e, r, this._store.settings.axis.y.interval) : A2(e, r, !1);
  }
  _computeXLabelInfo() {
    if (this._options.xValues)
      this._xLabelInfo = this._computeXLabels(
        Math.min(...this._options.xValues),
        Math.max(...this._options.xValues)
      );
    else {
      const e = this._store.model.series[0].datapoints.map(
        (r) => Wr(r.facetBox("x"), this._store.getFormatType("horizTick"))
      );
      this._xLabelInfo = {
        labelTiers: [e]
      };
    }
  }
  _computeYLabelInfo() {
    const e = this._store.settings.axis.y.minValue === "unset" ? this._options.yMin ?? Math.min(...this._options.yValues) : this._store.settings.axis.y.minValue, r = this._store.settings.axis.y.maxValue === "unset" ? this._options.yMax ?? Math.max(...this._options.yValues) : this._store.settings.axis.y.maxValue;
    this._yLabelInfo = this._computeYLabels(e, r);
  }
}
class fV extends Ck {
  constructor(e, r) {
    super(e, r);
  }
  _init() {
    super._init(), this._axisInfo = new Jb(this._store, {
      yValues: this._store.model.allFacetValues("y").map((e) => e.value)
    });
  }
  seriesInNavOrder() {
    const e = this._store.model.dependentFacetKeys[0];
    return this._store.model.series.toSorted((r, n) => n.datapoints[0].facetValueNumericized(e) - r.datapoints[0].facetValueNumericized(e));
  }
}
function Pk(t, e) {
  const r = [], n = e.some((s) => s.equals(t));
  if (e.length >= (n ? 2 : 1)) {
    const s = n ? $i.other : void 0;
    r.push(qn($i.comparisonSelectedDatapoints, { other: s }));
    const o = e.toSorted((a, l) => a.datapoint.facetValueNumericized("y") > l.datapoint.facetValueNumericized("y") ? -1 : 1);
    for (const a of o)
      if (!a.equals(t)) {
        const l = a.datapoint.facetValueNumericized("y"), c = t.datapoint.facetValueNumericized("y"), p = yV(c, l), h = mV[p.relationship].msg, d = p.diff !== 0 ? qn("${diff:number} ", { diff: p.diff }) : void 0;
        r.push(p2e(qn(
          "${diff:string?}${comparatorMsg:string} ${seriesName:string} ${datapointXY:string}",
          { diff: d, comparatorMsg: h, seriesName: a.seriesKey, datapointXY: L0(a.datapoint, "raw") }
        )));
      }
  }
  return r;
}
function Rk(t, e, r) {
  let n = qt("getDatapointMinMax");
  const i = [], s = t.series.filter((d) => d.key === r)[0];
  let o = [], a = [];
  for (let d of s.rawData)
    o.push(Number(d.y));
  for (let d of t.series)
    for (let v of d.rawData)
      a.push(Number(v.y));
  const l = Math.min(...o), c = Math.min(...a), p = Math.max(...o), h = Math.max(...a);
  return e == c ? i.push($i.seriesChartMin) : e == l && i.push($i.seriesMin), e == h ? i.push($i.seriesChartMax) : e == p && i.push($i.seriesMax), n.info(i), i;
}
function gV(t, e) {
  const r = [];
  let n, i;
  return (n = ER(t, e, "prev")) && r.push(n), (i = ER(t, e, "next")) && r.push(i), d2e(r, !0);
}
function ER(t, e, r) {
  let n = qt("describeAdjacentDatapointComparison");
  const i = e[r];
  if (!i)
    return null;
  const s = `${i.series[i.index].facetBox("x").raw}, ${i.series[i.index].facetBox("y").raw}`;
  n.info(e.index);
  const o = t.series.filter((m) => m.key == e.seriesKey)[0], a = t.series.filter((m) => m.key == i.seriesKey)[0], l = o[e.index].facetBox("y").raw, c = a[i.index].facetBox("y").raw, p = yV(l, c);
  n.info(p);
  const h = mV[p.relationship][r], d = r === "prev" ? p.percentagePrev : p.percentageNext;
  if (p.diff === 0)
    return qn("${comparator:string} ${otherLabel:string}", { comparator: h, otherLabel: s });
  const v = r === "prev" ? "from" : "in";
  return qn(
    "${comparator:string} ${diff:number} (${percent:number#.1}%) ${preposition:string} ${otherLabel:string}",
    { comparator: h, diff: p.diff, percent: d, preposition: v, otherLabel: s }
  );
}
const $i = {
  comparisonSelectedDatapoints: "Comparison to${other:string?} selected datapoints",
  other: " other",
  seriesMin: "Series low",
  seriesChartMin: "Series low and chart low",
  seriesMax: "Series high",
  seriesChartMax: "Series high and chart high",
  seriesKeyLength: "${seriesKey:string}. ${datapointCount:number} datapoints",
  datapointKeyLength: "${seriesKey:string} ${datapointXY:string}. Datapoint ${datapointIndex:number} of ${datapointCount:number}.",
  percentageOfSeries: "${datapointXY:string}% of total amount in series: ${seriesKey:string}. Datapoint ${datapointIndex:number} of ${datapointCount:number}.",
  percentageOfChart: "${datapointXY:string}% of total amount in chart: ${chartKey:string}. Datapoint ${datapointIndex:number} of ${datapointCount:number}."
}, mV = {
  equal: {
    msg: "equal to",
    prev: "stayed the same from",
    next: "will stay the same in"
  },
  greater: {
    msg: "more than",
    prev: "grew by",
    next: "will decrease by"
  },
  less: {
    msg: "less than",
    prev: "decreased by",
    next: "will grow by"
  }
};
function yV(t, e) {
  qt("compare").info(e);
  const n = {
    diff: 0
  };
  if (t === e)
    n.relationship = "equal";
  else {
    n.relationship = t > e ? "greater" : "less";
    const i = new Ns(Math.min(t, e)), s = new Ns(Math.max(t, e));
    n.diff = s.sub(i).toNumber();
    const o = new Ns(t), a = new Ns(e);
    o && (n.percentageNext = a.sub(o).dividedBy(o).times(100).toNumber()), a && (n.percentagePrev = o.sub(a).dividedBy(a).times(100).toNumber());
  }
  return n;
}
class wke extends fV {
  constructor(e, r) {
    super(e, r), this._prevHighlightNavcode = "", this.log = qt("LineChartInfo");
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "textfield",
      key: "type.line.lineWidth",
      label: "Line width",
      options: {
        inputType: "number",
        min: 1,
        max: this._store.settings.type.line.lineWidthMax
      },
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "chart.isDrawSymbols",
      label: "Show symbols",
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "chart.showPopups",
      label: "Show popups",
      parentView: "controlPanel.tabs.chart.popups"
    });
  }
  get settings() {
    return super.settings;
  }
  settingDidChange(e, r, n) {
    ["type.line.isTrendNavigationModeEnabled"].includes(e) && ([this._navMap, this._altNavMap] = [this._altNavMap, this._navMap], this._navMap.root.goTo("top", {})), super.settingDidChange(e, r, n);
  }
  async storeDidChange(e, r) {
    await super.storeDidChange(e, r), e === "seriesAnalyses" && this._createSequenceNavNodes();
  }
  _canCreateSequenceNavNodes() {
    return !!this._navMap && Object.keys(this._store.seriesAnalyses).length === this._store.model.seriesKeys.length && !!this._store.seriesAnalyses[this._store.model.seriesKeys[0]];
  }
  _createNavMap() {
    super._createNavMap(), this._createSequenceNavNodes();
  }
  _createSequenceNavNodes() {
    if (!this._canCreateSequenceNavNodes()) return;
    const e = [];
    this._altNavMap = this._navMap.clone(), this._altNavMap.root.query("series").forEach((r) => {
      e.length && r.connect("left", e.at(-1).at(-1));
      const n = this._store.seriesAnalyses[r.options.seriesKey], i = r.allNodes("right", "datapoint"), s = [];
      n.sequences.forEach((o) => {
        const a = new Ia(r.layer, "sequence", {
          seriesKey: r.options.seriesKey,
          start: o.start,
          end: o.end
        }, this._store);
        s.push(a);
      }), e.push(s), s.slice(0, -1).forEach((o, a) => {
        o.connect("right", s[a + 1]);
      }), r.connect("right", s[0]), i[0].disconnect("left", !1), i.at(-1).disconnect("right"), s.forEach((o) => {
        o.connect(
          "in",
          i[o.options.start],
          !i[o.options.start].getLink("out")
        );
        for (let a = o.options.start + 1; a < o.options.end; a++)
          i[a].connect("out", o, !1);
        o.peekNode("right", 1) && i[o.options.end - 1].connect("in", o.peekNode("right", 1), !1);
      });
    }), e.slice(0, -1).forEach((r, n) => {
      r.forEach((i) => {
        const s = e[n + 1].find((o) => o.options.start <= i.options.start && o.options.end > i.options.start);
        i.connect("down", s, !1);
      });
    }), e.slice(1).forEach((r, n) => {
      r.forEach((i, s) => {
        const o = e[n].find((a) => a.options.start <= i.options.start && a.options.end > i.options.start);
        i.connect("up", o, !1);
      });
    });
  }
  noticePosted(e, r) {
    if (super.noticePosted(e, r), this._store.settings.ui.isNarrativeHighlightEnabled)
      if (e === "utteranceBoundary") {
        const n = r;
        this._prevHighlightNavcode = this._doHighlight(n, this._prevHighlightNavcode);
      } else e === "utteranceEnd" && (this._store.paraChart.captionBox.highlightManualOverride || (this._store.clearHighlight(), this._store.clearAllSeriesLowlights()), this._prevHighlightNavcode && (this.didRemoveHighlight(this._prevHighlightNavcode), this._prevHighlightNavcode = ""));
  }
  _doHighlight(e, r) {
    if (e.navcode) {
      if (e.navcode.startsWith("series")) {
        const n = e.navcode.split(/-/);
        this._store.lowlightOtherSeries(...n.slice(1));
      } else
        this._store.clearHighlight(), this._store.highlight(e.navcode), r && this.didRemoveHighlight(r), this.didAddHighlight(e.navcode);
      r = e.navcode;
    } else
      this._store.clearHighlight(), this._store.clearAllSeriesLowlights(), r && (this.didRemoveHighlight(r), r = "");
    return r;
  }
  legend() {
    const e = [...this._store.model.seriesKeys];
    return this._store.settings.legend.itemOrder === "alphabetical" && e.sort(), e.map((r) => ({
      label: r,
      color: this._store.seriesProperties.properties(r).color
    }));
  }
  // TODO: localize this text output
  // focused view: e.options!.focus
  // all visited datapoint views: e.options!.visited
  queryData() {
    const e = [], r = this._navMap.cursor;
    if (r.isNodeType("top"))
      e.push(`Displaying Chart: ${this._store.title}`);
    else if (r.isNodeType("series")) {
      const n = r.options.seriesKey, i = this._store.model.atKey(n).length;
      e.push(qn(
        $i.seriesKeyLength,
        { seriesKey: n, datapointCount: i }
      ));
    } else if (r.isNodeType("datapoint")) {
      const n = this._store.selectedDatapoints, i = r.options.seriesKey, s = r.options.index, o = this._store.model.atKey(i).datapoints[s], a = this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(i, s);
      if (e.push(qn(
        $i.datapointKeyLength,
        {
          seriesKey: i,
          datapointXY: L0(o, "raw"),
          datapointIndex: r.options.index + 1,
          datapointCount: this._store.model.atKey(i).length
        }
      )), n.size > 0) {
        const c = n.values().map((h) => {
          const d = on(h);
          return this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(d.seriesKey, d.index);
        }).toArray(), p = Pk(
          a,
          c
        );
        e.push(...p);
      } else {
        const c = gV(this._store.model, a);
        e.push(c);
      }
      const l = Rk(
        this._store.model,
        o.facetValueAsNumber("y"),
        i
      );
      e.push(...l);
    }
    this._store.announce(e);
  }
}
class xke {
  constructor(e, r) {
    this.chartInfo = e, this.key = r, this.stacks = {}, this.log = qt("BarCluster"), this.id = `barcluster-${Yn(this.key)}`, this.labelId = `tick-x-${this.id}`;
  }
  get index() {
    return Object.keys(this.chartInfo.clusteredData).indexOf(this.key);
  }
}
class SR {
  constructor(e, r) {
    this.cluster = e, this.key = r, this.bars = {}, this._label = null, this.id = `barstack-${Yn(this.cluster.key)}-${Yn(this.key)}`, this.labelId = `tick-x-${this.id}`;
  }
  get index() {
    return Object.keys(this.cluster.stacks).indexOf(this.key);
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._label = e;
  }
}
class AR extends Ck {
  constructor(e, r) {
    super(e, r);
  }
  _init() {
    super._init(), this._clusteredData = this._clusterData();
    const e = Object.values(this._clusteredData).flatMap((n) => Object.values(n.stacks).map(
      (i) => Object.values(i.bars).map((s) => s.value.value).reduce((s, o) => s + o, 0)
      //        + Object.values(s.bars).length*this.settings.stackInsideGap
    ));
    this._axisInfo = new Jb(this._store, {
      // xTiers: [this.paraview.store.model!.allFacetValues('x')!.map(x =>
      //   formatBox(x, 'barCluster', this.paraview.store))],
      xTiers: [Object.keys(this._clusteredData)],
      yValues: e,
      yMin: Math.min(0, Math.min(...e)),
      isXInterval: !0,
      // manifest can override this
      isXVertical: this._store.type === "bar"
    });
    const r = this._store.model.numSeries;
    this.settings.stacking === "standard" ? this._stacksPerCluster = 1 : this.settings.stacking === "none" && (this._stacksPerCluster = Math.ceil(r / 1));
  }
  get settings() {
    return super.settings;
  }
  get clusteredData() {
    return this._clusteredData;
  }
  get stacksPerCluster() {
    return this._stacksPerCluster;
  }
  _clusterData() {
    const e = this._store.settings.type[this._type], r = {}, n = this._store.model.series[0].datapoints.map((o) => o.facetBox("x")), i = [];
    for (const [o, a] of Wn(n)) {
      const l = Wr(o, this._store.getFormatType("barCluster"));
      let c = r[l];
      c || (c = new xke(this, l), r[l] = c, i.push(c));
    }
    const s = [...this._store.model.series];
    this._store.type === "column" && e.stacking === "standard" && s.reverse();
    for (const [o, a] of Wn(s))
      for (const [l, c] of Wn(o.datapoints.map((p) => p.facetBox("y")))) {
        let p, h;
        e.stacking === "standard" ? (h = "stack", p = i[c].stacks[h], p || (p = new SR(i[c], h), i[c].stacks[h] = p)) : e.stacking === "none" && (h = o.key, p = i[c].stacks[h], p || (p = new SR(i[c], h), i[c].stacks[h] = p)), p.bars[o.key] = {
          series: o.key,
          value: o.datapoints[c].facetBox("y")
        };
      }
    return r;
  }
  legend() {
    return this._store.settings.legend.itemOrder === "series" ? this._store.model.series.map((e) => ({
      label: e.getLabel(),
      color: this._store.seriesProperties.properties(e.key).color
    })) : this._store.model.seriesKeys.toSorted().map((e) => ({
      label: this._store.model.atKey(e).getLabel(),
      color: this._store.seriesProperties.properties(e).color
    }));
  }
  // TODO: localize this text output
  // focused view: e.options!.focus
  // all visited datapoint views: e.options!.visited
  queryData() {
    const e = [], r = this._navMap.cursor;
    if (r.isNodeType("top"))
      e.push(`Displaying Chart: ${this._store.title}`);
    else if (r.isNodeType("series")) {
      const n = r.options.seriesKey, i = this._store.model.atKey(n).length;
      e.push(qn(
        $i.seriesKeyLength,
        { seriesKey: n, datapointCount: i }
      ));
    } else if (r.isNodeType("datapoint")) {
      const n = this._store.selectedDatapoints, i = r.options.seriesKey, s = r.options.index, o = this._store.model.atKey(i).datapoints[s], a = this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(i, s);
      if (e.push(qn(
        $i.datapointKeyLength,
        {
          seriesKey: i,
          datapointXY: L0(o, "raw"),
          datapointIndex: r.options.index + 1,
          datapointCount: this._store.model.atKey(i).length
        }
      )), n.size > 0) {
        const c = n.values().map((h) => {
          const d = on(h);
          return this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(d.seriesKey, d.index);
        }).toArray(), p = Pk(
          a,
          c
        );
        e.push(...p);
      } else {
        const c = gV(this._store.model, a);
        e.push(c);
      }
      const l = Rk(
        this._store.model,
        o.facetValueAsNumber("y"),
        i
      );
      e.push(...l);
    }
    this._store.announce(e);
  }
}
class kR extends tV {
  constructor(e, r) {
    super(e, r);
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "slider",
      key: `type.${this._type}.orientationAngleOffset`,
      label: "Orientation",
      options: {
        min: 0,
        max: 360,
        step: 1,
        compact: !0,
        width: "8rem"
      },
      parentView: "controlPanel.tabs.chart.chart"
    });
    const e = ["", "category", "percentage:(value)"];
    this._store.settingControls.add({
      type: "dropdown",
      key: `type.${this._type}.insideLabels.contents`,
      label: "Inside labels:",
      options: { options: e },
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: `type.${this._type}.outsideLabels.contents`,
      label: "Outside labels:",
      options: { options: e },
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "textfield",
      key: `type.${this._type}.explode`,
      label: "Explode",
      options: {
        inputType: "text"
      },
      parentView: "controlPanel.tabs.chart.chart"
    });
  }
  _createNavMap() {
    super._createNavMap();
    const e = new w2(this._navMap, "slices");
    KSe.forEach((n) => {
      this._navMap.node("top", {}).connect(n, e);
    });
    const r = this._store.model.series[0].datapoints.map((n, i) => {
      const s = new Ia(e, "datapoint", {
        seriesKey: n.seriesKey,
        index: n.datapointIndex
      }, this._store);
      return s.connect("out", this._navMap.root), s.connect("up", this._navMap.root), s;
    });
    r.slice(0, -1).forEach((n, i) => {
      n.connect("right", e.get("datapoint", i + 1));
    }), r.at(-1).connect("right", r[0]);
  }
  legend() {
    const e = this._store.model.series[0].datapoints.map((n) => Wr(n.facetBox("x"), this._store.getFormatType("pieSliceLabel"))), r = this._store.model.series[0].datapoints.map((n) => Wr(n.facetBox("y"), this._store.getFormatType("pieSliceValue")));
    return e.map((n, i) => ({
      label: `${n}: ${r[i]}`,
      color: i,
      datapointIndex: i
    }));
  }
  playDatapoints(e) {
    this._sonifier.playDatapoints(e, { invert: !0, durationVariable: !0 });
  }
  playDir(e) {
  }
  playRiff(e, r) {
  }
  _sparkBrailleInfo() {
    return {
      data: this._navMap.cursor.isNodeType("datapoint") || this._navMap.cursor.isNodeType("series") ? JSON.stringify(this._store.model.atKey(
        this._navMap.cursor.options.seriesKey
      ).datapoints.map((e) => ({
        // XXX shouldn't assume x is string (or that we have an 'x' facet, for that matter)
        label: e.facetValue("x"),
        value: e.facetValueAsNumber("y")
      }))) : "0",
      isProportional: !0
    };
  }
  // TODO: localize this text output
  // focused view: e.options!.focus
  // all visited datapoint views: e.options!.visited
  queryData() {
    const e = [], r = this._navMap.cursor;
    if (r.isNodeType("top"))
      e.push(`Displaying Chart: ${this._store.title}`);
    else if (r.isNodeType("series")) {
      const n = r.options.seriesKey, i = this._store.model.atKey(n).length;
      e.push(qn(
        $i.seriesKeyLength,
        { seriesKey: n, datapointCount: i }
      ));
    } else if (r.isNodeType("datapoint")) {
      const n = this._store.selectedDatapoints, i = r.options.seriesKey, s = r.options.index, o = this._store.model.atKey(i).datapoints[s], a = this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(i, s);
      if (n.size) {
        const c = n.values().map((h) => {
          const d = on(h);
          return this._store.paraChart.paraView.documentView.chartLayers.dataLayer.datapointView(d.seriesKey, d.index);
        }).toArray(), p = Pk(
          a,
          c
        );
        e.push(...p);
      } else
        e.push(qn(
          $i.percentageOfChart,
          {
            chartKey: i,
            datapointXY: L0(o, "raw"),
            datapointIndex: r.options.index + 1,
            datapointCount: this._store.model.atKey(i).length
          }
        )), this._store.model.multi && e.push(qn(
          $i.percentageOfSeries,
          {
            seriesKey: i,
            datapointXY: L0(o, "raw"),
            datapointIndex: r.options.index + 1,
            datapointCount: this._store.model.atKey(i).length
          }
        ));
      const l = Rk(
        this._store.model,
        o.facetValueAsNumber("y"),
        i
      );
      e.push(...l);
    }
    this._store.announce(e);
  }
}
var Eke = Object.defineProperty, Ske = (t, e, r) => e in t ? Eke(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, rs = (t, e, r) => Ske(t, typeof e != "symbol" ? e + "" : e, r);
function Ake(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var _R = { exports: {} }, rx, CR;
function vV() {
  if (CR) return rx;
  CR = 1, rx = e;
  var t = +(Math.pow(2, 27) + 1);
  function e(r, n, i) {
    var s = r * n, o = t * r, a = o - r, l = o - a, c = r - l, p = t * n, h = p - n, d = p - h, v = n - d, m = s - l * d, b = m - c * d, f = b - l * v, E = c * v - f;
    return i ? (i[0] = E, i[1] = s, i) : [E, s];
  }
  return rx;
}
var nx, IR;
function kke() {
  if (IR) return nx;
  IR = 1, nx = e;
  function t(r, n) {
    var i = r + n, s = i - r, o = i - s, a = n - s, l = r - o, c = l + a;
    return c ? [c, i] : [i];
  }
  function e(r, n) {
    var i = r.length | 0, s = n.length | 0;
    if (i === 1 && s === 1)
      return t(r[0], n[0]);
    var o = i + s, a = new Array(o), l = 0, c = 0, p = 0, h = Math.abs, d = r[c], v = h(d), m = n[p], b = h(m), f, E;
    v < b ? (E = d, c += 1, c < i && (d = r[c], v = h(d))) : (E = m, p += 1, p < s && (m = n[p], b = h(m))), c < i && v < b || p >= s ? (f = d, c += 1, c < i && (d = r[c], v = h(d))) : (f = m, p += 1, p < s && (m = n[p], b = h(m)));
    for (var A = f + E, x = A - f, g = E - x, w = g, _ = A, S, R, L, F, z; c < i && p < s; )
      v < b ? (f = d, c += 1, c < i && (d = r[c], v = h(d))) : (f = m, p += 1, p < s && (m = n[p], b = h(m))), E = w, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = _ + A, R = S - _, L = S - R, F = A - R, z = _ - L, w = z + F, _ = S;
    for (; c < i; )
      f = d, E = w, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = _ + A, R = S - _, L = S - R, F = A - R, z = _ - L, w = z + F, _ = S, c += 1, c < i && (d = r[c]);
    for (; p < s; )
      f = m, E = w, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = _ + A, R = S - _, L = S - R, F = A - R, z = _ - L, w = z + F, _ = S, p += 1, p < s && (m = n[p]);
    return w && (a[l++] = w), _ && (a[l++] = _), l || (a[l++] = 0), a.length = l, a;
  }
  return nx;
}
var ix, PR;
function _ke() {
  if (PR) return ix;
  PR = 1, ix = t;
  function t(e, r, n) {
    var i = e + r, s = i - e, o = i - s, a = r - s, l = e - o;
    return n ? (n[0] = l + a, n[1] = i, n) : [l + a, i];
  }
  return ix;
}
var sx, RR;
function Cke() {
  if (RR) return sx;
  RR = 1;
  var t = vV(), e = _ke();
  sx = r;
  function r(n, i) {
    var s = n.length;
    if (s === 1) {
      var o = t(n[0], i);
      return o[0] ? o : [o[1]];
    }
    var a = new Array(2 * s), l = [0.1, 0.1], c = [0.1, 0.1], p = 0;
    t(n[0], i, l), l[0] && (a[p++] = l[0]);
    for (var h = 1; h < s; ++h) {
      t(n[h], i, c);
      var d = l[1];
      e(d, c[0], l), l[0] && (a[p++] = l[0]);
      var v = c[1], m = l[1], b = v + m, f = b - v, E = m - f;
      l[1] = b, E && (a[p++] = E);
    }
    return l[1] && (a[p++] = l[1]), p === 0 && (a[p++] = 0), a.length = p, a;
  }
  return sx;
}
var ox, OR;
function Ike() {
  if (OR) return ox;
  OR = 1, ox = e;
  function t(r, n) {
    var i = r + n, s = i - r, o = i - s, a = n - s, l = r - o, c = l + a;
    return c ? [c, i] : [i];
  }
  function e(r, n) {
    var i = r.length | 0, s = n.length | 0;
    if (i === 1 && s === 1)
      return t(r[0], -n[0]);
    var o = i + s, a = new Array(o), l = 0, c = 0, p = 0, h = Math.abs, d = r[c], v = h(d), m = -n[p], b = h(m), f, E;
    v < b ? (E = d, c += 1, c < i && (d = r[c], v = h(d))) : (E = m, p += 1, p < s && (m = -n[p], b = h(m))), c < i && v < b || p >= s ? (f = d, c += 1, c < i && (d = r[c], v = h(d))) : (f = m, p += 1, p < s && (m = -n[p], b = h(m)));
    for (var A = f + E, x = A - f, g = E - x, w = g, _ = A, S, R, L, F, z; c < i && p < s; )
      v < b ? (f = d, c += 1, c < i && (d = r[c], v = h(d))) : (f = m, p += 1, p < s && (m = -n[p], b = h(m))), E = w, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = _ + A, R = S - _, L = S - R, F = A - R, z = _ - L, w = z + F, _ = S;
    for (; c < i; )
      f = d, E = w, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = _ + A, R = S - _, L = S - R, F = A - R, z = _ - L, w = z + F, _ = S, c += 1, c < i && (d = r[c]);
    for (; p < s; )
      f = m, E = w, A = f + E, x = A - f, g = E - x, g && (a[l++] = g), S = _ + A, R = S - _, L = S - R, F = A - R, z = _ - L, w = z + F, _ = S, p += 1, p < s && (m = -n[p]);
    return w && (a[l++] = w), _ && (a[l++] = _), l || (a[l++] = 0), a.length = l, a;
  }
  return ox;
}
var TR;
function Pke() {
  return TR || (TR = 1, function(t) {
    var e = vV(), r = kke(), n = Cke(), i = Ike(), s = 5, o = 11102230246251565e-32, a = (3 + 16 * o) * o, l = (7 + 56 * o) * o;
    function c(x, g, w, _) {
      return function(S, R, L) {
        var F = x(x(g(R[1], L[0]), g(-L[1], R[0])), x(g(S[1], R[0]), g(-R[1], S[0]))), z = x(g(S[1], L[0]), g(-L[1], S[0])), j = _(F, z);
        return j[j.length - 1];
      };
    }
    function p(x, g, w, _) {
      return function(S, R, L, F) {
        var z = x(x(w(x(g(L[1], F[0]), g(-F[1], L[0])), R[2]), x(w(x(g(R[1], F[0]), g(-F[1], R[0])), -L[2]), w(x(g(R[1], L[0]), g(-L[1], R[0])), F[2]))), x(w(x(g(R[1], F[0]), g(-F[1], R[0])), S[2]), x(w(x(g(S[1], F[0]), g(-F[1], S[0])), -R[2]), w(x(g(S[1], R[0]), g(-R[1], S[0])), F[2])))), j = x(x(w(x(g(L[1], F[0]), g(-F[1], L[0])), S[2]), x(w(x(g(S[1], F[0]), g(-F[1], S[0])), -L[2]), w(x(g(S[1], L[0]), g(-L[1], S[0])), F[2]))), x(w(x(g(R[1], L[0]), g(-L[1], R[0])), S[2]), x(w(x(g(S[1], L[0]), g(-L[1], S[0])), -R[2]), w(x(g(S[1], R[0]), g(-R[1], S[0])), L[2])))), W = _(z, j);
        return W[W.length - 1];
      };
    }
    function h(x, g, w, _) {
      return function(S, R, L, F, z) {
        var j = x(x(x(w(x(w(x(g(F[1], z[0]), g(-z[1], F[0])), L[2]), x(w(x(g(L[1], z[0]), g(-z[1], L[0])), -F[2]), w(x(g(L[1], F[0]), g(-F[1], L[0])), z[2]))), R[3]), x(w(x(w(x(g(F[1], z[0]), g(-z[1], F[0])), R[2]), x(w(x(g(R[1], z[0]), g(-z[1], R[0])), -F[2]), w(x(g(R[1], F[0]), g(-F[1], R[0])), z[2]))), -L[3]), w(x(w(x(g(L[1], z[0]), g(-z[1], L[0])), R[2]), x(w(x(g(R[1], z[0]), g(-z[1], R[0])), -L[2]), w(x(g(R[1], L[0]), g(-L[1], R[0])), z[2]))), F[3]))), x(w(x(w(x(g(L[1], F[0]), g(-F[1], L[0])), R[2]), x(w(x(g(R[1], F[0]), g(-F[1], R[0])), -L[2]), w(x(g(R[1], L[0]), g(-L[1], R[0])), F[2]))), -z[3]), x(w(x(w(x(g(F[1], z[0]), g(-z[1], F[0])), R[2]), x(w(x(g(R[1], z[0]), g(-z[1], R[0])), -F[2]), w(x(g(R[1], F[0]), g(-F[1], R[0])), z[2]))), S[3]), w(x(w(x(g(F[1], z[0]), g(-z[1], F[0])), S[2]), x(w(x(g(S[1], z[0]), g(-z[1], S[0])), -F[2]), w(x(g(S[1], F[0]), g(-F[1], S[0])), z[2]))), -R[3])))), x(x(w(x(w(x(g(R[1], z[0]), g(-z[1], R[0])), S[2]), x(w(x(g(S[1], z[0]), g(-z[1], S[0])), -R[2]), w(x(g(S[1], R[0]), g(-R[1], S[0])), z[2]))), F[3]), x(w(x(w(x(g(R[1], F[0]), g(-F[1], R[0])), S[2]), x(w(x(g(S[1], F[0]), g(-F[1], S[0])), -R[2]), w(x(g(S[1], R[0]), g(-R[1], S[0])), F[2]))), -z[3]), w(x(w(x(g(L[1], F[0]), g(-F[1], L[0])), R[2]), x(w(x(g(R[1], F[0]), g(-F[1], R[0])), -L[2]), w(x(g(R[1], L[0]), g(-L[1], R[0])), F[2]))), S[3]))), x(w(x(w(x(g(L[1], F[0]), g(-F[1], L[0])), S[2]), x(w(x(g(S[1], F[0]), g(-F[1], S[0])), -L[2]), w(x(g(S[1], L[0]), g(-L[1], S[0])), F[2]))), -R[3]), x(w(x(w(x(g(R[1], F[0]), g(-F[1], R[0])), S[2]), x(w(x(g(S[1], F[0]), g(-F[1], S[0])), -R[2]), w(x(g(S[1], R[0]), g(-R[1], S[0])), F[2]))), L[3]), w(x(w(x(g(R[1], L[0]), g(-L[1], R[0])), S[2]), x(w(x(g(S[1], L[0]), g(-L[1], S[0])), -R[2]), w(x(g(S[1], R[0]), g(-R[1], S[0])), L[2]))), -F[3]))))), W = x(x(x(w(x(w(x(g(F[1], z[0]), g(-z[1], F[0])), L[2]), x(w(x(g(L[1], z[0]), g(-z[1], L[0])), -F[2]), w(x(g(L[1], F[0]), g(-F[1], L[0])), z[2]))), S[3]), w(x(w(x(g(F[1], z[0]), g(-z[1], F[0])), S[2]), x(w(x(g(S[1], z[0]), g(-z[1], S[0])), -F[2]), w(x(g(S[1], F[0]), g(-F[1], S[0])), z[2]))), -L[3])), x(w(x(w(x(g(L[1], z[0]), g(-z[1], L[0])), S[2]), x(w(x(g(S[1], z[0]), g(-z[1], S[0])), -L[2]), w(x(g(S[1], L[0]), g(-L[1], S[0])), z[2]))), F[3]), w(x(w(x(g(L[1], F[0]), g(-F[1], L[0])), S[2]), x(w(x(g(S[1], F[0]), g(-F[1], S[0])), -L[2]), w(x(g(S[1], L[0]), g(-L[1], S[0])), F[2]))), -z[3]))), x(x(w(x(w(x(g(L[1], z[0]), g(-z[1], L[0])), R[2]), x(w(x(g(R[1], z[0]), g(-z[1], R[0])), -L[2]), w(x(g(R[1], L[0]), g(-L[1], R[0])), z[2]))), S[3]), w(x(w(x(g(L[1], z[0]), g(-z[1], L[0])), S[2]), x(w(x(g(S[1], z[0]), g(-z[1], S[0])), -L[2]), w(x(g(S[1], L[0]), g(-L[1], S[0])), z[2]))), -R[3])), x(w(x(w(x(g(R[1], z[0]), g(-z[1], R[0])), S[2]), x(w(x(g(S[1], z[0]), g(-z[1], S[0])), -R[2]), w(x(g(S[1], R[0]), g(-R[1], S[0])), z[2]))), L[3]), w(x(w(x(g(R[1], L[0]), g(-L[1], R[0])), S[2]), x(w(x(g(S[1], L[0]), g(-L[1], S[0])), -R[2]), w(x(g(S[1], R[0]), g(-R[1], S[0])), L[2]))), -z[3])))), te = _(j, W);
        return te[te.length - 1];
      };
    }
    function d(x) {
      var g = x === 3 ? c : x === 4 ? p : h;
      return g(r, e, n, i);
    }
    var v = d(3), m = d(4), b = [
      function() {
        return 0;
      },
      function() {
        return 0;
      },
      function(x, g) {
        return g[0] - x[0];
      },
      function(x, g, w) {
        var _ = (x[1] - w[1]) * (g[0] - w[0]), S = (x[0] - w[0]) * (g[1] - w[1]), R = _ - S, L;
        if (_ > 0) {
          if (S <= 0)
            return R;
          L = _ + S;
        } else if (_ < 0) {
          if (S >= 0)
            return R;
          L = -(_ + S);
        } else
          return R;
        var F = a * L;
        return R >= F || R <= -F ? R : v(x, g, w);
      },
      function(x, g, w, _) {
        var S = x[0] - _[0], R = g[0] - _[0], L = w[0] - _[0], F = x[1] - _[1], z = g[1] - _[1], j = w[1] - _[1], W = x[2] - _[2], te = g[2] - _[2], le = w[2] - _[2], ce = R * j, Ee = L * z, xe = L * F, _e = S * j, Ie = S * z, je = R * F, ue = W * (ce - Ee) + te * (xe - _e) + le * (Ie - je), O = (Math.abs(ce) + Math.abs(Ee)) * Math.abs(W) + (Math.abs(xe) + Math.abs(_e)) * Math.abs(te) + (Math.abs(Ie) + Math.abs(je)) * Math.abs(le), N = l * O;
        return ue > N || -ue > N ? ue : m(x, g, w, _);
      }
    ];
    function f(x) {
      var g = b[x.length];
      return g || (g = b[x.length] = d(x.length)), g.apply(void 0, x);
    }
    function E(x, g, w, _, S, R, L) {
      return function(F, z, j, W, te) {
        switch (arguments.length) {
          case 0:
          case 1:
            return 0;
          case 2:
            return _(F, z);
          case 3:
            return S(F, z, j);
          case 4:
            return R(F, z, j, W);
          case 5:
            return L(F, z, j, W, te);
        }
        for (var le = new Array(arguments.length), ce = 0; ce < arguments.length; ++ce)
          le[ce] = arguments[ce];
        return x(le);
      };
    }
    function A() {
      for (; b.length <= s; )
        b.push(d(b.length));
      t.exports = E.apply(void 0, [f].concat(b));
      for (var x = 0; x <= s; ++x)
        t.exports[x] = b[x];
    }
    A();
  }(_R)), _R.exports;
}
var Rke = Pke();
const n1 = /* @__PURE__ */ Ake(Rke);
function nE(t, e, r) {
  for (var n = e[0], i = e[1], s = t.length, o = 1, a = s, l = 0, c = s - 1; l < a; c = l++) {
    var p = t[l], h = t[c], d = p[1], v = h[1];
    if (v < d) {
      if (v < i && i < d) {
        var m = n1(p, h, e);
        if (Math.abs(m) < r)
          return 0;
        o ^= 0 < m | 0;
      } else if (i === d) {
        var b = t[(l + 1) % s], f = b[1];
        if (d < f) {
          var m = n1(p, h, e);
          if (m === 0)
            return 0;
          o ^= 0 < m | 0;
        }
      }
    } else if (d < v) {
      if (d < i && i < v) {
        var m = n1(p, h, e);
        if (m === 0)
          return 0;
        o ^= m < 0 | 0;
      } else if (i === d) {
        var b = t[(l + 1) % s], f = b[1];
        if (f < d) {
          var m = n1(p, h, e);
          if (m === 0)
            return 0;
          o ^= m < 0 | 0;
        }
      }
    } else if (i === d) {
      var E = Math.min(p[0], h[0]), A = Math.max(p[0], h[0]);
      if (l === 0) {
        for (; c > 0; ) {
          var x = (c + s - 1) % s, g = t[x];
          if (g[1] !== i)
            break;
          var w = g[0];
          E = Math.min(E, w), A = Math.max(A, w), c = x;
        }
        if (c === 0)
          return E <= n && n <= A ? 0 : 1;
        a = c + 1;
      }
      for (var _ = t[(c + s - 1) % s][1]; l + 1 < a; ) {
        var g = t[l + 1];
        if (g[1] !== i)
          break;
        var w = g[0];
        E = Math.min(E, w), A = Math.max(A, w), l += 1;
      }
      if (E <= n && n <= A)
        return 0;
      var S = t[(l + 1) % s][1];
      n < E && _ < i != S < i && (o ^= 1);
    }
  }
  return 2 * o - 1;
}
function iE(t) {
  let e = t.slice();
  return e.sort(Tke), Oke(e);
}
function Oke(t) {
  if (t.length <= 1)
    return t.slice();
  let e = [];
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    for (; e.length >= 2; ) {
      const s = e[e.length - 1], o = e[e.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
        e.pop();
      else
        break;
    }
    e.push(i);
  }
  e.pop();
  let r = [];
  for (let n = t.length - 1; n >= 0; n--) {
    const i = t[n];
    for (; r.length >= 2; ) {
      const s = r[r.length - 1], o = r[r.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
        r.pop();
      else
        break;
    }
    r.push(i);
  }
  return r.pop(), e.length == 1 && r.length == 1 && e[0].x == r[0].x && e[0].y == r[0].y ? e : e.concat(r);
}
function Tke(t, e) {
  return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0;
}
class Lke {
  constructor(e, r, n, i, s) {
    rs(this, "dataset"), rs(this, "epsilon"), rs(this, "minPts"), rs(this, "distance"), rs(this, "forceIn"), rs(this, "clusters"), rs(this, "clusterCentroids"), rs(this, "noise"), rs(this, "noiseAssigned"), rs(this, "_visited"), rs(this, "_assigned"), rs(this, "_datasetLength"), this.dataset = e, this.epsilon = r, this.minPts = n, s || (s = this._euclideanDistance), this.distance = s, this.forceIn = i, this.clusters = [], this.clusterCentroids = [], this.noise = [], this.noiseAssigned = [], this._visited = [], this._assigned = [], this._datasetLength = e.length, this.run(e, r, n, i, s);
  }
  /******************************************************************************/
  // public functions
  /**
   * Start clustering
   *
   * @param {Array} dataset
   * @param {number} epsilon
   * @param {number} minPts
   * @param {function} distanceFunction
   * @param {boolean} distanceFunction
   * @returns {undefined}
   * @access public
   */
  run(e, r, n, i, s) {
    this._init(e, r, n, i, s);
    for (var o = 0; o < this._datasetLength; o++)
      if (this._visited[o] !== 1) {
        this._visited[o] = 1;
        var a = this._regionQuery(o);
        if (a.length < this.minPts)
          this.noise.push(o);
        else {
          var l = this.clusters.length;
          this.clusters.push([]), this._addToCluster(o, l), this._expandCluster(l, a);
        }
      }
    if (this.dataset.length > 1e3) {
      for (var c = this.minPts * 2, l = 0; l < this.clusters.length; l++) {
        var p = this.clusters[l];
        if (p.length < c) {
          for (var o = 0; o < p.length; o++)
            this.noise.push(p[o]);
          this.clusters[l] = [];
        }
      }
      this.clusters = this.clusters.filter((m) => m.length > 0);
    }
    for (var h = 0; h < this.clusters.length; h++)
      this.clusterCentroids.push(this._centroid(this.clusters[h]));
    let d = [];
    for (let m = 0; m < this._datasetLength; m++)
      d.push(0);
    for (let m in this.clusters)
      for (let b of this.clusters[m])
        d[b] = Number(m);
    let v = [];
    for (let m of this.noise) {
      let b = this._nearestAssignedNeighbor(this.clusters.flat(), m);
      v.push([m, Number(d[b])]);
    }
    if (this.forceIn) {
      this.noiseAssigned = [];
      for (let m = 0; m < v.length; m++) {
        let b = v[m];
        this.noiseAssigned.push([b[0], b[1]]), this._addToCluster(b[0], b[1]), d[b[0]] = b[1];
      }
      this.noise = [];
    } else {
      this.noiseAssigned = [];
      for (let m = 0; m < v.length; m++) {
        let b = v[m];
        this.noiseAssigned.push([b[0], b[1]]), d[b[0]] = b[1];
      }
    }
    return this.clusters;
  }
  /******************************************************************************/
  // protected functions
  /**
   * Set object properties
   *
   * @param {Array} dataset
   * @param {number} epsilon
   * @param {number} minPts
   * @param {function} distance
   * @param {boolean} forceIn
   * @returns {undefined}
   * @access protected
   */
  _init(e, r, n, i, s) {
    if (e) {
      if (!(e instanceof Array))
        throw Error("Dataset must be of type array, " + typeof e + " given");
      this.dataset = e, this.clusters = [], this.noise = [], this._datasetLength = e.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength);
    }
    r && (this.epsilon = r), n && (this.minPts = n), s && (this.distance = s), i && (this.forceIn = i);
  }
  /**
   * Expand cluster to closest points of given neighborhood
   *
   * @param {number} clusterId
   * @param {Array} neighbors
   * @returns {undefined}
   * @access protected
   */
  _expandCluster(e, r) {
    for (var n = 0; n < r.length; n++) {
      var i = r[n];
      if (this._visited[i] !== 1) {
        this._visited[i] = 1;
        var s = this._regionQuery(i);
        s.length >= this.minPts && (r = this._mergeArrays(r, s));
      }
      this._assigned[i] !== 1 && (this._addToCluster(i, e), this.noise.indexOf(i) > -1 && this.noise.splice(this.noise.indexOf(i), 1));
    }
  }
  /**
   * Add new point to cluster
   *
   * @param {number} pointId
   * @param {number} clusterId
   */
  _addToCluster(e, r) {
    this.clusters[r].push(e), this._assigned[e] = 1;
  }
  /**
   * Find all neighbors around given point
   *
   * @param {number} pointId,
   * @param {number} epsilon
   * @returns {Array}
   * @access protected
   */
  _regionQuery(e) {
    let r = [];
    for (var n = 0; n < this._datasetLength; n++) {
      var i = this.distance(this.dataset[e], this.dataset[n]);
      i < this.epsilon && r.push(n);
    }
    return r;
  }
  /******************************************************************************/
  // helpers
  /**
   * @param {Array} a
   * @param {Array} b
   * @returns {Array}
   * @access protected
   */
  _mergeArrays(e, r) {
    for (var n = r.length, i = 0; i < n; i++) {
      var s = r[i];
      e.indexOf(s) < 0 && e.push(s);
    }
    return e;
  }
  /**
   * Calculate euclidean distance in multidimensional space
   *
   * @param {Array} p
   * @param {Array} q
   * @returns {number}
   * @access protected
   */
  _euclideanDistance(e, r) {
    for (var n = 0, i = Math.min(e.length, r.length); i--; )
      n += (e[i] - r[i]) * (e[i] - r[i]);
    return Math.sqrt(n);
  }
  /**
   * Calculate centroid of a group of points
   *
   * @param {Array} c
   * @returns {Array}
   * @access protected
   */
  _centroid(e) {
    let r = 0, n = 0;
    const i = e.length;
    for (let s of e)
      r += this.dataset[s][0], n += this.dataset[s][1];
    return [r / i, n / i];
  }
  /**
  * Given a list of clustered points and an outlier, returns the closest clustered point.
  *
  * @param {Array} datasetIds
  * @param {number} pointId
  * @returns {number}
  * @access protected
  */
  _nearestAssignedNeighbor(e, r) {
    var n = [0, 0];
    for (var i of e) {
      n[1] == 0 && (n = [i, this._euclideanDistance(this.dataset[r], this.dataset[i])]);
      let s = this._euclideanDistance(this.dataset[r], this.dataset[i]);
      n[1] > s && (n = [i, s]);
    }
    return n[0];
  }
}
/*!
Copyright (C) 2010-2013 Raymond Hill: https://github.com/gorhill/Javascript-Voronoi
MIT License: See https://github.com/gorhill/Javascript-Voronoi/LICENSE.md
*/
function pt() {
  this.vertices = null, this.edges = null, this.cells = null, this.toRecycle = null, this.beachsectionJunkyard = [], this.circleEventJunkyard = [], this.vertexJunkyard = [], this.edgeJunkyard = [], this.cellJunkyard = [];
}
pt.prototype.reset = function() {
  if (this.beachline || (this.beachline = new this.RBTree()), this.beachline.root)
    for (var t = this.beachline.getFirst(this.beachline.root); t; )
      this.beachsectionJunkyard.push(t), t = t.rbNext;
  this.beachline.root = null, this.circleEvents || (this.circleEvents = new this.RBTree()), this.circleEvents.root = this.firstCircleEvent = null, this.vertices = [], this.edges = [], this.cells = [];
};
pt.prototype.sqrt = Math.sqrt;
pt.prototype.abs = Math.abs;
pt.prototype. = pt. = 1e-9;
pt.prototype.inv = pt.inv = 1 / pt.;
pt.prototype.equalWithEpsilon = function(t, e) {
  return this.abs(t - e) < 1e-9;
};
pt.prototype.greaterThanWithEpsilon = function(t, e) {
  return t - e > 1e-9;
};
pt.prototype.greaterThanOrEqualWithEpsilon = function(t, e) {
  return e - t < 1e-9;
};
pt.prototype.lessThanWithEpsilon = function(t, e) {
  return e - t > 1e-9;
};
pt.prototype.lessThanOrEqualWithEpsilon = function(t, e) {
  return t - e < 1e-9;
};
pt.prototype.RBTree = function() {
  this.root = null;
};
pt.prototype.RBTree.prototype.rbInsertSuccessor = function(t, e) {
  var r;
  if (t) {
    if (e.rbPrevious = t, e.rbNext = t.rbNext, t.rbNext && (t.rbNext.rbPrevious = e), t.rbNext = e, t.rbRight) {
      for (t = t.rbRight; t.rbLeft; )
        t = t.rbLeft;
      t.rbLeft = e;
    } else
      t.rbRight = e;
    r = t;
  } else this.root ? (t = this.getFirst(this.root), e.rbPrevious = null, e.rbNext = t, t.rbPrevious = e, t.rbLeft = e, r = t) : (e.rbPrevious = e.rbNext = null, this.root = e, r = null);
  e.rbLeft = e.rbRight = null, e.rbParent = r, e.rbRed = !0;
  var n, i;
  for (t = e; r && r.rbRed; )
    n = r.rbParent, r === n.rbLeft ? (i = n.rbRight, i && i.rbRed ? (r.rbRed = i.rbRed = !1, n.rbRed = !0, t = n) : (t === r.rbRight && (this.rbRotateLeft(r), t = r, r = t.rbParent), r.rbRed = !1, n.rbRed = !0, this.rbRotateRight(n))) : (i = n.rbLeft, i && i.rbRed ? (r.rbRed = i.rbRed = !1, n.rbRed = !0, t = n) : (t === r.rbLeft && (this.rbRotateRight(r), t = r, r = t.rbParent), r.rbRed = !1, n.rbRed = !0, this.rbRotateLeft(n))), r = t.rbParent;
  this.root.rbRed = !1;
};
pt.prototype.RBTree.prototype.rbRemoveNode = function(t) {
  t.rbNext && (t.rbNext.rbPrevious = t.rbPrevious), t.rbPrevious && (t.rbPrevious.rbNext = t.rbNext), t.rbNext = t.rbPrevious = null;
  var e = t.rbParent, r = t.rbLeft, n = t.rbRight, i;
  r ? n ? i = this.getFirst(n) : i = r : i = n, e ? e.rbLeft === t ? e.rbLeft = i : e.rbRight = i : this.root = i;
  var s;
  if (r && n ? (s = i.rbRed, i.rbRed = t.rbRed, i.rbLeft = r, r.rbParent = i, i !== n ? (e = i.rbParent, i.rbParent = t.rbParent, t = i.rbRight, e.rbLeft = t, i.rbRight = n, n.rbParent = i) : (i.rbParent = e, e = i, t = i.rbRight)) : (s = t.rbRed, t = i), t && (t.rbParent = e), !s) {
    if (t && t.rbRed) {
      t.rbRed = !1;
      return;
    }
    var o;
    do {
      if (t === this.root)
        break;
      if (t === e.rbLeft) {
        if (o = e.rbRight, o.rbRed && (o.rbRed = !1, e.rbRed = !0, this.rbRotateLeft(e), o = e.rbRight), o.rbLeft && o.rbLeft.rbRed || o.rbRight && o.rbRight.rbRed) {
          (!o.rbRight || !o.rbRight.rbRed) && (o.rbLeft.rbRed = !1, o.rbRed = !0, this.rbRotateRight(o), o = e.rbRight), o.rbRed = e.rbRed, e.rbRed = o.rbRight.rbRed = !1, this.rbRotateLeft(e), t = this.root;
          break;
        }
      } else if (o = e.rbLeft, o.rbRed && (o.rbRed = !1, e.rbRed = !0, this.rbRotateRight(e), o = e.rbLeft), o.rbLeft && o.rbLeft.rbRed || o.rbRight && o.rbRight.rbRed) {
        (!o.rbLeft || !o.rbLeft.rbRed) && (o.rbRight.rbRed = !1, o.rbRed = !0, this.rbRotateLeft(o), o = e.rbLeft), o.rbRed = e.rbRed, e.rbRed = o.rbLeft.rbRed = !1, this.rbRotateRight(e), t = this.root;
        break;
      }
      o.rbRed = !0, t = e, e = e.rbParent;
    } while (!t.rbRed);
    t && (t.rbRed = !1);
  }
};
pt.prototype.RBTree.prototype.rbRotateLeft = function(t) {
  var e = t, r = t.rbRight, n = e.rbParent;
  n ? n.rbLeft === e ? n.rbLeft = r : n.rbRight = r : this.root = r, r.rbParent = n, e.rbParent = r, e.rbRight = r.rbLeft, e.rbRight && (e.rbRight.rbParent = e), r.rbLeft = e;
};
pt.prototype.RBTree.prototype.rbRotateRight = function(t) {
  var e = t, r = t.rbLeft, n = e.rbParent;
  n ? n.rbLeft === e ? n.rbLeft = r : n.rbRight = r : this.root = r, r.rbParent = n, e.rbParent = r, e.rbLeft = r.rbRight, e.rbLeft && (e.rbLeft.rbParent = e), r.rbRight = e;
};
pt.prototype.RBTree.prototype.getFirst = function(t) {
  for (; t.rbLeft; )
    t = t.rbLeft;
  return t;
};
pt.prototype.RBTree.prototype.getLast = function(t) {
  for (; t.rbRight; )
    t = t.rbRight;
  return t;
};
pt.prototype.Diagram = function(t) {
  this.site = t;
};
pt.prototype.Cell = function(t) {
  this.site = t, this.halfedges = [], this.closeMe = !1;
};
pt.prototype.Cell.prototype.init = function(t) {
  return this.site = t, this.halfedges = [], this.closeMe = !1, this;
};
pt.prototype.createCell = function(t) {
  var e = this.cellJunkyard.pop();
  return e ? e.init(t) : new this.Cell(t);
};
pt.prototype.Cell.prototype.prepareHalfedges = function() {
  for (var t = this.halfedges, e = t.length, r; e--; )
    r = t[e].edge, (!r.vb || !r.va) && t.splice(e, 1);
  return t.sort(function(n, i) {
    return i.angle - n.angle;
  }), t.length;
};
pt.prototype.Cell.prototype.getNeighborIds = function() {
  for (var t = [], e = this.halfedges.length, r; e--; )
    r = this.halfedges[e].edge, r.lSite !== null && r.lSite.voronoiId != this.site.voronoiId ? t.push(r.lSite.voronoiId) : r.rSite !== null && r.rSite.voronoiId != this.site.voronoiId && t.push(r.rSite.voronoiId);
  return t;
};
pt.prototype.Cell.prototype.getBbox = function() {
  for (var t = this.halfedges, e = t.length, r = 1 / 0, n = 1 / 0, i = -1 / 0, s = -1 / 0, o, a, l; e--; )
    o = t[e].getStartpoint(), a = o.x, l = o.y, a < r && (r = a), l < n && (n = l), a > i && (i = a), l > s && (s = l);
  return {
    x: r,
    y: n,
    width: i - r,
    height: s - n
  };
};
pt.prototype.Cell.prototype.pointIntersection = function(t, e) {
  for (var r = this.halfedges, n = r.length, i, s, o, a; n--; ) {
    if (i = r[n], s = i.getStartpoint(), o = i.getEndpoint(), a = (e - s.y) * (o.x - s.x) - (t - s.x) * (o.y - s.y), !a)
      return 0;
    if (a > 0)
      return -1;
  }
  return 1;
};
pt.prototype.Vertex = function(t, e) {
  this.x = t, this.y = e;
};
pt.prototype.Edge = function(t, e) {
  this.lSite = t, this.rSite = e, this.va = this.vb = null;
};
pt.prototype.Halfedge = function(t, e, r) {
  if (this.site = e, this.edge = t, r)
    this.angle = Math.atan2(r.y - e.y, r.x - e.x);
  else {
    var n = t.va, i = t.vb;
    this.angle = t.lSite === e ? Math.atan2(i.x - n.x, n.y - i.y) : Math.atan2(n.x - i.x, i.y - n.y);
  }
};
pt.prototype.createHalfedge = function(t, e, r) {
  return new this.Halfedge(t, e, r);
};
pt.prototype.Halfedge.prototype.getStartpoint = function() {
  return this.edge.lSite === this.site ? this.edge.va : this.edge.vb;
};
pt.prototype.Halfedge.prototype.getEndpoint = function() {
  return this.edge.lSite === this.site ? this.edge.vb : this.edge.va;
};
pt.prototype.createVertex = function(t, e) {
  var r = this.vertexJunkyard.pop();
  return r ? (r.x = t, r.y = e) : r = new this.Vertex(t, e), this.vertices.push(r), r;
};
pt.prototype.createEdge = function(t, e, r, n) {
  var i = this.edgeJunkyard.pop();
  return i ? (i.lSite = t, i.rSite = e, i.va = i.vb = null) : i = new this.Edge(t, e), this.edges.push(i), r && this.setEdgeStartpoint(i, t, e, r), n && this.setEdgeEndpoint(i, t, e, n), this.cells[t.voronoiId].halfedges.push(this.createHalfedge(i, t, e)), this.cells[e.voronoiId].halfedges.push(this.createHalfedge(i, e, t)), i;
};
pt.prototype.createBorderEdge = function(t, e, r) {
  var n = this.edgeJunkyard.pop();
  return n ? (n.lSite = t, n.rSite = null) : n = new this.Edge(t, null), n.va = e, n.vb = r, this.edges.push(n), n;
};
pt.prototype.setEdgeStartpoint = function(t, e, r, n) {
  !t.va && !t.vb ? (t.va = n, t.lSite = e, t.rSite = r) : t.lSite === r ? t.vb = n : t.va = n;
};
pt.prototype.setEdgeEndpoint = function(t, e, r, n) {
  this.setEdgeStartpoint(t, r, e, n);
};
pt.prototype.Beachsection = function() {
};
pt.prototype.createBeachsection = function(t) {
  var e = this.beachsectionJunkyard.pop();
  return e || (e = new this.Beachsection()), e.site = t, e;
};
pt.prototype.leftBreakPoint = function(t, e) {
  var r = t.site, n = r.x, i = r.y, s = i - e;
  if (!s)
    return n;
  var o = t.rbPrevious;
  if (!o)
    return -1 / 0;
  r = o.site;
  var a = r.x, l = r.y, c = l - e;
  if (!c)
    return a;
  var p = a - n, h = 1 / s - 1 / c, d = p / c;
  return h ? (-d + this.sqrt(d * d - 2 * h * (p * p / (-2 * c) - l + c / 2 + i - s / 2))) / h + n : (n + a) / 2;
};
pt.prototype.rightBreakPoint = function(t, e) {
  var r = t.rbNext;
  if (r)
    return this.leftBreakPoint(r, e);
  var n = t.site;
  return n.y === e ? n.x : 1 / 0;
};
pt.prototype.detachBeachsection = function(t) {
  this.detachCircleEvent(t), this.beachline.rbRemoveNode(t), this.beachsectionJunkyard.push(t);
};
pt.prototype.removeBeachsection = function(t) {
  var e = t.circleEvent, r = e.x, n = e.ycenter, i = this.createVertex(r, n), s = t.rbPrevious, o = t.rbNext, a = [t], l = Math.abs;
  this.detachBeachsection(t);
  for (var c = s; c.circleEvent && l(r - c.circleEvent.x) < 1e-9 && l(n - c.circleEvent.ycenter) < 1e-9; )
    s = c.rbPrevious, a.unshift(c), this.detachBeachsection(c), c = s;
  a.unshift(c), this.detachCircleEvent(c);
  for (var p = o; p.circleEvent && l(r - p.circleEvent.x) < 1e-9 && l(n - p.circleEvent.ycenter) < 1e-9; )
    o = p.rbNext, a.push(p), this.detachBeachsection(p), p = o;
  a.push(p), this.detachCircleEvent(p);
  var h = a.length, d;
  for (d = 1; d < h; d++)
    p = a[d], c = a[d - 1], this.setEdgeStartpoint(p.edge, c.site, p.site, i);
  c = a[0], p = a[h - 1], p.edge = this.createEdge(c.site, p.site, void 0, i), this.attachCircleEvent(c), this.attachCircleEvent(p);
};
pt.prototype.addBeachsection = function(t) {
  for (var e = t.x, r = t.y, n, i, s, o, a = this.beachline.root; a; )
    if (s = this.leftBreakPoint(a, r) - e, s > 1e-9)
      a = a.rbLeft;
    else if (o = e - this.rightBreakPoint(a, r), o > 1e-9) {
      if (!a.rbRight) {
        n = a;
        break;
      }
      a = a.rbRight;
    } else {
      s > -1e-9 ? (n = a.rbPrevious, i = a) : o > -1e-9 ? (n = a, i = a.rbNext) : n = i = a;
      break;
    }
  var l = this.createBeachsection(t);
  if (this.beachline.rbInsertSuccessor(n, l), !(!n && !i)) {
    if (n === i) {
      this.detachCircleEvent(n), i = this.createBeachsection(n.site), this.beachline.rbInsertSuccessor(l, i), l.edge = i.edge = this.createEdge(n.site, l.site), this.attachCircleEvent(n), this.attachCircleEvent(i);
      return;
    }
    if (n && !i) {
      l.edge = this.createEdge(n.site, l.site);
      return;
    }
    if (n !== i) {
      this.detachCircleEvent(n), this.detachCircleEvent(i);
      var c = n.site, p = c.x, h = c.y, d = t.x - p, v = t.y - h, m = i.site, b = m.x - p, f = m.y - h, E = 2 * (d * f - v * b), A = d * d + v * v, x = b * b + f * f, g = this.createVertex((f * A - v * x) / E + p, (d * x - b * A) / E + h);
      this.setEdgeStartpoint(i.edge, c, m, g), l.edge = this.createEdge(c, t, void 0, g), i.edge = this.createEdge(t, m, void 0, g), this.attachCircleEvent(n), this.attachCircleEvent(i);
      return;
    }
  }
};
pt.prototype.CircleEvent = function() {
  this.arc = null, this.rbLeft = null, this.rbNext = null, this.rbParent = null, this.rbPrevious = null, this.rbRed = !1, this.rbRight = null, this.site = null, this.x = this.y = this.ycenter = 0;
};
pt.prototype.attachCircleEvent = function(t) {
  var e = t.rbPrevious, r = t.rbNext;
  if (!(!e || !r)) {
    var n = e.site, i = t.site, s = r.site;
    if (n !== s) {
      var o = i.x, a = i.y, l = n.x - o, c = n.y - a, p = s.x - o, h = s.y - a, d = 2 * (l * h - c * p);
      if (!(d >= -2e-12)) {
        var v = l * l + c * c, m = p * p + h * h, b = (h * v - c * m) / d, f = (l * m - p * v) / d, E = f + a, A = this.circleEventJunkyard.pop();
        A || (A = new this.CircleEvent()), A.arc = t, A.site = i, A.x = b + o, A.y = E + this.sqrt(b * b + f * f), A.ycenter = E, t.circleEvent = A;
        for (var x = null, g = this.circleEvents.root; g; )
          if (A.y < g.y || A.y === g.y && A.x <= g.x)
            if (g.rbLeft)
              g = g.rbLeft;
            else {
              x = g.rbPrevious;
              break;
            }
          else if (g.rbRight)
            g = g.rbRight;
          else {
            x = g;
            break;
          }
        this.circleEvents.rbInsertSuccessor(x, A), x || (this.firstCircleEvent = A);
      }
    }
  }
};
pt.prototype.detachCircleEvent = function(t) {
  var e = t.circleEvent;
  e && (e.rbPrevious || (this.firstCircleEvent = e.rbNext), this.circleEvents.rbRemoveNode(e), this.circleEventJunkyard.push(e), t.circleEvent = null);
};
pt.prototype.connectEdge = function(t, e) {
  var r = t.vb;
  if (r)
    return !0;
  var n = t.va, i = e.xl, s = e.xr, o = e.yt, a = e.yb, l = t.lSite, c = t.rSite, p = l.x, h = l.y, d = c.x, v = c.y, m = (p + d) / 2, b = (h + v) / 2, f, E;
  if (this.cells[l.voronoiId].closeMe = !0, this.cells[c.voronoiId].closeMe = !0, v !== h && (f = (p - d) / (v - h), E = b - f * m), f === void 0) {
    if (m < i || m >= s)
      return !1;
    if (p > d) {
      if (!n || n.y < o)
        n = this.createVertex(m, o);
      else if (n.y >= a)
        return !1;
      r = this.createVertex(m, a);
    } else {
      if (!n || n.y > a)
        n = this.createVertex(m, a);
      else if (n.y < o)
        return !1;
      r = this.createVertex(m, o);
    }
  } else if (f < -1 || f > 1)
    if (p > d) {
      if (!n || n.y < o)
        n = this.createVertex((o - E) / f, o);
      else if (n.y >= a)
        return !1;
      r = this.createVertex((a - E) / f, a);
    } else {
      if (!n || n.y > a)
        n = this.createVertex((a - E) / f, a);
      else if (n.y < o)
        return !1;
      r = this.createVertex((o - E) / f, o);
    }
  else if (h < v) {
    if (!n || n.x < i)
      n = this.createVertex(i, f * i + E);
    else if (n.x >= s)
      return !1;
    r = this.createVertex(s, f * s + E);
  } else {
    if (!n || n.x > s)
      n = this.createVertex(s, f * s + E);
    else if (n.x < i)
      return !1;
    r = this.createVertex(i, f * i + E);
  }
  return t.va = n, t.vb = r, !0;
};
pt.prototype.clipEdge = function(t, e) {
  var r = t.va.x, n = t.va.y, i = t.vb.x, s = t.vb.y, o = 0, a = 1, l = i - r, c = s - n, p = r - e.xl;
  if (l === 0 && p < 0)
    return !1;
  var h = -p / l;
  if (l < 0) {
    if (h < o)
      return !1;
    h < a && (a = h);
  } else if (l > 0) {
    if (h > a)
      return !1;
    h > o && (o = h);
  }
  if (p = e.xr - r, l === 0 && p < 0)
    return !1;
  if (h = p / l, l < 0) {
    if (h > a)
      return !1;
    h > o && (o = h);
  } else if (l > 0) {
    if (h < o)
      return !1;
    h < a && (a = h);
  }
  if (p = n - e.yt, c === 0 && p < 0)
    return !1;
  if (h = -p / c, c < 0) {
    if (h < o)
      return !1;
    h < a && (a = h);
  } else if (c > 0) {
    if (h > a)
      return !1;
    h > o && (o = h);
  }
  if (p = e.yb - n, c === 0 && p < 0)
    return !1;
  if (h = p / c, c < 0) {
    if (h > a)
      return !1;
    h > o && (o = h);
  } else if (c > 0) {
    if (h < o)
      return !1;
    h < a && (a = h);
  }
  return o > 0 && (t.va = this.createVertex(r + o * l, n + o * c)), a < 1 && (t.vb = this.createVertex(r + a * l, n + a * c)), (o > 0 || a < 1) && (this.cells[t.lSite.voronoiId].closeMe = !0, this.cells[t.rSite.voronoiId].closeMe = !0), !0;
};
pt.prototype.clipEdges = function(t) {
  for (var e = this.edges, r = e.length, n, i = Math.abs; r--; )
    n = e[r], (!this.connectEdge(n, t) || !this.clipEdge(n, t) || i(n.va.x - n.vb.x) < 1e-9 && i(n.va.y - n.vb.y) < 1e-9) && (n.va = n.vb = null, e.splice(r, 1));
};
pt.prototype.closeCells = function(t) {
  for (var e = t.xl, r = t.xr, n = t.yt, i = t.yb, s = this.cells, o = s.length, a, l, c, p, h, d, v, m, b, f = Math.abs; o--; )
    if (a = s[o], !!a.prepareHalfedges() && a.closeMe) {
      for (c = a.halfedges, p = c.length, l = 0; l < p; ) {
        if (d = c[l].getEndpoint(), m = c[(l + 1) % p].getStartpoint(), f(d.x - m.x) >= 1e-9 || f(d.y - m.y) >= 1e-9)
          switch (!0) {
            case (this.equalWithEpsilon(d.x, e) && this.lessThanWithEpsilon(d.y, i)):
              if (b = this.equalWithEpsilon(m.x, e), v = this.createVertex(e, b ? m.y : i), h = this.createBorderEdge(a.site, d, v), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, b)
                break;
              d = v;
            case (this.equalWithEpsilon(d.y, i) && this.lessThanWithEpsilon(d.x, r)):
              if (b = this.equalWithEpsilon(m.y, i), v = this.createVertex(b ? m.x : r, i), h = this.createBorderEdge(a.site, d, v), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, b)
                break;
              d = v;
            case (this.equalWithEpsilon(d.x, r) && this.greaterThanWithEpsilon(d.y, n)):
              if (b = this.equalWithEpsilon(m.x, r), v = this.createVertex(r, b ? m.y : n), h = this.createBorderEdge(a.site, d, v), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, b)
                break;
              d = v;
            case (this.equalWithEpsilon(d.y, n) && this.greaterThanWithEpsilon(d.x, e)):
              if (b = this.equalWithEpsilon(m.y, n), v = this.createVertex(b ? m.x : e, n), h = this.createBorderEdge(a.site, d, v), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, b || (d = v, b = this.equalWithEpsilon(m.x, e), v = this.createVertex(e, b ? m.y : i), h = this.createBorderEdge(a.site, d, v), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, b) || (d = v, b = this.equalWithEpsilon(m.y, i), v = this.createVertex(b ? m.x : r, i), h = this.createBorderEdge(a.site, d, v), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, b) || (d = v, b = this.equalWithEpsilon(m.x, r), v = this.createVertex(r, b ? m.y : n), h = this.createBorderEdge(a.site, d, v), l++, c.splice(l, 0, this.createHalfedge(h, a.site, null)), p++, b))
                break;
            default:
              throw "Voronoi.closeCells() > this makes no sense!";
          }
        l++;
      }
      a.closeMe = !1;
    }
};
pt.prototype.quantizeSites = function(t) {
  for (var e = this., r = t.length, n; r--; )
    n = t[r], n.x = Math.floor(n.x / e) * e, n.y = Math.floor(n.y / e) * e;
};
pt.prototype.recycle = function(t) {
  if (t)
    if (t instanceof this.Diagram)
      this.toRecycle = t;
    else
      throw "Voronoi.recycleDiagram() > Need a Diagram object.";
};
pt.prototype.compute = function(t, e) {
  var r = /* @__PURE__ */ new Date();
  this.reset(), this.toRecycle && (this.vertexJunkyard = this.vertexJunkyard.concat(this.toRecycle.vertices), this.edgeJunkyard = this.edgeJunkyard.concat(this.toRecycle.edges), this.cellJunkyard = this.cellJunkyard.concat(this.toRecycle.cells), this.toRecycle = null);
  var n = t.slice(0);
  n.sort(function(d, v) {
    var m = v.y - d.y;
    return m || v.x - d.x;
  });
  for (var i = n.pop(), s = 0, o, a, l = this.cells, c; ; )
    if (c = this.firstCircleEvent, i && (!c || i.y < c.y || i.y === c.y && i.x < c.x))
      (i.x !== o || i.y !== a) && (l[s] = this.createCell(i), i.voronoiId = s++, this.addBeachsection(i), a = i.y, o = i.x), i = n.pop();
    else if (c)
      this.removeBeachsection(c.arc);
    else
      break;
  this.clipEdges(e), this.closeCells(e);
  var p = /* @__PURE__ */ new Date(), h = new this.Diagram();
  return h.cells = this.cells, h.edges = this.edges, h.vertices = this.vertices, h.execTime = p.getTime() - r.getTime(), this.reset(), h;
};
typeof module < "u" && (module.exports = pt);
/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function Mke(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(p) {
      return l([c, p]);
    };
  }
  function l(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
      switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
        case 0:
        case 1:
          s = c;
          break;
        case 4:
          return r.label++, { value: c[1], done: !1 };
        case 5:
          r.label++, i = c[1], c = [0];
          continue;
        case 7:
          c = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            r = 0;
            continue;
          }
          if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
            r.label = c[1];
            break;
          }
          if (c[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = c;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(c);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      c = e.call(t, r);
    } catch (p) {
      c = [6, p], i = 0;
    } finally {
      n = s = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
var hc = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r) {
      this.next = null, this.key = e, this.data = r, this.left = null, this.right = null;
    }
    return t;
  }()
);
function Nke(t, e) {
  return t > e ? 1 : t < e ? -1 : 0;
}
function Il(t, e, r) {
  for (var n = new hc(null, null), i = n, s = n; ; ) {
    var o = r(t, e.key);
    if (o < 0) {
      if (e.left === null)
        break;
      if (r(t, e.left.key) < 0) {
        var a = e.left;
        if (e.left = a.right, a.right = e, e = a, e.left === null)
          break;
      }
      s.left = e, s = e, e = e.left;
    } else if (o > 0) {
      if (e.right === null)
        break;
      if (r(t, e.right.key) > 0) {
        var a = e.right;
        if (e.right = a.left, a.left = e, e = a, e.right === null)
          break;
      }
      i.right = e, i = e, e = e.right;
    } else
      break;
  }
  return i.right = e.left, s.left = e.right, e.left = n.right, e.right = n.left, e;
}
function ax(t, e, r, n) {
  var i = new hc(t, e);
  if (r === null)
    return i.left = i.right = null, i;
  r = Il(t, r, n);
  var s = n(t, r.key);
  return s < 0 ? (i.left = r.left, i.right = r, r.left = null) : s >= 0 && (i.right = r.right, i.left = r, r.right = null), i;
}
function LR(t, e, r) {
  var n = null, i = null;
  if (e) {
    e = Il(t, e, r);
    var s = r(e.key, t);
    s === 0 ? (n = e.left, i = e.right) : s < 0 ? (i = e.right, e.right = null, n = e) : (n = e.left, e.left = null, i = e);
  }
  return { left: n, right: i };
}
function Dke(t, e, r) {
  return e === null ? t : (t === null || (e = Il(t.key, e, r), e.left = t), e);
}
function sE(t, e, r, n, i) {
  if (t) {
    n("" + e + (r ? " " : " ") + i(t) + `
`);
    var s = e + (r ? "    " : "   ");
    t.left && sE(t.left, s, !1, n, i), t.right && sE(t.right, s, !0, n, i);
  }
}
var Ok = (
  /** @class */
  function() {
    function t(e) {
      e === void 0 && (e = Nke), this._root = null, this._size = 0, this._comparator = e;
    }
    return t.prototype.insert = function(e, r) {
      return this._size++, this._root = ax(e, r, this._root, this._comparator);
    }, t.prototype.add = function(e, r) {
      var n = new hc(e, r);
      this._root === null && (n.left = n.right = null, this._size++, this._root = n);
      var i = this._comparator, s = Il(e, this._root, i), o = i(e, s.key);
      return o === 0 ? this._root = s : (o < 0 ? (n.left = s.left, n.right = s, s.left = null) : o > 0 && (n.right = s.right, n.left = s, s.right = null), this._size++, this._root = n), this._root;
    }, t.prototype.remove = function(e) {
      this._root = this._remove(e, this._root, this._comparator);
    }, t.prototype._remove = function(e, r, n) {
      var i;
      if (r === null)
        return null;
      r = Il(e, r, n);
      var s = n(e, r.key);
      return s === 0 ? (r.left === null ? i = r.right : (i = Il(e, r.left, n), i.right = r.right), this._size--, i) : r;
    }, t.prototype.pop = function() {
      var e = this._root;
      if (e) {
        for (; e.left; )
          e = e.left;
        return this._root = Il(e.key, this._root, this._comparator), this._root = this._remove(e.key, this._root, this._comparator), { key: e.key, data: e.data };
      }
      return null;
    }, t.prototype.findStatic = function(e) {
      for (var r = this._root, n = this._comparator; r; ) {
        var i = n(e, r.key);
        if (i === 0)
          return r;
        i < 0 ? r = r.left : r = r.right;
      }
      return null;
    }, t.prototype.find = function(e) {
      return this._root && (this._root = Il(e, this._root, this._comparator), this._comparator(e, this._root.key) !== 0) ? null : this._root;
    }, t.prototype.contains = function(e) {
      for (var r = this._root, n = this._comparator; r; ) {
        var i = n(e, r.key);
        if (i === 0)
          return !0;
        i < 0 ? r = r.left : r = r.right;
      }
      return !1;
    }, t.prototype.forEach = function(e, r) {
      for (var n = this._root, i = [], s = !1; !s; )
        n !== null ? (i.push(n), n = n.left) : i.length !== 0 ? (n = i.pop(), e.call(r, n), n = n.right) : s = !0;
      return this;
    }, t.prototype.range = function(e, r, n, i) {
      for (var s = [], o = this._comparator, a = this._root, l; s.length !== 0 || a; )
        if (a)
          s.push(a), a = a.left;
        else {
          if (a = s.pop(), l = o(a.key, r), l > 0)
            break;
          if (o(a.key, e) >= 0 && n.call(i, a))
            return this;
          a = a.right;
        }
      return this;
    }, t.prototype.keys = function() {
      var e = [];
      return this.forEach(function(r) {
        var n = r.key;
        return e.push(n);
      }), e;
    }, t.prototype.values = function() {
      var e = [];
      return this.forEach(function(r) {
        var n = r.data;
        return e.push(n);
      }), e;
    }, t.prototype.min = function() {
      return this._root ? this.minNode(this._root).key : null;
    }, t.prototype.max = function() {
      return this._root ? this.maxNode(this._root).key : null;
    }, t.prototype.minNode = function(e) {
      if (e === void 0 && (e = this._root), e)
        for (; e.left; )
          e = e.left;
      return e;
    }, t.prototype.maxNode = function(e) {
      if (e === void 0 && (e = this._root), e)
        for (; e.right; )
          e = e.right;
      return e;
    }, t.prototype.at = function(e) {
      for (var r = this._root, n = !1, i = 0, s = []; !n; )
        if (r)
          s.push(r), r = r.left;
        else if (s.length > 0) {
          if (r = s.pop(), i === e)
            return r;
          i++, r = r.right;
        } else
          n = !0;
      return null;
    }, t.prototype.next = function(e) {
      var r = this._root, n = null;
      if (e.right) {
        for (n = e.right; n.left; )
          n = n.left;
        return n;
      }
      for (var i = this._comparator; r; ) {
        var s = i(e.key, r.key);
        if (s === 0)
          break;
        s < 0 ? (n = r, r = r.left) : r = r.right;
      }
      return n;
    }, t.prototype.prev = function(e) {
      var r = this._root, n = null;
      if (e.left !== null) {
        for (n = e.left; n.right; )
          n = n.right;
        return n;
      }
      for (var i = this._comparator; r; ) {
        var s = i(e.key, r.key);
        if (s === 0)
          break;
        s < 0 ? r = r.left : (n = r, r = r.right);
      }
      return n;
    }, t.prototype.clear = function() {
      return this._root = null, this._size = 0, this;
    }, t.prototype.toList = function() {
      return jke(this._root);
    }, t.prototype.load = function(e, r, n) {
      r === void 0 && (r = []), n === void 0 && (n = !1);
      var i = e.length, s = this._comparator;
      if (n && lE(e, r, 0, i - 1, s), this._root === null)
        this._root = oE(e, r, 0, i), this._size = i;
      else {
        var o = Bke(this.toList(), $ke(e, r), s);
        i = this._size + i, this._root = aE({ head: o }, 0, i);
      }
      return this;
    }, t.prototype.isEmpty = function() {
      return this._root === null;
    }, Object.defineProperty(t.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(t.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: !0,
      configurable: !0
    }), t.prototype.toString = function(e) {
      e === void 0 && (e = function(n) {
        return String(n.key);
      });
      var r = [];
      return sE(this._root, "", !0, function(n) {
        return r.push(n);
      }, e), r.join("");
    }, t.prototype.update = function(e, r, n) {
      var i = this._comparator, s = LR(e, this._root, i), o = s.left, a = s.right;
      i(e, r) < 0 ? a = ax(r, n, a, i) : o = ax(r, n, o, i), this._root = Dke(o, a, i);
    }, t.prototype.split = function(e) {
      return LR(e, this._root, this._comparator);
    }, t.prototype[Symbol.iterator] = function() {
      var e, r, n;
      return Mke(this, function(i) {
        switch (i.label) {
          case 0:
            e = this._root, r = [], n = !1, i.label = 1;
          case 1:
            return n ? [3, 6] : e === null ? [3, 2] : (r.push(e), e = e.left, [3, 5]);
          case 2:
            return r.length === 0 ? [3, 4] : (e = r.pop(), [4, e]);
          case 3:
            return i.sent(), e = e.right, [3, 5];
          case 4:
            n = !0, i.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    }, t;
  }()
);
function oE(t, e, r, n) {
  var i = n - r;
  if (i > 0) {
    var s = r + Math.floor(i / 2), o = t[s], a = e[s], l = new hc(o, a);
    return l.left = oE(t, e, r, s), l.right = oE(t, e, s + 1, n), l;
  }
  return null;
}
function $ke(t, e) {
  for (var r = new hc(null, null), n = r, i = 0; i < t.length; i++)
    n = n.next = new hc(t[i], e[i]);
  return n.next = null, r.next;
}
function jke(t) {
  for (var e = t, r = [], n = !1, i = new hc(null, null), s = i; !n; )
    e ? (r.push(e), e = e.left) : r.length > 0 ? (e = s = s.next = r.pop(), e = e.right) : n = !0;
  return s.next = null, i.next;
}
function aE(t, e, r) {
  var n = r - e;
  if (n > 0) {
    var i = e + Math.floor(n / 2), s = aE(t, e, i), o = t.head;
    return o.left = s, t.head = t.head.next, o.right = aE(t, i + 1, r), o;
  }
  return null;
}
function Bke(t, e, r) {
  for (var n = new hc(null, null), i = n, s = t, o = e; s !== null && o !== null; )
    r(s.key, o.key) < 0 ? (i.next = s, s = s.next) : (i.next = o, o = o.next), i = i.next;
  return s !== null ? i.next = s : o !== null && (i.next = o), n.next;
}
function lE(t, e, r, n, i) {
  if (!(r >= n)) {
    for (var s = t[r + n >> 1], o = r - 1, a = n + 1; ; ) {
      do
        o++;
      while (i(t[o], s) < 0);
      do
        a--;
      while (i(t[a], s) > 0);
      if (o >= a)
        break;
      var l = t[o];
      t[o] = t[a], t[a] = l, l = e[o], e[o] = e[a], e[a] = l;
    }
    lE(t, e, r, a, i), lE(t, e, a + 1, n, i);
  }
}
const Pa = 11102230246251565e-32, En = 134217729, Fke = (3 + 8 * Pa) * Pa;
function lx(t, e, r, n, i) {
  let s, o, a, l, c = e[0], p = n[0], h = 0, d = 0;
  p > c == p > -c ? (s = c, c = e[++h]) : (s = p, p = n[++d]);
  let v = 0;
  if (h < t && d < r)
    for (p > c == p > -c ? (o = c + s, a = s - (o - c), c = e[++h]) : (o = p + s, a = s - (o - p), p = n[++d]), s = o, a !== 0 && (i[v++] = a); h < t && d < r; )
      p > c == p > -c ? (o = s + c, l = o - s, a = s - (o - l) + (c - l), c = e[++h]) : (o = s + p, l = o - s, a = s - (o - l) + (p - l), p = n[++d]), s = o, a !== 0 && (i[v++] = a);
  for (; h < t; )
    o = s + c, l = o - s, a = s - (o - l) + (c - l), c = e[++h], s = o, a !== 0 && (i[v++] = a);
  for (; d < r; )
    o = s + p, l = o - s, a = s - (o - l) + (p - l), p = n[++d], s = o, a !== 0 && (i[v++] = a);
  return (s !== 0 || v === 0) && (i[v++] = s), v;
}
function zke(t, e) {
  let r = e[0];
  for (let n = 1; n < t; n++) r += e[n];
  return r;
}
function Am(t) {
  return new Float64Array(t);
}
const Uke = (3 + 16 * Pa) * Pa, Vke = (2 + 12 * Pa) * Pa, Hke = (9 + 64 * Pa) * Pa * Pa, vp = Am(4), MR = Am(8), NR = Am(12), DR = Am(16), Hn = Am(4);
function Gke(t, e, r, n, i, s, o) {
  let a, l, c, p, h, d, v, m, b, f, E, A, x, g, w, _, S, R;
  const L = t - i, F = r - i, z = e - s, j = n - s;
  g = L * j, d = En * L, v = d - (d - L), m = L - v, d = En * j, b = d - (d - j), f = j - b, w = m * f - (g - v * b - m * b - v * f), _ = z * F, d = En * z, v = d - (d - z), m = z - v, d = En * F, b = d - (d - F), f = F - b, S = m * f - (_ - v * b - m * b - v * f), E = w - S, h = w - E, vp[0] = w - (E + h) + (h - S), A = g + E, h = A - g, x = g - (A - h) + (E - h), E = x - _, h = x - E, vp[1] = x - (E + h) + (h - _), R = A + E, h = R - A, vp[2] = A - (R - h) + (E - h), vp[3] = R;
  let W = zke(4, vp), te = Vke * o;
  if (W >= te || -W >= te || (h = t - L, a = t - (L + h) + (h - i), h = r - F, c = r - (F + h) + (h - i), h = e - z, l = e - (z + h) + (h - s), h = n - j, p = n - (j + h) + (h - s), a === 0 && l === 0 && c === 0 && p === 0) || (te = Hke * o + Fke * Math.abs(W), W += L * p + j * a - (z * c + F * l), W >= te || -W >= te)) return W;
  g = a * j, d = En * a, v = d - (d - a), m = a - v, d = En * j, b = d - (d - j), f = j - b, w = m * f - (g - v * b - m * b - v * f), _ = l * F, d = En * l, v = d - (d - l), m = l - v, d = En * F, b = d - (d - F), f = F - b, S = m * f - (_ - v * b - m * b - v * f), E = w - S, h = w - E, Hn[0] = w - (E + h) + (h - S), A = g + E, h = A - g, x = g - (A - h) + (E - h), E = x - _, h = x - E, Hn[1] = x - (E + h) + (h - _), R = A + E, h = R - A, Hn[2] = A - (R - h) + (E - h), Hn[3] = R;
  const le = lx(4, vp, 4, Hn, MR);
  g = L * p, d = En * L, v = d - (d - L), m = L - v, d = En * p, b = d - (d - p), f = p - b, w = m * f - (g - v * b - m * b - v * f), _ = z * c, d = En * z, v = d - (d - z), m = z - v, d = En * c, b = d - (d - c), f = c - b, S = m * f - (_ - v * b - m * b - v * f), E = w - S, h = w - E, Hn[0] = w - (E + h) + (h - S), A = g + E, h = A - g, x = g - (A - h) + (E - h), E = x - _, h = x - E, Hn[1] = x - (E + h) + (h - _), R = A + E, h = R - A, Hn[2] = A - (R - h) + (E - h), Hn[3] = R;
  const ce = lx(le, MR, 4, Hn, NR);
  g = a * p, d = En * a, v = d - (d - a), m = a - v, d = En * p, b = d - (d - p), f = p - b, w = m * f - (g - v * b - m * b - v * f), _ = l * c, d = En * l, v = d - (d - l), m = l - v, d = En * c, b = d - (d - c), f = c - b, S = m * f - (_ - v * b - m * b - v * f), E = w - S, h = w - E, Hn[0] = w - (E + h) + (h - S), A = g + E, h = A - g, x = g - (A - h) + (E - h), E = x - _, h = x - E, Hn[1] = x - (E + h) + (h - _), R = A + E, h = R - A, Hn[2] = A - (R - h) + (E - h), Hn[3] = R;
  const Ee = lx(ce, NR, 4, Hn, DR);
  return DR[Ee - 1];
}
function Wke(t, e, r, n, i, s) {
  const o = (e - s) * (r - i), a = (t - i) * (n - s), l = o - a, c = Math.abs(o + a);
  return Math.abs(l) >= Uke * c ? l : -Gke(t, e, r, n, i, s, c);
}
const If = (t, e) => t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y, cE = (t, e) => {
  if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null;
  const r = t.ll.x < e.ll.x ? e.ll.x : t.ll.x, n = t.ur.x < e.ur.x ? t.ur.x : e.ur.x, i = t.ll.y < e.ll.y ? e.ll.y : t.ll.y, s = t.ur.y < e.ur.y ? t.ur.y : e.ur.y;
  return {
    ll: {
      x: r,
      y: i
    },
    ur: {
      x: n,
      y: s
    }
  };
};
let Ml = Number.EPSILON;
Ml === void 0 && (Ml = Math.pow(2, -52));
const qke = Ml * Ml, $R = (t, e) => {
  if (-Ml < t && t < Ml && -Ml < e && e < Ml)
    return 0;
  const r = t - e;
  return r * r < qke * t * e ? 0 : t < e ? -1 : 1;
};
class Qke {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new jR(), this.yRounder = new jR();
  }
  round(e, r) {
    return {
      x: this.xRounder.round(e),
      y: this.yRounder.round(r)
    };
  }
}
let jR = class {
  constructor() {
    this.tree = new Ok(), this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(e) {
    const r = this.tree.add(e), n = this.tree.prev(r);
    if (n !== null && $R(r.key, n.key) === 0)
      return this.tree.remove(e), n.key;
    const i = this.tree.next(r);
    return i !== null && $R(r.key, i.key) === 0 ? (this.tree.remove(e), i.key) : e;
  }
};
const X0 = new Qke(), G1 = (t, e) => t.x * e.y - t.y * e.x, bV = (t, e) => t.x * e.x + t.y * e.y, BR = (t, e, r) => {
  const n = Wke(t.x, t.y, e.x, e.y, r.x, r.y);
  return n > 0 ? -1 : n < 0 ? 1 : 0;
}, k2 = (t) => Math.sqrt(bV(t, t)), Kke = (t, e, r) => {
  const n = {
    x: e.x - t.x,
    y: e.y - t.y
  }, i = {
    x: r.x - t.x,
    y: r.y - t.y
  };
  return G1(i, n) / k2(i) / k2(n);
}, Yke = (t, e, r) => {
  const n = {
    x: e.x - t.x,
    y: e.y - t.y
  }, i = {
    x: r.x - t.x,
    y: r.y - t.y
  };
  return bV(i, n) / k2(i) / k2(n);
}, FR = (t, e, r) => e.y === 0 ? null : {
  x: t.x + e.x / e.y * (r - t.y),
  y: r
}, zR = (t, e, r) => e.x === 0 ? null : {
  x: r,
  y: t.y + e.y / e.x * (r - t.x)
}, Zke = (t, e, r, n) => {
  if (e.x === 0) return zR(r, n, t.x);
  if (n.x === 0) return zR(t, e, r.x);
  if (e.y === 0) return FR(r, n, t.y);
  if (n.y === 0) return FR(t, e, r.y);
  const i = G1(e, n);
  if (i == 0) return null;
  const s = {
    x: r.x - t.x,
    y: r.y - t.y
  }, o = G1(s, e) / i, a = G1(s, n) / i, l = t.x + a * e.x, c = r.x + o * n.x, p = t.y + a * e.y, h = r.y + o * n.y, d = (l + c) / 2, v = (p + h) / 2;
  return {
    x: d,
    y: v
  };
};
let Co = class wV {
  // for ordering sweep events in the sweep event queue
  static compare(e, r) {
    const n = wV.comparePoints(e.point, r.point);
    return n !== 0 ? n : (e.point !== r.point && e.link(r), e.isLeft !== r.isLeft ? e.isLeft ? 1 : -1 : _2.compare(e.segment, r.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(e, r) {
    return e.x < r.x ? -1 : e.x > r.x ? 1 : e.y < r.y ? -1 : e.y > r.y ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(e, r) {
    e.events === void 0 ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = r;
  }
  link(e) {
    if (e.point === this.point)
      throw new Error("Tried to link already linked events");
    const r = e.point.events;
    for (let n = 0, i = r.length; n < i; n++) {
      const s = r[n];
      this.point.events.push(s), s.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const e = this.point.events.length;
    for (let r = 0; r < e; r++) {
      const n = this.point.events[r];
      if (n.segment.consumedBy === void 0)
        for (let i = r + 1; i < e; i++) {
          const s = this.point.events[i];
          s.consumedBy === void 0 && n.otherSE.point.events === s.otherSE.point.events && n.segment.consume(s.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const e = [];
    for (let r = 0, n = this.point.events.length; r < n; r++) {
      const i = this.point.events[r];
      i !== this && !i.segment.ringOut && i.segment.isInResult() && e.push(i);
    }
    return e;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(e) {
    const r = /* @__PURE__ */ new Map(), n = (i) => {
      const s = i.otherSE;
      r.set(i, {
        sine: Kke(this.point, e.point, s.point),
        cosine: Yke(this.point, e.point, s.point)
      });
    };
    return (i, s) => {
      r.has(i) || n(i), r.has(s) || n(s);
      const {
        sine: o,
        cosine: a
      } = r.get(i), {
        sine: l,
        cosine: c
      } = r.get(s);
      return o >= 0 && l >= 0 ? a < c ? 1 : a > c ? -1 : 0 : o < 0 && l < 0 ? a < c ? -1 : a > c ? 1 : 0 : l < o ? -1 : l > o ? 1 : 0;
    };
  }
}, Jke = 0, _2 = class W1 {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(e, r) {
    const n = e.leftSE.point.x, i = r.leftSE.point.x, s = e.rightSE.point.x, o = r.rightSE.point.x;
    if (o < n) return 1;
    if (s < i) return -1;
    const a = e.leftSE.point.y, l = r.leftSE.point.y, c = e.rightSE.point.y, p = r.rightSE.point.y;
    if (n < i) {
      if (l < a && l < c) return 1;
      if (l > a && l > c) return -1;
      const h = e.comparePoint(r.leftSE.point);
      if (h < 0) return 1;
      if (h > 0) return -1;
      const d = r.comparePoint(e.rightSE.point);
      return d !== 0 ? d : -1;
    }
    if (n > i) {
      if (a < l && a < p) return -1;
      if (a > l && a > p) return 1;
      const h = r.comparePoint(e.leftSE.point);
      if (h !== 0) return h;
      const d = e.comparePoint(r.rightSE.point);
      return d < 0 ? 1 : d > 0 ? -1 : 1;
    }
    if (a < l) return -1;
    if (a > l) return 1;
    if (s < o) {
      const h = r.comparePoint(e.rightSE.point);
      if (h !== 0) return h;
    }
    if (s > o) {
      const h = e.comparePoint(r.rightSE.point);
      if (h < 0) return 1;
      if (h > 0) return -1;
    }
    if (s !== o) {
      const h = c - a, d = s - n, v = p - l, m = o - i;
      if (h > d && v < m) return 1;
      if (h < d && v > m) return -1;
    }
    return s > o ? 1 : s < o || c < p ? -1 : c > p ? 1 : e.id < r.id ? -1 : e.id > r.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(e, r, n, i) {
    this.id = ++Jke, this.leftSE = e, e.segment = this, e.otherSE = r, this.rightSE = r, r.segment = this, r.otherSE = e, this.rings = n, this.windings = i;
  }
  static fromRing(e, r, n) {
    let i, s, o;
    const a = Co.comparePoints(e, r);
    if (a < 0)
      i = e, s = r, o = 1;
    else if (a > 0)
      i = r, s = e, o = -1;
    else throw new Error(`Tried to create degenerate segment at [${e.x}, ${e.y}]`);
    const l = new Co(i, !0), c = new Co(s, !1);
    return new W1(l, c, [n], [o]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(e) {
    this.rightSE = e, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const e = this.leftSE.point.y, r = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: e < r ? e : r
      },
      ur: {
        x: this.rightSE.point.x,
        y: e > r ? e : r
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(e) {
    return e.x === this.leftSE.point.x && e.y === this.leftSE.point.y || e.x === this.rightSE.point.x && e.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(e) {
    if (this.isAnEndpoint(e)) return 0;
    const r = this.leftSE.point, n = this.rightSE.point, i = this.vector();
    if (r.x === n.x)
      return e.x === r.x ? 0 : e.x < r.x ? 1 : -1;
    const s = (e.y - r.y) / i.y, o = r.x + s * i.x;
    if (e.x === o) return 0;
    const a = (e.x - r.x) / i.x, l = r.y + a * i.y;
    return e.y === l ? 0 : e.y < l ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(e) {
    const r = this.bbox(), n = e.bbox(), i = cE(r, n);
    if (i === null) return null;
    const s = this.leftSE.point, o = this.rightSE.point, a = e.leftSE.point, l = e.rightSE.point, c = If(r, a) && this.comparePoint(a) === 0, p = If(n, s) && e.comparePoint(s) === 0, h = If(r, l) && this.comparePoint(l) === 0, d = If(n, o) && e.comparePoint(o) === 0;
    if (p && c)
      return d && !h ? o : !d && h ? l : null;
    if (p)
      return h && s.x === l.x && s.y === l.y ? null : s;
    if (c)
      return d && o.x === a.x && o.y === a.y ? null : a;
    if (d && h) return null;
    if (d) return o;
    if (h) return l;
    const v = Zke(s, this.vector(), a, e.vector());
    return v === null || !If(i, v) ? null : X0.round(v.x, v.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(e) {
    const r = [], n = e.events !== void 0, i = new Co(e, !0), s = new Co(e, !1), o = this.rightSE;
    this.replaceRightSE(s), r.push(s), r.push(i);
    const a = new W1(i, o, this.rings.slice(), this.windings.slice());
    return Co.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), Co.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), n && (i.checkForConsuming(), s.checkForConsuming()), r;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const e = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = e, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let r = 0, n = this.windings.length; r < n; r++)
      this.windings[r] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(e) {
    let r = this, n = e;
    for (; r.consumedBy; ) r = r.consumedBy;
    for (; n.consumedBy; ) n = n.consumedBy;
    const i = W1.compare(r, n);
    if (i !== 0) {
      if (i > 0) {
        const s = r;
        r = n, n = s;
      }
      if (r.prev === n) {
        const s = r;
        r = n, n = s;
      }
      for (let s = 0, o = n.rings.length; s < o; s++) {
        const a = n.rings[s], l = n.windings[s], c = r.rings.indexOf(a);
        c === -1 ? (r.rings.push(a), r.windings.push(l)) : r.windings[c] += l;
      }
      n.rings = null, n.windings = null, n.consumedBy = r, n.leftSE.consumedBy = r.leftSE, n.rightSE.consumedBy = r.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev) this._beforeState = {
      rings: [],
      windings: [],
      multiPolys: []
    };
    else {
      const e = this.prev.consumedBy || this.prev;
      this._beforeState = e.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const e = this.beforeState();
    this._afterState = {
      rings: e.rings.slice(0),
      windings: e.windings.slice(0),
      multiPolys: []
    };
    const r = this._afterState.rings, n = this._afterState.windings, i = this._afterState.multiPolys;
    for (let a = 0, l = this.rings.length; a < l; a++) {
      const c = this.rings[a], p = this.windings[a], h = r.indexOf(c);
      h === -1 ? (r.push(c), n.push(p)) : n[h] += p;
    }
    const s = [], o = [];
    for (let a = 0, l = r.length; a < l; a++) {
      if (n[a] === 0) continue;
      const c = r[a], p = c.poly;
      if (o.indexOf(p) === -1)
        if (c.isExterior) s.push(p);
        else {
          o.indexOf(p) === -1 && o.push(p);
          const h = s.indexOf(c.poly);
          h !== -1 && s.splice(h, 1);
        }
    }
    for (let a = 0, l = s.length; a < l; a++) {
      const c = s[a].multiPoly;
      i.indexOf(c) === -1 && i.push(c);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const e = this.beforeState().multiPolys, r = this.afterState().multiPolys;
    switch (Ds.type) {
      case "union": {
        const n = e.length === 0, i = r.length === 0;
        this._isInResult = n !== i;
        break;
      }
      case "intersection": {
        let n, i;
        e.length < r.length ? (n = e.length, i = r.length) : (n = r.length, i = e.length), this._isInResult = i === Ds.numMultiPolys && n < i;
        break;
      }
      case "xor": {
        const n = Math.abs(e.length - r.length);
        this._isInResult = n % 2 === 1;
        break;
      }
      case "difference": {
        const n = (i) => i.length === 1 && i[0].isSubject;
        this._isInResult = n(e) !== n(r);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${Ds.type}`);
    }
    return this._isInResult;
  }
}, UR = class {
  constructor(e, r, n) {
    if (!Array.isArray(e) || e.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = r, this.isExterior = n, this.segments = [], typeof e[0][0] != "number" || typeof e[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const i = X0.round(e[0][0], e[0][1]);
    this.bbox = {
      ll: {
        x: i.x,
        y: i.y
      },
      ur: {
        x: i.x,
        y: i.y
      }
    };
    let s = i;
    for (let o = 1, a = e.length; o < a; o++) {
      if (typeof e[o][0] != "number" || typeof e[o][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      let l = X0.round(e[o][0], e[o][1]);
      l.x === s.x && l.y === s.y || (this.segments.push(_2.fromRing(s, l, this)), l.x < this.bbox.ll.x && (this.bbox.ll.x = l.x), l.y < this.bbox.ll.y && (this.bbox.ll.y = l.y), l.x > this.bbox.ur.x && (this.bbox.ur.x = l.x), l.y > this.bbox.ur.y && (this.bbox.ur.y = l.y), s = l);
    }
    (i.x !== s.x || i.y !== s.y) && this.segments.push(_2.fromRing(s, i, this));
  }
  getSweepEvents() {
    const e = [];
    for (let r = 0, n = this.segments.length; r < n; r++) {
      const i = this.segments[r];
      e.push(i.leftSE), e.push(i.rightSE);
    }
    return e;
  }
};
class Xke {
  constructor(e, r) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new UR(e[0], this, !0), this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    }, this.interiorRings = [];
    for (let n = 1, i = e.length; n < i; n++) {
      const s = new UR(e[n], this, !1);
      s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.interiorRings.push(s);
    }
    this.multiPoly = r;
  }
  getSweepEvents() {
    const e = this.exteriorRing.getSweepEvents();
    for (let r = 0, n = this.interiorRings.length; r < n; r++) {
      const i = this.interiorRings[r].getSweepEvents();
      for (let s = 0, o = i.length; s < o; s++)
        e.push(i[s]);
    }
    return e;
  }
}
let VR = class {
  constructor(e, r) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof e[0][0][0] == "number" && (e = [e]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let n = 0, i = e.length; n < i; n++) {
      const s = new Xke(e[n], this);
      s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.polys.push(s);
    }
    this.isSubject = r;
  }
  getSweepEvents() {
    const e = [];
    for (let r = 0, n = this.polys.length; r < n; r++) {
      const i = this.polys[r].getSweepEvents();
      for (let s = 0, o = i.length; s < o; s++)
        e.push(i[s]);
    }
    return e;
  }
}, e9e = class uE {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(e) {
    const r = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      if (!s.isInResult() || s.ringOut) continue;
      let o = null, a = s.leftSE, l = s.rightSE;
      const c = [a], p = a.point, h = [];
      for (; o = a, a = l, c.push(a), a.point !== p; )
        for (; ; ) {
          const d = a.getAvailableLinkedEvents();
          if (d.length === 0) {
            const b = c[0].point, f = c[c.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${b.x}, ${b.y}]. Last matching segment found ends at [${f.x}, ${f.y}].`);
          }
          if (d.length === 1) {
            l = d[0].otherSE;
            break;
          }
          let v = null;
          for (let b = 0, f = h.length; b < f; b++)
            if (h[b].point === a.point) {
              v = b;
              break;
            }
          if (v !== null) {
            const b = h.splice(v)[0], f = c.splice(b.index);
            f.unshift(f[0].otherSE), r.push(new uE(f.reverse()));
            continue;
          }
          h.push({
            index: c.length,
            point: a.point
          });
          const m = a.getLeftmostComparator(o);
          l = d.sort(m)[0].otherSE;
          break;
        }
      r.push(new uE(c));
    }
    return r;
  }
  constructor(e) {
    this.events = e;
    for (let r = 0, n = e.length; r < n; r++)
      e[r].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let e = this.events[0].point;
    const r = [e];
    for (let c = 1, p = this.events.length - 1; c < p; c++) {
      const h = this.events[c].point, d = this.events[c + 1].point;
      BR(h, e, d) !== 0 && (r.push(h), e = h);
    }
    if (r.length === 1) return null;
    const n = r[0], i = r[1];
    BR(n, e, i) === 0 && r.shift(), r.push(r[0]);
    const s = this.isExteriorRing() ? 1 : -1, o = this.isExteriorRing() ? 0 : r.length - 1, a = this.isExteriorRing() ? r.length : -1, l = [];
    for (let c = o; c != a; c += s) l.push([r[c].x, r[c].y]);
    return l;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const e = this.enclosingRing();
      this._isExteriorRing = e ? !e.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let e = this.events[0];
    for (let i = 1, s = this.events.length; i < s; i++) {
      const o = this.events[i];
      Co.compare(e, o) > 0 && (e = o);
    }
    let r = e.segment.prevInResult(), n = r ? r.prevInResult() : null;
    for (; ; ) {
      if (!r) return null;
      if (!n) return r.ringOut;
      if (n.ringOut !== r.ringOut)
        return n.ringOut.enclosingRing() !== r.ringOut ? r.ringOut : r.ringOut.enclosingRing();
      r = n.prevInResult(), n = r ? r.prevInResult() : null;
    }
  }
}, HR = class {
  constructor(e) {
    this.exteriorRing = e, e.poly = this, this.interiorRings = [];
  }
  addInterior(e) {
    this.interiorRings.push(e), e.poly = this;
  }
  getGeom() {
    const e = [this.exteriorRing.getGeom()];
    if (e[0] === null) return null;
    for (let r = 0, n = this.interiorRings.length; r < n; r++) {
      const i = this.interiorRings[r].getGeom();
      i !== null && e.push(i);
    }
    return e;
  }
};
class t9e {
  constructor(e) {
    this.rings = e, this.polys = this._composePolys(e);
  }
  getGeom() {
    const e = [];
    for (let r = 0, n = this.polys.length; r < n; r++) {
      const i = this.polys[r].getGeom();
      i !== null && e.push(i);
    }
    return e;
  }
  _composePolys(e) {
    const r = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      if (!s.poly)
        if (s.isExteriorRing()) r.push(new HR(s));
        else {
          const o = s.enclosingRing();
          o.poly || r.push(new HR(o)), o.poly.addInterior(s);
        }
    }
    return r;
  }
}
class r9e {
  constructor(e) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _2.compare;
    this.queue = e, this.tree = new Ok(r), this.segments = [];
  }
  process(e) {
    const r = e.segment, n = [];
    if (e.consumedBy)
      return e.isLeft ? this.queue.remove(e.otherSE) : this.tree.remove(r), n;
    const i = e.isLeft ? this.tree.add(r) : this.tree.find(r);
    if (!i) throw new Error(`Unable to find segment #${r.id} [${r.leftSE.point.x}, ${r.leftSE.point.y}] -> [${r.rightSE.point.x}, ${r.rightSE.point.y}] in SweepLine tree.`);
    let s = i, o = i, a, l;
    for (; a === void 0; )
      s = this.tree.prev(s), s === null ? a = null : s.key.consumedBy === void 0 && (a = s.key);
    for (; l === void 0; )
      o = this.tree.next(o), o === null ? l = null : o.key.consumedBy === void 0 && (l = o.key);
    if (e.isLeft) {
      let c = null;
      if (a) {
        const h = a.getIntersection(r);
        if (h !== null && (r.isAnEndpoint(h) || (c = h), !a.isAnEndpoint(h))) {
          const d = this._splitSafely(a, h);
          for (let v = 0, m = d.length; v < m; v++)
            n.push(d[v]);
        }
      }
      let p = null;
      if (l) {
        const h = l.getIntersection(r);
        if (h !== null && (r.isAnEndpoint(h) || (p = h), !l.isAnEndpoint(h))) {
          const d = this._splitSafely(l, h);
          for (let v = 0, m = d.length; v < m; v++)
            n.push(d[v]);
        }
      }
      if (c !== null || p !== null) {
        let h = null;
        c === null ? h = p : p === null ? h = c : h = Co.comparePoints(c, p) <= 0 ? c : p, this.queue.remove(r.rightSE), n.push(r.rightSE);
        const d = r.split(h);
        for (let v = 0, m = d.length; v < m; v++)
          n.push(d[v]);
      }
      n.length > 0 ? (this.tree.remove(r), n.push(e)) : (this.segments.push(r), r.prev = a);
    } else {
      if (a && l) {
        const c = a.getIntersection(l);
        if (c !== null) {
          if (!a.isAnEndpoint(c)) {
            const p = this._splitSafely(a, c);
            for (let h = 0, d = p.length; h < d; h++)
              n.push(p[h]);
          }
          if (!l.isAnEndpoint(c)) {
            const p = this._splitSafely(l, c);
            for (let h = 0, d = p.length; h < d; h++)
              n.push(p[h]);
          }
        }
      }
      this.tree.remove(r);
    }
    return n;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(e, r) {
    this.tree.remove(e);
    const n = e.rightSE;
    this.queue.remove(n);
    const i = e.split(r);
    return i.push(n), e.consumedBy === void 0 && this.tree.add(e), i;
  }
}
const GR = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, n9e = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
class i9e {
  run(e, r, n) {
    Ds.type = e, X0.reset();
    const i = [new VR(r, !0)];
    for (let p = 0, h = n.length; p < h; p++)
      i.push(new VR(n[p], !1));
    if (Ds.numMultiPolys = i.length, Ds.type === "difference") {
      const p = i[0];
      let h = 1;
      for (; h < i.length; )
        cE(i[h].bbox, p.bbox) !== null ? h++ : i.splice(h, 1);
    }
    if (Ds.type === "intersection")
      for (let p = 0, h = i.length; p < h; p++) {
        const d = i[p];
        for (let v = p + 1, m = i.length; v < m; v++)
          if (cE(d.bbox, i[v].bbox) === null) return [];
      }
    const s = new Ok(Co.compare);
    for (let p = 0, h = i.length; p < h; p++) {
      const d = i[p].getSweepEvents();
      for (let v = 0, m = d.length; v < m; v++)
        if (s.insert(d[v]), s.size > GR)
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
    }
    const o = new r9e(s);
    let a = s.size, l = s.pop();
    for (; l; ) {
      const p = l.key;
      if (s.size === a) {
        const d = p.segment;
        throw new Error(`Unable to pop() ${p.isLeft ? "left" : "right"} SweepEvent [${p.point.x}, ${p.point.y}] from segment #${d.id} [${d.leftSE.point.x}, ${d.leftSE.point.y}] -> [${d.rightSE.point.x}, ${d.rightSE.point.y}] from queue.`);
      }
      if (s.size > GR)
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      if (o.segments.length > n9e)
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      const h = o.process(p);
      for (let d = 0, v = h.length; d < v; d++) {
        const m = h[d];
        m.consumedBy === void 0 && s.insert(m);
      }
      a = s.size, l = s.pop();
    }
    X0.reset();
    const c = e9e.factory(o.segments);
    return new t9e(c).getGeom();
  }
}
const Ds = new i9e(), s9e = function(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  return Ds.run("union", t, r);
}, o9e = function(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  return Ds.run("intersection", t, r);
}, a9e = function(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  return Ds.run("xor", t, r);
}, l9e = function(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  return Ds.run("difference", t, r);
};
var c9e = {
  union: s9e,
  intersection: o9e,
  xor: a9e,
  difference: l9e
};
function WR(t, e, r) {
  const n = t.length;
  if (n == 0)
    throw new Error("Error: Given data has zero length");
  const i = [];
  let s = [], o = [];
  if (r != null) {
    if (n != r.length)
      throw new Error("Error: Given labels do not match length of data");
    o = [...new Set(r.flat())];
    for (let W = 0; W < o.length; W++)
      s.push({ label: o[W], factor: W });
    for (let W = 0; W < r.length; W++)
      i.push(o.indexOf(r[W]));
  }
  const a = 4, l = [];
  for (let W = 0; W < n; W++)
    l.push([Number(t[W].x), Number(t[W].y)]);
  const c = [], p = [];
  for (let W = 0; W < n; W++)
    p.push(d9e(l, W, a));
  for (let W = 0; W < n; W++) {
    let te = 0;
    for (let le = 0; le < n; le++)
      te += p[le][W];
    c.push(te / n);
  }
  const h = new Lke(l, 2 * c[a], a, e);
  let d = h.clusters, v = h.clusterCentroids, m = h.noiseAssigned;
  if (r != null) {
    d = [];
    for (let W = 0; W < o.length; W++)
      d.push([]);
    for (let W = 0; W < l.length; W++) {
      let te = i[W];
      d[te].push(W);
    }
    v = [];
    for (let W = 0; W < d.length; W++) {
      let te = [];
      for (let le of d[W])
        te.push(l[le]);
      v.push(E9e(te));
    }
    m = [];
  }
  const b = [], f = b9e(v), E = w9e(f), A = [], x = [];
  for (let W = 0; W < n; W++)
    A.push(l[W][0]), x.push(l[W][1]);
  const g = Math.max(...x), w = Math.max(...A), _ = Math.min(...x), S = Math.min(...A);
  let R = 0;
  for (let W of d) {
    const te = {
      area: 0,
      centroid: [],
      dataPoints: [],
      dataPointIDs: [],
      outlierIDs: [],
      density: 0,
      densityRank: 0,
      hasSignificantHole: !1,
      holes: [],
      hull: [],
      hullIDs: [],
      hullSimplified: [],
      id: 0,
      perimeter: 0,
      region: 0,
      regionDesc: "",
      relations: [{
        angle: 0,
        cardDirection: "",
        distance: 0,
        id: 0,
        isNeighbor: !1
      }],
      shape: { description: "" },
      xMin: 0,
      xMax: 0,
      yMin: 0,
      yMax: 0
    }, le = [];
    for (let ee of W)
      le.push(l[ee]);
    r && (te.label = o[R]), te.dataPoints = le, te.dataPointIDs = W;
    let ce = le[0][0], Ee = le[0][0], xe = le[0][1], _e = le[0][1];
    for (let ee of le)
      ee[0] < ce && (ce = ee[0]), ee[0] > Ee && (Ee = ee[0]), ee[1] < xe && (xe = ee[1]), ee[1] > _e && (_e = ee[1]);
    te.xMin = ce, te.xMax = Ee, te.yMin = xe, te.yMax = _e, te.centroid = v[R], te.id = R, te.region = f[R], te.regionDesc = E[R];
    const Ie = iE(r0(le));
    te.hull = Ie;
    for (let ee of Ie) {
      const ae = l.findIndex((me) => me[0] == ee.x && me[1] == ee.y);
      te.hullIDs.push(ae);
    }
    const je = qR(Ie);
    te.hullSimplified = je;
    const ue = q1(Ie);
    te.area = ue;
    const O = Tk(Ie);
    te.perimeter = O;
    const N = j(te);
    te.shape = N;
    const J = W.length / ue;
    te.density = J, te.relations = [];
    const re = y9e(v, R), oe = p9e(v, R);
    for (let ee = 0; ee < d.length; ee++) {
      const ae = To(v[R], v[re[ee]]), me = x9e(v[R], v[re[ee]]);
      te.relations.push({
        id: re[ee],
        distance: oe[ee],
        angle: ae,
        cardDirection: me
      });
    }
    te.holes = h9e(te), te.holes[0][2] > 0.2 ? te.hasSignificantHole = !0 : te.hasSignificantHole = !1, b.push(te), R++;
  }
  for (let W of m)
    b[W[1]].outlierIDs.push(W[0]);
  const L = JSON.parse(JSON.stringify(b)).sort((W, te) => W.density - te.density), F = [];
  for (let W of L)
    F.push(W.id);
  for (let W of b)
    W.densityRank = F.indexOf(W.id);
  R = 0;
  const z = 1.2;
  for (let W of v) {
    let te = 0;
    for (let le of v) {
      let ce = [];
      if (R == te)
        b[R].relations[0].isNeighbor = !0, te++;
      else {
        R < te && (ce = [...v.slice(0, R), ...v.slice(R + 1)], ce.splice(te - 1, 1)), R > te && (ce = [...v.slice(0, te), ...v.slice(te + 1)], ce.splice(R - 1, 1));
        const Ee = dr(W, le), xe = [];
        for (let Ie of ce)
          dr(W, Ie) < dr(W, le) && xe.push(dr(W, Ie) + dr(Ie, le));
        let _e = {
          angle: 0,
          cardDirection: "",
          distance: 0,
          id: 0,
          isNeighbor: !1
        };
        for (let Ie of b[R].relations)
          Ie.id == te && (_e = Ie);
        Math.min(...xe) < z * Ee ? b[R].relations[b[R].relations.indexOf(_e)].isNeighbor = !1 : b[R].relations[b[R].relations.indexOf(_e)].isNeighbor = !0, te++;
      }
    }
    R++;
  }
  for (let W in b) {
    let te = b[W];
    for (let le in b) {
      let ce = 0;
      for (let Ee in b[W].relations)
        b[W].relations[Ee].id == Number(le) && (ce = Number(Ee));
      if (W == le)
        b[W].relations[ce].overlap = 1;
      else {
        let Ee = b[le], xe = c9e.intersection([Ts(te.hull)], [Ts(Ee.hull)]);
        if (xe.length > 0) {
          let _e = q1(r0(xe[0][0])) / te.area;
          b[W].relations[ce].overlap = _e, b[W].relations[ce].sharedPts = [];
          for (let Ie of te.dataPoints) {
            let je = 10 ** (Math.log10(Math.max(te.xMax - te.xMin, te.yMax - te.yMin)) - 4);
            nE(Ts(Ee.hull), Ie, je) < 1 && b[W].relations[ce].sharedPts.push(Ie);
          }
          b[W].relations[ce].percentPtsShared = b[W].relations[ce].sharedPts.length / b[W].dataPoints.length;
        } else
          b[W].relations[ce].overlap = 0;
      }
    }
  }
  function j(W) {
    const te = W.dataPoints, le = iE(r0(te)), ce = v9e(le);
    if (ce > 0.92)
      return {
        description: "roughly circular",
        radius: Math.sqrt(q1(le) / Math.PI)
      };
    if (ce > 0.7) {
      const Ee = Ts(qR(le)), xe = Ee.length;
      switch (!0) {
        case xe == 3:
          return {
            description: "triangular",
            averageSideLength: (dr(Ee[0], Ee[1]) + dr(Ee[1], Ee[2]) + dr(Ee[2], Ee[0])) / 3
          };
        case xe == 4:
          const _e = To(Ee[0], Ee[1]), Ie = To(Ee[1], Ee[2]), je = To(Ee[2], Ee[3]), ue = To(Ee[3], Ee[0]), O = Ie - _e, N = je - Ie, J = ue - je, re = _e - ue;
          if (Math.abs((O + 720) % 360 - 270) < 15 && Math.abs((N + 720) % 360 - 270) < 15 && Math.abs((J + 720) % 360 - 270) < 15 && Math.abs((re + 720) % 360 - 270) < 15) {
            const X = dr(Ee[0], Ee[1]), Ae = dr(Ee[1], Ee[2]), Re = dr(Ee[2], Ee[3]), Fe = dr(Ee[3], Ee[0]), Te = (X + Ae + Re + Fe) / 4;
            return Te * 0.91 < X && X < Te * 1.1 && Te * 0.91 < Ae && Ae < Te * 1.1 && Te * 0.91 < Re && Re < Te * 1.1 && Te * 0.91 < Fe && Fe < Te * 1.1 ? (_e % 90 + Ie % 90 + je % 90 + ue % 90) / 4 > 25 && (_e % 90 + Ie % 90 + je % 90 + ue % 90) / 4 < 65 ? {
              description: "diamond",
              averageSideLength: Te
            } : {
              description: "square",
              averageSideLength: Te
            } : { description: "rectangular" };
          } else return Math.abs((O + 720) % 360 - (J + 720) % 360) < 20 && Math.abs((N + 720) % 360 - (re + 720) % 360) < 20 ? { description: "parallelogram" } : { description: "irregular quadrilateral" };
        case xe == 5:
          return { description: "pentagon" };
        case xe > 5:
          const oe = [], ee = [];
          for (let X = 0; X < le.length; X++)
            oe.push(le[X].x), ee.push(le[X].y);
          const ae = QR(oe, ee)[1], me = (Math.max(...oe) - Math.min(...oe)) / (w - S), H = (Math.max(...ee) - Math.min(...ee)) / (g - _);
          if (me / H > 2 || H / me > 2)
            return me > H ? {
              description: "elliptical: horizontal",
              slope: ae
            } : {
              description: "elliptical: vertical",
              slope: ae
            };
          switch (!0) {
            case ae >= 0.3:
              return {
                description: "elliptical: positively correlated",
                slope: ae
              };
            case ae <= -0.3:
              return {
                description: "elliptical: negatively correlated",
                slope: ae
              };
            case (ae < 0.3 && ae > -0.3 && (Math.max(...oe) - Math.min(...oe)) / (w - S) > (Math.max(...ee) - Math.min(...ee)) / (g - _)):
              return {
                description: "elliptical: horizontal",
                slope: ae
              };
            case (ae < 0.3 && ae > -0.3 && (Math.max(...oe) - Math.min(...oe)) / (w - S) <= (Math.max(...ee) - Math.min(...ee)) / (g - _)):
              return {
                description: "elliptical: vertical",
                slope: ae
              };
          }
      }
    } else {
      const Ee = [], xe = [];
      for (let Ie = 0; Ie < le.length; Ie++)
        Ee.push(le[Ie].x), xe.push(le[Ie].y);
      const _e = QR(Ee, xe)[1];
      switch (!0) {
        case _e > 0.3:
          return {
            description: "roughly linear: positively correlated",
            slope: _e
          };
        case _e < -0.3:
          return {
            description: "roughly linear: negatively correlated",
            slope: _e
          };
        case (_e < 0.3 && _e > -0.3 && (Math.max(...Ee) - Math.min(...Ee)) / (w - S) > (Math.max(...xe) - Math.min(...xe)) / (g - _)):
          return {
            description: "roughly linear: horizontal",
            slope: _e
          };
        case (_e < 0.3 && _e > -0.3 && (Math.max(...Ee) - Math.min(...Ee)) / (w - S) < (Math.max(...xe) - Math.min(...xe)) / (g - _)):
          return {
            description: "roughly linear: vertical",
            slope: _e
          };
      }
    }
    throw new Error("Something has gone wrong in judgeShape()");
  }
  return b;
}
function qR(t) {
  const e = Ts(t), r = 15;
  let n = e.length;
  for (let o = 0; o < n; o++) {
    const a = To(e[o % n], e[(o + 1) % n]), l = To(e[(o + 1) % n], e[(o + 2) % n]) - a;
    (Math.abs(l) < r || Math.abs(l + 360) < r || Math.abs(l - 360) < r) && (e.splice((o + 1) % n, 1), o--, n--);
  }
  const i = 20, s = Tk(t);
  for (let o = 0; o < n; o++)
    if (dr(e[(o + 1) % n], e[(o + 2) % n]) < s / i) {
      const a = To(e[o % n], e[(o + 1) % n]), l = To(e[(o + 2) % n], e[(o + 3) % n]) - a;
      if (!(160 < (l + 720) % 360 && (l + 720) % 360 < 200)) {
        const c = xV(e[o % n], e[(o + 1) % n], e[(o + 2) % n], e[(o + 3) % n]);
        e[(o + 1) % n] = c, e.splice((o + 2) % n, 1), o--, n--;
      }
    }
  return r0(e);
}
function xV(t, e, r, n) {
  if (Array.isArray(t) || (t = [t.x, t.y]), Array.isArray(e) || (e = [e.x, e.y]), Array.isArray(r) || (r = [r.x, r.y]), Array.isArray(n) || (n = [n.x, n.y]), e[0] - t[0] == 0) {
    if (n[0] - r[0] == 0)
      throw new Error("Error: attempting to compare parallel lines in completeAngle");
    return [t[0], (n[1] - r[1]) / (n[0] - r[0]) * t[0] + r[1] - (n[1] - r[1]) / (n[0] - r[0]) * r[0]];
  }
  if (n[0] - r[0] == 0)
    return [r[0], (e[1] - t[1]) / (e[0] - t[0]) * r[0] + t[1] - (e[1] - t[1]) / (e[0] - t[0]) * t[0]];
  const i = (e[1] - t[1]) / (e[0] - t[0]), s = (n[1] - r[1]) / (n[0] - r[0]);
  if (i - s == 0)
    throw new Error("Error: attempting to compare parallel lines in completeAngle");
  const o = (t[1] - r[1] - i * t[0] + s * r[0]) / (s - i);
  return [o, i * o + t[1] - i * t[0]];
}
function u9e(t, e, r, n) {
  if (Array.isArray(t) || (t = [t.x, t.y]), Array.isArray(e) || (e = [e.x, e.y]), Array.isArray(r) || (r = [r.x, r.y]), Array.isArray(n) || (n = [n.x, n.y]), e[0] - t[0] == 0)
    return n[0] - r[0] == 0;
  const i = (e[1] - t[1]) / (e[0] - t[0]), s = (n[1] - r[1]) / (n[0] - r[0]);
  return i - s == 0;
}
function QR(t, e) {
  const r = t.length;
  let n = 0, i = 0, s = 0, o = 0;
  for (let l = 0; l < r; l++) {
    const c = t[l], p = e[l];
    n += c, i += p, s += c * p, o += c * c;
  }
  const a = (r * s - n * i) / (r * o - n * n);
  return [i / r - a * (n / r), a];
}
function h9e(t) {
  const e = r0(t.dataPoints), r = new pt(), n = { xl: t.xMin, xr: t.xMax, yt: t.yMin, yb: t.yMax }, i = r.compute(e, n), s = iE(e), o = [], a = [];
  for (let b of i.edges) {
    const f = [b.va.x, b.va.y], E = [b.vb.x, b.vb.y], A = s.length;
    for (let x = 0; x < A; x++)
      if (!u9e(f, E, s[x % A], s[(x + 1) % A])) {
        let g = xV(f, E, s[x % A], s[(x + 1) % A]);
        (g[0] > f[0] && g[0] < E[0] || g[0] < f[0] && g[0] > E[0]) && (g[1] > f[1] && g[1] < E[1] || g[1] < f[1] && g[1] > E[1]) && o.push(g);
      }
  }
  const l = 10 ** (Math.log10(Math.max(t.xMax - t.xMin, t.yMax - t.yMin)) - 4);
  for (let b of Ts(i.vertices))
    nE(Ts(s), b, l) < 1 && a.push(b);
  for (let b of o)
    nE(Ts(s), b, l) < 1 && a.push(b);
  let c = [];
  for (let b in a) {
    let f = a[b], E = [Number(b), dr(f, Ts(e)[0])];
    for (let A of Ts(e))
      E[1] > dr(f, A) && (E = [Number(b), dr(f, A)]);
    c.push(E);
  }
  let p = c.sort((b, f) => f[1] - b[1]);
  for (let b in p) {
    const f = p[b];
    let E = Number(b) + 1;
    for (; E < p.length; )
      dr(a[f[0]], a[p[E][0]]) < f[1] && (p.splice(E, 1), E--), E++;
  }
  const h = Ts(t.hull);
  let d = dr(h[0], t.centroid), v = 0;
  for (let b of h) {
    const f = dr(b, t.centroid);
    d < f && (d = f), v += f / h.length;
  }
  const m = [];
  for (let b = 0; b < p.length; b++) {
    const f = [a[p[b][0]], p[b][1], 0], E = dr(f[0], t.centroid), A = f[1] / v * (1 - E / d);
    f[2] = A, m.push(f);
  }
  return m.sort((b, f) => f[2] - b[2]);
}
function dr(t, e) {
  let r = 0, n = Math.min(t.length, e.length);
  for (; n--; )
    r += (t[n] - e[n]) * (t[n] - e[n]);
  return Math.sqrt(r);
}
function p9e(t, e) {
  const r = [];
  for (let n = 0; n < t.length; n++) {
    const i = dr(t[e], t[n]);
    r.push(i);
  }
  return r.sort((n, i) => n - i), r;
}
function d9e(t, e, r) {
  const n = [];
  for (let i = 0; i < t.length; i++) {
    const s = dr(t[e], t[i]);
    n.push(s);
  }
  return m9e(n, 2 * r);
}
function f9e(t, e, r, n) {
  let i;
  for (typeof r > "u" && (r = 0), typeof n > "u" && (n = t.length); r < n; )
    i = Math.floor((r + n) / 2), e < t[i] ? n = i : r = i + 1;
  return r;
}
function g9e(t, e) {
  t.splice(f9e(t, e), 0, e);
}
function m9e(t, e) {
  let r = [];
  for (let n = 0, i = t.length; n < i; ++n) {
    const s = t[n];
    (r.length < e || s < r[r.length - 1]) && (g9e(r, s), r.length > e && r.splice(e, 1));
  }
  return r;
}
function y9e(t, e) {
  let r = [];
  for (let i = 0; i < t.length; i++) {
    const s = [i, dr(t[e], t[i])];
    r.push(s);
  }
  r = r.sort((i, s) => i[1] - s[1]);
  const n = [];
  for (let i = 0; i < t.length; i++)
    n.push(r[i][0]);
  return n;
}
function q1(t) {
  if (t.length == 0)
    return 0;
  let e = 0;
  const r = t.length;
  for (let n = 0; n < r - 1; n++)
    e += t[n].x * t[n + 1].y - t[n].y * t[n + 1].x;
  return e += t[r - 1].x * t[0].y - t[r - 1].y * t[0].x, Math.abs(e / 2);
}
function Tk(t) {
  let e = 0;
  const r = t.length;
  if (r < 2)
    return 0;
  if (r == 2)
    return dr([t[0].x, t[0].y], [t[1].x, t[1].y]);
  for (let n = 0; n < r - 1; n++) {
    let i = [t[n].x, t[n].y], s = [t[n + 1].x, t[n + 1].y];
    e += dr(i, s);
  }
  return e += dr([t[r - 1].x, t[r - 1].y], [t[0].x, t[0].y]), e;
}
function v9e(t) {
  return 2 * Math.sqrt(q1(t) * Math.PI) / Tk(t);
}
function b9e(t) {
  const e = [], r = t.length;
  let n = t[0][0], i = t[0][1], s = t[0][0], o = t[0][1];
  for (let h = 0; h < r; h++)
    n < t[h][0] && (n = t[h][0]), s > t[h][0] && (s = t[h][0]), i < t[h][1] && (i = t[h][1]), o > t[h][1] && (o = t[h][1]);
  const a = (n - s) / 3 + s, l = (n - s) * 2 / 3 + s, c = (i - o) / 3 + o, p = (i - o) * 2 / 3 + o;
  for (let h of t) {
    const d = [h[0] < a, h[0] < l, h[1] < c, h[1] < p];
    switch (!0) {
      case JSON.stringify(d) == JSON.stringify([!0, !0, !0, !0]):
        e.push(0);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !0, !0, !0]):
        e.push(1);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !1, !0, !0]):
        e.push(2);
        break;
      case JSON.stringify(d) == JSON.stringify([!0, !0, !1, !0]):
        e.push(3);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !0, !1, !0]):
        e.push(4);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !1, !1, !0]):
        e.push(5);
        break;
      case JSON.stringify(d) == JSON.stringify([!0, !0, !1, !1]):
        e.push(6);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !0, !1, !1]):
        e.push(7);
        break;
      case JSON.stringify(d) == JSON.stringify([!1, !1, !1, !1]):
        e.push(8);
    }
  }
  return e;
}
function w9e(t) {
  const e = [], r = t.length;
  for (let n = 0; n < r; n++) {
    const i = t[n];
    switch (!0) {
      case i == 0:
        e.push("bottom left");
        break;
      case i == 1:
        e.push("bottom center");
        break;
      case i == 2:
        e.push("bottom right");
        break;
      case i == 3:
        e.push("left");
        break;
      case i == 4:
        e.push("center");
        break;
      case i == 5:
        e.push("right");
        break;
      case i == 6:
        e.push("top left");
        break;
      case i == 7:
        e.push("top center");
        break;
      case i == 8:
        e.push("top right");
    }
  }
  return e;
}
function To(t, e) {
  const r = e.map((i, s) => i - t[s]);
  let n = 0;
  if (r[0] == 0 && r[1] > 0)
    return 90;
  if (r[0] == 0 && r[1] < 0)
    return 270;
  if (r[1] == 0 && r[0] >= 0)
    return 0;
  if (r[1] == 0 && r[0] < 0)
    return 180;
  switch (!0) {
    case (r[0] > 0 && r[1] > 0):
      n = Math.atan(r[1] / r[0]);
      break;
    case (r[0] < 0 && r[1] > 0):
      n = Math.atan(r[0] / r[1]), n = Math.abs(n) + Math.PI / 2;
      break;
    case (r[0] < 0 && r[1] < 0):
      n = Math.atan(r[1] / r[0]), n = Math.abs(n) + Math.PI;
      break;
    case (r[0] > 0 && r[1] < 0):
      n = Math.atan(r[0] / r[1]), n = Math.abs(n) + 3 * Math.PI / 2;
      break;
  }
  return n = n * 180 / Math.PI, n;
}
function x9e(t, e) {
  const r = To(t, e);
  switch (!0) {
    case (345 < r || r <= 15):
      return "east";
    case (15 < r && r <= 75):
      return "north-east";
    case (75 < r && r <= 105):
      return "north";
    case (105 < r && r <= 165):
      return "north-west";
    case (165 < r && r <= 195):
      return "west";
    case (195 < r && r <= 255):
      return "south-west";
    case (255 < r && r <= 285):
      return "south";
    case (285 < r && r <= 345):
      return "south-east";
  }
  throw new Error("Error: undefined angle in judgeAngle()");
}
function Ts(t) {
  if (t.length == 0)
    return [];
  const e = [];
  for (let r = 0; r < t.length; r++)
    e.push([t[r].x, t[r].y]);
  return e;
}
function r0(t) {
  if (t.length == 0)
    return [];
  const e = [];
  for (let r = 0; r < t.length; r++)
    e.push({ x: t[r][0], y: t[r][1] });
  return e;
}
function E9e(t) {
  var e = [0, 0], r = 0, n = 0, i = t.length;
  for (r = 0; r < i; r++)
    for (n = 0; n < t[r].length; n++)
      e[n] !== void 0 || e.push(0), e[n] += t[r][n] / i;
  return e;
}
class S9e extends fV {
  constructor(e, r) {
    super(e, r), this._currentCluster = -1;
  }
  _init() {
    this._generateClustering(), super._init(), this._axisInfo = new Jb(this._store, {
      xValues: this._store.model.allFacetValues("x").map((e) => e.value),
      yValues: this._store.model.allFacetValues("y").map((e) => e.value)
    });
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "checkbox",
      key: "type.scatter.isDrawTrendLine",
      label: "Trend line",
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "type.scatter.isShowOutliers",
      label: "Show outliers",
      parentView: "controlPanel.tabs.chart.chart"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "chart.showPopups",
      label: "Show popups",
      parentView: "controlPanel.tabs.chart.popups"
    });
  }
  get clustering() {
    return this._clustering;
  }
  get currentCluster() {
    return this._currentCluster;
  }
  get _datapointNavNodeType() {
    return "scatterpoint";
  }
  _datapointNavNodeOptions(e) {
    const r = super._datapointNavNodeOptions(e);
    return r.cluster = this._findCluster(e.datapointIndex), r;
  }
  _createNavMap() {
    super._createNavMap(), this._clustering && this._createClusterNavNodes();
  }
  _generateClustering() {
    const e = [], r = this._store.model.series;
    for (const i of r)
      for (let s = 0; s < i.length; s++)
        e.push({ x: Number(i.rawData[s].x), y: Number(i.rawData[s].y) });
    const n = [];
    if (r.length > 1)
      for (const i of r)
        for (let s = 0; s < i.length; s++)
          n.push(i[s].seriesKey);
    this._store.model.numSeries > 1 ? this._clustering = WR(e, !0, n) : this._clustering = WR(e, !1);
  }
  get navDatapointType() {
    return "scatterpoint";
  }
  seriesInNavOrder() {
    return this._store.model.series;
  }
  _createClusterNavNodes() {
    const e = [];
    this._navMap.root.query("series").forEach((n) => {
      e.length && n.connect("left", e.at(-1).at(-1));
      let i = this.clustering;
      this._store.model.numSeries > 1 && (i = i.slice(n.index, n.index + 1));
      const s = n.allNodes("right", "scatterpoint"), o = [];
      i.forEach((a) => {
        const l = new Ia(n.layer, "cluster", {
          seriesKey: n.options.seriesKey,
          start: 0,
          //cluster.dataPointIDs[0],
          end: a.dataPointIDs.length - 1,
          //cluster.dataPointIDs[cluster.dataPointIDs.length - 1],
          datapoints: this._store.model.numSeries > 1 ? a.dataPointIDs.map((c) => c - a.dataPointIDs[0]) : [...a.dataPointIDs, ...a.outlierIDs],
          clustering: a
        }, this._store);
        o.push(l);
      }), e.push(o), o.sort((a, l) => a.options.clustering.centroid[0] - l.options.clustering.centroid[0]), o.slice(0, -1).forEach((a, l) => {
        a.connect("right", o[l + 1]);
      }), n.connect("right", o[0]), s[0].disconnect("left", !1), s.at(-1).disconnect("right"), o.forEach((a) => {
        a.connect(
          "in",
          s[0],
          !s[0].getLink("out")
        );
        for (const l of s)
          l.connect("out", a, !1);
        a.peekNode("right", 1) && s.at(-1).connect("in", a.peekNode("right", 1), !1);
      });
    });
    const r = this.navMap.node("top", {});
    e.forEach((n, i) => {
      n.forEach((s, o) => {
        s.connect("out", r, !1);
      });
    }), r.connect("right", e[0][0], !0), e.slice(0, -1).forEach((n, i) => {
      n[n.length - 1].connect("right", e[i + 1][0], !0);
    });
  }
  _findCluster(e) {
    return this._clustering.findIndex((r) => r.dataPointIDs.includes(e));
  }
  async navRunDidEnd(e) {
    this._clustering && (e.isNodeType("cluster") ? this._currentCluster = e.options.clustering.id : e.isNodeType("scatterpoint") ? this._currentCluster = e.options.cluster : e.isNodeType("top") && (this._currentCluster = -1), this._store.paraChart.paraView.requestUpdate(), super.navRunDidEnd(e));
  }
}
class A9e extends Ck {
  constructor(e, r) {
    super(e, r);
  }
  _init() {
    this._resolution = this._store.settings.type.heatmap.resolution ?? 20, this._generateHeatmap();
    const e = this._grid.flat();
    this._maxCount = Math.max(...e), this._axisInfo = new Jb(this._store, {
      xValues: this._store.model.allFacetValues("x").map((r) => r.value),
      yValues: this._store.model.allFacetValues("y").map((r) => r.value)
    }), super._init();
  }
  _addSettingControls() {
    super._addSettingControls(), this._store.settingControls.add({
      type: "textfield",
      key: "type.heatmap.resolution",
      label: "Resolution",
      options: {
        inputType: "number",
        min: 5,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.chart"
    });
  }
  get grid() {
    return this._grid;
  }
  get maxCount() {
    return this._maxCount;
  }
  _createPrimaryNavNodes() {
    super._createPrimaryNavNodes(), this._navMap.root.query("series").forEach((e) => {
      e.allNodes("right").slice(0, -this._resolution).forEach((r, n) => {
        r.connect("down", r.layer.get("datapoint", n + this._resolution));
      });
    });
  }
  _createNavLinksBetweenSeries() {
  }
  _createChordNavNodes() {
  }
  _datapointSummary(e) {
    const r = this._grid[e % this._resolution][Math.floor(e / this._resolution)], n = this._axisInfo.xLabelInfo, i = this._axisInfo.yLabelInfo, s = n.range / this._resolution, o = i.range / this._resolution, a = (i.max - o * Math.floor(e / this._resolution)).toFixed(2), l = (i.max - o * (Math.floor(e / this._resolution) + 1)).toFixed(2), c = (n.min + s * (e % this._resolution)).toFixed(2), p = (n.min + s * (e % this._resolution + 1)).toFixed(2);
    return `This block contains ${r} datapoints. It spans x values from ${c} to ${p}, and y values from ${l} to ${a}`;
  }
  async navRunDidEnd(e) {
    e.isNodeType("datapoint") && this._store.announce(this._datapointSummary(e.options.index));
  }
  _generateHeatmap() {
    const e = this._store.model.series;
    this._data = [];
    for (let h of e)
      for (let d = 0; d < h.length; d++)
        this._data.push([h[d].facetValueNumericized("x"), h[d].facetValueNumericized("y")]);
    const r = [], n = [];
    for (const h of this._data)
      n.push(h[0]), r.push(h[1]);
    const i = A2(
      Math.min(...this._store.model.allFacetValues("x").map((h) => h.value)),
      Math.max(...this._store.model.allFacetValues("x").map((h) => h.value)),
      !1
    ), s = A2(
      Math.min(...this._store.model.allFacetValues("y").map((h) => h.value)),
      Math.max(...this._store.model.allFacetValues("y").map((h) => h.value)),
      !1
    );
    let o = s.max, a = i.max, l = s.min, c = i.min;
    a += (a - c) / 10, c -= (a - c) / 10;
    const p = [];
    for (let h = 0; h < this.resolution; h++) {
      p.push([]);
      for (let d = 0; d < this.resolution; d++)
        p[h].push(0);
    }
    for (const h of this._data) {
      const d = Math.floor((h[0] - c) * this.resolution / (a - c)), v = Math.floor((h[1] - l) * this.resolution / (o - l));
      p[d][this.resolution - v - 1]++;
    }
    return this._grid = p, p;
  }
  get resolution() {
    return this._resolution;
  }
  goSeriesMinMax(e) {
  }
  goChartMinMax(e) {
  }
}
const k9e = {
  bar: AR,
  column: AR,
  line: wke,
  pie: kR,
  donut: kR,
  scatter: S9e,
  heatmap: A9e
  // histogram: Histogram,
  // gauge: BarChart, //GaugeChart,
  // stepline: LineChart, //StepLineChart,
  // lollipop: BarChart, //LollipopChart
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class hE extends _v {
  constructor(e) {
    if (super(e), this.it = Ne, e.type !== Av.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(e) {
    if (e === Ne || e == null) return this._t = void 0, this.it = e;
    if (e === Ra) return e;
    if (typeof e != "string") throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (e === this.it) return this._t;
    this.it = e;
    const r = [e];
    return r.raw = r, this._t = { _$litType$: this.constructor.resultType, strings: r, values: [] };
  }
}
hE.directiveName = "unsafeHTML", hE.resultType = 1;
const EV = kv(hE);
class fi extends Pr {
  constructor(e, r) {
    super(e), this.options = r, this._elRef = Et(), this._textLines = [], this._canWidthFlex = !0, this._canHeightFlex = !0, r.classList ? (r.classList.includes("label") || r.classList.push("label"), this._classInfo = Object.fromEntries(r.classList.map((n) => [n, !0]))) : this._classInfo = {
      label: !0
    }, this._angle = this.options.angle ?? 0, this._textAnchor = this.options.textAnchor ?? (r.wrapWidth ? "start" : "middle"), this._justify = this.options.justify ?? "start", this._lineSpacing = this.options.lineSpacing ?? 0, this._text = this.options.text, this.updateSize(), this.options.loc && (this._loc = this.options.loc), this.options.x && (this._x = this.options.x), this.options.y && (this._y = this.options.y), this.options.left && (this.left = this.options.left), this.options.right && (this.right = this.options.right), this.options.top && (this.top = this.options.top), this.options.bottom && (this.bottom = this.options.bottom), this.options.centerX && (this.centerX = this.options.centerX), this.options.centerY && (this.centerY = this.options.centerY), this.options.topLeft && (this.topLeft = this.options.topLeft), this.options.topRight && (this.topRight = this.options.topRight), this.options.bottomRight && (this.bottomRight = this.options.bottomRight), this.options.bottomLeft && (this.bottomLeft = this.options.bottomLeft);
  }
  _createId() {
    return this.options.id || o8e(this._text, this.paraview.store);
  }
  get el() {
    return this._elRef.value;
  }
  get text() {
    return this._text;
  }
  set text(e) {
    this._text = e, this.updateSize(), this.paraview.requestUpdate();
  }
  get angle() {
    return this._angle;
  }
  set angle(e) {
    this._angle = e, this.updateSize();
  }
  get textAnchor() {
    return this._textAnchor;
  }
  set textAnchor(e) {
    this._textAnchor = e, this.updateSize();
  }
  // get bbox() {
  //   return this._elRef.value!.getBBox();
  // }
  get topLeft() {
    return this._loc.add(this._textCornerOffsets.topLeft);
  }
  set topLeft(e) {
    this._loc = e.subtract(this._textCornerOffsets.topLeft);
  }
  get topRight() {
    return this._loc.add(this._textCornerOffsets.topRight);
  }
  set topRight(e) {
    this._loc = e.subtract(this._textCornerOffsets.topRight);
  }
  get bottomRight() {
    return this._loc.add(this._textCornerOffsets.bottomRight);
  }
  set bottomRight(e) {
    this._loc = e.subtract(this._textCornerOffsets.bottomRight);
  }
  get bottomLeft() {
    return this._loc.add(this._textCornerOffsets.bottomLeft);
  }
  set bottomLeft(e) {
    this._loc = e.subtract(this._textCornerOffsets.bottomLeft);
  }
  get textCorners() {
    return {
      topLeft: this.topLeft,
      topRight: this.topRight,
      bottomRight: this.bottomRight,
      bottomLeft: this.bottomLeft
    };
  }
  resize(e, r) {
  }
  computeSize() {
    var b;
    const e = document.createElementNS(Cp, "text");
    this.options.classList && e.classList.add(...this.options.classList), e.setAttribute("text-anchor", this._textAnchor), e.style.visibility = "hidden", this._text ? e.textContent = this._text : e.innerHTML = "&nbsp;", this._angle && e.setAttribute("transform", `rotate(${this._angle})`), this.paraview.root.append(e);
    const r = ((b = this.paraview.root) == null ? void 0 : b.getBoundingClientRect()) ?? new DOMRect(0, 0, 0, 0), n = e.getBoundingClientRect();
    let i = n.width, s = n.height;
    this._locOffset.x = -(n.x - r.x), this._locOffset.y = -(n.y - r.y);
    let o = 0, a = 0, l = 0, c = 0;
    const p = this.options.wrapWidth !== void 0 && i > this.options.wrapWidth;
    if (p || this._text.includes(`
`)) {
      e.textContent = "";
      const f = [document.createElementNS(Cp, "tspan")], E = this._text.split(p ? /(\s+)/ : /(\n+)/);
      for (f.at(-1).textContent = E.shift(), e.append(f.at(-1)); E.length; ) {
        const x = E.shift();
        if (x.includes(`
`)) {
          f.push(document.createElementNS(Cp, "tspan"));
          const _ = f.at(-1);
          e.append(_), _.textContent = x, _.setAttribute("x", "0");
          const S = f.at(-2).getBoundingClientRect();
          _.setAttribute("dy", `${S.height + this._lineSpacing}px`);
          continue;
        }
        if (!x.match(/\w/))
          continue;
        const g = f.at(-1), w = g.textContent;
        if (p) {
          g.textContent += " " + x;
          const _ = this.paraview.store.settings.ui.isFullscreenEnabled ? g.getBBox() : g.getBoundingClientRect();
          _.width >= this.options.wrapWidth && (g.textContent = w, f.push(document.createElementNS(Cp, "tspan")), e.append(f.at(-1)), f.at(-1).textContent = x, f.at(-1).setAttribute("x", "0"), f.at(-1).setAttribute("dy", `${_.height + this._lineSpacing}px`));
        } else {
          g.textContent = x;
          const _ = g.getBoundingClientRect();
          f.length > 1 && (f.at(-1).setAttribute("x", "0"), f.at(-1).setAttribute("dy", `${_.height + this._lineSpacing}px`));
        }
      }
      const A = this.paraview.store.settings.ui.isFullscreenEnabled ? e.getBBox() : e.getBoundingClientRect();
      i = A.width, s = A.height, this._locOffset.x = -(A.x - r.x), this._locOffset.y = -(A.y - r.y), this._textLines = f.map((x) => ({ text: x.textContent, offset: 0 })), this._justify !== "start" && f.forEach((x, g) => {
        const w = x.getBoundingClientRect();
        let _ = i - w.width;
        this._justify === "center" && (_ = _ / 2), this._textLines[g].offset = _;
      }), f.forEach((x) => {
        const g = x.getNumberOfChars();
        for (let w = 0; w < g; w++) {
          const _ = x.getExtentOfChar(w);
          o = Math.min(o, _.y), a = Math.max(a, _.y + _.height), l = Math.min(l, _.x), c = Math.max(c, _.x + _.width);
        }
      }), this._lineHeight = f[0].getExtentOfChar(0).height, f.forEach((x) => x.remove());
    } else {
      this._textLines = [];
      const f = e.getNumberOfChars();
      o = e.getExtentOfChar(0).y, a = e.getExtentOfChar(0).y + e.getExtentOfChar(0).height, l = e.getExtentOfChar(0).x, c = e.getExtentOfChar(f - 1).x + e.getExtentOfChar(f - 1).width, this._lineHeight = e.getExtentOfChar(0).height;
    }
    const h = new Ye(l, o).rotate(-this._angle * Math.PI / 180), d = new Ye(c, o).rotate(-this._angle * Math.PI / 180), v = new Ye(c, a).rotate(-this._angle * Math.PI / 180), m = new Ye(l, a).rotate(-this._angle * Math.PI / 180);
    return this._textCornerOffsets = {
      topLeft: h,
      topRight: d,
      bottomRight: v,
      bottomLeft: m
    }, e.remove(), [i, s];
  }
  _makeTransform() {
    let e;
    return this._angle && (e = nt`
        translate(${this._x},${this._y})
        rotate(${this._angle})
        translate(${-this._x},${-this._y})`), e;
  }
  settingDidChange(e, r, n) {
    this.updateSize(), super.settingDidChange(e, r, n);
  }
  render() {
    return Tt`
      ${this.options.hasBackground ? Tt`
          <path
            class="label-bg"
            d="
              M${this.topLeft.x},${this.topLeft.y}
              L${this.topRight.x},${this.topRight.y}
              L${this.bottomRight.x},${this.bottomRight.y}
              L${this.bottomLeft.x},${this.bottomLeft.y}
              Z"
            width=${this._width}
            height=${this._height}
          ></path>
        ` : ""}
      <text
        ${yt(this._elRef)}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : Ne}
        role=${this.options.role ?? Ne}
        x=${nt`${this._x}`}
        y=${nt`${this._y}`}
        text-anchor=${this._textAnchor !== "start" ? this._textAnchor : Ne}
        transform=${this._makeTransform() ?? Ne}
        id=${this.id}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : Ne}
        @pointerenter=${this.options.pointerEnter ?? Ne}
        @pointerleave=${this.options.pointerLeave ?? Ne}
        @click=${this.options.click ?? Ne}
      >
        ${this._textLines.length ? this._textLines.map((e, r) => Tt`
              <tspan
                x=${nt`${this._x + e.offset}`}
                dy=${r === 0 ? "0" : this._lineHeight + this._lineSpacing}
              >
                ${e.text}
              </tspan>
            `) : this._text ? this._text : EV("&nbsp;")}
      </text>
    `;
  }
}
class pf extends vo(Pr) {
  constructor(e, r, n) {
    super(e), this._width = r, this._height = n;
  }
  _createId(e) {
    return `${e}-layer`;
  }
  _addedToParent() {
    this.setSize(this._parent.logicalWidth, this._parent.logicalHeight, !1);
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
}
class jo extends Qb {
  constructor(e, r) {
    super(e, r), this._points = r.points.map((n) => n.clone());
  }
  get _options() {
    let e = super._options;
    return e.points = this._points.map((r) => r.clone()), e;
  }
  clone() {
    return new jo(this.paraview, this._options);
  }
  get points() {
    return this._points.map((e) => e.clone());
  }
  set points(e) {
    this._points = e.map((r) => r.clone());
  }
  get xs() {
    return this._points.map((e) => e.x);
  }
  get ys() {
    return this._points.map((e) => e.y);
  }
  get width() {
    return Math.max(...this.xs) - Math.min(...this.xs);
  }
  get height() {
    return Math.max(...this.ys) - Math.min(...this.ys);
  }
  get left() {
    return this._x + Math.min(...this.xs);
  }
  set left(e) {
    this._x += e - this.left;
  }
  get right() {
    return this._x + Math.max(...this.xs);
  }
  set right(e) {
    this._x += e - this.right;
  }
  get top() {
    return this._y + Math.min(...this.ys);
  }
  set top(e) {
    this._y += e - this.top;
  }
  get bottom() {
    return this._y + Math.max(...this.ys);
  }
  set bottom(e) {
    this._y += e - this.bottom;
  }
  get _pathD() {
    const e = this._points.map((n) => n.add(this._loc));
    let r = nt`M${e[0].x},${e[0].y}`;
    return e.slice(1).forEach((n) => {
      r += nt`L${n.x},${n.y}`;
    }), r;
  }
  render() {
    return Tt`
      <path
        ${this._ref ? yt(this._ref) : void 0}
        id=${this._id || Ne}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : Ne}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : Ne}
        role=${this._role || Ne}
        d=${this._pathD}
        clip-path=${this._options.isClip ? "url(#clip-path)" : Ne}
      ></path>
    `;
  }
}
function i1(t) {
  return t * Math.PI / 180;
}
function _9e(t) {
  return t * 180 / Math.PI;
}
function KR(t) {
  return t %= 360, t < 0 ? 360 + t : t;
}
function s1(t, e, r) {
  return t * (1 - r) + e * r;
}
class C2 extends Qb {
  constructor(e, r) {
    super(e, r), this.options = r, this._annularThickness = null, this._arcSweep = 1, this._r = r.r, this._centralAngle = r.centralAngle, this._orientationAngle = r.orientationAngle, this._orientationAngleCounterclockwise = !!r.orientationAngleCounterclockwise, r.annularThickness && (this._annularThickness = r.annularThickness), this._arcCenterIsOrientationAnchor = !!r.arcCenterIsOrientationAnchor, this._orientationAngleOffset = r.orientationAngleOffset ?? 90, r.isPattern && (this._isPattern = r.isPattern), this.computeLayout();
  }
  get _options() {
    let e = super._options;
    return e.r = this._r, e.centralAngle = this._centralAngle, e.orientationAngle = this._orientationAngle, e.orientationAngleCounterclockwise = this._orientationAngleCounterclockwise, this._annularThickness && (e.annularThickness = this._annularThickness), e.arcCenterIsOrientationAnchor = this._arcCenterIsOrientationAnchor, e.orientationAngleOffset = this._orientationAngleOffset, this._isPattern && (e.isPattern = this._isPattern), e;
  }
  clone() {
    return new C2(this.paraview, this._options);
  }
  get x() {
    return super.x;
  }
  set x(e) {
    super.x = e, this.computeLayout();
  }
  get y() {
    return super.y;
  }
  set y(e) {
    super.y = e, this.computeLayout();
  }
  get loc() {
    return this._loc;
  }
  set loc(e) {
    this._loc = e, this.computeLayout();
  }
  get startX() {
    return this._startX;
  }
  get startY() {
    return this._startY;
  }
  get endX() {
    return this._endX;
  }
  get endY() {
    return this._endY;
  }
  _orientationAngleToPolar(e) {
    return KR((this._orientationAngleCounterclockwise ? e : 360 - e) + this._orientationAngleOffset);
  }
  _polarAngleToOrientation(e) {
    const r = e - this._orientationAngleOffset;
    return KR(this._orientationAngleCounterclockwise ? r : 360 - r);
  }
  /**
   * Convert polar angle to Cartesian vector.
   * @returns Vector with origin at circle center, positive y UP
   */
  _angleToVector(e) {
    return new Ye(
      this._r * Math.cos(i1(e)),
      this._r * Math.sin(i1(e))
    );
  }
  /**
   * Convert Cartesian vector to polar angle.
   */
  _vectorToAngle(e) {
    e = e.normalize();
    const r = Math.abs(_9e(Math.asin(e.y)));
    return e.x >= 0 && e.y >= 0 ? r : e.x < 0 && e.y >= 0 ? 180 - r : e.x < 0 && e.y < 0 ? 180 + r : 360 - r;
  }
  get arcCenterAngle() {
    return this._orientationAngleToPolar(this._arcCenterIsOrientationAnchor ? this._orientationAngle : this._orientationAngle + this._centralAngle / 2);
  }
  get arcCenter() {
    return this._angleToVector(this.arcCenterAngle).multiply(new Ye(1, -1)).add(this._loc);
  }
  get arcLeftAngle() {
    return this._orientationAngleToPolar(this._arcCenterIsOrientationAnchor ? this._orientationAngle + this._centralAngle / 2 : this._orientationAngle);
  }
  get arcLeft() {
    return this._angleToVector(this.arcLeftAngle).multiply(new Ye(1, -1)).add(this._loc);
  }
  get arcRightAngle() {
    return this._orientationAngleToPolar(this._arcCenterIsOrientationAnchor ? this._orientationAngle + this._centralAngle / 2 : this._orientationAngle + this._centralAngle);
  }
  get arcRight() {
    return this._angleToVector(this.arcRightAngle).multiply(new Ye(1, -1)).add(this._loc);
  }
  get r() {
    return this._r;
  }
  set r(e) {
    this._r = e, this.computeLayout();
  }
  get centralAngle() {
    return this._centralAngle;
  }
  set centralAngle(e) {
    this._centralAngle = e, this.computeLayout();
  }
  get orientationAngle() {
    return this._orientationAngle;
  }
  set orientationAngle(e) {
    this._orientationAngle = e, this.computeLayout();
  }
  get annularThickness() {
    return this._annularThickness;
  }
  set annularThickness(e) {
    this._annularThickness = e, this.computeLayout();
  }
  get orientationVector() {
    return this.arcCenter.subtract(this._loc).normalize();
  }
  containsPoint(e) {
    const r = e.subtract(this._loc);
    r.y = -r.y;
    const n = this._polarAngleToOrientation(this._vectorToAngle(r)), i = this._polarAngleToOrientation(this.arcLeftAngle), s = this._polarAngleToOrientation(this.arcRightAngle), o = n >= i && n <= (s === 0 ? 360 : s);
    return this._annularThickness === null || this._annularThickness === 1 ? o && r.length() <= this._r : o && r.length() >= this._r - this._annularThickness * this._r;
  }
  computeLayout() {
    const e = i1(this.arcLeftAngle), r = i1(this.arcRightAngle);
    this._startX = this._x + this._r * Math.cos(e), this._startY = this._y - this._r * Math.sin(e), this._endX = this._x + this._r * Math.cos(r), this._endY = this._y - this._r * Math.sin(r), this._arcLarge = this._centralAngle >= 180 ? 1 : 0;
  }
  get _pathD() {
    let e = this._x, r = this.y, n = 0;
    return this._annularThickness !== null && this._annularThickness < 1 && (n = this._r * (1 - this._annularThickness), e = s1(this._x, this._startX, 1 - this._annularThickness), r = s1(this._y, this._startY, 1 - this._annularThickness)), nt`
      M${e},${r}
      L${this._startX},${this._startY}
      A${this._r},${this._r}
        0 ${this._arcLarge} ${this._arcSweep}
        ${this._endX},${this._endY}
      ${this._annularThickness !== null && this._annularThickness < 1 ? nt`
          L${s1(this._endX, this._x, this._annularThickness)},
          ${s1(this._endY, this._y, this._annularThickness)}
          A${n},${n}
            0 ${this._arcLarge} ${1 - this._arcSweep}
            ${e},${r}
        ` : ""}
      Z`;
  }
  render() {
    if (this._options.isPattern) {
      let e = this.parent.index, r = this.parent;
      return this._styleInfo.fill = `url(#Pattern${e})`, this.paraview.store.isVisited(r.seriesKey, e) && (this._styleInfo.stroke = this.paraview.store.colors.colorValue("visit"), this._styleInfo.strokeWidth = 6), Tt`
          <defs>${this.paraview.store.colors.patternValueAt(e)}</defs>
          <path
            d=${this._pathD}
            transform=${this._scale !== 1 ? `translate(${this._x},${this._y})
                    scale(${this._scale})
                    translate(${-this._x},${-this._y})` : Ne}
            fill="white"
            stroke="black"
            stroke-width=4
            clip-path=${this._options.isClip ? "url(#clip-path)" : Ne}
          ></path>
          <path
            ${this._ref ? yt(this._ref) : void 0}
            id=${this._id || Ne}
            style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : Ne}
            class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : Ne}
            role=${this._role || Ne}
            d=${this._pathD}
            transform=${this._scale !== 1 ? `translate(${this._x},${this._y})
                    scale(${this._scale})
                    translate(${-this._x},${-this._y})` : Ne}
            clip-path=${this._options.isClip ? "url(#clip-path)" : Ne}
            @pointerenter=${this.options.pointerEnter ?? Ne}
            @pointerleave=${this.options.pointerLeave ?? Ne}
          ></path>
        `;
    } else
      return Tt`
      <path
        ${this._ref ? yt(this._ref) : void 0}
        id=${this._id || Ne}
        style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : Ne}
        class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : Ne}
        role=${this._role || Ne}
        d=${this._pathD}
        transform=${this._scale !== 1 ? `translate(${this._x},${this._y})
             scale(${this._scale})
             translate(${-this._x},${-this._y})` : Ne}
        clip-path=${this._options.isClip ? "url(#clip-path)" : Ne}
        @pointerenter=${this.options.pointerEnter ?? Ne}
        @pointerleave=${this.options.pointerLeave ?? Ne}
      ></path>
    `;
  }
}
class SV {
  constructor(e, r, n, i, s) {
    this._pts = [];
    const o = new Ye(e, r), a = new Ye(n, i);
    for (let l = 0; l < s; l++) {
      const c = l / s, p = c * c, h = p * c;
      this._pts.push(
        o.multiplyScalar(3 * (h - 2 * p + c)).add(
          a.multiplyScalar(3 * (p - h)).add(
            new Ye(h, h)
          )
        )
      );
    }
    this._pts.push(new Ye(1, 1));
  }
  // copy() {
  //   cdef Bezier c = Bezier.__new__(Bezier)
  //   c.pts = [v.copy() for v in self.pts]
  //   return c
  // }
  eval(e) {
    for (let r = 0; r < this._pts.length - 1; r++)
      if (e <= this._pts[r + 1].x) {
        const n = this._pts[r], i = this._pts[r + 1];
        return n.lerp(i, (e - n.x) / (i.x - n.x)).y;
      }
  }
}
class C9e extends Pr {
  constructor(e, r) {
    super(e), r && (this._id = r);
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(e) {
    this._children.forEach((r) => {
      r.x += e - this._x;
    }), super.x = e;
  }
  set y(e) {
    this._children.forEach((r) => {
      r.y += e - this._y;
    }), super.y = e;
  }
  // setSize(width: number, height: number, isBubble = true) {
  //   super.setSize(width, height, isBubble);
  //   this.layoutViews();
  // }
  // constrainSize(maxWidth: number, maxHeight: number, isBubble = false) {
  //   this.log.info('CONSTRAIN', this.id || this.constructor.name, maxWidth, maxHeight, isBubble);
  //   this.setSize(Math.min(this._width, maxWidth), Math.min(this._height, maxHeight), isBubble);
  //   this._children.forEach(kid => {
  //     kid.constrainSize(this._width, this._height, false);
  //   });
  //   this._adjustToSizeConstraint();
  // }
  // protected _adjustToSizeConstraint() {
  //   this.layoutViews();
  // }
  _didAddChildToList(e) {
    e.isBubbleSizeChange = !0;
  }
  _childDidResize(e) {
    this.updateSize();
  }
  _didAddChild(e) {
  }
  _didRemoveChild(e) {
    this.updateSize();
  }
}
function YR(t) {
  return Math.round(t * 100) / 100;
}
class kh extends C9e {
  constructor(e, r, n) {
    super(e, n), this._rows = [], this._territories = /* @__PURE__ */ new Map(), this._hRules = [], this._vRules = [], this.log = qt("GridLayout "), this._canWidthFlex = !!r.canWidthFlex, this._canHeightFlex = !!r.canHeightFlex, this._width = r.width ?? this._width, this._height = r.height ?? this._height, this._isAutoWidth = !!r.isAutoWidth, this._isAutoHeight = !!r.isAutoHeight, this._numCols = r.numCols, this._rowGaps = r.rowGaps !== void 0 ? this._expandRowGaps(r.rowGaps) : [0], this._colGaps = r.colGaps !== void 0 ? this._expandColGaps(r.colGaps) : new Array(this._numCols - 1).fill(0), this._rowAligns = r.rowAligns !== void 0 ? this._expandRowAligns(r.rowAligns) : ["center"], this._colAligns = r.colAligns !== void 0 ? this._expandColAligns(r.colAligns) : new Array(this._numCols).fill("center"), this._rows.push(new Array(this._numCols).fill(null)), this._resetRules();
  }
  get padding() {
    return super.padding;
  }
  set padding(e) {
    super.padding = e, this.layoutViews();
  }
  get numRows() {
    return this._rows.length;
  }
  get numCols() {
    return this._numCols;
  }
  get rowGaps() {
    return Array.from(this._rowGaps);
  }
  get colGaps() {
    return Array.from(this._colGaps);
  }
  get rowAligns() {
    return Array.from(this._rowAligns);
  }
  get colAligns() {
    return Array.from(this._colAligns);
  }
  set numCols(e) {
    this._numCols = e, this._arrangeChildren(), this.layoutViews();
  }
  set rowGaps(e) {
    this._rowGaps = this._expandRowGaps(e), this.setSize(...this.computeSize()), this.layoutViews();
  }
  get hRules() {
    return this._hRules;
  }
  get vRules() {
    return this._vRules;
  }
  setRowGap(e, r) {
    if (e >= this._rowGaps.length)
      throw new Error(`row gap index '${e}' out of bounds`);
    const n = this._rowGaps[e];
    this._rowGaps[e] = r;
    const i = e + 1, s = this._hRules.slice(i + 1).map((o) => o - (r - n));
    this._hRules.splice(i + 1, s.length, ...s), this._hRules[i] -= r, this._territories.keys().forEach((o) => {
      this._adjustViewToRules(o);
    }), this.layoutViews();
  }
  _expandRowGaps(e) {
    return typeof e == "object" ? Array.from(e) : [e];
  }
  set colGaps(e) {
    this._colGaps = this._expandColGaps(e), this.setSize(...this.computeSize()), this.layoutViews();
  }
  setColGap(e, r) {
    if (e < 0 || e >= this._colGaps.length)
      throw new Error(`col gap index '${e}' out of bounds`);
    const n = this._colGaps[e];
    this._colGaps[e] = r;
    const i = e + 1, s = this._vRules.slice(i + 1).map((o) => o - (r - n));
    this._vRules.splice(i + 1, s.length, ...s), this._vRules[i] -= r, this._territories.keys().forEach((o) => {
      this._adjustViewToRules(o);
    }), this.layoutViews();
  }
  _expandColGaps(e) {
    return typeof e == "object" ? Array.from(e) : new Array(this._numCols - 1).fill(e);
  }
  set rowAligns(e) {
    this._rowAligns = this._expandRowAligns(e), this.layoutViews();
  }
  _expandRowAligns(e) {
    return typeof e == "object" ? Array.from(e) : [e];
  }
  set colAligns(e) {
    this._colAligns = this._expandColAligns(e), this.layoutViews();
  }
  /** Contents of each cell in the given column. */
  col(e) {
    return this._rows.map((r) => r[e]);
  }
  _expandColAligns(e) {
    return typeof e == "object" ? Array.from(e) : new Array(this._numCols).fill(e);
  }
  // getAvailableSpace(territory: GridTerritory): {width: number, height: number} {
  //   // all cells must be empty
  //   for (let i = territory.x; i < territory.x + territory.width; i++) {
  //     for (let j = territory.y; j < territory.y + territory.height; j++) {
  //       if (this._rows[j][i]) {
  //         throw new Error(`grid row=${j} col=${i} already occupied`);
  //       }
  //     }
  //   }
  // }
  addColumnLeft() {
    this._numCols++, this._colGaps.unshift(0), this._colAligns.unshift("center"), this._rows.forEach((e) => e.unshift(null)), this._territories.values().forEach((e) => {
      e.x++;
    }), this._vRules.unshift(0);
  }
  addColumnRight() {
    this._numCols++, this._colGaps.push(0), this._colAligns.push("center"), this._rows.forEach((e) => e.push(null)), this._vRules.push(this._vRules.at(-1));
  }
  splitColumnRight(e, r = 0, n = "center") {
    const i = this.col(e).filter((s) => {
      if (s) {
        const o = this._territories.get(s);
        return o.x + o.width === e + 1;
      }
      return !1;
    });
    this._territories.values().forEach((s) => {
      s.x > e && s.x++;
    }), this._numCols++, this._colGaps.splice(e, 0, r), this._colAligns.splice(e + 1, 0, n), this._rows.forEach((s) => {
      s.splice(e + 1, 0, null);
    }), this._vRules.splice(e + 1, 0, i.length ? Math.max(...i.map((s) => s.paddedRight)) : this._vRules[e + 1]);
  }
  addRowTop() {
    this._rowGaps.unshift(0), this._rowAligns.unshift("center"), this._rows.unshift(new Array(this._numCols).fill(null)), this._territories.values().forEach((e) => {
      e.y++;
    }), this._hRules.unshift(0);
  }
  addRowBottom() {
    this._rowGaps.push(0), this._rowAligns.push("center"), this._rows.push(new Array(this._numCols).fill(null)), this._hRules.push(this._hRules.at(-1));
  }
  splitRowTop(e, r = "center") {
    const n = this._rows[e].filter((i) => i ? this._territories.get(i).y === e : !1);
    this._territories.values().forEach((i) => {
      i.y >= e && i.y++;
    }), this._rowGaps.splice(e - 1, 0, 0), this._rowAligns.splice(e, 0, r), this._rows.splice(e, 0, this._rows[0].map((i) => null)), this._hRules.splice(e + 1, 0, n.length ? Math.min(...n.map((i) => i.paddedTop)) : this._hRules[e]);
  }
  insertRow(e, r = 0, n = "center") {
    if (this._rowGaps.splice(e, 0, r), this._rowAligns.splice(e, 0, n), this._rows.splice(e, 0, new Array(this._numCols).fill(null)), this._territories.values().forEach((i) => {
      i.y >= e && i.y++;
    }), this._hRules.splice(e, 0, this._hRules[e] ?? this._hRules.at(-1)), r)
      for (let i = e + 2; i < this._hRules.length; i++)
        this._hRules[i] -= r;
  }
  _resetRules() {
    this._hRules = [0, this._isAutoHeight ? 0 : this._height - this._rowGaps.reduce((e, r) => e + r, 0)], this._vRules = new Array(this._numCols).fill(0), this._vRules.push(this._isAutoWidth ? 0 : this._width - this._colGaps.reduce((e, r) => e + r, 0));
  }
  _defaultMargin(e, r) {
    return {
      left: this._colGaps[this._leftGapIndex(e)] ?? 0,
      right: this._colGaps[this._rightGapIndex(e)] ?? 0,
      top: this._rowGaps[this._topGapIndex(r)] ?? 0,
      bottom: this._rowGaps[this._bottomGapIndex(r)] ?? 0
    };
  }
  _createTerritory(e) {
    const r = e.x ?? 0, n = e.y ?? 0;
    return {
      x: r,
      y: n,
      width: e.width ?? 1,
      height: e.height ?? 1,
      rowAlign: e.rowAlign,
      colAlign: e.colAlign
      // margin: input.margin !== undefined
      //   ? this._expandPadding(input.margin, this._defaultMargin(x, y))
      //   : this._defaultMargin(x, y)
    };
  }
  _claimTerritory(e, r) {
    if (this._territories.has(e))
      throw new Error("view already present in grid");
    r && this._territories.set(e, this._createTerritory(r));
  }
  _territoryView(e) {
    return this._territories.keys().find((r) => this._territories.get(r) === e);
  }
  _territoryPhysWidth(e, r = !0) {
    return this._vRuleDist(e.x, e.x + e.width, r);
  }
  _territoryPhysHeight(e, r = !0) {
    return this._hRuleDist(e.y, e.y + e.height, r);
  }
  /** Physical distance between two hRules, possibly inclusive of gaps */
  _hRuleDist(e, r, n = !0) {
    return this._hRules[r] - this._hRules[e] + (n ? this._rowGaps.slice(e, r).reduce((i, s) => i + s, 0) : 0);
  }
  /** Physical distance between two vRules, possibly inclusive of gaps */
  _vRuleDist(e, r, n = !0) {
    return this._vRules[r] - this._vRules[e] + (n ? this._colGaps.slice(e, r).reduce((i, s) => i + s, 0) : 0);
  }
  /**
   * View's unused horizontal space in its territory
   */
  _viewAvailWidth(e) {
    return this._territoryPhysWidth(this._territories.get(e), !1) - e.paddedWidth;
  }
  /**
   * View's unused vertical space in its territory
   */
  _viewAvailHeight(e) {
    return this._territoryPhysHeight(this._territories.get(e), !1) - e.paddedHeight;
  }
  _territoryBbox(e) {
    let r = this.left;
    const n = this._vRules.slice(1).map((d, v) => d - this._vRules[v]), i = this._colGaps;
    for (let d = 0; d < e.x; d++)
      r += n[d] + i[d];
    const s = n.slice(e.x, e.x + e.width).reduce((d, v) => d + v, 0) + i.slice(e.x, e.x + e.width - 1).reduce((d, v) => d + v, 0), o = r + s;
    let a = this.top;
    const l = this._hRules.slice(1).map((d, v) => d - this._hRules[v]), c = this._rowGaps;
    for (let d = 0; d < e.y; d++)
      a += l[d] + c[d];
    const p = l.slice(e.y, e.y + e.height).reduce((d, v) => d + v, 0) + c.slice(e.y, e.y + e.height - 1).reduce((d, v) => d + v, 0), h = a + p;
    return new DOMRect(r, a, o - r, h - a);
  }
  append(e, r) {
    this._claimTerritory(e, r), super.append(e);
  }
  prepend(e, r) {
    this._claimTerritory(e, r), super.prepend(e);
  }
  _didAddChild(e) {
    this._arrangeChild(e), this._adjustRules(e), (this._isAutoWidth || this._isAutoHeight) && this.updateSize(), this.layoutViews(), super._didAddChild(e);
  }
  _didRemoveChild(e) {
    this._rows = this._rows.map((r) => r.map((n) => n === e ? null : n)), this._territories.delete(e), this._contractRules(), super._didRemoveChild(e);
  }
  _firstEmptyCell() {
    for (let e = 0; e < this._rows.length; e++) {
      const r = this._rows[e];
      for (let n = 0; n < r.length; n++)
        if (!r[n])
          return [e, n];
    }
    return [this._rows.length, 0];
  }
  _arrangeChild(e) {
    const r = this._territories.get(e);
    let n = [], i = [];
    if (r)
      r.x < 0 && (r.x = this._numCols + r.x), r.y < 0 && (r.y = this._rows.length + r.y), n = ua(r.height, (s) => r.y + s), i = ua(r.width, (s) => r.x + s);
    else {
      const [s, o] = this._firstEmptyCell();
      n = [s], i = [o], this._territories.set(e, {
        x: o,
        y: s,
        width: 1,
        height: 1
        // margin: this._defaultMargin(col, row)
      });
    }
    n.filter((s) => s > this._rows.length - 1).forEach((s) => {
      this._rows.push(ua(this._numCols, (o) => null)), this._rowGaps.push(0), this._hRules.push(this._hRules.at(-1));
    }), n.forEach(
      (s) => i.forEach((o) => {
        if (this._rows[s][o])
          throw new Error("grid children cannot overlap");
        this._rows[s][o] = e;
      })
    );
  }
  colWidth(e) {
    if (e > this._rows[0].length - 1)
      throw new Error(`col index '${e}' out of bounds`);
    return this._vRuleDist(e, e + 1, !1);
  }
  rowHeight(e) {
    if (e > this._rows.length - 1)
      throw new Error(`row index '${e}' out of bounds`);
    return this._hRuleDist(e, e + 1, !1);
  }
  /** Whether a row can expand vertically. */
  _rowCanGrow(e) {
    return this.rowHeight(e) ? this._rows[e].every((n) => !n || n.canWidthFlex) : !1;
  }
  /**
   * How much a row can shrink vertically;
   * max value is the current row height
   */
  _rowShrinkability(e) {
    const r = this.rowHeight(e);
    if (!r)
      return 0;
    const n = this._rows[e].filter(
      (s) => {
        if (s) {
          const o = this._territories.get(s);
          return o.y === e || o.y + o.height === e + 1;
        }
      }
    );
    if (!n.length)
      return r;
    const i = n.map((s) => s.canHeightFlex ? r : Math.min(r, this._viewAvailHeight(s)));
    return YR(Math.min(...i));
  }
  /** Whether a column can expand horizontally. */
  _columnCanGrow(e) {
    return this.colWidth(e) ? this.col(e).every((n) => !n || n.canWidthFlex) : !1;
  }
  /**
   * How much a column can shrink horizontally;
   * max value is the current column width
   */
  _columnShrinkability(e) {
    const r = this.colWidth(e);
    if (!r)
      return 0;
    const n = this._rows.map((i) => i[e]).filter(
      (i) => {
        if (i) {
          const s = this._territories.get(i);
          return s.x === e || s.x + s.width === e + 1;
        }
      }
    );
    return n.length === 0 ? r : YR(Math.min(...n.map((i) => i.canWidthFlex ? r : Math.min(r, this._viewAvailWidth(i)))));
  }
  // protected _hRuleUpFlexibility(hRule: number): number {
  //   // views that end on hRule
  //   const prevRowViews = this._rows[hRule - 1]
  //     .filter(view => {
  //       if (view) {
  //         const t = this._territories.get(view)!;
  //         return t.y + t.height === hRule;
  //       }
  //     }
  //   ) as View[];
  //   if (prevRowViews.length) {
  //     const canShrink = prevRowViews.filter(view => view.isHeightCanShrink);
  //     const cantShrink = prevRowViews.filter(view => !view.isHeightCanShrink);
  //     if (canShrink.length === 0) {
  //       if (hRule > 1) {
  //         return this._hRuleUpFlexibility(hRule - 1);
  //       } else {
  //         return 0;
  //       }
  //     } else if (cantShrink.length === 0) {
  //       const rowFlex = Math.max(...canShrink.map(view => view.paddedHeight));
  //       if (hRule > 1) {
  //         return rowFlex + this._hRuleUpFlexibility(hRule - 1);
  //       } else {
  //         return rowFlex;
  //       }
  //     } else {
  //       const rowCanFlex = Math.max(...canShrink.map(view => view.paddedHeight));
  //       const rowCantFlex = Math.max(...cantShrink.map(view => view.paddedHeight));
  //       const rowFlex = Math.max(0, rowCanFlex - rowCantFlex);
  //       if (hRule > 1) {
  //         return rowFlex + this._hRuleUpFlexibility(hRule - 1);
  //       } else {
  //         return rowFlex;
  //       }
  //     }
  //   } else if (hRule > 1) {
  //     return this._hRuleUpFlexibility(hRule - 1);
  //   } else {
  //     return 0;
  //   }
  // }
  // canChildResize(kid: View, newWidth: number, newHeight: number): boolean {
  //   const territory = this._territories.get(kid)!;
  //   const hRuleStart = territory.y;
  //   const hRuleEnd = hRuleStart + territory.height;
  //   const vRuleStart = territory.x;
  //   const vRuleEnd = vRuleStart + territory.width;
  //   let rowShrinkage = new Map<number, number>();
  //   let columnShrinkage = new Map<number, number>();
  //   let kidWidthShrink = 0;
  //   let kidHeightShrink = 0;
  //   if (!this._canWidthFlex) {
  //     const territoryPhysWidth = this._territoryPhysWidth(territory);
  //     this.log.info('TPW', territoryPhysWidth, this._hRules, this._vRules);
  //     const widthDiff = kid.paddedWidth - territoryPhysWidth;
  //     this.log.info('WIDTH DIFF', widthDiff);
  //     if (widthDiff > 0) {
  //       let otherCols = this._rows[0].map((_, i) => i).filter(i =>
  //         i < territory.x || i >= territory.x + territory.width);
  //       let availShrink = otherCols.map(i => this._columnShrinkability(i));
  //       otherCols = otherCols.filter((_rowIdx, i) => availShrink[i]);
  //       availShrink = availShrink.filter(avail => avail).map(avail => avail);
  //       this.log.info('AVAIL COL SHRINK', otherCols, availShrink);
  //       // NB: otherCols may be empty
  //       const availShrinkSum = availShrink.reduce((a, b) => a + b, 0);
  //       if (availShrinkSum < widthDiff) {
  //         // we can shrink as much as possible, but kid must be able to shrink
  //         // XXX any view resizing should be queued and performed after all new sizes
  //         // are determined, in case a view needs to resize in both width and height
  //         if (availShrinkSum) {
  //           columnShrinkage = this._apportionShrinkage(
  //             availShrinkSum, availShrinkSum,
  //             availShrink, otherCols);
  //         }
  //         kidWidthShrink = widthDiff - availShrinkSum;
  //         this.log.info('KIDWIDTHSHRINK', kidWidthShrink, columnShrinkage);
  //       } else {
  //         // apportion space among shrinkable columns
  //         columnShrinkage = this._apportionShrinkage(
  //           widthDiff, availShrinkSum,
  //           availShrink, otherCols);
  //         this.log.info('COL SHRINK', columnShrinkage);
  //       }
  //     }
  //   } else {
  //     // All territories spanning the previous column that end on vRuleEnd
  //     const prevColTerritories = this._rows
  //       .map(row => row[vRuleEnd - 1])
  //       .filter(view => view)
  //       .map(view => this._territories.get(view!)!)
  //       .filter(t => t.x + t.width === vRuleEnd);
  //     const territoryDiffs = prevColTerritories.map(t => {
  //       const vRuleStart = t.x;
  //       const vRuleEnd = vRuleStart + t.width;
  //       const vDiff = this._vRules[vRuleEnd] - this._vRules[vRuleStart];
  //       const tView = this._rows[t.y][t.x];
  //       return tView!.paddedWidth - vDiff;
  //     });
  //     const vShift = Math.max(...territoryDiffs);
  //     if (vShift) {
  //       this._vRules[vRuleEnd] += vShift;
  //       this._vRules.slice(vRuleEnd + 1).forEach((vRule, i) => {
  //         this._vRules[vRuleEnd + 1 + i] += vShift;
  //       });
  //     }
  //   }
  //   if (!this._canHeightFlex) {
  //     const territoryPhysHeight = this._territoryPhysHeight(territory);
  //     this.log.info('TPH', territoryPhysHeight, kid.paddedHeight);
  //     const heightDiff = kid.paddedHeight - territoryPhysHeight;
  //     this.log.info('HEIGHT DIFF', heightDiff);
  //     if (heightDiff > 0) {
  //       let otherRows = this._rows.map((_, i) => i).filter(i =>
  //         i < territory.y || i >= territory.y + territory.height);
  //       this.log.info('OTHER ROWS', otherRows);
  //       let availShrink = otherRows.map(i => this._rowShrinkability(i));
  //       this.log.info('AVAIL SHRINK', availShrink);
  //       otherRows = otherRows.filter((_rowIdx, i) => availShrink[i]);
  //       availShrink = availShrink.filter(avail => avail).map(avail => avail);
  //       const availShrinkSum = availShrink.reduce((a, b) => a + b, 0);
  //       if (availShrinkSum < heightDiff) {
  //         if (availShrinkSum) {
  //           rowShrinkage = this._apportionShrinkage(
  //             availShrinkSum, availShrinkSum,
  //             availShrink, otherRows);
  //         }
  //         kidHeightShrink = heightDiff - availShrinkSum;
  //       } else {
  //         rowShrinkage = this._apportionShrinkage(
  //           heightDiff, availShrinkSum,
  //           availShrink, otherRows);
  //         this.log.info('ROW SHRINK', rowShrinkage);
  //       }
  //     }
  //   } else {
  //     // views in bottom-most row of territory that end on hRuleEnd
  //     const prevRowTerritories = this._rows[hRuleEnd - 1]
  //       .filter(view => view)
  //       .map(view => this._territories.get(view!)!)
  //       .filter(t => t.y + t.height === hRuleEnd);
  //     const rowTerritoryDiffs = prevRowTerritories.map(t => {
  //       const hRuleStart = t.y;
  //       const hRuleEnd = hRuleStart + t.height;
  //       const hDiff = this._hRules[hRuleEnd] - this._hRules[hRuleStart];
  //       const tView = this._rows[t.y][t.x];
  //       // XXX not all views here will necessarily start at hRuleStart!
  //       return tView!.paddedHeight - hDiff;
  //     });
  //     const hShift = Math.max(...rowTerritoryDiffs);
  //     if (hShift) {
  //       this._hRules[hRuleEnd] += hShift;
  //       this._hRules.slice(hRuleEnd + 1).forEach((hRule, i) => {
  //         this._hRules[hRuleEnd + 1 + i] += hShift;
  //       });
  //     }
  //   }
  //   const toResize = new Map<View, {width: number, height: number}>();
  //   if (rowShrinkage.size) {
  //     this.log.info('ROWS WILL SHRINK');
  //     rowShrinkage.entries().forEach(([idx, shrink]) => {
  //       this._rows[idx].forEach(view => {
  //         if (view) {
  //           toResize.set(view, {width: view.width, height: view.height - shrink});
  //         }
  //       });
  //     });
  //     this.log.info('TO RESIZE', toResize);
  //     const rowsAbove = new Map(rowShrinkage.entries().filter(([idx, shrink]) =>
  //       idx < territory.y));
  //     const rowsBelow = new Map(rowShrinkage.entries().filter(([idx, shrink]) =>
  //       idx >= territory.y + territory.height));
  //     this.log.info('ROWS ABOVE', rowsAbove, rowsBelow);
  //     this.log.info('HRULES BEFORE', [...this._hRules]);
  //     // Move hrules above territory up
  //     rowsAbove.forEach((shrink, idx) => {
  //       this._hRules.splice(idx + 1, rowsAbove.size,
  //         ...this._hRules.slice(idx + 1, idx + 1 + rowsAbove.size).map(hr => hr - shrink));
  //     });
  //     // Move hrules below territory down
  //     rowsBelow.forEach((shrink, idx) => {
  //       this._hRules.splice(idx, rowsBelow.size,
  //         ...this._hRules.slice(idx).map(hr => hr + shrink));
  //     });
  //     this.log.info('HRULES', this._hRules);
  //   }
  //   if (columnShrinkage.size) {
  //     this.log.info('COLS WILL SHRINK');
  //     columnShrinkage.entries().forEach(([idx, shrink]) => {
  //       this._rows.map(row => row[idx]).forEach(view => {
  //         if (view) {
  //           toResize.set(view, {width: view.width - shrink, height: view.height});
  //         }
  //       });
  //     });
  //     this.log.info('TO RESIZE', toResize);
  //     const colsLeft = columnShrinkage.entries().filter(([idx, shrink]) =>
  //       idx < territory.x).toArray();
  //     const colsRight = columnShrinkage.entries().filter(([idx, shrink]) =>
  //       idx >= territory.x + territory.width).toArray().toReversed();
  //     this.log.info('VRULES BEFORE', [...this._vRules]);
  //     // Move vrules at territory left
  //     colsLeft.forEach(([idx, shrink]) => {
  //       this._vRules.splice(idx + 1, territory.x - (idx + 1),
  //         ...this._vRules.slice(idx + 1, territory.x).map(vr => vr - shrink));
  //     });
  //     // Move vrules at territory right
  //     colsRight.forEach(([idx, shrink]) => {
  //       const start = territory.x + territory.width;
  //       this._vRules.splice(start, idx + 1 - start,
  //         ...this._vRules.slice(start, idx + 1).map(vr => vr + shrink)
  //       );
  //     });
  //     this.log.info('VRULES', this._vRules);
  //   }
  //   toResize.forEach((newSize, view) => {
  //     // Set the size without notifying the parent of the size change
  //     this.log.info('RESIZING VIEWS', [...this._hRules]);
  //     // view.constrainSize(newSize.width, newSize.height);
  //     view.setSize(newSize.width, newSize.height, false);
  //     .log('RESIZING VIEWS COMPLETE', [...this._hRules]);
  //   });
  //   if (kidWidthShrink || kidHeightShrink) {
  //     this.log.info('KID CONSTRAIN', kid.width - kidWidthShrink, kid.height - kidHeightShrink);
  //     // kid.constrainSize(kid.width - kidWidthShrink, kid.height - kidHeightShrink);
  //     kid.setSize(kid.width - kidWidthShrink, kid.height - kidHeightShrink, false);
  //   }
  //   // XXX Don't forget to resize any other views in the kid's territory's row(s)/col(s),
  //   // if necessary
  // }
  _adjustRules(e) {
    const r = this._territories.get(e), i = r.y + r.height, o = r.x + r.width;
    let a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = 0, p = 0;
    if (this._isAutoWidth) {
      const d = e.paddedWidth - this._territoryPhysWidth(r);
      d > 0 && (this._vRules[o] += d, this._vRules.slice(o + 1).forEach((v, m) => {
        this._vRules[o + 1 + m] += d;
      }));
    } else {
      const d = this._territoryPhysWidth(r, !1), v = e.paddedWidth - d;
      if (v > 0) {
        let m = this._rows[0].map((E, A) => A).filter((E) => E < r.x || E >= r.x + r.width), b = m.map((E) => this._columnShrinkability(E));
        m = m.filter((E, A) => b[A]), b = b.filter((E) => E).map((E) => E);
        const f = b.reduce((E, A) => E + A, 0);
        f < v ? (f && (l = this._apportionShrinkage(
          f,
          f,
          b,
          m
        )), c = v - f) : l = this._apportionShrinkage(
          v,
          f,
          b,
          m
        );
      }
    }
    if (this._isAutoHeight) {
      const v = this._rows[i - 1].filter((b) => b).map((b) => this._territories.get(b)).filter((b) => b.y + b.height === i).map((b) => {
        const f = b.y, E = f + b.height, A = this._hRules[E] - this._hRules[f];
        return this._rows[b.y][b.x].paddedHeight - A;
      }), m = Math.max(...v);
      m && (this._hRules[i] += m, this._hRules.slice(i + 1).forEach((b, f) => {
        this._hRules[i + 1 + f] += m;
      }));
    } else {
      const d = this._territoryPhysHeight(r, !1), v = e.paddedHeight - d;
      if (v > 0) {
        let m = this._rows.map((E, A) => A).filter((E) => E < r.y || E >= r.y + r.height), b = m.map((E) => this._rowShrinkability(E));
        m = m.filter((E, A) => b[A]), b = b.filter((E) => E);
        const f = b.reduce((E, A) => E + A, 0);
        f < v ? (f && (a = this._apportionShrinkage(
          f,
          f,
          b,
          m
        )), p = v - f) : a = this._apportionShrinkage(
          v,
          f,
          b,
          m
        );
      }
    }
    const h = /* @__PURE__ */ new Map();
    if (a.size) {
      a.entries().forEach(([m, b]) => {
        this._rows[m].forEach((f) => {
          f && h.set(f, { width: f.width, height: f.height - b });
        });
      });
      const d = new Map(a.entries().filter(([m, b]) => m < r.y)), v = new Map(a.entries().filter(([m, b]) => m >= r.y + r.height));
      d.forEach((m, b) => {
        this._hRules.splice(
          b + 1,
          d.size,
          ...this._hRules.slice(b + 1, b + 1 + d.size).map((f) => f - m)
        );
      }), v.entries().forEach(([m, b]) => {
        this._hRules[m] += b;
      });
    }
    if (l.size) {
      l.entries().forEach(([m, b]) => {
        this._rows.map((f) => f[m]).forEach((f) => {
          f && h.set(f, { width: f.width - b, height: f.height });
        });
      });
      const d = l.entries().filter(([m, b]) => m < r.x).toArray(), v = l.entries().filter(([m, b]) => m >= r.x + r.width).toArray().toReversed();
      d.forEach(([m, b]) => {
        const f = this._vRules.slice(m + 1, r.x + 1).map((E) => E - b);
        this._vRules.splice(m + 1, f.length, ...f);
      }), v.forEach(([m, b]) => {
        const f = r.x + r.width;
        this._vRules.splice(
          f,
          m + 1 - f,
          ...this._vRules.slice(f, m + 1).map((E) => E + b)
        );
      });
    }
    h.forEach((d, v) => {
      v.resize(d.width, d.height);
    }), (c || p) && e.resize(e.width - c, e.height - p);
  }
  _adjustViewToRules(e) {
    const r = this._territories.get(e);
    let n = 0, i = 0;
    const s = this._territoryPhysWidth(r, !1), o = e.paddedWidth - s;
    o > 0 && (n = o);
    const a = this._territoryPhysHeight(r, !1), l = e.paddedHeight - a;
    l > 0 && (i = l), (n || i) && e.resize(e.width - n, e.height - i);
  }
  /**
   * Apportion shrinkage of rows or columns
   * @param toApportion - Total amount of shrinkage to apportion
   * @param availShrinkSum - Total shrinkage available in rows/columns
   * @param availShrink - Amount of shrinkage available in each row/column
   * @param indices - Row/column indices
   * @returns Map of row/column index to amount of shrinkage
   */
  _apportionShrinkage(e, r, n, i) {
    const s = /* @__PURE__ */ new Map(), o = e / r;
    return i.forEach((a, l) => {
      s.set(a, n[l] * o);
    }), s;
  }
  // protected _apportionColumnShrinkage(
  //   toApportion: number, availShrinkSum: number,
  //   availShrink: number[], cols: number[]
  // ): Map<number, number> {
  //   const shrinkage = new Map<number, number>();
  //   const apportionPct = toApportion/availShrinkSum;
  //   cols.forEach((colIdx, i) => {
  //     shrinkage.set(colIdx, availShrink[i]*apportionPct);
  //   });
  //   return shrinkage;
  // }
  _contractRules() {
    this._rows.forEach((r, n) => {
      if (r.every((i) => i === null)) {
        const i = this._hRules[n + 1] - this._hRules[n];
        this._hRules.splice(
          n + 1,
          this._hRules.length - (n + 1),
          ...this._hRules.slice(n + 1).map((s) => s - i)
        );
      }
    });
    const e = [];
    this._rows.forEach((r, n) => {
      r.forEach((i, s) => {
        e[s] || (e[s] = []), e[s][n] = i;
      });
    }), e.forEach((r, n) => {
      if (r.every((i) => i === null)) {
        const i = this._vRules[n + 1] - this._vRules[n];
        this._vRules.splice(
          n + 1,
          this._vRules.length - (n + 1),
          ...this._vRules.slice(n + 1).map((s) => s - i)
        );
      }
    });
  }
  // protected _computeColGap(index: number) {
  //   if (index < 0 || index > this._colGaps.length - 1) {
  //     return 0;
  //   }
  //   const leftViewMargins = this._rows
  //     .flatMap(row => row.filter((v, i) => v && (i === index)) as View[])
  //     .map(v => this._territories.get(v)!.margin.right);
  //   const rightViewMargins = this._rows
  //     .flatMap(row => row.filter((v, i) => v && (i === index + 1)) as View[])
  //     .map(v => this._territories.get(v)!.margin.left);
  //   const margins = leftViewMargins.concat(rightViewMargins);
  //   return margins.length ? Math.max(...margins) : 0;
  // }
  // protected _computeRowGap(index: number) {
  //   if (index < 0 || index > this._rowGaps.length - 1) {
  //     return 0;
  //   }
  //   const topViewMargins = ((this._rows[index]
  //     ?.filter(v => v) ?? []) as View[])
  //     .map(v => {
  //       return this._territories.get(v)!.margin.bottom;
  //     });
  //   const bottomViewMargins = ((this._rows[index + 1]
  //     ?.filter(v => v) ?? []) as View[])
  //     .map(v => this._territories.get(v)!.margin.top);
  //   const margins = topViewMargins.concat(bottomViewMargins);
  //   return margins.length ? Math.max(...margins) : 0;
  // }
  _leftGapIndex(e) {
    return e - 1;
  }
  _rightGapIndex(e) {
    return e;
  }
  _topGapIndex(e) {
    return e - 1;
  }
  _bottomGapIndex(e) {
    return e;
  }
  // protected _adjustGaps(kid: View) {
  //   const territory = this._territories.get(kid)!;
  //   const leftIndex = this._leftGapIndex(territory.x);
  //   if (leftIndex >= 0) {
  //     this._colGaps[leftIndex] = this._computeColGap(leftIndex);
  //   }
  //   const rightIndex = this._rightGapIndex(territory.x);
  //   if (rightIndex < this._colGaps.length) {
  //     this._colGaps[rightIndex] = this._computeColGap(rightIndex);
  //   }
  //   const topIndex = this._topGapIndex(territory.y);
  //   if (topIndex >= 0) {
  //     this._rowGaps[topIndex] = this._computeRowGap(topIndex);
  //   }
  //   const bottomIndex = this._bottomGapIndex(territory.y);
  //   if (bottomIndex < this._rowGaps.length) {
  //     this._rowGaps[bottomIndex] = this._computeRowGap(bottomIndex);
  //   }
  // }
  // protected _updateGaps() {
  //   for (const index of this._colGaps) {
  //     this._colGaps[index] = this._computeColGap(index);
  //   }
  //   for (const index of this._rowGaps) {
  //     this._rowGaps[index] = this._computeRowGap(index);
  //   }
  // }
  _arrangeChildren() {
    this._rows = [], this._territories.clear(), this._resetRules(), this._children.forEach((e) => {
      this._arrangeChild(e), this._adjustRules(e);
    }), this.setSize(...this.computeSize());
  }
  _childDidResize(e) {
    this._adjustRules(e), super._childDidResize(e);
  }
  computeSize() {
    const e = this._colGaps.reduce((n, i) => n + i, 0), r = this._rowGaps.reduce((n, i) => n + i, 0);
    return [
      this._vRules.at(-1) + e,
      this._hRules.at(-1) + r
    ];
  }
  _adjustToSizeConstraint() {
  }
  resize(e, r) {
    const n = /* @__PURE__ */ new Map();
    if (this._width !== e) {
      const i = ua(this.numCols, (s) => s);
      if (this._width > e) {
        const s = i.map((a) => this._columnShrinkability(a)), o = this._apportionShrinkage(
          this._width - e,
          s.reduce((a, l) => a + l, 0),
          s,
          i
        );
        i.forEach((a) => {
          this._vRules[a + 1] -= o.get(a), i.slice(a + 1).forEach((l) => {
            this._vRules[l + 1] -= o.get(a);
          });
        }), o.entries().forEach(([a, l]) => {
          this._rows.map((c) => c[a]).forEach((c) => {
            c && l && c.canWidthFlex && n.set(c, { width: c.width - l, height: c.height });
          });
        });
      } else if (this._width < e) {
        const s = i.map((l) => this._columnCanGrow(l)), o = s.reduce((l, c) => (l ? 1 : 0) + (c ? 1 : 0), 0), a = s.map((l) => l ? (e - this._width) / o : 0);
        i.forEach((l) => {
          this._vRules[l + 1] += a[l], i.slice(l + 1).forEach((c) => {
            this._vRules[c + 1] += a[l];
          });
        }), a.forEach((l, c) => {
          this._rows.map((p) => p[c]).forEach((p) => {
            p && l && n.set(p, { width: p.width + l, height: p.height });
          });
        });
      }
      this._width = e;
    }
    if (this._height > r) {
      const i = ua(this.numRows, (a) => a), s = i.map((a) => this._rowShrinkability(a)), o = this._apportionShrinkage(
        this._height - r,
        s.reduce((a, l) => a + l, 0),
        s,
        i
      );
      i.forEach((a) => {
        this._hRules[a + 1] -= o.get(a), i.slice(a + 1).forEach((l) => {
          this._hRules[l + 1] -= o.get(a);
        });
      }), o.entries().forEach(([a, l]) => {
        this._rows[a].forEach((c) => {
          c && l && c.canHeightFlex && n.set(c, { width: c.width, height: c.height - l });
        });
      }), this._height = r;
    } else if (this._height < r) {
      const i = ua(this.numRows, (l) => l), s = i.map((l) => this._rowCanGrow(l)), o = s.reduce((l, c) => (l ? 1 : 0) + (c ? 1 : 0), 0), a = s.map((l) => l ? (r - this._height) / o : 0);
      i.forEach((l) => {
        this._hRules[l + 1] += a[l], i.slice(l + 1).forEach((c) => {
          this._hRules[c + 1] += a[l];
        });
      }), a.forEach((l, c) => {
        this._rows[c].forEach((p) => {
          p && l && n.set(p, { width: p.width, height: p.height + l });
        });
      }), this._height = r;
    }
    n.forEach((i, s) => {
      s instanceof fi || s.resize(i.width, i.height);
    }), this.layoutViews();
  }
  layoutViews() {
    this._children.forEach((e, r) => {
      this._snapChildX(e), this._snapChildY(e);
    });
  }
  _snapChildX(e) {
    const r = this._territories.get(e);
    let n = this.left;
    const i = this._vRules.slice(1).map((l, c) => l - this._vRules[c]), s = this._colGaps;
    for (let l = 0; l < r.x; l++)
      n += i[l] + s[l];
    const o = r.colAlign ?? this._colAligns[r.x], a = i.slice(r.x, r.x + r.width).reduce((l, c) => l + c, 0) + s.slice(r.x, r.x + r.width - 1).reduce((l, c) => l + c, 0);
    o === "start" ? e.left = n : o === "end" ? e.right = n + a : e.centerX = n + a / 2;
  }
  _snapChildY(e) {
    const r = this._territories.get(e);
    let n = this.top;
    const i = this._hRules.slice(1).map((l, c) => l - this._hRules[c]), s = this._rowGaps;
    for (let l = 0; l < r.y; l++)
      n += i[l] + s[l];
    const o = r.rowAlign ?? this._rowAligns[r.y], a = i.slice(r.y, r.y + r.height).reduce((l, c) => l + c, 0) + s.slice(r.y, r.y + r.height - 1).reduce((l, c) => l + c, 0);
    o === "start" ? e.paddedTop = n : o === "end" ? e.paddedBottom = n + a : e.centerY = n + a / 2;
  }
  content(...e) {
    const r = this._territories.values().map((n) => {
      const i = this._territoryBbox(n), s = new nn(this.paraview, {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      });
      return s.classInfo = { "debug-grid-territory": !0 }, s;
    });
    return Tt`
      ${super.content()}
      ${this.paraview.store.settings.dev.isShowGridTerritories ? r.map((n) => n.render()) : ""}
    `;
  }
}
var I9e = Object.defineProperty, P9e = Object.getOwnPropertyDescriptor, AV = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? P9e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && I9e(e, r, i), i;
};
const cl = 10, ZR = 15, R9e = 6;
class ls extends Pr {
  constructor(e, r, n) {
    super(e), this.popupLabelOptions = r, this.popupShapeOptions = n, this.leftPadding = this.paraview.store.settings.popup.leftPadding, this.rightPadding = this.paraview.store.settings.popup.rightPadding, this.downPadding = this.paraview.store.settings.popup.downPadding, this.upPadding = this.paraview.store.settings.popup.upPadding, this.horizShift = 0, this.arrowPosition = "bottom", this._wrapWidth = this.paraview.store.settings.popup.maxWidth, this.applyDefaults(), this._label = new fi(this.paraview, this.popupLabelOptions), this.paraview.store.settings.popup.backgroundColor === "dark" && (this._label.styleInfo = {
      stroke: "none",
      fill: this.popupLabelOptions.fill ? this.popupLabelOptions.fill : this.popupLabelOptions.type == "chord" ? "black" : this.paraview.store.colors.contrastValueAt(this.popupLabelOptions.color)
    }), this.paraview.store.settings.ui.isLowVisionModeEnabled && (this._label.styleInfo = {
      stroke: "none",
      fill: "black"
    }), this._grid = this.generateGrid(), this.popupLabelOptions.inbounds && this.shiftGrid(), this.append(this._grid), this._box = this.generateBox(n), this.append(this._box);
    const i = parseFloat(this.paraview.documentView.chartLayers.width.toFixed(5));
    if (this.popupLabelOptions.type === "sequence") {
      const s = this.popupLabelOptions.points;
      s.map((o) => o.shapes.map((a) => a.intersects(this.box))).flat().some(Boolean) && (i - s[s.length - 1].x > this.grid.width ? (this.arrowPosition = "left", this.grid.x = s[s.length - 1].x + this.leftPadding + cl) : s[0].x > this.grid.width && (this.arrowPosition = "right", this.grid.x = s[0].x - this.grid.width - this.leftPadding - cl), this._children.pop(), this._box = this.generateBox(n), this.append(this._box));
    }
    this._children.unshift(this._box), this._children.pop(), r.id && (this.id = r.id);
  }
  get grid() {
    return this._grid;
  }
  get label() {
    return this._label;
  }
  get box() {
    return this._box;
  }
  get margin() {
    return this.popupLabelOptions.margin ?? this.paraview.store.settings.popup.margin;
  }
  get wrapWidth() {
    return this._wrapWidth;
  }
  set wrapWidth(e) {
    this._wrapWidth = e;
  }
  get text() {
    return this.popupLabelOptions.text;
  }
  applyDefaults() {
    this.popupLabelOptions.color || (this.popupLabelOptions.color = 0), this.popupLabelOptions.wrapWidth || (this.popupLabelOptions.wrapWidth = this.wrapWidth), this.popupLabelOptions.y && (this.popupLabelOptions.y -= this.margin), this.popupLabelOptions.inbounds == null && (this.popupLabelOptions.inbounds = !0), this.popupLabelOptions.rotationExempt == null && (this.popupLabelOptions.rotationExempt = !0), this.popupShapeOptions.fill || (this.popupShapeOptions.fill = this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(this.popupLabelOptions.color), 6) : this.paraview.store.colors.colorValueAt(this.popupLabelOptions.color)), this.popupShapeOptions.stroke || (this.popupShapeOptions.stroke = this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(this.popupLabelOptions.color) : "black"), this.paraview.store.settings.ui.isLowVisionModeEnabled || (this.popupShapeOptions.fill = `${this.popupShapeOptions.fill.slice(0, -1)}, ${this.paraview.store.settings.popup.opacity})`), this.popupShapeOptions.shape || (this.popupShapeOptions.shape = this.paraview.store.settings.popup.shape);
  }
  shiftGrid() {
    var n, i;
    const e = parseFloat(this.paraview.documentView.chartLayers.width.toFixed(5));
    this.grid.right + this.rightPadding > e && (this.popupLabelOptions.type === "chord" ? (this.arrowPosition = "right", this.grid.x += -(this.grid.width + 2 * cl + this.rightPadding + this.leftPadding)) : (this.horizShift = this.grid.right + this.rightPadding - e, this.grid.x -= this.horizShift));
    const r = this.popupLabelOptions.type === "vertAxis" ? 0 - this.paraview.documentView.vertAxis.layout.vRules[1] : 0;
    this.grid.left - this.leftPadding < r && (this.horizShift = -(this.leftPadding - this.grid.left + r), this.grid.x -= this.horizShift), this.grid.y - this.grid.bottom < 0 && this.popupLabelOptions.type !== "chord" && (this.grid.y += this.grid.y - this.grid.bottom), this.grid.top - this.upPadding < 0 && (this.popupLabelOptions.type !== "chord" ? (this.arrowPosition = "up", this.grid.y += 2 * this.margin + this.grid.height) : this.grid.height > ((n = this.paraview.documentView) == null ? void 0 : n.chartLayers.dataLayer.height) && this.wrapWidth + 50 < ((i = this.paraview.documentView) == null ? void 0 : i.chartLayers.dataLayer.width) && (this.wrapWidth += 50, this.generateGrid(), this.shiftGrid()));
  }
  generateGrid() {
    if (this.popupLabelOptions.type === "chord") {
      let e = [];
      this.leftPadding += 10, this.arrowPosition = "left";
      let r = [];
      for (let n = 0; n < this.popupLabelOptions.items.length - 1; n++)
        r.push(R9e);
      this._grid = new kh(this.paraview, {
        numCols: 2,
        colGaps: [15],
        rowGaps: r,
        colAligns: ["center", "start"],
        isAutoWidth: !0,
        isAutoHeight: !0
      }, "popup-grid"), this.popupLabelOptions.items.forEach((n, i) => {
        e.push(Fa.fromType(
          this.paraview,
          this.paraview.store.settings.chart.isDrawSymbols ? n.symbol ?? "square.solid" : "square.solid",
          {
            color: n.color
          }
        ));
        const o = this.popupLabelOptions.text.split(/\r?\n|\r/);
        e.push(new fi(this.paraview, {
          text: o[i],
          x: 0,
          y: 0,
          wrapWidth: this.wrapWidth,
          textAnchor: "start"
        }));
      }), e.forEach((n) => this._grid.append(n)), this._grid.y = this.paraview.documentView.chartLayers.height / 2 - this._grid.height / 2, this._grid.x = this.popupLabelOptions.x + cl + this.leftPadding + this.horizShift;
    } else {
      let e = [];
      this._grid = new kh(this.paraview, {
        numCols: 1,
        colAligns: ["start"],
        isAutoWidth: !0,
        isAutoHeight: !0
      }, "popup-grid"), e.push(this._label), e.forEach((r) => this._grid.append(r)), this._grid.y = this.popupLabelOptions.y, this._grid.x = this.popupLabelOptions.x - this._grid.width / 2;
    }
    return this._grid;
  }
  generateBox(e) {
    const r = e.shape ?? "box", n = this._grid, i = n.bottom, s = n.x, o = n.width, a = n.height, l = this.leftPadding, c = this.rightPadding, p = this.upPadding, h = this.downPadding, d = this.horizShift;
    return r === "boxWithArrow" ? this.arrowPosition == "bottom" ? new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i + h),
        new Ye(Math.max(s + o / 2 - Math.min(o / 2, ZR) + d, s - l), i + h),
        //This is manually correcting for what I'm pretty sure are floating-point errors
        new Ye(Math.abs(s + o / 2 + d - (s + o + c)) < 0.5 ? s + o + c : Math.abs(s + o / 2 + d - (s - l)) < 0.5 ? s - l : s + o / 2 + d, i + h + cl),
        new Ye(Math.min(s + o / 2 + Math.min(o / 2, ZR) + d, s + o + c), i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "boxWithArrow",
      arrowPosition: "down"
    }) : this.arrowPosition == "right" ? new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a / 2 + Math.min(a / 4, 15)),
        new Ye(s + o + c + cl, i - a / 2),
        new Ye(s + o + c, i - a / 2 - Math.min(a / 4, 15)),
        new Ye(s + o + c, i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "boxWithArrow",
      arrowPosition: "right"
    }) : this.arrowPosition == "left" ? new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i - a / 2 - Math.min(a / 4, 15)),
        new Ye(s - l - cl, i - a / 2),
        new Ye(s - l, i - a / 2 + Math.min(a / 4, 15)),
        new Ye(s - l, i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "boxWithArrow",
      arrowPosition: "left"
    }) : new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a - p),
        new Ye(Math.min(s + o / 2 + Math.min(o / 4, 15) + d, s + o + c), i - a - p),
        //This is manually correcting for what I'm pretty sure are floating-point errors
        new Ye(Math.abs(s + o / 2 + d - (s + o + c)) < 0.5 ? s + o + c : Math.abs(s + o / 2 + d - (s - l)) < 0.5 ? s - l : s + o / 2 + d, i - a - p - cl),
        new Ye(Math.max(s + o / 2 + -Math.min(o / 4, 15) + d, s - l), i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "boxWithArrow",
      arrowPosition: "up"
    }) : new Pf(this.paraview, {
      points: [
        new Ye(s - l, i - a - p),
        new Ye(s - l, i + h),
        new Ye(s + o + c, i + h),
        new Ye(s + o + c, i - a - p),
        new Ye(s - l, i - a - p)
      ],
      fill: e.fill,
      stroke: e.stroke,
      shape: "box"
    });
  }
  content() {
    var r, n, i, s, o, a;
    let e = nt``;
    return this.popupLabelOptions.rotationExempt && (((r = this.paraview.documentView) == null ? void 0 : r.chartLayers.orientation) === "east" ? e += nt`
                 rotate(-90)
                translate(${-((n = this.paraview.documentView) == null ? void 0 : n.chartLayers.logicalHeight)},${0})
            ` : ((i = this.paraview.documentView) == null ? void 0 : i.chartLayers.orientation) === "west" ? e += nt`
                rotate(90)
              translate(0,${-((s = this.paraview.documentView) == null ? void 0 : s.chartLayers.logicalHeight)})
            ` : ((o = this.paraview.documentView) == null ? void 0 : o.chartLayers.orientation) === "south" && (e += nt`
                scale(1,-1)
              translate(0,${-((a = this.paraview.documentView) == null ? void 0 : a.chartLayers.logicalHeight)})
            `)), Tt`
              <g
                id="popups"
                transform=${e}
              >
                ${super.content()}
              </g>
            `;
  }
}
let I2 = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("PopupSettingsDialog"), this._dialogRef = Et(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "dropdown",
      key: "popup.shape",
      label: "Shape",
      options: { options: ["box", "boxWithArrow"] },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: "popup.activation",
      label: "Activate popups on",
      options: { options: ["onHover", "onFocus", "onSelect"] },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "slider",
      key: "popup.opacity",
      label: "Opacity",
      options: {
        min: 0,
        max: 1,
        //highBound: this._store.settings.sonification.hertzUpper - 1,
        step: 0.1
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.maxWidth",
      label: "Max width",
      options: {
        inputType: "number",
        min: 0,
        max: 300
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.leftPadding",
      label: "Left padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.rightPadding",
      label: "Right padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.upPadding",
      label: "Up padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.downPadding",
      label: "Down padding",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.margin",
      label: "Vertical margin",
      options: {
        inputType: "number",
        min: 0,
        max: 100
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "popup.borderRadius",
      label: "Border radius",
      options: {
        inputType: "number",
        min: 0,
        max: 20
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: "popup.backgroundColor",
      label: "Color mode",
      options: {
        options: ["dark", "light"]
      },
      parentView: "controlPanel.tabs.chart.dialog.popups"
    });
  }
  render() {
    return We`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="Popup Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        <div id="controls">
          <div id="popup-settings"
            class="popup-views"
          >
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.dialog.popups")}
          </div>
        </div>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show();
  }
};
I2.styles = Nt`
    #controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  `;
AV([
  Ke()
], I2.prototype, "btnText", 2);
I2 = AV([
  Dt("para-popup-settings-dialog")
], I2);
class Pf extends jo {
  constructor(e, r) {
    super(e, r), this.options = r, this.curvePoints = {
      boxWithArrow: [1, 1, 0, 0, 0, 1, 1, 1],
      boxWithDownArrow: [1, 1, 0, 0, 0, 1, 1, 1],
      boxWithUpArrow: [1, 1, 1, 1, 0, 0, 0, 1],
      boxWithRightArrow: [1, 1, 1, 0, 0, 0, 1, 1],
      boxWithLeftArrow: [1, 0, 0, 0, 1, 1, 1, 1],
      box: [1, 1, 1, 1, 1]
    }, this._points = r.points.map((n) => n.clone()), this.shape = this.options.shape;
  }
  get _pathD() {
    const e = this.paraview.store.settings.popup.borderRadius;
    let r;
    this.shape == "boxWithArrow" && this.options.arrowPosition === "up" ? r = this.curvePoints.boxWithUpArrow : this.shape == "boxWithArrow" && this.options.arrowPosition === "down" ? r = this.curvePoints.boxWithDownArrow : this.shape == "boxWithArrow" && this.options.arrowPosition === "right" ? r = this.curvePoints.boxWithRightArrow : this.shape == "boxWithArrow" && this.options.arrowPosition === "left" ? r = this.curvePoints.boxWithLeftArrow : r = this.curvePoints[this.shape];
    const n = this._points.map((o) => o.add(this._loc));
    let i = nt``, s = n.length;
    if (!r[0] || Math.abs(n[0].x - n[s - 2].x) < e / 2 && Math.abs(n[0].y - n[s - 2].y) < e / 2)
      i += nt`M${n[0].x},${n[0].y}`;
    else {
      let o = n[0], a = n[1 % s];
      const l = Math.sign(o.x - a.x), c = Math.sign(o.y - a.y);
      i += nt`M${o.x - l * e},${o.y - c * e}`;
    }
    for (let o = 1; o < s; o++) {
      let a = n[o % s], l = n[(o - 1 + s) % s], c = n[(o + 1 + (o === s - 1 ? 1 : 0)) % s];
      if (!r[o % s] || Math.abs(a.x - l.x) < e / 2 && Math.abs(a.y - l.y) < e / 2 || Math.abs(a.x - c.x) < e / 2 && Math.abs(a.y - c.y) < e / 2 && o !== s - 1)
        i += nt`L${a.x},${a.y}`;
      else {
        const p = Math.sign(a.x - l.x), h = Math.sign(a.y - l.y), d = Math.sign(c.x - a.x), v = Math.sign(c.y - a.y);
        i += nt`L${a.x - p * e},${a.y - h * e}`, i += nt`A ${e}, ${e}, 0, 0, 0, ${a.x + d * e}, ${a.y + v * e}`;
      }
    }
    return i;
  }
}
class JR extends pf {
  constructor(e, r, n, i) {
    super(e, r, n), this.type = i, this._groups = /* @__PURE__ */ new Map();
  }
  _createId() {
    return super._createId(`${this.type}-annotation`);
  }
  group(e) {
    return this._groups.get(e);
  }
  addGroup(e, r = !1) {
    if (this._groups.has(e)) {
      if (r)
        return;
      throw new Error(`group '${e}' already exists`);
    }
    this._groups.set(e, new O9e(this.paraview, e)), this.append(this._groups.get(e));
  }
  removeGroup(e, r = !1) {
    if (this._groups.has(e))
      this._groups.delete(e);
    else {
      if (r)
        return;
      throw new Error(`group '${e}' does not exist`);
    }
  }
  renderChildren() {
    var e;
    if (this.type === "foreground") {
      if (this.paraview.store.modelTrendLines) {
        this.addGroup("trend-lines", !0), this.group("trend-lines").clearChildren();
        for (const r of this.paraview.store.modelTrendLines) {
          const n = this.paraview.store.model.series.filter((v) => v[0].seriesKey == r.seriesKey)[0], i = this.parent.docView.chartInfo.getYAxisInterval(), s = i.start ?? Number(this.paraview.store.settings.axis.y.minValue), o = i.end ?? Number(this.paraview.store.settings.axis.y.maxValue), a = this.height - (n.datapoints[r.startIndex].facetValueNumericized("y") - s) / (o - s) * this.height, l = this.height - (n.datapoints[r.endIndex - 1].facetValueNumericized("y") - s) / (o - s) * this.height, c = this.width * r.startPortion, p = this.width * r.endPortion, h = this.paraview.store.colors.colorValue("visit"), d = new jo(this.paraview, {
            x: this._x,
            y: this._y,
            points: [new Ye(c, a), new Ye(p, l)],
            fill: h,
            stroke: h
          });
          d.classInfo = { "trend-line": !0 }, this.group("trend-lines").append(d);
        }
      } else
        this._groups.has("trend-lines") && this.removeGroup("trend-lines", !0);
      if (this.paraview.store.userTrendLines) {
        this.addGroup("user-trend-lines", !0), this.group("user-trend-lines").clearChildren();
        let r = structuredClone(this.paraview.store.userTrendLines);
        if (this.paraview.store.visitedDatapoints.size > 0) {
          const n = on(this.paraview.store.visitedDatapoints.values().toArray()[0]);
          r = r.filter((i) => i.seriesKey == n.seriesKey);
        }
        for (const n of r) {
          const i = this.paraview.store.model.series.filter((m) => m[0].seriesKey == n.seriesKey)[0], s = this.parent.docView.chartInfo.getYAxisInterval(), o = s.start ?? Number(this.paraview.store.settings.axis.y.minValue), a = s.end ?? Number(this.paraview.store.settings.axis.y.maxValue), l = this.height - (i.datapoints[n.startIndex].facetValueNumericized("y") - o) / (a - o) * this.height, c = this.height - (i.datapoints[n.endIndex - 1].facetValueNumericized("y") - o) / (a - o) * this.height, p = this.width * n.startPortion, h = this.width * n.endPortion, d = this.paraview.store.colors.colorValue("highlight"), v = new jo(this.paraview, {
            x: this._x,
            y: this._y,
            points: [new Ye(p, l), new Ye(h, c)],
            fill: d,
            stroke: d
          });
          v.classInfo = { "user-trend-line": !0 }, this.group("user-trend-lines").append(v);
        }
      } else
        this._groups.has("user-trend-lines") && this.removeGroup("user-trend-lines", !0);
      if (this.paraview.store.annotations) {
        this.addGroup("annotation-popups", !0), this.group("annotation-popups").clearChildren();
        let r = structuredClone(this.paraview.store.annotations.filter((n) => n.type == "datapoint" && n.isSelected == !0));
        for (const n of r) {
          const i = this.paraview.store.model.series.filter((a) => a[0].seriesKey == n.seriesKey)[0].key, s = (e = this.paraview.documentView) == null ? void 0 : e.chartLayers.dataLayer.datapointViews.filter((a) => a.seriesKey == i && a.index == n.index)[0];
          if (!s)
            break;
          let o = new ls(
            this.paraview,
            {
              text: n.text,
              x: s.x,
              y: s.y,
              textAnchor: "middle",
              classList: ["annotationlabel"],
              id: this.id,
              color: s.color,
              points: [s]
            },
            {
              fill: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(s.color), 6) : this.paraview.store.colors.colorValueAt(s.color),
              stroke: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(s.color) : "black"
            }
          );
          o.classInfo = { popup: !0 }, this.group("annotation-popups").append(o);
        }
      } else
        this._groups.has("annotation-popups") && this.removeGroup("annotation-popups", !0);
    }
    if (this.type === "background") {
      if (this.paraview.store.rangeHighlights) {
        this.addGroup("range-highlights", !0), this.group("range-highlights").clearChildren();
        for (const r of this.paraview.store.rangeHighlights) {
          const n = this.width * r.startPortion, i = this.width * r.endPortion, s = new nn(this.paraview, {
            x: n,
            y: 0,
            width: i - n,
            height: this.height
          });
          s.classInfo = { "range-highlight": !0 }, this.group("range-highlights").append(s);
        }
      } else
        this._groups.has("range-highlights") && this.removeGroup("range-highlights", !0);
      if (this.paraview.store.modelLineBreaks) {
        this.addGroup("linebreaker-markers", !0), this.group("linebreaker-markers").clearChildren();
        for (const r of this.paraview.store.modelLineBreaks) {
          const n = this.width * r.startPortion, i = new nn(this.paraview, {
            x: n - 1.5,
            y: 0,
            width: 3,
            height: this.height
          });
          i.classInfo = { "linebreaker-marker": !0 }, this.group("linebreaker-markers").append(i);
        }
      } else
        this._groups.has("linebreaker-markers") && this.removeGroup("linebreaker-markers", !0);
      if (this.paraview.store.userLineBreaks) {
        this.addGroup("user-linebreaker-markers", !0), this.group("user-linebreaker-markers").clearChildren();
        let r = structuredClone(this.paraview.store.userLineBreaks);
        if (this.paraview.store.visitedDatapoints.size > 0) {
          const n = on(this.paraview.store.visitedDatapoints.values().toArray()[0]);
          r = r.filter((i) => i.seriesKey == n.seriesKey);
        }
        for (const n of r) {
          const i = this.paraview.store.model.series.findIndex((l) => l.key == n.seriesKey), s = this.paraview.store.colors.colorValueAt(i), o = this.width * n.startPortion, a = new nn(this.paraview, {
            x: o - 1.5,
            y: 0,
            width: 3,
            height: this.height,
            fill: s
          });
          a.classInfo = { "user-linebreaker-marker": !0 }, this.group("user-linebreaker-markers").append(a);
        }
      } else
        this._groups.has("user-linebreaks") && this.removeGroup("userlinebreaks", !0);
    }
    return super.renderChildren();
  }
}
let O9e = class extends vo(Pr) {
  constructor(e, r) {
    super(e), this._name = r;
  }
  get name() {
    return this._name;
  }
};
class kV extends pf {
  constructor(e, r, n, i, s) {
    super(e, r, n), this.dataLayerIndex = i, this._chartInfo = s, this._datapointDomIds = /* @__PURE__ */ new Map(), this._currentAnimationFrame = null, this._animateRevealComplete = !1;
  }
  _createId() {
    return super._createId("data");
  }
  _addedToParent() {
    super._addedToParent(), this._chartLandingView = new h8e(this.paraview), this.append(this._chartLandingView);
  }
  get managedSettingKeys() {
    return [`type.${this._parent.docView.type}`];
  }
  get settings() {
    return vr.getGroupLink(this.managedSettingKeys[0], this.paraview.store.settings);
  }
  get chartInfo() {
    return this._chartInfo;
  }
  resize(e, r) {
    super.resize(e, r), this._layoutDatapoints();
  }
  // get sonifier() {
  //   return this._sonifier;
  // }
  get chartLandingView() {
    return this._chartLandingView;
  }
  get datapointViews() {
    return this._chartLandingView.datapointViews;
  }
  get visitedDatapointViews() {
    return this.datapointViews.filter(
      (e) => this.paraview.store.isVisited(e.seriesKey, e.index)
    );
  }
  get selectedDatapointViews() {
    return this.datapointViews.filter(
      (e) => this.paraview.store.isSelected(e.seriesKey, e.index)
    );
  }
  registerDatapoint(e) {
    const r = `${e.seriesKey}-${e.index}`;
    this._datapointDomIds.set(r, e.id);
  }
  unregisterDatapoint(e) {
    this._datapointDomIds.delete(`${e.seriesKey}-${e.index}`);
  }
  get datapointDomIds() {
    return this._datapointDomIds;
  }
  get dataset() {
    return this.paraview.ref(`dataset${this.index}`).value;
  }
  get role() {
    return "dataset";
  }
  get ref() {
    return yt(this.paraview.ref(`dataset${this.index}`));
  }
  get animateRevealComplete() {
    return this._animateRevealComplete;
  }
  init() {
    this._layoutDatapoints(), this.paraview.store.settings.animation.isAnimationEnabled && this._animateReveal();
  }
  settingDidChange(e, r, n) {
    ["ui.isLowVisionModeEnabled"].includes(e) && (r || this.paraview.store.updateSettings((i) => {
      i.popup.activation = "onSelect";
    })), ["popup.activation"].includes(e) && (r === "onSelect" || r === "onFocus") && (this.paraview.store.popups.splice(0, this.paraview.store.popups.length), this.paraview.store.userLineBreaks.splice(0, this.paraview.store.userLineBreaks.length)), ["chart.showPopups"].includes(e) && this.paraview.store.popups.splice(0, this.paraview.store.popups.length), super.settingDidChange(e, r, n);
  }
  /**
   * Stroke width for visited datapoints. Can be overridden.
   */
  get visitedStrokeWidth() {
    const e = this.paraview.store.settings.chart.strokeHighlightScale;
    return this.paraview.store.settings.chart.strokeWidth * e;
  }
  /**
   * Mutate `styleInfo` with any custom series styles.
   * @param styleInfo
   */
  updateSeriesStyle(e) {
  }
  _beginDatapointLayout() {
    this._createDatapoints();
    for (const e of this.datapointViews)
      e.computeLocation();
  }
  _completeDatapointLayout() {
    for (const e of this.datapointViews)
      e.completeLayout();
  }
  _layoutDatapoints() {
    this._chartLandingView.clearChildren(), this._beginDatapointLayout(), this.paraview.store.settings.animation.isAnimationEnabled && this.paraview.store.settings.animation.symbolPopIn && this.datapointViews.map((e) => e.baseSymbolScale = 0), this._completeDatapointLayout();
  }
  // protected _layoutComponents() {
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.computeLocation();
  //   }
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.completeLayout();
  //   }
  //   //this._layoutSymbols();
  // }
  _animateReveal() {
    let e = -1;
    const r = new SV(0.2, 0.9, 0.5, 1, 10), n = (o) => {
      e === -1 && (e = o);
      const a = o - e, l = Math.max(1, this.paraview.store.settings.animation.animateRevealTimeMs), c = Math.min(a / l, 1), p = r.eval(c);
      this._animStep(p), this.paraview.paraChart.postNotice("animRevealStep", p), this.paraview.requestUpdate(), a < l ? this._currentAnimationFrame = requestAnimationFrame(n) : this._animEnd();
    };
    this._currentAnimationFrame = requestAnimationFrame(n);
    const i = Date.now(), s = () => {
      let o = setTimeout(() => {
        this.paraview.requestUpdate(), s();
      }, 50);
      Date.now() - i > this.paraview.store.settings.animation.popInAnimateRevealTimeMs + this.paraview.store.settings.animation.animateRevealTimeMs && clearTimeout(o);
    };
    s();
  }
  _animStep(e) {
    this.paraview.store.settings.animation.lineSnake && (this.paraview.clipWidth = e * this.paraview.documentView.chartLayers.width);
    for (const r of this.datapointViews)
      r.beginAnimStep(e);
    for (const r of this.datapointViews)
      r.endAnimStep(e);
  }
  _animEnd() {
    this.paraview.paraChart.postNotice("animRevealEnd", null), this._currentAnimationFrame = null, this._animateRevealComplete = !0;
  }
  stopAnimation() {
    this._currentAnimationFrame !== null && (cancelAnimationFrame(this._currentAnimationFrame), this._animStep(1), this.paraview.paraChart.postNotice("animRevealStep", 1), this.paraview.requestUpdate(), this._animEnd());
  }
  _newDatapointView(e, ...r) {
    return new hf(e);
  }
  _newSeriesView(e, r, ...n) {
    return new Ak(this, e, r);
  }
  datapointView(e, r) {
    return this.datapointViews.find((n) => n.seriesKey === e && n.index === r);
  }
  datapointViewForId(e) {
    return this.datapointViews.find((r) => r.id === e);
  }
  // protected _layoutSymbols() {
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.layoutSymbol();
  //   }
  // }
  focusRingBbox() {
    const r = this._parent.docView.chartInfo.navMap.cursor;
    return ["series", "chord", "datapoint", "sequence"].includes(r.type) ? Y4(...r.datapoints.map((n) => this.datapointView(n.seriesKey, n.datapointIndex).outerBbox)) : null;
  }
  handlePan(e, r, n, i) {
  }
  handleZoom(e, r) {
  }
}
class Xb extends kV {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this.log = qt("PlanePlotView");
  }
  get datapointViews() {
    return super.datapointViews;
  }
  get visitedDatapointViews() {
    return super.visitedDatapointViews;
  }
  get selectedDatapointViews() {
    return super.selectedDatapointViews;
  }
  /*
  protected get _eventActions(): Actions<this> {
    return {
      ...super._eventActions,
      // User attempted to move past series endpoint in chord mode
      series_endpoint_reached: function() {
        todo().controller.announce('On final point.');
      },
      // User attempted to move past endpoint of final series
      final_series_endpoint_reached: function() {
        todo().controller.appendAnnouncement('Press the up arrow to go to the previous series, or the left arrow to go to the previous point in this series');
        todo().controller.announce('On final point of final series.');
      },
      // User attempted to move up from first series
      first_series_reached: function() {
        todo().controller.appendAnnouncement('Press the down arrow to go to the next series, or the left or right arrow to explore this series');
        todo().controller.announce('On first series.');
      },
      // User attempted to move down from final series
      final_series_reached: function() {
        todo().controller.appendAnnouncement('Press the up arrow to go to the previous series, or the left or right arrow to explore this series');
        todo().controller.announce('On final series.');
      },
      // User attempted to move up or down while on the root nav point
      no_series: function() {
        todo().controller.announce('No series selected.');
      },
      chord_mode_no_up_down: function() {
        todo().controller.announce('Cannot switch series in chord mode.');
      },
    };
  }*/
  /*compareDatapoints(datapoint1: XYDatapointView, datapoint2: XYDatapointView) :
      {
        comparator: string,
        diff: number
      }
    {
      // TODO: localize this text output
      // TODO: move this to some statistical / NLP module
      const value1 = datapoint1.datapoint.y;
      const value2 = datapoint2.datapoint.y;
      const result = value1.compare(value2);
      let comparator = '';
      if (result.relationship === 'equal') {
        comparator = 'equal to';
      } else {
        comparator = (result.relationship === 'greater') ? 'greater than' : 'less than';
      }
      return {
        comparator,
        diff: result.diff!
      };
    }
  
    capitalize(string: string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }*/
}
class ew extends Ak {
  get children() {
    return super.children;
  }
  get siblings() {
    return super.siblings;
  }
}
class _V extends hf {
  constructor(e) {
    super(e);
  }
  _addedToParent() {
    super._addedToParent();
  }
  // override to get more specific return type
  get datapoint() {
    return super.datapoint;
  }
  // get styleInfo() {
  //   const styles = super.styleInfo;
  //   styles['--datapoint-centroid'] = this.centroid;
  //   return styles;
  // }
  /*protected get _eventActions(): Actions<this> {
    return {
      datapoint_focused: function(focusInfo: FocusInfo) {
        todo().controller.announce(this.summary(focusInfo));
      },
      datapoint_selected: function(selectionInfo: XYSelectionInfo) {
        todo().controller.announce(this.chart.composeDatapointSelectionAnnouncement(selectionInfo));
      },
    };
  }*/
  //abstract computeLayout(): void;
  /*summary(focusInfo: FocusInfo) {
    if (focusInfo.visited.length > 1) {
      return `${this.datapoint.formatX('statusBar')}, all points`;
    } else {
      // Don't include the series name unless the previously-visited point
      // was in a different series
      const datapoint = this.datapoint.format('statusBar');
      /*if (!focusInfo.isSeriesChange) {
        return datapoint;
      } else if (todo().seriesSummaries[focusInfo.visited[0].series.name!]) {
        return `${todo().controller.todo.seriesSummaries[focusInfo.visited[0].series.name!]} ${datapoint}`;
      } else {
        return `${focusInfo.visited[0].series.name!}: ${datapoint}`;
      }*/
  //  }
  //}
  async onFocus(e = !1) {
    await super.onFocus(e);
  }
}
class CV extends Xb {
  settingDidChange(e, r, n) {
    ["axis.y.maxValue", "axis.y.minValue"].includes(e) && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  async storeDidChange(e, r) {
    await super.storeDidChange(e, r), e === "frontSeries" && this._raiseSeries(r);
  }
  get datapointViews() {
    return super.datapointViews;
  }
  _newSeriesView(e) {
    return new T9e(this, e);
  }
  _newDatapointView(e) {
    return new Lk(e);
  }
  _createDatapoints() {
    const e = [];
    for (const [r, n] of Wn(this.paraview.store.model.series[0].datapoints))
      e.push(Wr(r.facetBox("x"), this.paraview.store.getFormatType(`${this.parent.docView.type}Point`))), Yn(e.at(-1));
    for (const [r, n] of Wn(this.paraview.store.model.series)) {
      const i = this._newSeriesView(r.key);
      this._chartLandingView.append(i);
      for (const [s, o] of Wn(r)) {
        const a = this._newDatapointView(i);
        i.append(a);
      }
    }
    this._chartLandingView.sortChildren((r, n) => n.children[0].datapoint.facetValueNumericized(n.children[0].datapoint.depKey) - r.children[0].datapoint.facetValueNumericized(r.children[0].datapoint.depKey));
  }
  // protected _layoutDatapoints() {
  //   ChartPoint.computeSize(this);
  //   for (const datapointView of this.datapointViews) {
  //      datapointView.computeLayout();
  //   }
  // }
  seriesRef(e) {
    return this.paraview.ref(`series.${e}`);
  }
  _raiseSeries(e) {
    this.log.info("RAISING", e);
    const r = this.seriesRef(e).value;
    this.dataset.append(r);
  }
  getDatapointGroupBbox(e) {
    const n = this.paraview.store.model.allFacetValues("x").map(
      (s) => Wr(s, this.paraview.store.getFormatType("horizTick"))
    ).findIndex((s) => s === e);
    if (n === -1)
      throw new Error(`no such datapoint with label '${e}'`);
    return this.paraview.ref("dataset").value.children[n].getBBox();
  }
  getTickX(e) {
    return this.datapointViews[e].x;
  }
}
class T9e extends ew {
}
class Lk extends _V {
  // static computeSize(chart: PointChart) {
  //   const axisDivisions = chart.paraview.store.model!.allFacetValues('x')!.length - 1;
  //   this.width = chart.parent.contentWidth/axisDivisions;
  // }
  constructor(e) {
    super(e), this._currentAnimationFrame = null, this._isAnimating = !1, this._hasAnimated = !1;
  }
  get width() {
    const e = this.paraview.store.model.series[0].length - 1;
    return this.chart.width / e;
  }
  get height() {
    return 0;
  }
  get _selectedMarkerX() {
    return this._x - this.width / 2;
  }
  get _selectedMarkerY() {
    return this._y - this.height / 2;
  }
  get hasAnimated() {
    return this._hasAnimated;
  }
  computeX() {
    return this.width * this.index;
  }
  computeY() {
    const e = this.chart.parent.docView.chartInfo.axisInfo.yLabelInfo, r = this.chart.height / e.range;
    return this.chart.height - (this.datapoint.facetValueNumericized("y") - e.min) * r;
  }
  computeLocation() {
    this._x = this.computeX(), this.paraview.store.settings.animation.isAnimationEnabled && this.paraview.store.settings.animation.expandPoints ? (this.paraview.store.settings.animation.animationOrigin === "initialValue" ? this._animStartState.y = this._parent.children[0].computeY() : this.paraview.store.settings.animation.animationOrigin === "baseline" ? this._animStartState.y = this.chart.height : this.paraview.store.settings.animation.animationOrigin === "top" ? this._animStartState.y = 0 : this._animStartState.y = this.paraview.store.settings.animation.animationOriginValue, this._animEndState.y = this.computeY(), this._y = this._animStartState.y) : (this._y = this.computeY(), this._animStartState.y = this._y, this._animEndState.y = this._y);
  }
  beginAnimStep(e) {
    this.paraview.store.settings.animation.symbolPopIn && e + 0.01 >= this.x / this.chart.width && !this._isAnimating && !this._hasAnimated && this.popInAnimation(e), this._y = this._animStartState.y * (1 - e) + this._animEndState.y * e, super.beginAnimStep(e);
  }
  _animEnd() {
    this._currentAnimationFrame = null, this._isAnimating = !1, this._hasAnimated = !0;
  }
  popInAnimation(e) {
    this._isAnimating = !0;
    let r = -1;
    this._baseSymbolScale = 0;
    const n = new SV(0.2, 6, 1, 1, 10), i = (s) => {
      r === -1 && (r = s);
      const o = s - r, a = Math.max(1, this.paraview.store.settings.animation.popInAnimateRevealTimeMs), l = Math.min(o / a, 1), c = n.eval(l);
      this._baseSymbolScale = c * 0.25 + 0.75, this._contentUpdateSymbol(), o < a ? this._currentAnimationFrame = requestAnimationFrame(i) : this._animEnd();
    };
    this._currentAnimationFrame = requestAnimationFrame(i);
  }
}
class L9e extends Pr {
  constructor(e) {
    super(e.paraview), this.chart = e, this.x1 = 0, this.x2 = 0, this.y1 = 0, this.y2 = 0, this._generateEndpoints();
  }
  _generateEndpoints() {
    const e = [];
    for (const n of this.chart.datapointViews)
      e.push([n.x, n.y]);
    const r = kE(e);
    this.y1 = r.b, this.x2 = this.chart.parent.width, this.y2 = this.x2 * r.m + r.b, this.y2 < 0 && (this.x2 = -1 * r.b / r.m, this.y2 = 0), this.y2 > this.chart.parent.height && (this.x2 = (this.chart.parent.height - r.b) / r.m, this.y2 = this.chart.parent.height);
  }
  render() {
    return Tt`
    <line x1=${this.x1} x2=${this.x2} y1=${this.y1} y2=${this.y2} style="stroke:red;stroke-width:3"/>
    `;
  }
}
const M9e = 8, XR = 0.125;
function N9e(t) {
  let e = 1, r = [], n = !0;
  for (; !r.length; )
    for (let s = 0; s < t.length; s++) {
      let o;
      if (t[s].match(/\s/) && !n ? o = t[s].split(/\s+/).map((a) => a.slice(0, e)).join("") : o = t[s].slice(0, e), r.includes(o)) {
        r = [], e++, n = !1;
        break;
      }
      r[s] = o;
    }
  const i = {};
  return t.forEach((s, o) => i[s] = r[o]), i;
}
class o1 extends Xb {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this._totalLabels = [], this.log = qt("BarPlotView");
  }
  _addedToParent() {
    super._addedToParent(), this.paraview.store.settings.type.bar.isAbbrevSeries && (this._abbrevs = N9e(this.paraview.store.model.seriesKeys)), this.paraview.store.settingControls.add({
      type: "checkbox",
      key: "chart.showPopups",
      label: "Show popups",
      parentView: "controlPanel.tabs.chart.popups"
    });
  }
  settingDidChange(e, r, n) {
    ["color.colorPalette", "color.colorVisionMode", "chart.showPopups"].includes(e) && (n === "pattern" || n !== "pattern" && r === "pattern" || this.paraview.store.settings.color.colorPalette === "pattern") && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  get abbrevs() {
    return this._abbrevs;
  }
  get numStacks() {
    return this._numStacks;
  }
  get stackWidth() {
    return this._stackWidth;
  }
  get clusterWidth() {
    return this._clusterWidth;
  }
  get availSpace() {
    return this._availSpace;
  }
  _newDatapointView(e, r) {
    return new D9e(e, r);
  }
  _beginDatapointLayout() {
    const e = Object.values(this._chartInfo.clusteredData).length;
    this._numStacks = e * this._chartInfo.stacksPerCluster;
    let r = (this._width - e * this._chartInfo.settings.clusterGap) / this._numStacks, n = 0;
    r >= M9e ? (this._stackWidth = (1 - XR) * r, n = XR * r) : this._stackWidth = r, this._availSpace = n * this._numStacks, super._beginDatapointLayout();
  }
  _createDatapoints() {
    const e = this._parent.docView.chartInfo, r = {};
    Object.entries(e.clusteredData).forEach(([n, i], s) => {
      for (const [o, a] of Object.entries(i.stacks))
        for (const [l, c] of Object.entries(a.bars))
          r[l] || (r[l] = new ew(this, l), this._chartLandingView.append(r[l])), r[l].append(this._newDatapointView(r[l], a));
    }), this.paraview.store.type === "column" && this._chartLandingView.reverseChildren();
  }
  _completeDatapointLayout() {
    if (super._completeDatapointLayout(), this._chartInfo.settings.stacking === "standard" && this._chartInfo.settings.isDrawTotalLabels) {
      this._totalLabels.forEach((i) => {
        i.remove();
      }), this._totalLabels = [];
      const e = this._chartLandingView.children;
      let r = 0;
      this.parent.orientation === "east" && (r = -90);
      let n = 0;
      for (const [i, s] of Object.entries(this._chartInfo.clusteredData))
        for (const [o, a] of Object.entries(s.stacks)) {
          const l = Object.values(a.bars).at(-1), p = e.find((d) => d.seriesKey === l.series).children[n++], h = Object.values(a.bars).map((d) => e.find((m) => m.seriesKey === d.series).children[n - 1].datapoint).reduce((d, v) => d + v.facetValueAsNumber("y"), 0);
          this._totalLabels.push(new fi(this.paraview, {
            // XXX hack
            text: h.toFixed(2),
            id: this._id + "-slb",
            classList: [`${this.paraview.store.type}-total-label`],
            role: "datapoint",
            // textAnchor,
            angle: r
          })), this.append(this._totalLabels.at(-1)), this._totalLabels.at(-1).centerX = p.centerX, this._totalLabels.at(-1).bottom = p.top;
        }
    }
  }
  noticePosted(e, r) {
    ["animRevealStep", "animRevealEnd"].includes(e) && this._completeDatapointLayout();
  }
  // protected _resizeToFitLabels() {
  //   const labels = Object.values(this.bars).flatMap(cluster =>
  //     Object.values(cluster.stacks)).map(stack => stack.label!);
  //   const minX = Math.min(...labels.map(label => label.left));
  //   if (minX < 0) {
  //     this._parent.logicalWidth += -minX;
  //     this.log.info('NEW WIDTH', this._width);
  //     this.datapointViews.forEach(dp => {
  //       dp.x += -minX;
  //     });
  //   }
  //   const maxX = Math.max(...labels.map(label => label.right));
  //   if (maxX > this._width) {
  //     const diff = maxX - this._width;
  //     this._parent.logicalWidth += diff;
  //     this.log.info('NEW WIDTH', this._width);
  //   }
  //   const minY = Math.min(...labels.map(label => label.top));
  //   if (minY < 0) {
  //     this._parent.logicalHeight += -minY;
  //     this.log.info('NEW HEIGHT', this._height);
  //     this.datapointViews.forEach(dp => {
  //       dp.y += -minY;
  //     });
  //     labels.forEach(label => {
  //       label.y += -minY;
  //     });
  //   }
  //   const maxY = Math.max(...labels.map(label => label.bottom));
  //   if (maxY > this._height) {
  //     const diff = maxY - this._height;
  //     this._parent.logicalHeight += diff;
  //     this.log.info('NEW HEIGHT', this._height);
  //   }
  //   //this._checkLabelSpacing();
  // }
  // protected _checkLabelSpacing() {
  //   const labels = Object.values(this.bars).flatMap(cluster =>
  //     Object.values(cluster.stacks)).map(stack => stack.label!);
  //   const gaps = labels.slice(1).map((label, i) => label.left - labels[i].right);
  //   const minGap = Math.min(...gaps);
  //   if (Math.round(minGap) < 0) {
  //     const diffBefore = labels.at(-1)!.x - labels[0].x;
  //     labels.slice(1).forEach((label, i) => {
  //       // NB: Even if the anchor is set to middle, the labels may be rotated, so
  //       // the anchor will no longer be in the middle of the bbox
  //       label.x = labels[i].right + 0 + label.anchorXOffset;
  //     });
  //     const diffAfter = labels.at(-1)!.x - labels[0].x;
  //     this._parent.logicalWidth += diffAfter - diffBefore;
  //   }
  // }
}
class D9e extends _V {
  constructor(e, r) {
    super(e), this._stack = r, this._recordLabel = null, this._dataLabel = null, this._isStyleEnabled = this.paraview.store.settings.type.bar.colorByDatapoint;
  }
  get classInfo() {
    return { bar: !0, ...super.classInfo };
  }
  get x() {
    return super.x;
  }
  set x(e) {
    this._dataLabel && (this._dataLabel.x += e - this._x), super.x = e;
  }
  get y() {
    return super.y;
  }
  set y(e) {
    this._dataLabel && (this._dataLabel.y += e - this._y), super.y = e;
  }
  get recordLabel() {
    return this._recordLabel;
  }
  set recordLabel(e) {
    this._recordLabel = e;
  }
  get dataLabel() {
    return this._dataLabel;
  }
  set dataLabel(e) {
    this._dataLabel = e;
  }
  get _selectedMarkerX() {
    return this._x;
  }
  get _selectedMarkerY() {
    return this._y;
  }
  // get styleInfo(): StyleInfo {
  //   const style = super.styleInfo;
  //   if (!this.paraview.store.isVisited(this.seriesKey, this.index)) {
  //     style.strokeWidth = 0;
  //   }
  //   return style;
  // }
  computeLocation() {
    const e = this.chart.chartInfo, r = this.chart.stackWidth;
    if (this._width = this.chart.stackWidth, this.paraview.store.settings.animation.isAnimationEnabled)
      this._height = 0, this._y = 0;
    else {
      const s = Object.keys(this._stack.bars).indexOf(this.series.key), o = this.chart.parent.logicalHeight / e.axisInfo.yLabelInfo.range, a = Object.values(this._stack.bars).slice(0, s).map((c) => c.value.value * o).reduce((c, p) => c + p, 0), l = this.chart.parent.logicalHeight - e.axisInfo.yLabelInfo.max * this.chart.parent.logicalHeight / e.axisInfo.yLabelInfo.range;
      this._height = Math.abs(this.datapoint.data.y.value * o), this.datapoint.data.y.value < 0 ? this._y = this.chart.height - a - l : this._y = this.chart.height - this.height - a - l;
    }
    const n = this.chart.availSpace / this.chart.numStacks, i = e.settings.clusterGap;
    this._x = i / 2 + n / 2 + r * (e.stacksPerCluster * this._stack.cluster.index + this._stack.index) + i * this._stack.cluster.index + n * (e.stacksPerCluster * this._stack.cluster.index + this._stack.index);
  }
  beginAnimStep(e) {
    const r = this.chart.chartInfo, n = Object.keys(this._stack.bars).indexOf(this.series.key), i = this.chart.parent.logicalHeight / r.axisInfo.yLabelInfo.range, s = Object.values(this._stack.bars).slice(0, n).map((a) => a.value.value * i).reduce((a, l) => a + l, 0), o = this.chart.parent.logicalHeight - r.axisInfo.yLabelInfo.max * this.chart.parent.logicalHeight / r.axisInfo.yLabelInfo.range;
    this._height = Math.abs(this.datapoint.data.y.value * i * e), this.datapoint.data.y.value < 0 ? this._y = this.chart.height - s * e - o : this._y = this.chart.height - this.height - s * e - o, super.beginAnimStep(e);
  }
  completeLayout() {
    super.completeLayout();
    const e = this.chart.chartInfo;
    let r = "middle", n = 0;
    this.chart.parent.orientation === "east" && (r = "start", n = -90), e.settings.isDrawRecordLabels && (this._recordLabel = new fi(this.paraview, {
      // @ts-ignore
      text: Wr(this.datapoint.data.x, this.paraview.store.getFormatType("pieSliceValue")),
      id: this._id + "-rlb",
      classList: [`${this.paraview.store.type}-label`],
      role: "datapoint",
      textAnchor: r,
      angle: n
    }), this.append(this._recordLabel), this._recordLabel.styleInfo = {
      stroke: "none",
      fill: this.paraview.store.colors.contrastValueAt(this._isStyleEnabled ? this.index : this.parent.index)
    }, this._recordLabel.centerX = this.centerX, this._recordLabel.y = this.chart.height - this._recordLabel.height - e.settings.stackLabelGap), e.settings.isDrawDataLabels && (this._dataLabel = new fi(this.paraview, {
      // @ts-ignore
      text: Wr(this.datapoint.data.y, this.paraview.store.getFormatType("pieSliceValue")),
      id: this._id + "-blb",
      classList: [`${this.paraview.store.type}-label`],
      role: "datapoint",
      textAnchor: r,
      angle: n
    }), this.append(this._dataLabel), this._dataLabel.styleInfo = {
      stroke: "none",
      fill: this.paraview.store.colors.contrastValueAt(this._isStyleEnabled ? this.index : this.parent.index)
    }, this._dataLabel.centerX = this.centerX, e.settings.dataLabelPosition === "center" ? this._dataLabel.centerY = this.centerY : e.settings.dataLabelPosition === "end" ? this._dataLabel.top = this.top : e.settings.dataLabelPosition === "base" ? this._dataLabel.bottom = this.bottom : this._dataLabel.bottom = this.top);
  }
  _createSymbol() {
  }
  // protected get _d() {
  //   return fixed`
  //     M${this._x},${this._y + this.chart.settings.barGap}
  //     v${this._height - this.chart.settings.barGap*2}
  //     h${BarStack.width}
  //     v${-(this._height - this.chart.settings.barGap*2)}
  //     Z`;
  // }
  _createShapes() {
    const e = this.paraview.store.colors.palette.isPattern;
    this._shapes.forEach((r) => {
      r.remove();
    }), this._shapes = [], this._shapes.push(new nn(this.paraview, {
      x: this._x,
      y: this._y,
      width: this._width,
      height: this._height,
      isPattern: !!e,
      pointerEnter: (r) => {
        this.paraview.store.settings.chart.showPopups && this.addPopup();
      },
      pointerLeave: (r) => {
        this.paraview.store.settings.chart.showPopups && this.removePopup(this.id);
      }
    })), super._createShapes();
  }
  get selectedMarker() {
    return new nn(this.paraview, {
      width: this._width + 4,
      height: this._height + 4,
      x: this._x - 2,
      y: this._y - 2,
      fill: "none",
      stroke: "black",
      strokeWidth: 2,
      isClip: this.shouldClip
    });
  }
  addPopup(e) {
    let r = `${this.seriesKey} ${this.index + 1}/${this.series.datapoints.length}: ${this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar")}`, n = new ls(
      this.paraview,
      {
        text: e ?? r,
        x: this.x + this.width / 2,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {}
    );
    this.paraview.store.popups.push(n);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
}
class cx extends CV {
  get datapointViews() {
    return super.datapointViews;
  }
  get settings() {
    return super.settings;
  }
  settingDidChange(e, r, n) {
    ["chart.hasDirectLabels"].includes(e) && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  updateSeriesStyle(e) {
    super.updateSeriesStyle(e), e.strokeWidth = this.effectiveLineWidth;
  }
  get effectiveLineWidth() {
    return this.paraview.store.settings.ui.isLowVisionModeEnabled ? this.paraview.store.settings.type.line.lowVisionLineWidth : this.paraview.store.settings.type.line.lineWidth;
  }
  get effectiveVisitedScale() {
    return this.paraview.store.settings.ui.isLowVisionModeEnabled ? 1 : this.paraview.store.settings.type.line.lineHighlightScale;
  }
  get visitedStrokeWidth() {
    return this.effectiveLineWidth * this.effectiveVisitedScale;
  }
  _newDatapointView(e) {
    return new $9e(e);
  }
}
class $9e extends Lk {
  // get height() {
  //   // apparently this can get called before the shape is created
  //   return bboxOfBboxes(...this._shapes.map(shape => shape.bbox)).height ?? 0;
  // }
  // get left() {
  //   return this._shape!.left;
  // }
  // get right() {
  //   return this._shape!.right;
  // }
  // get top() {
  //   return this._shape!.top;
  // }
  // get bottom() {
  //   return this._shape!.bottom;
  // }
  get outerBbox() {
    const e = this._shapes.map((r) => r.outerBbox);
    return this._symbol ? Y4(...e, this._symbol.outerBbox) : Y4(...e);
  }
  completeLayout() {
    this.index && this._computePrev(), this.index < this.chart.paraview.store.model.series[0].length - 1 && this._computeNext(), this._computeCentroid(), super.completeLayout();
  }
  _createSymbol() {
    var n;
    let r = this.seriesProps.symbol;
    (n = this._symbol) == null || n.remove(), this._symbol = Fa.fromType(this.paraview, r), this.append(this._symbol);
  }
  _computePrev() {
    this._prevMidX = -this.width / 2, this._prevMidY = (this._prev.y - this.y) / 2;
  }
  _computeNext() {
    this._nextMidX = this.width / 2, this._nextMidY = (this._next.y - this.y) / 2;
  }
  _computeCentroid() {
    var s, o;
    const e = ((s = this._symbol) == null ? void 0 : s.width) ?? 0, r = ((o = this._symbol) == null ? void 0 : o.height) ?? 0;
    let n = "50%";
    this._prevMidX ? this._nextMidX || (n = `calc(100% - ${e / 2}px)`) : n = `${e / 2}px`;
    let i = "50%";
    if (!this._prevMidY && this._nextMidY)
      i = this._y > this._nextMidY ? `calc(100% - ${r / 2}px)` : `${r / 2}px`;
    else if (!this._nextMidY && this._prevMidY)
      i = this._y > this._prevMidY ? `calc(100% - ${r / 2}px)` : `${r / 2}px`;
    else if (this._nextMidY && this._prevMidY) {
      const a = this._y - r / 2, l = this._y + r / 2;
      l > this._nextMidY && l > this._prevMidY ? i = `calc(100% - ${r / 2}px)` : a < this._nextMidY && a < this._prevMidY ? i = `${r / 2}px` : i = `${this._y - Math.min(this._prevMidY, this._nextMidY)}px`;
    }
    this.centroid = `${n} ${i}`;
  }
  get _points() {
    return this._prevMidY !== void 0 && this._nextMidY !== void 0 ? [
      new Ye(this._prevMidX, this._prevMidY),
      new Ye(),
      new Ye(this._nextMidX, this._nextMidY)
    ] : this._prevMidY === void 0 && this._nextMidY !== void 0 ? [
      new Ye(),
      new Ye(this._nextMidX, this._nextMidY)
    ] : this._prevMidY !== void 0 && this._nextMidY === void 0 ? [
      new Ye(this._prevMidX, this._prevMidY),
      new Ye()
    ] : [
      new Ye()
    ];
  }
  get classInfo() {
    return {
      "data-line": !0,
      ...super.classInfo
    };
  }
  _shapeStyleInfo(e) {
    if (this.paraview.documentView.chartInfo.navMap.cursor.isNodeType("sequence")) {
      const r = this.paraview.documentView.chartInfo.navMap.cursor;
      if (this.index === r.options.start && this.index && !e || this.index === r.options.end - 1 && e)
        return {
          fill: this._parent.styleInfo.fill,
          stroke: this._parent.styleInfo.stroke,
          strokeWidth: this._parent.styleInfo.strokeWidth
        };
    }
    return super._shapeStyleInfo(e);
  }
  _createShapes() {
    this._shapes.forEach((s) => {
      s.remove();
    }), this._shapes = [];
    const e = this._points;
    let r = this.withCousins.map((s, o) => [s, o]).toSorted((s, o) => s[0].y - o[0].y), n = 0, i = 0;
    if (r.length === 1)
      n = 0, i = this.chart.height;
    else if (r[0][1] === this.parent.index)
      n = 0, i = (r[1][0].y - this.y) / 2 + this.y;
    else if (r[r.length - 1][1] === this.parent.index)
      n = (this.y - r[r.length - 2][0].y) / 2 + r[r.length - 2][0].y, i = this.chart.height - ((this.y - r[r.length - 2][0].y) / 2 + r[r.length - 2][0].y);
    else {
      let s = r.findIndex((o) => o[1] === this.parent.index);
      n = (this.y - r[s - 1][0].y) / 2 + r[s - 1][0].y, i = (r[s + 1][0].y - this.y) / 2 + this.y - ((this.y - r[s - 1][0].y) / 2 + r[s - 1][0].y);
    }
    if (e.length === 3) {
      const s = [e.slice(0, -1), e.slice(1)];
      this._shapes.push(
        new jo(this.paraview, {
          x: this._x,
          y: this._y,
          points: s[0],
          isClip: !0
        }),
        new jo(this.paraview, {
          x: this._x,
          y: this._y,
          points: s[1],
          isClip: !0
        })
      );
      let o = new nn(this.paraview, {
        x: this._x + s[0][0].x,
        y: n,
        width: s[1][1].x - s[0][0].x,
        height: i,
        stroke: "white",
        fill: "white",
        pointerEnter: (a) => {
          this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.addPopup();
        },
        pointerLeave: (a) => {
          this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.removePopup(this.id);
        }
      });
      this._shapes[0].classInfo = { "leg-left": !0 }, this._shapes[1].classInfo = { "leg-right": !0 }, o.classInfo = { invis: !0 }, this.append(o);
    } else if (e.length === 2) {
      this._shapes.push(
        new jo(this.paraview, {
          x: this._x,
          y: this._y,
          points: e,
          isClip: !0
        })
      );
      let s = new nn(this.paraview, {
        x: e[0].x == 0 ? this._x : this._x + e[0].x,
        y: n,
        width: e[0].x == 0 ? e[1].x : this.x,
        height: i,
        stroke: "white",
        fill: "white",
        pointerEnter: (o) => {
          this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.addPopup();
        },
        pointerLeave: (o) => {
          this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onHover" && !this.paraview.store.settings.ui.isNarrativeHighlightEnabled && this.removePopup(this.id);
        }
      });
      this._shapes[0].classInfo = this._prevMidY !== void 0 ? { "leg-left": !0 } : { "leg-right": !0 }, s.classInfo = { invis: !0 }, this.append(s);
    }
    this._shapes.forEach((s) => {
      s.isClip = this.shouldClip;
    }), super._createShapes();
  }
  addPopup(e) {
    let r = `${this.seriesKey} ${this.index + 1}/${this.series.datapoints.length}: ${this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar")}`, n = new ls(
      this.paraview,
      {
        text: e ?? r,
        x: this.x,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {}
    );
    this.paraview.store.popups.push(n);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1);
  }
}
class j9e extends kV {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this._arcType = "circle", this._startAngleOffset = -0.25, this._arc = 1, this._radiusDivisor = 2.3, this._centerLabel = null;
  }
  _addedToParent() {
    super._addedToParent(), this._resetRadius(), this._arcType === "semicircle" && (this._arc = 0.5, this._startAngleOffset = -0.25), this.paraview.store.settingControls.add({
      type: "checkbox",
      key: "chart.showPopups",
      label: "Show popups",
      parentView: "controlPanel.tabs.chart.popups"
    });
  }
  // get radius() {
  //   return this._radius;
  // }
  get settings() {
    return super.settings;
  }
  get cx() {
    return this._cx;
  }
  get cy() {
    return this._cy;
  }
  get arcType() {
    return this._arcType;
  }
  get startAngleOffset() {
    return this._startAngleOffset;
  }
  get radius() {
    return this._radius;
  }
  get datapointViews() {
    return super.datapointViews;
  }
  _completeDatapointLayout() {
    super._completeDatapointLayout(), this._createLabels();
  }
  _animStep(e) {
    super._animStep(e), this._createLabels();
  }
  init() {
    super.init(), this._resizeToFitLabels(), this.settings.centerLabel === "title" && (this.paraview.store.updateSettings((e) => {
      e.chart.title.isDrawTitle = !1;
    }), this._centerLabel = new fi(this.paraview, {
      text: this.paraview.store.title,
      centerX: this._cx,
      centerY: this._cy,
      textAnchor: "middle",
      wrapWidth: 2 * (this.radius - this.settings.annularThickness * this.radius) - this.settings.centerLabelPadding * 2,
      id: "chart-title",
      classList: ["chart-title"]
    }), this.append(this._centerLabel));
  }
  settingDidChange(e, r, n) {
    ["color.colorPalette", "color.colorVisionMode"].includes(e) && (n === "pattern" || n !== "pattern" && r === "pattern" || this.paraview.store.settings.color.colorPalette === "pattern") && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), ["explode", "orientationAngleOffset", "insideLabels.contents", "outsideLabels.contents"].map((s) => `type.${this.paraview.store.type}.${s}`).includes(e) && (this._resetRadius(), this._chartLandingView.clearChildren(), this._layoutDatapoints(), this._resizeToFitLabels(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  _resetRadius() {
    this._radius = Math.min(this._height, this._width) / 2, this._cx = this._width / 2, this._cy = this._height / 2;
  }
  _resizeToFitLabels() {
    for (; ; ) {
      const e = this.datapointViews.map((a) => a.outsideLabel).filter((a) => a);
      if (!e.length) return;
      let r = 1;
      const n = Math.min(...e.map((a) => a.paddedLeft));
      if (n < 0) {
        const a = this.datapointViews.find((h) => {
          var d;
          return ((d = h.outsideLabel) == null ? void 0 : d.paddedLeft) === n;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.x), p = Math.max((c + n) / c, 0.5);
        p < r && (r = p);
      }
      const i = Math.max(...e.map((a) => a.paddedRight));
      if (i > this._width) {
        const a = this.datapointViews.find((h) => {
          var d;
          return ((d = h.outsideLabel) == null ? void 0 : d.paddedRight) === i;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.x), p = Math.max((c - (i - this._width)) / c, 0.5);
        p < r && (r = p);
      }
      const s = Math.min(...e.map((a) => a.paddedTop));
      if (s < 0) {
        const a = this.datapointViews.find((h) => {
          var d;
          return ((d = h.outsideLabel) == null ? void 0 : d.paddedTop) === s;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.y), p = Math.max((c + s) / c, 0.5);
        p < r && (r = p);
      }
      const o = Math.max(...e.map((a) => a.paddedBottom));
      if (o > this._height) {
        const a = this.datapointViews.find((h) => {
          var d;
          return ((d = h.outsideLabel) == null ? void 0 : d.paddedBottom) === o;
        }), l = a.shapes[0].arcCenter.subtract(a.shapes[0].loc), c = Math.abs(l.y), p = Math.max((c - (o - this._height)) / c, 0.5);
        p < r && (r = p);
      }
      if (Math.round(r * 100) < 100)
        this._radius *= r, this._chartLandingView.clearChildren(), this._layoutDatapoints();
      else
        break;
    }
  }
  _createDatapoints() {
    const e = this.paraview.store.model.series[0].datapoints.map(
      (o) => Wr(o.facetBox("x"), this.paraview.store.getFormatType("pieSliceLabel"))
    ), r = this.paraview.store.model.series[0].datapoints.map((o) => o.facetValueNumericized("y")), n = r.reduce((o, a) => o + a, 0), i = new Ak(this, this.paraview.store.model.seriesKeys[0], !1);
    this._chartLandingView.append(i);
    let s = 0;
    for (const [o, a] of Wn(e)) {
      const l = r.at(a), c = this._arc * l / n, p = this._createSlice(i, {
        value: l,
        category: o,
        seriesIdx: a,
        percentage: c,
        accum: s,
        numDatapoints: e.length
      });
      i.append(p), s += c;
    }
  }
  _createLabels() {
    const e = this.paraview.store.model.series[0].datapoints.map(
      (n) => Wr(n.facetBox("x"), this.paraview.store.getFormatType("pieSliceLabel"))
    );
    this.paraview.store.model.series[0].datapoints.map(
      (n) => Wr(n.facetBox("y"), this.paraview.store.getFormatType("pieSliceLabel"))
    );
    for (const [n, i] of Wn(e)) {
      const s = this._chartLandingView.children[0].children[i];
      this.settings.outsideLabels.contents && s.createOutsidelabel(), this.settings.insideLabels.contents && s.createInsideLabel();
    }
    this.datapointViews.map((n) => n.outsideLabel).filter((n) => n).length && this._resolveOutsideLabelCollisions();
  }
  _resolveOutsideLabelCollisions() {
    const e = this.datapointViews.filter((r) => r.outsideLabel);
    e.sort((r, n) => n.outsideLabel.y - r.outsideLabel.y), e.slice(1).forEach((r, n) => {
      if (r.outsideLabel.intersects(e[n].outsideLabel)) {
        const i = r.outsideLabel.y;
        r.outsideLabel.bottom = e[n].outsideLabel.top - this.settings.outsideLabels.vertGap;
        const s = r.outsideLabel.y - i;
        r.adjustLeader(s);
      }
    });
  }
  focusRingShape() {
    const r = this._parent.docView.chartInfo.navMap.cursor;
    return r.isNodeType("datapoint") ? this.datapointView(r.options.seriesKey, r.options.index).focusRingShape() : null;
  }
}
class B9e extends hf {
  constructor(e, r) {
    super(e), this._params = r, this._outsideLabel = null, this._insideLabel = null, this._leader = null, this._focusRingShape = null, this._centralAngle = 0, this._isStyleEnabled = !0;
  }
  get percentage() {
    return this._params.percentage;
  }
  get outsideLabel() {
    return this._outsideLabel;
  }
  get insideLabel() {
    return this._insideLabel;
  }
  get shapes() {
    return this._shapes;
  }
  get role() {
    return "graphics-symbol";
  }
  get roleDescription() {
    return "datapoint";
  }
  get classInfo() {
    return {
      ...super.classInfo,
      "pastry-slice": !0
      // bad workaround for the problem that, when a visited datapoint is recreated,
      // the store data cursor now has a ref to the old instance
      // visited: this.paraview.store.isVisited(this.seriesKey, this.index),
      // selected: this.paraview.store.isSelected(this.seriesKey, this.index)
    };
  }
  get styleInfo() {
    const e = super.styleInfo;
    return delete e.strokeWidth, delete e.stroke, e;
  }
  get x() {
    return super.x;
  }
  set x(e) {
    this._outsideLabel && (this._outsideLabel.x += e - this._x), this._insideLabel && (this._insideLabel.x += e - this._x), this._leader && (this._leader.x += e - this._x), super.x = e;
  }
  get y() {
    return super.y;
  }
  set y(e) {
    this._outsideLabel && (this._outsideLabel.y += e - this._y), this._insideLabel && (this._insideLabel.y += e - this._y), this._leader && (this._leader.y += e - this._y), super.y = e;
  }
  _createSymbol() {
  }
  get isPositionRight() {
    return this.shapes[0].arcCenter.x > this.chart.cx;
  }
  get isPositionBottom() {
    return this.shapes[0].arcCenter.y > this.chart.cy;
  }
  _createShapes() {
    const e = this._shapes[0].clone(), r = this.paraview.store.settings.ui.focusRingGap, n = e.centralAngle;
    if (e.centralAngle += 2 * r * 360 / (2 * Math.PI * e.r), e.orientationAngle -= (e.centralAngle - n) / 2, e.annularThickness < 1) {
      e.r += r;
      const i = e.annularThickness * e.r;
      e.annularThickness = (i + 2 * r) / (e.r + r);
    } else
      e.scale = (e.r + r) / e.r;
    this._focusRingShape = e, super._createShapes();
  }
  _labelContents(e) {
    return e.split(/:/).map((i) => {
      let s = !1;
      i[0] === "(" && i.at(-1) === ")" && (s = !0, i = i.slice(1, -1));
      let o = "";
      if (i === "series")
        o = this.seriesKey;
      else if (i === "category")
        o = this._params.category;
      else if (i === "percentage")
        o = `${Math.round(this._params.percentage * 100)}%`;
      else if (i === "value")
        o = `${this._params.value}`;
      else
        throw new Error(`invalid radial label content field '${i}'`);
      return s ? `(${o})` : o;
    }).join(" ");
  }
  createOutsidelabel(e = "") {
    var c, p;
    const r = this.shapes[0], n = r.orientationVector.multiplyScalar(
      this.chart.settings.outsideLabels.arcGap
    );
    let i = "end", s = "topLeft", o = 0, a = 0;
    const l = r.arcCenter.add(n);
    this.isPositionRight ? (l.x += this.chart.settings.outsideLabels.horizShift, o = this.chart.settings.outsideLabels.horizPadding, i = "start") : (l.x -= this.chart.settings.outsideLabels.horizShift, a = this.chart.settings.outsideLabels.horizPadding), this.isPositionBottom ? s = i === "start" ? "topLeft" : "topRight" : s = i === "start" ? "bottomLeft" : "bottomRight", (c = this._outsideLabel) == null || c.remove(), this._outsideLabel = new fi(this.paraview, {
      text: this._labelContents(e || this.chart.settings.outsideLabels.contents),
      id: this.id + "-rlb",
      classList: ["pastry-outside-label"],
      role: "datapoint",
      [s]: l,
      textAnchor: i
    }), this._outsideLabel.padding = { left: o, right: a }, (p = this._leader) == null || p.remove(), this._leader = this._createOutsideLabelLeader(), this.append(this._leader), this.append(this._outsideLabel);
  }
  _createOutsideLabelLeader() {
    const e = new Ye(
      this.isPositionRight ? this._outsideLabel.paddedLeft : this._outsideLabel.paddedRight,
      this.chart.settings.outsideLabels.leaderStyle === "direct" ? this._outsideLabel.centerY : this._outsideLabel.bottom
    ).addY(
      this.chart.settings.outsideLabels.leaderStyle === "underline" ? this.chart.settings.outsideLabels.underlineGap : 0
    ), r = this.chart.settings.outsideLabels.leaderStyle === "direct" ? this.chart.settings.outsideLabels.horizPadding : this._outsideLabel.paddedWidth, n = new jo(this.paraview, {
      points: [this.shapes[0].arcCenter, e, e.x > this._outsideLabel.centerX ? e.subtractX(r) : e.addX(r)],
      stroke: this.paraview.store.colors.colorValueAt(this.color)
    });
    return n.classInfo = { "pastry-outside-label-leader": !0 }, n;
  }
  adjustLeader(e) {
    this._leader.points = [
      this._leader.points[0],
      this._leader.points[1].addY(e),
      this._leader.points[2].addY(e)
    ];
  }
  createInsideLabel() {
    var n;
    const e = this.shapes[0];
    let r = "topLeft";
    if (this.isPositionBottom ? r = this.isPositionRight ? "topLeft" : "topRight" : r = this.isPositionRight ? "bottomLeft" : "bottomRight", (n = this._insideLabel) == null || n.remove(), this._insideLabel = new fi(this.paraview, {
      text: this._labelContents(this.chart.settings.insideLabels.contents),
      id: this.id + "-ilb",
      classList: ["pastry-inside-label"],
      role: "datapoint",
      [a8e(r)]: e.loc.add(
        e.orientationVector.multiplyScalar(
          this.chart.radius * this.chart.settings.insideLabels.position
        )
      )
    }), Object.values(this._insideLabel.textCorners).every((i) => e.containsPoint(i)))
      this._insideLabel.styleInfo = {
        fill: this.paraview.store.colors.contrastValueAt(this.color)
      }, this.append(this._insideLabel);
    else {
      if (this._outsideLabel) {
        this._outsideLabel.text += `
${this._insideLabel.text}`;
        const i = this._leader;
        this._leader = this._createOutsideLabelLeader(), this.replaceChild(i, this._leader);
      } else
        this.createOutsidelabel(
          this.chart.settings.insideLabels.contents + (this.chart.settings.outsideLabels.contents ? ":" + this.chart.settings.outsideLabels.contents : "")
        );
      this._insideLabel = null;
    }
  }
  focusRingShape() {
    return this._focusRingShape;
  }
}
class eO extends j9e {
  _createSlice(e, r) {
    return new F9e(e, r);
  }
}
class F9e extends B9e {
  constructor(e, r) {
    super(e, r), this.log = qt("PieSlice"), this._x = this.chart.cx, this._y = this.chart.cy;
  }
  get width() {
    return 0;
  }
  get height() {
    return 0;
  }
  computeLocation() {
    this.paraview.store.settings.animation.isAnimationEnabled ? this._centralAngle = this.chart.animateRevealComplete ? this._params.percentage * 360 : 0 : this._centralAngle = this._params.percentage * 360;
  }
  beginAnimStep(e) {
    this._centralAngle = this._params.percentage * 360 * e, super.beginAnimStep(e);
  }
  _createShapes() {
    const e = this.paraview.store.colors.palette.isPattern;
    this._shapes.forEach((i) => {
      i.remove();
    }), this._shapes = [];
    const r = new C2(this.paraview, {
      x: this._x,
      y: this._y,
      r: this.chart.radius,
      centralAngle: this._centralAngle,
      orientationAngle: this._params.accum * 360,
      orientationAngleOffset: this.chart.settings.orientationAngleOffset,
      annularThickness: this.chart.settings.annularThickness,
      isPattern: !!e,
      pointerEnter: (i) => {
        this.paraview.store.settings.chart.showPopups && this.addPopup();
      },
      pointerLeave: (i) => {
        this.paraview.store.settings.chart.showPopups && this.removePopup(this.id);
      }
    });
    this._shapes.push(r), this.chart.settings.explode.split(":").map((i) => parseInt(i)).includes(this.index) && (r.loc = r.loc.add(r.orientationVector.multiplyScalar(this.chart.settings.explodeDistance))), super._createShapes();
  }
  // protected _computeLabelOptions() {
  //   const r = this.chart.radius.outer;
  //   const sector = (this._children[0] as Sector);
  //   const centerAngle = sector.options.orientationAngle + sector.options.centralAngle/2;
  //   let className = 'radial_label';
  //   // if (centerAngle >= 0.05 && centerAngle <= 0.45) {
  //   //   className = 'radial_label_right';
  //   // } else if (centerAngle >= 0.55 && centerAngle <= 0.95) {
  //   //   className = 'radial_label_left';
  //   // }
  //   // this.log.info('LABEL OPTS', r, centerAngle, this.chart.cx, this.chart.cy, this._radians);
  //   return {
  //     x: this.chart.cx + r*Math.cos(centerAngle*Math.PI/180),
  //     y: this.chart.cy + r*Math.sin(centerAngle*Math.PI/180),
  //     className
  //   };
  // }
  get selectedMarker() {
    return new C2(this.paraview, {
      x: this._x,
      y: this._y,
      r: this.chart.radius,
      centralAngle: this._params.percentage * 360,
      orientationAngle: this._params.accum * 360,
      orientationAngleOffset: this.chart.settings.orientationAngleOffset,
      annularThickness: this.chart.settings.annularThickness,
      fill: "none",
      stroke: "black",
      strokeWidth: 2
    });
  }
  addPopup(e) {
    if (this.paraview.store.popups.some((a) => a.id == this.id))
      return;
    let r = 2 * Math.PI - (this._params.accum * 2 * Math.PI + this._params.percentage * Math.PI - this.chart.settings.orientationAngleOffset * 2 * Math.PI / 360), n = this.x + this.chart.radius * (1 - this.chart.settings.annularThickness / 2) * Math.cos(r), i = this.y - this.chart.radius * (1 - this.chart.settings.annularThickness / 2) * Math.sin(r), s = `${this.seriesKey} ${this.index + 1}/${this.series.datapoints.length}: ${this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar")}`, o = new ls(
      this.paraview,
      {
        text: e ?? s,
        x: n,
        y: i,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {
        shape: "boxWithArrow",
        fill: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(this.color), 6) : this.paraview.store.colors.colorValueAt(this.color),
        stroke: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(this.color) : "black"
      }
    );
    this.paraview.store.popups.push(o);
  }
  removePopup(e) {
    let r = this.paraview.pointerEventManager.coords, n = r.x - this.paraview.documentView.padding.left - this.paraview.documentView.chartLayers.x, i = r.y - this.paraview.documentView.padding.top - this.paraview.documentView.chartLayers.y, s = this.paraview.store.popups.find((o) => o.id === e);
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((o) => o.id === e), 1), s && (n <= s.box.right && n >= s.box.left && i >= s.box.top && i <= s.box.bottom || this.paraview.requestUpdate());
  }
}
class z9e extends CV {
  constructor() {
    super(...arguments), this._clusterShellView = null;
  }
  get settings() {
    return super.settings;
  }
  get chartInfo() {
    return this._chartInfo;
  }
  get datapointViews() {
    return super.datapointViews;
  }
  settingDidChange(e, r, n) {
    ["type.scatter.isShowOutliers"].includes(e) && this.updateOutliers(), super.settingDidChange(e, r, n);
  }
  _newDatapointView(e) {
    return new U9e(e);
  }
  _createDatapoints() {
    for (const [r, n] of Wn(this.paraview.store.model.series)) {
      const i = this._newSeriesView(r.key);
      this._chartLandingView.append(i);
      for (const [s, o] of Wn(r)) {
        const a = this._newDatapointView(i);
        i.append(a);
      }
    }
    const e = this.datapointViews;
    for (const r of this._chartInfo.clustering) {
      for (const n of r.dataPointIDs)
        e[n].clusterID = r.id;
      for (const n of r.outlierIDs)
        e[n].clusterID = r.id, e[n].isOutlier = !0;
    }
    this.datapointViewsStatic = super.datapointViews;
  }
  _beginDatapointLayout() {
    super._beginDatapointLayout();
    for (let r of this.children)
      r instanceof tO && r.remove();
    let e = new tO(this);
    this.append(e);
  }
  updateOutliers() {
    for (let e of this.datapointViews)
      e.isOutlier && e.completeLayout();
  }
  content(...e) {
    var n;
    const r = this.parent.docView.chartInfo;
    return r.clustering && ((n = this._clusterShellView) == null || n.remove(), r.currentCluster !== -1 && (this._clusterShellView = new V9e(this, r.currentCluster), this.append(this._clusterShellView))), super.content(...e);
  }
}
class U9e extends Lk {
  constructor() {
    super(...arguments), this.isOutlier = !1;
  }
  computeX() {
    const e = this.chart.chartInfo.axisInfo, r = (this.datapoint.facetValueNumericized("x") - e.xLabelInfo.min) / e.xLabelInfo.range;
    return this.chart.parent.width * r;
  }
  get width() {
    var e;
    return (e = this._symbol) != null && e.width ? 2 * 1.5 * this._symbol.width : 36;
  }
  _createShape() {
  }
  get _symbolColor() {
    return this.symbolColor === void 0 && (this.symbolColor = this.seriesProps.color), this.paraview.store.isVisited(this.seriesKey, this.index) ? -1 : this.symbolColor;
  }
  _createSymbol() {
    const e = this.seriesProps;
    let r = e.symbol, n = e.color;
    const i = new XU().types;
    this.chart.chartInfo.clustering && (this.clusterID !== void 0 ? (n = Number(this.clusterID), r = i[n % i.length]) : r = i[8], this.paraview.store.settings.type.scatter.isShowOutliers && this.isOutlier && (n = 0, r = i[8])), this._symbol = Fa.fromType(this.paraview, r, {
      strokeWidth: this.paraview.store.settings.chart.symbolStrokeWidth,
      lighten: !0,
      pointerEnter: (s) => {
        this.paraview.store.settings.chart.showPopups && this.addPopup();
      },
      pointerLeave: (s) => {
        this.paraview.store.settings.chart.showPopups && this.removePopup(this.id);
      }
    }), this._symbol.role = "datapoint", this._symbol.id = `${this._id}-sym`, this.symbolColor = n, this._children = this.children.filter((s) => !(s instanceof Fa)), this.append(this._symbol);
  }
  get classInfo() {
    return {
      [`cluster-${this.clusterID}`]: this.clusterID !== void 0,
      ...super.classInfo
    };
  }
  get color() {
    return this.chart.chartInfo.clustering ? this.clusterID : super.color;
  }
  addPopup() {
    let e = new ls(
      this.paraview,
      {
        text: this.chart.chartInfo.summarizer.getDatapointSummary(this.datapoint, "statusBar"),
        x: this.x,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: this.color,
        points: [this]
      },
      {
        shape: "boxWithArrow",
        fill: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 100%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.lighten(this.paraview.store.colors.colorValueAt(this.color), 6) : this.paraview.store.colors.colorValueAt(this.color),
        stroke: this.paraview.store.settings.ui.isLowVisionModeEnabled ? "hsl(0, 0%, 0%)" : this.paraview.store.settings.popup.backgroundColor === "light" ? this.paraview.store.colors.colorValueAt(this.color) : "black"
      }
    );
    this.paraview.store.popups.push(e);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
}
class tO extends L9e {
  render() {
    return this.paraview.store.settings.type.scatter.isDrawTrendLine ? Tt`
    <line x1=${this.x1} x2=${this.x2} y1=${this.y1} y2=${this.y2} style="stroke:red;stroke-width:3"/>
    ` : Tt``;
  }
}
class V9e extends Pr {
  constructor(e, r, n) {
    super(e.paraview), this.chart = e, this.clusterID = r, this.selectedPoints = n, this._points = [], this.generatePoints();
  }
  _createId(...e) {
    return "";
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  generatePoints() {
    if (this.selectedPoints !== void 0) {
      let e = [];
      for (let r of this.selectedPoints)
        e.push([r.x, r.y]);
      this._points = e;
    } else if (this.clusterID !== void 0) {
      const e = this.chart.datapointViewsStatic, i = this.chart.parent.docView.chartInfo.clustering[this.clusterID].hullIDs, s = [];
      for (const o of i)
        s.push([e[o].x, e[o].y]);
      this._points = s;
    } else
      this._points = [];
  }
  get points() {
    return this._points;
  }
  get pointsString() {
    let e = "";
    for (const r of this.points)
      e = e.concat(nt`${r[0]},${r[1]} `);
    return e;
  }
  get centroid() {
    const e = [0, 0];
    for (const r of this.points)
      e[0] += r[0] / this.points.length, e[1] += r[1] / this.points.length;
    return e;
  }
  get color() {
    return this.clusterID !== void 0 ? this.clusterID : 0;
  }
  render() {
    let e = new ZU(this.paraview.store);
    return Tt`<g>
      <polygon points=${this.pointsString} style="stroke:black; fill:none; stroke-width:2"/>
      <circle
        cx=${nt`${this.centroid[0]}`}
        cy=${nt`${this.centroid[1]}`} r="8"
        style=stroke:black;fill:${e.colorValueAt(this.color)}
      />
    </g>`;
  }
}
class H9e extends Xb {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this.log = qt("HeatMapPlotView"), this._settings = this.paraview.store.settings.type.heatmap;
  }
  settingDidChange(e, r, n) {
    e === "type.heatmap.resolution" && (this.paraview.createDocumentView(), this.paraview.requestUpdate()), super.settingDidChange(e, r, n);
  }
  get settings() {
    return this._settings;
  }
  get chartInfo() {
    return this._chartInfo;
  }
  _newDatapointView(e) {
    return new rO(this, e);
  }
  _createDatapoints() {
    this.log.info("CREATING DATAPOINTS");
    const e = [];
    for (const [r, n] of Wn(this.paraview.store.model.allFacetValues("x")))
      e.push(Wr(r, this.paraview.store.getFormatType(`${this.parent.docView.type}Point`))), Yn(e.at(-1));
    for (const [r, n] of Wn(this.paraview.store.model.series)) {
      const i = new ew(this, r.key);
      this._chartLandingView.append(i);
      for (let s = 0; s < this._chartInfo.resolution ** 2; s++) {
        const o = new rO(this, i);
        i.append(o);
      }
    }
    this._chartLandingView.sortChildren((r, n) => n.children[0].datapoint.facetValueNumericized(n.children[0].datapoint.depKey) - r.children[0].datapoint.facetValueNumericized(r.children[0].datapoint.depKey));
  }
  // protected _layoutDatapoints() {
  //   for (const datapointView of this.datapointViews) {
  //     datapointView.completeLayout();
  //   }
  // }
  seriesRef(e) {
    return this.paraview.ref(`series.${e}`);
  }
  _raiseSeries(e) {
    const r = this.seriesRef(e).value;
    this.dataset.append(r);
  }
  getTickX(e) {
    return this.datapointViews[e].x;
  }
}
class rO extends hf {
  constructor(e, r) {
    super(r), this._count = 0;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get count() {
    return this._count;
  }
  get fillColor() {
    let e = "hsl(0, 0%, 0%)";
    return this._count > 0 && (e = `hsl(0, 0%, ${85 * this._count / this.chart.chartInfo.maxCount + 15}%)`), e;
  }
  get _selectedMarkerX() {
    return this._x;
  }
  get _selectedMarkerY() {
    return this._y;
  }
  get selectedMarker() {
    return new nn(this.paraview, {
      width: this._width + 4,
      height: this._height + 4,
      x: this._x - 2,
      y: this._y - 2,
      fill: "none",
      stroke: "red",
      strokeWidth: 5
    });
  }
  _createId(...e) {
    return [
      "datapoint",
      Yn(this.series.key),
      //facets,
      `${this.index}`
    ].join("-");
  }
  completeLayout() {
    const e = this.chart.chartInfo;
    this._height = this.chart.parent.height / e.resolution, this._width = this.chart.parent.width / e.resolution, this._x = this.index % e.resolution * this._width, this._y = Math.floor(this.index / e.resolution) * this._height;
    const r = this.index;
    this._count = e.grid[r % e.resolution][Math.floor(r / e.resolution)], this.id = [
      "datapoint",
      Yn(this.seriesKey),
      nt`${this._x}`,
      nt`${this._y}`
    ].join("-"), super.completeLayout();
  }
  _createSymbol() {
  }
  _contentUpdateShapes() {
  }
  layoutSymbol() {
  }
  _createShapes() {
    const e = new G9e(this.paraview, {
      x: this._x,
      y: this._y,
      width: this._width,
      height: this._height,
      fill: this.fillColor,
      stroke: this.fillColor
    });
    this._shapes.push(e), super._createShapes();
  }
}
class G9e extends nn {
  get count() {
    return this.parent.count;
  }
  get chart() {
    return this.parent.chart;
  }
  get fillColor() {
    return this.parent.fillColor;
  }
  get parentIndex() {
    return this.parent.index;
  }
  render() {
    return this._styleInfo.stroke = this.paraview.store.visitedDatapoints.values().some((e) => e === this.parent.datapointId) ? "hsl(0, 100.00%, 50.00%)" : this.options.stroke ?? this._options.stroke, Tt`
        <rect
          ${this._ref ? yt(this._ref) : void 0}
          id=${this._id || Ne}
          style=${Object.keys(this._styleInfo).length ? mn(this._styleInfo) : Ne}
          class=${Object.keys(this._classInfo).length ? Br(this._classInfo) : Ne}
          role=${this._role || Ne}
          x=${nt`${this._x}`}
          y=${nt`${this._y}`}
          width=${nt`${this.width}`}
          height=${nt`${this.height}`}
          fill= '${this.fillColor}'

          clip-path=${this._options.isClip ? "url(#clip-path)" : Ne}
        ></rect>
      `;
  }
}
class W9e extends Xb {
  settingDidChange(e, r, n) {
    ["type.histogram.groupingAxis", "type.histogram.displayAxis", "type.histogram.relativeAxes", "axis.y.maxValue", "axis.y.minValue"].includes(e) ? (this.paraview.createDocumentView(), this.paraview.requestUpdate()) : e === "type.histogram.bins" && (this.paraview.createDocumentView(), this.paraview.requestUpdate(), this.paraview.store.updateSettings((i) => {
      i.axis.y.maxValue = "unset";
    }), this.paraview.store.updateSettings((i) => {
      i.axis.y.minValue = "unset";
    })), super.settingDidChange(e, r, n);
  }
  get chartInfo() {
    return this._chartInfo;
  }
  get datapointViews() {
    return super.datapointViews;
  }
  get settings() {
    return this._settings;
  }
  _newDatapointView(e) {
    return new nO(this, e);
  }
  _createDatapoints() {
    const e = [];
    for (const [n, i] of Wn(this.paraview.store.model.series[0].datapoints))
      e.push(Wr(n.facetBox("x"), this.paraview.store.getFormatType(`${this.parent.docView.type}Point`))), Yn(e.at(-1));
    const r = new ew(this, this.paraview.store.model.series[0].key);
    this._chartLandingView.append(r);
    for (let n = 0; n < this.chartInfo.bins; n++) {
      const i = new nO(this, r);
      r.append(i);
    }
    this._chartLandingView.sortChildren((n, i) => i.children[0].datapoint.facetValueNumericized(i.children[0].datapoint.depKey) - n.children[0].datapoint.facetValueNumericized(n.children[0].datapoint.depKey));
  }
  _layoutDatapoints() {
    for (const e of this.datapointViews)
      e.completeLayout();
  }
  seriesRef(e) {
    return this.paraview.ref(`series.${e}`);
  }
  _raiseSeries(e) {
    const r = this.seriesRef(e).value;
    this.dataset.append(r);
  }
  getTickX(e) {
    return this.datapointViews[e].x;
  }
}
class nO extends hf {
  constructor(e, r) {
    super(r), this._count = 0;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get count() {
    return this._count;
  }
  get _selectedMarkerX() {
    return this._x;
  }
  get _selectedMarkerY() {
    return this._y;
  }
  get selectedMarker() {
    return new nn(this.paraview, {
      width: this._width,
      height: this._height,
      x: this._x,
      y: this._y - this._height,
      fill: "none",
      stroke: "black",
      strokeWidth: 4
    });
  }
  // protected get visitedTransform() {
  //   return 'scaleX(1.15)';
  // }
  computeLocation() {
  }
  layoutSymbol() {
  }
  /*
     completeLayout() {
    //super.completeLayout();
  }
    */
  completeLayout() {
    const e = this.chart.chartInfo;
    if (this.chart.settings.displayAxis == "x" || this.chart.settings.displayAxis == null) {
      const r = this.index;
      this._y = this.chart.parent.height, this._width = this.chart.parent.width / e.bins, this._x = this.index % e.bins * this._width, this._height = (e.grid[r] - e.axisInfo.yLabelInfo.min) / e.axisInfo.yLabelInfo.max * this._y, this.chart.settings.relativeAxes == "Percentage" && (this._height = this._height / e.grid.reduce((n, i) => n + i)), this._count = e.grid[r], this._id = [
        "datapoint-tile",
        Yn(this.seriesKey),
        `${this._x}`,
        `${this._y}`
      ].join("-");
    } else {
      const r = this.index - length;
      this._x = 0, this._height = this.chart.parent.height / e.bins, this._y = (e.grid.length - r - 1) % e.bins * this._height + this._height, this._width = (e.grid[r] - e.axisInfo.xLabelInfo.min) / e.axisInfo.xLabelInfo.max * this.chart.parent.width, this.chart.settings.relativeAxes == "Percentage" && (this._width = this._width / e.grid.reduce((n, i) => n + i)), this._count = e.grid[r], this._id = [
        "datapoint-tile",
        Yn(this.seriesKey),
        `${this._x}`,
        `${this._y}`
      ].join("-");
    }
  }
  summary() {
    const e = this.paraview.store.model.series.flat()[0].length, r = this.chart.chartInfo.axisInfo.xLabelInfo, n = r.range / this.chart.chartInfo.bins, i = (r.min + n * (this.index % this.chart.chartInfo.bins)).toFixed(2), s = (r.min + n * (this.index % this.chart.chartInfo.bins + 1)).toFixed(2);
    return `This bin contains ${this.count} datapoints, which is ${(100 * this.count / e).toFixed(2)}% of the overall data.
        It spans x values from ${i} to ${s}}`;
  }
  //Note: I'm overriding this for now because at the time of writing JIM doesn't support visualizations with a
  //different number of visible datapoints (treating bins as datapoints in this case) than exist in the dataset
  _createId(...e) {
    return `datapoint-${this.index}`;
  }
  get _d() {
    return nt`
          M${this._x},${this._y}
          v${-1 * this._height}
          h${this._width}
          v${this._height}
          Z`;
  }
  render() {
    let e = "hsl(0, 0%, 0%)", r = this.paraview.store.colors.colorValueAt(0);
    return this.paraview.store.visitedDatapoints.values().some((n) => on(n).index === this.index) ? this.chart.settings.displayAxis == "x" || this.chart.settings.displayAxis == null ? Tt`
                    <g>
                        <path
                            d='${this._d}'
                            role="datapoint"
                            stroke-width= '2'
                            fill= '${"hsl(0, 100.00%, 50.00%)"}'
                            stroke= '${e}'
                            id= '${this.id}'
                        ></path>
                        <line x1=${this._x} y1=${this._y} x2=${this._x + this._width} y2=${this._y} stroke="hsl(0, 100.00%, 50.00%)" stroke-width= 2 />
                    </g>
                ` : Tt`
                    <g>
                        <path
                            d='${this._d}'
                            role="datapoint"
                            stroke-width= '2'
                            fill= '${"hsl(0, 100.00%, 50.00%)"}'
                            stroke= '${e}'
                            id= '${this.id}'
                        ></path>
                        <line x1=${this._x} y1=${this._y} x2=${this._x} y2=${this._y - this._height} stroke="hsl(0, 100.00%, 50.00%)" stroke-width= 2 />
                    </g>
                ` : Tt`
                    <path
                        d='${this._d}'
                        role="datapoint"
                        stroke-width= '2'
                        fill= '${r}'
                        stroke= '${e}'
                        id= '${this.id}'
                    ></path>
            `;
  }
}
class iO extends pf {
  constructor(e, r, n, i) {
    super(e, r, n), this.type = i;
  }
  _createId() {
    return super._createId(`${this.type}-highlights`);
  }
  content() {
    var o;
    const e = this.paraview.store.highlightedSelector;
    let r = null, n = [], i = null, s = [];
    return e && (s = this.paraview.documentView.chartInfo.datapointsForSelector(e).map((l) => this._parent.dataLayer.datapointView(l.seriesKey, l.datapointIndex)), e.startsWith("datapoint") ? (n.push(s[0].symbol.clone()), this.paraview.store.settings.chart.showPopups && this.type == "foreground" && s[0].addPopup()) : e.startsWith("sequence") && (n.push(s[0].symbol.clone()), n.push(s.at(-1).symbol.clone()), i = new jo(this.paraview, {
      x: 0,
      y: 0,
      points: [n[0].loc, n[1].loc],
      stroke: this.paraview.store.colors.colorValueAt(n[0].color),
      opacity: 0.5,
      strokeWidth: 20
    }), this.type === "background" && (r = new nn(this.paraview, {
      x: n[0].x,
      y: 0,
      width: n[1].x - n[0].x,
      height: this._height,
      fill: this.paraview.store.colors.colorValueAt(n[0].color),
      opacity: 0.25
    })), this.paraview.store.settings.chart.showPopups && this.type == "foreground" && this.paraview.store.popups.push(...this.parent.popupLayer.addSequencePopups(s))), n.forEach((l) => {
      l.scale *= 3, l.opacity = 0.5, l.fill = "empty";
    }), (o = this.paraview.documentView) == null || o.chartLayers.popupLayer.addPopups()), Tt`
      ${this.paraview.store.visitedDatapoints.values().map((a) => {
      const { seriesKey: l, index: c } = on(a);
      return Tt`
            <use
              id="visited-mark-${l}-${c}"
              class="visited-mark"
              href="#${this._parent.dataLayer.datapointDomIds.get(a)}"
            />
          `;
    })}
      ${this.type === "background" && r ? r.render() : ""}
      ${/*overlaySym
            ?
                svg`
                  <use
                    id="highlighted-mark-${datapointViews[0].seriesKey}-${datapointViews[0].index}"
                    class="highlighted-mark"
                    href="#${datapointViews[0].id}-sym"
                  />
                `
    
            : ''*/
    this.type === "foreground" && i ? i.render() : ""}
      ${this.type === "foreground" && n.length ? n.map((a) => a.render()) : ""}
    `;
  }
}
class q9e extends pf {
  _createId() {
    return super._createId("selection");
  }
  get class() {
    return "selected-datapoint-marker";
  }
  content() {
    const e = this._parent.dataLayer;
    return Tt`
      ${this.paraview.store.selectedDatapoints.values().map((r) => e.datapointViewForId(e.datapointDomIds.get(r)).selectedMarker.render())}
    `;
  }
}
const bp = 4, sO = 2;
class Q9e extends vo(Pr) {
  constructor(e, r) {
    super(e);
    const n = e.store.settings.ui.focusRingGap;
    let i = r.focusRingShape();
    if (i) {
      i.remove(), i.stroke = "white", i.strokeWidth = bp, i.fill = "none", this.append(i);
      const s = i.clone();
      s.stroke = "black", s.strokeWidth = sO, s.fill = "none", this.append(s);
    } else {
      const s = r.focusRingBbox() ?? r.outerBbox, o = s.left - bp / 2 - n, a = s.top - bp / 2 - n, l = s.width + bp + n * 2, c = s.height + bp + n * 2;
      this.append(new nn(e, {
        x: o,
        y: a,
        width: l,
        height: c,
        stroke: "white",
        strokeWidth: bp,
        fill: "none"
      })), this.append(new nn(e, {
        x: o,
        y: a,
        width: l,
        height: c,
        stroke: "black",
        strokeWidth: sO,
        fill: "none"
      }));
    }
  }
}
class K9e extends pf {
  _createId() {
    return super._createId("focus");
  }
  content() {
    const e = this._parent.dataLayer.focusLeaf, r = this._parent.docView.chartInfo.shouldDrawFocusRing && (this.paraview.store.settings.ui.isLowVisionModeEnabled || this.paraview.store.settings.ui.isFocusRingEnabled) ? new Q9e(this.paraview, e) : null;
    return Tt`
      ${r == null ? void 0 : r.render()}
    `;
  }
}
const oO = {
  /** A single rising sequence */
  Rise: "Rising",
  /** A single falling sequence */
  Fall: "Falling",
  /** A single stable sequence */
  Stable: "Stable",
  /** A single sequence that shows a large, rapid increase in value */
  BigJump: "Big Jump",
  /** A single sequence that shows a large, rapid decrease in value */
  BigFall: "Big Fall",
  /** A falling sequence followed by a rising sequence */
  ReversalToRise: "Reversal to Rising",
  /** A rising sequence followed by a falling sequence */
  ReversalToFall: "Reversal to Falling",
  /** A stable sequence followed by a rising sequence */
  EmergingRise: "Emerging Rising",
  /** A stable sequence followed by a falling sequence */
  EmergingFall: "Emerging Falling",
  /** A rising sequence followed by a stable sequence */
  RiseToStable: "Rising to Stable",
  /** A falling sequence followed by a stable sequence */
  FallToStable: "Falling to Stable",
  /** A rising sequence followed by a falling sequence and another rising sequence */
  Rebound: "Rebounding",
  /** A falling sequence followed by a rising sequence and another falling sequence */
  TemporaryJump: "Temporary Jump",
  /** A falling sequence followed by a short rising sequence at the end of the chart */
  PossibleReversalToRise: "Possible Reversal to Rising",
  /** A rising sequence followed by a short falling sequence at the end of the chart */
  PossibleReversalToFall: "Possible Reversal to Falling",
  /** A stable sequence followed by a short rising sequence at the end of the chart */
  PossibleEmergingRise: "Possible Emerging Rising",
  /** A stable sequence followed by a short falling sequence at the end of the chart */
  PossibleEmergingFall: "Possible Emerging Falling",
  /** A rising sequence followed by a short stable sequence at the end of the chart */
  PossibleRiseToStable: "Possible Rising to Stable",
  /** A falling sequence followed by a short stable sequence at the end of the chart */
  PossibleFallToStable: "Possible Falling to Stable",
  /** A rising sequence followed by a falling sequence and another short rising sequence at the end of the chart */
  PossibleRebound: "Possible Rebounding",
  /** A falling sequence followed by a rising sequence and another short falling sequence at the end of the chart */
  PossibleTemporaryJump: "Possible Temporary Jump"
};
class Y9e extends pf {
  constructor(e, r, n, i) {
    super(e, r, n), this.type = i, this._groups = /* @__PURE__ */ new Map();
  }
  _createId() {
    return super._createId(`${this.type}-annotation`);
  }
  group(e) {
    return this._groups.get(e);
  }
  addGroup(e, r = !1) {
    if (this._groups.has(e)) {
      if (r)
        return;
      throw new Error(`group '${e}' already exists`);
    }
    this._groups.set(e, new Z9e(this.paraview, e)), this.append(this._groups.get(e));
  }
  removeGroup(e, r = !1) {
    if (this._groups.has(e))
      this._groups.delete(e);
    else {
      if (r)
        return;
      throw new Error(`group '${e}' does not exist`);
    }
  }
  addPopups() {
    if (this.addGroup("datapoint-popups", !0), this.group("datapoint-popups").clearChildren(), this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onFocus") {
      this.paraview.store.userLineBreaks.splice(0, this.paraview.store.userLineBreaks.length), this.paraview.store.popups.splice(0, this.paraview.store.popups.length);
      const e = this.paraview.documentView.chartLayers.dataLayer.chartInfo.navMap.cursor, n = e.datapoints.map((s) => this._parent.dataLayer.datapointView(s.seriesKey, s.datapointIndex));
      let i = [];
      if (e.type === "chord")
        i.push(...this.addChordPopups(n));
      else if (e.type === "sequence")
        i.push(...this.addSequencePopups(n));
      else if (e.type === "series")
        i.push(...this.addSeriesPopups(n));
      else
        for (let s of this.paraview.store.visitedDatapoints) {
          const { seriesKey: o, index: a } = on(s);
          this.paraview.documentView.chartLayers.dataLayer.datapointView(o, a).addPopup();
        }
      for (let s of i)
        this.paraview.store.popups.push(s);
    } else if (this.paraview.store.settings.chart.showPopups && this.paraview.store.settings.popup.activation === "onSelect") {
      this.paraview.store.popups.splice(0, this.paraview.store.popups.length);
      for (let e of this.paraview.store.selectedDatapoints) {
        const { seriesKey: r, index: n } = on(e);
        this.paraview.documentView.chartLayers.dataLayer.datapointView(r, n).addPopup();
      }
    }
    for (const e of this.paraview.store.popups)
      e.classInfo = { popup: !0 }, this.type === "foreground" ? this.group("datapoint-popups").append(e) : this._groups.has("datapoint-popups") && this.removeGroup("datapoint-popups", !0);
  }
  addChordPopups(e) {
    var o, a, l;
    let r = "";
    for (let c of e)
      r = r.concat(`${c.seriesKey}: ${this.paraview.documentView.chartLayers.dataLayer.chartInfo.summarizer.getDatapointSummary(c.datapoint, "statusBar")}
`);
    const n = e[0], i = (o = this.paraview.documentView) == null ? void 0 : o.chartLayers.dataLayer.chartInfo.popuplegend();
    this.paraview.store.addLineBreak(
      ((a = this.paraview.documentView) == null ? void 0 : a.chartLayers.dataLayer.chartInfo.navMap.cursor.index) / (this.paraview.store.model.series[0].datapoints.length - 1),
      n.index,
      n.seriesKey,
      !1
    ), (l = this.paraview.documentView) == null || l.chartLayers.backgroundAnnotationLayer.render();
    const s = new ls(
      this.paraview,
      {
        text: r,
        x: n.x,
        y: n.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: n.color,
        //margin: 60,
        type: "chord",
        items: i,
        points: e
      },
      {
        fill: "hsl(0, 0%, 100%)",
        stroke: "hsl(0, 0%, 0%)"
      }
    );
    return s.classInfo = { popup: !0 }, [s];
  }
  addSequencePopups(e) {
    const r = e[0];
    let i = (e[e.length - 1].x + r.x) / 2, s = 0;
    if (e.length % 2 == 0) {
      const v = e[e.length / 2 - 1], m = e[e.length / 2];
      s = (v.y + m.y) / 2;
    } else
      s = e[(e.length - 1) / 2].y;
    const o = this.paraview.store.seriesAnalyses[r.seriesKey], a = o.sequences.findIndex((v) => v.start === e[0].index && v.end - 1 === e[e.length - 1].index), l = this.paraview.store.model.series[0].datapoints.map(
      (v) => Wr(v.facetBox("x"), this.paraview.store.getFormatType("horizTick"))
    ), c = this.paraview.store.model.series.find((v) => v.key === e[0].seriesKey).datapoints;
    let p = "";
    if (o.sequences[a].message == null) {
      let v = o.sequences[a];
      e[e.length - 1].y - e[0].y > 0 && Math.abs(v.slopeInfo.slope) > 0.2 ? p = p.concat("Falling trend") : e[e.length - 1].y - e[0].y <= 0 && Math.abs(v.slopeInfo.slope) > 0.2 ? p = p.concat("Rising trend") : p = p.concat("Stable trend");
    } else
      p = p.concat(`${oO[o.sequences[a].message]} trend`);
    const h = parseFloat((c[o.sequences[a].end - 1].facetValueAsNumber("y") - c[o.sequences[a].start].facetValueAsNumber("y")).toFixed(4));
    p = p.concat(`
${h > 0 ? "+" : ""}${h}`), p = p.concat(`
${l[o.sequences[a].start]}-${l[o.sequences[a].end - 1]}`), p = p.concat(`
${o.sequences[a].end - o.sequences[a].start} records`);
    const d = new ls(
      this.paraview,
      {
        text: p,
        x: i,
        y: s,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: r.color,
        margin: 60,
        type: "sequence",
        points: e
      },
      {}
    );
    return d.classInfo = { popup: !0 }, [d];
  }
  addSeriesPopups(e) {
    const r = e[0];
    let i = (e[e.length - 1].x + r.x) / 2, s = 0;
    if (e.length % 2 == 0) {
      const d = e[e.length / 2 - 1], v = e[e.length / 2];
      s = (d.y + v.y) / 2;
    } else
      s = e[(e.length - 1) / 2].y;
    const o = this.paraview.store.seriesAnalyses[r.seriesKey], a = this.paraview.store.model.series[0].datapoints.map(
      (d) => Wr(d.facetBox("x"), this.paraview.store.getFormatType("horizTick"))
    ), l = this.paraview.store.model.series.find((d) => d.key === e[0].seriesKey).datapoints;
    let c = "";
    c = c.concat(`${e[0].seriesKey}`), (o == null ? void 0 : o.message) == null ? c = c.concat(`
No trend detected`) : c = c.concat(`
${oO[o == null ? void 0 : o.message]} trend`);
    let p = parseFloat((l[l.length - 1].facetValueAsNumber("y") - l[0].facetValueAsNumber("y")).toFixed(4));
    c = c.concat(`
${p > 0 ? "+" : ""}${p}`), c = c.concat(`
${a[0]}-${a[l.length - 1]}`), c = c.concat(`
${l.length} records`);
    const h = new ls(
      this.paraview,
      {
        text: c,
        x: i,
        y: s,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        color: r.color,
        margin: 60,
        points: e
      },
      {}
    );
    return h.classInfo = { popup: !0 }, [h];
  }
  renderChildren() {
    return super.renderChildren();
  }
}
class Z9e extends vo(Pr) {
  constructor(e, r) {
    super(e), this._name = r;
  }
  get name() {
    return this._name;
  }
}
const J9e = {
  bar: o1,
  column: o1,
  line: cx,
  scatter: z9e,
  histogram: W9e,
  heatmap: H9e,
  pie: eO,
  donut: eO,
  gauge: o1,
  //GaugeChart,
  stepline: cx,
  //StepLineChart,
  lollipop: o1,
  //LollipopChart
  graph: cx
};
class X9e extends Pr {
  constructor(e, r, n) {
    super(e.paraview), this.docView = e, this._orientation = this.paraview.store.settings.chart.orientation, this.width = r, this.height = n, this._canWidthFlex = !0, this._canHeightFlex = !0, this.createLayers();
  }
  _createId() {
    return "layers";
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  createLayers() {
    this._backgroundHighlightsLayer = new iO(this.paraview, this._width, this._height, "background"), this.append(this._backgroundHighlightsLayer), this._backgroundAnnotationLayer = new JR(this.paraview, this._width, this._height, "background"), this.append(this._backgroundAnnotationLayer), this.createDataLayers(), this._foregroundHighlightsLayer = new iO(this.paraview, this._width, this._height, "foreground"), this.append(this._foregroundHighlightsLayer), this._foregroundAnnotationLayer = new JR(this.paraview, this._width, this._height, "foreground"), this.append(this._foregroundAnnotationLayer), this._selectionLayer = new q9e(this.paraview, this._width, this._height), this.append(this._selectionLayer), this._focusLayer = new K9e(this.paraview, this._width, this._height), this.append(this._focusLayer), this._popupLayer = new Y9e(this.paraview, this._width, this._height, "foreground"), this.append(this._popupLayer);
  }
  /** Physical width of the chart; i.e., width onscreen after any rotation. */
  get width() {
    return super.width;
  }
  set width(e) {
    this._orientation === "north" || this._orientation === "south" ? this._logicalWidth = e : this._logicalHeight = e, super.width = e, this._resizeLayers();
  }
  /** Physical height of the chart; i.e., height onscreen after any rotation. */
  get height() {
    return super.height;
  }
  set height(e) {
    this._orientation === "north" || this._orientation === "south" ? this._logicalHeight = e : this._logicalWidth = e, super.height = e, this._resizeLayers();
  }
  get logicalWidth() {
    return this._logicalWidth;
  }
  set logicalWidth(e) {
    this._orientation === "north" || this._orientation === "south" ? this.width = e : this.height = e, this._logicalWidth = e, this._resizeLayers();
  }
  get logicalHeight() {
    return this._logicalHeight;
  }
  set logicalHeight(e) {
    this._orientation === "north" || this._orientation === "south" ? this.height = e : this.width = e, this._logicalHeight = e, this._resizeLayers();
  }
  get orientation() {
    return this._orientation;
  }
  get backgroundHighlightsLayer() {
    return this._backgroundHighlightsLayer;
  }
  get backgroundAnnotationLayer() {
    return this._backgroundAnnotationLayer;
  }
  get dataLayer() {
    return this._dataLayers[0];
  }
  get foregroundHighlightsLayer() {
    return this._foregroundHighlightsLayer;
  }
  get foregroundAnnotationLayer() {
    return this._foregroundAnnotationLayer;
  }
  get selectionLayer() {
    return this._selectionLayer;
  }
  get popupLayer() {
    return this._popupLayer;
  }
  _resizeLayers() {
    this._children.forEach((e) => {
      e.resize(this._logicalWidth, this._logicalHeight);
    });
  }
  resize(e, r) {
    super.resize(e, r), this._orientation === "north" || this._orientation === "south" ? (this._logicalWidth = e, this._logicalHeight = r) : (this._logicalHeight = e, this._logicalWidth = r), this._resizeLayers();
  }
  createDataLayers() {
    const e = J9e[this.paraview.store.type];
    let r;
    if (e)
      r = new e(this.paraview, this._width, this._height, 0, this.docView.chartInfo), this.append(r);
    else
      throw new Error(`no class found for chart type '${this.paraview.store.type}'`);
    this._dataLayers = [r];
  }
  updateLoc() {
  }
  render() {
    this.popupLayer.addPopups();
    let e = nt`translate(${this._x + this._padding.left},${this._y + this._padding.top})`;
    return this._orientation === "east" ? e += nt`
        translate(${this._logicalHeight},${0})
        rotate(90)
      ` : this._orientation === "west" ? e += nt`
        translate(0,${this._logicalHeight})
        rotate(-90)
      ` : this._orientation === "south" && (e += nt`
        translate(0,${this._logicalHeight})
        scale(1,-1)
      `), Tt`
      <g
        id="chart-layers"
        transform=${e}
      >
        <rect
          id="data-backdrop"
          width=${nt`${this._logicalWidth}`}
          height=${nt`${this._logicalHeight}`}
        />
        ${this._backgroundHighlightsLayer.render()}
        ${this._backgroundAnnotationLayer.render()}
        ${this._dataLayers.map((r) => r.render())}
        ${this._foregroundHighlightsLayer.render()}
        ${this._selectionLayer.render()}
        ${this._foregroundAnnotationLayer.render()}
        ${this._focusLayer.render()}
        ${this.popupLayer.render()}
      </g>
    `;
  }
}
class IV extends Pr {
  constructor(e, r) {
    super(e.paraview), this.axis = e, this.length = r, this._classInfo = { "axis-line": !0 };
  }
  get length() {
    return 0;
  }
  set length(e) {
  }
  _createId(...e) {
    return `${this.axis.orientation}-axis-line`;
  }
  render() {
    const e = nt`translate(${this._x},${this._y})`;
    return Tt`
      <path
        transform=${this._x !== 0 || this._y !== 0 ? e : Ne}
        id=${this._id}
        class=${Br(this._classInfo)}
        d=${this.getLineD()}
      ></path>
    `;
  }
}
class e7e extends IV {
  constructor(e, r) {
    super(e, r), this._height = 0, this._canWidthFlex = !0;
  }
  get length() {
    return this.width;
  }
  set length(e) {
    this.width = e, super.length = e;
  }
  getLineD() {
    if (this.axis.orientationSettings.line.isDrawOverhang) {
      const e = this.paraview.store.settings.axis.vert.ticks.length, r = this.paraview.store.settings.axis.vert.position === "west" ? -e : 0;
      return nt`M${r},0 h${this.width + e}`;
    } else
      return nt`M0,0 h${this.width}`;
  }
}
class t7e extends IV {
  constructor(e, r) {
    super(e, r), this._width = 0, this._canHeightFlex = !0;
  }
  get length() {
    return this.height;
  }
  set length(e) {
    this.height = e, super.length = e;
  }
  getLineD() {
    if (this.axis.orientationSettings.line.isDrawOverhang) {
      const e = this.paraview.store.settings.axis.horiz.ticks.length, r = this.paraview.store.settings.axis.horiz.position === "north" ? -e : 0;
      return nt`M0,${r} v${this.height + e}`;
    } else
      return nt`M0,0 v${this.height}`;
  }
}
class PV extends vo(Pr) {
  constructor(e, r, n, i, s, o) {
    super(o), this.axis = e, this.tickLabels = r, this.tierIndex = n, this._tickStep = s, this._updateSizeFromLength(i), this.createTickLabels();
  }
  resize(e, r) {
    super.resize(e, r), this.createTickLabels();
  }
  get class() {
    return "tick-label-tier";
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get tickInterval() {
    return this._labelDistance;
  }
  _createId(...e) {
    return `tick-label-tier-${this.axis.orientation}-${this.tierIndex}`;
  }
  _maxLabelWidth() {
    return this._children.length ? Math.max(...this._children.map((e) => e.paddedWidth ?? 0)) : 0;
  }
  _maxLabelHeight() {
    return this._children.length ? Math.max(...this._children.map((e) => e.paddedHeight ?? 0)) : 0;
  }
  createTickLabels(e = !0) {
    const r = this.axis.isInterval ? this.tickLabels.length : this.tickLabels.length - 1;
    this._labelDistance = this._length / (r / this._tickStep), this.clearChildren();
    for (const [n, i] of this.tickLabels.entries()) {
      if (n % this._tickStep)
        continue;
      const s = new fi(this.paraview, {
        id: `tick-label-${this.axis.orientation}-${n}`,
        classList: [
          "tick-label",
          `tick-label-${this.axis.orientation}`,
          this.axis.orientationSettings.position
        ],
        role: "axislabel",
        text: i,
        textAnchor: this._labelTextAnchor,
        wrapWidth: this._labelWrapWidth,
        x: 0,
        y: 0,
        pointerEnter: (o) => {
          this.addPopup(i, n);
        },
        pointerLeave: (o) => {
          this.removePopup(this.id);
        }
      });
      this.append(s);
    }
  }
  addPopup(e, r) {
  }
  removePopup(e) {
  }
  updateTickLabelIds() {
  }
}
class r7e extends PV {
  constructor(e, r, n, i, s, o) {
    super(e, r, n, i, s, o), this.axis = e, this.tickLabels = r, this.log = qt("HorizTickLabelTier"), this._canWidthFlex = !0, this.padding = { top: this.axis.orientationSettings.ticks.labels.offsetGap };
  }
  _updateSizeFromLength(e) {
    this._width = e;
  }
  get _length() {
    return this._width;
  }
  get _labelTextAnchor() {
    return this.axis.orientationSettings.ticks.labels.angle ? "end" : "middle";
  }
  get _labelWrapWidth() {
    return this._labelDistance;
  }
  computeSize() {
    return [this._width, this._maxLabelHeight()];
  }
  _tickLabelX(e) {
    let r = this._labelDistance * e;
    return this.axis.isInterval && (r += this._labelDistance / this._tickStep / 2), this.axis.orientationSettings.labelOrder === "westToEast" ? r : this._width - r;
  }
  _tickLabelY(e) {
    return this.paraview.store.model.getAxisFacet(this.axis.orientation) ?? this.paraview.store.model.getFacet(this.axis.orientation === "horiz" ? "x" : "y"), this.axis.orientationSettings.position === "north" ? this.height : 0;
  }
  createTickLabels(e = !0) {
    super.createTickLabels(), this._children.forEach((r, n) => {
      this.paraview.store.settings.axis.horiz.ticks.labels.angle && (r.angle = this.axis.orientationSettings.ticks.labels.angle), r.angle === 0 ? (r.top = this._tickLabelY(n), r.centerX = this._tickLabelX(n)) : r.angle > 0 ? r.topLeft = new Ye(this._tickLabelX(n), this._tickLabelY(n)) : r.topRight = new Ye(this._tickLabelX(n), this._tickLabelY(n));
    }), this.updateSize(), e && (this._tickStep = this._optimizeLabelSpacing(), this.createTickLabels(!1));
  }
  _optimizeLabelSpacing() {
    const e = this._children.map((i) => i.bbox);
    let r = [...e];
    this._children.map((i) => i.locOffset.x);
    let n = this._tickStep;
    for (this._width; ; ) {
      const i = r.slice(1).map((o, a) => o.left - r[a].right), s = Math.min(...i);
      if (Math.round(s) < this.axis.orientationSettings.ticks.labels.gap) {
        if (n++, r = e.filter((a, l) => l % n === 0), !(Math.floor(this.tickLabels.length / n) + this.tickLabels.length % n))
          throw new Error("tick labels will always overlap");
        continue;
      }
      break;
    }
    return n;
  }
  addPopup(e, r) {
    var o;
    let n = "no text detected";
    const i = this.tickLabels.length % this.children.length == 0 ? this.children.length / this.tickLabels.length : this.children.length / (this.tickLabels.length + 1);
    let s = new ls(
      this.paraview,
      {
        text: e ?? n,
        x: this._tickLabelX(r ?? 0) * i,
        y: (o = this.paraview.documentView) == null ? void 0 : o.chartLayers.height,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        type: "horizTick",
        fill: "hsl(0, 0%, 0%)",
        inbounds: !1
      },
      {
        fill: "hsl(0, 0%, 100%)",
        shape: "box"
      }
    );
    this.paraview.store.popups.push(s);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
}
class n7e extends PV {
  constructor(e, r, n, i, s, o) {
    super(e, r, n, i, s, o), this.axis = e, this.tickLabels = r, this._canHeightFlex = !0, this.padding = { right: this.axis.orientationSettings.ticks.labels.offsetGap };
  }
  _updateSizeFromLength(e) {
    this._height = e;
  }
  get _length() {
    return this._height;
  }
  get _labelTextAnchor() {
    return "end";
  }
  get _labelWrapWidth() {
  }
  computeSize() {
    return [this._maxLabelWidth(), this._height];
  }
  _tickLabelX(e) {
    return this.axis.orientationSettings.position === "west" ? this.width : 0;
  }
  _tickLabelY(e) {
    const r = this._labelDistance * e;
    return this.axis.orientationSettings.labelOrder === "northToSouth" ? r + this._labelDistance / 2 + this._children[e].height / 3 : this.height - r + this._children[e].height / 3;
  }
  createTickLabels() {
    super.createTickLabels(), this.updateSize(!1), this._children.forEach((e, r) => {
      e.x = this._tickLabelX(r), e.y = this._tickLabelY(r);
    });
  }
  addPopup(e, r) {
    let n = "no text detected", i = new ls(
      this.paraview,
      {
        text: e ?? n,
        x: this._tickLabelX(r ?? 0),
        y: this._tickLabelY(r ?? 0) + this.paraview.store.settings.popup.margin - this.children[r ?? 0].height,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        type: "vertTick",
        fill: "hsl(0, 0%, 0%)",
        inbounds: !1
      },
      {
        fill: "hsl(0, 0%, 100%)",
        shape: "box"
      }
    );
    this.paraview.store.popups.push(i);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
}
class RV extends Pr {
  constructor(e, r = !0, n, i, s = !1) {
    super(e), this._major = r, this._orientation = i, this.darken = s, this.length = n;
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get length() {
    return 0;
  }
  set length(e) {
  }
  _addedToParent() {
    this.updateSize();
  }
  content() {
    const e = this._shouldNegateLength ? -this.length : this.length, r = nt`M${this._x},${this._y}`, n = this._orientation + nt`${e}`;
    return Tt`
      <path
        id=${this.darken ? "grid-zero" : ""}
        class=${Br(this.classInfo)}
        d=${r + " " + n}
      ></path>
    `;
  }
}
class OV extends RV {
  /**
   * @param _pointsTo - The tick starts on the axis and points in this direction.
   * @param major
   */
  constructor(e, r, n = !0, i, s = !1) {
    super(r, n, i, "v", s), this._pointsTo = e;
  }
  get length() {
    return this.height;
  }
  set length(e) {
    this.height = e, super.length = e;
  }
  computeSize() {
    return [
      0,
      // computeSize() initially gets called before the parent is set
      this.height
    ];
  }
}
class TV extends RV {
  /**
   * @param _pointsTo - The tick starts on the axis and points in this direction.
   * @param major
   */
  constructor(e, r, n = !0, i, s = !1) {
    super(r, n, i, "h", s), this._pointsTo = e;
  }
  get length() {
    return this.width;
  }
  set length(e) {
    this.width = e, super.length = e;
  }
  computeSize() {
    return [
      // computeSize() initially gets called before the parent is set
      this.width,
      0
    ];
  }
}
class i7e extends OV {
  get classInfo() {
    return {
      tick: !0,
      "tick-horiz": !0
    };
  }
  get length() {
    return this._major ? super.length : super.length / 2;
  }
  set length(e) {
    super.length = e;
  }
  get _shouldNegateLength() {
    return this._pointsTo === "north";
  }
}
class s7e extends TV {
  get classInfo() {
    return {
      tick: !0,
      "tick-vert": !0
    };
  }
  get length() {
    return this._major ? super.length : super.length / 2;
  }
  set length(e) {
    super.length = e;
  }
  get _shouldNegateLength() {
    return this._pointsTo === "west";
  }
}
class o7e extends OV {
  get classInfo() {
    return {
      grid: !0,
      "grid-horiz": !0
    };
  }
  get _shouldNegateLength() {
    return this._pointsTo === "south";
  }
}
class a7e extends TV {
  get classInfo() {
    return {
      grid: !0,
      "grid-vert": !0
    };
  }
  get _shouldNegateLength() {
    return this._pointsTo === "east";
  }
}
class LV extends vo(Pr) {
  constructor(e, r, n, i) {
    super(e), this._axisSettings = r, this._majorModulus = n, this._options = i, this._indices = [], this._updateSizeFromLength(this._options.length), this._count = this._options.tickCount, this._options.isInterval, this._computeInterval();
  }
  resize(e, r) {
    super.resize(e, r), this._computeInterval(), this.clearChildren(), this._createTicks();
  }
  // protected _computeCount() {
  //   // XXX CIRCULAR DEPENDENCY between this and computeInterval()
  //   const intervalCount = this._length / this._interval;
  //   this._count = Math.round(intervalCount);
  //   if (this._options.isInterval) {
  //     this._count++;
  //   }
  // }
  _computeInterval() {
    const e = this._options.isInterval ? this._count : this._count - 1;
    this._interval = this._length / (e / this._options.tickStep);
  }
  _addedToParent() {
    this._createTicks();
  }
  /**
   * Overridden by subclasses to set the appropriate size dimension from `length`.
   */
  _updateSizeFromLength(e) {
    this.updateSize();
  }
  _createId(...e) {
    return `${this._options.orientation}-axis-tick-strip`;
  }
  get parent() {
    return this._parent;
  }
  get class() {
    return "tick-strip";
  }
  set parent(e) {
    super.parent = e;
  }
}
class l7e extends LV {
  constructor(e, r, n, i) {
    super(e, r, n, i), this._ruleXs = [], this._ruleY = 0, this._canWidthFlex = !0;
  }
  computeSize() {
    return [
      this._options.length,
      // NB! The grid lines DON'T COUNT toward the height!
      this._axisSettings.ticks.isDrawTicks || this._options.isDrawOverhang ? this._axisSettings.ticks.length : 0
    ];
  }
  get _length() {
    return this._width;
  }
  _updateSizeFromLength(e) {
    this._width = e, super._updateSizeFromLength(e);
  }
  // resize(width: number, height: number, interval: number) {
  //   this.width = width;
  //   this._gridLineLength = height;
  //   super.resize(width, height, interval);
  // }
  _createTicks() {
    const e = this._options.orthoAxisPosition === "east";
    let r = this._axisSettings.ticks.length;
    this._ruleY = 0, this._axisSettings.position === "north" && (this._ruleY = this._axisSettings.ticks.isDrawTicks || this._options.isDrawOverhang ? r + this._axisSettings.ticks.padding : 0), this._indices = ua(this._count + (this._options.isInterval ? 1 : 0), (n) => n).filter((n) => n % this._options.tickStep === 0), this.paraview.store.settings.grid.isDrawVertAxisOppositeLine || (this._indices = e ? this._indices.slice(0, -1) : this._indices.slice(1)), this._indices = this._indices.slice(1), this._ruleXs = this._indices.map((n) => e ? this.width - n * this._interval : n * this._interval), this._indices.forEach((n, i) => {
      this.append(new i7e(
        this._axisSettings.position,
        this.paraview,
        n % this._majorModulus === 0,
        r
      )), this._children.at(-1).x = this._ruleXs[i], this._children.at(-1).y = this._ruleY;
    });
  }
  addRules(e) {
    this._indices.forEach((r, n) => {
      this.append(new o7e(
        this._axisSettings.position,
        this.paraview,
        void 0,
        e,
        n === this._options.zeroIndex
      )), this._children.at(-1).x = this._ruleXs[n], this._children.at(-1).y = this._ruleY, this._children.at(-1).hidden = !this.paraview.store.settings.grid.isDrawVertLines;
    });
  }
}
class c7e extends LV {
  constructor(e, r, n, i) {
    super(e, r, n, i), this._ruleX = 0, this._ruleYs = [], this._canHeightFlex = !0;
  }
  computeSize() {
    return [
      // NB! The grid lines DON'T COUNT toward the width!
      this._axisSettings.ticks.isDrawTicks || this._options.isDrawOverhang ? this._axisSettings.ticks.length : 0,
      this._options.length
    ];
  }
  get _length() {
    return this._height;
  }
  _updateSizeFromLength(e) {
    this._height = e, super._updateSizeFromLength(e);
  }
  // protected _adjustToSizeConstraint() {
  //   this._gridLineLength = width;
  //   this.height = height;
  //   super.resize(width, height, interval);
  // }
  _createTicks() {
    const e = this._options.orthoAxisPosition === "north", r = this._axisSettings.ticks.length;
    this._ruleX = r, this._indices = ua(this._count, (n) => n), this.paraview.store.settings.grid.isDrawHorizAxisOppositeLine || (this._indices = e ? this._indices.slice(1) : this._indices.slice(0, -1)), this._axisSettings.position === "east" && (this._ruleX = 0), this._ruleYs = this._indices.map((n) => e ? this.height - n * this._interval : n * this._interval), this._indices.forEach((n) => {
      this.append(new s7e(
        this._axisSettings.position,
        this.paraview,
        n % this._majorModulus === 0,
        r
      )), this._children.at(-1).x = this._ruleX, this._children.at(-1).y = this._ruleYs[n];
    });
  }
  addRules(e) {
    this._indices.forEach((r) => {
      this.append(new a7e(
        this._axisSettings.position,
        // XXX don't use `plotWidth` here
        this.paraview,
        void 0,
        e,
        this._indices.length - r - 1 === this._options.zeroIndex
      )), this._children.at(-1).x = this._ruleX, this._children.at(-1).y = this._ruleYs[r], this._children.at(-1).hidden = !this.paraview.store.settings.grid.isDrawHorizLines;
    });
  }
}
class iPe extends Error {
  constructor(e) {
    super(), this.preferredWidth = e;
  }
}
class sPe extends Error {
  constructor(e) {
    super(), this.preferredTickStep = e;
  }
}
class MV extends vo(Pr) {
  constructor(e, r) {
    super(e.paraview), this.docView = e, this.orientation = r, this._tickLabelTiers = [], this._tickStrip = null, this._store = this.paraview.store, this.chartLayers = e.chartLayers, this._facet = e.chartInfo.axisInfo.getFacetForOrientation(this.orientation), this.datatype = this._facet.datatype, this.settings = vr.getGroupLink(
      this.managedSettingKeys[0],
      this._store.settings
    ), this.orientationSettings = vr.getGroupLink(
      `axis.${r}`,
      this._store.settings
    ), this._tickStep = this.orientationSettings.ticks.step, this._labelInfo = this.coord === "x" ? e.chartInfo.axisInfo.xLabelInfo : e.chartInfo.axisInfo.yLabelInfo, this._isInterval = this.coord === "x" ? !!e.chartInfo.axisInfo.options.isXInterval : !!e.chartInfo.axisInfo.options.isYInterval, this._titleText = this.orientationSettings.title.text ?? "";
  }
  get coord() {
    return this._store.model.facetKeys.find((e) => this._store.model.getFacet(e) === this._facet);
  }
  _createId() {
    return `${this.orientation}-axis`;
  }
  isHoriz() {
    return this.orientation === "horiz";
  }
  isVert() {
    return this.orientation === "vert";
  }
  get asHoriz() {
    if (this.isHoriz())
      return this;
    throw new Error("axis is not horizontal");
  }
  get asVert() {
    if (this.isVert())
      return this;
    throw new Error("axis is not vertical");
  }
  get managedSettingKeys() {
    return [`axis.${this.coord}`];
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    super.parent = e;
  }
  get tickStep() {
    return this._tickStep;
  }
  get isInterval() {
    return this._isInterval;
  }
  get tickLabelTiers() {
    return this._tickLabelTiers;
  }
  get role() {
    return "graphics-object";
  }
  get roleDescription() {
    return `${this.coord}-axis`;
  }
  get extraAttrs() {
    return [
      {
        attr: Lu`data-axistype`,
        value: this.datatype
      }
    ];
  }
  get viewGroup() {
    return this._layout;
  }
  get titleText() {
    return this._titleText;
  }
  // get range() {
  //   return this.chartLayers.getAxisInterval(this.coord);
  // }
  get orthoAxis() {
    return this._orthoAxis;
  }
  get layout() {
    return this._layout;
  }
  set orthoAxis(e) {
    this._orthoAxis = e;
  }
  resize(e, r) {
    this._layout.resize(e, r), super.resize(e, r);
  }
  _childDidResize(e) {
    this.updateSize();
  }
  // settingDidChange(path: string, _oldValue?: Setting, _newValue?: Setting): void {
  //   if (['axis.y.maxValue', 'axis.y.minValue'].includes(path)) {
  //     this._layout.clearChildren();
  //     this.createComponents();
  //     this.layoutComponents();
  //   }
  // }
  createComponents() {
    this.orientationSettings.title.isDrawTitle && this._titleText && (this._createAxisTitle(), this._appendTitle()), this.orientationSettings.ticks.labels.isDrawTickLabels && (this._tickLabelTiers = this._createTickLabelTiers(), this._appendTickLabelTiers()), this.orientationSettings.ticks.isDrawTicks && (this._tickStrip = this._createTickStrip(), this._appendTickStrip()), this.orientationSettings.line.isDrawAxisLine && (this._createAxisLine(), this._appendAxisLine());
  }
  layoutComponents() {
  }
  _createAxisTitle() {
    this._axisTitle = new fi(this.paraview, {
      id: `axis-title-${this.orientation}`,
      text: this.titleText,
      classList: [`axis-title-${this.orientation}`],
      role: "heading",
      angle: this._getAxisTitleAngle(),
      pointerEnter: (e) => {
        this.addPopup();
      },
      pointerLeave: (e) => {
        this.removePopup(this.id);
      }
    }), this._axisTitle.padding = this._getAxisTitlePadding();
  }
  addPopup(e) {
    let r = `${this.titleText}`, n = new ls(
      this.paraview,
      {
        text: e ?? r,
        x: this.x,
        y: this.y,
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        type: "vertAxis",
        fill: "hsl(0, 0%, 0%)"
      },
      {
        fill: "hsl(0, 0%, 100%)",
        shape: "box"
      }
    );
    this.paraview.store.popups.push(n);
  }
  removePopup(e) {
    this.paraview.store.popups.splice(this.paraview.store.popups.findIndex((r) => r.id === e), 1), this.paraview.requestUpdate();
  }
  updateTickLabelIds() {
    for (const e of this._tickLabelTiers)
      e.updateTickLabelIds();
  }
  setAxisLabelText(e) {
    this._titleText = e ?? this.orientationSettings.title.text ?? "", this._axisTitle && (this._axisTitle.text = this._titleText);
  }
  _getAxisTitleAngle() {
    return 0;
  }
  addGridRules(e) {
    var r;
    (r = this._tickStrip) == null || r.addRules(e);
  }
}
class u7e extends MV {
  constructor(e) {
    super(e, "horiz"), this._canWidthFlex = !0, this._layout = new kh(this.paraview, {
      numCols: 1,
      rowAligns: "end",
      colAligns: "center",
      canWidthFlex: !0,
      width: this.docView.width,
      isAutoHeight: !0
    }, "horiz-axis-layout"), this._layout.isBubbleSizeChange = !0, this.append(this._layout);
  }
  get length() {
    return this._width;
  }
  computeSize() {
    return [
      this._layout.width,
      this._layout.height
    ];
  }
  _appendTitle() {
    this._layout.append(this._axisTitle);
  }
  _createTickLabelTiers() {
    return this._labelInfo.labelTiers.map((e, r) => new r7e(
      this,
      e,
      r,
      this.docView.width,
      this._tickStep,
      this.paraview
    ));
  }
  _appendTickLabelTiers() {
    this._tickLabelTiers.forEach((e, r) => {
      this._layout.splitRowTop(0, "end"), this._layout.append(e);
    });
  }
  _createTickStrip() {
    return new l7e(this.paraview, this.orientationSettings, 1, {
      orientation: this.orientation,
      length: this.docView.width,
      plotWidth: this.docView.width,
      plotHeight: this._layout.height,
      tickCount: this._labelInfo.labelTiers[0].length,
      isInterval: this._isInterval,
      isDrawOverhang: this.paraview.store.settings.axis.vert.line.isDrawOverhang,
      tickStep: this._tickStep,
      orthoAxisPosition: this.paraview.store.settings.axis.vert.position,
      zeroIndex: this._labelInfo.labelTiers[0].findIndex((e) => e === "0") - 1
    });
  }
  _appendTickStrip() {
    this._layout.splitRowTop(0, "end"), this._layout.append(this._tickStrip);
  }
  _createAxisLine() {
    this._axisLine = new e7e(this, this.docView.width);
  }
  _appendAxisLine() {
    this._layout.splitRowTop(0, "end"), this._layout.append(this._axisLine);
  }
  _getAxisTitlePadding() {
    return this.orientationSettings.position === "south" ? { top: this.orientationSettings.title.gap } : { bottom: this.orientationSettings.title.gap };
  }
  layoutComponents() {
    this.orientationSettings.position === "south" && (this._layout.reverseChildren(), this._layout.layoutViews()), super.layoutComponents();
  }
}
class h7e extends MV {
  constructor(e) {
    super(e, "vert"), this._canHeightFlex = !0, this._layout = new kh(this.paraview, {
      numCols: 1,
      // new cols will get added as needed
      rowAligns: "center",
      colAligns: "start",
      canHeightFlex: !0,
      height: this.docView.height,
      isAutoWidth: !0
    }, "vert-axis-layout"), this._layout.isBubbleSizeChange = !0, this.append(this._layout);
  }
  get length() {
    return this._height;
  }
  _addedToParent() {
    super._addedToParent();
    const e = this._labelInfo.min, r = this._labelInfo.max;
    this.paraview.store.settingControls.add({
      type: "textfield",
      key: "axis.y.minValue",
      label: "Min y-value",
      options: { inputType: "number" },
      value: this.settings.minValue === "unset" ? e : this.settings.minValue,
      validator: (n) => {
        const i = this.paraview.store.settings.axis.y.maxValue === "unset" ? Math.max(...this.docView.chartInfo.axisInfo.options.yValues) : this.paraview.store.settings.axis.y.maxValue;
        return n >= i ? { err: `Min y-value (${n}) must be less than (${i})` } : {};
      },
      parentView: "controlPanel.tabs.chart.general.minY"
    }), this.paraview.store.settingControls.add({
      type: "textfield",
      key: "axis.y.maxValue",
      label: "Max y-value",
      options: { inputType: "number" },
      value: this.settings.maxValue === "unset" ? r : this.settings.maxValue,
      validator: (n) => {
        const i = this.paraview.store.settings.axis.y.minValue == "unset" ? Math.min(...this.docView.chartInfo.axisInfo.options.yValues) : this.paraview.store.settings.axis.y.minValue;
        return n <= i ? { err: `Max y-value (${n}) must be greater than (${i})` } : {};
      },
      parentView: "controlPanel.tabs.chart.general.maxY"
    });
  }
  computeSize() {
    return [
      this._layout.width,
      this._layout.height
    ];
  }
  _appendTitle() {
    this._layout.append(this._axisTitle);
  }
  _createTickLabelTiers() {
    return this._labelInfo.labelTiers.map((e, r) => new n7e(
      this,
      e,
      r,
      this.docView.height,
      this._tickStep,
      this.paraview
    ));
  }
  _appendTickLabelTiers() {
    this._tickLabelTiers.forEach((e, r) => {
      this._layout.splitColumnRight(r, 0, "start"), this._layout.append(e, {
        x: r + 1
      });
    });
  }
  _createTickStrip() {
    return new c7e(this.paraview, this.orientationSettings, 1, {
      orientation: this.orientation,
      length: this.docView.height,
      plotWidth: this.docView.width,
      plotHeight: this.docView.height,
      tickCount: this._labelInfo.labelTiers[0].length,
      isInterval: this._isInterval,
      isDrawOverhang: this.paraview.store.settings.axis.horiz.line.isDrawOverhang,
      tickStep: this._tickStep,
      orthoAxisPosition: this.paraview.store.settings.axis.horiz.position,
      // XXX could be '0.0' or have a unit, etc.
      zeroIndex: this._labelInfo.labelTiers[0].findIndex((e) => e === "0")
    });
  }
  _appendTickStrip() {
    this._layout.splitColumnRight(this._tickLabelTiers.length, 0, "start"), this._layout.append(this._tickStrip, {
      x: this._layout.numCols - 1
    });
  }
  _createAxisLine() {
    this._axisLine = new t7e(this, this.docView.height);
  }
  _appendAxisLine() {
    this._layout.splitColumnRight(this._tickLabelTiers.length + 1, 0, "start"), this._layout.append(this._axisLine, {
      x: this._layout.numCols - 1
    });
  }
  _getAxisTitlePadding() {
    return this.orientationSettings.position === "west" ? { right: this.orientationSettings.title.gap } : { left: this.orientationSettings.title.gap };
  }
  tickLabelTotalWidth() {
    return this._tickLabelTiers.map((e) => e.width).reduce((e, r) => e + r, 0);
  }
  layoutComponents() {
    this.orientationSettings.position === "west" || this._layout.reverseChildren(), super.layoutComponents();
  }
  _getAxisTitleAngle() {
    return this.orientationSettings.position === "east" ? 90 : -90;
  }
}
const aO = (...t) => {
  const e = [];
  for (let r = 0; r < Math.max(...t.map((n) => n.length)); r++)
    t.forEach((n) => {
      n[r] !== void 0 && e.push(n[r]);
    });
  return e;
};
class a1 extends vo(Pr) {
  constructor(e, r, n = { orientation: "vert" }) {
    super(e), this._items = r, this._options = n, this._markers = [];
  }
  get settings() {
    return vr.getGroupLink("legend", this.paraview.store.settings);
  }
  get classInfo() {
    return { legend: !0 };
  }
  _addedToParent() {
    const e = [], r = this.settings.boxStyle.outline !== "none" || this.settings.boxStyle.fill !== "none";
    this._items.forEach((s) => {
      this._markers.push(new nn(this.paraview, { width: 12, height: 6 })), e.push(this._markers.at(-1)), e.push(Fa.fromType(
        this.paraview,
        this.paraview.store.settings.chart.isDrawSymbols ? s.symbol ?? "square.solid" : "square.solid",
        {
          color: s.color,
          pointerEnter: (o) => {
            this.paraview.store.lowlightOtherSeries(s.label);
          },
          pointerLeave: (o) => {
            this.paraview.store.clearAllSeriesLowlights();
          }
        }
      )), e.push(new fi(this.paraview, {
        text: s.label,
        x: 0,
        y: 0,
        textAnchor: "start",
        classList: ["legend-label"],
        pointerEnter: (o) => {
          this.paraview.store.lowlightOtherSeries(s.label);
        },
        pointerLeave: (o) => {
          this.paraview.store.clearAllSeriesLowlights();
        }
      }));
    });
    const n = this.paraview.store.settings.legend.symbolLabelGap, i = this.paraview.store.settings.legend.pairGap;
    if (this._options.orientation === "vert")
      this._grid = new kh(this.paraview, {
        numCols: 3,
        colGaps: n,
        colAligns: ["center", "center", "start"],
        isAutoWidth: !0,
        isAutoHeight: !0
      }, "legend-grid"), this._grid.padding = r ? this.paraview.store.settings.legend.padding : 0, e.forEach((s) => this._grid.append(s));
    else {
      let s = e.length / 3;
      for (; ; ) {
        const o = aO(
          new Array(s).fill(0),
          new Array(s).fill(n),
          new Array(s - 1).fill(i)
        );
        if (this._grid = new kh(this.paraview, {
          numCols: s * 3,
          colGaps: o
        }, "legend-grid"), this._grid.padding = r ? this.paraview.store.settings.legend.padding : 0, e.forEach((a) => this._grid.append(a)), this._options.wrapWidth === void 0 || this._grid.paddedWidth <= this._options.wrapWidth || s === 1)
          break;
        s--, e.forEach((a) => a.remove());
      }
      this._grid.colAligns = aO(
        new Array(s).fill("center"),
        new Array(s).fill("start")
      );
    }
    this.append(this._grid), r && this.prepend(new nn(this.paraview, {
      width: this._grid.width,
      height: this._grid.height,
      fill: this.settings.boxStyle.fill,
      stroke: this.settings.boxStyle.outline,
      strokeWidth: this.settings.boxStyle.outlineWidth
    })), this.updateSize();
  }
  computeSize() {
    var e, r;
    return [((e = this._grid) == null ? void 0 : e.paddedWidth) ?? 0, ((r = this._grid) == null ? void 0 : r.paddedHeight) ?? 0];
  }
  content() {
    return this._items.forEach((e, r) => {
      const n = this._markers[r].styleInfo;
      (e.datapointIndex !== void 0 ? this.paraview.store.isVisited(
        this.paraview.store.model.seriesKeys[0],
        e.datapointIndex
      ) : this.paraview.store.isVisitedSeries(e.label)) ? n.fill = this.paraview.store.colors.colorValueAt(-1) : n.fill = "none", this._markers[r].styleInfo = n;
    }), super.content();
  }
}
class p7e extends vo(Pr) {
  constructor(e) {
    super(e.paraview), this._chart = e, this.log = qt("DirectLabelStrip"), this._id = "direct-label-strip", this._createLabels();
  }
  _createLabels() {
    var s;
    const e = this.paraview.store.settings.chart.isDrawSymbols ? this._chart.settings.seriesLabelPadding * 2 : this._chart.settings.seriesLabelPadding, r = this._chart.datapointViews.filter(
      (o) => o.index === this.paraview.store.model.series[0].length - 1
    );
    r.sort((o, a) => o.y - a.y), (s = this.seriesLabels) == null || s.forEach((o) => {
      o.remove();
    }), this.seriesLabels = [], r.forEach((o, a) => {
      this.seriesLabels.push(new fi(this.paraview, {
        text: o.series.label,
        left: e,
        y: o.y,
        classList: ["direct-label"],
        pointerEnter: (l) => {
          this.paraview.store.lowlightOtherSeries(o.seriesKey);
        },
        pointerLeave: (l) => {
          this.paraview.store.clearAllSeriesLowlights();
        }
      })), this.append(this.seriesLabels.at(-1));
    }), this.seriesLabels.forEach((o) => {
      o.y += o.locOffset.y / 2;
    });
    const n = this.seriesLabels[0];
    n.y < 0 && (n.y = 0), this.seriesLabels.at(-1).bottom - this.height, this.resolveSeriesLabelCollisions(r);
  }
  _addedToParent() {
    this.observeNotices();
  }
  noticePosted(e, r) {
    ["animRevealStep", "animRevealEnd"].includes(e) && this._createLabels();
  }
  computeSize() {
    return [
      Math.max(...this.seriesLabels.map((e) => e.right)),
      this._chart.height
    ];
  }
  // XXX I don't think this method will get the job done in all cases
  resolveSeriesLabelCollisions(e) {
    var n, i;
    const r = [];
    for (let s = 1; s < this.seriesLabels.length; s++)
      this.seriesLabels[s].top < this.seriesLabels[s - 1].bottom && (((n = r.at(-1)) == null ? void 0 : n.label) !== this.seriesLabels[s - 1] && r.push({ label: this.seriesLabels[s - 1], endpoint: e[s - 1] }), r.push({ label: this.seriesLabels[s], endpoint: e[s] }));
    if ((i = this.leaders) == null || i.forEach((s) => {
      s.remove();
    }), this.leaders = [], r.length) {
      const s = this.paraview.store.settings.chart.isDrawSymbols ? -this._chart.settings.seriesLabelPadding : 0;
      r.reverse().slice(1).forEach((a, l) => {
        a.label.bottom = r[l].label.top;
      });
      const o = this.seriesLabels.filter((a) => !r.map((l) => l.label).includes(a)).toReversed();
      if (o.length) {
        const l = r.at(-1).label.bottom - o[0].y;
        l < 0 && (o.forEach((c) => c.y -= l), o.at(-1).y < 0 && this.log.warn("unable to resolve series label collision"));
      }
      r.forEach((a) => {
        a.label.x += this._chart.settings.leaderLineLength + s, this.leaders.push(new d7e(a.endpoint, a.label, this._chart)), this.prepend(this.leaders.at(-1));
      });
    }
  }
}
class d7e extends Pr {
  constructor(e, r, n) {
    super(n.paraview), this._endpoint = e, this._chart = n, this._endX = this._chart.paraview.store.settings.type.line.leaderLineLength, this._endY = r.y - r.locOffset.y / 2, this._lineD = nt`
      M${0},${e.y}
      L${this._endX},${this._endY}`;
  }
  get styleInfo() {
    const e = {};
    let r = this._chart.paraview.store.colors.colorValueAt(this._endpoint.seriesProps.color);
    return e.fill = r, e.stroke = r, e;
  }
  get classInfo() {
    return {
      "label-leader": !0,
      lowlight: this.paraview.store.isSeriesLowlighted(this._endpoint.seriesKey)
    };
  }
  content() {
    return Tt`
      <g
        class=${Br(this.classInfo)}
        style=${mn(this.styleInfo)}
      >
        <path
          d=${this._lineD}
          />
        <circle
          cx=${this._endX}
          cy=${this._endY}
          r="1.8"
        />
      </g>
    `;
  }
}
class f7e extends vo(Pr) {
  constructor(e) {
    super(e), this._directLabelStrip = null, this._legends = {}, this.log = qt("DocumentView"), this._store = e.store, this.observeNotices(), this.type = this._store.type, this._chartInfo = new k9e[this.type](this.type, this._store, this), this.setTitleText(this._store.title);
    const r = this._parsePadding(this._store.settings.chart.padding), n = Math.max(8 + 1.1 * 16, r.left);
    this.padding = {
      left: n,
      right: r.right,
      top: r.top,
      bottom: r.bottom
    }, this._createGrid();
  }
  _createGrid() {
    var e;
    (e = this._grid) == null || e.remove(), this._grid = new kh(this.paraview, {
      width: this._store.settings.chart.size.width - this._padding.left - this._padding.right,
      height: this._store.settings.chart.size.height - this._padding.top - this._padding.bottom,
      canWidthFlex: !1,
      canHeightFlex: !1,
      numCols: 4,
      // (this._store.settings.legend.isDrawLegend &&
      // ['east', 'west'].includes(this._store.settings.legend.position))
      // ? 4 : 3,
      rowAligns: "start",
      colAligns: "start"
      // rowGaps: this._store.settings.chart.title.isDrawTitle && this._store.title
      //   ? [this._store.settings.chart.title.margin]
      //   : undefined
    }, "doc-grid"), this.append(this._grid), this.updateSize(), this._populateGrid(), this._grid.layoutViews(), this.setSize(this._grid.paddedWidth, this._grid.paddedHeight, !1);
  }
  /**
   * Parse `padding` like CSS padding (1-4 numbers, same order as CSS)
   */
  _parsePadding(e) {
    const r = e.trim().split(" ");
    if (r.length === 0)
      throw new Error("must supply between 1 and 4 values for chart padding");
    return r.length === 1 ? this._expandPadding(parseFloat(r[0])) : r.length === 2 ? this._expandPadding({
      vert: parseFloat(r[0]),
      horiz: parseFloat(r[1])
    }) : r.length === 3 ? this._expandPadding({
      top: parseFloat(r[0]),
      horiz: parseFloat(r[1]),
      bottom: parseFloat(r[2])
    }) : this._expandPadding({
      top: parseFloat(r[0]),
      right: parseFloat(r[1]),
      bottom: parseFloat(r[2]),
      left: parseFloat(r[3])
    });
  }
  _populateGrid() {
    var o, a;
    this._store.settings.chart.title.isDrawTitle && this._store.title && this.createTitle();
    const e = this._store.settings.axis.horiz.position;
    if (this._chartInfo.axisInfo) {
      if (this._store.settings.axis.horiz.isDrawAxis) {
        this._horizAxis = new u7e(this);
        const l = this._chartInfo.axisInfo.horizFacet;
        this._horizAxis.setAxisLabelText(l.label), this._horizAxis.createComponents(), this._horizAxis.layoutComponents(), this._grid.append(this._horizAxis, {
          x: 1,
          y: (e === "north" ? 0 : 1) + (this._titleLabel ? 1 : 0),
          width: 1,
          rowAlign: "end"
        });
      }
      if (this._store.settings.axis.vert.isDrawAxis) {
        this._vertAxis = new h7e(this);
        const l = this._chartInfo.axisInfo.vertFacet;
        this._vertAxis.setAxisLabelText(l.label), this._vertAxis.createComponents(), this._vertAxis.layoutComponents(), this._grid.append(this._vertAxis, {
          x: 0,
          y: this._titleLabel ? 1 : 0,
          // XXX title might be at bottom
          height: 1,
          rowAlign: e === "north" ? "end" : "start"
        });
      }
      this._titleText = this._store.title ?? this._store.settings.chart.title.text;
    }
    const r = (this._chartInfo.axisInfo && e === "north" ? 1 : 0) + (this._titleLabel ? 1 : 0), n = this._horizAxis ? this._grid.colWidth(1) : this._grid.width, i = this._vertAxis ? this._grid.rowHeight(r) : this._grid.height;
    if (this._chartLayers = new X9e(this, n, i), this._chartLayers.dataLayer.init(), this._grid.append(this._chartLayers, {
      x: 1,
      y: r
    }), this._chartLayers.dataLayer.observeStore(), this._chartLayers.dataLayer.observeNotices(), this._store.settings.chart.hasDirectLabels && this.type === "line" && /*this._chartLayers.dataLayer.settings.isAlwaysShowSeriesLabel || */
    this._store.model.multi) {
      const l = this._store.settings.axis.horiz.position, c = (this._chartInfo.axisInfo && l === "north" ? 1 : 0) + (this._titleLabel ? 1 : 0);
      this._directLabelStrip = new p7e(this._chartLayers.dataLayer), this._grid.append(this._directLabelStrip, {
        x: 2,
        y: c,
        height: 1
      });
    }
    this._shouldAddLegend && this.addLegend(this._store.settings.legend.position), this._chartInfo.axisInfo && ((o = this._horizAxis) == null || o.addGridRules(this._chartLayers.height), (a = this._vertAxis) == null || a.addGridRules(this._chartLayers.width));
  }
  get _shouldAddLegend() {
    return this._store.settings.legend.isDrawLegend && (this._store.settings.legend.isAlwaysDrawLegend || this._directLabelStrip && this._store.settings.chart.hasLegendWithDirectLabels || !this._directLabelStrip && this._store.model.multi);
  }
  settingDidChange(e, r, n) {
    this._chartInfo.settingDidChange(e, r, n), ["chart.size.width", "chart.size.height", "chart.fontScale"].includes(e) && this._createGrid(), super.settingDidChange(e, r, n);
  }
  async storeDidChange(e, r) {
    return await super.storeDidChange(e, r), this._chartInfo.storeDidChange(e, r);
  }
  // noticePosted(key: string, value: any): void {
  //   this.log.info('NOTICE', key);
  //   if (key === 'animRevealEnd') {
  //     const shouldAddDirectLabelStrip = this._store.settings.chart.hasDirectLabels
  //       && this.type === 'line'
  //       && /*this._chartLayers.dataLayer.settings.isAlwaysShowSeriesLabel || */
  //         this._store.model!.multi;
  //     if (shouldAddDirectLabelStrip) {
  //       const horizAxisPos = this._store.settings.axis.horiz.position;
  //       const plotRow = (this._chartInfo.axisInfo && horizAxisPos === 'north'
  //         ? 1
  //         : 0) + (this._titleLabel ? 1 : 0);
  //       this.log.info('PLOT ROW', plotRow);
  //       // this._directLabelStrip = new DirectLabelStrip(this._chartLayers.dataLayer as LinePlotView);
  //       // this._grid.append(this._directLabelStrip, {
  //       //   x: 2,
  //       //   y: plotRow,
  //       //   height: 1
  //       // });
  //     }
  //   }
  // }
  get chartInfo() {
    return this._chartInfo;
  }
  _createId() {
    return "doc-view";
  }
  get role() {
    return "graphics-document";
  }
  get roleDescription() {
    return `${this.type} chart`;
  }
  get chartLayers() {
    return this._chartLayers;
  }
  get titleText() {
    return this._titleText;
  }
  setTitleText(e) {
    this._titleText = e ?? this._store.settings.chart.title.text ?? "[TITLE]", this._titleLabel && (this._titleLabel.text = this._titleText);
  }
  get horizAxis() {
    return this._horizAxis;
  }
  get vertAxis() {
    return this._vertAxis;
  }
  get xAxis() {
    return this.getAxisForCoord("x");
  }
  get yAxis() {
    return this.getAxisForCoord("y");
  }
  getAxisForCoord(e) {
    var r, n;
    if (((r = this._horizAxis) == null ? void 0 : r.coord) === e)
      return this._horizAxis;
    if (((n = this._vertAxis) == null ? void 0 : n.coord) === e)
      return this._vertAxis;
    this.log.info("no axis!", this._horizAxis, this._vertAxis, e);
  }
  /*protected get _hotkeyActions() {
      return hotkeyActions.global;
    }
  
    get keymap() {
      return keymaps.global;
    }*/
  createTitle() {
    const e = this._store.settings.chart.title.align ?? "center";
    this._titleLabel = new fi(this.paraview, {
      id: "chart-title",
      role: "heading",
      classList: ["chart-title"],
      text: this._titleText,
      wrapWidth: this._grid.width,
      justify: e
    }), this._titleLabel.canHeightFlex = !1;
    let r = 0;
    this._store.settings.chart.title.margin, this._store.settings.chart.title.position, this._store.settings.chart.title.position === "top" ? this._grid.insertRow(0, this._store.settings.chart.title.margin) : (this._grid.insertRow(this._grid.numRows, this._store.settings.chart.title.margin), r = this._grid.numRows), this._grid.append(this._titleLabel, {
      x: 0,
      y: r,
      colAlign: e,
      width: 4
      // margin: {
      //   top: titlePos === 'top' ? 0 : titleMargin,
      //   bottom: titlePos === 'bottom' ? 0 : titleMargin
      // }
    });
  }
  computeSize() {
    return [this._grid.width, this._grid.height];
  }
  _childDidResize(e) {
    this.updateSize(!1);
  }
  _boundingSizeDidChange() {
    this.paraview.computeViewBox();
  }
  /*updateAllKeymaps() {
    const update = (v: View) => {
      v.updateKeymap();
      v.children.forEach(update);
    };
    update(this);
  }*/
  addLegend(e) {
    const r = this._chartInfo.legend(), n = this._store.settings.legend.margin;
    e === "east" ? (this._legends.east = new a1(this.paraview, r), this._grid.append(this._legends.east, {
      x: 3,
      y: 1,
      height: 1
      //margin: {left: margin}
    }), this._grid.setColGap(this._directLabelStrip ? 2 : 1, n)) : e === "west" ? (this._legends.west = new a1(this.paraview, r), this._grid.addColumnLeft(), this._grid.append(this._legends.west, {
      x: 0,
      y: 0,
      height: 2
      //margin: {right: margin}
    })) : e === "south" ? (this._legends.south = new a1(this.paraview, r, {
      orientation: "horiz",
      wrapWidth: this._chartLayers.paddedWidth
    }), this._grid.insertRow(this._grid.numRows), this._grid.append(this._legends.south, {
      x: 1,
      y: -1,
      width: 1,
      colAlign: "center"
      //margin: {top: margin}
    })) : e === "north" && (this._legends.north = new a1(this.paraview, r, {
      orientation: "horiz",
      wrapWidth: this._chartLayers.paddedWidth
    }), this._grid.insertRow(this._store.settings.chart.title.isDrawTitle && this._store.title ? 1 : 0), this._grid.append(this._legends.north, {
      x: 1,
      y: 0,
      width: 1,
      colAlign: "center"
      //margin: {bottom: margin}
    }));
  }
}
var g7e = Object.defineProperty, m7e = Object.getOwnPropertyDescriptor, bo = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? m7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && g7e(e, r, i), i;
};
let Ji = class extends ts {
  constructor() {
    super(), this.type = "bar", this.contrastLevel = 1, this.disableFocus = !1, this._rootRef = Et(), this._defsRef = Et(), this._frameRef = Et(), this._dataspaceRef = Et(), this.loadingMessageRectRef = Et(), this.loadingMessageTextRef = Et(), this.log = qt("ParaView"), this.loadingMessageStyles = {
      display: "none"
    }, this._chartRefs = /* @__PURE__ */ new Map(), this._fileSavePlaceholderRef = Et(), this._pointerEventManager = null, this._defs = {}, this._jim = "", this._lowVisionModeSaved = /* @__PURE__ */ new Map(), this._hotkeyListener = (t) => {
      const e = this.paraChart.api.actions[t.action];
      e ? e(t.args) : this.log.warn(`no handler for action '${t.action}'`);
    }, this._jimReadyPromise = new Promise((t, e) => {
      this._jimReadyResolver = t, this._jimReadyRejector = e;
    });
  }
  get viewBox() {
    return this._viewBox;
  }
  get root() {
    return this._rootRef.value;
  }
  get frame() {
    return this._frameRef.value;
  }
  get dataspace() {
    return this._dataspaceRef.value;
  }
  get documentView() {
    return this._documentView;
  }
  get prevFocusLeaf() {
    return this._prevFocusLeaf;
  }
  set prevFocusLeaf(t) {
    this._prevFocusLeaf = t;
  }
  get fileSavePlaceholder() {
    return this._fileSavePlaceholderRef.value;
  }
  get defs() {
    return this._defs;
  }
  async jimReady() {
    await this._jimReadyPromise, this._jimReadyPromise = new Promise((t, e) => {
      this._jimReadyResolver = t, this._jimReadyRejector = e;
    });
  }
  get pointerEventManager() {
    return this._pointerEventManager;
  }
  connectedCallback() {
    super.connectedCallback(), this._controller ?? (this._controller = new fAe(this._store)), this._storeChangeUnsub = this._store.subscribe(async (t, e) => {
      var r;
      t === "data" && await this.dataUpdated(), await ((r = this._documentView) == null ? void 0 : r.storeDidChange(t, e));
    }), this.computeViewBox(), this._store.keymapManager.addEventListener("hotkeypress", this._hotkeyListener), this._store.settings.chart.isStatic || (this._pointerEventManager = new gAe(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._storeChangeUnsub(), this._store.keymapManager.removeEventListener("hotkeyPress", this._hotkeyListener);
  }
  // Anything that needs to be done when data is updated, do here
  async dataUpdated() {
    this.createDocumentView(), this.paraChart.headless && await this.addJIMSeriesSummaries(), this._jim = this._store.jimerator ? JSON.stringify(this._store.jimerator.jim, void 0, 2) : "", this._jimReadyResolver();
  }
  willUpdate(t) {
    t.has("width") && this.computeViewBox(), t.has("chartTitle") && this.documentView && this.documentView.setTitleText(this.chartTitle), t.has("xAxisLabel") && this.documentView && this.documentView.xAxis.setAxisLabelText(this.xAxisLabel), t.has("yAxisLabel") && this.documentView && this.documentView.yAxis.setAxisLabelText(this.yAxisLabel);
  }
  firstUpdated(t) {
    this.log.info("ready"), this.dispatchEvent(new CustomEvent("paraviewready", { bubbles: !0, composed: !0, cancelable: !0 }));
  }
  settingDidChange(t, e, r) {
    var n;
    if ((n = this._documentView) == null || n.settingDidChange(t, e, r), t === "ui.isFullscreenEnabled") {
      if (r && !document.fullscreenElement)
        try {
          this.root.requestFullscreen();
        } catch {
          this.log.error("failed to enter fullscreen"), this._store.updateSettings((i) => {
            i.ui.isFullscreenEnabled = !1;
          }, !0);
        }
      else if (!r && document.fullscreenElement)
        try {
          document.exitFullscreen();
        } catch {
          this.log.error("failed to exit fullscreen"), this._store.updateSettings((i) => {
            i.ui.isFullscreenEnabled = !0;
          }, !0);
        }
    } else if (t === "ui.isLowVisionModeEnabled")
      r ? this._store.colors.selectPaletteWithKey("low-vision") : this._store.colors.prevSelectedColor.length > 0 && this._store.colors.selectPaletteWithKey(this._store.colors.prevSelectedColor), this._store.updateSettings((i) => {
        this._store.announce(`Low vision mode ${r ? "enabled" : "disabled"}`), i.color.isDarkModeEnabled = !!r, i.ui.isFullscreenEnabled = !!r, r ? (this._lowVisionModeSaved.set("animation.isAnimationEnabled", i.animation.isAnimationEnabled), this._lowVisionModeSaved.set("chart.fontScale", i.chart.fontScale), this._lowVisionModeSaved.set("grid.isDrawVertLines", i.grid.isDrawVertLines), this._documentView.chartLayers.dataLayer.stopAnimation(), i.animation.isAnimationEnabled = !1, i.chart.fontScale = 2, i.grid.isDrawVertLines = !0) : (i.animation.isAnimationEnabled = this._lowVisionModeSaved.get("animation.isAnimationEnabled"), i.chart.fontScale = this._lowVisionModeSaved.get("chart.fontScale"), i.grid.isDrawVertLines = this._lowVisionModeSaved.get("grid.isDrawVertLines"), this._lowVisionModeSaved.clear());
      });
    else if (t === "ui.isVoicingEnabled")
      if (this._store.settings.ui.isVoicingEnabled)
        if (this._store.settings.ui.isNarrativeHighlightEnabled)
          (async () => this._store.announce(await this._documentView.chartInfo.summarizer.getChartSummary()))();
        else {
          const i = ["Self-voicing enabled."], s = this.paraChart.ariaLiveRegion.lastAnnouncement;
          s && i.push(s), this._store.announce(i);
        }
      else
        this.paraChart.ariaLiveRegion.voicing.shutUp(), this.paraChart.ariaLiveRegion.voicing.speak("Self-voicing disabled.", []);
    else if (t === "ui.isNarrativeHighlightEnabled")
      if (this._store.settings.ui.isNarrativeHighlightEnabled)
        if (this._store.settings.ui.isVoicingEnabled) {
          this.startNarrativeHighlightMode();
          const i = this.paraChart.ariaLiveRegion.lastAnnouncement, s = ["Narrative Highlights Mode enabled."];
          i && s.push(i), this._store.announce(s), (async () => this._store.announce(await this._documentView.chartInfo.summarizer.getChartSummary()))();
        } else {
          this._store.updateSettings((o) => {
            o.ui.isVoicingEnabled = !0;
          }), this.startNarrativeHighlightMode();
          const i = this.paraChart.ariaLiveRegion.lastAnnouncement, s = ["Narrative Highlights Mode enabled."];
          i && s.push(i), this._store.announce(s), (async () => this._store.announce(await this._documentView.chartInfo.summarizer.getChartSummary()))();
        }
      else
        this.endNarrativeHighlightMode(), this._store.updateSettings((i) => {
          i.ui.isVoicingEnabled = !1;
        }), this._store.announce(["Narrative Highlight Mode disabled."]);
    else t === "ui.isNarrativeHighlightPaused" && this.paraChart.ariaLiveRegion.voicing.togglePaused();
  }
  _onFullscreenChange() {
    document.fullscreenElement ? this._store.settings.ui.isFullscreenEnabled || this._store.updateSettings((t) => {
      t.ui.isFullscreenEnabled = !0;
    }, !0) : this._store.settings.ui.isLowVisionModeEnabled ? this._store.updateSettings((t) => {
      t.ui.isLowVisionModeEnabled = !1;
    }) : this._store.settings.ui.isFullscreenEnabled && this._store.updateSettings((t) => {
      t.ui.isFullscreenEnabled = !1;
    }, !0);
  }
  /*protected updated(changedProperties: PropertyValues) {
    this.log.info('canvas updated');
    if (changedProperties.has('dataState')) {
      if (this.dataState === 'pending') {
        const bbox = this._rootRef.value!.getBoundingClientRect();
        const textLength = bbox.width / 3;
        const fontSize = 20;
        const rectHPadding = 5;
        const rectVPadding = 3;
        const rectWidth = textLength + rectHPadding * 2;
        const rectHeight = fontSize + rectVPadding * 2;
        this.loadingMessageRectRef.value!.setAttribute('x', `${bbox.width / 2 - rectWidth / 2}`);
        this.loadingMessageRectRef.value!.setAttribute('y', `${bbox.height / 2}`);
        this.loadingMessageRectRef.value!.setAttribute('width', `${rectWidth}`);
        this.loadingMessageRectRef.value!.setAttribute('height', `${rectHeight}`);
        this.loadingMessageTextRef.value!.setAttribute('x', `${bbox.width / 2 - textLength / 2}`);
        this.loadingMessageTextRef.value!.setAttribute('y', `${bbox.height / 2 + fontSize}`);
        this.loadingMessageTextRef.value!.setAttribute('textLength', `${textLength}`);
        this.loadingMessageStyles = {
          'font-size': `${fontSize}px`,
          color: 'black'
        };
      } else if (this.dataState === 'complete') {
        this.loadingMessageStyles = {
          display: 'none'
        };
        //this.todo.signalManager.signal('canvasDataLoadComplete');
        // this.isReady = true;
      }
    }
  }*/
  ref(t) {
    return this._chartRefs.has(t) || this._chartRefs.set(t, Et()), this._chartRefs.get(t);
  }
  unref(t) {
    if (t.endsWith("*")) {
      const e = t.slice(0, -1);
      for (const r of this._chartRefs.keys())
        r.startsWith(e) && this._chartRefs.delete(r);
    } else if (this._chartRefs.has(t))
      this._chartRefs.delete(t);
    else
      throw new Error(`no ref for key '${t}'`);
  }
  startNarrativeHighlightMode() {
    this._store.updateSettings((t) => {
      t.ui.isVoicingEnabled = !0;
    }), this._store.updateSettings((t) => {
      t.chart.showPopups = !0;
    });
  }
  endNarrativeHighlightMode() {
    this._store.updateSettings((t) => {
      t.ui.isVoicingEnabled = !1, t.chart.showPopups = !1;
    });
  }
  createDocumentView() {
    this.log.info("creating document view", this.type), this._documentView = new f7e(this), this.computeViewBox(), this.paraChart.styleManager.update();
  }
  computeViewBox() {
    this._viewBox = {
      x: 0,
      y: 0,
      width: this._store.settings.chart.size.width,
      height: this._store.settings.chart.size.height
    }, this.log.info("view box:", this._viewBox.width, "x", this._viewBox.height);
  }
  updateViewbox(t, e, r, n) {
    this.viewBox.x = t ?? this.viewBox.x, this.viewBox.y = e ?? this.viewBox.y, this.viewBox.width = r ?? this.viewBox.width, this.viewBox.height = n ?? this.viewBox.height;
  }
  // updateDefs(el: SVGLinearGradientElement) {
  //   this._defsRef.value!.appendChild(el);
  // }
  async addJIMSeriesSummaries() {
    var r;
    const t = this._documentView.chartInfo.summarizer, e = ((r = this._store.model) == null ? void 0 : r.originalSeriesKeys) || [];
    for (const n of e) {
      const i = await t.getSeriesSummary(Yn(n)), s = typeof i == "string" ? i : i.text;
      this._store.jimerator.addSeriesSummary(n, s);
    }
  }
  serialize() {
    var s, o;
    const t = this.root.cloneNode(!0);
    t.id = "para" + (((o = (s = window.crypto).randomUUID) == null ? void 0 : o.call(s)) ?? "");
    const e = this.paraChart.extractStyles(t.id) + `
` + this.extractStyles(t.id), r = document.createElementNS(Cp, "style");
    r.textContent = e, t.prepend(r);
    const n = [], i = (a) => {
      for (const l of a)
        l instanceof Comment ? n.push(l) : l.childNodes.length && i(l.childNodes);
    };
    return i(t.childNodes), n.forEach((a) => a.remove()), t.removeAttribute("width"), t.removeAttribute("height"), t.removeAttribute("role"), new XMLSerializer().serializeToString(t).split(`
`).filter((a) => !a.match(/^\s*$/)).join(`
`);
  }
  downloadSVG() {
    const t = this.serialize(), e = new Blob([t], {
      type: "image/svg+xml;charset=utf-8"
    }), r = URL.createObjectURL(e);
    this.downloadContent(r, "svg"), URL.revokeObjectURL(r);
  }
  downloadPNG() {
    const t = this.serialize(), e = new Blob([t], {
      type: "image/svg+xml;charset=utf-8"
    }), r = URL.createObjectURL(e), n = new Image();
    n.addEventListener("load", () => {
      const i = this._rootRef.value.getBBox(), s = document.createElement("canvas");
      s.width = i.width, s.height = i.height, s.getContext("2d").drawImage(n, 0, 0, i.width, i.height), URL.revokeObjectURL(r), s.toBlob((a) => {
        if (a) {
          const l = URL.createObjectURL(a);
          this.downloadContent(l, "png"), URL.revokeObjectURL(l);
        } else
          throw new Error("failed to create image download blob");
      });
    }), n.src = r;
  }
  downloadContent(t, e) {
    const r = document.createElement("a");
    this.fileSavePlaceholder.appendChild(r);
    const n = this._documentView.titleText || "parachart";
    r.download = `${n.replace(/\W/g, "_")}.${e}`, r.href = t, r.click(), r.remove();
  }
  addDef(t, e) {
    if (this._defs[t])
      throw new Error("view already in defs");
    this.log.info("ADDING DEF", t), this._defs = { ...this._defs, [t]: e }, this.requestUpdate();
  }
  _rootStyle() {
    const t = {
      fontFamily: this._store.settings.chart.fontFamily,
      fontWeight: this._store.settings.chart.fontWeight
    };
    if (document.fullscreenElement === this.root) {
      const r = Math.round(this._viewBox.width), n = Math.round(this._viewBox.height), i = Math.min(r, n) / Math.max(r, n) * 100;
      r > n ? (t.width = "100vw", t.height = `${i}vh`) : (t.width = `${i}vw`, t.height = "100vh");
    }
    const e = this.store.settings.color.contrastLevel * 50;
    return this._store.settings.color.isDarkModeEnabled ? (t["--axis-line-color"] = `hsl(0, 0%, ${50 + e}%)`, t["--label-color"] = `hsl(0, 0%, ${50 + e}%)`, t["--background-color"] = `hsl(0, 0%, ${(100 - e) / 5 - 10}%)`) : (t["--axis-line-color"] = `hsl(0, 0%, ${50 - e}%)`, t["--label-color"] = `hsl(0, 0%, ${50 - e}%)`), t;
  }
  _rootClasses() {
    return {
      darkmode: this._store.settings.color.isDarkModeEnabled
    };
  }
  navToDatapoint(t, e) {
    this._documentView.chartInfo.navToDatapoint(t, e);
  }
  render() {
    var t, e;
    return this.log.info("render"), We`
      <svg
        role="application"
        tabindex=${this.disableFocus ? -1 : 0}
        aria-label=${this._documentView ? `${this._documentView.titleText}, accessible chart` : "loading..."}
        ${yt(this._rootRef)}
        xmlns=${Cp}
        data-charttype=${this.paraChart.type ?? this.type}
        width=${nt`${this._viewBox.width}px`}
        height=${nt`${this._viewBox.height}px`}
        class=${Br(this._rootClasses())}
        viewBox=${nt`${this._viewBox.x} ${this._viewBox.y} ${this._viewBox.width} ${this._viewBox.height}`}
        style=${mn(this._rootStyle())}
        @fullscreenchange=${() => this._onFullscreenChange()}
        @focus=${() => {
      this._store.settings.chart.isStatic;
    }}
        @keydown=${(r) => this._controller.handleKeyEvent(r)}
        @pointerdown=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleStart(r);
    }}
        @pointerup=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleEnd(r);
    }}
        @pointercancel=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleCancel(r);
    }}
        @pointermove=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleMove(r);
    }}
        @pointerleave=${(r) => l8e(this, r) ? void 0 : this.requestUpdate()}
        @click=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleClick(r);
    }}
        @dblclick=${(r) => {
      var n;
      return (n = this._pointerEventManager) == null ? void 0 : n.handleDoubleClick(r);
    }}
      >
        <defs
          ${yt(this._defsRef)}
        >
          ${Object.entries(this._defs).map(([r, n]) => n)}
          ${(t = this._documentView) != null && t.horizAxis ? Tt`
            <clipPath id="clip-path">
              <rect
                x=${0}
                y=${0}
                width=${this.clipWidth ?? this._documentView.chartLayers.width}
                height=${this._documentView.chartLayers.height}>
              </rect>
            </clipPath>
          ` : ""}
        </defs>
        <metadata data-type="text/jim+json">
          ${this._jim}
        </metadata>
        <rect
          ${yt(this._frameRef)}
          id="frame"
          class=${Ne}
          pointer-events="all"
          x="0"
          y="0"
          width="100%"
          height="100%"
        >
        </rect>
        ${((e = this._documentView) == null ? void 0 : e.render()) ?? ""}
      </svg>
      <div
        ${yt(this._fileSavePlaceholderRef)}
        hidden
      ></div>
    `;
  }
};
Ji.styles = [
  //styles,
  Nt`
      #frame {
        fill: var(--background-color);
        stroke: none;
      }
      #frame.pending {
        fill: lightgray;
      }
      .darkmode {
        --axis-line-color: ghostwhite;
        --label-color: ghostwhite;
        --background-color: black;
      }
      #loading-message {
        fill: black;
      }
      #loading-message text {
        fill: white;
      }
      .grid-horiz {
        stroke: var(--axis-line-color);
        opacity: 0.2;
      }
      .grid-vert {
        stroke: var(--axis-line-color);
        opacity: 0.2;
      }
      #grid-zero {
        opacity: 0.6;
        stroke-width: 2;
      }
      .tick {
        stroke: var(--label-color);
      }
      .chart-title {
        font-size: calc(var(--chart-title-font-size)*var(--chart-font-scale));
      }
      .axis-title-horiz {
        font-size: calc(var(--horiz-axis-title-font-size)*var(--chart-font-scale));
      }
      .axis-title-vert {
        font-size: calc(var(--vert-axis-title-font-size)*var(--chart-font-scale));
      }
      .direct-label {
        font-size: calc(var(--direct-label-font-size)*var(--chart-font-scale));
      }
      .legend-label {
        font-size: calc(var(--legend-label-font-size)*var(--chart-font-scale));
      }
      .label {
        fill: var(--label-color);
        stroke: none;
      }
      .label-bg {
        fill: lightgray;
      }
      .tick-label-horiz {
        font-size: calc(var(--horiz-axis-tick-label-font-size)*var(--chart-font-scale));
      }
      .tick-label-vert {
        font-size: calc(var(--vert-axis-tick-label-font-size)*var(--chart-font-scale));
      }
      .bar-label {
        font-size: calc(var(--bar-label-font-size)*var(--chart-font-scale));
        fill: white;
      }
      .bar-total-label {
        font-size: calc(var(--bar-label-font-size)*var(--chart-font-scale));
      }
      .column-label {
        font-size: calc(var(--column-label-font-size)*var(--chart-font-scale));
        fill: white;
      }
      .column-total-label {
        font-size: calc(var(--column-label-font-size)*var(--chart-font-scale));
                background-color: red;
      }
      .pastry-inside-label {
      }
      .pastry-outside-label-leader {
        fill: none;
        stroke-width: 2;
      }
      .pastry-slice {
        stroke: white;
        stroke-width: 2;
      }
      .label-leader {
        stroke-width: 2;
      }
      #vert-axis-line {
        fill: none;
        stroke: var(--axis-line-color);
        stroke-width: 2px;
        stroke-linecap: round;
      }
      #horiz-axis-line {
        fill: none;
        stroke: var(--axis-line-color);
        opacity: 1;
        stroke-width: 2px;
        stroke-linecap: round;
      }
      rect#data-backdrop {
        stroke: none;
        fill: none; /*lightgoldenrodyellow;*/
        /*opacity: 0.5;*/
        pointer-events: all;
      }
      .symbol {
        /*stroke-width: 2;*/
        stroke-linejoin: round;
      }
      .symbol.outline {
        fill: white;
      }
      use.visited-mark {
       pointer-events: none;
      }
      .bar {
        stroke-width: 0;
      }
      .data-line {
        fill: none;
        /*stroke-width: 3px;*/
        stroke-linecap: round;
      }
      .range-highlight {
        fill: silver;
        opacity: 0.5;
      }
      .linebreaker-marker {
        fill: hsl(0, 17.30%, 37.50%);
      }
      .user-linebreaker-marker {
        fill: hsl(0, 87%, 48%);
      }
      .trend-line{
        display: inline;
        stroke-width: 8px;
        stroke-linecap: butt;
        stroke-dasharray: 12 12;
        stroke-opacity: 0.8;
      }
      .user-trend-line{
        display: inline;
        stroke-width: 8px;
        stroke-linecap: butt;
        stroke-dasharray: 12 12;
        stroke-opacity: 0.8;
      }
      .datapoint.visited:not(.highlighted) {
        stroke: var(--visited-color);
        fill: var(--visited-color);
        stroke-width: var(--visited-stroke-width);
      }
      .datapoint.highlighted {
/*        stroke: var(--highlighted-color);
        fill: var(--highlighted-color);
        stroke-width: var(--visited-stroke-width); */
      }
      .lowlight {
        opacity: 0.20;
      }
      .hidden {
        display: none;
      }
      .invis {
        opacity: 0;
      }
      .control-column {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-start;
        gap: 0.5em;
      }
      .debug-grid-territory {
        fill: lightblue;
        stroke: blue;
        stroke-width: 2;
        opacity: 0.5;
      }
    `
];
bo([
  Ke()
], Ji.prototype, "type", 2);
bo([
  Ke()
], Ji.prototype, "chartTitle", 2);
bo([
  Ke()
], Ji.prototype, "xAxisLabel", 2);
bo([
  Ke()
], Ji.prototype, "yAxisLabel", 2);
bo([
  Ke()
], Ji.prototype, "contrastLevel", 2);
bo([
  Ke({ type: Boolean })
], Ji.prototype, "disableFocus", 2);
bo([
  Ke()
], Ji.prototype, "clipWidth", 2);
bo([
  Ur()
], Ji.prototype, "loadingMessageStyles", 2);
bo([
  Ur()
], Ji.prototype, "_defs", 2);
bo([
  Ur()
], Ji.prototype, "_jim", 2);
Ji = bo([
  Dt("para-view")
], Ji);
class NV extends ts {
  constructor() {
    super(...arguments), this.log = qt("SettingControlContainer");
  }
  connectedCallback() {
    super.connectedCallback(), this._controlsState = new S5(this, this._store.settingControls);
  }
}
const Vk = class Vk extends NV {
  get controlPanel() {
    return this._controlPanel;
  }
  set controlPanel(e) {
    this._controlPanel = e, this.store = e.store;
  }
};
Vk.styles = [
  Nt`
      .tab-content {
        display: flex;
        flex-direction: row;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
        padding: 0.2rem;
      }

      .tab-content.stacked {
        flex-direction: column;
        gap: 0.1rem;
        align-items: flex-start;
        justify-content: space-between;
        padding: 0.5rem 0.2rem;
      }
    `
];
let xn = Vk;
var y7e = Object.getOwnPropertyDescriptor, v7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? y7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let pE = class extends xn {
  render() {
    return We`   
      <div class="tab-content">
        <div
          class="setting-views"
        >
          <slot name="settings">
            <span id="settings"> </span>
          </slot>
        </div>
      </div>
    `;
  }
};
pE.styles = [
  //styles,
  Nt`
    `
];
pE = v7e([
  Dt("para-analysis-panel")
], pE);
var b7e = Object.getOwnPropertyDescriptor, w7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? b7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let dE = class extends xn {
  constructor() {
    super();
  }
  showAnnotations() {
    return We`
      <ol class="annotations">
        ${this._store.annotations.map((t) => We`
            <li
              data-series="${t.seriesKey}"
              data-index="${t.index}"
              @click=${(e) => {
      t.isSelected = !t.isSelected, this._selectAnnotation(e);
    }}
              @dblclick=${(e) => {
      this._store.annotations = this._store.annotations.filter((r) => r.id != t.id);
    }}
            >${t.annotation}</li>
          `)}
      </ol>
    `;
  }
  _selectAnnotation(t) {
    const e = t == null ? void 0 : t.target;
    if (e && (this._highlightAnnotation(e), e.dataset.series && e.dataset.index)) {
      const r = e.dataset.series, n = parseInt(e.dataset.index);
      this._navToAnnotation(r, n);
    }
  }
  _highlightAnnotation(t) {
    var e;
    for (const r of (e = t.parentElement) == null ? void 0 : e.children)
      r.classList.remove("selected");
    t.classList.add("selected"), t.scrollIntoView(!1);
  }
  _navToAnnotation(t, e) {
    this._controlPanel.paraChart.paraView.navToDatapoint(t, e);
  }
  render() {
    return We`
      <div id="annotation-tab" class="tab-content">
        <section id="annotations">
          ${this.showAnnotations()}
        </section>
        <div>
          <button
            @click=${() => {
      this._store.addAnnotation();
    }}
          >
            Add Annotation
          </button>
        </div>
        <div> 
          <button
            @click=${() => {
      this._store.addUserLineBreaks();
    }}
          >
            Add Line breaks
          </button>
        </div>
         <div>
          <button
            @click=${() => {
      this._store.clearUserLineBreaks(), this._store.clearUserTrendLines();
    }}
          >
            Remove added line breaks
          </button>
        </div>
         <div>
          <button
            @click=${() => {
      this._store.updateSettings((t) => {
        t.controlPanel.isMDRAnnotationsVisible = !this._store.settings.controlPanel.isMDRAnnotationsVisible;
      }), this._store.showMDRAnnotations();
    }}
          >
            Show Trend Annotations
          </button>
        </div>
      </div>
    `;
  }
};
dE.styles = [
  ...xn.styles,
  Nt`
      :host {
        --zebraStripe: hsl(0, 0%, 85%);
      }

      ol.annotations {
        padding-inline-start: 1.5rem;
        max-height: 6rem;
        overflow-y: scroll;
      }

      ol.annotations li {
        cursor: pointer;
        padding: 4px;
      }

      ol.annotations li:nth-child(even) {
        background-color: var(--zebraStripe);
      }

      ol.annotations li.selected {
        font-weight: bold;
        background-color: var(--theme-color-light);
      }
    `
];
dE = w7e([
  Dt("para-annotation-panel")
], dE);
var x7e = Object.defineProperty, E7e = Object.getOwnPropertyDescriptor, DV = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? E7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && x7e(e, r, i), i;
};
let P2 = class extends NV {
  constructor() {
    super(...arguments), this._dialogRef = Et(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isNotificationEnabled",
      label: "Notification sounds",
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "slider",
      key: "sonification.hertzLower",
      label: "Lower hertz",
      options: {
        min: 0,
        max: K4.length - 1,
        highBound: this._store.settings.sonification.hertzUpper - 1,
        step: 1
      },
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "slider",
      key: "sonification.hertzUpper",
      label: "Upper hertz",
      options: {
        min: 0,
        max: K4.length - 1,
        lowBound: this._store.settings.sonification.hertzLower + 1,
        step: 1
      },
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isRiffEnabled",
      label: "Series riff enabled",
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isArpeggiateChords",
      label: "Chords are arpeggiated",
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    }), this._store.settingControls.add({
      type: "slider",
      key: "sonification.riffSpeedIndex",
      label: "Riff speed",
      options: {
        min: 0,
        max: rV.length - 1,
        step: 1
      },
      parentView: "controlPanel.tabs.audio.sonification.dialog"
    });
  }
  render() {
    return We`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="Sonification Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        ${this._store.settingControls.getContent("controlPanel.tabs.audio.sonification.dialog")}
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show();
  }
};
P2.styles = Nt`
  `;
DV([
  Ke()
], P2.prototype, "btnText", 2);
P2 = DV([
  Dt("para-soni-settings-dialog")
], P2);
var S7e = Object.defineProperty, A7e = Object.getOwnPropertyDescriptor, $V = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? A7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && S7e(e, r, i), i;
};
let R2 = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("AdvancedControlSettingsDialog"), this._dialogRef = Et(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "radio",
      key: "controlPanel.tabLabelStyle",
      label: "Tab label style",
      options: {
        buttons: {
          icon: {
            label: "Icon only"
          },
          iconLabel: {
            label: "Icon and label"
          },
          label: {
            label: "Label only"
          }
        },
        layout: "horiz"
      },
      parentView: "controlPanel.tabs.controls.dialog.tabLabels"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.isCaptionVisible",
      label: "Caption visible",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.isExplorationBarVisible",
      label: "Exploration bar visible",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.caption.isCaptionExternalWhenControlPanelClosed",
      label: "Caption external when control panel closed",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "controlPanel.caption.isExplorationBarBeside",
      label: "Exploration bar is beside caption",
      parentView: "controlPanel.tabs.controls.dialog.settings"
    });
  }
  render() {
    return We`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="Advanced Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        <div id="controls">
          <div id="advanced"
            class="advanced-views"
          >
            ${this._store.settingControls.getContent("controlPanel.tabs.controls.dialog.settings")}
          </div>
          <div>
            ${this._store.settingControls.getContent("controlPanel.tabs.controls.dialog.tabLabels")}
          </div>
        </div>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
R2.styles = Nt`
    #controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  `;
$V([
  Ke()
], R2.prototype, "btnText", 2);
R2 = $V([
  Dt("para-advanced-control-settings-dialog")
], R2);
var k7e = Object.defineProperty, _7e = Object.getOwnPropertyDescriptor, jV = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? _7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && k7e(e, r, i), i;
};
let O2 = class extends ts {
  constructor() {
    super(...arguments), this._dialogRef = Et(), this.btnText = "Okay";
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.expandPoints",
      label: "Expand points vertically?",
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "animation.animateRevealTimeMs",
      label: "Animation rate",
      options: {
        inputType: "number",
        min: 0,
        max: 1e4
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "radio",
      key: "animation.animationType",
      label: "Animation type",
      options: {
        buttons: {
          uniform: {
            label: "Uniform"
          },
          progressive: {
            label: "Progressive"
          }
        },
        layout: "horiz"
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "radio",
      key: "animation.animationOrigin",
      label: "Animation origin",
      options: {
        buttons: {
          baseline: {
            label: "Bottom"
          },
          top: {
            label: "Top"
          },
          initialValue: {
            label: "Initial Value"
          },
          custom: {
            label: "Custom"
          }
        },
        layout: "horiz"
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "textfield",
      key: "animation.animationOriginValue",
      label: "Animation origin value",
      options: {
        inputType: "number",
        min: 0,
        max: 1e4
      },
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.lineSnake",
      label: "Snake lines from left?",
      parentView: "controlPanel.tabs.controls.dialog.animation"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.symbolPopIn",
      label: "Pop in symbols?",
      parentView: "controlPanel.tabs.controls.dialog.animation"
    });
  }
  render() {
    return We`
      <fizz-dialog
        ${yt(this._dialogRef)}
        title="Animation Settings"
        .buttons=${[{ tag: "cancel", text: this.btnText }]}
      >
        <div id="animation-controls">
          ${this._store.settingControls.getContent("controlPanel.tabs.controls.dialog.animation")}
        </div>
      </fizz-dialog>
    `;
  }
  /**
   * Show the dialog
   */
  async show() {
    await this._dialogRef.value.show(() => this._dialogRef.value.button("cancel").focus());
  }
};
O2.styles = Nt`
    #animation-controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
  `;
jV([
  Ke()
], O2.prototype, "btnText", 2);
O2 = jV([
  Dt("para-animation-dialog")
], O2);
var C7e = Object.getOwnPropertyDescriptor, I7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? C7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let fE = class extends xn {
  constructor() {
    super(...arguments), this._soniDialogRef = Et();
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "checkbox",
      key: "ui.isVoicingEnabled",
      label: "Self-voicing mode",
      parentView: "controlPanel.tabs.audio.voicing"
    }), this._store.settingControls.add({
      type: "slider",
      key: "ui.speechRate",
      label: "Speech rate",
      options: {
        min: 0.5,
        max: 2,
        step: 0.1,
        percent: !0
      },
      parentView: "controlPanel.tabs.audio.voicing"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "ui.isAnnouncementEnabled",
      label: "Announce to screen reader",
      parentView: "controlPanel.tabs.audio.voicing"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "sonification.isSoniEnabled",
      label: "Sonification mode",
      parentView: "controlPanel.tabs.audio.sonification"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "ui.isNarrativeHighlightEnabled",
      label: "Narrative Highlights mode",
      parentView: "controlPanel.tabs.audio.narrative"
    }), this._store.settingControls.add({
      type: "button",
      key: "ui.isNarrativeHighlightPaused",
      label: "Play/Pause Narrative Highlights",
      parentView: "controlPanel.tabs.audio.narrative"
    });
  }
  render() {
    return We`   
      <div class="tab-content">
        <section id="voicing">
          ${this._store.settingControls.getContent("controlPanel.tabs.audio.voicing")}
        </section>
        <section id="narrative">
          ${this._store.settingControls.getContent("controlPanel.tabs.audio.narrative")}
        </section>
        <section id="sonification">
          ${this._store.settingControls.getContent("controlPanel.tabs.audio.sonification")}
          <button
            @click=${() => {
      var t;
      return (t = this._soniDialogRef.value) == null ? void 0 : t.show();
    }}
          >
            Sonification Controls
          </button>
        </section>
      </div>
      <para-soni-settings-dialog
        ${yt(this._soniDialogRef)}
        id="sonification-settings-dialog"
        .store=${this._store}
      ></para-soni-settings-dialog>
    `;
  }
};
fE.styles = [
  ...xn.styles,
  Nt`
      #voicing, 
      #sonification,
      #narrative,
      .control-column {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: flex-start;
        align-items: center;
        gap: 0.5em;
      }
    `
];
fE = I7e([
  Dt("para-audio-panel")
], fE);
var P7e = Object.getOwnPropertyDescriptor, R7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? P7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let gE = class extends xn {
  constructor() {
    super(...arguments), this._popupDialogRef = Et();
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "slider",
      key: "chart.fontScale",
      label: "Font scale",
      options: {
        min: 0.5,
        max: 3,
        step: 0.1,
        showValue: !0
      },
      parentView: "controlPanel.tabs.chart.fonts"
    });
  }
  render() {
    const t = this._store.settingControls.getContent("controlPanel.tabs.chart.chart"), e = this._store.settingControls.getContent("controlPanel.tabs.chart.popups"), r = this._store.settingControls.getContent("controlPanel.tabs.chart.fonts");
    return We`
      <section id="panel">
        <div id="columns">
          <div id="width">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.width")}
          </div>
          <div id="height">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.height")}
          </div>
          <div id="min-y">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.minY")}
          </div>
          <div id="max-y">
            ${this._store.settingControls.getContent("controlPanel.tabs.chart.general.maxY")}
          </div>
          ${t.map((n) => We`
            <div>
              ${n}
            </div>
          `)}
          ${e.map((n) => We`
            <div>
              ${n}
            </div>
          `)}

          <section id="popups">
            <button
              @click=${() => {
      var n;
      (n = this._popupDialogRef.value) == null || n.show();
    }}
            >
              Popup settings
            </button>
            <para-popup-settings-dialog
              ${yt(this._popupDialogRef)}
              id="popup-settings-dialog"
              .store=${this._store}
            >
            </para-popup-settings-dialog>
          </section>
        </div>
        <div>
          ${r}
        </div>
      </section>
    `;
  }
};
gE.styles = [
  ...xn.styles,
  Nt`
      #columns {
        display: grid;
        grid-template-columns: repeat(4, 9rem);
        padding: 0.25rem;
        column-gap: 0.5rem;
        row-gap: 0.5rem;
        align-items: center;
      }
      #width {
        grid-row: 1;
        grid-column: 1;
      }
      #height {
        grid-row: 2;
        grid-column: 1;
      }
      #min-y {
        grid-row: 1;
        grid-column: 2;
      }
      #max-y {
        grid-row: 2;
        grid-column: 2;
      }
      #panel {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: center;
      }
    `
];
gE = R7e([
  Dt("para-chart-panel")
], gE);
const O7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eNormal%20Color%20Vision%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(240,%20100%25,%2043%25);%20}%20.medium%20{%20fill:%20hsl(106,%2058%25,%2041%25);%20}%20.long%20{%20fill:%20hsl(5,%2083%25,%2053%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e", T7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eDeutan%20(Green-Red)%20Color%20Vision%20Deficiency%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(240,%20100%25,%2043%25);%20}%20.medium%20{%20fill:%20none;%20stroke:%20hsl(106,%2058%25,%2041%25);%20stroke-width:%2010px;%20}%20.long%20{%20fill:%20hsl(5,%2083%25,%2053%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M48,71.373C30.563,71.373%2014.622,62.651%205.199,48C14.622,33.349%2030.563,24.627%2048,24.627C65.436,24.627%2081.378,33.349%2090.801,48C81.378,62.651%2065.436,71.373%2048,71.373Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e", L7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eProtan%20(Red-Green)%20Color%20Vision%20Deficiency%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(240,%20100%25,%2043%25);%20}%20.medium%20{%20fill:%20hsl(106,%2058%25,%2041%25);%20}%20.long%20{%20fill:%20none;%20stroke:%20hsl(5,%2083%25,%2053%25);%20stroke-width:%2010px;%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M48,71.373C30.563,71.373%2014.622,62.651%205.199,48C14.622,33.349%2030.563,24.627%2048,24.627C65.436,24.627%2081.378,33.349%2090.801,48C81.378,62.651%2065.436,71.373%2048,71.373Z'/%3e%3c/svg%3e", M7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eTriatan%20(Blue-Yellow)%20Color%20Vision%20Deficiency%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20none;%20stroke:%20hsl(240,%20100%25,%2043%25);%20stroke-width:%2010px;%20}%20.medium%20{%20fill:%20hsl(106,%2058%25,%2041%25);%20}%20.long%20{%20fill:%20hsl(5,%2083%25,%2053%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M48,71.373C30.563,71.373%2014.622,62.651%205.199,48C14.622,33.349%2030.563,24.627%2048,24.627C65.436,24.627%2081.378,33.349%2090.801,48C81.378,62.651%2065.436,71.373%2048,71.373Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e", N7e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20228%2096'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eNormal%20Color%20Vision%3c/title%3e%3cstyle%3e%20path%20{%20fill-rule:%20nonzero;%20stroke:%20white;%20stroke-width:%201px;%20}%20.short%20{%20fill:%20hsl(0,%200%25,%2047%25);%20}%20.medium%20{%20fill:%20hsl(0,%200%25,%2035%25);%20}%20.long%20{%20fill:%20hsl(0,%200%25,%2020%25);%20}%20%3c/style%3e%3cpath%20class='short'%20transform='translate(0,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='medium'%20transform='translate(66,-20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3cpath%20class='long'%20transform='translate(132,20)'%20d='M93.299,47.35C83.481,31.582%2066.547,22.169%2048,22.169C29.452,22.169%2012.518,31.583%202.701,47.351C2.453,47.749%202.453,48.253%202.701,48.651C12.518,64.418%2029.452,73.831%2048,73.831C66.547,73.831%2083.481,64.417%2093.299,48.649C93.547,48.252%2093.547,47.748%2093.299,47.35Z'/%3e%3c/svg%3e";
var D7e = Object.getOwnPropertyDescriptor, $7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? D7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let mE = class extends xn {
  connectedCallback() {
    super.connectedCallback();
    const t = this._store.colors.palettes.filter((e) => !e.cvd).map((e) => e.key);
    this._store.settingControls.add({
      type: "checkbox",
      key: "color.isDarkModeEnabled",
      label: "Dark mode",
      parentView: "controlPanel.tabs.color.colorContrast"
    }), this._store.settingControls.add({
      type: "slider",
      key: "color.contrastLevel",
      label: "Contrast",
      options: {
        min: 0,
        max: 1,
        step: 0.1,
        percent: !0,
        compact: !0
      },
      parentView: "controlPanel.tabs.color.colorContrast"
    }), this._store.settingControls.add({
      type: "radio",
      key: "color.colorVisionMode",
      label: "Chart colors for CVD (color blindness)",
      options: {
        buttons: {
          normal: {
            label: "Normal",
            title: "Trichromat color vision",
            icon: O7e
          },
          deutan: {
            label: "Deutan",
            title: "Green-red color blindness",
            icon: T7e
          },
          protan: {
            label: "Protan",
            title: "Red-green color blindness",
            icon: L7e
          },
          tritan: {
            label: "Tritan",
            title: "Blue-yellow color blindness",
            icon: M7e
          },
          grayscale: {
            label: "Gray",
            title: "Grayscale printing or achromotopsia",
            icon: N7e
          }
        }
      },
      parentView: "controlPanel.tabs.color.colorVision"
    }), this._store.settingControls.add({
      type: "dropdown",
      key: "color.colorPalette",
      label: "Color palette:",
      options: { options: t },
      parentView: "controlPanel.tabs.color.colorPalette"
    }), this._state = new S5(this, this._store.settingControls);
  }
  render() {
    return We`
      <div class="tab-content">
        <div class="control-column">
          ${this._store.settingControls.getContent("controlPanel.tabs.color.colorContrast")}

          ${this.controlPanel.settings.isColorPaletteControlVisible ? this._store.settingControls.getContent("controlPanel.tabs.color.colorPalette") : Ne}
        </div>
        ${this.controlPanel.settings.isCVDControlVisible ? We`
            <div>
              ${this._store.settingControls.getContent("controlPanel.tabs.color.colorVision")}
            </div>
          ` : Ne}
      </div>
    `;
  }
};
mE.styles = [
  ...xn.styles,
  Nt`
      #setting-colorcontrastlevel {
        --width: 6rem;
      }
    `
];
mE = $7e([
  Dt("para-colors-panel")
], mE);
var j7e = Object.getOwnPropertyDescriptor, B7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? j7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let yE = class extends xn {
  constructor() {
    super(...arguments), this._advancedControlDialogRef = Et(), this._animationDialogRef = Et();
  }
  connectedCallback() {
    super.connectedCallback(), this._store.settingControls.add({
      type: "button",
      key: "ui.isFullscreenEnabled",
      label: "Fullscreen",
      parentView: "controlPanel.tabs.controls.fullscreen"
    }), this._store.settingControls.add({
      type: "checkbox",
      key: "animation.isAnimationEnabled",
      label: "Animation enabled",
      parentView: "controlPanel.tabs.controls.animation"
    });
  }
  _getHelp() {
    return We`
      <p>ParaCharts is an accessible data visualization app with multimodal features for different disabilities. You can explore it using the mouse, touchscreen, or keyboard.</p>
      <ul>
        <li>Navigate using the arrow keys:
          <ul>
            <li><b>Right or left arrow keys</b>: move to the next or previous data point in this series</li>
            <li><b>Up or down arrow keys</b>: move to the previous or next data series</li>
          </ul>
        </li>
        <li><b>Enter key</b>: select current data point</li>
        <li><b>Shift + Enter key</b>: add current data point to selection</li>
        <li><b>Q key</b>: get more information about this data point or series, and compare selected data points</li>
        <li><b>S key</b>: toggle sonification on or off</li>
        <li><b>V key</b>: toggle self-voicing on or off</li>
        <li><b>L key</b>: low vision mode</li>
        <li><b>C key</b>: chord mode</li>
        <li>High/low jump keys:
          <ul>
            <li><b>] (right bracket) key</b>: jump to the highest data point in this series</li>
            <li><b>Shift + ] (right bracket) key</b>: jump to the highest data point in the chart</li>
            <li><b>[ (left bracket) key</b>: jump to the lowest data point in this series</li>
            <li><b>Shift + [ (left bracket) key</b>: jump to the lowest data point in the chart</li>
          </ul>
        </li>
        <li><b>Escape key</b> or <b>Control key</b>: stop speaking</li>
        <li><b>H key</b>: open this Help dialog</li>
      </ul>

      <p>Explore the collapsible Control Panel to find many more accessibility features, including options for color blindness, dark mode with fine-grained contrast, self-voicing, SparkBraille tactile support, and more.</p>

      <p>For more details, visit the <a href="https://fizzstudio.github.io/paracharts" target="_blank">ParaCharts Documentation</a>.</p>
    `;
  }
  showHelpDialog() {
    this.controlPanel.dialog.show("Help", this._getHelp());
  }
  _getKeyTable() {
    return We`
      <table>
        <tbody>
          ${Object.entries(eV).map(([t, e]) => We`
              <tr>
                <th scope="row">${e.label}</th>
                <td>${e.hotkeys}</td>
                <td><button disable>edit</button></td>
              </tr>
            `)}
        </tbody>
      </table>
    `;
  }
  render() {
    return We`
      <div id="controls-tab" class="tab-content">
        <div>
          <button
            @click=${() => this.controlPanel.dialog.show("Key Bindings", this._getKeyTable())}
          >
            Keyboard Controls
          </button>
          <button
            @click=${() => this.store.updateSettings((t) => {
      t.ui.isFullscreenEnabled = !0;
    })}
          >
            Fullscreen
          </button>
        </div>

        <div>
          ${this._store.settingControls.getContent("controlPanel.tabs.controls")}
        </div>

        <section id="animation">
          ${this._store.settingControls.getContent("controlPanel.tabs.controls.animation")}
          <button
            @click=${() => {
      var t;
      (t = this._animationDialogRef.value) == null || t.show();
    }}
          >
            Animation settings
          </button>
          <para-animation-dialog
            ${yt(this._animationDialogRef)}
            id="animation-settings-dialog"
            .store=${this._store}
          >
          </para-animation-dialog>
        </section>

        <section id="advanced">
          <button
            @click=${() => this.showHelpDialog()}
          >
            Help
          </button>
          <button
            @click=${() => {
      var t;
      return (t = this._advancedControlDialogRef.value) == null ? void 0 : t.show();
    }}
          >
          Advanced Controls
          </button>
        </section>
      </div>
      <div id="file-save-placeholder" style="display: none;">
      </div>
      <para-advanced-control-settings-dialog
        ${yt(this._advancedControlDialogRef)}
        id="advanced-control-settings-dialog"
        .store=${this._store}
      ></para-advanced-control-settings-dialog>
    `;
  }
};
yE.styles = [
  ...xn.styles,
  Nt`
    `
];
yE = B7e([
  Dt("para-controls-panel")
], yE);
var F7e = Object.getOwnPropertyDescriptor, z7e = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? F7e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = o(i) || i);
  return i;
};
let vE = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("DataTableView");
  }
  render() {
    return this.log.info("MODEL", this.model), We`
      <div class="wrapper">
        <table>
          <thead>
            <tr>
              <th>
                ${this.model.getFacet(this.model.independentFacetKeys[0]).label} // TODO: Assumes exactly 1 indep facet
              </th>
              ${this.model.series.map((t) => We`
                <th scope="col">
                  ${t.key}
                </th>
              `)}
            </tr>
          </thead>
          <tbody>
            ${this.model.series[0].datapoints.map((t, e) => We`
              <tr>
                <td>
                  ${Zf(t, "raw")}
                </td>
                ${this.model.series.map((r) => We`
                  <td>
                    ${bS(r[e], "value")}
                  </td>
                `)}
              </tr>
            `)}
          </tbody>
        </table>
      </div>
    `;
  }
};
vE.styles = [
  Nt`
      th, td {
        padding: 0.25rem;
      }
      thead {
        position: sticky;
        top: 0;
        background: var(--theme-color-light);
      }
      .wrapper {
        overflow: scroll;
        max-height: 15rem;
      }
    `
];
vE = z7e([
  Dt("para-datatable")
], vE);
class U7e {
  constructor(e, r) {
    this.data = e, this.binCount = r, this.init();
  }
  get binnedData() {
    return this._binnedData;
  }
  init() {
    this.findMinMax(), this.binData();
  }
  findMinMax() {
    this.min = Math.min(...this.data), this.max = Math.max(...this.data), this.range = this.max - this.min;
  }
  binData() {
    this._binnedData = [], this._binnedData = this.data.map((e) => Math.min(
      this.binCount - 1,
      Math.floor(this.binCount * (e - this.min) / this.range)
    ));
  }
}
const lO = [[1, 2, 3, 7], [4, 5, 6, 8]];
class V7e {
  constructor(e, r = !1) {
    this.binnedData = e, this.isBar = r, this.cellArray = [], this.init();
  }
  get cells() {
    return this.cellArray;
  }
  init() {
    this.buildGlyphs();
  }
  buildGlyphs() {
    let e = [];
    for (let r = 0; r < this.binnedData.length; ++r) {
      const n = this.binnedData[r], i = r % 2;
      if (e.push(lO[i][3 - n]), this.isBar)
        for (let s = 0; s < n; s++)
          e.push(lO[i][3 - s]);
      (i || this.binnedData.length === r + 1) && (this.cellArray.push(e), e = []);
    }
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Q1 = globalThis, Mk = Q1.ShadowRoot && (Q1.ShadyCSS === void 0 || Q1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Nk = Symbol(), cO = /* @__PURE__ */ new WeakMap();
let BV = class {
  constructor(t, e, r) {
    if (this._$cssResult$ = !0, r !== Nk) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (Mk && t === void 0) {
      const r = e !== void 0 && e.length === 1;
      r && (t = cO.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), r && cO.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const H7e = (t) => new BV(typeof t == "string" ? t : t + "", void 0, Nk), G7e = (t, ...e) => {
  const r = t.length === 1 ? t[0] : e.reduce((n, i, s) => n + ((o) => {
    if (o._$cssResult$ === !0) return o.cssText;
    if (typeof o == "number") return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(i) + t[s + 1], t[0]);
  return new BV(r, t, Nk);
}, W7e = (t, e) => {
  if (Mk) t.adoptedStyleSheets = e.map((r) => r instanceof CSSStyleSheet ? r : r.styleSheet);
  else for (const r of e) {
    const n = document.createElement("style"), i = Q1.litNonce;
    i !== void 0 && n.setAttribute("nonce", i), n.textContent = r.cssText, t.appendChild(n);
  }
}, uO = Mk ? (t) => t : (t) => t instanceof CSSStyleSheet ? ((e) => {
  let r = "";
  for (const n of e.cssRules) r += n.cssText;
  return H7e(r);
})(t) : t;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: q7e, defineProperty: Q7e, getOwnPropertyDescriptor: K7e, getOwnPropertyNames: Y7e, getOwnPropertySymbols: Z7e, getPrototypeOf: J7e } = Object, cd = globalThis, hO = cd.trustedTypes, X7e = hO ? hO.emptyScript : "", pO = cd.reactiveElementPolyfillSupport, n0 = (t, e) => t, T2 = { toAttribute(t, e) {
  switch (e) {
    case Boolean:
      t = t ? X7e : null;
      break;
    case Object:
    case Array:
      t = t == null ? t : JSON.stringify(t);
  }
  return t;
}, fromAttribute(t, e) {
  let r = t;
  switch (e) {
    case Boolean:
      r = t !== null;
      break;
    case Number:
      r = t === null ? null : Number(t);
      break;
    case Object:
    case Array:
      try {
        r = JSON.parse(t);
      } catch {
        r = null;
      }
  }
  return r;
} }, Dk = (t, e) => !q7e(t, e), dO = { attribute: !0, type: String, converter: T2, reflect: !1, hasChanged: Dk };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), cd.litPropertyMetadata ?? (cd.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class _p extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, r = dO) {
    if (r.state && (r.attribute = !1), this._$Ei(), this.elementProperties.set(e, r), !r.noAccessor) {
      const n = Symbol(), i = this.getPropertyDescriptor(e, n, r);
      i !== void 0 && Q7e(this.prototype, e, i);
    }
  }
  static getPropertyDescriptor(e, r, n) {
    const { get: i, set: s } = K7e(this.prototype, e) ?? { get() {
      return this[r];
    }, set(o) {
      this[r] = o;
    } };
    return { get() {
      return i == null ? void 0 : i.call(this);
    }, set(o) {
      const a = i == null ? void 0 : i.call(this);
      s.call(this, o), this.requestUpdate(e, a, n);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? dO;
  }
  static _$Ei() {
    if (this.hasOwnProperty(n0("elementProperties"))) return;
    const e = J7e(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(n0("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(n0("properties"))) {
      const r = this.properties, n = [...Y7e(r), ...Z7e(r)];
      for (const i of n) this.createProperty(i, r[i]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const r = litPropertyMetadata.get(e);
      if (r !== void 0) for (const [n, i] of r) this.elementProperties.set(n, i);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [r, n] of this.elementProperties) {
      const i = this._$Eu(r, n);
      i !== void 0 && this._$Eh.set(i, r);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const r = [];
    if (Array.isArray(e)) {
      const n = new Set(e.flat(1 / 0).reverse());
      for (const i of n) r.unshift(uO(i));
    } else e !== void 0 && r.push(uO(e));
    return r;
  }
  static _$Eu(e, r) {
    const n = r.attribute;
    return n === !1 ? void 0 : typeof n == "string" ? n : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$ES = new Promise((r) => this.enableUpdating = r), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((r) => r(this));
  }
  addController(e) {
    var r;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((r = e.hostConnected) == null || r.call(e));
  }
  removeController(e) {
    var r;
    (r = this._$EO) == null || r.delete(e);
  }
  _$E_() {
    const e = /* @__PURE__ */ new Map(), r = this.constructor.elementProperties;
    for (const n of r.keys()) this.hasOwnProperty(n) && (e.set(n, this[n]), delete this[n]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return W7e(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$EO) == null || e.forEach((r) => {
      var n;
      return (n = r.hostConnected) == null ? void 0 : n.call(r);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null || e.forEach((r) => {
      var n;
      return (n = r.hostDisconnected) == null ? void 0 : n.call(r);
    });
  }
  attributeChangedCallback(e, r, n) {
    this._$AK(e, n);
  }
  _$EC(e, r) {
    var n;
    const i = this.constructor.elementProperties.get(e), s = this.constructor._$Eu(e, i);
    if (s !== void 0 && i.reflect === !0) {
      const o = (((n = i.converter) == null ? void 0 : n.toAttribute) !== void 0 ? i.converter : T2).toAttribute(r, i.type);
      this._$Em = e, o == null ? this.removeAttribute(s) : this.setAttribute(s, o), this._$Em = null;
    }
  }
  _$AK(e, r) {
    var n;
    const i = this.constructor, s = i._$Eh.get(e);
    if (s !== void 0 && this._$Em !== s) {
      const o = i.getPropertyOptions(s), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((n = o.converter) == null ? void 0 : n.fromAttribute) !== void 0 ? o.converter : T2;
      this._$Em = s, this[s] = a.fromAttribute(r, o.type), this._$Em = null;
    }
  }
  requestUpdate(e, r, n) {
    if (e !== void 0) {
      if (n ?? (n = this.constructor.getPropertyOptions(e)), !(n.hasChanged ?? Dk)(this[e], r)) return;
      this.P(e, r, n);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(e, r, n) {
    this._$AL.has(e) || this._$AL.set(e, r), n.reflect === !0 && this._$Em !== e && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(e);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (r) {
      Promise.reject(r);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var e;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [s, o] of this._$Ep) this[s] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [s, o] of i) o.wrapped !== !0 || this._$AL.has(s) || this[s] === void 0 || this.P(s, this[s], o);
    }
    let r = !1;
    const n = this._$AL;
    try {
      r = this.shouldUpdate(n), r ? (this.willUpdate(n), (e = this._$EO) == null || e.forEach((i) => {
        var s;
        return (s = i.hostUpdate) == null ? void 0 : s.call(i);
      }), this.update(n)) : this._$EU();
    } catch (i) {
      throw r = !1, this._$EU(), i;
    }
    r && this._$AE(n);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var r;
    (r = this._$EO) == null || r.forEach((n) => {
      var i;
      return (i = n.hostUpdated) == null ? void 0 : i.call(n);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((r) => this._$EC(r, this[r]))), this._$EU();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
}
_p.elementStyles = [], _p.shadowRootOptions = { mode: "open" }, _p[n0("elementProperties")] = /* @__PURE__ */ new Map(), _p[n0("finalized")] = /* @__PURE__ */ new Map(), pO == null || pO({ ReactiveElement: _p }), (cd.reactiveElementVersions ?? (cd.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const L2 = globalThis, M2 = L2.trustedTypes, fO = M2 ? M2.createPolicy("lit-html", { createHTML: (t) => t }) : void 0, FV = "$lit$", Pl = `lit$${Math.random().toFixed(9).slice(2)}$`, zV = "?" + Pl, e_e = `<${zV}>`, _h = document, eg = () => _h.createComment(""), tg = (t) => t === null || typeof t != "object" && typeof t != "function", $k = Array.isArray, t_e = (t) => $k(t) || typeof (t == null ? void 0 : t[Symbol.iterator]) == "function", ux = `[ 	
\f\r]`, Rf = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, gO = /-->/g, mO = />/g, Pu = RegExp(`>|${ux}(?:([^\\s"'>=/]+)(${ux}*=${ux}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), yO = /'/g, vO = /"/g, UV = /^(?:script|style|textarea|title)$/i, r_e = (t) => (e, ...r) => ({ _$litType$: t, strings: e, values: r }), n_e = r_e(1), ud = Symbol.for("lit-noChange"), Gr = Symbol.for("lit-nothing"), bO = /* @__PURE__ */ new WeakMap(), zu = _h.createTreeWalker(_h, 129);
function VV(t, e) {
  if (!$k(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return fO !== void 0 ? fO.createHTML(e) : e;
}
const i_e = (t, e) => {
  const r = t.length - 1, n = [];
  let i, s = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", o = Rf;
  for (let a = 0; a < r; a++) {
    const l = t[a];
    let c, p, h = -1, d = 0;
    for (; d < l.length && (o.lastIndex = d, p = o.exec(l), p !== null); ) d = o.lastIndex, o === Rf ? p[1] === "!--" ? o = gO : p[1] !== void 0 ? o = mO : p[2] !== void 0 ? (UV.test(p[2]) && (i = RegExp("</" + p[2], "g")), o = Pu) : p[3] !== void 0 && (o = Pu) : o === Pu ? p[0] === ">" ? (o = i ?? Rf, h = -1) : p[1] === void 0 ? h = -2 : (h = o.lastIndex - p[2].length, c = p[1], o = p[3] === void 0 ? Pu : p[3] === '"' ? vO : yO) : o === vO || o === yO ? o = Pu : o === gO || o === mO ? o = Rf : (o = Pu, i = void 0);
    const v = o === Pu && t[a + 1].startsWith("/>") ? " " : "";
    s += o === Rf ? l + e_e : h >= 0 ? (n.push(c), l.slice(0, h) + FV + l.slice(h) + Pl + v) : l + Pl + (h === -2 ? a : v);
  }
  return [VV(t, s + (t[r] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), n];
};
class rg {
  constructor({ strings: e, _$litType$: r }, n) {
    let i;
    this.parts = [];
    let s = 0, o = 0;
    const a = e.length - 1, l = this.parts, [c, p] = i_e(e, r);
    if (this.el = rg.createElement(c, n), zu.currentNode = this.el.content, r === 2 || r === 3) {
      const h = this.el.content.firstChild;
      h.replaceWith(...h.childNodes);
    }
    for (; (i = zu.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes()) for (const h of i.getAttributeNames()) if (h.endsWith(FV)) {
          const d = p[o++], v = i.getAttribute(h).split(Pl), m = /([.?@])?(.*)/.exec(d);
          l.push({ type: 1, index: s, name: m[2], strings: v, ctor: m[1] === "." ? o_e : m[1] === "?" ? a_e : m[1] === "@" ? l_e : tw }), i.removeAttribute(h);
        } else h.startsWith(Pl) && (l.push({ type: 6, index: s }), i.removeAttribute(h));
        if (UV.test(i.tagName)) {
          const h = i.textContent.split(Pl), d = h.length - 1;
          if (d > 0) {
            i.textContent = M2 ? M2.emptyScript : "";
            for (let v = 0; v < d; v++) i.append(h[v], eg()), zu.nextNode(), l.push({ type: 2, index: ++s });
            i.append(h[d], eg());
          }
        }
      } else if (i.nodeType === 8) if (i.data === zV) l.push({ type: 2, index: s });
      else {
        let h = -1;
        for (; (h = i.data.indexOf(Pl, h + 1)) !== -1; ) l.push({ type: 7, index: s }), h += Pl.length - 1;
      }
      s++;
    }
  }
  static createElement(e, r) {
    const n = _h.createElement("template");
    return n.innerHTML = e, n;
  }
}
function hd(t, e, r = t, n) {
  var i, s;
  if (e === ud) return e;
  let o = n !== void 0 ? (i = r._$Co) == null ? void 0 : i[n] : r._$Cl;
  const a = tg(e) ? void 0 : e._$litDirective$;
  return (o == null ? void 0 : o.constructor) !== a && ((s = o == null ? void 0 : o._$AO) == null || s.call(o, !1), a === void 0 ? o = void 0 : (o = new a(t), o._$AT(t, r, n)), n !== void 0 ? (r._$Co ?? (r._$Co = []))[n] = o : r._$Cl = o), o !== void 0 && (e = hd(t, o._$AS(t, e.values), o, n)), e;
}
class s_e {
  constructor(e, r) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = r;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: r }, parts: n } = this._$AD, i = ((e == null ? void 0 : e.creationScope) ?? _h).importNode(r, !0);
    zu.currentNode = i;
    let s = zu.nextNode(), o = 0, a = 0, l = n[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new km(s, s.nextSibling, this, e) : l.type === 1 ? c = new l.ctor(s, l.name, l.strings, this, e) : l.type === 6 && (c = new c_e(s, this, e)), this._$AV.push(c), l = n[++a];
      }
      o !== (l == null ? void 0 : l.index) && (s = zu.nextNode(), o++);
    }
    return zu.currentNode = _h, i;
  }
  p(e) {
    let r = 0;
    for (const n of this._$AV) n !== void 0 && (n.strings !== void 0 ? (n._$AI(e, n, r), r += n.strings.length - 2) : n._$AI(e[r])), r++;
  }
}
class km {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, r, n, i) {
    this.type = 2, this._$AH = Gr, this._$AN = void 0, this._$AA = e, this._$AB = r, this._$AM = n, this.options = i, this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const r = this._$AM;
    return r !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = r.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, r = this) {
    e = hd(this, e, r), tg(e) ? e === Gr || e == null || e === "" ? (this._$AH !== Gr && this._$AR(), this._$AH = Gr) : e !== this._$AH && e !== ud && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : t_e(e) ? this.k(e) : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.O(e));
  }
  _(e) {
    this._$AH !== Gr && tg(this._$AH) ? this._$AA.nextSibling.data = e : this.T(_h.createTextNode(e)), this._$AH = e;
  }
  $(e) {
    var r;
    const { values: n, _$litType$: i } = e, s = typeof i == "number" ? this._$AC(e) : (i.el === void 0 && (i.el = rg.createElement(VV(i.h, i.h[0]), this.options)), i);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === s) this._$AH.p(n);
    else {
      const o = new s_e(s, this), a = o.u(this.options);
      o.p(n), this.T(a), this._$AH = o;
    }
  }
  _$AC(e) {
    let r = bO.get(e.strings);
    return r === void 0 && bO.set(e.strings, r = new rg(e)), r;
  }
  k(e) {
    $k(this._$AH) || (this._$AH = [], this._$AR());
    const r = this._$AH;
    let n, i = 0;
    for (const s of e) i === r.length ? r.push(n = new km(this.O(eg()), this.O(eg()), this, this.options)) : n = r[i], n._$AI(s), i++;
    i < r.length && (this._$AR(n && n._$AB.nextSibling, i), r.length = i);
  }
  _$AR(e = this._$AA.nextSibling, r) {
    var n;
    for ((n = this._$AP) == null ? void 0 : n.call(this, !1, !0, r); e && e !== this._$AB; ) {
      const i = e.nextSibling;
      e.remove(), e = i;
    }
  }
  setConnected(e) {
    var r;
    this._$AM === void 0 && (this._$Cv = e, (r = this._$AP) == null || r.call(this, e));
  }
}
class tw {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, r, n, i, s) {
    this.type = 1, this._$AH = Gr, this._$AN = void 0, this.element = e, this.name = r, this._$AM = i, this.options = s, n.length > 2 || n[0] !== "" || n[1] !== "" ? (this._$AH = Array(n.length - 1).fill(new String()), this.strings = n) : this._$AH = Gr;
  }
  _$AI(e, r = this, n, i) {
    const s = this.strings;
    let o = !1;
    if (s === void 0) e = hd(this, e, r, 0), o = !tg(e) || e !== this._$AH && e !== ud, o && (this._$AH = e);
    else {
      const a = e;
      let l, c;
      for (e = s[0], l = 0; l < s.length - 1; l++) c = hd(this, a[n + l], r, l), c === ud && (c = this._$AH[l]), o || (o = !tg(c) || c !== this._$AH[l]), c === Gr ? e = Gr : e !== Gr && (e += (c ?? "") + s[l + 1]), this._$AH[l] = c;
    }
    o && !i && this.j(e);
  }
  j(e) {
    e === Gr ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}
class o_e extends tw {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === Gr ? void 0 : e;
  }
}
class a_e extends tw {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== Gr);
  }
}
class l_e extends tw {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s), this.type = 5;
  }
  _$AI(e, r = this) {
    if ((e = hd(this, e, r, 0) ?? Gr) === ud) return;
    const n = this._$AH, i = e === Gr && n !== Gr || e.capture !== n.capture || e.once !== n.once || e.passive !== n.passive, s = e !== Gr && (n === Gr || i);
    i && this.element.removeEventListener(this.name, this, n), s && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var r;
    typeof this._$AH == "function" ? this._$AH.call(((r = this.options) == null ? void 0 : r.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}
class c_e {
  constructor(e, r, n) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = r, this.options = n;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    hd(this, e);
  }
}
const wO = L2.litHtmlPolyfillSupport;
wO == null || wO(rg, km), (L2.litHtmlVersions ?? (L2.litHtmlVersions = [])).push("3.2.1");
const u_e = (t, e, r) => {
  const n = (r == null ? void 0 : r.renderBefore) ?? e;
  let i = n._$litPart$;
  if (i === void 0) {
    const s = (r == null ? void 0 : r.renderBefore) ?? null;
    n._$litPart$ = i = new km(e.insertBefore(eg(), s), s, void 0, r ?? {});
  }
  return i._$AI(t), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let i0 = class extends _p {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = u_e(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
  }
  render() {
    return ud;
  }
};
var xO;
i0._$litElement$ = !0, i0.finalized = !0, (xO = globalThis.litElementHydrateSupport) == null || xO.call(globalThis, { LitElement: i0 });
const EO = globalThis.litElementPolyfillSupport;
EO == null || EO({ LitElement: i0 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const h_e = (t) => (e, r) => {
  r !== void 0 ? r.addInitializer(() => {
    customElements.define(t, e);
  }) : customElements.define(t, e);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const p_e = { attribute: !0, type: String, converter: T2, reflect: !1, hasChanged: Dk }, d_e = (t = p_e, e, r) => {
  const { kind: n, metadata: i } = r;
  let s = globalThis.litPropertyMetadata.get(i);
  if (s === void 0 && globalThis.litPropertyMetadata.set(i, s = /* @__PURE__ */ new Map()), s.set(r.name, t), n === "accessor") {
    const { name: o } = r;
    return { set(a) {
      const l = e.get.call(this);
      e.set.call(this, a), this.requestUpdate(o, l, t);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, t), a;
    } };
  }
  if (n === "setter") {
    const { name: o } = r;
    return function(a) {
      const l = this[o];
      e.call(this, a), this.requestUpdate(o, l, t);
    };
  }
  throw Error("Unsupported decorator location: " + n);
};
function _m(t) {
  return (e, r) => typeof r == "object" ? d_e(t, e, r) : ((n, i, s) => {
    const o = i.hasOwnProperty(s);
    return i.constructor.createProperty(s, o ? { ...n, wrapped: !0 } : n), o ? Object.getOwnPropertyDescriptor(i, s) : void 0;
  })(t, e, r);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function f_e(t) {
  return _m({ ...t, state: !0, attribute: !1 });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const g_e = (t, e, r) => (r.configurable = !0, r.enumerable = !0, Reflect.decorate && typeof e != "object" && Object.defineProperty(t, e, r), r);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function m_e(t) {
  return (e, r) => {
    const { slot: n } = {}, i = "slot" + (n ? `[name=${n}]` : ":not([name])");
    return g_e(e, r, { get() {
      var s;
      const o = (s = this.renderRoot) == null ? void 0 : s.querySelector(i);
      return (o == null ? void 0 : o.assignedNodes(t)) ?? [];
    } });
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const y_e = (t) => t.strings === void 0;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const v_e = { CHILD: 2 }, b_e = (t) => (...e) => ({ _$litDirective$: t, values: e });
class w_e {
  constructor(e) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(e, r, n) {
    this._$Ct = e, this._$AM = r, this._$Ci = n;
  }
  _$AS(e, r) {
    return this.update(e, r);
  }
  update(e, r) {
    return this.render(...r);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s0 = (t, e) => {
  var r;
  const n = t._$AN;
  if (n === void 0) return !1;
  for (const i of n) (r = i._$AO) == null || r.call(i, e, !1), s0(i, e);
  return !0;
}, N2 = (t) => {
  let e, r;
  do {
    if ((e = t._$AM) === void 0) break;
    r = e._$AN, r.delete(t), t = e;
  } while ((r == null ? void 0 : r.size) === 0);
}, HV = (t) => {
  for (let e; e = t._$AM; t = e) {
    let r = e._$AN;
    if (r === void 0) e._$AN = r = /* @__PURE__ */ new Set();
    else if (r.has(t)) break;
    r.add(t), S_e(e);
  }
};
function x_e(t) {
  this._$AN !== void 0 ? (N2(this), this._$AM = t, HV(this)) : this._$AM = t;
}
function E_e(t, e = !1, r = 0) {
  const n = this._$AH, i = this._$AN;
  if (i !== void 0 && i.size !== 0) if (e) if (Array.isArray(n)) for (let s = r; s < n.length; s++) s0(n[s], !1), N2(n[s]);
  else n != null && (s0(n, !1), N2(n));
  else s0(this, t);
}
const S_e = (t) => {
  t.type == v_e.CHILD && (t._$AP ?? (t._$AP = E_e), t._$AQ ?? (t._$AQ = x_e));
};
class A_e extends w_e {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(e, r, n) {
    super._$AT(e, r, n), HV(this), this.isConnected = e._$AU;
  }
  _$AO(e, r = !0) {
    var n, i;
    e !== this.isConnected && (this.isConnected = e, e ? (n = this.reconnected) == null || n.call(this) : (i = this.disconnected) == null || i.call(this)), r && (s0(this, e), N2(this));
  }
  setValue(e) {
    if (y_e(this._$Ct)) this._$Ct._$AI(e, this);
    else {
      const r = [...this._$Ct._$AH];
      r[this._$Ci] = e, this._$Ct._$AI(r, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const SO = () => new k_e();
class k_e {
}
const hx = /* @__PURE__ */ new WeakMap(), AO = b_e(class extends A_e {
  render(t) {
    return Gr;
  }
  update(t, [e]) {
    var r;
    const n = e !== this.Y;
    return n && this.Y !== void 0 && this.rt(void 0), (n || this.lt !== this.ct) && (this.Y = e, this.ht = (r = t.options) == null ? void 0 : r.host, this.rt(this.ct = t.element)), Gr;
  }
  rt(t) {
    if (this.isConnected || (t = void 0), typeof this.Y == "function") {
      const e = this.ht ?? globalThis;
      let r = hx.get(e);
      r === void 0 && (r = /* @__PURE__ */ new WeakMap(), hx.set(e, r)), r.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), r.set(this.Y, t), t !== void 0 && this.Y.call(this.ht, t);
    } else this.Y.value = t;
  }
  get lt() {
    var t, e;
    return typeof this.Y == "function" ? (t = hx.get(this.ht ?? globalThis)) == null ? void 0 : t.get(this.Y) : (e = this.Y) == null ? void 0 : e.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
class __e {
  constructor(e, r) {
    this.labeledDataString = e, this.binCount = r, this._letters = [], this._proportions = [], this._returnString = "", this.labeledData = [], this.init();
  }
  get returnString() {
    return this._returnString;
  }
  init() {
    this.labeledData = JSON.parse(this.labeledDataString), this.labeledData.sort((e, r) => r.value - e.value), this.findTotal();
    for (let e of this.labeledData)
      this.findCandidateLetter(e.label);
    this.assignProportions(), this.composeString();
  }
  findTotal() {
    let e = 0;
    for (let r of this.labeledData)
      e += r.value;
    this.total = e;
  }
  findCandidateLetter(e) {
    const r = [];
    if (this._letters)
      for (let l of this._letters)
        r.push(l.candidate);
    let n = 0, i = e[0].toUpperCase();
    const s = e.replace(/\s+/g, ""), o = [...e.matchAll(/\s(\w)/g)], a = String(o.map((l) => l[1]).join(""));
    for (; r.includes(s[n].toUpperCase()); ) {
      if (o.length > 0 && !r.includes(a[0].toUpperCase())) {
        i = a[0].toUpperCase();
        break;
      }
      if (n += 1, i = s[n].toUpperCase(), n > s.length) {
        i = "?";
        break;
      }
    }
    this._letters.push({ label: e, candidate: i });
  }
  assignProportions() {
    let e = this.binCount;
    for (let r = this.labeledData.length - 1; r > -1; r--) {
      let n = this.labeledData[r];
      const i = n.value / this.total;
      let s = Math.max(1, Math.round(i * this.binCount));
      this.labeledData[0] == n && (s = e);
      const o = this._letters.filter((a) => a.label == n.label)[0].candidate;
      this._proportions.push({ label: o, value: s }), e -= s;
    }
    this._proportions.sort((r, n) => n.value - r.value);
  }
  composeString() {
    for (let e of this._proportions)
      this._returnString = this._returnString.concat(e.label.repeat(e.value));
  }
}
var C_e = Object.defineProperty, I_e = Object.getOwnPropertyDescriptor, Jh = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? I_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && C_e(e, r, i), i;
};
const P_e = 10240;
function R_e(t) {
  return t.reduce((e, r) => {
    if (typeof r > "u" || r === null)
      throw new Error("Invalid dot specification");
    let n = P_e;
    for (const i of r) {
      if (i < 1 || i > 8)
        throw new Error(`Dot out of range: ${i}`);
      n |= 1 << i - 1;
    }
    return e + String.fromCharCode(n);
  }, "");
}
let za = class extends i0 {
  constructor() {
    super(), this.bar = !1, this.isProp = !1, this.regionRef = SO(), this.preRef = SO(), this.onSelectionChange = () => {
      var t, e;
      const r = document.getSelection();
      if (((e = (t = r == null ? void 0 : r.anchorNode) == null ? void 0 : t.parentNode) == null ? void 0 : e.parentNode) !== this.regionRef.value)
        return;
      const n = r == null ? void 0 : r.anchorOffset;
      this.dispatchEvent(
        new CustomEvent(
          "select",
          {
            bubbles: !0,
            composed: !0,
            detail: n
          }
        )
      );
    };
  }
  /** Binned data, in case you want to see it. */
  get binnedData() {
    return this._binnedData;
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("selectionchange", this.onSelectionChange), this.data && !this.cells && this.renderBraille(this.data);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  willUpdate(t) {
    t.has("data") && this.renderBraille(this.data);
  }
  toBraille(t) {
    return t.split("").map((e) => O_e[e]).join("");
  }
  render() {
    let t;
    if (this.isProp) {
      const e = this.labeledData, r = new __e(e, 20);
      t = this.toBraille(r.returnString);
    } else
      t = this.cells ? R_e(this.cells) : "";
    return n_e`
      <div
        ${AO(this.regionRef)}
        role="textbox"
        contenteditable="true"
      >
        <pre 
          ${AO(this.preRef)}
          contenteditable="false"
        >${t}</pre>
        <div class="data" style="display: none">
          <slot 
          ></slot>
        </div>
      </div>
    `;
  }
  firstUpdated(t) {
    if (this.cells)
      return;
    const e = this.slotNodes.find((r) => {
      var n;
      return (n = r.textContent) == null ? void 0 : n.trim();
    });
    e && this.renderBraille(e.textContent);
  }
  renderBraille(t) {
    const e = t.split(/ /).map(parseFloat), r = new U7e(e, 4);
    this._binnedData = r.binnedData;
    const n = new V7e(this._binnedData, this.bar);
    this.cells = n.cells;
  }
};
za.styles = G7e`
    div {
      font-size: var(--font-size, 2rem);
      padding: var(--padding, unset);
      margin: var(--margin, unset);
    }
    pre {
      margin: 0;
    }
  `;
Jh([
  _m()
], za.prototype, "data", 2);
Jh([
  _m({ type: Boolean })
], za.prototype, "bar", 2);
Jh([
  _m()
], za.prototype, "labeledData", 2);
Jh([
  _m({ type: Boolean })
], za.prototype, "isProp", 2);
Jh([
  f_e()
], za.prototype, "cells", 2);
Jh([
  m_e()
], za.prototype, "slotNodes", 2);
za = Jh([
  h_e("fizz-sparkbraille")
], za);
const O_e = {
  " ": "",
  a: "",
  b: "",
  c: "",
  d: "",
  e: "",
  f: "",
  g: "",
  h: "",
  i: "",
  j: "",
  k: "",
  l: "",
  m: "",
  n: "",
  o: "",
  p: "",
  q: "",
  r: "",
  s: "",
  t: "",
  u: "",
  v: "",
  w: "",
  x: "",
  y: "",
  z: "",
  1: "",
  2: "",
  3: "",
  4: "",
  5: "",
  6: "",
  7: "",
  8: "",
  9: "",
  0: "",
  ",": "",
  ".": "",
  ";": "",
  ":": "",
  "!": "",
  "?": "",
  '"': "",
  "'": "",
  "-": "",
  "(": "",
  ")": "",
  A: "",
  B: "",
  C: "",
  D: "",
  E: "",
  F: "",
  G: "",
  H: "",
  I: "",
  J: "",
  K: "",
  L: "",
  M: "",
  N: "",
  O: "",
  P: "",
  Q: "",
  R: "",
  S: "",
  T: "",
  U: "",
  V: "",
  W: "",
  X: "",
  Y: "",
  Z: ""
};
var T_e = Object.defineProperty, L_e = Object.getOwnPropertyDescriptor, GV = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? L_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && T_e(e, r, i), i;
};
let D2 = class extends xn {
  constructor() {
    super(...arguments), this.isSparkBrailleVisible = !1, this._sparkBrailleRef = Et(), this._sparkBrailleWrapperRef = Et();
  }
  _saveChart() {
    const t = this.controlPanel.paraChart.paraView.serialize(), e = new Blob([t], { type: "image/svg+xml;charset=utf-8" }), r = URL.createObjectURL(e);
    this._controlPanel.paraChart.paraView.downloadContent(r, "svg"), URL.revokeObjectURL(r);
  }
  _saveData() {
    const t = this._store.getModelCsv(), e = new Blob([t], { type: "text/csv;charset=utf-8" }), r = URL.createObjectURL(e);
    this._controlPanel.paraChart.paraView.downloadContent(r, "csv"), URL.revokeObjectURL(r);
  }
  render() {
    var e, r, n, i, s, o;
    const t = this.controlPanel.parentElement.firstElementChild;
    return We`
      <div
        id="data-page"
        class="tab-content"
      >
        <div>
          <p>Source: <span id="source-name">unknown</span></p>
        </div>
        <div id="data-buttons">
          ${this.controlPanel.settings.isSparkBrailleControlVisible ? We`
              <button
                @click=${() => {
      this.isSparkBrailleVisible = !this.isSparkBrailleVisible, t.store.updateSettings((a) => {
        a.controlPanel.isSparkBrailleVisible = this.isSparkBrailleVisible;
      }), this._sparkBrailleRef.value.focus();
    }}
              >
                SparkBraille
              </button>
            ` : Ne}
          <button
            @click=${() => {
      this.controlPanel.dialog.show(
        "JSON Image Metadata",
        We`
                  <pre>
                    <code>
                      ${JSON.stringify(this._store.jimerator.jim, void 0, 2)}
                    </code>
                  </pre>`
      );
    }}
          >
            JIM
          </button>
          <button
            @click=${() => this._saveData()}
          >
            Save data
          </button>
          <button
            @click=${() => {
      this.controlPanel.dialog.show("Data table", We`
                <para-datatable
                  .model=${this._store.model}
                >
                </para-datatable>
              `);
    }}
          >
            Data table
          </button>
          <button
            @click=${() => this.controlPanel.dialog.show("Source links")}
          >
            Source Links
          </button>
          <button
            @click=${() => {
      this._saveChart();
    }}
          >
            Save chart
          </button>
        </div>
      </div>
      <div
        ${yt(this._sparkBrailleWrapperRef)}
        id="sparkbraille"
        class=${this.isSparkBrailleVisible ? Ne : "hidden"}
        ?hidden=${!this.isSparkBrailleVisible}
    >
        <!--
          What should happen when a braille cell is selected?
        -->
        <fizz-sparkbraille
          ${yt(this._sparkBrailleRef)}
          ?bar=${(e = this._store.sparkBrailleInfo) == null ? void 0 : e.isBar}
          ?isProp=${(r = this._store.sparkBrailleInfo) == null ? void 0 : r.isProportional}
          data=${(n = this._store.sparkBrailleInfo) != null && n.isProportional ? "" : ((i = this._store.sparkBrailleInfo) == null ? void 0 : i.data) ?? ""}
          labeledData=${(s = this._store.sparkBrailleInfo) != null && s.isProportional ? ((o = this._store.sparkBrailleInfo) == null ? void 0 : o.data) ?? "" : ""}
          @select=${(a) => {
      a.detail * 2;
    }}
        >
        </fizz-sparkbraille>
      </div>
    `;
  }
};
D2.styles = [
  ...xn.styles,
  Nt`
      #data-page {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        align-content: center;
        flex-grow: 1;
      }
      #data-page p {
        white-space: nowrap;
      }
      #data-buttons {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        align-content: center;
        flex-wrap: wrap;
        width: 30rem;
      }

      #data-buttons button {
        width: 8rem;
        max-width: 8rem;
      }
      #sparkbraille {
        background-color: var(--theme-color-light);
        padding: 0.2rem;
      }
    `
];
GV([
  Ke({ type: Boolean })
], D2.prototype, "isSparkBrailleVisible", 2);
D2 = GV([
  Dt("para-data-panel")
], D2);
var M_e = Object.defineProperty, N_e = Object.getOwnPropertyDescriptor, jk = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? N_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && M_e(e, r, i), i;
};
let ng = class extends xn {
  constructor() {
    super(...arguments), this.caption = "", this.visibleStatus = "", this._captionBoxWrapperRef = Et();
  }
  // get ariaLiveRegion() {
  //   return this._ariaLiveRegionRef.value!;
  // }
  positionCaptionBox() {
    this._controlPanel.settings.isControlPanelDefaultOpen || !this._controlPanel.settings.caption.isCaptionExternalWhenControlPanelClosed ? this.internalizeCaptionBox() : this._controlPanel.externalizeCaptionBox();
  }
  // get speechRate() {
  //   return this._controller.voice.rate;
  // }
  // set speechRate(rate: number) {
  //   this._controller.voice.rate = rate;
  // }
  clearStatusBar() {
    this._controlPanel.paraChart.clearAriaLive();
  }
  // clearAriaLive() {
  //   this._ariaLiveRegionRef.value!.clear();
  // }
  // protected _showAriaLiveHistory() {
  //   this._ariaLiveRegionRef.value!.showHistoryDialog();
  // }
  internalizeCaptionBox() {
    this.renderRoot.querySelector("#wrapper").append(this.controlPanel.paraChart.captionBox);
  }
  render() {
    return We`
      <div id="wrapper"></div>
    `;
  }
};
ng.styles = [
  ...xn.styles,
  Nt`
      #description {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      #desc-footer {
        background-color: var(--theme-color-light);
        padding: 0.2rem;
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-direction: row;
        justify-content: space-between;
      }
    `
];
jk([
  Ke()
], ng.prototype, "caption", 2);
jk([
  Ke()
], ng.prototype, "visibleStatus", 2);
ng = jk([
  Dt("para-description-panel")
], ng);
const D_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%205px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20%3c/style%3e%3cpath%20d='M95,23.6%20A14.1,14.1,0,0,0,80.8,9.4%20H19.1%20A14.1,14.1,0,0,0,5,23.6%20V52.1%20A14.1,14.1,0,0,0,19.1,66.2%20H45.7%20L69.0,89.9%20a1.9,1.9,0,0,0,3.4%20-1.5%20L70.4,66.2%20H80.8%20A14.1,14.1,0,0,0,95,52.1%20ZM91.0,52.1%20a10.1,10.1,0,0,1-10.1,10.1%20H68.2%20a1.9,1.9,0,0,0-1.9,2.1%20L67.9,83.1%20l-19.9%20-20.2%20a1.9,1.9,0,0,0-1.4%20-.59567h-27.4%20a10.1,10.1,0,0,1-10.1%20-10.1%20V23.6%20a10.1,10.1,0,0,1,10.1%20-10.1%20H80.8%20a10.1,10.1,0,0,1,10.1,10.1%20Z%20M20,25%20H75%20M20,37.5%20H75%20M20,50%20H75'%20/%3e%3c/svg%3e", $_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%207px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20%3c/style%3e%3cpath%20d='M50%204.6875c-21.875%200-39.062%209.2188-39.062%2020.938v48.594c0%2011.875%2017.188%2021.094%2039.062%2021.094s39.062-9.2188%2039.062-20.938v-48.75c0-11.719-17.188-20.938-39.062-20.938zm35.938%2069.688c0%209.6875-16.406%2017.812-35.938%2017.812s-35.938-8.125-35.938-17.812v-15.938c5.9375%207.5%2019.531%2012.656%2035.938%2012.656s30-5.1562%2035.938-12.656zm0-24.375c0%209.6875-16.406%2017.812-35.938%2017.812s-35.938-8.125-35.938-17.812v-15.938c5.9375%207.5%2019.531%2012.656%2035.938%2012.656s30-5.1562%2035.938-12.656zm-35.938-6.4062c-19.531%200-35.938-8.125-35.938-17.812s16.406-17.969%2035.938-17.969%2035.938%208.125%2035.938%2017.812-16.406%2017.969-35.938%2017.969z'%20/%3e%3c/svg%3e", j_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cpath%20d='m44.375%2088.531c1.7109%201.5938%203.5977%202.9883%205.625%204.1562-7.1992%204.1562-15.762%205.2734-23.789%203.0977-8.0234-2.1719-14.852-7.4531-18.973-14.676-4.1211-7.2227-5.1914-15.789-2.9805-23.801%202.2148-8.0156%207.5312-14.82%2014.773-18.902%200.25391%202.1992%200.76953%204.3594%201.5312%206.4375%202.5391%207.0938%207.5391%2013.039%2014.094%2016.75-0.1875%201.3359-0.28125%202.6836-0.28125%204.0312-0.007812%208.6953%203.6172%2017%2010%2022.906zm36.594-50.125c-0.25391%202.1992-0.76953%204.3594-1.5312%206.4375-2.5391%207.0938-7.5391%2013.039-14.094%2016.75%200.1875%201.3359%200.28125%202.6836%200.28125%204.0312%200.007812%208.6953-3.6172%2017-10%2022.906-1.7109%201.5938-3.5977%202.9883-5.625%204.1562%207.1992%204.1562%2015.762%205.2734%2023.789%203.0977%208.0234-2.1719%2014.852-7.4531%2018.973-14.676%204.1211-7.2227%205.1914-15.789%202.9805-23.801-2.2148-8.0156-7.5312-14.82-14.773-18.902zm-7.1875%203.625c-2.6172-0.92969-5.3789-1.4062-8.1562-1.4062-3.4414-0.003906-6.8477%200.71094-10%202.0938%203.6914%203.4258%206.5%207.6914%208.1875%2012.438%204.7266-3.1055%208.2461-7.7383%209.9688-13.125zm-14.438%2022.156c-6.082%201.918-12.605%201.918-18.688%200-0.03125%200.46875-0.03125%200.96875-0.03125%201.4375-0.007812%207.5781%203.4453%2014.75%209.375%2019.469%205.9297-4.7188%209.3828-11.891%209.375-19.469%200-0.46875%200-0.96875-0.03125-1.4375zm-9.3438-4.8125c2.7773%200%205.5391-0.47656%208.1562-1.4062-1.4844-4.6602-4.3242-8.7734-8.1562-11.812-3.832%203.0391-6.6719%207.1523-8.1562%2011.812%202.6172%200.92969%205.3789%201.4062%208.1562%201.4062zm-15.625-18.75c-2.7773%200-5.5391%200.47656-8.1562%201.4062%201.7227%205.3867%205.2422%2010.02%209.9688%2013.125%201.6875-4.7461%204.4961-9.0117%208.1875-12.438-3.1523-1.3828-6.5586-2.0977-10-2.0938zm0-6.25c5.4844-0.003906%2010.875%201.4414%2015.625%204.1875%204.75-2.7461%2010.141-4.1914%2015.625-4.1875%203.1719-0.003906%206.3203%200.48047%209.3438%201.4375%202.0859%200.65234%204.0977%201.5195%206%202.5938%200.1875-1.3359%200.28125-2.6836%200.28125-4.0312%200-11.164-5.957-21.48-15.625-27.062s-21.582-5.582-31.25%200-15.625%2015.898-15.625%2027.062c0%201.3477%200.09375%202.6953%200.28125%204.0312%201.9023-1.0742%203.9141-1.9414%206-2.5938%203.0234-0.95703%206.1719-1.4414%209.3438-1.4375z'%20/%3e%3c/svg%3e", B_e = "data:image/svg+xml,%3csvg%20viewBox='0%200%20100%20100'%20xmlns='http://www.w3.org/2000/svg'%3e%3cstyle%3e%20path%20{%20stroke:%20black;%20stroke-width:%208;%20stroke-linecap:round;%20fill:%20none;%20}%20path%23speaker%20{%20stroke:%20none;%20fill:%20black;%20}%20%3c/style%3e%3cpath%20id='speaker'%20d='M%2052.9,11.7%20C%2050,10.2%2046.5,10.5%2043.8,12.5%20L%2020.9,29.5%20C%2020.7,29.7%2020.3,29.8%2020,29.8%20H%2011.1%20C%206.3,29.8%202.4,33.7%202.4,38.5%20V%2061.5%20C%202.4,66.3%206.3,70.2%2011.1,70.2%20H%2020%20C%2020.3,70.2%2020.6,70.3%2020.9,70.5%20L%2043.8,87.5%20C%2045.3,88.6%2047.1,89.2%2049,89.2%2050.3,89.2%2051.7,88.9%2052.9,88.3%2055.8,86.8%2057.7,83.8%2057.7,80.5%20V%2019.5%20C%2057.6,16.2%2055.8,13.2%2052.9,11.7%20Z'%20/%3e%3cpath%20d='M70.5,31%20C78.5,40%2078.5,60%2070.5,69'%20/%3e%3cpath%20d='M81.5,17%20C97.5,34%2097.5,66%2081.5,83'%20/%3e%3c/svg%3e", F_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%208px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20circle%20{%20fill:%20white;%20stroke:%20black;%20stroke-width:%206px;%20}%20%3c/style%3e%3cg%3e%3cpath%20d='M15,25%20H85'%20/%3e%3ccircle%20cx='28'%20cy='25'%20r='7'%20/%3e%3c/g%3e%3cg%3e%3cpath%20d='M15,50%20H85'%20/%3e%3ccircle%20cx='68'%20cy='50'%20r='7'%20/%3e%3c/g%3e%3cg%3e%3cpath%20d='M15,75%20H85'%20/%3e%3ccircle%20cx='50'%20cy='75'%20r='7'%20/%3e%3c/g%3e%3c/svg%3e", z_e = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20viewBox='0%200%20100%20100'%3e%3cstyle%3e%20path.new%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%208px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20%3c/style%3e%3cpath%20class='new'%20d='M10,10%20V90%20H90%20M22,60%20L35,75%20L50,58%20L58,68%20L90,28'%20/%3e%3c/svg%3e", kO = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='10%2010%2080%2080'%3e%3cstyle%3e%20path%20{%20fill:%20none;%20stroke:%20black;%20stroke-width:%207px;%20stroke-linejoin:%20round;%20stroke-linecap:%20round;%20}%20circle%20{%20fill:%20white;%20stroke:%20black;%20stroke-width:%206px;%20}%20%3c/style%3e%3cpath%20d='M57.5%20,70%20m23.3%202.6%20-20.5%20-35.0%20v-20.3%20h4.5%20c1.3%200%202.5-1.1%202.5-2.5%200-1.3%20-1.1%20-2.5%20-2.5%20-2.5%20h-30.1%20c-1.3%200-2.5%201.1%20-2.5%202.5%200%201.3%201.1%202.5%202.5%202.5%20h4.7%20v20.3%20l-19.9%2035.1%20c-1.6%202.9%20-1.6%206.5%200.0%209.4%201.7%202.9%204.7%204.7%208.2%204.7%20h44.8%20c3.4%200%206.5%20-1.7%208.2%20-4.7%201.7%20-2.9%201.6%20-6.5%20-0.0%20-9.5%20z%20M33,50%20H67'%20/%3e%3ccircle%20cx='40'%20cy='63'%20r='4'%20/%3e%3ccircle%20cx='57'%20cy='72'%20r='4'%20/%3e%3c/svg%3e", U_e = "data:image/svg+xml,%3csvg%20id='fizz_logo'%20x='0'%20y='0'%20width='100%25'%20height='100%25'%20viewBox='0%200%20208%20208'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eFizz%20Logo%3c/title%3e%3cstyle%3e%20text%20{%20font-family:%20'Trebuchet%20MS',%20Helvetica,%20sans-serif;%20font-size:%20180px;%20}%20%3c/style%3e%3cg%20fill='hsl(258,%2030%25,%2040%25)'%3e%3ccircle%20id='circle-0-0'%20cx='50'%20cy='50'%20r='30'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-0-1'%20cx='120'%20cy='46.5'%20r='23'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-0-2'%20cx='176'%20cy='43'%20r='16'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-1-0'%20cx='46.5'%20cy='120'%20r='23'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-1-1'%20cx='112'%20cy='112'%20r='16'%20fill='%23944bbb'/%3e%3ccircle%20id='circle-2-0'%20cx='43'%20cy='176'%20r='16'%20fill='%23944bbb'/%3e%3c/g%3e%3c/svg%3e", WV = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMS4yNXJlbSIgaGVpZ2h0PSIxLjI1cmVtIiB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGNpcmNsZSBzdHlsZT0ic3Ryb2tlOmdob3N0d2hpdGU7IHN0cm9rZS13aWR0aDoxLjhweDsgZmlsbDpub25lOyIgY3g9IjEwIiBjeT0iMTAiIHI9IjkiLz48dGV4dCB4PSIxMCIgeT0iMTYiIHN0eWxlPSJmaWxsOmdob3N0d2hpdGU7IGZvbnQ6Ym9sZCAxOHB4ICdUaW1lcyBOZXcgUm9tYW4nLFRpbWVzLHNlcmlmOyB0ZXh0LWFuY2hvcjptaWRkbGU7Ij5pPC90ZXh0Pgo8L3N2Zz4K";
var V_e = Object.defineProperty, H_e = Object.getOwnPropertyDescriptor, Bk = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? H_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && V_e(e, r, i), i;
};
let ig = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("ParaControlPanel"), this.dataState = "initial", this._tabsRef = Et(), this._descriptionPanelRef = Et(), this._dataPanelRef = Et(), this._colorsPanelRef = Et(), this._chartPanelRef = Et(), this._annotationPanelRef = Et(), this._controlsPanelRef = Et(), this._dialogRef = Et(), this._msgDialogRef = Et();
  }
  get settings() {
    return vr.getGroupLink(
      this.managedSettingKeys[0],
      this._store.settings
    );
  }
  get managedSettingKeys() {
    return ["controlPanel"];
  }
  get descriptionPanel() {
    return this._descriptionPanelRef.value;
  }
  get chartPanel() {
    return this._chartPanelRef.value;
  }
  get annotationPanel() {
    return this._annotationPanelRef.value;
  }
  // get statusBar() {
  //   return this._descriptionPanelRef.value!.statusBar;
  // }
  get dialog() {
    return this._dialogRef.value;
  }
  connectedCallback() {
    super.connectedCallback(), this._storeChangeUnsub = this._store.subscribe((t, e) => {
      t === "data" && this.dataUpdated();
    }), this.addButtonListeners();
  }
  addButtonListeners() {
    const t = () => {
      var n, i, s;
      let e = setTimeout(() => {
        t();
      }, 100), r = (s = (i = (n = this.shadowRoot) == null ? void 0 : n.getElementById("wrapper")) == null ? void 0 : i.children[0].shadowRoot) == null ? void 0 : s.children[0].getElementsByClassName("toggle")[0];
      r && (r.addEventListener("pointerenter", () => {
        this.addPopup(!!this.paraChart.isControlPanelOpen);
      }), r.addEventListener("pointerleave", () => {
        this.removePopup(this.id);
      }), r.addEventListener("click", () => {
        this.removePopup(this.id), this.addButtonListeners();
      }), clearTimeout(e));
    };
    t();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._storeChangeUnsub();
  }
  // Anything that needs to be done when data is updated, do here
  dataUpdated() {
    this.dataState = "complete";
  }
  settingDidChange(t, e) {
    var s;
    const r = t.match(/controlPanel\.(\w+)/)[1], n = /is(\w+)TabVisible/, i = (s = r.match(n)) == null ? void 0 : s[1];
    if (i)
      e ? this._tabsRef.value.show(i) : this._tabsRef.value.hide(i);
    else if (r === "isControlPanelDefaultOpen" || r === "tabLabelStyle")
      this.requestUpdate();
    else if (r === "isCaptionVisible" || r === "isExplorationBarVisible")
      this._descriptionPanelRef.value.requestUpdate();
    else if (r === "isSparkBrailleVisible")
      this._dataPanelRef.value.isSparkBrailleVisible = e;
    else if (r === "isSparkBrailleControlVisible")
      this._dataPanelRef.value.requestUpdate();
    else if (r === "isColorPaletteControlVisible" || r === "isCVDControlVisible")
      this._colorsPanelRef.value.requestUpdate();
    else
      return !1;
    return !0;
  }
  updated(t) {
    t.has("dataState") && this.dataState === "complete" && this.descriptionPanel.requestUpdate();
  }
  externalizeCaptionBox() {
    this.after(this.paraChart.captionBox);
  }
  onFocus() {
    this._descriptionPanelRef.value.clearStatusBar();
  }
  showHelpDialog() {
    return this._controlsPanelRef.value.showHelpDialog();
  }
  addPopup(t) {
    let e = this.paraChart.paraView, r = t ? "Close control panel" : "Open control panel", n = e.documentView.height - 80, i = new ls(
      e,
      {
        text: r ?? "",
        x: 10,
        y: n + (t ? 26.4 : 0),
        textAnchor: "middle",
        classList: ["annotationlabel"],
        id: this.id,
        type: "controlPanelIcon",
        fill: "hsl(0, 0%, 0%)",
        inbounds: !1
      },
      {
        fill: "hsl(0, 0%, 100%)",
        shape: "box"
      }
    );
    e.store.popups.push(i);
  }
  removePopup(t) {
    this.paraChart.paraView.store.popups.splice(this.paraChart.paraView.store.popups.findIndex((e) => e.id === t), 1), this.paraChart.paraView.requestUpdate();
  }
  render() {
    let t = this.paraChart.isControlPanelOpen ? "expanded" : "collapsed";
    const e = {
      icon: "icons",
      iconLabel: "icons-labels",
      label: "labels"
    };
    return We`
      <div id="wrapper">
        <fizz-tabs
          ${yt(this._tabsRef)}
          ?open=${this.settings.isControlPanelDefaultOpen}
          class=${t}
          tablabelmode=${e[this.settings.tabLabelStyle]}
		  openbuttonarialabel="ParaCharts control panel"
          @open=${() => {
      this.paraChart.isControlPanelOpen = !0, this.settings.caption.isCaptionExternalWhenControlPanelClosed && this._descriptionPanelRef.value.internalizeCaptionBox();
    }}
          @close=${() => {
      this.paraChart.isControlPanelOpen = !1, this.settings.caption.isCaptionExternalWhenControlPanelClosed && this.externalizeCaptionBox();
    }}
          @invalidvalue=${(r) => this._msgDialogRef.value.show(r.detail)}
          @ready=${() => {
    }}
        >
          <fizz-tab-panel
            tablabel="Description"
            icon=${D_e}
          >
            <para-description-panel
              ${yt(this._descriptionPanelRef)}
              .controlPanel=${this}
            ></para-description-panel>
          </fizz-tab-panel>
          <fizz-tab-panel
            tablabel="Data"
            icon=${$_e}
            ?hidden=${!this.settings.isDataTabVisible}
          >
            <para-data-panel
              ${yt(this._dataPanelRef)}
              .controlPanel=${this}
              .sparkBrailleData=${this.sparkBrailleData}
              .isSparkBrailleVisible=${this.settings.isSparkBrailleVisible}
            ></para-data-panel>
          </fizz-tab-panel>
          <fizz-tab-panel
            tablabel="Colors"
            icon=${j_e}
            ?hidden=${!this.settings.isColorsTabVisible}
          >
            <para-colors-panel
              ${yt(this._colorsPanelRef)}
              .controlPanel=${this}
            ></para-colors-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Audio"
            icon=${B_e}
            ?hidden=${!this.settings.isAudioTabVisible}
          >
            <para-audio-panel
              .controlPanel=${this}
            ></para-audio-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Controls"
            icon=${F_e}
            ?hidden=${!this.settings.isControlsTabVisible}
          >
            <para-controls-panel
              ${yt(this._controlsPanelRef)}
              .controlPanel=${this}
            ></para-controls-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Chart"
            icon=${z_e}
            ?hidden=${!this.settings.isChartTabVisible}
          >
            <para-chart-panel
              ${yt(this._chartPanelRef)}
              .controlPanel=${this}
            ></para-chart-panel>
          </fizz-tab-panel>

          <fizz-tab-panel
            tablabel="Annotations"
            icon=${kO}
            ?hidden=${!this.settings.isAnnotationsTabVisible}
          >
            <para-annotation-panel
              ${yt(this._annotationPanelRef)}
              .controlPanel=${this}
            ></para-annotation-panel>
          </fizz-tab-panel>

          <!--<fizz-tab-panel
            tablabel="Analysis"
            icon=${kO}
            ?hidden=${!this.settings.isAnalysisTabVisible}
          >
            <para-analysis-panel
              .controlPanel=${this}
            ></para-analysis-panel>
          </fizz-tab-panel>-->
        </fizz-tabs>
      </div>
      ${this.renderDialog()}
    `;
  }
  renderDialog() {
    return We`
      <para-dialog
        ${yt(this._dialogRef)}
        id="generic-dialog"
      ></para-dialog>
      <fizz-msg-dialog
        ${yt(this._msgDialogRef)}
      ></fizz-msg-dialog>
    `;
  }
  renderTabDebug() {
    return We`
      <fizz-tab-panel tablabel="Debug">
        <div class="tab-content">
          <div
            class="setting-views"
          >
          </div>
        </div>
      </fizz-tab-panel>
    `;
  }
  getJsonStr(t, e, r) {
    return e ? `
        <pre><code>${JSON.stringify(t, null, r)}
        </code></pre>
      ` : JSON.stringify(t, null, r);
  }
};
ig.styles = [
  //styles,
  Nt`
      * {
        font-family: "Trebuchet MS", Helvetica, sans-serif;
        font-size: var(--control-panel-font-size, 1rem);
      }
      #wrapper {
        position: relative;
      }
      fizz-tabs {
        --background: #eee;
        --toggle-button-icon: var(--control-panel-icon, url(${Zu(U_e)}));
        /*--control-panel-icon: url(${Zu(WV)});*/
        --summary-marker-font-weight: bold;
        --control-panel-icon-size: 1.1rem;
        --contents-margin: 2px 0 0 0;
        width: 1;
        min-width: 40rem;
        max-width: 50%;
      }
      fizz-tabs.collapsed {
        /*width: rem;*/
        /*min-width: unset;*/
        position: absolute;
        bottom: 10px;
        /*--background: none;
        --control-panel-background: none;
        --control-panel-icon-color: var(--theme-color);
        --control-panel-icon-size: 1.5rem;
        --theme-contrast-color: var(--theme-color);
        --border: none;*/
        border: 2px solid transparent;
      }

      fizz-tabs.expanded {
        border: 2px solid var(--theme-color);
        border-radius: 4px;
        --background: none;
        --control-panel-icon-color: ghostwhite;
        --summary-padding: 0 0.35rem;
        --summary-margin: -2px 0;
      }

      fizz-tabs.collapsed.darkmode  {
        --control-panel-icon-color: ghostwhite;
      }
    `
];
Bk([
  Ke()
], ig.prototype, "sparkBrailleData", 2);
Bk([
  Ur()
], ig.prototype, "dataState", 2);
ig = Bk([
  Dt("para-control-panel")
], ig);
var G_e = Object.defineProperty, W_e = Object.getOwnPropertyDescriptor, Fk = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? W_e(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && G_e(e, r, i), i;
};
let sg = class extends ts {
  constructor() {
    super(...arguments), this.log = qt("ParaCaptionBox"), this._lastSpans = /* @__PURE__ */ new Set(), this._prevSpanIdx = 0, this._highlightManualOverride = !1, this._caption = { text: "", html: "" }, this._spans = [], this._isEBarVisible = !1;
  }
  get highlightManualOverride() {
    return this._highlightManualOverride;
  }
  connectedCallback() {
    super.connectedCallback(), this.setCaption(), this._storeChangeUnsub = this._store.subscribe(this.setCaption.bind(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._storeChangeUnsub();
  }
  updated(t) {
    if (!this._store.settings.ui.isNarrativeHighlightEnabled) return;
    const e = this.getSpans();
    this._spans = this._spans.filter((r) => e.includes(r)), e.forEach((r, n) => {
      this._spans.includes(r) || (this._spans.push(r), r.addEventListener("pointerenter", (i) => {
        if (!this._store.settings.ui.isNarrativeHighlightEnabled || this._store.paraChart.ariaLiveRegion.voicing.isSpeaking) return;
        const s = this._store.announcement.highlights[n];
        this._store.paraChart.postNotice("utteranceBoundary", s);
      }));
    });
  }
  clearStatusBar() {
    this.parachart.clearAriaLive();
  }
  async setCaption() {
    this._store.dataState === "complete" && (this._summarizer || (this.store.model.type === "pie" || this.store.model.type === "donut" ? this._summarizer = new qb(this.store.model) : this._summarizer = new Wb(this.store.model)), this._caption = await this._summarizer.getChartSummary());
  }
  noticePosted(t, e) {
    if (this._store.settings.ui.isNarrativeHighlightEnabled) {
      if (t === "utteranceBoundary") {
        const r = e;
        for (const n of this.getSpans())
          n.dataset.phrasecode === `${r.phrasecode}` ? (n.classList.add("highlight"), this._lastSpans.add(n)) : (n.classList.remove("highlight"), this._lastSpans.delete(n));
      } else if (t === "utteranceEnd" && !this._highlightManualOverride)
        for (const r of this._lastSpans)
          r.classList.remove("highlight");
    }
  }
  highlightSpan(t = !0) {
    const e = (o) => {
      const a = document.createElement("div");
      return a.innerHTML = this._store.announcement.html, a.children[o].innerText;
    }, r = this._store.paraChart.ariaLiveRegion.voicing;
    let n = this._prevSpanIdx;
    this._highlightManualOverride || (n = r.highlightIndex, this._highlightManualOverride = !0), n = Math.min(
      this._store.announcement.highlights.length - 1,
      Math.max(0, n + (t ? 1 : -1))
    ), this._prevSpanIdx = n;
    const i = e(n), s = this._store.announcement.highlights[n];
    r.shutUp(), r.speakText(i), this._store.paraChart.postNotice("utteranceBoundary", s);
  }
  clearSpanHighlights() {
    for (const t of this.getSpans())
      t.classList.remove("highlight");
  }
  renderSummary(t, e) {
    return typeof t == "string" && (t = { text: t, html: t }), We`
      <article>
        ${EV(t.html)}
      </article>
    `;
  }
  getSpans() {
    return Array.from(this.renderRoot.querySelectorAll("span"));
  }
  render() {
    this._isEBarVisible = !!this.store.announcement.text && this._store.announcement.text !== this._caption.text;
    const t = !this._isEBarVisible || !this._store.settings.controlPanel.isExplorationBarVisible;
    return We`
      <figcaption class=${this.parachart.isControlPanelOpen ? "" : "external"}>
        <div id="caption-box">
          <div
            id="caption"
            class=${t ? "solo" : ""}
            ?hidden=${!this._store.settings.controlPanel.isCaptionVisible}
          >
            ${this.renderSummary(this._caption, "caption")}
          </div>
          <div
            id="exploration-bar"
            class=${t ? "hidden" : ""}
          >
            <div
              id="exploration-bar-text"
              aria-hidden="true"
            >
              ${this._store.announcement.text === this._caption.text ? "" : this.renderSummary(this._store.announcement, "statusbar")}
            </div>
            ${!this._store.settings.controlPanel.caption.isCaptionExternalWhenControlPanelClosed || this.parachart.isControlPanelOpen ? We`
                <button
                  @click=${() => this.parachart.showAriaLiveHistory()}
                >
                  History
                </button>` : ""}
          </div>
        </div>
      </figcaption>
    `;
  }
};
sg.styles = [
  Nt`
      figcaption.external {
        border: var(--caption-border);
      }
      #caption-box {
        display: grid;
        grid-template-columns: var(--caption-grid-template-columns);
      }
      #caption {
        padding: 0.25rem;
      }
      #caption.solo {
        grid-column: 1 / 3
      }
      #exploration-bar {
        background-color: var(--theme-color-light);
        padding: 0.2rem;
        display: var(--exploration-bar-display);
        flex-direction: column;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
      }
      #exploration-bar-text {
        align-self: flex-start;
      }
      #caption span.highlight {
        background-color: var(--theme-color-light);
      }
      #exploration-bar span.highlight {
        background-color: white;
      }
      #exploration-bar.hidden {
        /* Using this rather than 'hidden' attr to override flex display */
        display: none;
      }
    `
];
Fk([
  Ke({ attribute: !1 })
], sg.prototype, "parachart", 2);
Fk([
  Ur()
], sg.prototype, "_caption", 2);
sg = Fk([
  Dt("para-caption-box")
], sg);
const q_e = "./node_modules/@fizz/chart-data/data/";
class Q_e {
  constructor() {
    this.log = qt("ParaLoader"), this._csvParseResult = null;
  }
  async load(e, r, n, i) {
    let s;
    if (e === "content")
      s = JSON.parse(r);
    else {
      let a = "";
      e === "fizz-chart-data" && (a = q_e), a += r, this.log.info(`loading manifest from ${a}`), s = await (await fetch(a)).json();
    }
    let o;
    if (s.datasets[0].data.source === "external") {
      s.datasets[0].data.source = "inline", o = {}, s.datasets[0].data.path !== "para:preload" && this.preloadData(s.datasets[0].data.path);
      const a = s.datasets[0].series.map((c) => c.key), l = this._csvParseResult.meta.fields.filter((c) => !a.includes(c))[0];
      this._csvParseResult.data.forEach((c, p) => {
        Object.entries(c).forEach(([h, d]) => {
          a.includes(h) && (o[h] || (o[h] = []), o[h].push({
            x: c[l],
            y: d
          }));
        });
      }), s.datasets[0].series.forEach((c) => {
        c.records = o[c.key];
      });
    }
    return this.log.info("manifest loaded"), n && (s.datasets[0].type = n, this.log.info("manifest chart type changed")), i && (s.datasets[0].description = i, this.log.info("manifest description changed")), { result: "success", manifest: s };
  }
  /**
   * Fetch and parse a CSV, storing the parse results.
   * @param url - CSV URL
   * @returns List of FieldInfo records
   */
  async preloadData(e) {
    const r = await (await fetch(e)).text();
    return RN.parse(r, {
      header: !0,
      complete: (n) => {
        this._csvParseResult = n;
      },
      error: (n) => {
        throw new Error(`Papa Parse error: ${n}`);
      }
    }), this._csvParseResult.meta.fields.map((n) => ({
      name: n,
      // XXX need to detect date formats
      type: isNaN(parseFloat(this._csvParseResult.data[0][n])) ? "string" : "number"
    }));
  }
}
class K_e {
  constructor() {
    this._customPrefix = "--para-", this._paraRules = {}, this._colorPalette = null, this._symbolSet = null, this.log = qt("CustomPropertyLoader");
  }
  get store() {
    return this._store;
  }
  set store(e) {
    this._store = e;
  }
  // Convert `paraRules` to object of key-value pairs of type SettingInput
  processProperties() {
    this._getParaRules();
    const e = {};
    return Object.keys(this._paraRules).forEach((r) => {
      const n = r.replace(/\s+/g, "").substring(1), i = this._paraRules[r];
      this.log.info(r, i), Object.keys(i).forEach((s) => {
        const o = i[s], a = this._isColorProp(s), l = this._isSymbolProp(s);
        if (!a && !l) {
          this.log.info(s, o);
          const c = this._convertPropToSettingStr(s);
          let p = o, h = parseFloat(o);
          Number.isNaN(h) ? o === "true" ? p = !0 : o === "false" ? p = !1 : this._hasDoubleQuotes(o) && (p = this._trimQuotes(o)) : p = h, e[`${n}.${c}`] = p;
        } else a ? this._processColorProps(s, o) : l && this._processSymbolProps(s, o);
      });
    }), e;
  }
  _isSameDomain(e) {
    return e.href ? e.href.indexOf(window.location.origin) === 0 : !0;
  }
  // returns boolean and narrows type to CSSStyleRule
  _isStyleRule(e) {
    return e instanceof CSSStyleRule;
  }
  _isParaProp(e) {
    return e.startsWith(this._customPrefix);
  }
  _getParaRules() {
    const e = [...document.styleSheets].filter(this._isSameDomain);
    for (const r of e) {
      const n = [...r.cssRules].filter(this._isStyleRule);
      for (const i of n) {
        const s = [...i.style].filter(this._isParaProp.bind(this)).map((o) => ({
          [o]: i.style.getPropertyValue(o)
        }));
        if (s.length) {
          const o = i.selectorText;
          this._paraRules[o] ? this.log.warn(`[ParaCharts] Duplicate selector '${o}'; collecting all properties`) : this._paraRules[o] = {}, s.forEach((a) => {
            Object.entries(a).forEach(([l, c]) => {
              this._convertPropToSettingStr(l);
              const p = this._paraRules[o][l];
              if (p) {
                const h = p === c ? `[ParaCharts] Duplicate value '${c}' for property '${l}' in selector '${o}'` : `[ParaCharts] Replaced value '${p}' with value '${c}' for property '${l}' in selector '${o}'`;
                this.log.warn(h);
              }
              this._paraRules[o][l] = c;
            });
          });
        }
      }
    }
  }
  _hasDoubleQuotes(e) {
    return e.startsWith('"') && e.endsWith('"') || e.startsWith("'") && e.endsWith("'");
  }
  _trimQuotes(e) {
    return e.replace(/['"]/g, "");
  }
  _convertPropToSettingStr(e) {
    const r = e.replace(this._customPrefix, "");
    return this._convertKebabToCamelCase(r);
  }
  _convertKebabToCamelCase(e) {
    return e.replace(/-./g, (n) => n[1].toUpperCase());
  }
  _convertCamelToKebabCase(e) {
    return e.replace(/[A-Z0-9]+(?![a-z0-9])|[A-Z]/g, (n, i) => (i ? "-" : "") + n.toLowerCase());
  }
  _isColorProp(e) {
    const r = e.match(/series-\d+-color/gi), n = e.match(/palette/gi);
    return !!(r != null && r.length || n != null && n.length);
  }
  _processColorProps(e, r) {
    if (this._colorPalette || (this._colorPalette = {
      key: "custom-0",
      title: "Custom palette",
      colors: []
    }), e === `${this._customPrefix}palette`) {
      const n = r.split(/,\s+/);
      this._colorPalette.key = this._trimQuotes(n[0]), this._colorPalette.title = this._trimQuotes(n[1]);
    } else {
      const n = parseInt(e.match(/\d+/g)[0]), i = r.split(/,\s+['"]/);
      this.log.info("color valueArray", i), this._colorPalette.colors[n] = {
        value: i[0],
        name: this._trimQuotes(i[1])
      };
    }
  }
  registerColors() {
    this._colorPalette && (this._store.colors.addPalette(this._colorPalette), this._store.colors.selectPaletteWithKey(this._colorPalette.key));
  }
  _isSymbolProp(e) {
    const r = e.match(/series-\d+-symbol/gi);
    return !!(r != null && r.length);
  }
  _processSymbolProps(e, r) {
    this._symbolSet || (this._symbolSet = []);
    const n = parseInt(e.match(/\d+/g)[0]), i = r.split(/,\s+['"]/), s = this._trimQuotes(i[0]), o = this._trimQuotes(i[1]);
    this._symbolSet[n] = `${s}.${o}`;
  }
  registerSymbols() {
    this._symbolSet && (this._store.symbols.types = this._symbolSet);
  }
}
class Y_e {
  constructor(e) {
    this._selector = e, this._declarations = /* @__PURE__ */ new Map();
  }
  get selector() {
    return this._selector;
  }
  set(e) {
    Object.entries(e).forEach(([r, n]) => {
      this._declarations.set(r, n);
    });
  }
  toString() {
    return `${this._selector} {
${this._declarations.entries().map(([e, r]) => `  ${e}: ${typeof r == "function" ? r() : r.toString()};`).toArray().join(`
`)}
}`;
  }
}
class Z_e {
  constructor(e) {
    this._stylesheet = e, this._rules = /* @__PURE__ */ new Map(), this.log = qt("StyleManager");
  }
  set(e, r) {
    let n = this._rules.get(e);
    n || (n = new Y_e(e), this._rules.set(e, n)), n.set(r);
  }
  update() {
    this._rules.values().map((r) => {
      const n = r.selector.split(" "), i = new RegExp(["^", ...n, "\\{"].join("\\s*"));
      return Array.from(this._stylesheet.cssRules).findIndex((s) => s.cssText.match(i));
    }).filter((r) => r !== -1).toArray().sort().reverse().forEach((r) => {
      this.log.info("DEL", r), this._stylesheet.deleteRule(r);
    }), this._rules.values().forEach((r) => {
      this.log.info("INS", r), this._stylesheet.insertRule(r.toString());
    });
  }
}
class Ip {
  constructor(e) {
    const r = e.store, n = () => e.documentView.chartInfo, i = () => e.documentView.chartLayers.dataLayer;
    this._commands = {
      key(s) {
        return r.keymapManager.onKeydown(s);
      },
      click(s, o, a = !1) {
        const l = i().datapointView(s, o);
        return l ? (n().navMap.goTo(n().navDatapointType, {
          seriesKey: l.seriesKey,
          index: l.index
        }), n().selectCurrent(a), !0) : !1;
      }
    };
  }
  static getInst(e) {
    return Ip._inst || (Ip._inst = new Ip(e)), Ip._inst;
  }
  get commands() {
    return this._commands;
  }
}
class J_e {
  constructor(e) {
    this._paraChart = e;
    const r = e.store, n = e.paraView;
    this._allSeries = r.model.seriesKeys.map((a) => new X_e(a, this));
    const i = () => e.paraView.documentView.chartInfo, s = this;
    this._standardActions = {
      move(a) {
        i().clearPlay(), i().move(a.direction);
      },
      goFirst() {
        i().navFirst();
      },
      goLast() {
        i().navLast();
      },
      goMinimum() {
        i().goSeriesMinMax(!0);
      },
      goMaximum() {
        i().goSeriesMinMax(!1);
      },
      goTotalMinimum() {
        i().goChartMinMax(!0);
      },
      goTotalMaximum() {
        i().goChartMinMax(!1);
      },
      select() {
        i().selectCurrent(!1);
      },
      extendSelection() {
        i().selectCurrent(!0);
      },
      clearSelection() {
        i().clearDatapointSelection();
      },
      playRight() {
        i().playDir("right");
      },
      playLeft() {
        i().playDir("left");
      },
      stopPlay() {
        i().clearPlay();
      },
      queryData() {
        i().queryData();
      },
      toggleSonificationMode() {
        r.updateSettings((a) => {
          a.sonification.isSoniEnabled = !a.sonification.isSoniEnabled;
          const l = a.sonification.isSoniEnabled ? "enable" : "disable";
          r.announce(`Sonification ${l + "d"}`), e.postNotice(l + "Sonification", null);
        });
      },
      toggleTrendNavigationMode() {
        r.updateSettings((a) => {
          a.type.line.isTrendNavigationModeEnabled = !a.type.line.isTrendNavigationModeEnabled;
          const l = a.type.line.isTrendNavigationModeEnabled ? "enable" : "disable";
          r.announce(`Trend navigation ${l + "d"}`), e.postNotice(l + "TrendNavigation", null);
        });
      },
      toggleAnnouncementMode() {
        r.settings.ui.isAnnouncementEnabled ? (r.announce("Announcements disabled"), r.updateSettings((a) => {
          a.ui.isAnnouncementEnabled = !1;
        }), e.postNotice("disableAnnouncements", null)) : (r.updateSettings((a) => {
          a.ui.isAnnouncementEnabled = !0;
        }), r.announce("Announcements enabled"), e.postNotice("enableAnnouncements", null));
      },
      toggleVoicingMode() {
        r.updateSettings((a) => {
          a.ui.isVoicingEnabled = !a.ui.isVoicingEnabled;
          const l = a.ui.isVoicingEnabled ? "enable" : "disable";
          e.postNotice(l + "Voicing", null);
        });
      },
      toggleDarkMode() {
        r.updateSettings((a) => {
          a.color.isDarkModeEnabled = !a.color.isDarkModeEnabled;
          const l = a.color.isDarkModeEnabled ? "enable" : "disable";
          e.postNotice(l + "DarkMode", null), r.announce(`Dark mode ${l + "d"}`);
        });
      },
      toggleLowVisionMode() {
        r.updateSettings((a) => {
          a.ui.isLowVisionModeEnabled ? (a.ui.isFullscreenEnabled = !1, e.postNotice("disableLowVisionMode", null)) : (a.ui.isLowVisionModeEnabled = !0, e.postNotice("enableLowVisionMode", null));
        });
      },
      openHelp() {
        e.controlPanel.showHelpDialog();
      },
      announceVersionInfo() {
        r.announce(`Version ${__APP_VERSION__}; commit ${__COMMIT_HASH__}`);
      },
      jumpToChordLanding() {
        i().navToChordLanding();
      },
      shutUp() {
        e.ariaLiveRegion.voicing.shutUp();
      },
      repeatLastAnnouncement() {
        e.ariaLiveRegion.replay();
      },
      addAnnotation() {
        r.addAnnotation();
      },
      toggleNarrativeHighlightMode() {
        n.startNarrativeHighlightMode(), s._actions = s._narrativeActions, r.updateSettings((a) => {
          a.ui.isNarrativeHighlightEnabled = !0;
          //!draft.ui.isNarrativeHighlightEnabled;
          e.postNotice("enableNarrativeHighlightMode", null);
        });
      },
      playPauseMedia() {
      },
      reset() {
        r.clearSelected(), i().navMap.root.goTo("top", {}), n.createDocumentView();
      }
    }, this._actions = this._standardActions, this._narrativeActions = Object.create(this._actions);
    const o = n.paraChart.ariaLiveRegion.voicing;
    this._narrativeActions.move = async (a) => {
      r.paraChart.captionBox.highlightSpan(a.direction === "right" || a.direction === "down");
    }, this._narrativeActions.goFirst = () => {
    }, this._narrativeActions.goLast = () => {
    }, this._narrativeActions.repeatLastAnnouncement = () => {
    }, this._narrativeActions.toggleNarrativeHighlightMode = () => {
      e.captionBox.clearSpanHighlights(), r.clearHighlight(), r.clearAllSeriesLowlights(), n.endNarrativeHighlightMode(), s._actions = this._standardActions, r.settings.ui.isNarrativeHighlightEnabled ? r.updateSettings((a) => {
        a.ui.isNarrativeHighlightEnabled = !1;
      }) : r.updateSettings((a) => {
        a.ui.isNarrativeHighlightEnabled = !0;
      });
    }, this._narrativeActions.playPauseMedia = () => {
      o.togglePaused();
    };
  }
  get paraChart() {
    return this._paraChart;
  }
  get chartInfo() {
    return this._paraChart.paraView.documentView.chartInfo;
  }
  get allSeries() {
    return this._allSeries;
  }
  get actions() {
    return this._actions;
  }
  doAction(e, r) {
    this._actions[e](r);
  }
  getSeries(e) {
    return this.getAllSeries(e)[0];
  }
  getAllSeries(...e) {
    const r = Array.from(new Set(e)), n = [];
    for (const i of r) {
      const s = this._allSeries.find((o) => o.key === i);
      if (!s) throw new Error(`no series with key '${i}'`);
      n.push(s);
    }
    return n;
  }
  // sendKey(keyId: string) {
  //   this._paraChart.command('key', [keyId]);
  // }
  serializeChart() {
    return this._paraChart.paraView.serialize();
  }
  downloadSVG() {
    this._paraChart.paraView.downloadSVG();
  }
  downloadPNG() {
    this._paraChart.paraView.downloadPNG();
  }
  setSetting(e, r) {
    this._paraChart.store.updateSettings((n) => {
      vr.set(e, r, n);
    });
  }
  clearAllSeriesLowlights() {
    this._paraChart.store.clearAllSeriesLowlights();
  }
  enableNarrativeActions() {
    this._actions = this._narrativeActions;
  }
  enableStandardActions() {
    this._actions = this._standardActions;
  }
}
class X_e {
  constructor(e, r) {
    this._key = e, this._api = r, this._datapoints = [...r.paraChart.store.model.atKey(e).datapoints], this._allPoints = this._datapoints.map((n) => new eCe(n, this));
  }
  get key() {
    return this._key;
  }
  get api() {
    return this._api;
  }
  get allPoints() {
    return this._allPoints;
  }
  getPoint(e) {
    return this.getPoints(e)[0];
  }
  getPoints(...e) {
    const r = Array.from(new Set(e)), n = [];
    for (const i of r) {
      const s = this._allPoints[i];
      if (!s) throw new Error(`invalid index '${i}'`);
      n.push(s);
    }
    return n;
  }
  lowlight() {
    this._api.paraChart.store.lowlightSeries(this._key);
  }
  clearLowlight() {
    this._api.paraChart.store.clearSeriesLowlight(this._key);
  }
  isLowlighted() {
    return this._api.paraChart.store.isSeriesLowlighted(this._key);
  }
  lowlightOthers() {
    this._api.paraChart.store.lowlightOtherSeries(this._key);
  }
  playRiff() {
    this._api.chartInfo.playRiff(this._datapoints);
  }
}
class eCe {
  constructor(e, r) {
    this._datapoint = e, this._apiSeries = r;
  }
  visit() {
    this._apiSeries.api.chartInfo.navMap.goTo(this._apiSeries.api.chartInfo.navDatapointType, {
      seriesKey: this._datapoint.seriesKey,
      index: this._datapoint.datapointIndex
    });
  }
  select(e = !1) {
    this.visit(), this._apiSeries.api.chartInfo.selectCurrent(e);
  }
  highlight() {
  }
  clearHighlight() {
  }
  play() {
    this._apiSeries.api.chartInfo.playDatapoints([this._datapoint]);
  }
  annotate(e) {
    this._apiSeries.api.paraChart.store.annotatePoint(
      this._apiSeries.key,
      this._datapoint.datapointIndex,
      e
    );
  }
}
class tCe {
  constructor(e) {
    this.log = qt("Scrollyteller"), this.parachart = e, this.chartId = this.parachart.id, this._events = /* @__PURE__ */ new Map(), this.steps = [], this.globalOffset = { format: "percent", value: 0.5 }, this.containerElement = void 0, this.rootElement = null, this.progressThreshold = 0, this.isEnabled = !1, this.isProgress = !1, this.isTriggerOnce = !1, this.exclude = [], this.currentScrollY = 0, this.comparisonScrollY = 0, this.direction = void 0, this._handleScroll = this._handleScroll.bind(this), this._resizeStep = this._resizeStep.bind(this), this._intersectStep = this._intersectStep.bind(this), this._intersectProgress = this._intersectProgress.bind(this), this.settings = this.parachart.paraView.store.settings.scrollytelling, this.settings.isScrollytellingEnabled && this.init();
  }
  init() {
    var e;
    this.stepElements = document.querySelectorAll("[data-para-step]"), this.setup({
      step: "[data-para-step]",
      offset: 0.5,
      progress: !0,
      once: !1
    }), this.on("stepEnter", (r) => {
      const n = r.element;
      this.highlightPageContent(n);
      for (const { action: i, params: s } of r.actions) {
        if (i === "highlightSeries" && s.length > 0 && this.parachart.store.lowlightOtherSeries(...s), i === "highlightDatapoint" && s.length >= 2 && this.parachart.api.getSeries(s[0]).getPoint(+s[1]).select(), i === "directLabels") {
          console.warn("directLabels", s);
          const o = s[0] === "true";
          this.parachart.api.setSetting("chart.hasDirectLabels", o);
        }
        if (i === "hasSymbols") {
          console.warn("hasSymbols", s);
          const o = s[0] === "true";
          this.parachart.api.setSetting("chart.isDrawSymbols", o);
        }
        i === "setColorPalette" && (console.warn("setColorPalette", s), this.parachart.api.setSetting("color.colorPalette", s[0])), i === "setManifest" && (console.warn("manifest", s), console.warn("this.parachart", this.parachart), this.parachart.setAttribute("manifest", s[0])), i === "playSonification" && this.parachart.api.getSeries(s[0]).playRiff();
      }
    }), this.on("stepExit", (r) => {
      if (r.element, r.direction === "down")
        this.log.warn("SCROLLY: exit down", r);
      else {
        this.log.warn("SCROLLY: exit up", r), this.log.warn("SCROLLY: reverse action!");
        for (const { action: n, params: i } of r.actions)
          n === "highlightDatapoint" && i.length >= 2 && this.parachart.api.getSeries(i[0]).getPoint(+i[1]).select();
      }
    }), (e = this.stepElements[0]) == null || e.classList.add("para-active");
  }
  highlightPageContent(e) {
    this.stepElements.forEach((r) => r.classList.remove("para-active")), e.classList.add("para-active");
  }
  // internal helpers
  getChartSteps(e, r = document) {
    return this.selectAll(e, r).filter((i) => {
      const s = i.dataset.paraChartid;
      return !s || s === this.chartId;
    });
  }
  selectAll(e, r = document) {
    return typeof e == "string" ? Array.from(r.querySelectorAll(e)) : e instanceof Element ? [e] : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [];
  }
  getIndex(e) {
    const r = e.getAttribute("data-scrollytelling-index");
    return r ? +r : 0;
  }
  indexSteps(e) {
    e.forEach(
      (r) => r.node.setAttribute("data-scrollytelling-index", r.index.toString())
    );
  }
  getOffsetTop(e) {
    const { top: r } = e.getBoundingClientRect(), n = window.pageYOffset, i = document.body.clientTop || 0;
    return r + n - i;
  }
  parseOffset(e) {
    if (typeof e == "string" && e.indexOf("px") > 0) {
      const r = +e.replace("px", "");
      return isNaN(r) ? (this.err('offset value must be in "px" format. Fallback to 0.5.'), { format: "percent", value: 0.5 }) : { format: "pixels", value: r };
    } else if (typeof e == "number" || e != null && !isNaN(+e)) {
      const r = typeof e == "number" ? e : +e;
      return r > 1 && this.err("offset value is greater than 1. Fallback to 1."), r < 0 && this.err("offset value is lower than 0. Fallback to 0."), { format: "percent", value: Math.min(Math.max(0, r), 1) };
    }
    return { format: "percent", value: 0.5 };
  }
  getActions(e) {
    let r = [];
    const n = this.parseActions(e.dataset.paraAction);
    r.push(...n);
    const i = e.querySelectorAll("[data-para-action]");
    return Array.from(i).filter((o) => {
      const a = o.dataset.paraChartid;
      return !a || a === this.chartId;
    }).forEach((o) => {
      const a = this.parseActions(o.dataset.paraAction);
      r.push(...a);
    }), r;
  }
  parseActions(e) {
    if (!e) return [];
    const r = [];
    return e.split(")").forEach((i) => {
      if (i = i.trim(), i) {
        const s = i.split("("), o = s[0].trim(), a = s[1] ? s[1].trim() : "", l = a ? a.split(",").map((c) => c.trim()) : [];
        r.push({
          action: o,
          params: l
        });
      }
    }), r;
  }
  err(e) {
    this.log.error(`scrollytelling: ${e}`);
  }
  createProgressThreshold(e, r) {
    const n = Math.ceil(e / r), i = [], s = 1 / n;
    for (let o = 0; o < n + 1; o += 1) i.push(o * s);
    return i;
  }
  _resetExclusions() {
    this.exclude = [];
  }
  on(e, r) {
    return this._events.has(e) || this._events.set(e, []), this._events.get(e).push(r), this;
  }
  once(e, r) {
    const n = (i) => {
      r(i), this.off(e, n);
    };
    return this.on(e, n);
  }
  off(e, r) {
    if (!e)
      this._events.clear();
    else if (!r)
      this._events.delete(e);
    else {
      const n = this._events.get(e);
      if (n) {
        const i = n.indexOf(r);
        i > -1 && n.splice(i, 1);
      }
    }
    return this;
  }
  emit(e, r) {
    const n = this._events.get(e);
    n && n.forEach((i) => i(r));
  }
  _disconnectObserver(e) {
    Object.keys(e).forEach((r) => e[r].disconnect());
  }
  _disconnectObservers() {
    this.steps.forEach((e) => this._disconnectObserver(e.observers));
  }
  _handleEnable(e) {
    e && !this.isEnabled && this._updateObservers(), !e && this.isEnabled && this._disconnectObservers(), this.isEnabled = e;
  }
  _notifyProgress(e, r) {
    const n = this.getIndex(e), i = this.steps[n];
    r !== void 0 && (i.progress = r);
    const s = { element: e, index: n, progress: r, direction: this.direction, actions: i.actions };
    i.state === "enter" && this.emit("stepProgress", s);
  }
  _notifyStepEnter(e) {
    const r = this.getIndex(e), n = this.steps[r], i = { element: e, index: r, direction: this.direction, actions: n.actions };
    n.direction = this.direction, n.state = "enter", this.exclude[r] || this.emit("stepEnter", i), this.isTriggerOnce && (this.exclude[r] = !0);
  }
  _notifyStepExit(e) {
    const r = this.getIndex(e), n = this.steps[r];
    if (!n.state) return !1;
    const i = { element: e, index: r, direction: this.direction, actions: n.actions };
    return this.isProgress && (this.direction === "down" && n.progress < 1 ? this._notifyProgress(e, 1) : this.direction === "up" && n.progress > 0 && this._notifyProgress(e, 0)), n.direction = this.direction, n.state = "exit", this.emit("stepExit", i), !0;
  }
  _handleScroll() {
    const e = this.containerElement ? this.containerElement.scrollTop : window.pageYOffset;
    this.currentScrollY !== e && (this.currentScrollY = e, this.currentScrollY > this.comparisonScrollY ? this.direction = "down" : this.currentScrollY < this.comparisonScrollY && (this.direction = "up"), this.comparisonScrollY = this.currentScrollY);
  }
  _setupScrollListener() {
    document.removeEventListener("scroll", this._handleScroll), document.addEventListener("scroll", this._handleScroll, { passive: !0 });
  }
  _resizeStep(e) {
    if (e.length === 0) return;
    const r = e[0], n = this.getIndex(r.target), i = this.steps[n], s = r.target.offsetHeight;
    s !== i.height && (i.height = s, this._disconnectObserver(i.observers), this._updateResizeObserver(i), this._updateStepObserver(i), this.isProgress && this._updateProgressObserver(i));
  }
  _intersectStep(e) {
    if (e.length === 0) return;
    const r = e[0];
    this._handleScroll();
    const { isIntersecting: n, target: i } = r;
    n ? this._notifyStepEnter(i) : this._notifyStepExit(i);
  }
  _intersectProgress(e) {
    if (e.length === 0) return;
    const r = e[0], n = this.getIndex(r.target), i = this.steps[n], { isIntersecting: s, intersectionRatio: o, target: a } = r;
    s && i.state === "enter" && this._notifyProgress(a, o);
  }
  _updateResizeObserver(e) {
    const r = new ResizeObserver(this._resizeStep);
    r.observe(e.node), e.observers.resize = r;
  }
  _updateResizeObservers() {
    this.steps.forEach((e) => this._updateResizeObserver(e));
  }
  _updateStepObserver(e) {
    const r = window.innerHeight, n = e.offset || this.globalOffset, i = n.format === "pixels" ? 1 : r, s = n.value * i, o = e.height / 2 - s, a = e.height / 2 - (r - s), l = `${o}px 0px ${a}px 0px`, c = this.rootElement, h = { rootMargin: l, threshold: 0.5, root: c }, d = new IntersectionObserver(this._intersectStep, h);
    d.observe(e.node), e.observers.step = d;
  }
  _updateStepObservers() {
    this.steps.forEach((e) => this._updateStepObserver(e));
  }
  _updateProgressObserver(e) {
    const r = window.innerHeight, n = e.offset || this.globalOffset, i = n.format === "pixels" ? 1 : r, s = n.value * i, o = -s + e.height, a = s - r, l = `${o}px 0px ${a}px 0px`, c = this.createProgressThreshold(e.height, this.progressThreshold), p = { rootMargin: l, threshold: c }, h = new IntersectionObserver(this._intersectProgress, p);
    h.observe(e.node), e.observers.progress = h;
  }
  _updateProgressObservers() {
    this.steps.forEach((e) => this._updateProgressObserver(e));
  }
  _updateObservers() {
    this._disconnectObservers(), this._updateResizeObservers(), this._updateStepObservers(), this.isProgress && this._updateProgressObservers();
  }
  setup({
    step: e,
    parent: r,
    offset: n = 0.5,
    threshold: i = 4,
    progress: s = !1,
    once: o = !1,
    container: a = void 0,
    root: l = null
  }) {
    this._setupScrollListener();
    const c = typeof e == "string" && r && document.querySelector(r) || document;
    return this.steps = this.getChartSteps(e, c).map((p, h) => ({
      index: h,
      direction: void 0,
      height: p.offsetHeight,
      node: p,
      observers: {},
      offset: this.parseOffset(p.dataset.offset),
      actions: this.getActions(p),
      top: this.getOffsetTop(p),
      progress: 0,
      state: void 0
    })), this.steps.length ? (this.isProgress = s, this.isTriggerOnce = o, this.progressThreshold = Math.max(1, +i), this.globalOffset = this.parseOffset(n), this.containerElement = a, this.rootElement = l, this.off(), this._resetExclusions(), this.indexSteps(this.steps), this._handleEnable(!0), this) : (this.log.info("scrollytelling: no step elements found"), this);
  }
  enable() {
    return this._handleEnable(!0), this;
  }
  disable() {
    return this._handleEnable(!1), this;
  }
  destroy() {
    return this._handleEnable(!1), this.off(), this._resetExclusions(), document.removeEventListener("scroll", this._handleScroll), this;
  }
  resize() {
    return this._updateObservers(), this;
  }
  get offset() {
    return this.globalOffset.value;
  }
  set offset(e) {
    this.globalOffset = this.parseOffset(e), this._updateObservers();
  }
}
class rCe {
  constructor() {
    this.log = qt("SlotLoader");
  }
  canLoadData(e) {
    return e.length !== 0 && e[0].tagName === "TABLE";
  }
  async findManifest(e, r, n) {
    if (r && (this.log.info(`Loading from manifest ID: ${r}`), document.getElementById(r)))
      if (document.getElementById(r).hasAttribute("src")) {
        const s = await (await fetch(document.getElementById(r).getAttribute("src"))).json();
        return n && (s.datasets[0].description = n, this.log.info("manifest description changed")), { result: "success", manifest: s };
      } else {
        let i = JSON.parse(document.getElementById(r).innerHTML);
        return { result: "success", manifest: this.validateManifest(e, i, n).manifest };
      }
    if (document.getElementsByClassName("manifest").length > 0) {
      let i = JSON.parse(document.getElementsByClassName("manifest")[0].innerHTML);
      return { result: "success", manifest: this.validateManifest(e, i, n).manifest };
    } else {
      this.log.info("Manifest ID not found or not present, attempting manifest construction from data");
      let i = {
        datasets: [{
          type: "",
          //chartTheme: {baseQuantity: 'Y unit', baseKind: 'number'}, 
          title: "",
          facets: {},
          series: [],
          data: { source: "inline" }
        }]
      };
      return { result: "success", manifest: this.validateManifest(e, i, n).manifest };
    }
  }
  validateManifest(e, r, n) {
    document.getElementsByTagName("para-chart")[0];
    const i = e[0], s = r.datasets[0];
    s.title || (s.title = this.findManifestTitle(i)), (!s.facets || !s.facets.keys) && (s.facets = this.loadFacets(i.rows[0]));
    const o = this.loadHeaders(i.rows[0]);
    if (!s.series || s.series.length === 0) {
      s.series = [];
      for (let l = 1; l < o.length; l++) {
        const c = {
          key: o[l].label,
          /*theme: { 
            baseQuantity: '',
            baseKind: 'number',
            entity: vars[i].label 
          },*/
          records: this.loadDataFromElement(e, r, o[l].label)
        };
        s.series.push(c);
      }
    }
    for (let l = 1; l < o.length; l++)
      r.datasets[0].series[0].records.length === 0 && (s.series[l].records = this.loadDataFromElement(e, r, o[l].label));
    s.type || (s.type = this.findManifestType(e, r)), s.data || (s.data = { source: "inline" }), s.settings || (s.settings = { "sonification.isEnabled": !0 });
    const a = o.map((l) => []);
    Array.from(i.rows).slice(1).forEach((l) => {
      this.loadRow(l, o).forEach((p, h) => {
        a[h].push(p);
      });
    });
    for (let l = 0; l < 2; l++) {
      let c = s.facets[Object.keys(s.facets)[l]];
      /%/.test(a[l][0]) && (c.measure = "ratio"), /\b(year|month|day)\b/i.test(o[l].label) ? c.datatype = "date" : isNaN(Number(a[l][0].replace("%", ""))) ? c.datatype = "string" : c.datatype = "number";
    }
    return n && (r.datasets[0].description = n, this.log.info("manifest description changed")), { result: "success", manifest: r };
  }
  loadDataFromElement(e, r, n) {
    if (!e.length || e[0].tagName !== "TABLE")
      throw this.log.info(e), new Error("'table' element must be provided");
    const i = e[0];
    let s = this.loadHeaders(i.rows[0]), o;
    n && (o = s.filter((p) => p.label == n)[0]);
    let a = s.indexOf(o);
    a == -1 && (a = 1);
    const l = s.map((p) => []);
    Array.from(i.rows).slice(1).forEach((p) => {
      this.loadRow(p, s).forEach((d, v) => {
        l[v].push(d);
      });
    });
    let c = [];
    for (let p = 0; p < l[0].length; p++)
      c.push({ x: l[0][p], y: l[a][p] });
    return c;
  }
  loadHeaders(e) {
    var s;
    const r = document.getElementsByTagName("para-chart")[0];
    if (!e)
      throw new Error("table must include a header row");
    const n = [];
    let i = 0;
    for (const o of e.children) {
      if (o.tagName !== "TD" && o.tagName !== "TH")
        throw new Error("immediate children of 'tr' element must be 'td' or 'th' elements");
      const a = ((s = o.textContent) == null ? void 0 : s.trim()) ?? "";
      if (!a)
        throw new Error("var name must be provided as 'td' element text content");
      let l = o.dataset.type ?? "string";
      if (!["string", "number", "date"].includes(l))
        throw new Error("var type must be provided as 'td' element 'data-type' attribute. Must be string, number, or date");
      const c = o.dataset.independent === "true" ? "independent" : "dependent";
      let p = o.dataset.measure ?? "nominal";
      const h = r.type == "pie" || r.type == "donut", d = ["horizontal", "vertical"];
      let v;
      h ? v = o.dataset.displayType ?? { type: "marking" } : v = o.dataset.displayType ?? { type: "axis", orientation: d[i] }, n.push({
        label: a,
        datatype: l,
        variableType: c,
        measure: p,
        displayType: v
      }), i++;
    }
    return n;
  }
  loadFacets(e) {
    let r = this.loadHeaders(e);
    if (r.length < 2)
      throw new Error("Error: please provide at least two variables");
    if (r.length === 2) {
      let o = { x: r[0], y: r[1] };
      return o.x.variableType = "independent", ["Year", "year", "Years", "years"].includes(o.x.label) ? o.x.units = "year" : o.x.units || (o.x.units = "point"), o;
    }
    let n;
    for (let o of r)
      if (o.variableType == "independent") {
        n = o;
        break;
      }
    n === void 0 && (n = r[0]);
    let i = "";
    for (let o of r.toSpliced(r.indexOf(n), 1)) {
      if (i.concat(o.label, " ").length > 50) {
        i = i.concat("...");
        break;
      }
      i = i.concat(o.label, ", ");
    }
    let s = { x: r[0], y: r[1] };
    return s.x.variableType = "independent", s.y.label = i, ["Year", "year", "Years", "years"].includes(s.x.label) ? s.x.units = "year" : s.x.units || (s.x.units = "point"), s;
  }
  loadRow(e, r) {
    if (!e || e.tagName !== "TR")
      throw new Error("immediate children of 'table' element must be 'tr' elements");
    const n = r.map((i) => "");
    return Array.from(e.children).forEach((i, s) => {
      if (i.tagName !== "TD")
        throw new Error("immediate children of 'tr' element must be 'td' elements");
      const o = i.textContent;
      if (!o)
        throw new Error("var value must be provided as 'td' element text content");
      n[s] = o;
    }), n;
  }
  findManifestTitle(e) {
    for (const r of e.children)
      if (r.nodeName === "CAPTION")
        return r.innerHTML;
    return e.hasAttribute("aria-label") ? e.getAttribute("aria-label") : e.hasAttribute("title") ? e.getAttribute("title") : `'${this.loadHeaders(e.rows[0])[0].label}' vs '${this.loadHeaders(e.rows[0])[1].label}'`;
  }
  findManifestType(e, r) {
    if (document.getElementsByTagName("para-chart")[0].hasAttribute("type"))
      return document.getElementsByTagName("para-chart")[0].getAttribute("type");
    throw new Error("Error: please provide a type for the para-chart");
  }
}
var nCe = Object.defineProperty, iCe = Object.getOwnPropertyDescriptor, qV = (t) => {
  throw TypeError(t);
}, ca = (t, e, r, n) => {
  for (var i = n > 1 ? void 0 : n ? iCe(e, r) : e, s = t.length - 1, o; s >= 0; s--)
    (o = t[s]) && (i = (n ? o(e, r, i) : o(i)) || i);
  return n && i && nCe(e, r, i), i;
}, QV = (t, e, r) => e.has(t) || qV("Cannot " + r), l1 = (t, e, r) => (QV(t, e, "read from private field"), r ? r.call(t) : e.get(t)), c1 = (t, e, r) => e.has(t) ? qV("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), u1 = (t, e, r, n) => (QV(t, e, "write to private field"), e.set(t, r), r), K1, Y1, Z1, J1;
const Hk = class Hk extends ts {
  constructor(e, r) {
    super(), this.headless = !1, c1(this, K1, ""), this.manifestType = "url", this.data = "", c1(this, Y1, {}), c1(this, Z1), c1(this, J1), this.isControlPanelOpen = !1, this._paraViewRef = Et(), this._controlPanelRef = Et(), this._ariaLiveRegionRef = Et(), this._loader = new Q_e(), this._slotLoader = new rCe(), this.log = qt("ParaChart"), this._loaderPromise = null, this._loaderResolver = null, this._loaderRejector = null;
    const n = new K_e(), i = n.processProperties();
    this.store = new Cr(
      this,
      // XXX config won't get set until connectedCallback()
      Object.assign(i, this.config),
      this._suppleteSettingsWith,
      e,
      r
    ), this.captionBox = document.createElement("para-caption-box"), this.captionBox.store = this._store, this.captionBox.parachart = this, n.store = this.store, n.registerColors(), n.registerSymbols(), this._loaderPromise = new Promise((s, o) => {
      this._loaderResolver = s, this._loaderRejector = o;
    }), this._readyPromise = new Promise((s) => {
      this.addEventListener("paraviewready", async () => {
        if (s(), await J3e(), this.manifest)
          this.data && await this._loader.preloadData(this.data), this._runLoader(this.manifest, this.manifestType).then(() => {
            this.log.info("ParaCharts fully initialized"), this._scrollyteller = new tCe(this);
          });
        else if (this.getElementsByTagName("table")[0]) {
          this.log.info("loading from slot");
          const o = this.getElementsByTagName("table")[0], a = this.getElementsByClassName("manifest")[0];
          if (this._store.dataState = "pending", o) {
            const l = await this._slotLoader.findManifest(
              [o, a],
              "some-manifest",
              this.description
            );
            this.log.info("loaded manifest"), l.result === "success" ? (this.store.setManifest(l.manifest), this._store.dataState = "complete") : this._store.dataState = "error";
          }
        } else
          this.log.info("No datatable in slot"), this._store.dataState = "error";
      });
    });
  }
  get manifest() {
    return l1(this, K1);
  }
  set manifest(e) {
    u1(this, K1, e);
  }
  get config() {
    return l1(this, Y1);
  }
  set config(e) {
    u1(this, Y1, e);
  }
  get forcecharttype() {
    return l1(this, Z1);
  }
  set forcecharttype(e) {
    u1(this, Z1, e);
  }
  get description() {
    return l1(this, J1);
  }
  set description(e) {
    u1(this, J1, e);
  }
  get paraView() {
    return this._paraViewRef.value;
  }
  get controlPanel() {
    return this._controlPanelRef.value;
  }
  get ready() {
    return this._readyPromise;
  }
  get loaded() {
    return this._loaderPromise;
  }
  get loader() {
    return this._loader;
  }
  get ariaLiveRegion() {
    return this._ariaLiveRegionRef.value;
  }
  get slotted() {
    return this._slotted;
  }
  get styleManager() {
    return this._styleManager;
  }
  get api() {
    return this._paraAPI;
  }
  get scrollyteller() {
    return this._scrollyteller;
  }
  connectedCallback() {
    super.connectedCallback(), this.isControlPanelOpen = this._store.settings.controlPanel.isControlPanelDefaultOpen, this._styleManager = new Z_e(this.shadowRoot.adoptedStyleSheets[0]), this._styleManager.set(":host", {
      "--axis-line-color": "hsl(0, 0%, 0%)",
      "--label-color": "hsl(0, 0%, 0%)",
      "--tick-grid-color": "hsl(270, 50%, 50%)",
      "--background-color": "white",
      "--theme-color": "var(--fizz-theme-color, purple)",
      "--theme-color-light": "var(--fizz-theme-color-light, hsl(275.4, 100%, 88%))",
      "--theme-contrast-color": "white",
      "--fizz-theme-color": "var(--paracharts-theme-color, navy)",
      "--fizz-theme-color-light": "var(--paracharts-theme-color-light, hsl(210.5, 100%, 88%))",
      "--visited-color": () => this._store.colors.colorValue("visit"),
      "--highlighted-color": () => this._store.colors.colorValue("highlight"),
      "--visited-stroke-width": () => {
        var e, r;
        return ((r = (e = this._paraViewRef.value) == null ? void 0 : e.documentView) == null ? void 0 : r.chartLayers.dataLayer.visitedStrokeWidth) ?? 0;
      },
      "--selected-color": "var(--label-color)",
      "--datapoint-centroid": "50% 50%",
      "--focus-animation": "all 0.5s ease-in-out",
      "--chart-cursor": "pointer",
      "--data-cursor": "cell",
      "--focus-shadow-color": "gray",
      "--focus-shadow": "drop-shadow(0px 0px 4px var(--focus-shadow-color))",
      "--caption-border": () => this._store.settings.controlPanel.caption.hasBorder ? "solid 2px var(--theme-color)" : "none",
      "--caption-grid-template-columns": () => this._store.settings.controlPanel.isExplorationBarVisible && this._store.settings.controlPanel.isCaptionVisible && this._store.settings.controlPanel.caption.isExplorationBarBeside ? "2fr 1fr" : "1fr",
      "--exploration-bar-display": () => this._store.settings.controlPanel.isExplorationBarVisible ? "flex" : "none",
      "--chart-font-scale": () => this._store.settings.chart.fontScale,
      "--chart-title-font-size": () => this._store.settings.chart.title.fontSize,
      "--horiz-axis-title-font-size": () => this._store.settings.axis.horiz.title.fontSize,
      "--vert-axis-title-font-size": () => this._store.settings.axis.vert.title.fontSize,
      "--horiz-axis-tick-label-font-size": () => this._store.settings.axis.horiz.ticks.labels.fontSize,
      "--vert-axis-tick-label-font-size": () => this._store.settings.axis.vert.ticks.labels.fontSize,
      "--direct-label-font-size": () => this._store.settings.chart.directLabelFontSize,
      "--legend-label-font-size": () => this._store.settings.legend.fontSize,
      "--bar-label-font-size": () => this._store.settings.type.bar.labelFontSize,
      "--column-label-font-size": () => this._store.settings.type.column.labelFontSize,
      display: "block",
      "font-family": '"Trebuchet MS", Helvetica, sans-serif',
      "font-size": "var(--chart-view-font-size, 1rem)"
    }), this._store.settings.chart.isShowVisitedDatapointsOnly && (this._styleManager.set(".datapoint:not(.visited)", {
      display: "none"
    }), this._styleManager.set(".leg-right", {
      display: "none"
    })), this._styleManager.update();
  }
  firstUpdated(e) {
    this._commander = Ip.getInst(this._paraViewRef.value);
  }
  willUpdate(e) {
    e.has("manifest") && this.manifest !== "" && this._paraViewRef.value && (this.log.info(`manifest changed: '${this.manifestType === "content" ? "<content>" : this.manifest}`), this._loaderPromise = this._runLoader(this.manifest, this.manifestType), this.dispatchEvent(new CustomEvent("manifestchange", { bubbles: !0, composed: !0, cancelable: !0 }))), e.has("config") && Object.entries(this.config).forEach(([r, n]) => this._store.updateSettings((i) => {
      vr.set(r, n, i);
    }));
  }
  async _runLoader(e, r) {
    var i;
    this.log.info(`loading manifest: '${r === "content" ? "<content>" : e}'`), this._store.dataState = "pending";
    const n = await this._loader.load(
      this.manifestType,
      e,
      this.forcecharttype,
      this.description
    );
    this.log.info("loaded manifest"), n.result === "success" ? (this._manifest = n.manifest, this._store.setManifest(n.manifest, n.data), this._store.dataState = "complete", (i = this._controlPanelRef.value) == null || i.descriptionPanel.positionCaptionBox(), this._paraAPI = new J_e(this), this._loaderResolver()) : (this.log.error(n.error), this._store.dataState = "error", this._loaderRejector());
  }
  settingDidChange(e, r, n) {
    var i;
    this.log.info("setting did change:", e, "=", n, `(was ${r})`), this._styleManager.update(), (i = this._paraViewRef.value) == null || i.settingDidChange(e, r, n), this._styleManager.update();
  }
  postNotice(e, r) {
    this.paraView.documentView.noticePosted(e, r), this.paraView.documentView.chartInfo.noticePosted(e, r), this.captionBox.noticePosted(e, r), this.dispatchEvent(
      new CustomEvent("paranotice", { detail: { key: e, value: r }, bubbles: !0, composed: !0 })
    );
  }
  clearAriaLive() {
    this._ariaLiveRegionRef.value.clear();
  }
  showAriaLiveHistory() {
    this._ariaLiveRegionRef.value.showHistoryDialog();
  }
  command(e, r) {
    const n = this._commander.commands[e];
    if (n)
      return n(...r);
    this.log.warn(`no handler for command '${e}'`);
  }
  render() {
    var r;
    const e = {
      "sr-only": this.headless
    };
    return We`
      <figure
        class=${Br(e)}
        aria-hidden=${this.headless ? "true" : "false"}
      >
        <para-view
          ${yt(this._paraViewRef)}
          .paraChart=${this}
          .store=${this._store}
          colormode=${((r = this._store) == null ? void 0 : r.settings.color.colorVisionMode) ?? Ne}
          ?disableFocus=${this.headless}
        ></para-view>
        ${this.headless || this._store.settings.chart.isStatic ? "" : We`
            <para-control-panel
              ${yt(this._controlPanelRef)}
              .paraChart=${this}
              .store=${this._store}
            ></para-control-panel>`}
        <para-aria-live-region
          ${yt(this._ariaLiveRegionRef)}
          .store=${this._store}
          .announcement=${this._store.announcement}
        ></para-aria-live-region>
        <slot
          @slotchange=${(n) => {
    }}
        ></slot>
      </figure>
    `;
  }
};
Hk.styles = [
  A5,
  Nt`
      :host {
        --summary-marker-size: 1.1rem;
      }
      figure {
        display: inline grid;
        margin: 0;
      }
    `
];
let Xi = Hk;
K1 = /* @__PURE__ */ new WeakMap();
Y1 = /* @__PURE__ */ new WeakMap();
Z1 = /* @__PURE__ */ new WeakMap();
J1 = /* @__PURE__ */ new WeakMap();
ca([
  Ke({ type: Boolean })
], Xi.prototype, "headless", 2);
ca([
  Ke()
], Xi.prototype, "manifest", 1);
ca([
  Ke()
], Xi.prototype, "manifestType", 2);
ca([
  Ke()
], Xi.prototype, "data", 2);
ca([
  Ke({ type: Object })
], Xi.prototype, "config", 1);
ca([
  Ke()
], Xi.prototype, "forcecharttype", 1);
ca([
  Ke()
], Xi.prototype, "type", 2);
ca([
  Ke()
], Xi.prototype, "description", 1);
ca([
  Ke({ type: Boolean, attribute: !1 })
], Xi.prototype, "isControlPanelOpen", 2);
ca([
  Ig({ flatten: !0 })
], Xi.prototype, "_slotted", 2);
const Gk = class Gk extends Xi {
  constructor() {
    super(TG, Uie), this.log = qt("ParaChartAi"), this.log.info("AI-enhanced ParaChart created");
  }
};
Gk.styles = [
  A5,
  Nt`
      :host {
      --control-panel-icon: url(${Zu(WV)});
        --summary-marker-size: 1.1rem;
      }
      figure {
        display: inline-block;
        margin: 0;
      }
    `
];
let bE = Gk;
class oPe {
  constructor() {
    this._createParaChart(), this._paraChart.store.updateSettings((e) => {
      e.animation.isAnimationEnabled = !1;
    });
  }
  get ready() {
    return this._paraChart.ready;
  }
  _createParaChart() {
    this._paraChart = document.createElement("para-chart"), this._paraChart.setAttribute("headless", ""), document.body.append(this._paraChart);
  }
  loadData(e) {
    return this._paraChart.loader.preloadData(e);
  }
  loadManifest(e, r = "url") {
    return this._paraChart.manifest = e, this._paraChart.manifestType = r, new Promise((n) => {
      this._paraChart.addEventListener("manifestchange", async () => {
        await this._paraChart.loaded, n();
      }, { once: !0 });
    });
  }
  get jimReady() {
    return this._paraChart.paraView.jimReady();
  }
  get api() {
    return this._paraChart.api;
  }
}
customElements.define("para-chart", bE);
export {
  R2 as AdvancedControlSettingsDialog,
  pE as AnalysisPanel,
  O2 as AnimationDialog,
  JR as AnnotationLayer,
  dE as AnnotationPanel,
  Cy as AriaLive,
  x0 as AriaLiveHistoryDialog,
  fE as AudioPanel,
  MV as Axis,
  Jb as AxisInfo,
  IV as AxisLine,
  RV as AxisRule,
  D9e as Bar,
  o1 as BarPlotView,
  SV as Bezier,
  fR as ButtonSettingControl,
  h8e as ChartLandingView,
  gE as ChartPanel,
  iPe as ChartTooDenseError,
  sPe as ChartTooWideError,
  hR as CheckboxSettingControl,
  V9e as ClusterShellView,
  ZU as Colors,
  mE as ColorsPanel,
  xn as ControlPanelTabPanel,
  yE as ControlsPanel,
  kV as DataLayer,
  D2 as DataPanel,
  JU as DataView,
  hf as DatapointView,
  ng as DescriptionPanel,
  uR as DropdownSettingControl,
  YSe as FORMAT_CONTEXT_SETTINGS,
  K9e as FocusLayer,
  K4 as HERTZ,
  H9e as HeatMapPlotView,
  G9e as HeatmapTile,
  rO as HeatmapTileView,
  iO as HighlightsLayer,
  W9e as Histogram,
  nO as HistogramBinView,
  u7e as HorizAxis,
  e7e as HorizAxisLine,
  o7e as HorizGridLine,
  OV as HorizRule,
  i7e as HorizTick,
  r7e as HorizTickLabelTier,
  l7e as HorizTickStrip,
  Z8e as HotkeyEvent,
  J8e as KeymapManager,
  cx as LinePlotView,
  $9e as LineSection,
  Vie as LogLevel,
  Hie as Logger,
  w2 as NavLayer,
  _k as NavMap,
  Ia as NavNode,
  vAe as OscillatorAudioEngine,
  bE as ParaChartAi,
  ts as ParaComponent,
  ig as ParaControlPanel,
  ch as ParaDialog,
  oPe as ParaHelper,
  Cr as ParaStore,
  Ji as ParaView,
  fAe as ParaViewController,
  j9e as PastryPlotView,
  jo as PathShape,
  eO as PiePlotView,
  F9e as PieSlice,
  _V as PlaneDatapointView,
  Xb as PlanePlotView,
  ew as PlaneSeriesView,
  pf as PlotLayer,
  X9e as PlotLayerManager,
  Lk as PointDatapointView,
  CV as PointPlotView,
  T9e as PointSeriesView,
  B9e as RadialSlice,
  pR as RadioSettingControl,
  nn as RectShape,
  Cp as SVGNS,
  z9e as ScatterPlotView,
  tO as ScatterTrendLineView,
  w0 as ScreenReaderBridge,
  tCe as Scrollyteller,
  C2 as SectorShape,
  q9e as SelectionLayer,
  w8e as SeriesProperties,
  lR as SeriesPropertyManager,
  Ak as SeriesView,
  Ks as SettingControl,
  YU as SettingControlManager,
  vr as SettingsManager,
  Qb as Shape,
  dR as SliderSettingControl,
  P2 as SoniSettingsDialog,
  cR as TextfieldSettingControl,
  PV as TickLabelTier,
  LV as TickStrip,
  L9e as TrendLineView,
  Ye as Vec2,
  h7e as VertAxis,
  t7e as VertAxisLine,
  a7e as VertGridLine,
  TV as VertRule,
  s7e as VertTick,
  n7e as VertTickLabelTier,
  c7e as VertTickStrip,
  Y4 as bboxOfBboxes,
  a8e as bboxOppositeAnchor,
  QIe as capitalize,
  J9e as chartClasses,
  aR as chartTypeDefaults,
  A2 as computeLabels,
  on as datapointIdToCursor,
  ZIe as datapointMatchKeyAndIndex,
  n8e as defaults,
  KSe as directions,
  KIe as exhaustive,
  nt as fixed,
  o8e as generateUniqueId,
  qt as getLogger,
  YIe as groupBbox,
  l8e as isPointerInbounds,
  XCe as setLogLevel,
  s8e as toFixed
};
